{"pageProps":{"data":{"count":1,"rows":[{"id":73,"title":"How do I write a correct micro-benchmark in Java?","slug":"how-do-i-write-a-correct-micro-benchmark-in-java-1657384488725","postType":"QUESTION","createdAt":"2022-07-09T16:34:48.000Z","updatedAt":"2022-07-09T16:34:48.000Z","tags":[{"id":265,"name":"jvm","slug":"jvm","createdAt":"2022-07-09T16:34:48.000Z","updatedAt":"2022-07-09T16:34:48.000Z","Questions_Tags":{"questionId":73,"tagId":265}}]}]},"slug":"jvm","page":1,"answers":{"73":["\n&lt;p&gt;Tips about writing micro benchmarks &lt;a href=&quot;https://wiki.openjdk.java.net/display/HotSpot/Main&quot; rel=&quot;noreferrer&quot;&gt;from the creators of Java HotSpot&lt;/a&gt;:&lt;/p&gt;\n\n&lt;p&gt;&lt;strong&gt;Rule 0:&lt;/strong&gt; Read a reputable paper on JVMs and micro-benchmarking. A good one is &lt;a href=&quot;http://www.ibm.com/developerworks/java/library/j-jtp02225&quot; rel=&quot;noreferrer&quot;&gt;Brian Goetz, 2005&lt;/a&gt;. Do not expect too much from micro-benchmarks; they measure only a limited range of JVM performance characteristics.&lt;/p&gt;\n\n&lt;p&gt;&lt;strong&gt;Rule 1:&lt;/strong&gt; Always include a warmup phase which runs your test kernel all the way through, enough to trigger all initializations and compilations before timing phase(s). (Fewer iterations is OK on the warmup phase. The rule of thumb is several tens of thousands of inner loop iterations.)&lt;/p&gt;\n\n&lt;p&gt;&lt;strong&gt;Rule 2:&lt;/strong&gt; Always run with &lt;code&gt;-XX:+PrintCompilation&lt;/code&gt;, &lt;code&gt;-verbose:gc&lt;/code&gt;, etc., so you can verify that the compiler and other parts of the JVM are not doing unexpected work during your timing phase.&lt;/p&gt;\n\n&lt;p&gt;&lt;strong&gt;Rule 2.1:&lt;/strong&gt; Print messages at the beginning and end of timing and warmup phases, so you can verify that there is no output from Rule 2 during the timing phase.&lt;/p&gt;\n\n&lt;p&gt;&lt;strong&gt;Rule 3:&lt;/strong&gt; Be aware of the difference between &lt;code&gt;-client&lt;/code&gt; and &lt;code&gt;-server&lt;/code&gt;, and OSR and regular compilations. The &lt;code&gt;-XX:+PrintCompilation&lt;/code&gt; flag reports OSR compilations with an at-sign to denote the non-initial entry point, for example: &lt;code&gt;Trouble$1::run @ 2 (41 bytes)&lt;/code&gt;. Prefer server to client, and regular to OSR, if you are after best performance.&lt;/p&gt;\n\n&lt;p&gt;&lt;strong&gt;Rule 4:&lt;/strong&gt; Be aware of initialization effects. Do not print for the first time during your timing phase, since printing loads and initializes classes. Do not load new classes outside of the warmup phase (or final reporting phase), unless you are testing class loading specifically (and in that case load only the test classes). Rule 2 is your first line of defense against such effects.&lt;/p&gt;\n\n&lt;p&gt;&lt;strong&gt;Rule 5:&lt;/strong&gt; Be aware of deoptimization and recompilation effects. Do not take any code path for the first time in the timing phase, because the compiler may junk and recompile the code, based on an earlier optimistic assumption that the path was not going to be used at all. Rule 2 is your first line of defense against such effects.&lt;/p&gt;\n\n&lt;p&gt;&lt;strong&gt;Rule 6:&lt;/strong&gt; Use appropriate tools to read the compiler&apos;s mind, and expect to be surprised by the code it produces. Inspect the code yourself before forming theories about what makes something faster or slower.&lt;/p&gt;\n\n&lt;p&gt;&lt;strong&gt;Rule 7:&lt;/strong&gt; Reduce noise in your measurements. Run your benchmark on a quiet machine, and run it several times, discarding outliers. Use &lt;code&gt;-Xbatch&lt;/code&gt; to serialize the compiler with the application, and consider setting &lt;code&gt;-XX:CICompilerCount=1&lt;/code&gt; to prevent the compiler from running in parallel with itself. Try your best to reduce GC overhead, set &lt;code&gt;Xmx&lt;/code&gt;(large enough) equals &lt;code&gt;Xms&lt;/code&gt; and use &lt;a href=&quot;http://openjdk.java.net/jeps/318&quot; rel=&quot;noreferrer&quot;&gt;&lt;code&gt;UseEpsilonGC&lt;/code&gt;&lt;/a&gt; if it is available.&lt;/p&gt;\n\n&lt;p&gt;&lt;strong&gt;Rule 8:&lt;/strong&gt; Use a library for your benchmark as it is probably more efficient and was already debugged for this sole purpose. Such as &lt;a href=&quot;http://openjdk.java.net/projects/code-tools/jmh/&quot; rel=&quot;noreferrer&quot;&gt;JMH&lt;/a&gt;, &lt;a href=&quot;https://github.com/google/caliper&quot; rel=&quot;noreferrer&quot;&gt;Caliper&lt;/a&gt; or &lt;a href=&quot;http://cseweb.ucsd.edu/users/wgg/JavaProf/javaprof.html&quot; rel=&quot;noreferrer&quot;&gt;Bill and Paul&apos;s Excellent UCSD Benchmarks for Java&lt;/a&gt;.  &lt;/p&gt;\n    ","\n&lt;p&gt;I know this question has been marked as answered but I wanted to mention two libraries that help us to write micro benchmarks&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://github.com/google/caliper&quot; rel=&quot;noreferrer&quot;&gt;Caliper from Google&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;\n&lt;p&gt;&lt;em&gt;Getting started tutorials&lt;/em&gt;&lt;/p&gt;\n&lt;ol&gt;\n&lt;li&gt;&lt;a href=&quot;http://codingjunkie.net/micro-benchmarking-with-caliper/&quot; rel=&quot;noreferrer&quot;&gt;http://codingjunkie.net/micro-benchmarking-with-caliper/&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=&quot;http://vertexlabs.co.uk/blog/caliper&quot; rel=&quot;noreferrer&quot;&gt;http://vertexlabs.co.uk/blog/caliper&lt;/a&gt;&lt;/li&gt;\n&lt;/ol&gt;\n&lt;p&gt;&lt;strong&gt;&lt;a href=&quot;http://openjdk.java.net/projects/code-tools/jmh/&quot; rel=&quot;noreferrer&quot;&gt;JMH from OpenJDK&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;\n&lt;p&gt;&lt;em&gt;Getting started tutorials&lt;/em&gt;&lt;/p&gt;\n&lt;ol&gt;\n&lt;li&gt;&lt;a href=&quot;http://www.oracle.com/technetwork/articles/java/architect-benchmarking-2266277.html&quot; rel=&quot;noreferrer&quot;&gt;Avoiding Benchmarking Pitfalls on the JVM&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=&quot;http://nitschinger.at/Using-JMH-for-Java-Microbenchmarking&quot; rel=&quot;noreferrer&quot;&gt;Using JMH for Java Microbenchmarking&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=&quot;https://web.archive.org/web/20181018130828/http://java-performance.info:80/jmh&quot; rel=&quot;noreferrer&quot;&gt;Introduction to JMH&lt;/a&gt;&lt;/li&gt;\n&lt;/ol&gt;\n    ","\n&lt;p&gt;Important things for Java benchmarks are:&lt;/p&gt;\n\n&lt;ul&gt;\n&lt;li&gt;Warm up the JIT first by running the code several times &lt;strong&gt;before timing&lt;/strong&gt; it&lt;/li&gt;\n&lt;li&gt;Make sure you run it for long enough to be able to measure the results in seconds or (better) tens of seconds&lt;/li&gt;\n&lt;li&gt;While you can&apos;t call &lt;code&gt;System.gc()&lt;/code&gt; between iterations, it&apos;s a good idea to run it between tests, so that each test will hopefully get a &quot;clean&quot; memory space to work with. (Yes, &lt;code&gt;gc()&lt;/code&gt; is more of a hint than a guarantee, but it&apos;s very &lt;em&gt;likely&lt;/em&gt; that it really will garbage collect in my experience.)&lt;/li&gt;\n&lt;li&gt;I like to display iterations and time, and a score of time/iteration which can be scaled such that the &quot;best&quot; algorithm gets a score of 1.0 and others are scored in a relative fashion. This means you can run &lt;em&gt;all&lt;/em&gt; algorithms for a longish time, varying both number of iterations and time, but still getting comparable results.&lt;/li&gt;\n&lt;/ul&gt;\n\n&lt;p&gt;I&apos;m just in the process of blogging about the design of a benchmarking framework in .NET. I&apos;ve got a &lt;a href=&quot;http://msmvps.com/blogs/jon_skeet/archive/2009/01/26/benchmarking-made-easy.aspx&quot; rel=&quot;noreferrer&quot;&gt;couple&lt;/a&gt; of &lt;a href=&quot;http://msmvps.com/blogs/jon_skeet/archive/2009/01/29/for-vs-foreach-on-arrays-and-lists.aspx&quot; rel=&quot;noreferrer&quot;&gt;earlier posts&lt;/a&gt; which may be able to give you some ideas - not everything will be appropriate, of course, but some of it may be.&lt;/p&gt;\n    ","\n&lt;p&gt;&lt;a href=&quot;http://openjdk.java.net/projects/code-tools/jmh/&quot; rel=&quot;nofollow noreferrer&quot;&gt;jmh&lt;/a&gt; is a recent addition to OpenJDK and has been written by some performance engineers from Oracle. Certainly worth a look.&lt;/p&gt;\n\n&lt;blockquote&gt;\n  &lt;p&gt;The jmh is a Java harness for building, running, and analysing nano/micro/macro benchmarks written in Java and other languages targetting the JVM.&lt;/p&gt;\n&lt;/blockquote&gt;\n\n&lt;p&gt;Very interesting pieces of information buried in &lt;a href=&quot;http://hg.openjdk.java.net/code-tools/jmh/file/tip/jmh-samples/src/main/java/org/openjdk/jmh/samples/&quot; rel=&quot;nofollow noreferrer&quot;&gt;the sample tests comments&lt;/a&gt;.&lt;/p&gt;\n\n&lt;p&gt;See also:&lt;/p&gt;\n\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=&quot;http://www.oracle.com/technetwork/articles/java/architect-benchmarking-2266277.html&quot; rel=&quot;nofollow noreferrer&quot;&gt;Avoiding Benchmarking Pitfalls on the JVM&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=&quot;https://groups.google.com/forum/#!msg/mechanical-sympathy/m4opvy4xq3U/7lY8x8SvHgwJ&quot; rel=&quot;nofollow noreferrer&quot;&gt;Discussion on the main strengths of jmh&lt;/a&gt;.&lt;/li&gt;\n&lt;/ul&gt;\n    ","\n&lt;blockquote&gt;\n  &lt;p&gt;Should the benchmark measure time/iteration or iterations/time, and why?&lt;/p&gt;\n&lt;/blockquote&gt;\n\n&lt;p&gt;It depends on &lt;strong&gt;what&lt;/strong&gt; you are trying to test.  &lt;/p&gt;\n\n&lt;p&gt;If you are interested in &lt;strong&gt;latency&lt;/strong&gt;, use time/iteration and if you are interested in &lt;strong&gt;throughput&lt;/strong&gt;, use iterations/time.&lt;/p&gt;\n    ","\n&lt;p&gt;Make sure you somehow use results which are computed in benchmarked code. Otherwise your code can be optimized away.&lt;/p&gt;\n    ","\n&lt;p&gt;If you are trying to compare two algorithms, do at least two benchmarks for each, alternating the order.  i.e.:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-java s-code-block&quot;&gt;&lt;code class=&quot;hljs language-java&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt;(i=&lt;span class=&quot;hljs-number&quot;&gt;1.&lt;/span&gt;.n)\n  alg1();\n&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt;(i=&lt;span class=&quot;hljs-number&quot;&gt;1.&lt;/span&gt;.n)\n  alg2();\n&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt;(i=&lt;span class=&quot;hljs-number&quot;&gt;1.&lt;/span&gt;.n)\n  alg2();\n&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt;(i=&lt;span class=&quot;hljs-number&quot;&gt;1.&lt;/span&gt;.n)\n  alg1();\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;I have found some noticeable differences (5-10% sometimes) in the runtime of the same algorithm in different passes..&lt;/p&gt;\n\n&lt;p&gt;Also, make sure that &lt;em&gt;n&lt;/em&gt; is very large, so that the runtime of each loop is at the very least 10 seconds or so.  The more iterations, the more significant figures in your benchmark time and the more reliable that data is.&lt;/p&gt;\n    ","\n&lt;p&gt;There are many possible pitfalls for writing micro-benchmarks in Java.&lt;/p&gt;\n\n&lt;p&gt;First: You have to calculate with all sorts of events that take time more or less random: Garbage collection, caching effects (of OS for files and of CPU for memory), IO etc.&lt;/p&gt;\n\n&lt;p&gt;Second: You cannot trust the accuracy of the measured times for very short intervals.&lt;/p&gt;\n\n&lt;p&gt;Third: The JVM optimizes your code while executing. So different runs in the same JVM-instance will become faster and faster.&lt;/p&gt;\n\n&lt;p&gt;My recommendations: Make your benchmark run some seconds, that is more reliable than a runtime over milliseconds. Warm up the JVM (means running the benchmark at least once without measuring, that the JVM can run optimizations). And run your benchmark multiple times (maybe 5 times) and take the median-value. Run every micro-benchmark in a new JVM-instance (call for every benchmark new Java) otherwise optimization effects of the JVM can influence later running tests. Don&apos;t execute things, that aren&apos;t executed in the warmup-phase (as this could trigger class-load and recompilation).&lt;/p&gt;\n    ","\n&lt;p&gt;It should also be noted that it might also be important to analyze the results of the micro benchmark when comparing different implementations. Therefore a &lt;a href=&quot;http://en.wikipedia.org/wiki/Significance_testing&quot; rel=&quot;noreferrer&quot;&gt;significance test&lt;/a&gt; should be made.&lt;/p&gt;\n\n&lt;p&gt;This is because implementation &lt;code&gt;A&lt;/code&gt; might be faster during most of the runs of the benchmark than implementation &lt;code&gt;B&lt;/code&gt;. But &lt;code&gt;A&lt;/code&gt; might also have a higher spread, so the measured performance benefit of &lt;code&gt;A&lt;/code&gt; won&apos;t be of any significance when compared with &lt;code&gt;B&lt;/code&gt;.&lt;/p&gt;\n\n&lt;p&gt;So it is also important to write and run a micro benchmark correctly, but also to analyze it correctly.&lt;/p&gt;\n    ","\n&lt;p&gt;To add to the other excellent advice, I&apos;d also be mindful of the following:&lt;/p&gt;\n\n&lt;p&gt;For some CPUs (e.g. Intel Core i5 range with TurboBoost), the temperature (and number of cores currently being used, as well as thier utilisation percent) affects the clock speed. Since CPUs are dynamically clocked, this can affect your results. For example, if you have a single-threaded application, the maximum clock speed (with TurboBoost) is higher than for an application using all cores. This can therefore interfere with comparisons of single and multi-threaded performance on some systems. Bear in mind that the temperature and volatages also affect how long Turbo frequency is maintained.&lt;/p&gt;\n\n&lt;p&gt;Perhaps a more fundamentally important aspect that you have direct control over: make sure you&apos;re measuring the right thing! For example, if you&apos;re using &lt;code&gt;System.nanoTime()&lt;/code&gt; to benchmark a particular bit of code, put the calls to the assignment in places that make sense to avoid measuring things which you aren&apos;t interested in. For example, don&apos;t do:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-java s-code-block&quot;&gt;&lt;code class=&quot;hljs language-java&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;long&lt;/span&gt; &lt;span class=&quot;hljs-variable&quot;&gt;startTime&lt;/span&gt; &lt;span class=&quot;hljs-operator&quot;&gt;=&lt;/span&gt; System.nanoTime();\n&lt;span class=&quot;hljs-comment&quot;&gt;//code here...&lt;/span&gt;\nSystem.out.println(&lt;span class=&quot;hljs-string&quot;&gt;&quot;Code took &quot;&lt;/span&gt;+(System.nanoTime()-startTime)+&lt;span class=&quot;hljs-string&quot;&gt;&quot;nano seconds&quot;&lt;/span&gt;);\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Problem is you&apos;re not immediately getting the end time when the code has finished. Instead, try the following:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-java s-code-block&quot;&gt;&lt;code class=&quot;hljs language-java&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;long&lt;/span&gt; endTime, startTime = System.nanoTime();\n&lt;span class=&quot;hljs-comment&quot;&gt;//code here...&lt;/span&gt;\nendTime = System.nanoTime();\nSystem.out.println(&lt;span class=&quot;hljs-string&quot;&gt;&quot;Code took &quot;&lt;/span&gt;+(endTime-startTime)+&lt;span class=&quot;hljs-string&quot;&gt;&quot;nano seconds&quot;&lt;/span&gt;);\n&lt;/code&gt;&lt;/pre&gt;\n    ","\n&lt;p&gt;&lt;a href=&quot;http://opt.sourceforge.net/&quot; rel=&quot;noreferrer&quot;&gt;http://opt.sourceforge.net/&lt;/a&gt; Java Micro Benchmark - control tasks required to determine the comparative performance characteristics of the computer system on different platforms. Can be used to guide optimization decisions and to compare different Java implementations.&lt;/p&gt;\n    "]},"randomTags":[{"name":"promise","slug":"promise"},{"name":"footer","slug":"footer"},{"name":"python-class","slug":"python-class"},{"name":"ajax","slug":"ajax"},{"name":"dangling-pointer","slug":"dangling-pointer"},{"name":"jakarta-ee","slug":"jakarta-ee"},{"name":"flask-restless","slug":"flask-restless"},{"name":"recursive-query","slug":"recursive-query"},{"name":"variable-length-array","slug":"variable-length-array"},{"name":"sleep","slug":"sleep"},{"name":"profiler","slug":"profiler"},{"name":"abi","slug":"abi"},{"name":"nosuchelementexception","slug":"nosuchelementexception"},{"name":"pivot","slug":"pivot"},{"name":"branch-prediction","slug":"branch-prediction"},{"name":"bash","slug":"bash"},{"name":"client-side","slug":"client-side"},{"name":"security","slug":"security"},{"name":"gets","slug":"gets"},{"name":"forward-declaration","slug":"forward-declaration"}]},"__N_SSG":true}