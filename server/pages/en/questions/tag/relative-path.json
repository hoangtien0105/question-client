{"pageProps":{"data":{"count":1,"rows":[{"id":365,"title":"Relative imports for the billionth time","slug":"relative-imports-for-the-billionth-time-1657387756383","postType":"QUESTION","createdAt":"2022-07-09T17:29:16.000Z","updatedAt":"2022-07-09T17:29:16.000Z","tags":[{"id":2022,"name":"relative-path","slug":"relative-path","createdAt":"2022-07-09T17:29:16.000Z","updatedAt":"2022-07-09T17:29:16.000Z","Questions_Tags":{"questionId":365,"tagId":2022}}]}]},"slug":"relative-path","page":1,"answers":{"365":["\n&lt;p&gt;&lt;strong&gt;Script vs. Module&lt;/strong&gt;&lt;/p&gt;\n&lt;p&gt;Here&apos;s an explanation.  The short version is that there is a big difference between directly running a Python file, and importing that file from somewhere else.  &lt;strong&gt;Just knowing what directory a file is in does not determine what package Python thinks it is in.&lt;/strong&gt;  That depends, additionally, on how you load the file into Python (by running or by importing).&lt;/p&gt;\n&lt;p&gt;There are two ways to load a Python file: as the top-level script, or as a\nmodule.  A file is loaded as the top-level script if you execute it directly, for instance by typing &lt;code&gt;python myfile.py&lt;/code&gt; on the command line.  It is loaded as a module when an &lt;code&gt;import&lt;/code&gt; statement is encountered inside some other file.  There can only be one top-level script at a time; the top-level script is the Python file you ran to start things off.&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;Naming&lt;/strong&gt;&lt;/p&gt;\n&lt;p&gt;When a file is loaded, it is given a name (which is stored in its &lt;code&gt;__name__&lt;/code&gt; attribute).  If it was loaded as the top-level script, its name is &lt;code&gt;__main__&lt;/code&gt;.  If it was loaded as a module, its name is the filename, preceded by the names of any packages/subpackages of which it is a part, separated by dots.&lt;/p&gt;\n&lt;p&gt;So for instance in your example:&lt;/p&gt;\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;package/\n    __init__.py\n    subpackage1/\n        __init__.py\n        moduleX.py\n    moduleA.py\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;if you imported &lt;code&gt;moduleX&lt;/code&gt; (note: &lt;em&gt;imported&lt;/em&gt;, not directly executed), its name would be &lt;code&gt;package.subpackage1.moduleX&lt;/code&gt;.  If you imported &lt;code&gt;moduleA&lt;/code&gt;, its name would be &lt;code&gt;package.moduleA&lt;/code&gt;.  However, if you &lt;em&gt;directly run&lt;/em&gt; &lt;code&gt;moduleX&lt;/code&gt; from the command line, its name will instead be &lt;code&gt;__main__&lt;/code&gt;, and if you directly run &lt;code&gt;moduleA&lt;/code&gt; from the command line, its name will be &lt;code&gt;__main__&lt;/code&gt;.  When a module is run as the top-level script, it loses its normal name and its name is instead &lt;code&gt;__main__&lt;/code&gt;.&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;Accessing a module NOT through its containing package&lt;/strong&gt;&lt;/p&gt;\n&lt;p&gt;There is an additional wrinkle: the module&apos;s name depends on whether it was imported &quot;directly&quot; from the directory it is in or imported via a package.  This only makes a difference if you run Python in a directory, and try to import a file in that same directory (or a subdirectory of it).  For instance, if you start the Python interpreter in the directory &lt;code&gt;package/subpackage1&lt;/code&gt; and then do &lt;code&gt;import moduleX&lt;/code&gt;, the name of &lt;code&gt;moduleX&lt;/code&gt; will just be &lt;code&gt;moduleX&lt;/code&gt;, and not &lt;code&gt;package.subpackage1.moduleX&lt;/code&gt;.  This is because Python adds the current directory to its search path when the interpreter is entered interactively; if it finds the to-be-imported module in the current directory, it will not know that that directory is part of a package, and the package information will not become part of the module&apos;s name.&lt;/p&gt;\n&lt;p&gt;A special case is if you run the interpreter interactively (e.g., just type &lt;code&gt;python&lt;/code&gt; and start entering Python code on the fly).  In this case, the name of that interactive session is &lt;code&gt;__main__&lt;/code&gt;.&lt;/p&gt;\n&lt;p&gt;Now here is the crucial thing for your error message: &lt;strong&gt;if a module&apos;s name has no dots, it is not considered to be part of a package&lt;/strong&gt;.  It doesn&apos;t matter where the file actually is on disk.  All that matters is what its name is, and its name depends on how you loaded it.&lt;/p&gt;\n&lt;p&gt;Now look at the quote you included in your question:&lt;/p&gt;\n&lt;blockquote&gt;\n&lt;p&gt;Relative imports use a module&apos;s name attribute to determine that module&apos;s position in the package hierarchy. If the module&apos;s name does not contain any package information (e.g. it is set to &apos;main&apos;) then relative imports are resolved as if the module were a top-level module, regardless of where the module is actually located on the file system.&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;p&gt;&lt;strong&gt;Relative imports...&lt;/strong&gt;&lt;/p&gt;\n&lt;p&gt;Relative imports use the module&apos;s &lt;em&gt;name&lt;/em&gt; to determine where it is in a package.  When you use a relative import like &lt;code&gt;from .. import foo&lt;/code&gt;, the dots indicate to step up some number of levels in the package hierarchy.  For instance, if your current module&apos;s name is &lt;code&gt;package.subpackage1.moduleX&lt;/code&gt;, then &lt;code&gt;..moduleA&lt;/code&gt; would mean &lt;code&gt;package.moduleA&lt;/code&gt;.  For a &lt;code&gt;from .. import&lt;/code&gt; to work, the module&apos;s name must have at least as many dots as there are in the &lt;code&gt;import&lt;/code&gt; statement.&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;... are only relative in a package&lt;/strong&gt;&lt;/p&gt;\n&lt;p&gt;However, if your module&apos;s name is &lt;code&gt;__main__&lt;/code&gt;, it is not considered to be in a package.  Its name has no dots, and therefore you cannot use &lt;code&gt;from .. import&lt;/code&gt; statements inside it.  If you try to do so, you will get the &quot;relative-import in non-package&quot; error.&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;Scripts can&apos;t import relative&lt;/strong&gt;&lt;/p&gt;\n&lt;p&gt;What you probably did is you tried to run &lt;code&gt;moduleX&lt;/code&gt; or the like from the command line.  When you did this, its name was set to &lt;code&gt;__main__&lt;/code&gt;, which means that relative imports within it will fail, because its name does not reveal that it is in a package. Note that this will also happen if you run Python from the same directory where a module is, and then try to import that module, because, as described above, Python will find the module in the current directory &quot;too early&quot; without realizing it is part of a package.&lt;/p&gt;\n&lt;p&gt;Also remember that when you run the interactive interpreter, the &quot;name&quot; of that interactive session is always &lt;code&gt;__main__&lt;/code&gt;.  Thus &lt;strong&gt;you cannot do relative imports directly from an interactive session&lt;/strong&gt;.  Relative imports are only for use within module files.&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;Two solutions:&lt;/strong&gt;&lt;/p&gt;\n&lt;ol&gt;\n&lt;li&gt;&lt;p&gt;If you really do want to run &lt;code&gt;moduleX&lt;/code&gt; directly, but you still want it to be considered part of a package, you can do &lt;code&gt;python -m package.subpackage1.moduleX&lt;/code&gt;.  The &lt;code&gt;-m&lt;/code&gt; tells Python to load it as a module, not as the top-level script.&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;p&gt;Or perhaps you don&apos;t actually want to &lt;em&gt;run&lt;/em&gt; &lt;code&gt;moduleX&lt;/code&gt;, you just want to run some other script, say &lt;code&gt;myfile.py&lt;/code&gt;, that &lt;em&gt;uses&lt;/em&gt; functions inside &lt;code&gt;moduleX&lt;/code&gt;.  If that is the case, put &lt;code&gt;myfile.py&lt;/code&gt; &lt;em&gt;somewhere else&lt;/em&gt;  &lt;em&gt;not&lt;/em&gt; inside the &lt;code&gt;package&lt;/code&gt; directory  and run it.  If inside &lt;code&gt;myfile.py&lt;/code&gt; you do things like &lt;code&gt;from package.moduleA import spam&lt;/code&gt;, it will work fine.&lt;/p&gt;\n&lt;/li&gt;\n&lt;/ol&gt;\n&lt;p&gt;&lt;strong&gt;Notes&lt;/strong&gt;&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;p&gt;For either of these solutions, the package directory (&lt;code&gt;package&lt;/code&gt; in your example) must be accessible from the Python module search path (&lt;code&gt;sys.path&lt;/code&gt;).  If it is not, you will not be able to use anything in the package reliably at all.&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;p&gt;Since Python 2.6, the module&apos;s &quot;name&quot; for package-resolution purposes is determined not just by its &lt;code&gt;__name__&lt;/code&gt; attributes but also by the &lt;code&gt;__package__&lt;/code&gt; attribute.  That&apos;s why I&apos;m avoiding using the explicit symbol &lt;code&gt;__name__&lt;/code&gt; to refer to the module&apos;s &quot;name&quot;.  Since Python 2.6 a module&apos;s &quot;name&quot; is effectively &lt;code&gt;__package__ + &apos;.&apos; + __name__&lt;/code&gt;, or just &lt;code&gt;__name__&lt;/code&gt; if &lt;code&gt;__package__&lt;/code&gt; is &lt;code&gt;None&lt;/code&gt;.)&lt;/p&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n    ","\n&lt;p&gt;This is really a problem within python. &lt;strong&gt;The origin of confusion is that people mistakenly takes the relative import as path relative which is not.&lt;/strong&gt; &lt;/p&gt;\n\n&lt;p&gt;For example when you write in &lt;em&gt;faa.py&lt;/em&gt;:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;from&lt;/span&gt; .. &lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; foo\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;This has a meaning only if &lt;em&gt;faa.py&lt;/em&gt; was &lt;em&gt;identified and loaded&lt;/em&gt; by python, during execution, as a part of a package. In that case,the &lt;strong&gt;module&apos;s name&lt;/strong&gt; \n for &lt;em&gt;faa.py&lt;/em&gt; would be for example &lt;em&gt;some_packagename.faa&lt;/em&gt;. If the file was loaded just because it is in the current directory, when python is run, then its name would not refer to any package and eventually relative import would fail. &lt;/p&gt;\n\n&lt;p&gt;A simple solution to refer modules in the current directory, is to use this:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; __package__ &lt;span class=&quot;hljs-keyword&quot;&gt;is&lt;/span&gt; &lt;span class=&quot;hljs-literal&quot;&gt;None&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;or&lt;/span&gt; __package__ == &lt;span class=&quot;hljs-string&quot;&gt;&apos;&apos;&lt;/span&gt;:\n    &lt;span class=&quot;hljs-comment&quot;&gt;# uses current directory visibility&lt;/span&gt;\n    &lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; foo\n&lt;span class=&quot;hljs-keyword&quot;&gt;else&lt;/span&gt;:\n    &lt;span class=&quot;hljs-comment&quot;&gt;# uses current package visibility&lt;/span&gt;\n    &lt;span class=&quot;hljs-keyword&quot;&gt;from&lt;/span&gt; . &lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; foo\n&lt;/code&gt;&lt;/pre&gt;\n    ","\n&lt;p&gt;So after carping about this along with many others, I came across a note posted by &lt;a href=&quot;https://stackoverflow.com/users/5420054/dorian-b&quot;&gt;Dorian B&lt;/a&gt; in this &lt;a href=&quot;https://stackoverflow.com/questions/5286210/is-there-a-way-to-access-parent-modules-in-python&quot;&gt;article&lt;/a&gt; that solved the specific problem I was having where I would develop modules and classes for use with a web service, but I also want to be able to test them as I&apos;m coding, using the debugger facilities in PyCharm. To run tests in a self-contained class, I would include the following at the end of my class file:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; __name__ == &lt;span class=&quot;hljs-string&quot;&gt;&apos;__main__&apos;&lt;/span&gt;:\n   &lt;span class=&quot;hljs-comment&quot;&gt;# run test code here...&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;but if I wanted to import other classes or modules in the same folder, I would then have to change all my import statements from relative notation to local references (i.e. remove the dot (.))  But after reading Dorian&apos;s suggestion, I tried his &apos;one-liner&apos; and it worked!  I can now test in PyCharm and leave my test code in place when I use the class in another class under test, or when I use it in my web service!&lt;/p&gt;\n\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;&lt;span class=&quot;hljs-comment&quot;&gt;# import any site-lib modules first, then...&lt;/span&gt;\n&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; sys\nparent_module = sys.modules[&lt;span class=&quot;hljs-string&quot;&gt;&apos;.&apos;&lt;/span&gt;.join(__name__.split(&lt;span class=&quot;hljs-string&quot;&gt;&apos;.&apos;&lt;/span&gt;)[:-&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;]) &lt;span class=&quot;hljs-keyword&quot;&gt;or&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&apos;__main__&apos;&lt;/span&gt;]\n&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; __name__ == &lt;span class=&quot;hljs-string&quot;&gt;&apos;__main__&apos;&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;or&lt;/span&gt; parent_module.__name__ == &lt;span class=&quot;hljs-string&quot;&gt;&apos;__main__&apos;&lt;/span&gt;:\n    &lt;span class=&quot;hljs-keyword&quot;&gt;from&lt;/span&gt; codex &lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; Codex &lt;span class=&quot;hljs-comment&quot;&gt;# these are in same folder as module under test!&lt;/span&gt;\n    &lt;span class=&quot;hljs-keyword&quot;&gt;from&lt;/span&gt; dblogger &lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; DbLogger\n&lt;span class=&quot;hljs-keyword&quot;&gt;else&lt;/span&gt;:\n    &lt;span class=&quot;hljs-keyword&quot;&gt;from&lt;/span&gt; .codex &lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; Codex\n    &lt;span class=&quot;hljs-keyword&quot;&gt;from&lt;/span&gt; .dblogger &lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; DbLogger\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;The if statement checks to see if we&apos;re running this module as &lt;strong&gt;main&lt;/strong&gt; or if it&apos;s being used in another module that&apos;s being tested as &lt;strong&gt;main&lt;/strong&gt;.  Perhaps this is obvious, but I offer this note here in case anyone else frustrated by the relative import issues above can make use of it.&lt;/p&gt;\n    ","\n&lt;p&gt;There are too much too long anwers in a foreign language. So I&apos;ll try to make it short.&lt;/p&gt;\n&lt;p&gt;If you write &lt;code&gt;from . import module&lt;/code&gt;, opposite to  what you think, &lt;code&gt;module&lt;/code&gt; will not be imported from current directory, but from the top level of your package! If you run .py file as a script, it simply doesn&apos;t know where the top level is and thus refuses to work.&lt;/p&gt;\n&lt;p&gt;If you start it like this &lt;code&gt;py -m package.module&lt;/code&gt; from the directory above &lt;code&gt;package&lt;/code&gt;, then python knows where the top level is. That&apos;s very similar to java: &lt;code&gt;java -cp bin_directory package.class&lt;/code&gt;&lt;/p&gt;\n    ","\n&lt;p&gt;Here&apos;s a general recipe, modified to fit as an example, that I am using right now for dealing with Python libraries written as packages, that contain interdependent files, where I want to be able to test parts of them piecemeal.  Let&apos;s call this &lt;code&gt;lib.foo&lt;/code&gt; and say that it needs access to &lt;code&gt;lib.fileA&lt;/code&gt; for functions &lt;code&gt;f1&lt;/code&gt; and &lt;code&gt;f2&lt;/code&gt;, and &lt;code&gt;lib.fileB&lt;/code&gt; for class &lt;code&gt;Class3&lt;/code&gt;.&lt;/p&gt;\n&lt;p&gt;I have included a few &lt;code&gt;print&lt;/code&gt; calls to help illustrate how this works.  In practice you would want to remove them (and maybe also the &lt;code&gt;from __future__ import print_function&lt;/code&gt; line).&lt;/p&gt;\n&lt;p&gt;This particular example is too simple to show when we really need to insert an entry into &lt;code&gt;sys.path&lt;/code&gt;.  (See &lt;a href=&quot;https://stackoverflow.com/a/38455936/1256452&quot;&gt;Lars&apos; answer&lt;/a&gt; for a case where we &lt;em&gt;do&lt;/em&gt; need it, when we have two or more levels of package directories, and then we use &lt;code&gt;os.path.dirname(os.path.dirname(__file__))&lt;/code&gt;but it doesn&apos;t really &lt;em&gt;hurt&lt;/em&gt; here either.)  It&apos;s also safe enough to do this without the &lt;code&gt;if _i in sys.path&lt;/code&gt; test.  However, if each imported file inserts the same pathfor instance, if both &lt;code&gt;fileA&lt;/code&gt; and &lt;code&gt;fileB&lt;/code&gt; want to import utilities from the packagethis clutters up &lt;code&gt;sys.path&lt;/code&gt; with the same path many times, so it&apos;s nice to have the &lt;code&gt;if _i not in sys.path&lt;/code&gt; in the boilerplate.&lt;/p&gt;\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;from&lt;/span&gt; __future__ &lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; print_function &lt;span class=&quot;hljs-comment&quot;&gt;# only when showing how this works&lt;/span&gt;\n\n&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; __package__:\n    &lt;span class=&quot;hljs-built_in&quot;&gt;print&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&apos;Package named {!r}; __name__ is {!r}&apos;&lt;/span&gt;.&lt;span class=&quot;hljs-built_in&quot;&gt;format&lt;/span&gt;(__package__, __name__))\n    &lt;span class=&quot;hljs-keyword&quot;&gt;from&lt;/span&gt; .fileA &lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; f1, f2\n    &lt;span class=&quot;hljs-keyword&quot;&gt;from&lt;/span&gt; .fileB &lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; Class3\n&lt;span class=&quot;hljs-keyword&quot;&gt;else&lt;/span&gt;:\n    &lt;span class=&quot;hljs-built_in&quot;&gt;print&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&apos;Not a package; __name__ is {!r}&apos;&lt;/span&gt;.&lt;span class=&quot;hljs-built_in&quot;&gt;format&lt;/span&gt;(__name__))\n    &lt;span class=&quot;hljs-comment&quot;&gt;# these next steps should be used only with care and if needed&lt;/span&gt;\n    &lt;span class=&quot;hljs-comment&quot;&gt;# (remove the sys.path manipulation for simple cases!)&lt;/span&gt;\n    &lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; os, sys\n    _i = os.path.dirname(os.path.abspath(__file__))\n    &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; _i &lt;span class=&quot;hljs-keyword&quot;&gt;not&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; sys.path:\n        &lt;span class=&quot;hljs-built_in&quot;&gt;print&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&apos;inserting {!r} into sys.path&apos;&lt;/span&gt;.&lt;span class=&quot;hljs-built_in&quot;&gt;format&lt;/span&gt;(_i))\n        sys.path.insert(&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;, _i)\n    &lt;span class=&quot;hljs-keyword&quot;&gt;else&lt;/span&gt;:\n        &lt;span class=&quot;hljs-built_in&quot;&gt;print&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&apos;{!r} is already in sys.path&apos;&lt;/span&gt;.&lt;span class=&quot;hljs-built_in&quot;&gt;format&lt;/span&gt;(_i))\n    &lt;span class=&quot;hljs-keyword&quot;&gt;del&lt;/span&gt; _i &lt;span class=&quot;hljs-comment&quot;&gt;# clean up global name space&lt;/span&gt;\n\n    &lt;span class=&quot;hljs-keyword&quot;&gt;from&lt;/span&gt; fileA &lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; f1, f2\n    &lt;span class=&quot;hljs-keyword&quot;&gt;from&lt;/span&gt; fileB &lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; Class3\n\n&lt;span class=&quot;hljs-meta&quot;&gt;... &lt;/span&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;all&lt;/span&gt; the code &lt;span class=&quot;hljs-keyword&quot;&gt;as&lt;/span&gt; usual ...\n\n&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; __name__ == &lt;span class=&quot;hljs-string&quot;&gt;&apos;__main__&apos;&lt;/span&gt;:\n    &lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; doctest, sys\n    ret = doctest.testmod()\n    sys.exit(&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; ret.failed == &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;)\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;The idea here is this (and note that these all function the same across python2.7 and python 3.x):&lt;/p&gt;\n&lt;ol&gt;\n&lt;li&gt;&lt;p&gt;If run as &lt;code&gt;import lib&lt;/code&gt; or &lt;code&gt;from lib import foo&lt;/code&gt; as a regular package import from ordinary code, &lt;code&gt;__package&lt;/code&gt; is &lt;code&gt;lib&lt;/code&gt; and &lt;code&gt;__name__&lt;/code&gt; is &lt;code&gt;lib.foo&lt;/code&gt;.  We take the first code path, importing from &lt;code&gt;.fileA&lt;/code&gt;, etc.&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;p&gt;If run as &lt;code&gt;python lib/foo.py&lt;/code&gt;, &lt;code&gt;__package__&lt;/code&gt; will be None and &lt;code&gt;__name__&lt;/code&gt; will be &lt;code&gt;__main__&lt;/code&gt;.&lt;/p&gt;\n&lt;p&gt;We take the second code path.  The &lt;code&gt;lib&lt;/code&gt; directory will already be in &lt;code&gt;sys.path&lt;/code&gt; so there is no need to add it.  We import from &lt;code&gt;fileA&lt;/code&gt;, etc.&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;p&gt;If run within the &lt;code&gt;lib&lt;/code&gt; directory as &lt;code&gt;python foo.py&lt;/code&gt;, the behavior is the same as for case 2.&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;p&gt;If run within the &lt;code&gt;lib&lt;/code&gt; directory as &lt;code&gt;python -m foo&lt;/code&gt;, the behavior is similar to cases 2 and 3.  However, the path to the &lt;code&gt;lib&lt;/code&gt; directory is not in &lt;code&gt;sys.path&lt;/code&gt;, so we add it before importing.  The same applies if we run Python and then &lt;code&gt;import foo&lt;/code&gt;.&lt;/p&gt;\n&lt;p&gt;(Since &lt;code&gt;.&lt;/code&gt; &lt;em&gt;is&lt;/em&gt; in &lt;code&gt;sys.path&lt;/code&gt;, we don&apos;t really need to add the absolute version of the path here.  This is where a deeper package nesting structure, where we want to do &lt;code&gt;from ..otherlib.fileC import ...&lt;/code&gt;, makes a difference.  If you&apos;re not doing this, you can omit all the &lt;code&gt;sys.path&lt;/code&gt; manipulation entirely.)&lt;/p&gt;\n&lt;/li&gt;\n&lt;/ol&gt;\n&lt;h3&gt;Notes&lt;/h3&gt;\n&lt;p&gt;There is still a quirk.  If you run this whole thing from outside:&lt;/p&gt;\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;$ python2 lib.foo\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;or:&lt;/p&gt;\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;$ python3 lib.foo\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;the behavior depends on the contents of &lt;code&gt;lib/__init__.py&lt;/code&gt;.  If that exists and &lt;em&gt;is empty&lt;/em&gt;, all is well:&lt;/p&gt;\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;Package named &lt;span class=&quot;hljs-string&quot;&gt;&apos;lib&apos;&lt;/span&gt;; __name__ &lt;span class=&quot;hljs-keyword&quot;&gt;is&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&apos;__main__&apos;&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;But if &lt;code&gt;lib/__init__.py&lt;/code&gt; &lt;em&gt;itself&lt;/em&gt; imports &lt;code&gt;routine&lt;/code&gt; so that it can export &lt;code&gt;routine.name&lt;/code&gt; directly as &lt;code&gt;lib.name&lt;/code&gt;, you get:&lt;/p&gt;\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;$ python2 lib.foo\nPackage named &lt;span class=&quot;hljs-string&quot;&gt;&apos;lib&apos;&lt;/span&gt;; __name__ &lt;span class=&quot;hljs-keyword&quot;&gt;is&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&apos;lib.foo&apos;&lt;/span&gt;\nPackage named &lt;span class=&quot;hljs-string&quot;&gt;&apos;lib&apos;&lt;/span&gt;; __name__ &lt;span class=&quot;hljs-keyword&quot;&gt;is&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&apos;__main__&apos;&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;That is, the module gets imported twice, once via the package and then again as &lt;code&gt;__main__&lt;/code&gt; so that it runs your &lt;code&gt;main&lt;/code&gt; code.  Python 3.6 and later warn about this:&lt;/p&gt;\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;$ python3 lib.routine\nPackage named &lt;span class=&quot;hljs-string&quot;&gt;&apos;lib&apos;&lt;/span&gt;; __name__ &lt;span class=&quot;hljs-keyword&quot;&gt;is&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&apos;lib.foo&apos;&lt;/span&gt;\n[...]/runpy.py:&lt;span class=&quot;hljs-number&quot;&gt;125&lt;/span&gt;: RuntimeWarning: &lt;span class=&quot;hljs-string&quot;&gt;&apos;lib.foo&apos;&lt;/span&gt; found &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; sys.modules\nafter &lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; of package &lt;span class=&quot;hljs-string&quot;&gt;&apos;lib&apos;&lt;/span&gt;, but prior to execution of &lt;span class=&quot;hljs-string&quot;&gt;&apos;lib.foo&apos;&lt;/span&gt;;\nthis may result &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; unpredictable behaviour\n  warn(RuntimeWarning(msg))\nPackage named &lt;span class=&quot;hljs-string&quot;&gt;&apos;lib&apos;&lt;/span&gt;; __name__ &lt;span class=&quot;hljs-keyword&quot;&gt;is&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&apos;__main__&apos;&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;The &lt;em&gt;warning&lt;/em&gt; is new, but the warned-about behavior is not.  It is part of what some call &lt;a href=&quot;http://python-notes.curiousefficiency.org/en/latest/python_concepts/import_traps.html#the-double-import-trap&quot; rel=&quot;noreferrer&quot;&gt;the double import trap&lt;/a&gt;.  (For additional details see &lt;a href=&quot;https://bugs.python.org/issue27487&quot; rel=&quot;noreferrer&quot;&gt;issue 27487&lt;/a&gt;.)  Nick Coghlan says:&lt;/p&gt;\n&lt;blockquote&gt;\n&lt;p&gt;This next trap exists in all current versions of Python, including 3.3, and can be summed up in the following general guideline: &quot;Never add a package directory, or any directory inside a package, directly to the Python path&quot;.&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;p&gt;Note that while we violate that rule here, we do it &lt;em&gt;only&lt;/em&gt; when the file being loaded is &lt;em&gt;not&lt;/em&gt; being loaded as part of a package, and our modification is specifically designed to allow us to access other files in that package.  (And, as I noted, we probably shouldn&apos;t do this at all for single level packages.)  If we wanted to be extra-clean, we might rewrite this as, e.g.:&lt;/p&gt;\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;    &lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; os, sys\n    _i = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))\n    &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; _i &lt;span class=&quot;hljs-keyword&quot;&gt;not&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; sys.path:\n        sys.path.insert(&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;, _i)\n    &lt;span class=&quot;hljs-keyword&quot;&gt;else&lt;/span&gt;:\n        _i = &lt;span class=&quot;hljs-literal&quot;&gt;None&lt;/span&gt;\n\n    &lt;span class=&quot;hljs-keyword&quot;&gt;from&lt;/span&gt; sub.fileA &lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; f1, f2\n    &lt;span class=&quot;hljs-keyword&quot;&gt;from&lt;/span&gt; sub.fileB &lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; Class3\n\n    &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; _i:\n        sys.path.remove(_i)\n    &lt;span class=&quot;hljs-keyword&quot;&gt;del&lt;/span&gt; _i\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;That is, we modify &lt;code&gt;sys.path&lt;/code&gt; long enough to achieve our imports, then put it back the way it was (deleting one copy of &lt;code&gt;_i&lt;/code&gt; if and only if we added one copy of &lt;code&gt;_i&lt;/code&gt;).&lt;/p&gt;\n    ","\n&lt;p&gt;Here is one solution that I would not recommend, but might be useful in some situations where modules were simply not generated:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; os\n&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; sys\nparent_dir_name = os.path.dirname(os.path.dirname(os.path.realpath(__file__)))\nsys.path.append(parent_dir_name + &lt;span class=&quot;hljs-string&quot;&gt;&quot;/your_dir&quot;&lt;/span&gt;)\n&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; your_script\nyour_script.a_function()\n&lt;/code&gt;&lt;/pre&gt;\n    ","\n&lt;p&gt;@BrenBarn&apos;s answer says it all, but if you&apos;re like me it might take a while to understand.  Here&apos;s my case and how @BrenBarn&apos;s answer applies to it, perhaps it will help you.&lt;/p&gt;\n\n&lt;p&gt;&lt;strong&gt;The case&lt;/strong&gt;&lt;/p&gt;\n\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;package/\n    __init__.py\n    subpackage1/\n        __init__.py\n        moduleX.py\n    moduleA.py\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Using our familiar example, and add to it that moduleX.py has a relative import to ..moduleA.  Given that I tried writing a test script in the subpackage1 directory that imported moduleX, but then got the dreaded error described by the OP.&lt;/p&gt;\n\n&lt;p&gt;&lt;strong&gt;Solution&lt;/strong&gt;&lt;/p&gt;\n\n&lt;p&gt;Move test script to the same level as package and import package.subpackage1.moduleX&lt;/p&gt;\n\n&lt;p&gt;&lt;strong&gt;Explanation&lt;/strong&gt;&lt;/p&gt;\n\n&lt;p&gt;As explained, relative imports are made relative to the current name.  When my test script imports moduleX from the same directory, then module name inside moduleX is moduleX.  When it encounters a relative import the interpreter can&apos;t back up the package hierarchy because it&apos;s already at the top&lt;/p&gt;\n\n&lt;p&gt;When I import moduleX from above, then name inside moduleX is package.subpackage1.moduleX and the relative import can be found&lt;/p&gt;\n    ","\n&lt;p&gt;I had a similar problem where I didn&apos;t want to change the Python module search \npath and needed to load a module relatively &lt;em&gt;from a script&lt;/em&gt; (in spite of &lt;em&gt;&quot;scripts can&apos;t import relative with all&quot;&lt;/em&gt; as BrenBarn explained nicely above).&lt;/p&gt;\n\n&lt;p&gt;So I used the following hack. Unfortunately, it relies on the &lt;code&gt;imp&lt;/code&gt; module that \nbecame deprecated since version 3.4 to be dropped in favour of &lt;code&gt;importlib&lt;/code&gt;.\n(Is this possible with &lt;code&gt;importlib&lt;/code&gt;, too? I don&apos;t know.) Still, the hack works for now.&lt;/p&gt;\n\n&lt;p&gt;Example for accessing members of &lt;code&gt;moduleX&lt;/code&gt; in &lt;code&gt;subpackage1&lt;/code&gt; from a script residing in the &lt;code&gt;subpackage2&lt;/code&gt; folder:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;&lt;span class=&quot;hljs-comment&quot;&gt;#!/usr/bin/env python3&lt;/span&gt;\n\n&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; inspect\n&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; imp\n&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; os\n\n&lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;get_script_dir&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;follow_symlinks=&lt;span class=&quot;hljs-literal&quot;&gt;True&lt;/span&gt;&lt;/span&gt;):\n    &lt;span class=&quot;hljs-string&quot;&gt;&quot;&quot;&quot;\n    Return directory of code defining this very function.\n    Should work from a module as well as from a script.\n    &quot;&quot;&quot;&lt;/span&gt;\n    script_path = inspect.getabsfile(get_script_dir)\n    &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; follow_symlinks:\n        script_path = os.path.realpath(script_path)\n    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; os.path.dirname(script_path)\n\n&lt;span class=&quot;hljs-comment&quot;&gt;# loading the module (hack, relying on deprecated imp-module)&lt;/span&gt;\nPARENT_PATH = os.path.dirname(get_script_dir())\n(x_file, x_path, x_desc) = imp.find_module(&lt;span class=&quot;hljs-string&quot;&gt;&apos;moduleX&apos;&lt;/span&gt;, [PARENT_PATH+&lt;span class=&quot;hljs-string&quot;&gt;&apos;/&apos;&lt;/span&gt;+&lt;span class=&quot;hljs-string&quot;&gt;&apos;subpackage1&apos;&lt;/span&gt;])\nmodule_x = imp.load_module(&lt;span class=&quot;hljs-string&quot;&gt;&apos;subpackage1.moduleX&apos;&lt;/span&gt;, x_file, x_path, x_desc)\n\n&lt;span class=&quot;hljs-comment&quot;&gt;# importing a function and a value&lt;/span&gt;\nfunction = module_x.my_function\nVALUE = module_x.MY_CONST\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;A cleaner approach seems to be to modify the sys.path used for loading modules as mentioned by Federico.&lt;/p&gt;\n\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;&lt;span class=&quot;hljs-comment&quot;&gt;#!/usr/bin/env python3&lt;/span&gt;\n\n&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; __name__ == &lt;span class=&quot;hljs-string&quot;&gt;&apos;__main__&apos;&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;and&lt;/span&gt; __package__ &lt;span class=&quot;hljs-keyword&quot;&gt;is&lt;/span&gt; &lt;span class=&quot;hljs-literal&quot;&gt;None&lt;/span&gt;:\n    &lt;span class=&quot;hljs-keyword&quot;&gt;from&lt;/span&gt; os &lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; sys, path\n    &lt;span class=&quot;hljs-comment&quot;&gt;# __file__ should be defined in this case&lt;/span&gt;\n    PARENT_DIR = path.dirname(path.dirname(path.abspath(__file__)))\n   sys.path.append(PARENT_DIR)\n&lt;span class=&quot;hljs-keyword&quot;&gt;from&lt;/span&gt; subpackage1.moduleX &lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; *\n&lt;/code&gt;&lt;/pre&gt;\n    ","\n&lt;p&gt;&lt;code&gt;__name__&lt;/code&gt; changes depending on whether the code in question is run in the global namespace or as part of an imported module.&lt;/p&gt;\n\n&lt;p&gt;If the code is not running in the global space, &lt;code&gt;__name__&lt;/code&gt; will be the name of the module. If it is running in global namespace -- for example, if you type it into a console, or run the module as a script using &lt;code&gt;python.exe yourscriptnamehere.py&lt;/code&gt; then &lt;code&gt;__name__&lt;/code&gt; becomes &lt;code&gt;&quot;__main__&quot;&lt;/code&gt;.  &lt;/p&gt;\n\n&lt;p&gt;You&apos;ll see a lot of python code with  &lt;code&gt;if __name__ == &apos;__main__&apos;&lt;/code&gt; is used to test whether the code is being run from the global namespace  that allows you to have a module that doubles as a script. &lt;/p&gt;\n\n&lt;p&gt;Did you try to do these imports from the console? &lt;/p&gt;\n    ","\n&lt;p&gt;Following up on what Lars has suggested I&apos;ve wrapped this approach in an experimental, new import library: &lt;a href=&quot;https://github.com/ronny-rentner/ultraimport&quot; rel=&quot;nofollow noreferrer&quot;&gt;ultraimport&lt;/a&gt;&lt;/p&gt;\n&lt;p&gt;It gives the programmer more control over imports and it allows file system based imports. Therefore, you can do relative imports from scripts. Parent package not necessary. ultraimports will always work, no matter how you run your code or what is your current working directory because ultraimport makes imports unambiguous. You don&apos;t need to change sys.path and also you don&apos;t need a try/except block to sometimes do relative imports and sometimes absolute.&lt;/p&gt;\n&lt;p&gt;You would then write in somefile.py something like:&lt;/p&gt;\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; ultraimport\nfoo = ultraimport(&lt;span class=&quot;hljs-string&quot;&gt;&apos;__dir__/foo.py&apos;&lt;/span&gt;)\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;__dir__ is the directory of somefile.py, the caller of ultraimport(). foo.py would live in the same directory as somefile.py.&lt;/p&gt;\n&lt;p&gt;One caveat when importing scripts like this is if they contain further relative imports. ultraimport has a builtin preprocessor to rewrite subsequent relative imports to ultraimports so they continue to work. Though, this is currently somewhat limited as original Python imports are ambiguous and there&apos;s only so much you can do about it.&lt;/p&gt;\n    ","\n&lt;blockquote&gt;\n  &lt;p&gt;Relative imports use a module&apos;s name attribute to determine that module&apos;s position in the package hierarchy. If the module&apos;s name does not contain any package information (e.g. it is set to &apos;main&apos;) then relative imports are resolved as if the module were a top level module, regardless of where the module is actually located on the file system.&lt;/p&gt;\n&lt;/blockquote&gt;\n\n&lt;p&gt;Wrote a little python package to PyPi that might help viewers of this question. The package acts as workaround if one wishes to be able to run python files containing imports containing upper level packages from within a package / project without being directly in the importing file&apos;s directory. &lt;a href=&quot;https://pypi.org/project/import-anywhere/&quot; rel=&quot;nofollow noreferrer&quot;&gt;https://pypi.org/project/import-anywhere/&lt;/a&gt; &lt;/p&gt;\n    ","\n&lt;p&gt;In most cases when I see the &lt;code&gt;ValueError: attempted relative import beyond top-level package&lt;/code&gt; and pull my hair out, the solution is as follows:&lt;/p&gt;\n&lt;p&gt;You need to &lt;strong&gt;step one level higher&lt;/strong&gt; in the file hierarchy!&lt;/p&gt;\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;&lt;span class=&quot;hljs-comment&quot;&gt;#dir/package/module1/foo.py&lt;/span&gt;\n\n&lt;span class=&quot;hljs-comment&quot;&gt;#dir/package/module2/bar.py&lt;/span&gt;\n&lt;span class=&quot;hljs-keyword&quot;&gt;from&lt;/span&gt; ..module1 &lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; foo\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;Importing &lt;code&gt;bar.py&lt;/code&gt; when interpreter is started in &lt;code&gt;dir/package/&lt;/code&gt; will result in error despite the import process never going beyond your current directory.&lt;/p&gt;\n&lt;p&gt;Importing &lt;code&gt;bar.py&lt;/code&gt; when interpreter is started in &lt;code&gt;dir/&lt;/code&gt; will succeed.&lt;/p&gt;\n&lt;p&gt;Similarly for unit tests:\n&lt;code&gt;python3 -m unittest discover --start-directory=.&lt;/code&gt; successfully works from &lt;code&gt;dir/&lt;/code&gt;, but not from &lt;code&gt;dir/package/&lt;/code&gt;.&lt;/p&gt;\n    "]},"randomTags":[{"name":"boolean-expression","slug":"boolean-expression"},{"name":"iife","slug":"iife"},{"name":"virtual-destructor","slug":"virtual-destructor"},{"name":"pseudo-element","slug":"pseudo-element"},{"name":"least-astonishment","slug":"least-astonishment"},{"name":"css-transitions","slug":"css-transitions"},{"name":"error-reporting","slug":"error-reporting"},{"name":"undefined-behavior","slug":"undefined-behavior"},{"name":"directory","slug":"directory"},{"name":"stack-trace","slug":"stack-trace"},{"name":"cross-browser","slug":"cross-browser"},{"name":"https","slug":"https"},{"name":"input","slug":"input"},{"name":"undefined-reference","slug":"undefined-reference"},{"name":"performance","slug":"performance"},{"name":"dhtml","slug":"dhtml"},{"name":"margin","slug":"margin"},{"name":"command","slug":"command"},{"name":"pdo","slug":"pdo"},{"name":"python-3.6","slug":"python-3.6"}]},"__N_SSG":true}