{"pageProps":{"data":{"count":1,"rows":[{"id":397,"title":"Why does printf not flush after the call unless a newline is in the format string?","slug":"why-does-printf-not-flush-after-the-call-unless-a-newline-is-in-the-format-string-1657387853407","postType":"QUESTION","createdAt":"2022-07-09T17:30:53.000Z","updatedAt":"2022-07-09T17:30:53.000Z","tags":[{"id":2138,"name":"printf","slug":"printf","createdAt":"2022-07-09T17:30:53.000Z","updatedAt":"2022-07-09T17:30:53.000Z","Questions_Tags":{"questionId":397,"tagId":2138}}]}]},"slug":"printf","page":1,"answers":{"397":["\n&lt;p&gt;The &lt;code&gt;stdout&lt;/code&gt; stream is line buffered by default, so will only display what&apos;s in the buffer after it reaches a newline (or when it&apos;s told to). You have a few options to print immediately:&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;p&gt;Print to &lt;code&gt;stderr&lt;/code&gt;instead using &lt;code&gt;fprintf&lt;/code&gt; (&lt;code&gt;stderr&lt;/code&gt; is &lt;a href=&quot;http://man7.org/linux/man-pages/man3/setbuf.3.html#DESCRIPTION&quot; rel=&quot;nofollow noreferrer&quot;&gt;unbuffered by default&lt;/a&gt;):&lt;/p&gt;\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;fprintf&lt;/span&gt;(&lt;span class=&quot;hljs-built_in&quot;&gt;stderr&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&quot;I will be printed immediately&quot;&lt;/span&gt;);\n&lt;/code&gt;&lt;/pre&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;p&gt;Flush &lt;code&gt;stdout&lt;/code&gt; whenever you need it to using &lt;code&gt;fflush&lt;/code&gt;:&lt;/p&gt;\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;Buffered, will be flushed&quot;&lt;/span&gt;);\nfflush(&lt;span class=&quot;hljs-built_in&quot;&gt;stdout&lt;/span&gt;); &lt;span class=&quot;hljs-comment&quot;&gt;// Will now print everything in the stdout buffer&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;p&gt;Disable buffering on stdout by using &lt;code&gt;setbuf&lt;/code&gt;:&lt;/p&gt;\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;setbuf(&lt;span class=&quot;hljs-built_in&quot;&gt;stdout&lt;/span&gt;, &lt;span class=&quot;hljs-literal&quot;&gt;NULL&lt;/span&gt;);\n&lt;/code&gt;&lt;/pre&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;p&gt;Or use the more flexible &lt;a href=&quot;https://en.cppreference.com/w/c/io/setvbuf&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;code&gt;setvbuf&lt;/code&gt;&lt;/a&gt;:&lt;/p&gt;\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;setvbuf(&lt;span class=&quot;hljs-built_in&quot;&gt;stdout&lt;/span&gt;, &lt;span class=&quot;hljs-literal&quot;&gt;NULL&lt;/span&gt;, _IONBF, &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;); \n&lt;/code&gt;&lt;/pre&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n    ","\n&lt;p&gt;No, it&apos;s not POSIX behaviour, it&apos;s ISO behaviour (well, it &lt;em&gt;is&lt;/em&gt; POSIX behaviour but only insofar as they conform to ISO).&lt;/p&gt;\n&lt;p&gt;Standard output is line buffered if it can be detected to refer to an interactive device, otherwise it&apos;s fully buffered. So there are situations where &lt;code&gt;printf&lt;/code&gt; won&apos;t flush, even if it gets a newline to send out, such as:&lt;/p&gt;\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;myprog &amp;gt;myfile.txt\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;This makes sense for efficiency since, if you&apos;re interacting with a user, they probably want to see every line. If you&apos;re sending the output to a file, it&apos;s most likely that there&apos;s not a user at the other end (though not impossible, they could be tailing the file). Now you &lt;em&gt;could&lt;/em&gt; argue that the user wants to see every character but there are two problems with that.&lt;/p&gt;\n&lt;p&gt;The first is that it&apos;s not very efficient. The second is that the original ANSI C mandate was to primarily codify &lt;em&gt;existing&lt;/em&gt; behaviour, rather than invent &lt;em&gt;new&lt;/em&gt; behaviour, and those design decisions were made long before ANSI started the process. Even ISO nowadays treads very carefully when changing existing rules in the standards.&lt;/p&gt;\n&lt;p&gt;As to how to deal with that, if you &lt;code&gt;fflush (stdout)&lt;/code&gt; after every output call that you want to see immediately, that will solve the problem.&lt;/p&gt;\n&lt;p&gt;Alternatively, you can use &lt;code&gt;setvbuf&lt;/code&gt; before operating on &lt;code&gt;stdout&lt;/code&gt;, to set it to unbuffered and you won&apos;t have to worry about adding all those &lt;code&gt;fflush&lt;/code&gt; lines to your code:&lt;/p&gt;\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;setvbuf (&lt;span class=&quot;hljs-built_in&quot;&gt;stdout&lt;/span&gt;, &lt;span class=&quot;hljs-literal&quot;&gt;NULL&lt;/span&gt;, _IONBF, BUFSIZ);\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;Just keep in mind that may affect performance quite a bit if you &lt;em&gt;are&lt;/em&gt; sending the output to a file. Also keep in mind that support for this is implementation-defined, not guaranteed by the standard.&lt;/p&gt;\n&lt;p&gt;ISO C99 section &lt;code&gt;7.19.3/3&lt;/code&gt; is the relevant bit:&lt;/p&gt;\n&lt;blockquote&gt;\n&lt;p&gt;When a stream is &lt;em&gt;unbuffered&lt;/em&gt;, characters are intended to appear from the source or at the destination as soon as possible. Otherwise characters may be accumulated and transmitted to or from the host environment as a block.&lt;/p&gt;\n&lt;p&gt;When a stream is &lt;em&gt;fully buffered&lt;/em&gt;, characters are intended to be transmitted to or from the host environment as a block when a buffer is filled.&lt;/p&gt;\n&lt;p&gt;When a stream is &lt;em&gt;line buffered&lt;/em&gt;, characters are intended to be transmitted to or from the host environment as a block when a new-line character is encountered.&lt;/p&gt;\n&lt;p&gt;Furthermore, characters are intended to be transmitted as a block to the host environment when a buffer is filled, when input is requested on an unbuffered stream, or when input is requested on a line buffered stream that requires the transmission of characters from the host environment.&lt;/p&gt;\n&lt;p&gt;Support for these characteristics is implementation-defined, and may be affected via the &lt;code&gt;setbuf&lt;/code&gt; and &lt;code&gt;setvbuf&lt;/code&gt; functions.&lt;/p&gt;\n&lt;/blockquote&gt;\n    ","\n&lt;p&gt;To immediately flush call &lt;code&gt;fflush(stdout)&lt;/code&gt; or &lt;code&gt;fflush(NULL)&lt;/code&gt; (&lt;code&gt;NULL&lt;/code&gt; means flush everything).&lt;/p&gt;\n    ","\n&lt;p&gt;It&apos;s probably like that because of efficiency and because if you have multiple programs writing to a single TTY, this way you don&apos;t get characters on a line interlaced. So if program A and B are outputting, you&apos;ll usually get:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;program A output\nprogram B output\nprogram B output\nprogram A output\nprogram B output\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;This stinks, but it&apos;s better than&lt;/p&gt;\n\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;proprogrgraam m AB  ououtputputt\nprproogrgram amB A  ououtputtput\nprogram B output\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Note that it isn&apos;t even guaranteed to flush on a newline, so you should flush explicitly if flushing matters to you.&lt;/p&gt;\n    ","\n&lt;p&gt;Note: Microsoft runtime libraries do not support line buffering, so &lt;code&gt;printf(&quot;will print immediately to terminal&quot;)&lt;/code&gt;:&lt;/p&gt;\n\n&lt;p&gt;&lt;a href=&quot;https://docs.microsoft.com/en-us/cpp/c-runtime-library/reference/setvbuf&quot; rel=&quot;nofollow noreferrer&quot;&gt;https://docs.microsoft.com/en-us/cpp/c-runtime-library/reference/setvbuf&lt;/a&gt;&lt;/p&gt;\n    ","\n&lt;p&gt;stdout is buffered, so will only output after a newline is printed.&lt;/p&gt;\n\n&lt;p&gt;To get immediate output, either:&lt;/p&gt;\n\n&lt;ol&gt;\n&lt;li&gt;Print to stderr.&lt;/li&gt;\n&lt;li&gt;Make stdout unbuffered.&lt;/li&gt;\n&lt;/ol&gt;\n    ","\n&lt;p&gt;by default, stdout is line buffered, stderr is none buffered and file is completely buffered.&lt;/p&gt;\n    ","\n&lt;p&gt;You can fprintf to stderr, which is unbuffered, instead.  Or you can flush stdout when you want to.  Or you can set stdout to unbuffered.&lt;/p&gt;\n    ","\n&lt;p&gt;Use &lt;code&gt;setbuf(stdout, NULL);&lt;/code&gt; to disable buffering.&lt;/p&gt;\n    ","\n&lt;p&gt;There are generally 2 levels of buffering-&lt;/p&gt;\n\n&lt;p&gt;&lt;strong&gt;1. Kernel buffer Cache (makes read/write faster)&lt;/strong&gt;&lt;/p&gt;\n\n&lt;p&gt;&lt;strong&gt;2. Buffering in I/O library (reduces no. of system calls)&lt;/strong&gt;&lt;/p&gt;\n\n&lt;p&gt;Let&apos;s take example of &lt;code&gt;fprintf and write()&lt;/code&gt;.&lt;/p&gt;\n\n&lt;p&gt;When you call &lt;code&gt;fprintf()&lt;/code&gt;, it doesn&apos;t wirte directly to the file. It first goes to stdio buffer in the program&apos;s memory. From there it is written to the kernel buffer cache by using write system call. So one way to skip I/O buffer is directly using write(). Other ways are by using &lt;code&gt;setbuff(stream,NULL)&lt;/code&gt;. This sets the buffering mode to no buffering and data is directly written to kernel buffer.\nTo forcefully make the data to be shifted to kernel buffer, we can use &quot;\\n&quot;, which in case of default buffering mode of &apos;line buffering&apos;, will flush I/O buffer.\nOr we can use &lt;code&gt;fflush(FILE *stream)&lt;/code&gt;.&lt;/p&gt;\n\n&lt;p&gt;Now we are in kernel buffer. Kernel(/OS) wants to minimise disk access time and hence it reads/writes only blocks of disk. So when a &lt;code&gt;read()&lt;/code&gt; is issued, which is a system call and can be invoked directly or through &lt;code&gt;fscanf()&lt;/code&gt;, kernel reads the disk block from disk and stores it in a buffer. After that data is copied from here to user space.&lt;/p&gt;\n\n&lt;p&gt;Similarly that &lt;code&gt;fprintf()&lt;/code&gt; data recieved from I/O buffer is written to the disk by the kernel. This makes read() write() faster.&lt;/p&gt;\n\n&lt;p&gt;Now to force the kernel to initiate a &lt;code&gt;write()&lt;/code&gt;, after which data transfer is controlled by hardware controllers, there are also some ways. We can use &lt;code&gt;O_SYNC&lt;/code&gt; or similar flags during write calls. Or we could use other functions like &lt;code&gt;fsync(),fdatasync(),sync()&lt;/code&gt; to make the kernel initiate writes as soon as data is available in the kernel buffer.&lt;/p&gt;\n    "]},"randomTags":[{"name":"pcre","slug":"pcre"},{"name":"intersection","slug":"intersection"},{"name":"module","slug":"module"},{"name":"c89","slug":"c89"},{"name":"undefined-behavior","slug":"undefined-behavior"},{"name":"form-submit","slug":"form-submit"},{"name":"browser","slug":"browser"},{"name":"xmlhttprequest","slug":"xmlhttprequest"},{"name":"local-storage","slug":"local-storage"},{"name":"https","slug":"https"},{"name":"cors","slug":"cors"},{"name":"duplicates","slug":"duplicates"},{"name":"eof","slug":"eof"},{"name":"slice","slug":"slice"},{"name":"header","slug":"header"},{"name":"user-input","slug":"user-input"},{"name":"sqliteopenhelper","slug":"sqliteopenhelper"},{"name":"path","slug":"path"},{"name":"kill","slug":"kill"},{"name":"aggregate","slug":"aggregate"}]},"__N_SSG":true}