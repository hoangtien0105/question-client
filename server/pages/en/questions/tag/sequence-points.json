{"pageProps":{"data":{"count":1,"rows":[{"id":81,"title":"Why are these constructs using pre and post-increment undefined behavior?","slug":"why-are-these-constructs-using-pre-and-post-increment-undefined-behavior-1657384520109","postType":"QUESTION","createdAt":"2022-07-09T16:35:20.000Z","updatedAt":"2022-07-09T16:35:20.000Z","tags":[{"id":301,"name":"sequence-points","slug":"sequence-points","createdAt":"2022-07-09T16:35:20.000Z","updatedAt":"2022-07-09T16:35:20.000Z","Questions_Tags":{"questionId":81,"tagId":301}}]}]},"slug":"sequence-points","page":1,"answers":{"81":["\n&lt;p&gt;C has the concept of undefined behavior, i.e. some language constructs are syntactically valid but you can&apos;t predict the behavior when the code is run.&lt;/p&gt;\n\n&lt;p&gt;As far as I know, the standard doesn&apos;t explicitly say &lt;em&gt;why&lt;/em&gt; the concept of undefined behavior exists. In my mind, it&apos;s simply because the language designers wanted there to be some leeway in the semantics, instead of i.e. requiring that all implementations handle integer overflow in the exact same way, which would very likely impose serious performance costs, they just left the behavior undefined so that if you write code that causes integer overflow, anything can happen.&lt;/p&gt;\n\n&lt;p&gt;So, with that in mind, why are these &quot;issues&quot;? The language clearly says that certain things lead to &lt;a href=&quot;http://en.wikipedia.org/wiki/Undefined_behavior&quot; rel=&quot;noreferrer&quot;&gt;undefined behavior&lt;/a&gt;. There is no problem, there is no &quot;should&quot; involved. If the undefined behavior changes when one of the involved variables is declared &lt;code&gt;volatile&lt;/code&gt;, that doesn&apos;t prove or change anything. It is &lt;em&gt;undefined&lt;/em&gt;; you cannot reason about the behavior.&lt;/p&gt;\n\n&lt;p&gt;Your most interesting-looking example, the one with&lt;/p&gt;\n\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;u = (u++);\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;is a text-book example of undefined behavior (see Wikipedia&apos;s entry on &lt;a href=&quot;http://en.wikipedia.org/wiki/Sequence_point&quot; rel=&quot;noreferrer&quot;&gt;sequence points&lt;/a&gt;).&lt;/p&gt;\n    ","\n&lt;p&gt;Most of the answers here quoted from C standard emphasizing that the behavior of these constructs are undefined. To understand &lt;strong&gt;why the behavior of these constructs are undefined&lt;/strong&gt;, let&apos;s understand these terms first in the light of C11 standard:&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;Sequenced:&lt;/strong&gt; (5.1.2.3)&lt;/p&gt;\n&lt;blockquote&gt;\n&lt;p&gt;Given any two evaluations &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt;, if &lt;code&gt;A&lt;/code&gt; is sequenced before &lt;code&gt;B&lt;/code&gt;, then the execution of &lt;code&gt;A&lt;/code&gt; shall precede the execution of &lt;code&gt;B&lt;/code&gt;.&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;p&gt;&lt;strong&gt;Unsequenced:&lt;/strong&gt;&lt;/p&gt;\n&lt;blockquote&gt;\n&lt;p&gt;If &lt;code&gt;A&lt;/code&gt; is not sequenced before or after &lt;code&gt;B&lt;/code&gt;, then &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt; are unsequenced.&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;p&gt;Evaluations can be one of two things:&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;strong&gt;value computations&lt;/strong&gt;, which work out the result of an expression; and&lt;/li&gt;\n&lt;li&gt;&lt;strong&gt;side effects&lt;/strong&gt;, which are modifications of objects.&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;&lt;strong&gt;Sequence Point:&lt;/strong&gt;&lt;/p&gt;\n&lt;blockquote&gt;\n&lt;p&gt;The presence of a sequence point between the evaluation of expressions &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt; implies that every &lt;em&gt;value computation&lt;/em&gt; and &lt;em&gt;side effect&lt;/em&gt; associated with &lt;code&gt;A&lt;/code&gt; is sequenced before every &lt;em&gt;value computation&lt;/em&gt; and &lt;em&gt;side effect&lt;/em&gt; associated with &lt;code&gt;B&lt;/code&gt;.&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;p&gt;Now coming to the question, for the expressions like&lt;/p&gt;\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;;\ni = i++;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;standard says that:&lt;/p&gt;\n&lt;h3&gt;6.5 Expressions:&lt;/h3&gt;\n&lt;blockquote&gt;\n&lt;p&gt;&lt;strong&gt;If a side effect on a scalar object is unsequenced relative to&lt;/strong&gt; either &lt;strong&gt;a different side effect on the same scalar object&lt;/strong&gt; or a value computation using the value of the same scalar object, &lt;strong&gt;the behavior is undefined&lt;/strong&gt;. [...]&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;p&gt;Therefore, the above expression invokes UB because two side effects on the same object &lt;code&gt;i&lt;/code&gt; is unsequenced relative to each other. That means it is not sequenced whether the side effect by assignment to &lt;code&gt;i&lt;/code&gt; will be done before or after the side effect by &lt;code&gt;++&lt;/code&gt;.&lt;br&gt;\nDepending on whether assignment occurs before or after the increment, different results will be produced and that&apos;s the one of the case of &lt;strong&gt;undefined behavior&lt;/strong&gt;.&lt;/p&gt;\n&lt;p&gt;Lets rename the &lt;code&gt;i&lt;/code&gt; at left of assignment be &lt;code&gt;il&lt;/code&gt; and at the right of assignment (in the expression &lt;code&gt;i++&lt;/code&gt;) be &lt;code&gt;ir&lt;/code&gt;, then the expression be like&lt;/p&gt;\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;il = ir++     &lt;span class=&quot;hljs-comment&quot;&gt;// Note that suffix l and r are used for the sake of clarity.&lt;/span&gt;\n              &lt;span class=&quot;hljs-comment&quot;&gt;// Both il and ir represents the same object.  &lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;&lt;a href=&quot;https://stackoverflow.com/a/17935062/2455888&quot;&gt;An important point&lt;/a&gt; regarding Postfix &lt;code&gt;++&lt;/code&gt; operator is that:&lt;/p&gt;\n&lt;blockquote&gt;\n&lt;p&gt;&lt;strong&gt;just because the &lt;code&gt;++&lt;/code&gt; comes after the variable does not mean that the increment happens late&lt;/strong&gt;. The increment can happen as early as the compiler likes &lt;em&gt;as long as the compiler ensures that the original value is used&lt;/em&gt;.&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;p&gt;It means the expression &lt;code&gt;il = ir++&lt;/code&gt; could be evaluated either as&lt;/p&gt;\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;temp = ir;      &lt;span class=&quot;hljs-comment&quot;&gt;// i = 1&lt;/span&gt;\nir = ir + &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;;    &lt;span class=&quot;hljs-comment&quot;&gt;// i = 2   side effect by ++ before assignment&lt;/span&gt;\nil = temp;      &lt;span class=&quot;hljs-comment&quot;&gt;// i = 1   result is 1  &lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;or&lt;/p&gt;\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;temp = ir;      &lt;span class=&quot;hljs-comment&quot;&gt;// i = 1&lt;/span&gt;\nil = temp;      &lt;span class=&quot;hljs-comment&quot;&gt;// i = 1   side effect by assignment before ++&lt;/span&gt;\nir = ir + &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;;    &lt;span class=&quot;hljs-comment&quot;&gt;// i = 2   result is 2  &lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;resulting in two different results &lt;code&gt;1&lt;/code&gt; and &lt;code&gt;2&lt;/code&gt; which depends on the sequence of side effects by assignment and &lt;code&gt;++&lt;/code&gt; and hence invokes UB.&lt;/p&gt;\n    ","\n&lt;p&gt;I think the relevant parts of the C99 standard are 6.5 Expressions, ยง2&lt;/p&gt;\n\n&lt;blockquote&gt;\n  &lt;p&gt;Between the previous and next sequence point an object shall have its stored value\n  modified at most once by the evaluation of an expression. Furthermore, the prior value\n  shall be read only to determine the value to be stored.&lt;/p&gt;\n&lt;/blockquote&gt;\n\n&lt;p&gt;and 6.5.16 Assignment operators, ยง4:&lt;/p&gt;\n\n&lt;blockquote&gt;\n  &lt;p&gt;The order of evaluation of the operands is unspecified. If an attempt is made to modify\n  the result of an assignment operator or to access it after the next sequence point, the\n  behavior is undefined. &lt;/p&gt;\n&lt;/blockquote&gt;\n    ","\n&lt;p&gt;Just compile and disassemble your line of code, if you are so inclined to know how exactly it is you get what you are getting.&lt;/p&gt;\n\n&lt;p&gt;This is what I get on my machine, together with what I think is going on:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;$ cat evil.c\n&lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;evil&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt;{\n  &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;;\n  i+= i++ + ++i;\n}\n$ gcc evil.c -c -o evil.bin\n$ gdb evil.bin\n(gdb) disassemble evil\nDump of assembler code &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; function evil:\n   &lt;span class=&quot;hljs-number&quot;&gt;0x00000000&lt;/span&gt; &amp;lt;+&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;&amp;gt;:   push   %ebp\n   &lt;span class=&quot;hljs-number&quot;&gt;0x00000001&lt;/span&gt; &amp;lt;+&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;&amp;gt;:   mov    %esp,%ebp\n   &lt;span class=&quot;hljs-number&quot;&gt;0x00000003&lt;/span&gt; &amp;lt;+&lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;&amp;gt;:   sub    $&lt;span class=&quot;hljs-number&quot;&gt;0x10&lt;/span&gt;,%esp\n   &lt;span class=&quot;hljs-number&quot;&gt;0x00000006&lt;/span&gt; &amp;lt;+&lt;span class=&quot;hljs-number&quot;&gt;6&lt;/span&gt;&amp;gt;:   movl   $&lt;span class=&quot;hljs-number&quot;&gt;0x0&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;-0x4&lt;/span&gt;(%ebp)  &lt;span class=&quot;hljs-comment&quot;&gt;// i = 0   i = 0&lt;/span&gt;\n   &lt;span class=&quot;hljs-number&quot;&gt;0x0000000d&lt;/span&gt; &amp;lt;+&lt;span class=&quot;hljs-number&quot;&gt;13&lt;/span&gt;&amp;gt;:  addl   $&lt;span class=&quot;hljs-number&quot;&gt;0x1&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;-0x4&lt;/span&gt;(%ebp)  &lt;span class=&quot;hljs-comment&quot;&gt;// i++     i = 1&lt;/span&gt;\n   &lt;span class=&quot;hljs-number&quot;&gt;0x00000011&lt;/span&gt; &amp;lt;+&lt;span class=&quot;hljs-number&quot;&gt;17&lt;/span&gt;&amp;gt;:  mov    &lt;span class=&quot;hljs-number&quot;&gt;-0x4&lt;/span&gt;(%ebp),%eax  &lt;span class=&quot;hljs-comment&quot;&gt;// j = i   i = 1  j = 1&lt;/span&gt;\n   &lt;span class=&quot;hljs-number&quot;&gt;0x00000014&lt;/span&gt; &amp;lt;+&lt;span class=&quot;hljs-number&quot;&gt;20&lt;/span&gt;&amp;gt;:  add    %eax,%eax        &lt;span class=&quot;hljs-comment&quot;&gt;// j += j  i = 1  j = 2&lt;/span&gt;\n   &lt;span class=&quot;hljs-number&quot;&gt;0x00000016&lt;/span&gt; &amp;lt;+&lt;span class=&quot;hljs-number&quot;&gt;22&lt;/span&gt;&amp;gt;:  add    %eax,&lt;span class=&quot;hljs-number&quot;&gt;-0x4&lt;/span&gt;(%ebp)  &lt;span class=&quot;hljs-comment&quot;&gt;// i += j  i = 3&lt;/span&gt;\n   &lt;span class=&quot;hljs-number&quot;&gt;0x00000019&lt;/span&gt; &amp;lt;+&lt;span class=&quot;hljs-number&quot;&gt;25&lt;/span&gt;&amp;gt;:  addl   $&lt;span class=&quot;hljs-number&quot;&gt;0x1&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;-0x4&lt;/span&gt;(%ebp)  &lt;span class=&quot;hljs-comment&quot;&gt;// i++     i = 4&lt;/span&gt;\n   &lt;span class=&quot;hljs-number&quot;&gt;0x0000001d&lt;/span&gt; &amp;lt;+&lt;span class=&quot;hljs-number&quot;&gt;29&lt;/span&gt;&amp;gt;:  leave  \n   &lt;span class=&quot;hljs-number&quot;&gt;0x0000001e&lt;/span&gt; &amp;lt;+&lt;span class=&quot;hljs-number&quot;&gt;30&lt;/span&gt;&amp;gt;:  ret\nEnd of assembler dump.\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;(I... suppose that the 0x00000014 instruction was some kind of compiler optimization?)&lt;/p&gt;\n    ","\n&lt;p&gt;The behavior can&apos;t really be explained because it invokes both &lt;a href=&quot;http://en.wikipedia.org/wiki/Unspecified_behavior&quot; rel=&quot;noreferrer&quot;&gt;unspecified behavior&lt;/a&gt; and &lt;a href=&quot;http://en.wikipedia.org/wiki/Undefined_behavior&quot; rel=&quot;noreferrer&quot;&gt;undefined behavior&lt;/a&gt;, so we can not make any general predictions about this code, although if you read &lt;em&gt;Olve Maudal&apos;s&lt;/em&gt; work such as &lt;a href=&quot;http://www.slideshare.net/olvemaudal/deep-c&quot; rel=&quot;noreferrer&quot;&gt;Deep C&lt;/a&gt; and &lt;a href=&quot;http://www.pvv.org/~oma/UnspecifiedAndUndefined_ACCU_Apr2013.pdf&quot; rel=&quot;noreferrer&quot;&gt;Unspecified and Undefined&lt;/a&gt; sometimes you can make good guesses in very specific cases with a specific compiler and environment but please don&apos;t do that anywhere near production.&lt;/p&gt;\n\n&lt;p&gt;So moving on to &lt;em&gt;unspecified behavior&lt;/em&gt;, in &lt;a href=&quot;http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1256.pdf&quot; rel=&quot;noreferrer&quot;&gt;draft c99 standard&lt;/a&gt; section&lt;code&gt;6.5&lt;/code&gt; paragraph &lt;em&gt;3&lt;/em&gt; says(&lt;em&gt;emphasis mine&lt;/em&gt;):&lt;/p&gt;\n\n&lt;blockquote&gt;\n  &lt;p&gt;The grouping of operators and operands is indicated by the syntax.74) Except as specified\n  later (for the function-call (), &amp;amp;&amp;amp;, ||, ?:, and comma operators), &lt;strong&gt;the order of evaluation of subexpressions and the order in which side effects take place are both unspecified.&lt;/strong&gt;&lt;/p&gt;\n&lt;/blockquote&gt;\n\n&lt;p&gt;So when we have a line like this:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;i = i++ + ++i;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;we do not know whether &lt;code&gt;i++&lt;/code&gt; or &lt;code&gt;++i&lt;/code&gt; will be evaluated first. This is mainly to give the compiler &lt;a href=&quot;https://stackoverflow.com/a/12540468/1708801&quot;&gt;better options for optimization&lt;/a&gt;.&lt;/p&gt;\n\n&lt;p&gt;We also have &lt;em&gt;undefined behavior&lt;/em&gt; here as well since the program is modifying variables(&lt;code&gt;i&lt;/code&gt;, &lt;code&gt;u&lt;/code&gt;, etc..) more than once between &lt;a href=&quot;http://en.wikipedia.org/wiki/Sequence_point&quot; rel=&quot;noreferrer&quot;&gt;sequence points&lt;/a&gt;. From draft standard section &lt;code&gt;6.5&lt;/code&gt; paragraph &lt;em&gt;2&lt;/em&gt;(&lt;em&gt;emphasis mine&lt;/em&gt;):&lt;/p&gt;\n\n&lt;blockquote&gt;\n  &lt;p&gt;&lt;strong&gt;Between the previous and next sequence point an object shall have its stored value\n  modified at most once&lt;/strong&gt; by the evaluation of an expression. Furthermore, &lt;strong&gt;the prior value\n  shall be read only to determine the value to be stored&lt;/strong&gt;.&lt;/p&gt;\n&lt;/blockquote&gt;\n\n&lt;p&gt;it cites the following code examples as being undefined:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;i = ++i + &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;;\na[i++] = i; \n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;In all these examples the code is attempting to modify an object more than once in the same sequence point, which will end with the &lt;code&gt;;&lt;/code&gt; in each one of these cases:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;i = i++ + ++i;\n^   ^       ^\n\ni = (i++);\n^    ^\n\nu = u++ + ++u;\n^   ^       ^\n\nu = (u++);\n^    ^\n\nv = v++ + ++v;\n^   ^       ^\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;&lt;em&gt;Unspecified behavior&lt;/em&gt; is defined in the &lt;a href=&quot;http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1256.pdf&quot; rel=&quot;noreferrer&quot;&gt;draft c99 standard&lt;/a&gt; in section &lt;code&gt;3.4.4&lt;/code&gt; as:&lt;/p&gt;\n\n&lt;blockquote&gt;\n  &lt;p&gt;use of an unspecified value, or other behavior where this International Standard provides\n  two or more possibilities and imposes no further requirements on which is chosen in any\n  instance&lt;/p&gt;\n&lt;/blockquote&gt;\n\n&lt;p&gt;and &lt;em&gt;undefined behavior&lt;/em&gt; is defined in section &lt;code&gt;3.4.3&lt;/code&gt; as:&lt;/p&gt;\n\n&lt;blockquote&gt;\n  &lt;p&gt;behavior, upon use of a nonportable or erroneous program construct or of erroneous data,\n  for which this International Standard imposes no requirements&lt;/p&gt;\n&lt;/blockquote&gt;\n\n&lt;p&gt;and notes that:&lt;/p&gt;\n\n&lt;blockquote&gt;\n  &lt;p&gt;Possible undefined behavior ranges from ignoring the situation completely with unpredictable results, to behaving during translation or program execution in a documented manner characteristic of the environment (with or without the issuance of a diagnostic message), to terminating a translation or execution (with the issuance of a diagnostic message).&lt;/p&gt;\n&lt;/blockquote&gt;\n    ","\n&lt;p&gt;Another way of answering this, rather than getting bogged down in arcane details of sequence points and undefined behavior, is simply to ask, &lt;em&gt;what are they supposed to mean?&lt;/em&gt; &lt;em&gt;What was the programmer trying to do?&lt;/em&gt;&lt;/p&gt;\n\n&lt;p&gt;The first fragment asked about, &lt;code&gt;i = i++ + ++i&lt;/code&gt;, is pretty clearly insane in my book.  No one would ever write it in a real program, it&apos;s not obvious what it does, there&apos;s no conceivable algorithm someone could have been trying to code that would have resulted in this particular contrived sequence of operations.  And since it&apos;s not obvious to you and me what it&apos;s supposed to do, it&apos;s fine in my book if the compiler can&apos;t figure out what it&apos;s supposed to do, either.&lt;/p&gt;\n\n&lt;p&gt;The second fragment, &lt;code&gt;i = i++&lt;/code&gt;, is a little easier to understand.  Someone is clearly trying to increment i, and assign the result back to i.  But there are a couple ways of doing this in C.  The most basic way to add 1 to i, and assign the result back to i, is the same in almost any programming language:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;i = i + &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;C, of course, has a handy shortcut:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;i++\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;This means, &quot;add 1 to i, and assign the result back to i&quot;.  So if we construct a hodgepodge of the two, by writing&lt;/p&gt;\n\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;i = i++\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;what we&apos;re really saying is &quot;add 1 to i, and assign the result back to i, and assign the result back to i&quot;.  We&apos;re confused, so it doesn&apos;t bother me too much if the compiler gets confused, too.&lt;/p&gt;\n\n&lt;p&gt;Realistically, the only time these crazy expressions get written is when people are using them as artificial examples of how ++ is supposed to work.  And of course it is important to understand how ++ works.  But one practical rule for using ++ is, &quot;If it&apos;s not obvious what an expression using ++ means, don&apos;t write it.&quot;&lt;/p&gt;\n\n&lt;p&gt;We used to spend countless hours on comp.lang.c discussing expressions like these and &lt;em&gt;why&lt;/em&gt; they&apos;re undefined.  Two of my longer answers, that try to really explain why, are archived on the web:&lt;/p&gt;\n\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=&quot;http://www.eskimo.com/~scs/readings/undef.950321.html&quot; rel=&quot;noreferrer&quot;&gt;Why doesn&apos;t the Standard define what these do?&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=&quot;http://www.eskimo.com/~scs/readings/precvsooe.960725.html&quot; rel=&quot;noreferrer&quot;&gt;Doesn&apos;t operator precedence determine the order of evaluation?&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n\n&lt;p&gt;See also &lt;a href=&quot;http://c-faq.com/expr/seqpoints.html&quot; rel=&quot;noreferrer&quot;&gt;question 3.8&lt;/a&gt; and the rest of the questions in &lt;a href=&quot;http://c-faq.com/expr/index.html&quot; rel=&quot;noreferrer&quot;&gt;section 3&lt;/a&gt; of the &lt;a href=&quot;http://c-faq.com/&quot; rel=&quot;noreferrer&quot;&gt;C FAQ list&lt;/a&gt;.&lt;/p&gt;\n    ","\n&lt;p&gt;Often this question is linked as a duplicate of questions related to code like&lt;/p&gt;\n\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;%d %d\\n&quot;&lt;/span&gt;, i, i++);\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;or &lt;/p&gt;\n\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;%d %d\\n&quot;&lt;/span&gt;, ++i, i++);\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;or similar variants.&lt;/p&gt;\n\n&lt;p&gt;While this is also &lt;a href=&quot;https://en.wikipedia.org/wiki/Undefined_behavior&quot; rel=&quot;noreferrer&quot;&gt;&lt;em&gt;undefined behaviour&lt;/em&gt;&lt;/a&gt; as stated already, there are subtle differences when &lt;code&gt;printf()&lt;/code&gt; is involved when comparing to a statement such as:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;x = i++ + i++;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;hr&gt;\n\n&lt;p&gt;In the following statement:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;%d %d\\n&quot;&lt;/span&gt;, ++i, i++);\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;the &lt;a href=&quot;http://en.cppreference.com/w/c/language/eval_order&quot; rel=&quot;noreferrer&quot;&gt;&lt;em&gt;order of evaluation&lt;/em&gt;&lt;/a&gt; of arguments in &lt;code&gt;printf()&lt;/code&gt; is &lt;a href=&quot;https://en.wikipedia.org/wiki/Unspecified_behavior&quot; rel=&quot;noreferrer&quot;&gt;&lt;em&gt;unspecified&lt;/em&gt;&lt;/a&gt;. That means, expressions &lt;code&gt;i++&lt;/code&gt; and &lt;code&gt;++i&lt;/code&gt; could be evaluated in any order. &lt;a href=&quot;http://port70.net/~nsz/c/c11/n1570.html&quot; rel=&quot;noreferrer&quot;&gt;C11 standard&lt;/a&gt; has some relevant descriptions on this:&lt;/p&gt;\n\n&lt;p&gt;&lt;strong&gt;Annex J, unspecified behaviours&lt;/strong&gt;&lt;/p&gt;\n\n&lt;blockquote&gt;\n  &lt;p&gt;The order in which the function designator, arguments, and\n  subexpressions within the arguments are evaluated in a function call\n  (6.5.2.2).&lt;/p&gt;\n&lt;/blockquote&gt;\n\n&lt;p&gt;&lt;strong&gt;3.4.4, unspecified behavior&lt;/strong&gt;&lt;/p&gt;\n\n&lt;blockquote&gt;\n  &lt;p&gt;Use of an unspecified value, or other behavior where this\n  International Standard provides two or more possibilities and imposes\n  no further requirements on which is chosen in any instance.&lt;/p&gt;\n  \n  &lt;p&gt;EXAMPLE An example of unspecified behavior is the order in which the\n  arguments to a function are evaluated.&lt;/p&gt;\n&lt;/blockquote&gt;\n\n&lt;p&gt;The &lt;em&gt;unspecified behaviour&lt;/em&gt; itself is NOT an issue. Consider this example:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;%d %d\\n&quot;&lt;/span&gt;, ++x, y++);\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;This too has &lt;em&gt;unspecified behaviour&lt;/em&gt; because the order of evaluation of &lt;code&gt;++x&lt;/code&gt; and &lt;code&gt;y++&lt;/code&gt; is unspecified. But it&apos;s perfectly legal and valid statement. There&apos;s &lt;em&gt;no&lt;/em&gt; undefined behaviour in this statement. Because the modifications (&lt;code&gt;++x&lt;/code&gt; and &lt;code&gt;y++&lt;/code&gt;) are done to &lt;em&gt;distinct&lt;/em&gt; objects.&lt;/p&gt;\n\n&lt;p&gt;What renders the following statement &lt;/p&gt;\n\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;%d %d\\n&quot;&lt;/span&gt;, ++i, i++);\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;as &lt;em&gt;undefined behaviour&lt;/em&gt; is the fact that these two expressions modify the &lt;em&gt;same&lt;/em&gt; object &lt;code&gt;i&lt;/code&gt; without an intervening &lt;a href=&quot;https://en.wikipedia.org/wiki/Sequence_point&quot; rel=&quot;noreferrer&quot;&gt;&lt;em&gt;sequence point&lt;/em&gt;&lt;/a&gt;.&lt;/p&gt;\n\n&lt;hr&gt;\n\n&lt;p&gt;Another detail is that the &lt;em&gt;comma&lt;/em&gt; involved in the printf() call is a &lt;em&gt;separator&lt;/em&gt;, not the &lt;a href=&quot;https://en.wikipedia.org/wiki/Comma_operator&quot; rel=&quot;noreferrer&quot;&gt;&lt;em&gt;comma operator&lt;/em&gt;&lt;/a&gt;.&lt;/p&gt;\n\n&lt;p&gt;This is an important distinction because the &lt;em&gt;comma operator&lt;/em&gt; does introduce a &lt;em&gt;sequence point&lt;/em&gt; between the evaluation of their operands, which makes the following legal:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt;;\n&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; j;\n\nj = (++i, i++);  &lt;span class=&quot;hljs-comment&quot;&gt;// No undefined behaviour here because the comma operator &lt;/span&gt;\n                 &lt;span class=&quot;hljs-comment&quot;&gt;// introduces a sequence point between &apos;++i&apos; and &apos;i++&apos;&lt;/span&gt;\n\n&lt;span class=&quot;hljs-built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;i=%d j=%d\\n&quot;&lt;/span&gt;,i, j); &lt;span class=&quot;hljs-comment&quot;&gt;// prints: i=7 j=6&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;The comma operator evaluates its operands left-to-right and yields only the value of the last operand. So in &lt;code&gt;j = (++i, i++);&lt;/code&gt;, &lt;code&gt;++i&lt;/code&gt; increments &lt;code&gt;i&lt;/code&gt; to &lt;code&gt;6&lt;/code&gt; and &lt;code&gt;i++&lt;/code&gt; yields old value of &lt;code&gt;i&lt;/code&gt; (&lt;code&gt;6&lt;/code&gt;) which is assigned to &lt;code&gt;j&lt;/code&gt;. Then &lt;code&gt;i&lt;/code&gt; becomes &lt;code&gt;7&lt;/code&gt; due to post-increment.&lt;/p&gt;\n\n&lt;p&gt;So if the &lt;em&gt;comma&lt;/em&gt; in the function call were to be a comma operator then &lt;/p&gt;\n\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;%d %d\\n&quot;&lt;/span&gt;, ++i, i++);\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;will not be a problem. But it invokes &lt;em&gt;undefined behaviour&lt;/em&gt; because the &lt;em&gt;comma&lt;/em&gt; here is a &lt;em&gt;separator&lt;/em&gt;.&lt;/p&gt;\n\n&lt;hr&gt;\n\n&lt;p&gt;For those who are new to &lt;em&gt;undefined behaviour&lt;/em&gt; would benefit from reading &lt;a href=&quot;http://blog.llvm.org/2011/05/what-every-c-programmer-should-know.html&quot; rel=&quot;noreferrer&quot;&gt;What Every C Programmer Should Know About Undefined Behavior&lt;/a&gt;  to understand the concept and many other variants of undefined behaviour in C.&lt;/p&gt;\n\n&lt;p&gt;This post: &lt;a href=&quot;https://stackoverflow.com/a/4105123/1275169&quot;&gt;Undefined, unspecified and implementation-defined behavior&lt;/a&gt; is also relevant.&lt;/p&gt;\n    ","\n&lt;p&gt;While it is unlikely that any compilers and processors would actually do so, it would be legal, under the C standard, for the compiler to implement &quot;i++&quot; with the sequence:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;In a single operation, read `i` and lock it to prevent access until further notice\n&lt;span class=&quot;hljs-title function_&quot;&gt;Compute&lt;/span&gt; &lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;+read_value)&lt;/span&gt;\nIn a single operation, unlock `i` and store the computed value\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;While I don&apos;t think any processors support the hardware to allow such a thing to be done efficiently, one can easily imagine situations where such behavior would make multi-threaded code easier (e.g. it would guarantee that if two threads try to perform the above sequence simultaneously, &lt;code&gt;i&lt;/code&gt; would get incremented by two) and it&apos;s not totally inconceivable that some future processor might provide a feature something like that.&lt;/p&gt;\n\n&lt;p&gt;If the compiler were to write &lt;code&gt;i++&lt;/code&gt; as indicated above (legal under the standard) and were to intersperse the above instructions throughout the evaluation of the overall expression (also legal), and if it didn&apos;t happen to notice that one of the other instructions happened to access &lt;code&gt;i&lt;/code&gt;, it would be possible (and legal) for the compiler to generate a sequence of instructions that would deadlock.  To be sure, a compiler would almost certainly detect the problem in the case where the same variable &lt;code&gt;i&lt;/code&gt; is used in both places, but if a routine accepts references to two pointers &lt;code&gt;p&lt;/code&gt; and &lt;code&gt;q&lt;/code&gt;, and uses &lt;code&gt;(*p)&lt;/code&gt; and &lt;code&gt;(*q)&lt;/code&gt; in the above expression (rather than using &lt;code&gt;i&lt;/code&gt; twice) the compiler would not be required to recognize or avoid the deadlock that would occur if the same object&apos;s address were passed for both &lt;code&gt;p&lt;/code&gt; and &lt;code&gt;q&lt;/code&gt;.&lt;/p&gt;\n    ","\n&lt;p&gt;While the &lt;strong&gt;syntax&lt;/strong&gt; of the expressions like &lt;code&gt;a = a++&lt;/code&gt; or &lt;code&gt;a++ + a++&lt;/code&gt; is legal, the &lt;strong&gt;behaviour&lt;/strong&gt; of these constructs is &lt;strong&gt;undefined&lt;/strong&gt; because a &lt;strong&gt;&lt;em&gt;shall&lt;/em&gt;&lt;/strong&gt; in C standard is not obeyed. &lt;a href=&quot;http://port70.net/~nsz/c/c99/n1256.html#6.5p2&quot; rel=&quot;noreferrer&quot;&gt;C99 6.5p2&lt;/a&gt;:&lt;/p&gt;\n\n&lt;blockquote&gt;\n  &lt;ol start=&quot;2&quot;&gt;\n  &lt;li&gt;Between the previous and next sequence point an object shall have its stored value modified at most once by the evaluation of an expression. [72] Furthermore, the prior value shall be read only to determine the value to be stored [73]&lt;/li&gt;\n  &lt;/ol&gt;\n&lt;/blockquote&gt;\n\n&lt;p&gt;With &lt;a href=&quot;http://port70.net/~nsz/c/c99/n1256.html#note73&quot; rel=&quot;noreferrer&quot;&gt;footnote 73&lt;/a&gt; further clarifying that&lt;/p&gt;\n\n&lt;blockquote&gt;\n  &lt;ol start=&quot;73&quot;&gt;\n  &lt;li&gt;&lt;p&gt;This paragraph renders undefined statement expressions such as&lt;/p&gt;\n\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;i = ++i + &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;;\na[i++] = i;\n&lt;/code&gt;&lt;/pre&gt;\n  \n  &lt;p&gt;while allowing&lt;/p&gt;\n\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;i = i + &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;;\na[i] = i;\n&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;\n  &lt;/ol&gt;\n&lt;/blockquote&gt;\n\n&lt;p&gt;The various sequence points are listed in Annex C of &lt;a href=&quot;http://port70.net/~nsz/c/c11/n1570.html#C&quot; rel=&quot;noreferrer&quot;&gt;C11&lt;/a&gt; (and &lt;a href=&quot;http://port70.net/~nsz/c/c99/n1256.html#C&quot; rel=&quot;noreferrer&quot;&gt;C99&lt;/a&gt;):&lt;/p&gt;\n\n&lt;blockquote&gt;\n  &lt;ol&gt;\n  &lt;li&gt;&lt;p&gt;The following are the sequence points described in 5.1.2.3:&lt;/p&gt;\n  \n  &lt;ul&gt;\n  &lt;li&gt;Between the evaluations of the function designator and actual arguments in a function call and the actual call. (6.5.2.2).&lt;/li&gt;\n  &lt;li&gt;Between the evaluations of the first and second operands of the following operators: logical AND &amp;amp;&amp;amp; (6.5.13); logical OR || (6.5.14); comma , (6.5.17).&lt;/li&gt;\n  &lt;li&gt;Between the evaluations of the first operand of the conditional ? : operator and whichever of the second and third operands is evaluated (6.5.15).&lt;/li&gt;\n  &lt;li&gt;The end of a full declarator: declarators (6.7.6);&lt;/li&gt;\n  &lt;li&gt;Between the evaluation of a full expression and the next full expression to be evaluated. The following are full expressions: an initializer that is not part of a compound literal (6.7.9); the expression in an expression statement (6.8.3); the controlling expression of a selection statement (if or switch) (6.8.4); the controlling expression of a while or do statement (6.8.5); each of the (optional) expressions of a for statement (6.8.5.3); the (optional) expression in a return statement (6.8.6.4).&lt;/li&gt;\n  &lt;li&gt;Immediately before a library function returns (7.1.4).&lt;/li&gt;\n  &lt;li&gt;After the actions associated with each formatted input/output function conversion specifier (7.21.6, 7.29.2).&lt;/li&gt;\n  &lt;li&gt;Immediately before and immediately after each call to a comparison function, and also between any call to a comparison function and any movement of the objects passed as arguments to that call (7.22.5). &lt;/li&gt;\n  &lt;/ul&gt;&lt;/li&gt;\n  &lt;/ol&gt;\n&lt;/blockquote&gt;\n\n&lt;p&gt;The wording of the same &lt;a href=&quot;http://port70.net/~nsz/c/c11/n1570.html#6.5p2&quot; rel=&quot;noreferrer&quot;&gt;paragraph in C11&lt;/a&gt; is:&lt;/p&gt;\n\n&lt;blockquote&gt;\n  &lt;ol start=&quot;2&quot;&gt;\n  &lt;li&gt;If a side effect on a scalar object is unsequenced relative to either a different side effect on the same scalar object or a value computation using the value of the same scalar object, the behavior is undefined. If there are multiple allowable orderings of the subexpressions of an expression, the behavior is undefined if such an unsequenced side effect occurs in any of the orderings.84) &lt;/li&gt;\n  &lt;/ol&gt;\n&lt;/blockquote&gt;\n\n&lt;hr&gt;\n\n&lt;p&gt;You can detect such errors in a program by for example using a recent version of GCC with &lt;code&gt;-Wall&lt;/code&gt; and &lt;code&gt;-Werror&lt;/code&gt;, and then GCC will outright refuse to compile your program. The following is the output of gcc (Ubuntu 6.2.0-5ubuntu12) 6.2.0 20161005:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;% gcc plusplus.c -Wall -Werror -pedantic\nplusplus.c: In function main:\nplusplus.c:&lt;span class=&quot;hljs-number&quot;&gt;6&lt;/span&gt;:&lt;span class=&quot;hljs-number&quot;&gt;6&lt;/span&gt;: error: operation on i may be undefined [-Werror=sequence-point]\n    i = i++ + ++i;\n    ~~^~~~~~~~~~~\nplusplus.c:&lt;span class=&quot;hljs-number&quot;&gt;6&lt;/span&gt;:&lt;span class=&quot;hljs-number&quot;&gt;6&lt;/span&gt;: error: operation on i may be undefined [-Werror=sequence-point]\nplusplus.c:&lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;:&lt;span class=&quot;hljs-number&quot;&gt;6&lt;/span&gt;: error: operation on i may be undefined [-Werror=sequence-point]\n    i = (i++);\n    ~~^~~~~~~\nplusplus.c:&lt;span class=&quot;hljs-number&quot;&gt;14&lt;/span&gt;:&lt;span class=&quot;hljs-number&quot;&gt;6&lt;/span&gt;: error: operation on u may be undefined [-Werror=sequence-point]\n    u = u++ + ++u;\n    ~~^~~~~~~~~~~\nplusplus.c:&lt;span class=&quot;hljs-number&quot;&gt;14&lt;/span&gt;:&lt;span class=&quot;hljs-number&quot;&gt;6&lt;/span&gt;: error: operation on u may be undefined [-Werror=sequence-point]\nplusplus.c:&lt;span class=&quot;hljs-number&quot;&gt;18&lt;/span&gt;:&lt;span class=&quot;hljs-number&quot;&gt;6&lt;/span&gt;: error: operation on u may be undefined [-Werror=sequence-point]\n    u = (u++);\n    ~~^~~~~~~\nplusplus.c:&lt;span class=&quot;hljs-number&quot;&gt;22&lt;/span&gt;:&lt;span class=&quot;hljs-number&quot;&gt;6&lt;/span&gt;: error: operation on v may be undefined [-Werror=sequence-point]\n    v = v++ + ++v;\n    ~~^~~~~~~~~~~\nplusplus.c:&lt;span class=&quot;hljs-number&quot;&gt;22&lt;/span&gt;:&lt;span class=&quot;hljs-number&quot;&gt;6&lt;/span&gt;: error: operation on v may be undefined [-Werror=sequence-point]\ncc1: all warnings being treated as errors\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;The important part is to know &lt;a href=&quot;https://stackoverflow.com/questions/3575350/sequence-points-in-c&quot;&gt;what a sequence point is -- and &lt;em&gt;what is&lt;/em&gt; a sequence point and what &lt;em&gt;isn&apos;t&lt;/em&gt;&lt;/a&gt;. For example the &lt;em&gt;comma operator&lt;/em&gt; is a sequence point, so&lt;/p&gt;\n\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;j = (i ++, ++ i);\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;is well-defined, and will increment &lt;code&gt;i&lt;/code&gt; by one, yielding the old value, discard that value; then at comma operator, settle the side effects; and then increment &lt;code&gt;i&lt;/code&gt; by one, and the resulting value becomes the value of the expression - i.e. this is just a contrived way to write &lt;code&gt;j = (i += 2)&lt;/code&gt; which is yet again a &quot;clever&quot; way to write&lt;/p&gt;\n\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;i += &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;;\nj = i;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;However, the &lt;code&gt;,&lt;/code&gt; in function argument lists is &lt;em&gt;not&lt;/em&gt; a comma operator, and there is no sequence point between evaluations of distinct arguments; instead their evaluations are unsequenced with regard to each other; so the function call &lt;/p&gt;\n\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;;\n&lt;span class=&quot;hljs-built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;%d %d\\n&quot;&lt;/span&gt;, i++, ++i, i);\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;has &lt;em&gt;undefined behaviour&lt;/em&gt; because &lt;strong&gt;there is no sequence point between the evaluations of &lt;code&gt;i++&lt;/code&gt; and &lt;code&gt;++i&lt;/code&gt; in function arguments&lt;/strong&gt;, and the value of &lt;code&gt;i&lt;/code&gt; is therefore modified twice, by both &lt;code&gt;i++&lt;/code&gt; and &lt;code&gt;++i&lt;/code&gt;, between the previous and the next sequence point.&lt;/p&gt;\n    ","\n&lt;p&gt;The C standard says that a variable should only be assigned at most once between two sequence points. A semi-colon for instance is a sequence point. &lt;br&gt;\nSo every statement of the form:&lt;br&gt;&lt;/p&gt;\n\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;i = i++;\ni = i++ + ++i;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;and so on violate that rule. The standard also says that behavior is undefined and not unspecified. Some compilers do detect these and produce some result but this is not per standard.&lt;br&gt;&lt;/p&gt;\n\n&lt;p&gt;However, two different variables can be incremented between two sequence points.&lt;br&gt;&lt;/p&gt;\n\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;while&lt;/span&gt;(*src++ = *dst++);\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;The above is a common coding practice while copying/analysing strings.&lt;/p&gt;\n    ","\n&lt;p&gt;In &lt;a href=&quot;https://stackoverflow.com/questions/29505280/incrementing-array-index-in-c&quot;&gt;https://stackoverflow.com/questions/29505280/incrementing-array-index-in-c&lt;/a&gt; someone asked about a statement like:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; k[] = {&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;4&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;6&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;7&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;8&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;9&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;};\n&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;;\n&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; num;\nnum = k[++i+k[++i]] + k[++i];\n&lt;span class=&quot;hljs-built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;%d&quot;&lt;/span&gt;, num);\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;which prints 7... the OP expected it to print 6.&lt;/p&gt;\n\n&lt;p&gt;The &lt;code&gt;++i&lt;/code&gt; increments aren&apos;t guaranteed to all complete before the rest of the calculations. In fact, different compilers will get different results here.  In the example you provided, the first 2 &lt;code&gt;++i&lt;/code&gt; executed, then the values of &lt;code&gt;k[]&lt;/code&gt; were read, then the last &lt;code&gt;++i&lt;/code&gt; then &lt;code&gt;k[]&lt;/code&gt;.&lt;/p&gt;\n\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;num = k[i+&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;]+k[i+&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;] + k[i+&lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;];\ni += &lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Modern compilers will optimize this very well. In fact, possibly better than the code you originally wrote (assuming it had worked the way you had hoped).&lt;/p&gt;\n    ","\n&lt;p&gt;Your question was probably not, &quot;Why are these constructs undefined behavior in C?&quot;.  Your question was probably, &quot;Why did this code (using &lt;code&gt;++&lt;/code&gt;) not give me the value I expected?&quot;, and someone marked your question as a duplicate, and sent you here.&lt;/p&gt;\n&lt;p&gt;&lt;em&gt;This&lt;/em&gt; answer tries to answer that question: why did your code not give you the answer you expected, and how can you learn to recognize (and avoid) expressions that will not work as expected.&lt;/p&gt;\n&lt;p&gt;I assume you&apos;ve heard the basic definition of C&apos;s &lt;code&gt;++&lt;/code&gt; and &lt;code&gt;--&lt;/code&gt; operators by now, and how the prefix form &lt;code&gt;++x&lt;/code&gt; differs from the postfix form &lt;code&gt;x++&lt;/code&gt;.  But these operators are hard to think about, so to make sure you understood, perhaps you wrote a tiny little test program involving something like&lt;/p&gt;\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; x = &lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt;;\n&lt;span class=&quot;hljs-built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;%d %d %d\\n&quot;&lt;/span&gt;, x, ++x, x++);\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;But, to your surprise, this program did &lt;em&gt;not&lt;/em&gt; help you understand  it printed some strange, inexplicable output, suggesting that maybe &lt;code&gt;++&lt;/code&gt; does something completely different, not at all what you thought it did.&lt;/p&gt;\n&lt;p&gt;Or, perhaps you&apos;re looking at a hard-to-understand expression like&lt;/p&gt;\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; x = &lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt;;\nx = x++ + ++x;\n&lt;span class=&quot;hljs-built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;%d\\n&quot;&lt;/span&gt;, x);\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;Perhaps someone gave you that code as a puzzle.  This code also makes no sense, especially if you run it  and if you compile and run it under two different compilers, you&apos;re likely to get two different answers!  What&apos;s up with that?  Which answer is correct?  (And the answer is that both of them are, or neither of them are.)&lt;/p&gt;\n&lt;p&gt;As you&apos;ve heard by now, these expressions are &lt;em&gt;undefined&lt;/em&gt;, which means that the C language makes no guarantee about what they&apos;ll do.  This is a strange and unsettling result, because you probably thought that any program you could write, as long as it compiled and ran, would generate a unique, well-defined output.  But in the case of undefined behavior, that&apos;s not so.&lt;/p&gt;\n&lt;p&gt;What makes an expression undefined?  Are expressions involving &lt;code&gt;++&lt;/code&gt; and &lt;code&gt;--&lt;/code&gt; always undefined?  Of course not: these are useful operators, and if you use them properly, they&apos;re perfectly well-defined.&lt;/p&gt;\n&lt;p&gt;For the expressions we&apos;re talking about, what makes them undefined is when there&apos;s too much going on at once, when we can&apos;t tell what order things will happen in, but when the order matters to the result we&apos;ll get.&lt;/p&gt;\n&lt;p&gt;Let&apos;s go back to the two examples I&apos;ve used in this answer.  When I wrote&lt;/p&gt;\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;%d %d %d\\n&quot;&lt;/span&gt;, x, ++x, x++);\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;the question is, before actually calling &lt;code&gt;printf&lt;/code&gt;, does the compiler compute the value of &lt;code&gt;x&lt;/code&gt; first, or &lt;code&gt;x++&lt;/code&gt;, or maybe &lt;code&gt;++x&lt;/code&gt;?  But it turns out &lt;em&gt;we don&apos;t know&lt;/em&gt;.  There&apos;s no rule in C which says that the arguments to a function get evaluated left-to-right, or right-to-left, or in some other order.  So we can&apos;t say whether the compiler will do &lt;code&gt;x&lt;/code&gt; first, then &lt;code&gt;++x&lt;/code&gt;, then &lt;code&gt;x++&lt;/code&gt;, or &lt;code&gt;x++&lt;/code&gt; then &lt;code&gt;++x&lt;/code&gt; then &lt;code&gt;x&lt;/code&gt;, or some other order.  But the order clearly matters, because depending on which order the compiler uses, we&apos;ll clearly get a different series of numbers printed out.&lt;/p&gt;\n&lt;p&gt;What about this crazy expression?&lt;/p&gt;\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;x = x++ + ++x;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;The problem with this expression is that it contains three different attempts to modify the value of &lt;code&gt;x&lt;/code&gt;: (1) the &lt;code&gt;x++&lt;/code&gt; part tries to take &lt;code&gt;x&lt;/code&gt;&apos;s value, add 1, store the new value in &lt;code&gt;x&lt;/code&gt;, and return the old value; (2) the &lt;code&gt;++x&lt;/code&gt; part tries to take &lt;code&gt;x&lt;/code&gt;&apos;s value, add 1, store the new value in &lt;code&gt;x&lt;/code&gt;, and return the new value; and (3) the &lt;code&gt;x =&lt;/code&gt; part tries to assign the sum of the other two back to &lt;code&gt;x&lt;/code&gt;.  Which of those three attempted assignments will &quot;win&quot;?  Which of the three values will actually determine the final value of &lt;code&gt;x&lt;/code&gt;?  Again, and perhaps surprisingly, there&apos;s no rule in C to tell us.&lt;/p&gt;\n&lt;p&gt;You might imagine that precedence or associativity or left-to-right evaluation tells you what order things happen in, but they do not.  You may not believe me, but please take my word for it, and I&apos;ll say it again: precedence and associativity do not determine every aspect of the evaluation order of an expression in C.  In particular, if within one expression there are multiple different spots where we try to assign a new value to something like &lt;code&gt;x&lt;/code&gt;, precedence and associativity do &lt;em&gt;not&lt;/em&gt; tell us which of those attempts happens first, or last, or anything.&lt;/p&gt;\n&lt;hr&gt;\n&lt;p&gt;So with all that background and introduction out of the way, if you want to make sure that all your programs are well-defined, which expressions can you write, and which ones can you not write?&lt;/p&gt;\n&lt;p&gt;These expressions are all fine:&lt;/p&gt;\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;y = x++;\nz = x++ + y++;\nx = x + &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;;\nx = a[i++];\nx = a[i++] + b[j++];\nx[i++] = a[j++] + b[k++];\nx = *p++;\nx = *p++ + *q++;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;These expressions are all undefined:&lt;/p&gt;\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;x = x++;\nx = x++ + ++x;\ny = x + x++;\na[i] = i++;\na[i++] = i;\n&lt;span class=&quot;hljs-built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;%d %d %d\\n&quot;&lt;/span&gt;, x, ++x, x++);\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;And the last question is, how can you tell which expressions are well-defined, and which expressions are undefined?&lt;/p&gt;\n&lt;p&gt;As I said earlier, the undefined expressions are the ones where there&apos;s too much going at once, where you can&apos;t be sure what order things happen in, and where the order matters:&lt;/p&gt;\n&lt;ol&gt;\n&lt;li&gt;If there&apos;s one variable that&apos;s getting modified (assigned to) in two or more different places, how do you know which modification happens first?&lt;/li&gt;\n&lt;li&gt;If there&apos;s a variable that&apos;s getting modified in one place, and having its value used in another place, how do you know whether it uses the old value or the new value?&lt;/li&gt;\n&lt;/ol&gt;\n&lt;p&gt;As an example of #1, in the expression&lt;/p&gt;\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;x = x++ + ++x;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;there are three attempts to modify &lt;code&gt;x&lt;/code&gt;.&lt;/p&gt;\n&lt;p&gt;As an example of #2, in the expression&lt;/p&gt;\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;y = x + x++;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;we both use the value of &lt;code&gt;x&lt;/code&gt;, and modify it.&lt;/p&gt;\n&lt;p&gt;So that&apos;s the answer: make sure that in any expression you write, each variable is modified at most once, and if a variable is modified, you don&apos;t also attempt to use the value of that variable somewhere else.&lt;/p&gt;\n&lt;hr&gt;\n&lt;p&gt;One more thing.  You might be wondering how to &quot;fix&quot; the undefined expressions I started this answer by presenting.&lt;/p&gt;\n&lt;p&gt;In the case of &lt;code&gt;printf(&quot;%d %d %d\\n&quot;, x, ++x, x++);&lt;/code&gt;, it&apos;s easy  just write it as three separate &lt;code&gt;printf&lt;/code&gt; calls:&lt;/p&gt;\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;%d &quot;&lt;/span&gt;, x);\n&lt;span class=&quot;hljs-built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;%d &quot;&lt;/span&gt;, ++x);\n&lt;span class=&quot;hljs-built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;%d\\n&quot;&lt;/span&gt;, x++);\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;Now the behavior is perfectly well defined, and you&apos;ll get sensible results.&lt;/p&gt;\n&lt;p&gt;In the case of &lt;code&gt;x = x++ + ++x&lt;/code&gt;, on the other hand, there&apos;s no way to fix it.  There&apos;s no way to write it so that it has guaranteed behavior matching your expectations  but that&apos;s okay, because you would never write an expression like &lt;code&gt;x = x++ + ++x&lt;/code&gt; in a real program anyway.&lt;/p&gt;\n    ","\n&lt;p&gt;A good explanation about what happens in this kind of computation is provided in the document &lt;a href=&quot;http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1188.pdf&quot; rel=&quot;noreferrer&quot;&gt;n1188&lt;/a&gt; from &lt;a href=&quot;http://www.open-std.org/jtc1/sc22/wg14/www/docs/&quot; rel=&quot;noreferrer&quot;&gt;the ISO W14 site&lt;/a&gt;.&lt;/p&gt;\n\n&lt;p&gt;I explain the ideas.&lt;/p&gt;\n\n&lt;p&gt;The main rule from the standard ISO 9899 that applies in this situation is  6.5p2.&lt;/p&gt;\n\n&lt;blockquote&gt;\n  &lt;p&gt;Between the previous and next sequence point an object shall have its stored value modified at most once by the evaluation of an expression.   Furthermore, the prior value shall be read only to determine the value to be stored.&lt;/p&gt;\n&lt;/blockquote&gt;\n\n&lt;p&gt;The sequence points in an expression like &lt;code&gt;i=i++&lt;/code&gt; are before &lt;code&gt;i=&lt;/code&gt; and after &lt;code&gt;i++&lt;/code&gt;.  &lt;/p&gt;\n\n&lt;p&gt;In the paper that I quoted above it is explained that you can figure out the program as being formed by small boxes, each box containing the instructions between 2 consecutive sequence points.  The sequence points are defined in annex C of the standard, in the case of &lt;code&gt;i=i++&lt;/code&gt; there are 2 sequence points that delimit a full-expression.  Such an expression is syntactically equivalent with an entry of &lt;code&gt;expression-statement&lt;/code&gt; in the Backus-Naur form of the grammar (a grammar is provided in annex A of the Standard).&lt;/p&gt;\n\n&lt;p&gt;So the order of instructions inside a box has no clear order.&lt;/p&gt;\n\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;i=i++\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;can be interpreted as&lt;/p&gt;\n\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;tmp = i\ni=i+&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;\ni = tmp\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;or as&lt;/p&gt;\n\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;tmp = i\ni = tmp\ni=i+&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;because both all these forms to interpret the code &lt;code&gt;i=i++&lt;/code&gt; are valid and because both generate different answers, the behavior is undefined.&lt;/p&gt;\n\n&lt;p&gt;So a sequence point can be seen by the beginning and the end of each box that composes the program [the boxes are atomic units in C] and inside a box the order of instructions is not defined in all cases.  Changing that order one can change the result sometimes.&lt;/p&gt;\n\n&lt;p&gt;EDIT:&lt;/p&gt;\n\n&lt;p&gt;Other good source for explaining such ambiguities are the entries from &lt;a href=&quot;http://c-faq.com/&quot; rel=&quot;noreferrer&quot;&gt;c-faq&lt;/a&gt; site (also published &lt;a href=&quot;https://rads.stackoverflow.com/amzn/click/com/0201845199&quot; rel=&quot;noreferrer&quot;&gt;as a book&lt;/a&gt;) , namely &lt;a href=&quot;http://c-faq.com/expr/seqpoints.html&quot; rel=&quot;noreferrer&quot;&gt;here&lt;/a&gt; and &lt;a href=&quot;http://c-faq.com/expr/evalorder4.html&quot; rel=&quot;noreferrer&quot;&gt;here&lt;/a&gt; and &lt;a href=&quot;http://c-faq.com/expr/confused.html&quot; rel=&quot;noreferrer&quot;&gt;here&lt;/a&gt; .&lt;/p&gt;\n    ","\n&lt;p&gt;The reason is that the program is running undefined behavior. The problem lies in the evaluation order, because there is no sequence points required according to C++98 standard ( no operations is sequenced before or after another according to C++11 terminology).&lt;/p&gt;\n&lt;p&gt;However if you stick to one compiler, you will find the behavior persistent, as long as you don&apos;t add function calls or pointers, which would make the behavior more messy.&lt;/p&gt;\n&lt;p&gt;Using &lt;a href=&quot;https://nuwen.net/mingw.html&quot; rel=&quot;nofollow noreferrer&quot;&gt;Nuwen MinGW&lt;/a&gt; 15 GCC 7.1 you will get:&lt;/p&gt;\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt; &lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;include&lt;/span&gt;&lt;span class=&quot;hljs-string&quot;&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;/span&gt;\n &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; argc, &lt;span class=&quot;hljs-type&quot;&gt;char&lt;/span&gt; ** argv)&lt;/span&gt;\n {\n    &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;;\n    i = i++ + ++i;\n    &lt;span class=&quot;hljs-built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;%d\\n&quot;&lt;/span&gt;, i); &lt;span class=&quot;hljs-comment&quot;&gt;// 2&lt;/span&gt;\n\n    i = &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;;\n    i = (i++);\n    &lt;span class=&quot;hljs-built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;%d\\n&quot;&lt;/span&gt;, i); &lt;span class=&quot;hljs-comment&quot;&gt;//1&lt;/span&gt;\n\n    &lt;span class=&quot;hljs-keyword&quot;&gt;volatile&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; u = &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;;\n    u = u++ + ++u;\n    &lt;span class=&quot;hljs-built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;%d\\n&quot;&lt;/span&gt;, u); &lt;span class=&quot;hljs-comment&quot;&gt;// 2&lt;/span&gt;\n\n    u = &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;;\n    u = (u++);\n    &lt;span class=&quot;hljs-built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;%d\\n&quot;&lt;/span&gt;, u); &lt;span class=&quot;hljs-comment&quot;&gt;//1&lt;/span&gt;\n\n    &lt;span class=&quot;hljs-keyword&quot;&gt;register&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; v = &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;;\n    v = v++ + ++v;\n    &lt;span class=&quot;hljs-built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;%d\\n&quot;&lt;/span&gt;, v); &lt;span class=&quot;hljs-comment&quot;&gt;//2&lt;/span&gt;\n }\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;How does GCC work? it evaluates sub expressions at a left to right order for the right hand side (RHS) , then assigns the value to the left hand side (LHS) . This is exactly how Java and C# behave and define their standards. (Yes, the equivalent software in Java and C# has defined behaviors). It evaluate each sub expression one by one in the RHS Statement in a left to right order; for each sub expression: the ++c (pre-increment)  is evaluated first then the value c is used for the operation, then the post increment c++).&lt;/p&gt;\n&lt;p&gt;according to &lt;a href=&quot;http://helpcentreonline.com/article/operator_console_gcc.pdf&quot; rel=&quot;nofollow noreferrer&quot;&gt;GCC C++: Operators&lt;/a&gt;&lt;/p&gt;\n&lt;blockquote&gt;\n&lt;p&gt;In GCC C++,  the precedence of the operators controls the order in\nwhich the individual operators are evaluated&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;p&gt;the equivalent code in defined behavior C++ as   GCC understands:&lt;/p&gt;\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;include&lt;/span&gt;&lt;span class=&quot;hljs-string&quot;&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; argc, &lt;span class=&quot;hljs-type&quot;&gt;char&lt;/span&gt; ** argv)&lt;/span&gt;\n{\n    &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;;\n    &lt;span class=&quot;hljs-comment&quot;&gt;//i = i++ + ++i;&lt;/span&gt;\n    &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; r;\n    r=i;\n    i++;\n    ++i;\n    r+=i;\n    i=r;\n    &lt;span class=&quot;hljs-built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;%d\\n&quot;&lt;/span&gt;, i); &lt;span class=&quot;hljs-comment&quot;&gt;// 2&lt;/span&gt;\n\n    i = &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;;\n    &lt;span class=&quot;hljs-comment&quot;&gt;//i = (i++);&lt;/span&gt;\n    r=i;\n    i++;\n    i=r;\n    &lt;span class=&quot;hljs-built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;%d\\n&quot;&lt;/span&gt;, i); &lt;span class=&quot;hljs-comment&quot;&gt;// 1&lt;/span&gt;\n\n    &lt;span class=&quot;hljs-keyword&quot;&gt;volatile&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; u = &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;;\n    &lt;span class=&quot;hljs-comment&quot;&gt;//u = u++ + ++u;&lt;/span&gt;\n    r=u;\n    u++;\n    ++u;\n    r+=u;\n    u=r;\n    &lt;span class=&quot;hljs-built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;%d\\n&quot;&lt;/span&gt;, u); &lt;span class=&quot;hljs-comment&quot;&gt;// 2&lt;/span&gt;\n\n    u = &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;;\n    &lt;span class=&quot;hljs-comment&quot;&gt;//u = (u++);&lt;/span&gt;\n    r=u;\n    u++;\n    u=r;\n    &lt;span class=&quot;hljs-built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;%d\\n&quot;&lt;/span&gt;, u); &lt;span class=&quot;hljs-comment&quot;&gt;// 1&lt;/span&gt;\n\n    &lt;span class=&quot;hljs-keyword&quot;&gt;register&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; v = &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;;\n    &lt;span class=&quot;hljs-comment&quot;&gt;//v = v++ + ++v;&lt;/span&gt;\n    r=v;\n    v++;\n    ++v;\n    r+=v;\n    v=r;\n    &lt;span class=&quot;hljs-built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;%d\\n&quot;&lt;/span&gt;, v); &lt;span class=&quot;hljs-comment&quot;&gt;//2&lt;/span&gt;\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;Then we go to &lt;a href=&quot;https://www.visualstudio.com/&quot; rel=&quot;nofollow noreferrer&quot;&gt;Visual Studio&lt;/a&gt;. Visual Studio 2015, you get:&lt;/p&gt;\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;include&lt;/span&gt;&lt;span class=&quot;hljs-string&quot;&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; argc, &lt;span class=&quot;hljs-type&quot;&gt;char&lt;/span&gt; ** argv)&lt;/span&gt;\n{\n    &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;;\n    i = i++ + ++i;\n    &lt;span class=&quot;hljs-built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;%d\\n&quot;&lt;/span&gt;, i); &lt;span class=&quot;hljs-comment&quot;&gt;// 3&lt;/span&gt;\n\n    i = &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;;\n    i = (i++);\n    &lt;span class=&quot;hljs-built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;%d\\n&quot;&lt;/span&gt;, i); &lt;span class=&quot;hljs-comment&quot;&gt;// 2 &lt;/span&gt;\n\n    &lt;span class=&quot;hljs-keyword&quot;&gt;volatile&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; u = &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;;\n    u = u++ + ++u;\n    &lt;span class=&quot;hljs-built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;%d\\n&quot;&lt;/span&gt;, u); &lt;span class=&quot;hljs-comment&quot;&gt;// 3&lt;/span&gt;\n\n    u = &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;;\n    u = (u++);\n    &lt;span class=&quot;hljs-built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;%d\\n&quot;&lt;/span&gt;, u); &lt;span class=&quot;hljs-comment&quot;&gt;// 2 &lt;/span&gt;\n\n    &lt;span class=&quot;hljs-keyword&quot;&gt;register&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; v = &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;;\n    v = v++ + ++v;\n    &lt;span class=&quot;hljs-built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;%d\\n&quot;&lt;/span&gt;, v); &lt;span class=&quot;hljs-comment&quot;&gt;// 3 &lt;/span&gt;\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;How does Visual Studio work, it takes another approach, it evaluates all pre-increments expressions in first pass, then uses variables values in the operations in second pass,  assign from RHS to LHS in third pass, then at last pass it evaluates all the post-increment expressions in one pass.&lt;/p&gt;\n&lt;p&gt;So the equivalent in defined behavior C++ as Visual C++ understands:&lt;/p&gt;\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;include&lt;/span&gt;&lt;span class=&quot;hljs-string&quot;&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; argc, &lt;span class=&quot;hljs-type&quot;&gt;char&lt;/span&gt; ** argv)&lt;/span&gt;\n{\n    &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; r;\n    &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;;\n    &lt;span class=&quot;hljs-comment&quot;&gt;//i = i++ + ++i;&lt;/span&gt;\n    ++i;\n    r = i + i;\n    i = r;\n    i++;\n    &lt;span class=&quot;hljs-built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;%d\\n&quot;&lt;/span&gt;, i); &lt;span class=&quot;hljs-comment&quot;&gt;// 3&lt;/span&gt;\n\n    i = &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;;\n    &lt;span class=&quot;hljs-comment&quot;&gt;//i = (i++);&lt;/span&gt;\n    r = i;\n    i = r;\n    i++;\n    &lt;span class=&quot;hljs-built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;%d\\n&quot;&lt;/span&gt;, i); &lt;span class=&quot;hljs-comment&quot;&gt;// 2 &lt;/span&gt;\n\n    &lt;span class=&quot;hljs-keyword&quot;&gt;volatile&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; u = &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;;\n    &lt;span class=&quot;hljs-comment&quot;&gt;//u = u++ + ++u;&lt;/span&gt;\n    ++u;\n    r = u + u;\n    u = r;\n    u++;\n    &lt;span class=&quot;hljs-built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;%d\\n&quot;&lt;/span&gt;, u); &lt;span class=&quot;hljs-comment&quot;&gt;// 3&lt;/span&gt;\n\n    u = &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;;\n    &lt;span class=&quot;hljs-comment&quot;&gt;//u = (u++);&lt;/span&gt;\n    r = u;\n    u = r;\n    u++;\n    &lt;span class=&quot;hljs-built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;%d\\n&quot;&lt;/span&gt;, u); &lt;span class=&quot;hljs-comment&quot;&gt;// 2 &lt;/span&gt;\n\n    &lt;span class=&quot;hljs-keyword&quot;&gt;register&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; v = &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;;\n    &lt;span class=&quot;hljs-comment&quot;&gt;//v = v++ + ++v;&lt;/span&gt;\n    ++v;\n    r = v + v;\n    v = r;\n    v++;\n    &lt;span class=&quot;hljs-built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;%d\\n&quot;&lt;/span&gt;, v); &lt;span class=&quot;hljs-comment&quot;&gt;// 3 &lt;/span&gt;\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;as Visual Studio documentation states at &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/2bxt6kc4.aspx&quot; rel=&quot;nofollow noreferrer&quot;&gt;Precedence and Order of Evaluation&lt;/a&gt;:&lt;/p&gt;\n&lt;blockquote&gt;\n&lt;p&gt;Where several operators appear together, they have equal precedence and are evaluated according to their associativity. The operators in the table are described in the sections beginning with Postfix Operators.&lt;/p&gt;\n&lt;/blockquote&gt;\n    "]},"randomTags":[{"name":"where-in","slug":"where-in"},{"name":"assembly","slug":"assembly"},{"name":"callback","slug":"callback"},{"name":"virtual-destructor","slug":"virtual-destructor"},{"name":"boolean-logic","slug":"boolean-logic"},{"name":"chrome-web-driver","slug":"chrome-web-driver"},{"name":"ranking","slug":"ranking"},{"name":"feof","slug":"feof"},{"name":"mysql","slug":"mysql"},{"name":"integer-division","slug":"integer-division"},{"name":"pageload","slug":"pageload"},{"name":"join","slug":"join"},{"name":"segmentation-fault","slug":"segmentation-fault"},{"name":"relative-path","slug":"relative-path"},{"name":"timezone","slug":"timezone"},{"name":"format","slug":"format"},{"name":"environment-variables","slug":"environment-variables"},{"name":"loops","slug":"loops"},{"name":"jsonp","slug":"jsonp"},{"name":"addeventlistener","slug":"addeventlistener"}]},"__N_SSG":true}