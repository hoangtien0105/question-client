{"pageProps":{"data":{"count":1,"rows":[{"id":589,"title":"Calculate distance between two latitude-longitude points? (Haversine formula)","slug":"calculate-distance-between-two-latitude-longitude-points-(haversine-formula)-1657388500103","postType":"QUESTION","createdAt":"2022-07-09T17:41:40.000Z","updatedAt":"2022-07-09T17:41:40.000Z","tags":[{"id":2807,"name":"haversine","slug":"haversine","createdAt":"2022-07-09T17:41:40.000Z","updatedAt":"2022-07-09T17:41:40.000Z","Questions_Tags":{"questionId":589,"tagId":2807}}]}]},"slug":"haversine","page":"1","answers":{"589":["\n&lt;p&gt;This &lt;a href=&quot;http://www.movable-type.co.uk/scripts/latlong.html&quot; rel=&quot;noreferrer&quot;&gt;link&lt;/a&gt; might be helpful to you, as it details the use of the &lt;a href=&quot;http://en.wikipedia.org/wiki/Haversine_formula&quot; rel=&quot;noreferrer&quot;&gt;Haversine formula&lt;/a&gt; to calculate the distance.&lt;/p&gt;\n\n&lt;p&gt;Excerpt:&lt;/p&gt;\n\n\n\n&lt;blockquote&gt;\n  &lt;p&gt;This script [in Javascript] calculates great-circle distances between the two points \n  that is, the shortest distance over the earths surface  using the\n  Haversine formula.&lt;/p&gt;\n&lt;/blockquote&gt;\n\n&lt;pre class=&quot;lang-js s-code-block&quot;&gt;&lt;code class=&quot;hljs language-javascript&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;getDistanceFromLatLonInKm&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;lat1,lon1,lat2,lon2&lt;/span&gt;) {\n  &lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; R = &lt;span class=&quot;hljs-number&quot;&gt;6371&lt;/span&gt;; &lt;span class=&quot;hljs-comment&quot;&gt;// Radius of the earth in km&lt;/span&gt;\n  &lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; dLat = &lt;span class=&quot;hljs-title function_&quot;&gt;deg2rad&lt;/span&gt;(lat2-lat1);  &lt;span class=&quot;hljs-comment&quot;&gt;// deg2rad below&lt;/span&gt;\n  &lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; dLon = &lt;span class=&quot;hljs-title function_&quot;&gt;deg2rad&lt;/span&gt;(lon2-lon1); \n  &lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; a = \n    &lt;span class=&quot;hljs-title class_&quot;&gt;Math&lt;/span&gt;.&lt;span class=&quot;hljs-title function_&quot;&gt;sin&lt;/span&gt;(dLat/&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;) * &lt;span class=&quot;hljs-title class_&quot;&gt;Math&lt;/span&gt;.&lt;span class=&quot;hljs-title function_&quot;&gt;sin&lt;/span&gt;(dLat/&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;) +\n    &lt;span class=&quot;hljs-title class_&quot;&gt;Math&lt;/span&gt;.&lt;span class=&quot;hljs-title function_&quot;&gt;cos&lt;/span&gt;(&lt;span class=&quot;hljs-title function_&quot;&gt;deg2rad&lt;/span&gt;(lat1)) * &lt;span class=&quot;hljs-title class_&quot;&gt;Math&lt;/span&gt;.&lt;span class=&quot;hljs-title function_&quot;&gt;cos&lt;/span&gt;(&lt;span class=&quot;hljs-title function_&quot;&gt;deg2rad&lt;/span&gt;(lat2)) * \n    &lt;span class=&quot;hljs-title class_&quot;&gt;Math&lt;/span&gt;.&lt;span class=&quot;hljs-title function_&quot;&gt;sin&lt;/span&gt;(dLon/&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;) * &lt;span class=&quot;hljs-title class_&quot;&gt;Math&lt;/span&gt;.&lt;span class=&quot;hljs-title function_&quot;&gt;sin&lt;/span&gt;(dLon/&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;)\n    ; \n  &lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; c = &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt; * &lt;span class=&quot;hljs-title class_&quot;&gt;Math&lt;/span&gt;.&lt;span class=&quot;hljs-title function_&quot;&gt;atan2&lt;/span&gt;(&lt;span class=&quot;hljs-title class_&quot;&gt;Math&lt;/span&gt;.&lt;span class=&quot;hljs-title function_&quot;&gt;sqrt&lt;/span&gt;(a), &lt;span class=&quot;hljs-title class_&quot;&gt;Math&lt;/span&gt;.&lt;span class=&quot;hljs-title function_&quot;&gt;sqrt&lt;/span&gt;(&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;-a)); \n  &lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; d = R * c; &lt;span class=&quot;hljs-comment&quot;&gt;// Distance in km&lt;/span&gt;\n  &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; d;\n}\n\n&lt;span class=&quot;hljs-keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;deg2rad&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;deg&lt;/span&gt;) {\n  &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; deg * (&lt;span class=&quot;hljs-title class_&quot;&gt;Math&lt;/span&gt;.&lt;span class=&quot;hljs-property&quot;&gt;PI&lt;/span&gt;/&lt;span class=&quot;hljs-number&quot;&gt;180&lt;/span&gt;)\n}\n&lt;/code&gt;&lt;/pre&gt;\n    ","\n&lt;p&gt;I needed to calculate a lot of distances between the points for my project, so I went ahead and tried to optimize the code, I have found here. On average in different browsers my new implementation &lt;strong&gt;runs 2 times faster&lt;/strong&gt; than the most upvoted answer.&lt;/p&gt;\n&lt;pre class=&quot;lang-js s-code-block&quot;&gt;&lt;code class=&quot;hljs language-javascript&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;distance&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;lat1, lon1, lat2, lon2&lt;/span&gt;) {\n  &lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; p = &lt;span class=&quot;hljs-number&quot;&gt;0.017453292519943295&lt;/span&gt;;    &lt;span class=&quot;hljs-comment&quot;&gt;// Math.PI / 180&lt;/span&gt;\n  &lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; c = &lt;span class=&quot;hljs-title class_&quot;&gt;Math&lt;/span&gt;.&lt;span class=&quot;hljs-property&quot;&gt;cos&lt;/span&gt;;\n  &lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; a = &lt;span class=&quot;hljs-number&quot;&gt;0.5&lt;/span&gt; - &lt;span class=&quot;hljs-title function_&quot;&gt;c&lt;/span&gt;((lat2 - lat1) * p)/&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt; + \n          &lt;span class=&quot;hljs-title function_&quot;&gt;c&lt;/span&gt;(lat1 * p) * &lt;span class=&quot;hljs-title function_&quot;&gt;c&lt;/span&gt;(lat2 * p) * \n          (&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt; - &lt;span class=&quot;hljs-title function_&quot;&gt;c&lt;/span&gt;((lon2 - lon1) * p))/&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;;\n\n  &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;12742&lt;/span&gt; * &lt;span class=&quot;hljs-title class_&quot;&gt;Math&lt;/span&gt;.&lt;span class=&quot;hljs-title function_&quot;&gt;asin&lt;/span&gt;(&lt;span class=&quot;hljs-title class_&quot;&gt;Math&lt;/span&gt;.&lt;span class=&quot;hljs-title function_&quot;&gt;sqrt&lt;/span&gt;(a)); &lt;span class=&quot;hljs-comment&quot;&gt;// 2 * R; R = 6371 km&lt;/span&gt;\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;You can play with my jsPerf and see the &lt;a href=&quot;http://jsperf.com/haversine-salvador/8&quot; rel=&quot;noreferrer&quot;&gt;results here&lt;/a&gt;.&lt;/p&gt;\n&lt;p&gt;Recently I needed to do the same in python, so here is a &lt;strong&gt;python implementation&lt;/strong&gt;:&lt;/p&gt;\n&lt;pre class=&quot;lang-python s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;from&lt;/span&gt; math &lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; cos, asin, sqrt, pi\n\n&lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;distance&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;lat1, lon1, lat2, lon2&lt;/span&gt;):\n    p = pi/&lt;span class=&quot;hljs-number&quot;&gt;180&lt;/span&gt;\n    a = &lt;span class=&quot;hljs-number&quot;&gt;0.5&lt;/span&gt; - cos((lat2-lat1)*p)/&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt; + cos(lat1*p) * cos(lat2*p) * (&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;-cos((lon2-lon1)*p))/&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;\n    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;12742&lt;/span&gt; * asin(sqrt(a)) &lt;span class=&quot;hljs-comment&quot;&gt;#2*R*asin...&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;And for the sake of completeness: &lt;a href=&quot;https://en.wikipedia.org/wiki/Haversine_formula&quot; rel=&quot;noreferrer&quot;&gt;Haversine&lt;/a&gt; on Wikipedia.&lt;/p&gt;\n    ","\n&lt;p&gt;Here is a C# Implementation:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cs s-code-block&quot;&gt;&lt;code class=&quot;hljs language-csharp&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;DistanceAlgorithm&lt;/span&gt;\n{\n    &lt;span class=&quot;hljs-keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;hljs-built_in&quot;&gt;double&lt;/span&gt; PIx = &lt;span class=&quot;hljs-number&quot;&gt;3.141592653589793&lt;/span&gt;;\n    &lt;span class=&quot;hljs-keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;hljs-built_in&quot;&gt;double&lt;/span&gt; RADIUS = &lt;span class=&quot;hljs-number&quot;&gt;6378.16&lt;/span&gt;;\n\n    &lt;span class=&quot;hljs-comment&quot;&gt;&lt;span class=&quot;hljs-doctag&quot;&gt;///&lt;/span&gt; &lt;span class=&quot;hljs-doctag&quot;&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;&lt;/span&gt;\n    &lt;span class=&quot;hljs-comment&quot;&gt;&lt;span class=&quot;hljs-doctag&quot;&gt;///&lt;/span&gt; Convert degrees to Radians&lt;/span&gt;\n    &lt;span class=&quot;hljs-comment&quot;&gt;&lt;span class=&quot;hljs-doctag&quot;&gt;///&lt;/span&gt; &lt;span class=&quot;hljs-doctag&quot;&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;&lt;/span&gt;\n    &lt;span class=&quot;hljs-comment&quot;&gt;&lt;span class=&quot;hljs-doctag&quot;&gt;///&lt;/span&gt; &lt;span class=&quot;hljs-doctag&quot;&gt;&amp;lt;param name=&quot;x&quot;&amp;gt;&lt;/span&gt;Degrees&lt;span class=&quot;hljs-doctag&quot;&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;&lt;/span&gt;\n    &lt;span class=&quot;hljs-comment&quot;&gt;&lt;span class=&quot;hljs-doctag&quot;&gt;///&lt;/span&gt; &lt;span class=&quot;hljs-doctag&quot;&gt;&amp;lt;returns&amp;gt;&lt;/span&gt;The equivalent in radians&lt;span class=&quot;hljs-doctag&quot;&gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;&lt;/span&gt;\n    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;hljs-built_in&quot;&gt;double&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;Radians&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;double&lt;/span&gt; x&lt;/span&gt;)&lt;/span&gt;\n    {\n        &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; x * PIx / &lt;span class=&quot;hljs-number&quot;&gt;180&lt;/span&gt;;\n    }\n\n    &lt;span class=&quot;hljs-comment&quot;&gt;&lt;span class=&quot;hljs-doctag&quot;&gt;///&lt;/span&gt; &lt;span class=&quot;hljs-doctag&quot;&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;&lt;/span&gt;\n    &lt;span class=&quot;hljs-comment&quot;&gt;&lt;span class=&quot;hljs-doctag&quot;&gt;///&lt;/span&gt; Calculate the distance between two places.&lt;/span&gt;\n    &lt;span class=&quot;hljs-comment&quot;&gt;&lt;span class=&quot;hljs-doctag&quot;&gt;///&lt;/span&gt; &lt;span class=&quot;hljs-doctag&quot;&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;&lt;/span&gt;\n    &lt;span class=&quot;hljs-comment&quot;&gt;&lt;span class=&quot;hljs-doctag&quot;&gt;///&lt;/span&gt; &lt;span class=&quot;hljs-doctag&quot;&gt;&amp;lt;param name=&quot;lon1&quot;&amp;gt;&lt;/span&gt;&lt;span class=&quot;hljs-doctag&quot;&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;&lt;/span&gt;\n    &lt;span class=&quot;hljs-comment&quot;&gt;&lt;span class=&quot;hljs-doctag&quot;&gt;///&lt;/span&gt; &lt;span class=&quot;hljs-doctag&quot;&gt;&amp;lt;param name=&quot;lat1&quot;&amp;gt;&lt;/span&gt;&lt;span class=&quot;hljs-doctag&quot;&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;&lt;/span&gt;\n    &lt;span class=&quot;hljs-comment&quot;&gt;&lt;span class=&quot;hljs-doctag&quot;&gt;///&lt;/span&gt; &lt;span class=&quot;hljs-doctag&quot;&gt;&amp;lt;param name=&quot;lon2&quot;&amp;gt;&lt;/span&gt;&lt;span class=&quot;hljs-doctag&quot;&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;&lt;/span&gt;\n    &lt;span class=&quot;hljs-comment&quot;&gt;&lt;span class=&quot;hljs-doctag&quot;&gt;///&lt;/span&gt; &lt;span class=&quot;hljs-doctag&quot;&gt;&amp;lt;param name=&quot;lat2&quot;&amp;gt;&lt;/span&gt;&lt;span class=&quot;hljs-doctag&quot;&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;&lt;/span&gt;\n    &lt;span class=&quot;hljs-comment&quot;&gt;&lt;span class=&quot;hljs-doctag&quot;&gt;///&lt;/span&gt; &lt;span class=&quot;hljs-doctag&quot;&gt;&amp;lt;returns&amp;gt;&lt;/span&gt;&lt;span class=&quot;hljs-doctag&quot;&gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;&lt;/span&gt;\n    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;hljs-built_in&quot;&gt;double&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;DistanceBetweenPlaces&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;\n        &lt;span class=&quot;hljs-built_in&quot;&gt;double&lt;/span&gt; lon1,\n        &lt;span class=&quot;hljs-built_in&quot;&gt;double&lt;/span&gt; lat1,\n        &lt;span class=&quot;hljs-built_in&quot;&gt;double&lt;/span&gt; lon2,\n        &lt;span class=&quot;hljs-built_in&quot;&gt;double&lt;/span&gt; lat2&lt;/span&gt;)&lt;/span&gt;\n    {\n        &lt;span class=&quot;hljs-built_in&quot;&gt;double&lt;/span&gt; dlon = Radians(lon2 - lon1);\n        &lt;span class=&quot;hljs-built_in&quot;&gt;double&lt;/span&gt; dlat = Radians(lat2 - lat1);\n\n        &lt;span class=&quot;hljs-built_in&quot;&gt;double&lt;/span&gt; a = (Math.Sin(dlat / &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;) * Math.Sin(dlat / &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;)) + Math.Cos(Radians(lat1)) * Math.Cos(Radians(lat2)) * (Math.Sin(dlon / &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;) * Math.Sin(dlon / &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;));\n        &lt;span class=&quot;hljs-built_in&quot;&gt;double&lt;/span&gt; angle = &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt; * Math.Atan2(Math.Sqrt(a), Math.Sqrt(&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt; - a));\n        &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; angle * RADIUS;\n    }\n\n}\n&lt;/code&gt;&lt;/pre&gt;\n    ","\n&lt;p&gt;Here is a java implementation of the Haversine formula.&lt;/p&gt;\n\n&lt;pre class=&quot;lang-java s-code-block&quot;&gt;&lt;code class=&quot;hljs language-java&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;double&lt;/span&gt; &lt;span class=&quot;hljs-variable&quot;&gt;AVERAGE_RADIUS_OF_EARTH_KM&lt;/span&gt; &lt;span class=&quot;hljs-operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;6371&lt;/span&gt;;\n&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;calculateDistanceInKilometer&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-type&quot;&gt;double&lt;/span&gt; userLat, &lt;span class=&quot;hljs-type&quot;&gt;double&lt;/span&gt; userLng,\n  &lt;span class=&quot;hljs-type&quot;&gt;double&lt;/span&gt; venueLat, &lt;span class=&quot;hljs-type&quot;&gt;double&lt;/span&gt; venueLng)&lt;/span&gt; {\n\n    &lt;span class=&quot;hljs-type&quot;&gt;double&lt;/span&gt; &lt;span class=&quot;hljs-variable&quot;&gt;latDistance&lt;/span&gt; &lt;span class=&quot;hljs-operator&quot;&gt;=&lt;/span&gt; Math.toRadians(userLat - venueLat);\n    &lt;span class=&quot;hljs-type&quot;&gt;double&lt;/span&gt; &lt;span class=&quot;hljs-variable&quot;&gt;lngDistance&lt;/span&gt; &lt;span class=&quot;hljs-operator&quot;&gt;=&lt;/span&gt; Math.toRadians(userLng - venueLng);\n\n    &lt;span class=&quot;hljs-type&quot;&gt;double&lt;/span&gt; &lt;span class=&quot;hljs-variable&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;hljs-operator&quot;&gt;=&lt;/span&gt; Math.sin(latDistance / &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;) * Math.sin(latDistance / &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;)\n      + Math.cos(Math.toRadians(userLat)) * Math.cos(Math.toRadians(venueLat))\n      * Math.sin(lngDistance / &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;) * Math.sin(lngDistance / &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;);\n\n    &lt;span class=&quot;hljs-type&quot;&gt;double&lt;/span&gt; &lt;span class=&quot;hljs-variable&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;hljs-operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt; * Math.atan2(Math.sqrt(a), Math.sqrt(&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt; - a));\n\n    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; (&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt;) (Math.round(AVERAGE_RADIUS_OF_EARTH_KM * c));\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Note that here we are rounding the answer to the nearest km.&lt;/p&gt;\n    ","\n&lt;p&gt;Thanks very much for all this. I used the following code in my Objective-C iPhone app:&lt;/p&gt;\n\n\n\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;double&lt;/span&gt; PIx = &lt;span class=&quot;hljs-number&quot;&gt;3.141592653589793&lt;/span&gt;;\n&lt;span class=&quot;hljs-type&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;double&lt;/span&gt; RADIO = &lt;span class=&quot;hljs-number&quot;&gt;6371&lt;/span&gt;; &lt;span class=&quot;hljs-comment&quot;&gt;// Mean radius of Earth in Km&lt;/span&gt;\n\n&lt;span class=&quot;hljs-type&quot;&gt;double&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;convertToRadians&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-type&quot;&gt;double&lt;/span&gt; val)&lt;/span&gt; {\n\n   &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; val * PIx / &lt;span class=&quot;hljs-number&quot;&gt;180&lt;/span&gt;;\n}\n\n-(&lt;span class=&quot;hljs-type&quot;&gt;double&lt;/span&gt;)kilometresBetweenPlace1:(CLLocationCoordinate2D) place1 andPlace2:(CLLocationCoordinate2D) place2 {\n\n        &lt;span class=&quot;hljs-type&quot;&gt;double&lt;/span&gt; dlon = convertToRadians(place2.longitude - place1.longitude);\n        &lt;span class=&quot;hljs-type&quot;&gt;double&lt;/span&gt; dlat = convertToRadians(place2.latitude - place1.latitude);\n\n        &lt;span class=&quot;hljs-type&quot;&gt;double&lt;/span&gt; a = ( &lt;span class=&quot;hljs-built_in&quot;&gt;pow&lt;/span&gt;(&lt;span class=&quot;hljs-built_in&quot;&gt;sin&lt;/span&gt;(dlat / &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;), &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;) + &lt;span class=&quot;hljs-built_in&quot;&gt;cos&lt;/span&gt;(convertToRadians(place1.latitude))) * &lt;span class=&quot;hljs-built_in&quot;&gt;cos&lt;/span&gt;(convertToRadians(place2.latitude)) * &lt;span class=&quot;hljs-built_in&quot;&gt;pow&lt;/span&gt;(&lt;span class=&quot;hljs-built_in&quot;&gt;sin&lt;/span&gt;(dlon / &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;), &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;);\n        &lt;span class=&quot;hljs-type&quot;&gt;double&lt;/span&gt; angle = &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt; * &lt;span class=&quot;hljs-built_in&quot;&gt;asin&lt;/span&gt;(&lt;span class=&quot;hljs-built_in&quot;&gt;sqrt&lt;/span&gt;(a));\n\n        &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; angle * RADIO;\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Latitude and Longitude are in decimal. I didn&apos;t use min() for the asin() call as the distances that I&apos;m using are so small that they don&apos;t require it.&lt;/p&gt;\n\n&lt;p&gt;It gave incorrect answers until I passed in the values in Radians - now it&apos;s pretty much the same as the values obtained from Apple&apos;s Map app :-)&lt;/p&gt;\n\n&lt;p&gt;Extra update:&lt;/p&gt;\n\n&lt;p&gt;If you are using iOS4 or later then Apple provide some methods to do this so the same functionality would be achieved with:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;-(&lt;span class=&quot;hljs-type&quot;&gt;double&lt;/span&gt;)kilometresBetweenPlace1:(CLLocationCoordinate2D) place1 andPlace2:(CLLocationCoordinate2D) place2 {\n\n    MKMapPoint  start, finish;\n\n\n    start = MKMapPointForCoordinate(place1);\n    finish = MKMapPointForCoordinate(place2);\n\n    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; MKMetersBetweenMapPoints(start, finish) / &lt;span class=&quot;hljs-number&quot;&gt;1000&lt;/span&gt;;\n}\n&lt;/code&gt;&lt;/pre&gt;\n    ","\n&lt;p&gt;This is a simple PHP function that will give a very reasonable approximation (under +/-1% error margin).  &lt;/p&gt;\n\n&lt;pre class=&quot;lang-php s-code-block&quot;&gt;&lt;code class=&quot;hljs language-php&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;&amp;lt;?php&lt;/span&gt;\n&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;distance&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;&lt;span class=&quot;hljs-variable&quot;&gt;$lat1&lt;/span&gt;, &lt;span class=&quot;hljs-variable&quot;&gt;$lon1&lt;/span&gt;, &lt;span class=&quot;hljs-variable&quot;&gt;$lat2&lt;/span&gt;, &lt;span class=&quot;hljs-variable&quot;&gt;$lon2&lt;/span&gt;&lt;/span&gt;) &lt;/span&gt;{\n\n    &lt;span class=&quot;hljs-variable&quot;&gt;$pi80&lt;/span&gt; = M_PI / &lt;span class=&quot;hljs-number&quot;&gt;180&lt;/span&gt;;\n    &lt;span class=&quot;hljs-variable&quot;&gt;$lat1&lt;/span&gt; *= &lt;span class=&quot;hljs-variable&quot;&gt;$pi80&lt;/span&gt;;\n    &lt;span class=&quot;hljs-variable&quot;&gt;$lon1&lt;/span&gt; *= &lt;span class=&quot;hljs-variable&quot;&gt;$pi80&lt;/span&gt;;\n    &lt;span class=&quot;hljs-variable&quot;&gt;$lat2&lt;/span&gt; *= &lt;span class=&quot;hljs-variable&quot;&gt;$pi80&lt;/span&gt;;\n    &lt;span class=&quot;hljs-variable&quot;&gt;$lon2&lt;/span&gt; *= &lt;span class=&quot;hljs-variable&quot;&gt;$pi80&lt;/span&gt;;\n\n    &lt;span class=&quot;hljs-variable&quot;&gt;$r&lt;/span&gt; = &lt;span class=&quot;hljs-number&quot;&gt;6372.797&lt;/span&gt;; &lt;span class=&quot;hljs-comment&quot;&gt;// mean radius of Earth in km&lt;/span&gt;\n    &lt;span class=&quot;hljs-variable&quot;&gt;$dlat&lt;/span&gt; = &lt;span class=&quot;hljs-variable&quot;&gt;$lat2&lt;/span&gt; - &lt;span class=&quot;hljs-variable&quot;&gt;$lat1&lt;/span&gt;;\n    &lt;span class=&quot;hljs-variable&quot;&gt;$dlon&lt;/span&gt; = &lt;span class=&quot;hljs-variable&quot;&gt;$lon2&lt;/span&gt; - &lt;span class=&quot;hljs-variable&quot;&gt;$lon1&lt;/span&gt;;\n    &lt;span class=&quot;hljs-variable&quot;&gt;$a&lt;/span&gt; = &lt;span class=&quot;hljs-title function_ invoke__&quot;&gt;sin&lt;/span&gt;(&lt;span class=&quot;hljs-variable&quot;&gt;$dlat&lt;/span&gt; / &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;) * &lt;span class=&quot;hljs-title function_ invoke__&quot;&gt;sin&lt;/span&gt;(&lt;span class=&quot;hljs-variable&quot;&gt;$dlat&lt;/span&gt; / &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;) + &lt;span class=&quot;hljs-title function_ invoke__&quot;&gt;cos&lt;/span&gt;(&lt;span class=&quot;hljs-variable&quot;&gt;$lat1&lt;/span&gt;) * &lt;span class=&quot;hljs-title function_ invoke__&quot;&gt;cos&lt;/span&gt;(&lt;span class=&quot;hljs-variable&quot;&gt;$lat2&lt;/span&gt;) * &lt;span class=&quot;hljs-title function_ invoke__&quot;&gt;sin&lt;/span&gt;(&lt;span class=&quot;hljs-variable&quot;&gt;$dlon&lt;/span&gt; / &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;) * &lt;span class=&quot;hljs-title function_ invoke__&quot;&gt;sin&lt;/span&gt;(&lt;span class=&quot;hljs-variable&quot;&gt;$dlon&lt;/span&gt; / &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;);\n    &lt;span class=&quot;hljs-variable&quot;&gt;$c&lt;/span&gt; = &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt; * &lt;span class=&quot;hljs-title function_ invoke__&quot;&gt;atan2&lt;/span&gt;(&lt;span class=&quot;hljs-title function_ invoke__&quot;&gt;sqrt&lt;/span&gt;(&lt;span class=&quot;hljs-variable&quot;&gt;$a&lt;/span&gt;), &lt;span class=&quot;hljs-title function_ invoke__&quot;&gt;sqrt&lt;/span&gt;(&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt; - &lt;span class=&quot;hljs-variable&quot;&gt;$a&lt;/span&gt;));\n    &lt;span class=&quot;hljs-variable&quot;&gt;$km&lt;/span&gt; = &lt;span class=&quot;hljs-variable&quot;&gt;$r&lt;/span&gt; * &lt;span class=&quot;hljs-variable&quot;&gt;$c&lt;/span&gt;;\n\n    &lt;span class=&quot;hljs-comment&quot;&gt;//echo &apos;&amp;lt;br/&amp;gt;&apos;.$km;&lt;/span&gt;\n    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-variable&quot;&gt;$km&lt;/span&gt;;\n}\n&lt;span class=&quot;hljs-meta&quot;&gt;?&amp;gt;&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;As said before; the earth is NOT a sphere.  It is like an old, old baseball that Mark McGwire decided to practice with - it is full of dents and bumps.  The simpler calculations (like this) treat it like a sphere.&lt;/p&gt;\n\n&lt;p&gt;Different methods may be more or less precise according to where you are on this irregular ovoid AND how far apart your points are (the closer they are the smaller the absolute error margin).  The more precise your expectation, the more complex the math.&lt;/p&gt;\n\n&lt;p&gt;For more info: &lt;a href=&quot;http://en.wikipedia.org/wiki/Geographical_distance&quot; rel=&quot;noreferrer&quot;&gt;wikipedia geographic distance&lt;/a&gt;&lt;/p&gt;\n    ","\n&lt;p&gt;I post here my working example.&lt;/p&gt;\n\n&lt;p&gt;List all points in table having distance between a designated point (we use a random point - lat:45.20327, long:23.7806) less than 50 KM, with latitude &amp;amp; longitude, in MySQL (the table fields are coord_lat and coord_long):&lt;/p&gt;\n\n&lt;p&gt;&lt;strong&gt;List all having DISTANCE&amp;lt;50, in Kilometres (considered Earth radius 6371 KM):&lt;/strong&gt;&lt;/p&gt;\n\n&lt;pre class=&quot;lang-sql s-code-block&quot;&gt;&lt;code class=&quot;hljs language-sql&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;SELECT&lt;/span&gt; denumire, (&lt;span class=&quot;hljs-number&quot;&gt;6371&lt;/span&gt; &lt;span class=&quot;hljs-operator&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;hljs-built_in&quot;&gt;acos&lt;/span&gt;( &lt;span class=&quot;hljs-built_in&quot;&gt;cos&lt;/span&gt;( radians(&lt;span class=&quot;hljs-number&quot;&gt;45.20327&lt;/span&gt;) ) &lt;span class=&quot;hljs-operator&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;hljs-built_in&quot;&gt;cos&lt;/span&gt;( radians( coord_lat ) ) &lt;span class=&quot;hljs-operator&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;hljs-built_in&quot;&gt;cos&lt;/span&gt;( radians( &lt;span class=&quot;hljs-number&quot;&gt;23.7806&lt;/span&gt; ) &lt;span class=&quot;hljs-operator&quot;&gt;-&lt;/span&gt; radians(coord_long) ) &lt;span class=&quot;hljs-operator&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;hljs-built_in&quot;&gt;sin&lt;/span&gt;( radians(&lt;span class=&quot;hljs-number&quot;&gt;45.20327&lt;/span&gt;) ) &lt;span class=&quot;hljs-operator&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;hljs-built_in&quot;&gt;sin&lt;/span&gt;( radians(coord_lat) ) )) &lt;span class=&quot;hljs-keyword&quot;&gt;AS&lt;/span&gt; distanta \n&lt;span class=&quot;hljs-keyword&quot;&gt;FROM&lt;/span&gt; obiective \n&lt;span class=&quot;hljs-keyword&quot;&gt;WHERE&lt;/span&gt; coord_lat&lt;span class=&quot;hljs-operator&quot;&gt;&amp;lt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;hljs-string&quot;&gt;&apos;&apos;&lt;/span&gt; \n    &lt;span class=&quot;hljs-keyword&quot;&gt;AND&lt;/span&gt; coord_long&lt;span class=&quot;hljs-operator&quot;&gt;&amp;lt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;hljs-string&quot;&gt;&apos;&apos;&lt;/span&gt; \n&lt;span class=&quot;hljs-keyword&quot;&gt;HAVING&lt;/span&gt; distanta&lt;span class=&quot;hljs-operator&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;hljs-number&quot;&gt;50&lt;/span&gt; \n&lt;span class=&quot;hljs-keyword&quot;&gt;ORDER&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;BY&lt;/span&gt; distanta &lt;span class=&quot;hljs-keyword&quot;&gt;desc&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;The above example was tested in MySQL 5.0.95 and 5.5.16 (Linux). &lt;/p&gt;\n    ","\n&lt;p&gt;In the other answers an implementation in &lt;a href=&quot;/questions/tagged/r&quot; class=&quot;post-tag&quot; title=&quot;show questions tagged &apos;r&apos;&quot; rel=&quot;tag&quot;&gt;r&lt;/a&gt; is missing.&lt;/p&gt;\n\n&lt;p&gt;Calculating the distance between two point is quite straightforward with the &lt;code&gt;distm&lt;/code&gt; function from the &lt;code&gt;geosphere&lt;/code&gt; package:&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;distm(p1, p2, fun = distHaversine)\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;where:&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;p1 = longitude/latitude for point(s)\np2 = longitude/latitude for point(s)\n# type of distance calculation\nfun = distCosine / distHaversine / distVincentySphere / distVincentyEllipsoid \n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;As the earth is not perfectly spherical, the &lt;a href=&quot;http://en.wikipedia.org/wiki/Vincenty%27s_formulae&quot; rel=&quot;noreferrer&quot;&gt;Vincenty formula for ellipsoids&lt;/a&gt; is probably the best way to calculate distances. Thus in the &lt;code&gt;geosphere&lt;/code&gt; package you use then:&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;distm(p1, p2, fun = distVincentyEllipsoid)\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;hr&gt;\n\n&lt;p&gt;Off course you don&apos;t necessarily have to use &lt;code&gt;geosphere&lt;/code&gt; package, you can also calculate the distance in base &lt;code&gt;R&lt;/code&gt; with a function:&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;hav.dist &amp;lt;- function(long1, lat1, long2, lat2) {\n  R &amp;lt;- 6371\n  diff.long &amp;lt;- (long2 - long1)\n  diff.lat &amp;lt;- (lat2 - lat1)\n  a &amp;lt;- sin(diff.lat/2)^2 + cos(lat1) * cos(lat2) * sin(diff.long/2)^2\n  b &amp;lt;- 2 * asin(pmin(1, sqrt(a))) \n  d = R * b\n  return(d)\n}\n&lt;/code&gt;&lt;/pre&gt;\n    ","\n&lt;p&gt;The haversine is definitely a good formula for probably most cases, other answers already include it so I am not going to take the space. But it is important to note that no matter what formula is used (yes not just one). Because of the huge range of accuracy possible as well as the computation time required. The choice of formula requires a bit more thought than a simple no brainer answer. &lt;/p&gt;\n\n&lt;p&gt;This posting from a person at nasa, is the best one I found at discussing the options&lt;/p&gt;\n\n&lt;p&gt;&lt;a href=&quot;http://www.cs.nyu.edu/visual/home/proj/tiger/gisfaq.html&quot; rel=&quot;noreferrer&quot;&gt;http://www.cs.nyu.edu/visual/home/proj/tiger/gisfaq.html&lt;/a&gt;&lt;/p&gt;\n\n&lt;p&gt;For example, if you are just sorting rows by distance in a 100 miles radius. The flat earth formula will be much faster than the haversine.&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;HalfPi = 1.5707963;\nR = 3956; /* the radius gives you the measurement unit*/\n\na = HalfPi - latoriginrad;\nb = HalfPi - latdestrad;\nu = a * a + b * b;\nv = - 2 * a * b * cos(longdestrad - longoriginrad);\nc = sqrt(abs(u + v));\nreturn R * c;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Notice there is just one cosine and one square root. Vs 9 of them on the Haversine formula.&lt;/p&gt;\n    ","\n&lt;p&gt;There could be a simpler solution, and more correct: The perimeter of earth is 40,000Km at the equator, about 37,000 on Greenwich (or any longitude) cycle. Thus:&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;pythagoras = function (lat1, lon1, lat2, lon2) {\n   function sqr(x) {return x * x;}\n   function cosDeg(x) {return Math.cos(x * Math.PI / 180.0);}\n\n   var earthCyclePerimeter = 40000000.0 * cosDeg((lat1 + lat2) / 2.0);\n   var dx = (lon1 - lon2) * earthCyclePerimeter / 360.0;\n   var dy = 37000000.0 * (lat1 - lat2) / 360.0;\n\n   return Math.sqrt(sqr(dx) + sqr(dy));\n};\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;I agree that it should be fine-tuned as, I myself said that it&apos;s an ellipsoid, so the radius to be multiplied by the cosine varies. But it&apos;s a bit more accurate. Compared with Google Maps and it did reduce the error significantly.&lt;/p&gt;\n    ","\n&lt;p&gt;All the above answers assumes the earth is a sphere. However, a more accurate approximation would be that of an oblate spheroid.&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;a= 6378.137#equitorial radius in km\nb= 6356.752#polar radius in km\n\ndef Distance(lat1, lons1, lat2, lons2):\n    lat1=math.radians(lat1)\n    lons1=math.radians(lons1)\n    R1=(((((a**2)*math.cos(lat1))**2)+(((b**2)*math.sin(lat1))**2))/((a*math.cos(lat1))**2+(b*math.sin(lat1))**2))**0.5 #radius of earth at lat1\n    x1=R*math.cos(lat1)*math.cos(lons1)\n    y1=R*math.cos(lat1)*math.sin(lons1)\n    z1=R*math.sin(lat1)\n\n    lat2=math.radians(lat2)\n    lons2=math.radians(lons2)\n    R1=(((((a**2)*math.cos(lat2))**2)+(((b**2)*math.sin(lat2))**2))/((a*math.cos(lat2))**2+(b*math.sin(lat2))**2))**0.5 #radius of earth at lat2\n    x2=R*math.cos(lat2)*math.cos(lons2)\n    y2=R*math.cos(lat2)*math.sin(lons2)\n    z2=R*math.sin(lat2)\n\n    return ((x1-x2)**2+(y1-y2)**2+(z1-z2)**2)**0.5\n&lt;/code&gt;&lt;/pre&gt;\n    ","\n&lt;p&gt;&lt;code&gt;pip install haversine&lt;/code&gt;&lt;/p&gt;\n&lt;p&gt;Python implementation&lt;/p&gt;\n&lt;p&gt;Origin is the center of the contiguous United States.&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;from haversine import haversine, Unit\norigin = (39.50, 98.35)\nparis = (48.8567, 2.3508)\nhaversine(origin, paris, unit=Unit.MILES)\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;To get the answer in kilometers simply set &lt;code&gt;unit=Unit.KILOMETERS&lt;/code&gt; (that&apos;s the default).&lt;/p&gt;\n    ","\n&lt;p&gt;I don&apos;t like adding yet another answer, but the Google maps API v.3 has spherical geometry (and more). After converting your WGS84 to decimal degrees you can do this:&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;&amp;lt;script src=&quot;http://maps.google.com/maps/api/js?sensor=false&amp;amp;libraries=geometry&quot; type=&quot;text/javascript&quot;&amp;gt;&amp;lt;/script&amp;gt;  \n\ndistance = google.maps.geometry.spherical.computeDistanceBetween(\n    new google.maps.LatLng(fromLat, fromLng), \n    new google.maps.LatLng(toLat, toLng));\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;No word about how accurate Google&apos;s calculations are or even what model is used (though it does say &quot;spherical&quot; rather than &quot;geoid&quot;.  By the way, the &quot;straight line&quot; distance will obviously be different from the distance if one travels on the surface of the earth which is what everyone seems to be presuming.&lt;/p&gt;\n    ","\n&lt;p&gt;You can use the build in CLLocationDistance to calculate this:&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;CLLocation *location1 = [[CLLocation alloc] initWithLatitude:latitude1 longitude:longitude1];\nCLLocation *location2 = [[CLLocation alloc] initWithLatitude:latitude2 longitude:longitude2];\n[self distanceInMetersFromLocation:location1 toLocation:location2]\n\n- (int)distanceInMetersFromLocation:(CLLocation*)location1 toLocation:(CLLocation*)location2 {\n    CLLocationDistance distanceInMeters = [location1 distanceFromLocation:location2];\n    return distanceInMeters;\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;In your case if you want kilometers just divide by 1000.&lt;/p&gt;\n    ","\n&lt;p&gt;Here is a &lt;strong&gt;typescript&lt;/strong&gt; implementation of the Haversine formula&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;static getDistanceFromLatLonInKm(lat1: number, lon1: number, lat2: number, lon2: number): number {\n    var deg2Rad = deg =&amp;gt; {\n        return deg * Math.PI / 180;\n    }\n\n    var r = 6371; // Radius of the earth in km\n    var dLat = deg2Rad(lat2 - lat1);   \n    var dLon = deg2Rad(lon2 - lon1);\n    var a =\n        Math.sin(dLat / 2) * Math.sin(dLat / 2) +\n        Math.cos(deg2Rad(lat1)) * Math.cos(deg2Rad(lat2)) *\n        Math.sin(dLon / 2) * Math.sin(dLon / 2);\n    var c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\n    var d = r * c; // Distance in km\n    return d;\n}\n&lt;/code&gt;&lt;/pre&gt;\n    ","\n&lt;p&gt;As pointed out, an accurate calculation should take into account that the earth is not a perfect sphere. Here are some comparisons of the various algorithms offered here:&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;geoDistance(50,5,58,3)\nHaversine: 899 km\nMaymenn: 833 km\nKeerthana: 897 km\ngoogle.maps.geometry.spherical.computeDistanceBetween(): 900 km\n\ngeoDistance(50,5,-58,-3)\nHaversine: 12030 km\nMaymenn: 11135 km\nKeerthana: 10310 km\ngoogle.maps.geometry.spherical.computeDistanceBetween(): 12044 km\n\ngeoDistance(.05,.005,.058,.003)\nHaversine: 0.9169 km\nMaymenn: 0.851723 km\nKeerthana: 0.917964 km\ngoogle.maps.geometry.spherical.computeDistanceBetween(): 0.917964 km\n\ngeoDistance(.05,80,.058,80.3)\nHaversine: 33.37 km\nMaymenn: 33.34 km\nKeerthana: 33.40767 km\ngoogle.maps.geometry.spherical.computeDistanceBetween(): 33.40770 km\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Over small distances, Keerthana&apos;s algorithm does seem to coincide with that of Google Maps. Google Maps does not seem to follow any simple algorithm, suggesting that it may be the most accurate method here.&lt;/p&gt;\n\n&lt;p&gt;Anyway, here is a Javascript implementation of Keerthana&apos;s algorithm:&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;function geoDistance(lat1, lng1, lat2, lng2){\n    const a = 6378.137; // equitorial radius in km\n    const b = 6356.752; // polar radius in km\n\n    var sq = x =&amp;gt; (x*x);\n    var sqr = x =&amp;gt; Math.sqrt(x);\n    var cos = x =&amp;gt; Math.cos(x);\n    var sin = x =&amp;gt; Math.sin(x);\n    var radius = lat =&amp;gt; sqr((sq(a*a*cos(lat))+sq(b*b*sin(lat)))/(sq(a*cos(lat))+sq(b*sin(lat))));\n\n    lat1 = lat1 * Math.PI / 180;\n    lng1 = lng1 * Math.PI / 180;\n    lat2 = lat2 * Math.PI / 180;\n    lng2 = lng2 * Math.PI / 180;\n\n    var R1 = radius(lat1);\n    var x1 = R1*cos(lat1)*cos(lng1);\n    var y1 = R1*cos(lat1)*sin(lng1);\n    var z1 = R1*sin(lat1);\n\n    var R2 = radius(lat2);\n    var x2 = R2*cos(lat2)*cos(lng2);\n    var y2 = R2*cos(lat2)*sin(lng2);\n    var z2 = R2*sin(lat2);\n\n    return sqr(sq(x1-x2)+sq(y1-y2)+sq(z1-z2));\n}\n&lt;/code&gt;&lt;/pre&gt;\n    ","\n&lt;p&gt;Here is the SQL Implementation to calculate the distance in km,&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;SELECT UserId, ( 3959 * acos( cos( radians( your latitude here ) ) * cos( radians(latitude) ) * \ncos( radians(longitude) - radians( your longitude here ) ) + sin( radians( your latitude here ) ) * \nsin( radians(latitude) ) ) ) AS distance FROM user HAVING\ndistance &amp;lt; 5  ORDER BY distance LIMIT 0 , 5;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;For further details in the implementation by programming langugage, you can just go through the php script given &lt;a href=&quot;https://www.geodatasource.com/developers/php&quot; rel=&quot;nofollow noreferrer&quot;&gt;here&lt;/a&gt;&lt;/p&gt;\n    ","\n&lt;p&gt;This script [in PHP] calculates distances between the two points.&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;public static function getDistanceOfTwoPoints($source, $dest, $unit=&apos;K&apos;) {\n        $lat1 = $source[0];\n        $lon1 = $source[1];\n        $lat2 = $dest[0];\n        $lon2 = $dest[1];\n\n        $theta = $lon1 - $lon2;\n        $dist = sin(deg2rad($lat1)) * sin(deg2rad($lat2)) +  cos(deg2rad($lat1)) * cos(deg2rad($lat2)) * cos(deg2rad($theta));\n        $dist = acos($dist);\n        $dist = rad2deg($dist);\n        $miles = $dist * 60 * 1.1515;\n        $unit = strtoupper($unit);\n\n        if ($unit == &quot;K&quot;) {\n            return ($miles * 1.609344);\n        }\n        else if ($unit == &quot;M&quot;)\n        {\n            return ($miles * 1.609344 * 1000);\n        }\n        else if ($unit == &quot;N&quot;) {\n            return ($miles * 0.8684);\n        } \n        else {\n            return $miles;\n        }\n    }\n&lt;/code&gt;&lt;/pre&gt;\n    ","\n&lt;blockquote&gt;\n  &lt;p&gt;Java implementation in according &lt;a href=&quot;https://en.wikipedia.org/wiki/Haversine_formula&quot; rel=&quot;nofollow noreferrer&quot;&gt;Haversine formula&lt;/a&gt;&lt;/p&gt;\n&lt;/blockquote&gt;\n\n&lt;pre class=&quot;lang-java s-code-block&quot;&gt;&lt;code class=&quot;hljs language-java&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;double&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;calculateDistance&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-type&quot;&gt;double&lt;/span&gt; latPoint1, &lt;span class=&quot;hljs-type&quot;&gt;double&lt;/span&gt; lngPoint1, \n                         &lt;span class=&quot;hljs-type&quot;&gt;double&lt;/span&gt; latPoint2, &lt;span class=&quot;hljs-type&quot;&gt;double&lt;/span&gt; lngPoint2)&lt;/span&gt; {\n    &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt;(latPoint1 == latPoint2 &amp;amp;&amp;amp; lngPoint1 == lngPoint2) {\n        &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;0d&lt;/span&gt;;\n    }\n\n    &lt;span class=&quot;hljs-keyword&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;double&lt;/span&gt; &lt;span class=&quot;hljs-variable&quot;&gt;EARTH_RADIUS&lt;/span&gt; &lt;span class=&quot;hljs-operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;6371.0&lt;/span&gt;; &lt;span class=&quot;hljs-comment&quot;&gt;//km value;&lt;/span&gt;\n\n    &lt;span class=&quot;hljs-comment&quot;&gt;//converting to radians&lt;/span&gt;\n    latPoint1 = Math.toRadians(latPoint1);\n    lngPoint1 = Math.toRadians(lngPoint1);\n    latPoint2 = Math.toRadians(latPoint2);\n    lngPoint2 = Math.toRadians(lngPoint2);\n\n    &lt;span class=&quot;hljs-type&quot;&gt;double&lt;/span&gt; &lt;span class=&quot;hljs-variable&quot;&gt;distance&lt;/span&gt; &lt;span class=&quot;hljs-operator&quot;&gt;=&lt;/span&gt; Math.pow(Math.sin((latPoint2 - latPoint1) / &lt;span class=&quot;hljs-number&quot;&gt;2.0&lt;/span&gt;), &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;) \n            + Math.cos(latPoint1) * Math.cos(latPoint2)\n            * Math.pow(Math.sin((lngPoint2 - lngPoint1) / &lt;span class=&quot;hljs-number&quot;&gt;2.0&lt;/span&gt;), &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;);\n    distance = &lt;span class=&quot;hljs-number&quot;&gt;2.0&lt;/span&gt; * EARTH_RADIUS * Math.asin(Math.sqrt(distance));\n\n    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; distance; &lt;span class=&quot;hljs-comment&quot;&gt;//km value&lt;/span&gt;\n}\n&lt;/code&gt;&lt;/pre&gt;\n    ","\n&lt;p&gt;To calculate the distance between two points on a sphere you need to do the &lt;a href=&quot;http://en.wikipedia.org/wiki/Great-circle_distance&quot; rel=&quot;nofollow noreferrer&quot;&gt;Great Circle calculation&lt;/a&gt;. &lt;/p&gt;\n\n&lt;p&gt;There are a number of C/C++ libraries to help with map projection at &lt;a href=&quot;http://www.maptools.org/&quot; rel=&quot;nofollow noreferrer&quot;&gt;MapTools&lt;/a&gt; if you need to reproject your distances to a flat surface.  To do this you will need the projection string of the various coordinate systems.&lt;/p&gt;\n\n&lt;p&gt;You may also find &lt;a href=&quot;http://www.mapwindow.org/&quot; rel=&quot;nofollow noreferrer&quot;&gt;MapWindow&lt;/a&gt; a useful tool to visualise the points.  Also as its open source its a useful guide to how to use the proj.dll library, which appears to be the core open source projection library.&lt;/p&gt;\n    ","\n&lt;p&gt;Here is my java implementation for calculation distance via decimal degrees after some search. I used mean radius of world (from wikipedia) in km. Ä°f you want result miles then use world radius in miles.&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;public static double distanceLatLong2(double lat1, double lng1, double lat2, double lng2) \n{\n  double earthRadius = 6371.0d; // KM: use mile here if you want mile result\n\n  double dLat = toRadian(lat2 - lat1);\n  double dLng = toRadian(lng2 - lng1);\n\n  double a = Math.pow(Math.sin(dLat/2), 2)  + \n          Math.cos(toRadian(lat1)) * Math.cos(toRadian(lat2)) * \n          Math.pow(Math.sin(dLng/2), 2);\n\n  double c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));\n\n  return earthRadius * c; // returns result kilometers\n}\n\npublic static double toRadian(double degrees) \n{\n  return (degrees * Math.PI) / 180.0d;\n}\n&lt;/code&gt;&lt;/pre&gt;\n    ","\n&lt;p&gt;Here&apos;s the accepted answer implementation ported to Java in case anyone needs it.&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;package com.project529.garage.util;\n\n\n/**\n * Mean radius.\n */\nprivate static double EARTH_RADIUS = 6371;\n\n/**\n * Returns the distance between two sets of latitudes and longitudes in meters.\n * &amp;lt;p/&amp;gt;\n * Based from the following JavaScript SO answer:\n * http://stackoverflow.com/questions/27928/calculate-distance-between-two-latitude-longitude-points-haversine-formula,\n * which is based on https://en.wikipedia.org/wiki/Haversine_formula (error rate: ~0.55%).\n */\npublic double getDistanceBetween(double lat1, double lon1, double lat2, double lon2) {\n    double dLat = toRadians(lat2 - lat1);\n    double dLon = toRadians(lon2 - lon1);\n\n    double a = Math.sin(dLat / 2) * Math.sin(dLat / 2) +\n            Math.cos(toRadians(lat1)) * Math.cos(toRadians(lat2)) *\n                    Math.sin(dLon / 2) * Math.sin(dLon / 2);\n    double c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\n    double d = EARTH_RADIUS * c;\n\n    return d;\n}\n\npublic double toRadians(double degrees) {\n    return degrees * (Math.PI / 180);\n}\n&lt;/code&gt;&lt;/pre&gt;\n    ","\n&lt;p&gt;here is an example in &lt;strong&gt;postgres&lt;/strong&gt; sql (in km, for miles version, replace 1.609344 by 0.8684 version)&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;CREATE OR REPLACE FUNCTION public.geodistance(alat float, alng float, blat  \n\nfloat, blng  float)\n  RETURNS float AS\n$BODY$\nDECLARE\n    v_distance float;\nBEGIN\n\n    v_distance = asin( sqrt(\n            sin(radians(blat-alat)/2)^2 \n                + (\n                    (sin(radians(blng-alng)/2)^2) *\n                    cos(radians(alat)) *\n                    cos(radians(blat))\n                )\n          )\n        ) * cast(&apos;7926.3352&apos; as float) * cast(&apos;1.609344&apos; as float) ;\n\n\n    RETURN v_distance;\nEND \n$BODY$\nlanguage plpgsql VOLATILE SECURITY DEFINER;\nalter function geodistance(alat float, alng float, blat float, blng float)\nowner to postgres;\n&lt;/code&gt;&lt;/pre&gt;\n    ","\n&lt;p&gt;For those looking for an Excel formula based on WGS-84 &amp;amp; GRS-80 standards:&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;=ACOS(COS(RADIANS(90-Lat1))*COS(RADIANS(90-Lat2))+SIN(RADIANS(90-Lat1))*SIN(RADIANS(90-Lat2))*COS(RADIANS(Long1-Long2)))*6371\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;&lt;a href=&quot;https://bluemm.blogspot.com/2007/01/excel-formula-to-calculate-distance.html&quot; rel=&quot;nofollow noreferrer&quot;&gt;Source&lt;/a&gt;&lt;/p&gt;\n    ","\n&lt;p&gt;I made a custom function in R to calculate haversine distance(km) between two spatial points using functions available in R base package.&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;custom_hav_dist &amp;lt;- function(lat1, lon1, lat2, lon2) {\nR &amp;lt;- 6371\nRadian_factor &amp;lt;- 0.0174533\nlat_1 &amp;lt;- (90-lat1)*Radian_factor\nlat_2 &amp;lt;- (90-lat2)*Radian_factor\ndiff_long &amp;lt;-(lon1-lon2)*Radian_factor\n\ndistance_in_km &amp;lt;- 6371*acos((cos(lat_1)*cos(lat_2))+ \n                 (sin(lat_1)*sin(lat_2)*cos(diff_long)))\nrm(lat1, lon1, lat2, lon2)\nreturn(distance_in_km)\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;Sample output&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;custom_hav_dist(50.31,19.08,54.14,19.39)\n[1] 426.3987\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;PS: To calculate distances in miles, substitute R in function (6371) with 3958.756 (and for nautical miles, use 3440.065).&lt;/p&gt;\n    ","\n&lt;p&gt;there is a good example in here to calculate distance with PHP &lt;a href=&quot;http://www.geodatasource.com/developers/php&quot; rel=&quot;nofollow&quot;&gt;http://www.geodatasource.com/developers/php&lt;/a&gt; :&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt; function distance($lat1, $lon1, $lat2, $lon2, $unit) {\n\n     $theta = $lon1 - $lon2;\n     $dist = sin(deg2rad($lat1)) * sin(deg2rad($lat2)) +  cos(deg2rad($lat1)) * cos(deg2rad($lat2)) * cos(deg2rad($theta));\n     $dist = acos($dist);\n     $dist = rad2deg($dist);\n     $miles = $dist * 60 * 1.1515;\n     $unit = strtoupper($unit);\n\n     if ($unit == &quot;K&quot;) {\n         return ($miles * 1.609344);\n     } else if ($unit == &quot;N&quot;) {\n          return ($miles * 0.8684);\n     } else {\n          return $miles;\n     }\n }\n&lt;/code&gt;&lt;/pre&gt;\n    ","\n&lt;p&gt;Here is the implementation VB.NET, this implementation will give you the result in KM or Miles based on an Enum value you pass.&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;Public Enum DistanceType\n    Miles\n    KiloMeters\nEnd Enum\n\nPublic Structure Position\n    Public Latitude As Double\n    Public Longitude As Double\nEnd Structure\n\nPublic Class Haversine\n\n    Public Function Distance(Pos1 As Position,\n                             Pos2 As Position,\n                             DistType As DistanceType) As Double\n\n        Dim R As Double = If((DistType = DistanceType.Miles), 3960, 6371)\n\n        Dim dLat As Double = Me.toRadian(Pos2.Latitude - Pos1.Latitude)\n\n        Dim dLon As Double = Me.toRadian(Pos2.Longitude - Pos1.Longitude)\n\n        Dim a As Double = Math.Sin(dLat / 2) * Math.Sin(dLat / 2) + Math.Cos(Me.toRadian(Pos1.Latitude)) * Math.Cos(Me.toRadian(Pos2.Latitude)) * Math.Sin(dLon / 2) * Math.Sin(dLon / 2)\n\n        Dim c As Double = 2 * Math.Asin(Math.Min(1, Math.Sqrt(a)))\n\n        Dim result As Double = R * c\n\n        Return result\n\n    End Function\n\n    Private Function toRadian(val As Double) As Double\n\n        Return (Math.PI / 180) * val\n\n    End Function\n\nEnd Class\n&lt;/code&gt;&lt;/pre&gt;\n    ","\n&lt;p&gt;I condensed the computation down by simplifying the formula.&lt;/p&gt;\n\n&lt;p&gt;Here it is in Ruby:&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;include Math\nearth_radius_mi = 3959\nradians = lambda { |deg| deg * PI / 180 }\ncoord_radians = lambda { |c| { :lat =&amp;gt; radians[c[:lat]], :lng =&amp;gt; radians[c[:lng]] } }\n\n# from/to = { :lat =&amp;gt; (latitude_in_degrees), :lng =&amp;gt; (longitude_in_degrees) }\ndef haversine_distance(from, to)\n  from, to = coord_radians[from], coord_radians[to]\n  cosines_product = cos(to[:lat]) * cos(from[:lat]) * cos(from[:lng] - to[:lng])\n  sines_product = sin(to[:lat]) * sin(from[:lat])\n  return earth_radius_mi * acos(cosines_product + sines_product)\nend\n&lt;/code&gt;&lt;/pre&gt;\n    ","\n&lt;pre&gt;&lt;code&gt;function getDistanceFromLatLonInKm(lat1,lon1,lat2,lon2,units) {\n  var R = 6371; // Radius of the earth in km\n  var dLat = deg2rad(lat2-lat1);  // deg2rad below\n  var dLon = deg2rad(lon2-lon1); \n  var a = \n    Math.sin(dLat/2) * Math.sin(dLat/2) +\n    Math.cos(deg2rad(lat1)) * Math.cos(deg2rad(lat2)) * \n    Math.sin(dLon/2) * Math.sin(dLon/2)\n    ; \n  var c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a)); \n  var d = R * c; \n  var miles = d / 1.609344; \n\nif ( units == &apos;km&apos; ) {  \nreturn d; \n } else {\nreturn miles;\n}}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Chuck&apos;s solution, valid for miles also.&lt;/p&gt;\n    ","\n&lt;p&gt;In Mysql use the following function pass the parameters as using  &lt;code&gt;POINT(LONG,LAT)&lt;/code&gt;&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;CREATE FUNCTION `distance`(a POINT, b POINT)\n RETURNS double\n    DETERMINISTIC\nBEGIN\n\nRETURN\n\nGLength( LineString(( PointFromWKB(a)), (PointFromWKB(b)))) * 100000; -- To Make the distance in meters\n\nEND;\n&lt;/code&gt;&lt;/pre&gt;\n    "]},"randomTags":[{"name":"dom-events","slug":"dom-events"},{"name":"pivot","slug":"pivot"},{"name":"sequence-points","slug":"sequence-points"},{"name":"aggregate","slug":"aggregate"},{"name":"prop","slug":"prop"},{"name":"ssl-certificate","slug":"ssl-certificate"},{"name":"event-propagation","slug":"event-propagation"},{"name":"branch-prediction","slug":"branch-prediction"},{"name":"forms","slug":"forms"},{"name":"underscore.js","slug":"underscore.js"},{"name":"footer","slug":"footer"},{"name":"casting","slug":"casting"},{"name":"3d","slug":"3d"},{"name":"operator-precedence","slug":"operator-precedence"},{"name":"shared-ptr","slug":"shared-ptr"},{"name":"android-activity","slug":"android-activity"},{"name":"conditional-operator","slug":"conditional-operator"},{"name":"asp.net-mvc-5","slug":"asp.net-mvc-5"},{"name":"hashcode","slug":"hashcode"},{"name":"while-loop","slug":"while-loop"}]},"__N_SSG":true}