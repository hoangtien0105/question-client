{"pageProps":{"data":{"count":1,"rows":[{"id":145,"title":"Why does std::getline() skip input after a formatted extraction?","slug":"why-does-std::getline()-skip-input-after-a-formatted-extraction-1657384756118","postType":"QUESTION","createdAt":"2022-07-09T16:39:16.000Z","updatedAt":"2022-07-09T16:39:16.000Z","tags":[{"id":528,"name":"istream","slug":"istream","createdAt":"2022-07-09T16:39:16.000Z","updatedAt":"2022-07-09T16:39:16.000Z","Questions_Tags":{"questionId":145,"tagId":528}}]}]},"slug":"istream","page":1,"answers":{"145":["\n&lt;h1&gt;Why does this happen?&lt;/h1&gt;\n&lt;p&gt;This has little to do with the input you provided yourself but rather with the default behavior &lt;code&gt;std::getline()&lt;/code&gt; has. When you provided your input for the age (&lt;code&gt;std::cin &amp;gt;&amp;gt; age&lt;/code&gt;), you not only submitted the following characters, but also an implicit newline was appended to the stream when you typed &lt;kbd&gt;Enter&lt;/kbd&gt;:&lt;/p&gt;\n&lt;blockquote&gt;\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-string&quot;&gt;&quot;10\\n&quot;&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;/blockquote&gt;\n&lt;p&gt;A newline is always appended to your input when you select &lt;kbd&gt;Enter&lt;/kbd&gt; or &lt;kbd&gt;Return&lt;/kbd&gt; when submitting from a terminal. It is also used in files for moving toward the next line. The newline is left in the buffer after the extraction into &lt;code&gt;age&lt;/code&gt; until the next I/O operation where it is either discarded or read. When the flow of control reaches &lt;code&gt;std::getline()&lt;/code&gt;, it will see &lt;code&gt;&quot;\\nMr. Whiskers&quot;&lt;/code&gt; and the newline at the beginning will be discarded, but the input operation will stop immediately. The reason this happens is because the job of &lt;code&gt;std::getline()&lt;/code&gt; is to attempt to read characters and stop when it finds a newline. So the rest of your input is left in the buffer unread.&lt;/p&gt;\n&lt;h1&gt;Solution&lt;/h1&gt;\n&lt;h2&gt;&lt;code&gt;cin.ignore()&lt;/code&gt;&lt;/h2&gt;\n&lt;p&gt;To fix this, one option is to skip over the newline before doing &lt;code&gt;std::getline()&lt;/code&gt;. You can do this by calling &lt;code&gt;std::cin.ignore()&lt;/code&gt; after the first input operation. It will discard the next character (the newline character) so that it is no longer in the way.&lt;/p&gt;\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;std::cin &amp;gt;&amp;gt; age;\nstd::cin.&lt;span class=&quot;hljs-built_in&quot;&gt;ignore&lt;/span&gt;();\nstd::&lt;span class=&quot;hljs-built_in&quot;&gt;getline&lt;/span&gt;(std::cin, name);\n\n&lt;span class=&quot;hljs-built_in&quot;&gt;assert&lt;/span&gt;(std::cin); \n&lt;span class=&quot;hljs-comment&quot;&gt;// Success!&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2&gt;&lt;code&gt;std::ws&lt;/code&gt;&lt;/h2&gt;\n&lt;p&gt;Another way to discard the whitespace is to use the &lt;code&gt;std::ws&lt;/code&gt; function which is a manipulator designed to extract and discard leading whitespace from the beginning of an input stream:&lt;/p&gt;\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;std::cin &amp;gt;&amp;gt; age;\nstd::&lt;span class=&quot;hljs-built_in&quot;&gt;getline&lt;/span&gt;(std::cin &amp;gt;&amp;gt; std::ws, name);\n\n&lt;span class=&quot;hljs-built_in&quot;&gt;assert&lt;/span&gt;(std::cin);\n&lt;span class=&quot;hljs-comment&quot;&gt;// Success!&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;The &lt;code&gt;std::cin &amp;gt;&amp;gt; std::ws&lt;/code&gt; expression is executed before the &lt;code&gt;std::getline()&lt;/code&gt; call (and after the &lt;code&gt;std::cin &amp;gt;&amp;gt; age&lt;/code&gt; call) so that the newline character is removed.&lt;/p&gt;\n&lt;p&gt;The difference is that &lt;code&gt;ignore()&lt;/code&gt; discards only 1 character (or N characters when given a parameter), and &lt;code&gt;std::ws&lt;/code&gt; continues to ignore whitespace until it finds a non-whitespace character. So if you don&apos;t know how much whitespace will precede the next token you should consider using this.&lt;/p&gt;\n&lt;h2&gt;Match the operations&lt;/h2&gt;\n&lt;p&gt;When you run into an issue like this it&apos;s usually because you&apos;re combining formatted input operations with unformatted input operations. A formatted input operation is when you take input and format it for a certain type. That&apos;s what &lt;code&gt;operator&amp;gt;&amp;gt;()&lt;/code&gt; is for. Unformatted input operations are anything other than that, like &lt;code&gt;std::getline()&lt;/code&gt;, &lt;code&gt;std::cin.read()&lt;/code&gt;, &lt;code&gt;std::cin.get()&lt;/code&gt;, etc. Those functions don&apos;t care about the format of the input and only process raw text.&lt;/p&gt;\n&lt;p&gt;If you stick to using a single type of formatting then you can avoid this annoying issue:&lt;/p&gt;\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-comment&quot;&gt;// Unformatted I/O&lt;/span&gt;\nstd::string age, name;\nstd::&lt;span class=&quot;hljs-built_in&quot;&gt;getline&lt;/span&gt;(std::cin, age);\nstd::&lt;span class=&quot;hljs-built_in&quot;&gt;getline&lt;/span&gt;(std::cin, name);\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;or&lt;/p&gt;\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-comment&quot;&gt;// Formatted I/O&lt;/span&gt;\n&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; age;\nstd::string firstName, lastName;\nstd::cin &amp;gt;&amp;gt; age &amp;gt;&amp;gt; firstName &amp;gt;&amp;gt; lastName;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;If you choose to read everything as strings using the unformatted operations you can convert them into the appropriate types afterwards.&lt;/p&gt;\n    ","\n&lt;p&gt;Everything will be OK if you change your initial code in the following way:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; ((cin &amp;gt;&amp;gt; name).&lt;span class=&quot;hljs-built_in&quot;&gt;get&lt;/span&gt;() &amp;amp;&amp;amp; std::&lt;span class=&quot;hljs-built_in&quot;&gt;getline&lt;/span&gt;(cin, state))\n&lt;/code&gt;&lt;/pre&gt;\n    ","\n&lt;p&gt;This happens because an implicit line feed also known as newline character &lt;code&gt;\\n&lt;/code&gt; is appended to all user input from a terminal as it&apos;s telling the stream to start a new line. You can safely account for this by using &lt;a href=&quot;http://en.cppreference.com/w/cpp/string/basic_string/getline&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;code&gt;std::getline&lt;/code&gt;&lt;/a&gt; when checking for multiple lines of user input. The default behavior of &lt;code&gt;std::getline&lt;/code&gt; will read everything up to and including the newline character &lt;code&gt;\\n&lt;/code&gt; from the input stream object which is &lt;code&gt;std::cin&lt;/code&gt; in this case.&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&amp;lt;string&amp;gt;&lt;/span&gt;&lt;/span&gt;\n\n&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt;\n&lt;/span&gt;{\n    std::string name;\n    std::string state;\n\n    &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (std::&lt;span class=&quot;hljs-built_in&quot;&gt;getline&lt;/span&gt;(std::cin, name) &amp;amp;&amp;amp; std::&lt;span class=&quot;hljs-built_in&quot;&gt;getline&lt;/span&gt;(std::cin, state))\n    {\n        std::cout &amp;lt;&amp;lt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;Your name is &quot;&lt;/span&gt; &amp;lt;&amp;lt; name &amp;lt;&amp;lt; &lt;span class=&quot;hljs-string&quot;&gt;&quot; and you live in &quot;&lt;/span&gt; &amp;lt;&amp;lt; state;\n    }\n    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;;\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;blockquote&gt;\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;Input:\n\n&lt;span class=&quot;hljs-string&quot;&gt;&quot;John&quot;&lt;/span&gt;\n&lt;span class=&quot;hljs-string&quot;&gt;&quot;New Hampshire&quot;&lt;/span&gt;\n\nOutput:\n\n&lt;span class=&quot;hljs-string&quot;&gt;&quot;Your name is John and you live in New Hampshire&quot;&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;/blockquote&gt;\n    ","\n&lt;p&gt;Since everyone above has answered the problem for input &lt;code&gt;10\\nMr Whisker\\n&lt;/code&gt;, I would like to answer a different approach. all the solution above published the code for if the buffer is like &lt;code&gt;10\\nMr Whisker\\n&lt;/code&gt;. but what if we don&apos;t know how user will behave giving input. the user might type &lt;code&gt;10\\n\\nMr. Whisker\\n&lt;/code&gt; or &lt;code&gt;10 \\n\\n Mr. whisker\\n&lt;/code&gt; by mistake. in that case, codes above may not work. so, I use the function below to take string input to address the problem.&lt;/p&gt;\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;string &lt;span class=&quot;hljs-title&quot;&gt;StringInput&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt;  &lt;span class=&quot;hljs-comment&quot;&gt;//returns null-terminated string&lt;/span&gt;\n&lt;/span&gt;{\n    string input;\n    &lt;span class=&quot;hljs-built_in&quot;&gt;getline&lt;/span&gt;(cin, input);\n    &lt;span class=&quot;hljs-keyword&quot;&gt;while&lt;/span&gt;(input.&lt;span class=&quot;hljs-built_in&quot;&gt;length&lt;/span&gt;()==&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;)&lt;span class=&quot;hljs-comment&quot;&gt;//keep taking input until valid string is taken&lt;/span&gt;\n    {\n        &lt;span class=&quot;hljs-built_in&quot;&gt;getline&lt;/span&gt;(cin, input);\n    }\n    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; input.&lt;span class=&quot;hljs-built_in&quot;&gt;c_str&lt;/span&gt;();\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;So, the answer would be:&lt;/p&gt;\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&amp;lt;string&amp;gt;&lt;/span&gt;&lt;/span&gt;\n\n&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt;\n&lt;/span&gt;{\n    &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; age;\n    std::string name;\n\n    std::cin &amp;gt;&amp;gt; age;\n    name = &lt;span class=&quot;hljs-built_in&quot;&gt;StringInput&lt;/span&gt;();\n    \n    std::cout &amp;lt;&amp;lt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;My cat is &quot;&lt;/span&gt; &amp;lt;&amp;lt; age &amp;lt;&amp;lt; &lt;span class=&quot;hljs-string&quot;&gt;&quot; years old and their name is &quot;&lt;/span&gt; &amp;lt;&amp;lt; name &amp;lt;&amp;lt; std::endl;\n    \n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;&lt;strong&gt;Extra:&lt;/strong&gt;&lt;/p&gt;\n&lt;p&gt;If user inputs &lt;code&gt;a \\n10\\n \\nmr. whiskey&lt;/code&gt;;\nTo check whether &lt;code&gt;int&lt;/code&gt; input is valid or not, this function can be used to check &lt;code&gt;int&lt;/code&gt; input (program will have undefined behavior if &lt;code&gt;char&lt;/code&gt; is given as input instead of &lt;code&gt;int&lt;/code&gt;):&lt;/p&gt;\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;\n&lt;span class=&quot;hljs-comment&quot;&gt;//instead of &quot;std::cin&amp;gt;&amp;gt;age;&quot; use &quot;get_untill_int(&amp;amp;age);&quot; in main function.&lt;/span&gt;\n&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;get_Untill_Int&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt;* pInput)&lt;/span&gt;&lt;span class=&quot;hljs-comment&quot;&gt;//keep taking input untill input is `int or float`&lt;/span&gt;\n&lt;/span&gt;{\n    cin&amp;gt;&amp;gt; *pInput;\n    &lt;span class=&quot;hljs-comment&quot;&gt;/*-----------check input validation----------------*/&lt;/span&gt;\n    &lt;span class=&quot;hljs-keyword&quot;&gt;while&lt;/span&gt; (!cin) \n    {\n        cin.&lt;span class=&quot;hljs-built_in&quot;&gt;clear&lt;/span&gt;();\n        cin.&lt;span class=&quot;hljs-built_in&quot;&gt;ignore&lt;/span&gt;(&lt;span class=&quot;hljs-number&quot;&gt;100&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&apos;\\n&apos;&lt;/span&gt;);\n        cout&amp;lt;&amp;lt;&lt;span class=&quot;hljs-string&quot;&gt;&quot;Invalid Input Type.\\nEnter again: &quot;&lt;/span&gt;;\n        cin &amp;gt;&amp;gt;*pInput;\n    }\n    &lt;span class=&quot;hljs-comment&quot;&gt;/*-----------checked input validation-------------*/&lt;/span&gt;\n}\n&lt;/code&gt;&lt;/pre&gt;\n    ","\n&lt;p&gt;I am really wondering. C++ has a dedicated function for eating up any remaining or whatever white spaces. It is called &lt;a href=&quot;https://en.cppreference.com/w/cpp/io/manip/ws&quot; rel=&quot;nofollow noreferrer&quot;&gt;std::ws&lt;/a&gt;. And then, you can simply use&lt;/p&gt;\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;std::&lt;span class=&quot;hljs-built_in&quot;&gt;getline&lt;/span&gt;(std::cin &amp;gt;&amp;gt; std::ws, name);\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;That should be the idomatic approach. For each transistion between formatted to unformatted input that should be used.&lt;/p&gt;\n&lt;p&gt;If we are not talking about white spaces, but entering for example letters where a number is expected, then we should follow the CPP reference and use&lt;/p&gt;\n&lt;p&gt;&lt;code&gt;.ignore(std::numeric_limits&amp;lt;std::streamsize&amp;gt;::max(), &apos;\\n&apos;);&lt;/code&gt; to eliminate the wrong stuff.&lt;/p&gt;\n&lt;p&gt;Please read &lt;a href=&quot;https://en.cppreference.com/w/cpp/io/basic_istream/ignore&quot; rel=&quot;nofollow noreferrer&quot;&gt;here&lt;/a&gt;&lt;/p&gt;\n    "]},"randomTags":[{"name":"security","slug":"security"},{"name":"multithreading","slug":"multithreading"},{"name":"automatic-semicolon-insertion","slug":"automatic-semicolon-insertion"},{"name":"sleep","slug":"sleep"},{"name":"pandas-explode","slug":"pandas-explode"},{"name":"matrix","slug":"matrix"},{"name":"dynamic-languages","slug":"dynamic-languages"},{"name":"css-position","slug":"css-position"},{"name":"margin","slug":"margin"},{"name":"google-chrome","slug":"google-chrome"},{"name":"chrome-web-driver","slug":"chrome-web-driver"},{"name":"substring","slug":"substring"},{"name":"strict-aliasing","slug":"strict-aliasing"},{"name":"recursive-query","slug":"recursive-query"},{"name":"string-aggregation","slug":"string-aggregation"},{"name":"uitableview","slug":"uitableview"},{"name":"list","slug":"list"},{"name":"haversine","slug":"haversine"},{"name":"browser-detection","slug":"browser-detection"},{"name":"object-notation","slug":"object-notation"}]},"__N_SSG":true}