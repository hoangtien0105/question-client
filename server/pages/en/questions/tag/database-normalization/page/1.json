{"pageProps":{"data":{"count":1,"rows":[{"id":68,"title":"Is storing a delimited list in a database column really that bad?","slug":"is-storing-a-delimited-list-in-a-database-column-really-that-bad-1657384474773","postType":"QUESTION","createdAt":"2022-07-09T16:34:34.000Z","updatedAt":"2022-07-09T16:34:34.000Z","tags":[{"id":251,"name":"database-normalization","slug":"database-normalization","createdAt":"2022-07-09T16:34:34.000Z","updatedAt":"2022-07-09T16:34:34.000Z","Questions_Tags":{"questionId":68,"tagId":251}}]}]},"slug":"database-normalization","page":"1","answers":{"68":["\n&lt;p&gt;In addition to violating &lt;a href=&quot;http://en.wikipedia.org/wiki/1NF&quot; rel=&quot;nofollow noreferrer&quot;&gt;First Normal Form&lt;/a&gt; because of the repeating group of values stored in a single column, comma-separated lists have a lot of other more practical problems:&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;Cant ensure that each value is the right data type: no way to prevent &lt;em&gt;1,2,3,banana,5&lt;/em&gt;&lt;/li&gt;\n&lt;li&gt;Cant use foreign key constraints to link values to a lookup table; no way to enforce referential integrity.&lt;/li&gt;\n&lt;li&gt;Cant enforce uniqueness: no way to prevent &lt;em&gt;1,2,3,3,3,5&lt;/em&gt;&lt;/li&gt;\n&lt;li&gt;Cant delete a value from the list without fetching the whole list.&lt;/li&gt;\n&lt;li&gt;Can&apos;t store a list longer than what fits in the string column.&lt;/li&gt;\n&lt;li&gt;Hard to search for all entities with a given value in the list; you have to use an inefficient table-scan. May have to resort to regular expressions, for example in MySQL:&lt;br&gt;\n&lt;code&gt;idlist REGEXP &apos;[[:&amp;lt;:]]2[[:&amp;gt;:]]&apos;&lt;/code&gt; or in MySQL 8.0: &lt;code&gt;idlist REGEXP &apos;\\\\b2\\\\b&apos;&lt;/code&gt;&lt;/li&gt;\n&lt;li&gt;Hard to count elements in the list, or do other aggregate queries.&lt;/li&gt;\n&lt;li&gt;Hard to join the values to the lookup table they reference.&lt;/li&gt;\n&lt;li&gt;Hard to fetch the list in sorted order.&lt;/li&gt;\n&lt;li&gt;Hard to choose a separator that is guaranteed not to appear in the values&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;To solve these problems, you have to write tons of application code, reinventing functionality that the RDBMS &lt;em&gt;already provides much more efficiently&lt;/em&gt;.&lt;/p&gt;\n&lt;p&gt;Comma-separated lists are wrong enough that I made this the first chapter in my book: &lt;a href=&quot;https://pragprog.com/titles/bksap1/&quot; rel=&quot;nofollow noreferrer&quot;&gt;SQL Antipatterns, Volume 1: Avoiding the Pitfalls of Database Programming&lt;/a&gt;.&lt;/p&gt;\n&lt;p&gt;There are times when you need to employ denormalization, but as &lt;a href=&quot;https://stackoverflow.com/a/3653507/578288&quot;&gt;@OMG Ponies mentions&lt;/a&gt;, these are exception cases.  Any non-relational optimization benefits one type of query at the expense of other uses of the data, so be sure you know which of your queries need to be treated so specially that they deserve denormalization.&lt;/p&gt;\n    ","\n&lt;p&gt;&quot;One reason was laziness&quot;.&lt;/p&gt;\n\n&lt;p&gt;This rings alarm bells. The only reason you should do something like this is that you know how to do it &quot;the right way&quot; but you have come to the conclusion that there is a tangible reason not to do it that way.&lt;/p&gt;\n\n&lt;p&gt;Having said this: if the data you are choosing to store this way is data that you will never need to query by, then there may be a case for storing it in the way you have chosen.&lt;/p&gt;\n\n&lt;p&gt;(Some users would dispute the statement in my previous paragraph, saying that &quot;you can never know what requirements will be added in the future&quot;. These users are either misguided or stating a religious conviction. Sometimes it is advantageous to work to the requirements you have before you.)&lt;/p&gt;\n    ","\n&lt;p&gt;There are numerous questions on SO asking:&lt;/p&gt;\n\n&lt;ul&gt;\n&lt;li&gt;how to get a count of specific values from the comma separated list&lt;/li&gt;\n&lt;li&gt;how to get records that have only the same 2/3/etc specific value from that comma separated list&lt;/li&gt;\n&lt;/ul&gt;\n\n&lt;p&gt;Another problem with the comma separated list is ensuring the values are consistent - storing text means the possibility of typos...&lt;/p&gt;\n\n&lt;p&gt;These are all symptoms of denormalized data, and highlight why you should always model for normalized data.  Denormalization &lt;em&gt;can&lt;/em&gt; be a query optimization, &lt;strong&gt;&lt;em&gt;to be applied when the need actually presents itself&lt;/em&gt;&lt;/strong&gt;.&lt;/p&gt;\n    ","\n&lt;p&gt;In general anything can be defensible if it meets the requirements of your project.  This doesn&apos;t mean that people will agree with or want to defend your decision...&lt;/p&gt;\n\n&lt;p&gt;In general, storing data in this way is suboptimal (e.g. harder to do efficient queries) and may cause maintenance issues if you modify the items in your form.  Perhaps you could have found a middle ground and used an integer representing a set of bit flags instead?&lt;/p&gt;\n    ","\n&lt;p&gt;Yes, I would say that it really is that bad.  It&apos;s a defensible choice, but that doesn&apos;t make it correct or good.&lt;/p&gt;\n\n&lt;p&gt;It breaks first normal form.&lt;/p&gt;\n\n&lt;p&gt;A second criticism is that putting raw input results directly into a database, without any validation or binding at all, leaves you open to SQL injection attacks.&lt;/p&gt;\n\n&lt;p&gt;What you&apos;re calling laziness and lack of SQL knowledge is the stuff that neophytes are made of.  I&apos;d recommend taking the time to do it properly and view it as an opportunity to learn.&lt;/p&gt;\n\n&lt;p&gt;Or leave it as it is and learn the painful lesson of a SQL injection attack.&lt;/p&gt;\n    ","\n&lt;p&gt;I needed a multi-value column, it could be implemented as an xml field&lt;/p&gt;\n\n&lt;p&gt;It could be converted to a comma delimited as necessary&lt;/p&gt;\n\n&lt;p&gt;&lt;a href=&quot;https://stackoverflow.com/questions/6097849/querying-an-xml-list-in-sql-server-using-xquery&quot;&gt;querying an XML list in sql server using Xquery&lt;/a&gt;.&lt;/p&gt;\n\n&lt;p&gt;By being an xml field, some of the concerns can be addressed.&lt;/p&gt;\n\n&lt;p&gt;&lt;strong&gt;With CSV:&lt;/strong&gt; Can&apos;t ensure that each value is the right data type: no way to prevent 1,2,3,banana,5&lt;/p&gt;\n\n&lt;p&gt;&lt;strong&gt;With XML:&lt;/strong&gt; values in a tag can be forced to be the correct type&lt;/p&gt;\n\n&lt;hr&gt;\n\n&lt;p&gt;&lt;strong&gt;With CSV:&lt;/strong&gt; Can&apos;t use foreign key constraints to link values to a lookup table; no way to enforce referential integrity.&lt;/p&gt;\n\n&lt;p&gt;&lt;strong&gt;With XML:&lt;/strong&gt; still an issue&lt;/p&gt;\n\n&lt;hr&gt;\n\n&lt;p&gt;&lt;strong&gt;With CSV:&lt;/strong&gt; Can&apos;t enforce uniqueness: no way to prevent 1,2,3,3,3,5&lt;/p&gt;\n\n&lt;p&gt;&lt;strong&gt;With XML:&lt;/strong&gt; still an issue&lt;/p&gt;\n\n&lt;hr&gt;\n\n&lt;p&gt;&lt;strong&gt;With CSV:&lt;/strong&gt; Can&apos;t delete a value from the list without fetching the whole list.&lt;/p&gt;\n\n&lt;p&gt;&lt;strong&gt;With XML:&lt;/strong&gt; single items can be removed&lt;/p&gt;\n\n&lt;hr&gt;\n\n&lt;p&gt;&lt;strong&gt;With CSV:&lt;/strong&gt; Hard to search for all entities with a given value in the list; you have to use an inefficient table-scan.&lt;/p&gt;\n\n&lt;p&gt;&lt;strong&gt;With XML:&lt;/strong&gt; xml field can be indexed&lt;/p&gt;\n\n&lt;hr&gt;\n\n&lt;p&gt;&lt;strong&gt;With CSV:&lt;/strong&gt; Hard to count elements in the list, or do other aggregate queries.**&lt;/p&gt;\n\n&lt;p&gt;&lt;strong&gt;With XML:&lt;/strong&gt; not particularly hard &lt;/p&gt;\n\n&lt;hr&gt;\n\n&lt;p&gt;&lt;strong&gt;With CSV:&lt;/strong&gt; Hard to join the values to the lookup table they reference.**&lt;/p&gt;\n\n&lt;p&gt;&lt;strong&gt;With XML:&lt;/strong&gt; not particularly hard &lt;/p&gt;\n\n&lt;hr&gt;\n\n&lt;p&gt;&lt;strong&gt;With CSV:&lt;/strong&gt; Hard to fetch the list in sorted order.&lt;/p&gt;\n\n&lt;p&gt;&lt;strong&gt;With XML:&lt;/strong&gt; not particularly hard &lt;/p&gt;\n\n&lt;hr&gt;\n\n&lt;p&gt;&lt;strong&gt;With CSV:&lt;/strong&gt; Storing integers as strings takes about twice as much space as storing binary integers.&lt;/p&gt;\n\n&lt;p&gt;&lt;strong&gt;With XML:&lt;/strong&gt; storage is even worse than a csv &lt;/p&gt;\n\n&lt;hr&gt;\n\n&lt;p&gt;&lt;strong&gt;With CSV:&lt;/strong&gt; Plus a lot of comma characters.&lt;/p&gt;\n\n&lt;p&gt;&lt;strong&gt;With XML:&lt;/strong&gt; tags are used instead of commas&lt;/p&gt;\n\n&lt;hr&gt;\n\n&lt;p&gt;In short, using XML gets around some of the issues with delimited list AND can be converted to a delimited list as needed&lt;/p&gt;\n    ","\n&lt;p&gt;Yes, it &lt;em&gt;is&lt;/em&gt; that bad.  My view is that if you don&apos;t like using relational databases then look for an alternative that suits you better, there are lots of interesting &quot;NOSQL&quot; projects out there with some really advanced features.&lt;/p&gt;\n    ","\n&lt;p&gt;Well I&apos;ve been using a key/value pair tab separated list in a NTEXT column in SQL Server for more than 4 years now and it works. You do lose the flexibility of making queries but on the other hand, if you have a library that persists/derpersists the key value pair then it&apos;s not a that bad idea.&lt;/p&gt;\n    ","\n&lt;p&gt;I would probably take the middle ground: make each field in the CSV into a separate column in the database, but not worry much about normalization (at least for now). At some point, normalization &lt;em&gt;might&lt;/em&gt; become interesting, but with all the data shoved into a single column you&apos;re gaining virtually no benefit from using a database at all. You need to separate the data into logical fields/columns/whatever you want to call them before you can manipulate it meaningfully at all.&lt;/p&gt;\n    ","\n&lt;p&gt;If you have a fixed number of boolean fields, you could use a &lt;code&gt;INT(1) NOT NULL&lt;/code&gt; (or &lt;code&gt;BIT NOT NULL&lt;/code&gt; if it exists) or &lt;code&gt;CHAR (0)&lt;/code&gt; (nullable) for each. You could also use a &lt;code&gt;SET&lt;/code&gt; (I forget the exact syntax).&lt;/p&gt;\n    "]},"randomTags":[{"name":"xmlhttprequest","slug":"xmlhttprequest"},{"name":"preg-match","slug":"preg-match"},{"name":"printing","slug":"printing"},{"name":"environment-variables","slug":"environment-variables"},{"name":"interface","slug":"interface"},{"name":"angularjs","slug":"angularjs"},{"name":"responsive-design","slug":"responsive-design"},{"name":"uuid","slug":"uuid"},{"name":"algorithm","slug":"algorithm"},{"name":"this","slug":"this"},{"name":"automatic-semicolon-insertion","slug":"automatic-semicolon-insertion"},{"name":"undo","slug":"undo"},{"name":"include","slug":"include"},{"name":"tabs","slug":"tabs"},{"name":"cors","slug":"cors"},{"name":"prototype-oriented","slug":"prototype-oriented"},{"name":"selenium","slug":"selenium"},{"name":"error-handling","slug":"error-handling"},{"name":"spring","slug":"spring"},{"name":"include-path","slug":"include-path"}]},"__N_SSG":true}