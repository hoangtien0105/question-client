{"pageProps":{"data":{"count":1,"rows":[{"id":512,"title":"Web-scraping JavaScript page with Python","slug":"web-scraping-javascript-page-with-python-1657388240875","postType":"QUESTION","createdAt":"2022-07-09T17:37:20.000Z","updatedAt":"2022-07-09T17:37:20.000Z","tags":[{"id":2541,"name":"python-2.x","slug":"python-2.x","createdAt":"2022-07-09T17:37:20.000Z","updatedAt":"2022-07-09T17:37:20.000Z","Questions_Tags":{"questionId":512,"tagId":2541}}]}]},"slug":"python-2.x","page":1,"answers":{"512":["\n&lt;p&gt;EDIT Sept 2021: &lt;code&gt;phantomjs&lt;/code&gt; isn&apos;t maintained any more, either&lt;/p&gt;\n&lt;p&gt;EDIT 30/Dec/2017: This answer appears in top results of Google searches, so I decided to update it. The old answer is still at the end.&lt;/p&gt;\n&lt;p&gt;dryscape isn&apos;t maintained anymore and the library dryscape developers recommend is Python 2 only. I have found using Selenium&apos;s python library with Phantom JS as a web driver fast enough and easy to get the work done.&lt;/p&gt;\n&lt;p&gt;Once you have installed &lt;a href=&quot;http://phantomjs.org/download.html&quot; rel=&quot;noreferrer&quot;&gt;Phantom JS&lt;/a&gt;, make sure the &lt;code&gt;phantomjs&lt;/code&gt; binary is available in the current path:&lt;/p&gt;\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-sql&quot;&gt;phantomjs &lt;span class=&quot;hljs-comment&quot;&gt;--version&lt;/span&gt;\n# &lt;span class=&quot;hljs-keyword&quot;&gt;result&lt;/span&gt;:\n&lt;span class=&quot;hljs-number&quot;&gt;2.1&lt;/span&gt;&lt;span class=&quot;hljs-number&quot;&gt;.1&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;#Example\nTo give an example, I created a sample page with following HTML code. (&lt;a href=&quot;http://avi.im/stuff/js-or-no-js.html&quot; rel=&quot;noreferrer&quot;&gt;link&lt;/a&gt;):&lt;/p&gt;\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-xml&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;&amp;lt;!DOCTYPE &lt;span class=&quot;hljs-keyword&quot;&gt;html&lt;/span&gt;&amp;gt;&lt;/span&gt;\n&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;html&lt;/span&gt;&amp;gt;&lt;/span&gt;\n&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;head&lt;/span&gt;&amp;gt;&lt;/span&gt;\n  &lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;meta&lt;/span&gt; &lt;span class=&quot;hljs-attr&quot;&gt;charset&lt;/span&gt;=&lt;span class=&quot;hljs-string&quot;&gt;&quot;utf-8&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;\n  &lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;title&lt;/span&gt;&amp;gt;&lt;/span&gt;Javascript scraping test&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;title&lt;/span&gt;&amp;gt;&lt;/span&gt;\n&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;head&lt;/span&gt;&amp;gt;&lt;/span&gt;\n&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;body&lt;/span&gt;&amp;gt;&lt;/span&gt;\n  &lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;hljs-attr&quot;&gt;id&lt;/span&gt;=&lt;span class=&quot;hljs-string&quot;&gt;&apos;intro-text&apos;&lt;/span&gt;&amp;gt;&lt;/span&gt;No javascript support&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;p&lt;/span&gt;&amp;gt;&lt;/span&gt;\n  &lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;script&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;language-javascript&quot;&gt;\n     &lt;span class=&quot;hljs-variable language_&quot;&gt;document&lt;/span&gt;.&lt;span class=&quot;hljs-title function_&quot;&gt;getElementById&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&apos;intro-text&apos;&lt;/span&gt;).&lt;span class=&quot;hljs-property&quot;&gt;innerHTML&lt;/span&gt; = &lt;span class=&quot;hljs-string&quot;&gt;&apos;Yay! Supports javascript&apos;&lt;/span&gt;;\n  &lt;/span&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;script&lt;/span&gt;&amp;gt;&lt;/span&gt; \n&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;body&lt;/span&gt;&amp;gt;&lt;/span&gt;\n&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;html&lt;/span&gt;&amp;gt;&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;without javascript it says: &lt;code&gt;No javascript support&lt;/code&gt; and with javascript: &lt;code&gt;Yay! Supports javascript&lt;/code&gt;&lt;/p&gt;\n&lt;p&gt;#Scraping without JS support:&lt;/p&gt;\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-haskell&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; requests\n&lt;span class=&quot;hljs-title&quot;&gt;from&lt;/span&gt; bs4 &lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; BeautifulSoup\n&lt;span class=&quot;hljs-title&quot;&gt;response&lt;/span&gt; = requests.get(my_url)\n&lt;span class=&quot;hljs-title&quot;&gt;soup&lt;/span&gt; = &lt;span class=&quot;hljs-type&quot;&gt;BeautifulSoup&lt;/span&gt;(response.text)\n&lt;span class=&quot;hljs-title&quot;&gt;soup&lt;/span&gt;.find(id=&lt;span class=&quot;hljs-string&quot;&gt;&quot;intro-text&quot;&lt;/span&gt;)\n&lt;span class=&quot;hljs-meta&quot;&gt;# Result:&lt;/span&gt;\n&amp;lt;p id=&lt;span class=&quot;hljs-string&quot;&gt;&quot;intro-text&quot;&lt;/span&gt;&amp;gt;&lt;span class=&quot;hljs-type&quot;&gt;No&lt;/span&gt; javascript support&amp;lt;/p&amp;gt;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;#Scraping with JS support:&lt;/p&gt;\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-coffeescript&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;from&lt;/span&gt; selenium &lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; webdriver\ndriver = webdriver.PhantomJS()\ndriver.get(my_url)\np_element = driver.find_element_by_id(id_=&lt;span class=&quot;hljs-string&quot;&gt;&apos;intro-text&apos;&lt;/span&gt;)\n&lt;span class=&quot;hljs-built_in&quot;&gt;print&lt;/span&gt;(p_element.text)\n&lt;span class=&quot;hljs-comment&quot;&gt;# result:&lt;/span&gt;\n&lt;span class=&quot;hljs-string&quot;&gt;&apos;Yay! Supports javascript&apos;&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;hr&gt;\n&lt;p&gt;You can also use Python library &lt;a href=&quot;https://github.com/niklasb/dryscrape&quot; rel=&quot;noreferrer&quot;&gt;dryscrape&lt;/a&gt; to scrape javascript driven websites.&lt;/p&gt;\n&lt;p&gt;#Scraping with JS support:&lt;/p&gt;\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-haskell&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; dryscrape\n&lt;span class=&quot;hljs-title&quot;&gt;from&lt;/span&gt; bs4 &lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; BeautifulSoup\n&lt;span class=&quot;hljs-title&quot;&gt;session&lt;/span&gt; = dryscrape.&lt;span class=&quot;hljs-type&quot;&gt;Session&lt;/span&gt;()\n&lt;span class=&quot;hljs-title&quot;&gt;session&lt;/span&gt;.visit(my_url)\n&lt;span class=&quot;hljs-title&quot;&gt;response&lt;/span&gt; = session.body()\n&lt;span class=&quot;hljs-title&quot;&gt;soup&lt;/span&gt; = &lt;span class=&quot;hljs-type&quot;&gt;BeautifulSoup&lt;/span&gt;(response)\n&lt;span class=&quot;hljs-title&quot;&gt;soup&lt;/span&gt;.find(id=&lt;span class=&quot;hljs-string&quot;&gt;&quot;intro-text&quot;&lt;/span&gt;)\n&lt;span class=&quot;hljs-meta&quot;&gt;# Result:&lt;/span&gt;\n&amp;lt;p id=&lt;span class=&quot;hljs-string&quot;&gt;&quot;intro-text&quot;&lt;/span&gt;&amp;gt;&lt;span class=&quot;hljs-type&quot;&gt;Yay&lt;/span&gt;! &lt;span class=&quot;hljs-type&quot;&gt;Supports&lt;/span&gt; javascript&amp;lt;/p&amp;gt;\n&lt;/code&gt;&lt;/pre&gt;\n    ","\n&lt;p&gt;We are not getting the correct results because any javascript generated content needs to be rendered on the DOM. When we fetch an HTML page, we fetch the initial, unmodified by javascript, DOM.&lt;/p&gt;\n\n&lt;p&gt;Therefore we need to render the javascript content before we crawl the page.&lt;/p&gt;\n\n&lt;p&gt;As selenium is already mentioned many times in this thread (and how slow it gets sometimes was mentioned also), I will list two other possible solutions.&lt;/p&gt;\n\n&lt;hr&gt;\n\n&lt;p&gt;&lt;strong&gt;Solution 1:&lt;/strong&gt; This is a very nice tutorial on &lt;a href=&quot;http://www.scrapingauthority.com/scrapy-javascript&quot; rel=&quot;noreferrer&quot;&gt;how to use Scrapy to crawl javascript generated content&lt;/a&gt; and we are going to follow just that.&lt;/p&gt;\n\n&lt;p&gt;&lt;strong&gt;What we will need:&lt;/strong&gt;&lt;/p&gt;\n\n&lt;ol&gt;\n&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://www.docker.com/&quot; rel=&quot;noreferrer&quot;&gt;Docker&lt;/a&gt; installed in our machine. This is a plus over other solutions until this point, as it utilizes an OS-independent platform.&lt;/p&gt;&lt;/li&gt;\n&lt;li&gt;&lt;p&gt;&lt;a href=&quot;http://splash.readthedocs.io/en/latest/install.html&quot; rel=&quot;noreferrer&quot;&gt;Install Splash&lt;/a&gt; following the instruction listed for our corresponding OS.&lt;br&gt;Quoting from splash documentation:&lt;/p&gt;\n\n&lt;blockquote&gt;\n  &lt;p&gt;Splash is a javascript rendering service. Its a lightweight web browser with an HTTP API, implemented in Python 3 using Twisted and QT5. &lt;/p&gt;\n&lt;/blockquote&gt;\n\n&lt;p&gt;Essentially we are going to use Splash to render Javascript generated content.&lt;/p&gt;&lt;/li&gt;\n&lt;li&gt;&lt;p&gt;Run the splash server: &lt;code&gt;sudo docker run -p 8050:8050 scrapinghub/splash&lt;/code&gt;.&lt;/p&gt;&lt;/li&gt;\n&lt;li&gt;&lt;p&gt;Install the &lt;a href=&quot;https://github.com/scrapy-plugins/scrapy-splash#installation&quot; rel=&quot;noreferrer&quot;&gt;scrapy-splash&lt;/a&gt; plugin: &lt;code&gt;pip install scrapy-splash&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;\n&lt;li&gt;&lt;p&gt;Assuming that we already have a Scrapy project created (if not, &lt;a href=&quot;https://docs.scrapy.org/en/latest/intro/tutorial.html#creating-a-project&quot; rel=&quot;noreferrer&quot;&gt;let&apos;s make one&lt;/a&gt;), we will follow the guide and update the &lt;code&gt;settings.py&lt;/code&gt;:&lt;/p&gt;\n\n&lt;blockquote&gt;\n  &lt;p&gt;Then go to your scrapy projects &lt;code&gt;settings.py&lt;/code&gt; and set these middlewares:&lt;/p&gt;\n\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-bash&quot;&gt;DOWNLOADER_MIDDLEWARES = {\n      &lt;span class=&quot;hljs-string&quot;&gt;&apos;scrapy_splash.SplashCookiesMiddleware&apos;&lt;/span&gt;: 723,\n      &lt;span class=&quot;hljs-string&quot;&gt;&apos;scrapy_splash.SplashMiddleware&apos;&lt;/span&gt;: 725,\n      &lt;span class=&quot;hljs-string&quot;&gt;&apos;scrapy.downloadermiddlewares.httpcompression.HttpCompressionMiddleware&apos;&lt;/span&gt;: 810,\n}\n&lt;/code&gt;&lt;/pre&gt;\n  \n  &lt;p&gt;The URL of the Splash server(if youre using Win or OSX this should be the URL of the docker machine: &lt;a href=&quot;https://stackoverflow.com/questions/17157721/how-to-get-a-docker-containers-ip-address-from-the-host&quot;&gt;How to get a Docker container&apos;s IP address from the host?&lt;/a&gt;):&lt;/p&gt;\n\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-ini&quot;&gt;&lt;span class=&quot;hljs-attr&quot;&gt;SPLASH_URL&lt;/span&gt; = &lt;span class=&quot;hljs-string&quot;&gt;&apos;http://localhost:8050&apos;&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n  \n  &lt;p&gt;And finally you need to set these values too:&lt;/p&gt;\n\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-ini&quot;&gt;&lt;span class=&quot;hljs-attr&quot;&gt;DUPEFILTER_CLASS&lt;/span&gt; = &lt;span class=&quot;hljs-string&quot;&gt;&apos;scrapy_splash.SplashAwareDupeFilter&apos;&lt;/span&gt;\n&lt;span class=&quot;hljs-attr&quot;&gt;HTTPCACHE_STORAGE&lt;/span&gt; = &lt;span class=&quot;hljs-string&quot;&gt;&apos;scrapy_splash.SplashAwareFSCacheStorage&apos;&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;/blockquote&gt;&lt;/li&gt;\n&lt;li&gt;&lt;p&gt;Finally, we can use a &lt;a href=&quot;https://github.com/scrapy-plugins/scrapy-splash#usage&quot; rel=&quot;noreferrer&quot;&gt;&lt;code&gt;SplashRequest&lt;/code&gt;&lt;/a&gt;:&lt;/p&gt;\n\n&lt;blockquote&gt;\n  &lt;p&gt;In a normal spider you have Request objects which you can use to open URLs. If the page you want to open contains JS generated data you have to use SplashRequest(or SplashFormRequest) to render the page. Heres a simple example:&lt;/p&gt;\n\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-ruby&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;MySpider&lt;/span&gt;(scrapy.Spider):\n    name = &lt;span class=&quot;hljs-string&quot;&gt;&quot;jsscraper&quot;&lt;/span&gt;\n    start_urls = [&lt;span class=&quot;hljs-string&quot;&gt;&quot;http://quotes.toscrape.com/js/&quot;&lt;/span&gt;]\n\n    &lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;start_requests&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;&lt;span class=&quot;hljs-variable language_&quot;&gt;self&lt;/span&gt;&lt;/span&gt;):\n        &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; url &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;hljs-variable language_&quot;&gt;self&lt;/span&gt;.&lt;span class=&quot;hljs-symbol&quot;&gt;start_urls:&lt;/span&gt;\n        &lt;span class=&quot;hljs-keyword&quot;&gt;yield&lt;/span&gt; SplashRequest(\n            url=url, callback=&lt;span class=&quot;hljs-variable language_&quot;&gt;self&lt;/span&gt;.parse, endpoint=&lt;span class=&quot;hljs-string&quot;&gt;&apos;render.html&apos;&lt;/span&gt;\n        )\n\n    &lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;parse&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;&lt;span class=&quot;hljs-variable language_&quot;&gt;self&lt;/span&gt;, response&lt;/span&gt;):\n        &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; q &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; response.css(&lt;span class=&quot;hljs-string&quot;&gt;&quot;div.quote&quot;&lt;/span&gt;):\n        quote = QuoteItem()\n        quote[&lt;span class=&quot;hljs-string&quot;&gt;&quot;author&quot;&lt;/span&gt;] = q.css(&lt;span class=&quot;hljs-string&quot;&gt;&quot;.author::text&quot;&lt;/span&gt;).extract_first()\n        quote[&lt;span class=&quot;hljs-string&quot;&gt;&quot;quote&quot;&lt;/span&gt;] = q.css(&lt;span class=&quot;hljs-string&quot;&gt;&quot;.text::text&quot;&lt;/span&gt;).extract_first()\n        &lt;span class=&quot;hljs-keyword&quot;&gt;yield&lt;/span&gt; quote\n&lt;/code&gt;&lt;/pre&gt;\n  \n  &lt;p&gt;SplashRequest renders the URL as html and returns the response which you can use in the callback(parse) method.&lt;/p&gt;\n&lt;/blockquote&gt;&lt;/li&gt;\n&lt;/ol&gt;\n\n&lt;hr&gt;\n\n&lt;p&gt;&lt;strong&gt;Solution 2:&lt;/strong&gt; Let&apos;s call this experimental at the moment (May 2018)...&lt;br&gt;\n&lt;strong&gt;This solution is for Python&apos;s version 3.6&lt;/strong&gt; only (at the moment).&lt;/p&gt;\n\n&lt;p&gt;Do you know the &lt;a href=&quot;http://docs.python-requests.org/en/master/&quot; rel=&quot;noreferrer&quot;&gt;requests&lt;/a&gt; module (well who doesn&apos;t)?&lt;br&gt;\nNow it has a web crawling little sibling: &lt;a href=&quot;https://github.com/psf/requests-html&quot; rel=&quot;noreferrer&quot;&gt;requests-HTML&lt;/a&gt;:&lt;/p&gt;\n\n&lt;blockquote&gt;\n  &lt;p&gt;This library intends to make parsing HTML (e.g. scraping the web) as simple and intuitive as possible.&lt;/p&gt;\n&lt;/blockquote&gt;\n\n&lt;ol&gt;\n&lt;li&gt;&lt;p&gt;Install requests-html: &lt;code&gt;pipenv install requests-html&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;\n&lt;li&gt;&lt;p&gt;Make a request to the page&apos;s url:&lt;/p&gt;\n\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-csharp&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;from&lt;/span&gt; requests_html import HTMLSession\n\nsession = HTMLSession()\nr = session.&lt;span class=&quot;hljs-keyword&quot;&gt;get&lt;/span&gt;(a_page_url)\n&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;\n&lt;li&gt;&lt;p&gt;Render the response to get the Javascript generated bits:&lt;/p&gt;\n\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-scss&quot;&gt;r&lt;span class=&quot;hljs-selector-class&quot;&gt;.html&lt;/span&gt;&lt;span class=&quot;hljs-selector-class&quot;&gt;.render&lt;/span&gt;()\n&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;\n&lt;/ol&gt;\n\n&lt;p&gt;Finally, the module seems to offer &lt;a href=&quot;https://html.python-requests.org/#api-documentation&quot; rel=&quot;noreferrer&quot;&gt;scraping capabilities&lt;/a&gt;.&lt;br&gt;\nAlternatively, we can try the well-documented way &lt;a href=&quot;https://www.dataquest.io/blog/web-scraping-beautifulsoup/&quot; rel=&quot;noreferrer&quot;&gt;of using BeautifulSoup&lt;/a&gt; with the &lt;code&gt;r.html&lt;/code&gt; object we just rendered.&lt;/p&gt;\n    ","\n&lt;p&gt;Maybe &lt;a href=&quot;http://www.seleniumhq.org/&quot;&gt;selenium&lt;/a&gt; can do it.&lt;/p&gt;\n\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-haskell&quot;&gt;&lt;span class=&quot;hljs-title&quot;&gt;from&lt;/span&gt; selenium &lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; webdriver\n&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; time\n\n&lt;span class=&quot;hljs-title&quot;&gt;driver&lt;/span&gt; = webdriver.&lt;span class=&quot;hljs-type&quot;&gt;Firefox&lt;/span&gt;()\n&lt;span class=&quot;hljs-title&quot;&gt;driver&lt;/span&gt;.get(url)\n&lt;span class=&quot;hljs-title&quot;&gt;time&lt;/span&gt;.sleep(&lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt;)\n&lt;span class=&quot;hljs-title&quot;&gt;htmlSource&lt;/span&gt; = driver.page_source\n&lt;/code&gt;&lt;/pre&gt;\n    ","\n&lt;p&gt;If you have ever used the &lt;code&gt;Requests&lt;/code&gt; module for python before, I recently found out that the developer created a new module called &lt;code&gt;Requests-HTML&lt;/code&gt; which now also has the ability to render JavaScript.&lt;/p&gt;\n\n&lt;p&gt;You can also visit &lt;a href=&quot;https://html.python-requests.org/&quot; rel=&quot;noreferrer&quot;&gt;https://html.python-requests.org/&lt;/a&gt; to learn more about this module, or if your only interested about rendering JavaScript then you can visit &lt;a href=&quot;https://html.python-requests.org/?#javascript-support&quot; rel=&quot;noreferrer&quot;&gt;https://html.python-requests.org/?#javascript-support&lt;/a&gt; to directly learn how to use the module to render JavaScript using Python.&lt;/p&gt;\n\n&lt;p&gt;Essentially, Once you correctly install the &lt;code&gt;Requests-HTML&lt;/code&gt; module, the following example, which is &lt;a href=&quot;https://html.python-requests.org/?#javascript-support&quot; rel=&quot;noreferrer&quot;&gt;shown on the above link&lt;/a&gt;, shows how you can use this module to scrape a website and render JavaScript contained within the website:&lt;/p&gt;\n\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-csharp&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;from&lt;/span&gt; requests_html import HTMLSession\nsession = HTMLSession()\n\nr = session.&lt;span class=&quot;hljs-keyword&quot;&gt;get&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&apos;http://python-requests.org/&apos;&lt;/span&gt;)\n\nr.html.render()\n\nr.html.search(&lt;span class=&quot;hljs-string&quot;&gt;&apos;Python 2 will retire in only {months} months!&apos;&lt;/span&gt;)[&lt;span class=&quot;hljs-string&quot;&gt;&apos;months&apos;&lt;/span&gt;]\n\n&lt;span class=&quot;hljs-string&quot;&gt;&apos;&amp;lt;time&amp;gt;25&amp;lt;/time&amp;gt;&apos;&lt;/span&gt; &lt;span class=&quot;hljs-meta&quot;&gt;#This is the result.&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;I recently learnt about this from a YouTube video. &lt;a href=&quot;https://www.youtube.com/watch?v=gKT_tg87H5Y&quot; rel=&quot;noreferrer&quot;&gt;Click Here!&lt;/a&gt; to watch the YouTube video, which demonstrates how the module works.&lt;/p&gt;\n    ","\n&lt;p&gt;It sounds like the data you&apos;re really looking for can be accessed via secondary URL called by some javascript on the primary page.&lt;/p&gt;\n\n&lt;p&gt;While you could try running javascript on the server to handle this, a simpler approach  to might be to load up the page using Firefox and use a tool like &lt;a href=&quot;http://www.google.co.uk/url?sa=t&amp;amp;rct=j&amp;amp;q=charles&amp;amp;source=web&amp;amp;cd=1&amp;amp;ved=0CC4QFjAA&amp;amp;url=http://www.charlesproxy.com/&amp;amp;ei=FBC5TpyZC9Ha4QSD7umcCA&amp;amp;usg=AFQjCNG_O70VsRrfb_q7F66Nkb9ZK6MNMA&quot; rel=&quot;noreferrer&quot;&gt;Charles&lt;/a&gt; or &lt;a href=&quot;http://www.google.co.uk/url?sa=t&amp;amp;rct=j&amp;amp;q=firebug&amp;amp;source=web&amp;amp;cd=1&amp;amp;ved=0CDEQFjAA&amp;amp;url=http://getfirebug.com/&amp;amp;ei=TBC5TuOPIbKQ4gTk7J3vBw&amp;amp;usg=AFQjCNGT1rhhsYGPQx5Vr5A8RvhIgdSp9g&quot; rel=&quot;noreferrer&quot;&gt;Firebug&lt;/a&gt; to identify exactly what that secondary URL is. Then you can just query that URL directly for the data you are interested in.&lt;/p&gt;\n    ","\n&lt;p&gt;This seems to be a good solution also, taken from a &lt;a href=&quot;https://impythonist.wordpress.com/2015/01/06/ultimate-guide-for-scraping-javascript-rendered-web-pages/&quot; rel=&quot;noreferrer&quot;&gt;great blog post&lt;/a&gt;&lt;/p&gt;\n\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; sys  \n&lt;span class=&quot;hljs-keyword&quot;&gt;from&lt;/span&gt; PyQt4.QtGui &lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; *  \n&lt;span class=&quot;hljs-keyword&quot;&gt;from&lt;/span&gt; PyQt4.QtCore &lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; *  \n&lt;span class=&quot;hljs-keyword&quot;&gt;from&lt;/span&gt; PyQt4.QtWebKit &lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; *  \n&lt;span class=&quot;hljs-keyword&quot;&gt;from&lt;/span&gt; lxml &lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; html \n\n&lt;span class=&quot;hljs-comment&quot;&gt;#Take this class for granted.Just use result of rendering.&lt;/span&gt;\n&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;Render&lt;/span&gt;(&lt;span class=&quot;hljs-title class_ inherited__&quot;&gt;QWebPage&lt;/span&gt;):  \n  &lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;__init__&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;self, url&lt;/span&gt;):  \n    self.app = QApplication(sys.argv)  \n    QWebPage.__init__(self)  \n    self.loadFinished.connect(self._loadFinished)  \n    self.mainFrame().load(QUrl(url))  \n    self.app.exec_()  \n\n  &lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;_loadFinished&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;self, result&lt;/span&gt;):  \n    self.frame = self.mainFrame()  \n    self.app.quit()  \n\nurl = &lt;span class=&quot;hljs-string&quot;&gt;&apos;http://pycoders.com/archive/&apos;&lt;/span&gt;  \nr = Render(url)  \nresult = r.frame.toHtml()\n&lt;span class=&quot;hljs-comment&quot;&gt;# This step is important.Converting QString to Ascii for lxml to process&lt;/span&gt;\n\n&lt;span class=&quot;hljs-comment&quot;&gt;# The following returns an lxml element tree&lt;/span&gt;\narchive_links = html.fromstring(&lt;span class=&quot;hljs-built_in&quot;&gt;str&lt;/span&gt;(result.toAscii()))\n&lt;span class=&quot;hljs-built_in&quot;&gt;print&lt;/span&gt; archive_links\n\n&lt;span class=&quot;hljs-comment&quot;&gt;# The following returns an array containing the URLs&lt;/span&gt;\nraw_links = archive_links.xpath(&lt;span class=&quot;hljs-string&quot;&gt;&apos;//div[@class=&quot;campaign&quot;]/a/@href&apos;&lt;/span&gt;)\n&lt;span class=&quot;hljs-built_in&quot;&gt;print&lt;/span&gt; raw_links\n&lt;/code&gt;&lt;/pre&gt;\n    ","\n&lt;p&gt;Selenium is the best for scraping JS and Ajax content.&lt;/p&gt;\n\n&lt;p&gt;Check this article for &lt;a href=&quot;https://likegeeks.com/python-web-scraping/&quot; rel=&quot;noreferrer&quot;&gt;extracting data from the web using Python&lt;/a&gt;&lt;/p&gt;\n\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-ruby&quot;&gt;&lt;span class=&quot;hljs-variable&quot;&gt;$ &lt;/span&gt;pip install selenium\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Then download Chrome webdriver.&lt;/p&gt;\n\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-coffeescript&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;from&lt;/span&gt; selenium &lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; webdriver\n\nbrowser = webdriver.Chrome()\n\nbrowser.get(&lt;span class=&quot;hljs-string&quot;&gt;&quot;https://www.python.org/&quot;&lt;/span&gt;)\n\nnav = browser.find_element_by_id(&lt;span class=&quot;hljs-string&quot;&gt;&quot;mainnav&quot;&lt;/span&gt;)\n\n&lt;span class=&quot;hljs-built_in&quot;&gt;print&lt;/span&gt;(nav.text)\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Easy, right?&lt;/p&gt;\n    ","\n&lt;p&gt;You can also execute javascript using webdriver.&lt;/p&gt;\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-csharp&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;from&lt;/span&gt; selenium import webdriver\n\ndriver = webdriver.Firefox()\ndriver.&lt;span class=&quot;hljs-keyword&quot;&gt;get&lt;/span&gt;(url)\ndriver.execute_script(&lt;span class=&quot;hljs-string&quot;&gt;&apos;document.title&apos;&lt;/span&gt;)\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;or store the value in a variable&lt;/p&gt;\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-vhdl&quot;&gt;result = driver.execute_script(&lt;span class=&quot;hljs-symbol&quot;&gt;&apos;var&lt;/span&gt; &lt;span class=&quot;hljs-literal&quot;&gt;text&lt;/span&gt; = document.title ; &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-literal&quot;&gt;text&lt;/span&gt;&apos;)\n&lt;/code&gt;&lt;/pre&gt;\n    ","\n&lt;p&gt;I personally prefer using scrapy and selenium and dockerizing both in separate containers. This way you can install both with minimal hassle and crawl modern websites that almost all contain javascript in one form or another. Here&apos;s an example:&lt;/p&gt;\n\n&lt;p&gt;Use the &lt;code&gt;scrapy startproject&lt;/code&gt; to create your scraper and write your spider, the skeleton can be as simple as this:&lt;/p&gt;\n\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-ruby&quot;&gt;import scrapy\n\n\n&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;MySpider&lt;/span&gt;(scrapy.Spider):\n    name = &lt;span class=&quot;hljs-string&quot;&gt;&apos;my_spider&apos;&lt;/span&gt;\n    start_urls = [&lt;span class=&quot;hljs-string&quot;&gt;&apos;https://somewhere.com&apos;&lt;/span&gt;]\n\n    &lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;start_requests&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;&lt;span class=&quot;hljs-variable language_&quot;&gt;self&lt;/span&gt;&lt;/span&gt;):\n        &lt;span class=&quot;hljs-keyword&quot;&gt;yield&lt;/span&gt; scrapy.Request(url=&lt;span class=&quot;hljs-variable language_&quot;&gt;self&lt;/span&gt;.start_urls[&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;])\n\n\n    &lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;parse&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;&lt;span class=&quot;hljs-variable language_&quot;&gt;self&lt;/span&gt;, response&lt;/span&gt;):\n\n        &lt;span class=&quot;hljs-comment&quot;&gt;# do stuff with results, scrape items etc.&lt;/span&gt;\n        &lt;span class=&quot;hljs-comment&quot;&gt;# now were just checking everything worked&lt;/span&gt;\n\n        print(response.body)\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;The real magic happens in the middlewares.py. Overwrite two methods in the downloader middleware,  &lt;code&gt;__init__&lt;/code&gt; and  &lt;code&gt;process_request&lt;/code&gt;, in the following way:&lt;/p&gt;\n\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;&lt;span class=&quot;hljs-comment&quot;&gt;# import some additional modules that we need&lt;/span&gt;\n&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; os\n&lt;span class=&quot;hljs-keyword&quot;&gt;from&lt;/span&gt; copy &lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; deepcopy\n&lt;span class=&quot;hljs-keyword&quot;&gt;from&lt;/span&gt; time &lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; sleep\n\n&lt;span class=&quot;hljs-keyword&quot;&gt;from&lt;/span&gt; scrapy &lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; signals\n&lt;span class=&quot;hljs-keyword&quot;&gt;from&lt;/span&gt; scrapy.http &lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; HtmlResponse\n&lt;span class=&quot;hljs-keyword&quot;&gt;from&lt;/span&gt; selenium &lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; webdriver\n\n&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;SampleProjectDownloaderMiddleware&lt;/span&gt;(&lt;span class=&quot;hljs-title class_ inherited__&quot;&gt;object&lt;/span&gt;):\n\n&lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;__init__&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;self&lt;/span&gt;):\n    SELENIUM_LOCATION = os.environ.get(&lt;span class=&quot;hljs-string&quot;&gt;&apos;SELENIUM_LOCATION&apos;&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&apos;NOT_HERE&apos;&lt;/span&gt;)\n    SELENIUM_URL = &lt;span class=&quot;hljs-string&quot;&gt;f&apos;http://&lt;span class=&quot;hljs-subst&quot;&gt;{SELENIUM_LOCATION}&lt;/span&gt;:4444/wd/hub&apos;&lt;/span&gt;\n    chrome_options = webdriver.ChromeOptions()\n\n    &lt;span class=&quot;hljs-comment&quot;&gt;# chrome_options.add_experimental_option(&quot;mobileEmulation&quot;, mobile_emulation)&lt;/span&gt;\n    self.driver = webdriver.Remote(command_executor=SELENIUM_URL,\n                                   desired_capabilities=chrome_options.to_capabilities())\n\n\n&lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;process_request&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;self, request, spider&lt;/span&gt;):\n\n    self.driver.get(request.url)\n\n    &lt;span class=&quot;hljs-comment&quot;&gt;# sleep a bit so the page has time to load&lt;/span&gt;\n    &lt;span class=&quot;hljs-comment&quot;&gt;# or monitor items on page to continue as soon as page ready&lt;/span&gt;\n    sleep(&lt;span class=&quot;hljs-number&quot;&gt;4&lt;/span&gt;)\n\n    &lt;span class=&quot;hljs-comment&quot;&gt;# if you need to manipulate the page content like clicking and scrolling, you do it here&lt;/span&gt;\n    &lt;span class=&quot;hljs-comment&quot;&gt;# self.driver.find_element_by_css_selector(&apos;.my-class&apos;).click()&lt;/span&gt;\n\n    &lt;span class=&quot;hljs-comment&quot;&gt;# you only need the now properly and completely rendered html from your page to get results&lt;/span&gt;\n    body = deepcopy(self.driver.page_source)\n\n    &lt;span class=&quot;hljs-comment&quot;&gt;# copy the current url in case of redirects&lt;/span&gt;\n    url = deepcopy(self.driver.current_url)\n\n    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; HtmlResponse(url, body=body, encoding=&lt;span class=&quot;hljs-string&quot;&gt;&apos;utf-8&apos;&lt;/span&gt;, request=request)\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Dont forget to enable this middlware by uncommenting the next lines in the settings.py file:&lt;/p&gt;\n\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-makefile&quot;&gt;DOWNLOADER_MIDDLEWARES = {\n&lt;span class=&quot;hljs-section&quot;&gt;&apos;sample_project.middlewares.SampleProjectDownloaderMiddleware&apos;: 543,}&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Next for dockerization. Create your &lt;code&gt;Dockerfile&lt;/code&gt; from a lightweight image (I&apos;m using python Alpine here), copy your project directory to it, install requirements:&lt;/p&gt;\n\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-bash&quot;&gt;&lt;span class=&quot;hljs-comment&quot;&gt;# Use an official Python runtime as a parent image&lt;/span&gt;\nFROM python:3.6-alpine\n\n&lt;span class=&quot;hljs-comment&quot;&gt;# install some packages necessary to scrapy and then curl because it&apos;s  handy for debugging&lt;/span&gt;\nRUN apk --update add linux-headers libffi-dev openssl-dev build-base libxslt-dev libxml2-dev curl python-dev\n\nWORKDIR /my_scraper\n\nADD requirements.txt /my_scraper/\n\nRUN pip install -r requirements.txt\n\nADD . /scrapers\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;And finally bring it all together in &lt;code&gt;docker-compose.yaml&lt;/code&gt;:&lt;/p&gt;\n\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-yaml&quot;&gt;&lt;span class=&quot;hljs-attr&quot;&gt;version:&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&apos;2&apos;&lt;/span&gt;\n&lt;span class=&quot;hljs-attr&quot;&gt;services:&lt;/span&gt;\n  &lt;span class=&quot;hljs-attr&quot;&gt;selenium:&lt;/span&gt;\n    &lt;span class=&quot;hljs-attr&quot;&gt;image:&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;selenium/standalone-chrome&lt;/span&gt;\n    &lt;span class=&quot;hljs-attr&quot;&gt;ports:&lt;/span&gt;\n      &lt;span class=&quot;hljs-bullet&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;4444:4444&quot;&lt;/span&gt;\n    &lt;span class=&quot;hljs-attr&quot;&gt;shm_size:&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;1G&lt;/span&gt;\n\n  &lt;span class=&quot;hljs-attr&quot;&gt;my_scraper:&lt;/span&gt;\n    &lt;span class=&quot;hljs-attr&quot;&gt;build:&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;.&lt;/span&gt;\n    &lt;span class=&quot;hljs-attr&quot;&gt;depends_on:&lt;/span&gt;\n      &lt;span class=&quot;hljs-bullet&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;selenium&quot;&lt;/span&gt;\n    &lt;span class=&quot;hljs-attr&quot;&gt;environment:&lt;/span&gt;\n      &lt;span class=&quot;hljs-bullet&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;SELENIUM_LOCATION=samplecrawler_selenium_1&lt;/span&gt;\n    &lt;span class=&quot;hljs-attr&quot;&gt;volumes:&lt;/span&gt;\n      &lt;span class=&quot;hljs-bullet&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;.:/my_scraper&lt;/span&gt;\n    &lt;span class=&quot;hljs-comment&quot;&gt;# use this command to keep the container running&lt;/span&gt;\n    &lt;span class=&quot;hljs-attr&quot;&gt;command:&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;tail&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;-f&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;/dev/null&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Run &lt;code&gt;docker-compose up -d&lt;/code&gt;. If you&apos;re doing this the first time it will take a while for it to fetch the latest selenium/standalone-chrome and the build your scraper image as well. &lt;/p&gt;\n\n&lt;p&gt;Once it&apos;s done, you can check that your containers are running with &lt;code&gt;docker ps&lt;/code&gt; and also check that the name of the selenium container matches that of the environment variable that we passed to our scraper container (here, it was &lt;code&gt;SELENIUM_LOCATION=samplecrawler_selenium_1&lt;/code&gt;). &lt;/p&gt;\n\n&lt;p&gt;Enter your scraper container with &lt;code&gt;docker exec -ti YOUR_CONTAINER_NAME sh&lt;/code&gt; , the command for me was &lt;code&gt;docker exec -ti samplecrawler_my_scraper_1 sh&lt;/code&gt;, cd into the right directory and run your scraper with &lt;code&gt;scrapy crawl my_spider&lt;/code&gt;.&lt;/p&gt;\n\n&lt;p&gt;The entire thing is on my github page and you can get it from &lt;a href=&quot;https://github.com/tarikki/sample_crawler&quot; rel=&quot;noreferrer&quot;&gt;here&lt;/a&gt;&lt;/p&gt;\n    ","\n&lt;p&gt;A mix of BeautifulSoup and Selenium works very well for me.&lt;/p&gt;\n\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-coffeescript&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;from&lt;/span&gt; selenium &lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; webdriver\n&lt;span class=&quot;hljs-keyword&quot;&gt;from&lt;/span&gt; selenium.webdriver.common.&lt;span class=&quot;hljs-keyword&quot;&gt;by&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; By\n&lt;span class=&quot;hljs-keyword&quot;&gt;from&lt;/span&gt; selenium.webdriver.support.ui &lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; WebDriverWait\n&lt;span class=&quot;hljs-keyword&quot;&gt;from&lt;/span&gt; selenium.webdriver.support &lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; expected_conditions &lt;span class=&quot;hljs-keyword&quot;&gt;as&lt;/span&gt; EC\n&lt;span class=&quot;hljs-keyword&quot;&gt;from&lt;/span&gt; bs4 &lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; BeautifulSoup &lt;span class=&quot;hljs-keyword&quot;&gt;as&lt;/span&gt; bs\n\ndriver = webdriver.Firefox()\ndriver.get(&lt;span class=&quot;hljs-string&quot;&gt;&quot;http://somedomain/url_that_delays_loading&quot;&lt;/span&gt;)\n    try:\n        element = WebDriverWait(driver, &lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;).&lt;span class=&quot;hljs-keyword&quot;&gt;until&lt;/span&gt;(\n        EC.presence_of_element_located((By.ID, &lt;span class=&quot;hljs-string&quot;&gt;&quot;myDynamicElement&quot;&lt;/span&gt;))) &lt;span class=&quot;hljs-comment&quot;&gt;#waits 10 seconds until element is located. Can have other wait conditions  such as visibility_of_element_located or text_to_be_present_in_element&lt;/span&gt;\n\n        html = driver.page_source\n        soup = bs(html, &lt;span class=&quot;hljs-string&quot;&gt;&quot;lxml&quot;&lt;/span&gt;)\n        dynamic_text = soup.find_all(&lt;span class=&quot;hljs-string&quot;&gt;&quot;p&quot;&lt;/span&gt;, {&lt;span class=&quot;hljs-string&quot;&gt;&quot;class&quot;&lt;/span&gt;:&lt;span class=&quot;hljs-string&quot;&gt;&quot;class_name&quot;&lt;/span&gt;}) &lt;span class=&quot;hljs-comment&quot;&gt;#or other attributes, optional&lt;/span&gt;\n    else:\n        &lt;span class=&quot;hljs-built_in&quot;&gt;print&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;Couldnt locate element&quot;&lt;/span&gt;)\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;P.S. You can find more wait conditions &lt;a href=&quot;http://selenium-python.readthedocs.io/waits.html&quot; rel=&quot;noreferrer&quot;&gt;here&lt;/a&gt;&lt;/p&gt;\n    ","\n&lt;p&gt;&lt;strong&gt;Using PyQt5&lt;/strong&gt;&lt;/p&gt;\n\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;from&lt;/span&gt; PyQt5.QtWidgets &lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; QApplication\n&lt;span class=&quot;hljs-keyword&quot;&gt;from&lt;/span&gt; PyQt5.QtCore &lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; QUrl\n&lt;span class=&quot;hljs-keyword&quot;&gt;from&lt;/span&gt; PyQt5.QtWebEngineWidgets &lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; QWebEnginePage\n&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; sys\n&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; bs4 &lt;span class=&quot;hljs-keyword&quot;&gt;as&lt;/span&gt; bs\n&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; urllib.request\n\n\n&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;Client&lt;/span&gt;(&lt;span class=&quot;hljs-title class_ inherited__&quot;&gt;QWebEnginePage&lt;/span&gt;):\n    &lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;__init__&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;self,url&lt;/span&gt;):\n        &lt;span class=&quot;hljs-keyword&quot;&gt;global&lt;/span&gt; app\n        self.app = QApplication(sys.argv)\n        QWebEnginePage.__init__(self)\n        self.html = &lt;span class=&quot;hljs-string&quot;&gt;&quot;&quot;&lt;/span&gt;\n        self.loadFinished.connect(self.on_load_finished)\n        self.load(QUrl(url))\n        self.app.exec_()\n\n    &lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;on_load_finished&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;self&lt;/span&gt;):\n        self.html = self.toHtml(self.&lt;span class=&quot;hljs-type&quot;&gt;Callable&lt;/span&gt;)\n        &lt;span class=&quot;hljs-built_in&quot;&gt;print&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;Load Finished&quot;&lt;/span&gt;)\n\n    &lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;Callable&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;self,data&lt;/span&gt;):\n        self.html = data\n        self.app.quit()\n\n&lt;span class=&quot;hljs-comment&quot;&gt;# url = &quot;&quot;&lt;/span&gt;\n&lt;span class=&quot;hljs-comment&quot;&gt;# client_response = Client(url)&lt;/span&gt;\n&lt;span class=&quot;hljs-comment&quot;&gt;# print(client_response.html)&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n    ","\n&lt;p&gt;You&apos;ll want to use urllib, requests, beautifulSoup and selenium web driver in your script for different parts of the page, (to name a few).&lt;br&gt;\nSometimes you&apos;ll get what you need with just one of these modules.&lt;br&gt;\nSometimes you&apos;ll need two, three, or all of these modules.&lt;br&gt;\nSometimes you&apos;ll need to switch off the js on your browser.&lt;br&gt;\nSometimes you&apos;ll need header info in your script.&lt;br&gt;\nNo websites can be scraped the same way and no website can be scraped in the same way forever without having to modify your crawler, usually after a few months. But they can all be scraped! Where there&apos;s a will there&apos;s a way for sure.&lt;br&gt;\nIf you need scraped data continuously into the future just scrape everything you need and store it in .dat files with pickle.&lt;br&gt;\nJust keep searching how to try what with these modules and copying and pasting your errors into the Google.&lt;/p&gt;\n    ","\n&lt;h2&gt;Pyppeteer&lt;/h2&gt;\n&lt;p&gt;You might consider &lt;a href=&quot;https://github.com/pyppeteer/pyppeteer&quot; rel=&quot;nofollow noreferrer&quot;&gt;Pyppeteer&lt;/a&gt;, a Python port of the Chrome/Chromium driver front-end &lt;a href=&quot;https://github.com/puppeteer/puppeteer/&quot; rel=&quot;nofollow noreferrer&quot;&gt;Puppeteer&lt;/a&gt;.&lt;/p&gt;\n&lt;p&gt;Here&apos;s a simple example to show how you can use Pyppeteer to access data that was injected into the page dynamically:&lt;/p&gt;\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; asyncio\n&lt;span class=&quot;hljs-keyword&quot;&gt;from&lt;/span&gt; pyppeteer &lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; launch\n\n&lt;span class=&quot;hljs-keyword&quot;&gt;async&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;main&lt;/span&gt;():\n    browser = &lt;span class=&quot;hljs-keyword&quot;&gt;await&lt;/span&gt; launch({&lt;span class=&quot;hljs-string&quot;&gt;&quot;headless&quot;&lt;/span&gt;: &lt;span class=&quot;hljs-literal&quot;&gt;True&lt;/span&gt;})\n    [page] = &lt;span class=&quot;hljs-keyword&quot;&gt;await&lt;/span&gt; browser.pages()\n\n    &lt;span class=&quot;hljs-comment&quot;&gt;# normally, you go to a live site...&lt;/span&gt;\n    &lt;span class=&quot;hljs-comment&quot;&gt;#await page.goto(&quot;http://www.example.com&quot;)&lt;/span&gt;\n    &lt;span class=&quot;hljs-comment&quot;&gt;# but for this example, just set the HTML directly:&lt;/span&gt;\n    &lt;span class=&quot;hljs-keyword&quot;&gt;await&lt;/span&gt; page.setContent(&lt;span class=&quot;hljs-string&quot;&gt;&quot;&quot;&quot;\n    &amp;lt;body&amp;gt;\n    &amp;lt;script&amp;gt;\n    // inject content dynamically with JS, not part of the static HTML!\n    document.body.innerHTML = `&amp;lt;p&amp;gt;hello world&amp;lt;/p&amp;gt;`; \n    &amp;lt;/script&amp;gt;\n    &amp;lt;/body&amp;gt;\n    &quot;&quot;&quot;&lt;/span&gt;)\n    &lt;span class=&quot;hljs-built_in&quot;&gt;print&lt;/span&gt;(&lt;span class=&quot;hljs-keyword&quot;&gt;await&lt;/span&gt; page.content()) &lt;span class=&quot;hljs-comment&quot;&gt;# shows that the `&amp;lt;p&amp;gt;` was inserted&lt;/span&gt;\n\n    &lt;span class=&quot;hljs-comment&quot;&gt;# evaluate a JS expression in browser context and scrape the data&lt;/span&gt;\n    expr = &lt;span class=&quot;hljs-string&quot;&gt;&quot;document.querySelector(&apos;p&apos;).textContent&quot;&lt;/span&gt;\n    &lt;span class=&quot;hljs-built_in&quot;&gt;print&lt;/span&gt;(&lt;span class=&quot;hljs-keyword&quot;&gt;await&lt;/span&gt; page.evaluate(expr, force_expr=&lt;span class=&quot;hljs-literal&quot;&gt;True&lt;/span&gt;)) &lt;span class=&quot;hljs-comment&quot;&gt;# =&amp;gt; hello world&lt;/span&gt;\n\n    &lt;span class=&quot;hljs-keyword&quot;&gt;await&lt;/span&gt; browser.close()\n\nasyncio.get_event_loop().run_until_complete(main())\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;See &lt;a href=&quot;https://pyppeteer.github.io/pyppeteer/reference.html&quot; rel=&quot;nofollow noreferrer&quot;&gt;Pyppeteer&apos;s reference docs&lt;/a&gt;.&lt;/p&gt;\n    ","\n&lt;h2&gt;Try accessing the API directly&lt;/h2&gt;\n&lt;p&gt;A common scenario you&apos;ll see in scraping is that the data is being requested asynchronously from an API endpoint by the webpage. A minimal example of this would be the following site:&lt;/p&gt;\n&lt;p&gt;&lt;/p&gt;&lt;div class=&quot;snippet&quot; data-lang=&quot;js&quot; data-hide=&quot;false&quot; data-console=&quot;true&quot; data-babel=&quot;false&quot;&gt;\n&lt;div class=&quot;snippet-code&quot;&gt;\n&lt;pre class=&quot;snippet-code-html lang-html s-code-block&quot;&gt;&lt;code class=&quot;hljs language-xml&quot;&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;body&lt;/span&gt;&amp;gt;&lt;/span&gt;\n&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;script&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;language-javascript&quot;&gt;\n&lt;span class=&quot;hljs-title function_&quot;&gt;fetch&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;https://jsonplaceholder.typicode.com/posts/1&quot;&lt;/span&gt;)\n  .&lt;span class=&quot;hljs-title function_&quot;&gt;then&lt;/span&gt;(&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-params&quot;&gt;res&lt;/span&gt; =&amp;gt;&lt;/span&gt; {\n    &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (!res.&lt;span class=&quot;hljs-property&quot;&gt;ok&lt;/span&gt;) &lt;span class=&quot;hljs-keyword&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;Error&lt;/span&gt;(res.&lt;span class=&quot;hljs-property&quot;&gt;status&lt;/span&gt;);\n    \n    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; res.&lt;span class=&quot;hljs-title function_&quot;&gt;json&lt;/span&gt;();\n  })\n  .&lt;span class=&quot;hljs-title function_&quot;&gt;then&lt;/span&gt;(&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-params&quot;&gt;data&lt;/span&gt; =&amp;gt;&lt;/span&gt; {\n    &lt;span class=&quot;hljs-comment&quot;&gt;// inject data dynamically via JS after page load&lt;/span&gt;\n    &lt;span class=&quot;hljs-variable language_&quot;&gt;document&lt;/span&gt;.&lt;span class=&quot;hljs-property&quot;&gt;body&lt;/span&gt;.&lt;span class=&quot;hljs-property&quot;&gt;innerText&lt;/span&gt; = data.&lt;span class=&quot;hljs-property&quot;&gt;title&lt;/span&gt;;\n  })\n  .&lt;span class=&quot;hljs-title function_&quot;&gt;catch&lt;/span&gt;(&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-params&quot;&gt;err&lt;/span&gt; =&amp;gt;&lt;/span&gt; &lt;span class=&quot;hljs-variable language_&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;hljs-title function_&quot;&gt;error&lt;/span&gt;(err))\n;\n&lt;/span&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;script&lt;/span&gt;&amp;gt;&lt;/span&gt;\n&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;body&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;\n&lt;div class=&quot;snippet-result&quot;&gt;&lt;div class=&quot;snippet-ctas&quot;&gt;&lt;button type=&quot;button&quot; class=&quot;s-btn s-btn__primary&quot;&gt;&lt;span class=&quot;icon-play-white _hover&quot;&gt;&lt;/span&gt;&lt;span&gt; Run code snippet&lt;/span&gt;&lt;/button&gt;&lt;input class=&quot;copySnippet s-btn s-btn__filled&quot; type=&quot;button&quot; value=&quot;Copy snippet to answer&quot; style=&quot;display: none;&quot;&gt;&lt;button type=&quot;button&quot; class=&quot;s-btn hideResults&quot; style=&quot;display: none;&quot;&gt;Hide results&lt;/button&gt;&lt;div class=&quot;popout-code&quot;&gt;&lt;a class=&quot;snippet-expand-link&quot;&gt;Expand snippet&lt;/a&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class=&quot;snippet-result-code&quot; style=&quot;display: none;&quot;&gt;&lt;iframe name=&quot;sif1&quot; sandbox=&quot;allow-forms allow-modals allow-scripts&quot; class=&quot;snippet-box-edit snippet-box-result&quot; frameborder=&quot;0&quot;&gt;&lt;/iframe&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;\n&lt;/div&gt;\n&lt;p&gt;&lt;/p&gt;\n&lt;p&gt;In many cases, the API will be protected by CORS or an access token or prohibitively rate limited, but in other cases it&apos;s publicly-accessible and you can bypass the website entirely. For CORS issues, you might try &lt;a href=&quot;https://stackoverflow.com/questions/29670703/how-to-use-cors-anywhere-to-reverse-proxy-and-add-cors-headers&quot;&gt;cors-anywhere&lt;/a&gt;.&lt;/p&gt;\n&lt;p&gt;The general procedure is to use your browser&apos;s developer tools&apos; network tab to search the requests made by the page for keywords/substrings of the data you want to scrape. Often, you&apos;ll see an unprotected API request endpoint with a JSON payload that you can access directly with &lt;code&gt;urllib&lt;/code&gt; or &lt;code&gt;requests&lt;/code&gt; modules. That&apos;s the case with the above runnable snippet which you can use to practice. After clicking &quot;run snippet&quot;, here&apos;s how I found the endpoint in my network tab:&lt;/p&gt;\n&lt;p&gt;&lt;a href=&quot;https://i.stack.imgur.com/EOxkc.png&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;img src=&quot;https://i.stack.imgur.com/EOxkc.png&quot; alt=&quot;example network tab showing remote URL endpoint found with a search&quot;&gt;&lt;/a&gt;&lt;/p&gt;\n&lt;p&gt;This example is contrived; the endpoint URL will likely be non-obvious from looking at the static markup because it could be dynamically assembled, minified and buried under dozens of other requests and endpoints. The network request will also show any relevant request payload details like access token you may need.&lt;/p&gt;\n&lt;p&gt;After obtaining the endpoint URL and relevant details, build a request in Python using a standard HTTP library and request the data:&lt;/p&gt;\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; requests\n&lt;span class=&quot;hljs-meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;res = requests.get(&lt;span class=&quot;hljs-string&quot;&gt;&quot;https://jsonplaceholder.typicode.com/posts/1&quot;&lt;/span&gt;)\n&lt;span class=&quot;hljs-meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;data = res.json()\n&lt;span class=&quot;hljs-meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;data[&lt;span class=&quot;hljs-string&quot;&gt;&quot;title&quot;&lt;/span&gt;]\n&lt;span class=&quot;hljs-string&quot;&gt;&apos;sunt aut facere repellat provident occaecati excepturi optio reprehenderit&apos;&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;When you can get away with it, this tends to be much easier, faster and more reliable than scraping the page with Selenium, Pyppeteer, Scrapy or whatever the popular scraping libraries are at the time you&apos;re reading this post.&lt;/p&gt;\n&lt;p&gt;If you&apos;re unlucky and the data hasn&apos;t arrived via an API request that returns the data in a nice format, it could be part of the original browser&apos;s payload in a &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; tag, either as a JSON string or (more likely) a JS object. For example:&lt;/p&gt;\n&lt;p&gt;&lt;/p&gt;&lt;div class=&quot;snippet&quot; data-lang=&quot;js&quot; data-hide=&quot;false&quot; data-console=&quot;true&quot; data-babel=&quot;false&quot;&gt;\n&lt;div class=&quot;snippet-code&quot;&gt;\n&lt;pre class=&quot;snippet-code-html lang-html s-code-block&quot;&gt;&lt;code class=&quot;hljs language-xml&quot;&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;body&lt;/span&gt;&amp;gt;&lt;/span&gt;\n&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;script&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;language-javascript&quot;&gt;\n  &lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; someHardcodedData = {\n    &lt;span class=&quot;hljs-attr&quot;&gt;userId&lt;/span&gt;: &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;,\n    &lt;span class=&quot;hljs-attr&quot;&gt;id&lt;/span&gt;: &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;,\n    &lt;span class=&quot;hljs-attr&quot;&gt;title&lt;/span&gt;: &lt;span class=&quot;hljs-string&quot;&gt;&apos;sunt aut facere repellat provident occaecati excepturi optio reprehenderit&apos;&lt;/span&gt;, \n    &lt;span class=&quot;hljs-attr&quot;&gt;body&lt;/span&gt;: &lt;span class=&quot;hljs-string&quot;&gt;&apos;quia et suscipit\\nsuscipit recusandae con sequuntur expedita et cum\\nreprehenderit molestiae ut ut quas totam\\nnostrum rerum est autem sunt rem eveniet architecto&apos;&lt;/span&gt;\n  };\n  &lt;span class=&quot;hljs-variable language_&quot;&gt;document&lt;/span&gt;.&lt;span class=&quot;hljs-property&quot;&gt;body&lt;/span&gt;.&lt;span class=&quot;hljs-property&quot;&gt;textContent&lt;/span&gt; = someHardcodedData.&lt;span class=&quot;hljs-property&quot;&gt;title&lt;/span&gt;;\n&lt;/span&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;script&lt;/span&gt;&amp;gt;&lt;/span&gt;\n&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;body&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;\n&lt;div class=&quot;snippet-result&quot;&gt;&lt;div class=&quot;snippet-ctas&quot;&gt;&lt;button type=&quot;button&quot; class=&quot;s-btn s-btn__primary&quot;&gt;&lt;span class=&quot;icon-play-white _hover&quot;&gt;&lt;/span&gt;&lt;span&gt; Run code snippet&lt;/span&gt;&lt;/button&gt;&lt;input class=&quot;copySnippet s-btn s-btn__filled&quot; type=&quot;button&quot; value=&quot;Copy snippet to answer&quot; style=&quot;display: none;&quot;&gt;&lt;button type=&quot;button&quot; class=&quot;s-btn hideResults&quot; style=&quot;display: none;&quot;&gt;Hide results&lt;/button&gt;&lt;div class=&quot;popout-code&quot;&gt;&lt;a class=&quot;snippet-expand-link&quot;&gt;Expand snippet&lt;/a&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class=&quot;snippet-result-code&quot; style=&quot;display: none;&quot;&gt;&lt;iframe name=&quot;sif2&quot; sandbox=&quot;allow-forms allow-modals allow-scripts&quot; class=&quot;snippet-box-edit snippet-box-result&quot; frameborder=&quot;0&quot;&gt;&lt;/iframe&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;\n&lt;/div&gt;\n&lt;p&gt;&lt;/p&gt;\n&lt;p&gt;There&apos;s no one-size-fits-all way to obtain this data. The basic technique is to use BeautifulSoup to access the &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; tag text, then apply a regex or a parse to extract the object structure, JSON string, or whatever format the data might be in. Here&apos;s a proof-of-concept on the sample structure shown above:&lt;/p&gt;\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; json\n&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; re\n&lt;span class=&quot;hljs-keyword&quot;&gt;from&lt;/span&gt; bs4 &lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; BeautifulSoup\n\n&lt;span class=&quot;hljs-comment&quot;&gt;# pretend we&apos;ve already used requests to retrieve the data, &lt;/span&gt;\n&lt;span class=&quot;hljs-comment&quot;&gt;# so we hardcode it for the purposes of this example&lt;/span&gt;\ntext = &lt;span class=&quot;hljs-string&quot;&gt;&quot;&quot;&quot;\n&amp;lt;body&amp;gt;\n&amp;lt;script&amp;gt;\n  var someHardcodedData = {\n    userId: 1,\n    id: 1,\n    title: &apos;sunt aut facere repellat provident occaecati excepturi optio reprehenderit&apos;, \n    body: &apos;quia et suscipit\\nsuscipit recusandae con sequuntur expedita et cum\\nreprehenderit molestiae ut ut quas totam\\nnostrum rerum est autem sunt rem eveniet architecto&apos;\n  };\n  document.body.textContent = someHardcodedData.title;\n&amp;lt;/script&amp;gt;\n&amp;lt;/body&amp;gt;\n&quot;&quot;&quot;&lt;/span&gt;\nsoup = BeautifulSoup(text, &lt;span class=&quot;hljs-string&quot;&gt;&quot;lxml&quot;&lt;/span&gt;)\nscript_text = &lt;span class=&quot;hljs-built_in&quot;&gt;str&lt;/span&gt;(soup.select_one(&lt;span class=&quot;hljs-string&quot;&gt;&quot;script&quot;&lt;/span&gt;))\npattern = &lt;span class=&quot;hljs-string&quot;&gt;r&quot;title: &apos;(.*?)&apos;&quot;&lt;/span&gt;\n&lt;span class=&quot;hljs-built_in&quot;&gt;print&lt;/span&gt;(re.search(pattern, script_text, re.S).group(&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;))\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;Check out these resources for parsing JS objects that aren&apos;t quite valid JSON:&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=&quot;https://stackoverflow.com/questions/24027589/how-to-convert-raw-javascript-object-to-python-dictionary&quot;&gt;How to convert raw javascript object to python dictionary?&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=&quot;https://stackoverflow.com/questions/50947760/how-to-fix-json-key-values-without-double-quotes&quot;&gt;How to Fix JSON Key Values without double-quotes?&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;Here are some additional case studies/proofs-of-concept where scraping was bypassed using an API:&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=&quot;https://stackoverflow.com/questions/69801378/how-can-i-scrape-yelp-reviews-and-star-ratings-into-csv-using-python-beautifulso?noredirect=1#comment123391238_69801378&quot;&gt;How can I scrape yelp reviews and star ratings into CSV using Python beautifulsoup&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=&quot;https://stackoverflow.com/a/59378253/6243352&quot;&gt;Beautiful Soup returns None on existing element&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=&quot;https://stackoverflow.com/a/65905956/6243352&quot;&gt;Extract data from  BeautifulSoup Python&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=&quot;https://stackoverflow.com/a/64419449/6243352&quot;&gt;Scraping Bandcamp fan collections via POST&lt;/a&gt; (uses a hybrid approach where an initial request was made to the website to extract a token from the markup using BeautifulSoup which was then used in a second request to a JSON endpoint)&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;If all else fails, try one of the many dynamic scraping libraries listed in this thread.&lt;/p&gt;\n    ","\n&lt;p&gt;As mentioned, Selenium is a good choice for rendering the results of the JavaScript:&lt;/p&gt;\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;from&lt;/span&gt; selenium.webdriver &lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; Firefox\n&lt;span class=&quot;hljs-keyword&quot;&gt;from&lt;/span&gt; selenium.webdriver.firefox.options &lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; Options\n\noptions = Options()\noptions.headless = &lt;span class=&quot;hljs-literal&quot;&gt;True&lt;/span&gt;\nbrowser = Firefox(executable_path=&lt;span class=&quot;hljs-string&quot;&gt;&quot;/usr/local/bin/geckodriver&quot;&lt;/span&gt;, options=options)\n\nurl = &lt;span class=&quot;hljs-string&quot;&gt;&quot;https://www.example.com&quot;&lt;/span&gt;\nbrowser.get(url)\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;And &lt;a href=&quot;https://github.com/maxhumber/gazpacho&quot; rel=&quot;nofollow noreferrer&quot;&gt;gazpacho&lt;/a&gt; is a really easy library to parse over the rendered html:&lt;/p&gt;\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;from&lt;/span&gt; gazpacho &lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; Soup\n\nsoup = Soup(browser.page_source)\nsoup.find(&lt;span class=&quot;hljs-string&quot;&gt;&quot;a&quot;&lt;/span&gt;).attrs[&lt;span class=&quot;hljs-string&quot;&gt;&apos;href&apos;&lt;/span&gt;]\n&lt;/code&gt;&lt;/pre&gt;\n    ","\n&lt;p&gt;I recently used requests_html library to solve this problem.&lt;/p&gt;\n&lt;p&gt;Their &lt;a href=&quot;https://requests.readthedocs.io/projects/requests-html/en/latest/&quot; rel=&quot;nofollow noreferrer&quot;&gt;expanded documentation&lt;/a&gt; at readthedocs.io is pretty good (skip the annotated version at pypi.org). If your use case is basic, you are likely to have some success.&lt;/p&gt;\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-coffeescript&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;from&lt;/span&gt; requests_html &lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; HTMLSession\nsession = HTMLSession()\nresponse = session.request(method=&lt;span class=&quot;hljs-string&quot;&gt;&quot;get&quot;&lt;/span&gt;,url=&lt;span class=&quot;hljs-string&quot;&gt;&quot;www.google.com/&quot;&lt;/span&gt;)\nresponse.html.render()\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;If you are having trouble rendering the data you need with response.html.render(), you can pass some javascript to the render function to render the particular js object you need. This is copied from their docs, but it might be just what you need:&lt;/p&gt;\n&lt;blockquote&gt;\n&lt;p&gt;If script is specified, it will execute the provided JavaScript at\nruntime. Example:&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-ini&quot;&gt;&lt;span class=&quot;hljs-attr&quot;&gt;script&lt;/span&gt; = &lt;span class=&quot;hljs-string&quot;&gt;&quot;&quot;&quot;\n    () =&amp;gt; {\n        return {\n            width: document.documentElement.clientWidth,\n            height: document.documentElement.clientHeight,\n            deviceScaleFactor: window.devicePixelRatio,\n        }\n    } \n&quot;&quot;&quot;&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;blockquote&gt;\n&lt;p&gt;Returns the return value of the executed script, if any is provided:&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-javascript&quot;&gt;&amp;gt;&amp;gt;&amp;gt; response.&lt;span class=&quot;hljs-property&quot;&gt;html&lt;/span&gt;.&lt;span class=&quot;hljs-title function_&quot;&gt;render&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;script=script&lt;/span&gt;)\n{&lt;span class=&quot;hljs-string&quot;&gt;&apos;width&apos;&lt;/span&gt;: &lt;span class=&quot;hljs-number&quot;&gt;800&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&apos;height&apos;&lt;/span&gt;: &lt;span class=&quot;hljs-number&quot;&gt;600&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&apos;deviceScaleFactor&apos;&lt;/span&gt;: &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;In my case, the data I wanted were the arrays that populated a javascript plot but the data wasn&apos;t getting rendered as text anywhere in the html. Sometimes its not clear at all what the object names are of the data you want if the data is populated dynamically. If you can&apos;t track down the js objects directly from view source or inspect, you can type in &quot;window&quot; followed by ENTER in the debugger console in the browser (Chrome) to pull up a full list of objects rendered by the browser. If you make a few educated guesses about where the data is stored, you might have some luck finding it there. My graph data was under window.view.data in the console, so in the &quot;script&quot; variable passed to the .render() method quoted above, I used:&lt;/p&gt;\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-kotlin&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; {\n    &lt;span class=&quot;hljs-keyword&quot;&gt;data&lt;/span&gt;: window.view.&lt;span class=&quot;hljs-keyword&quot;&gt;data&lt;/span&gt;\n}\n&lt;/code&gt;&lt;/pre&gt;\n    ","\n&lt;h2&gt;Playwright-Python&lt;/h2&gt;\n&lt;p&gt;Yet another option is &lt;a href=&quot;https://github.com/microsoft/playwright-python&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;code&gt;playwright-python&lt;/code&gt;&lt;/a&gt;, a port of Microsoft&apos;s Playwright (itself a Puppeteer-influenced browser automation library) to Python.&lt;/p&gt;\n&lt;p&gt;Here&apos;s the minimal example of selecting an element and grabbing its text:&lt;/p&gt;\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-css&quot;&gt;&lt;span class=&quot;hljs-selector-tag&quot;&gt;from&lt;/span&gt; playwright&lt;span class=&quot;hljs-selector-class&quot;&gt;.sync_api&lt;/span&gt; import sync_playwright\n\nwith sync_playwright() as &lt;span class=&quot;hljs-selector-tag&quot;&gt;p&lt;/span&gt;:\n    browser = p.chromium.&lt;span class=&quot;hljs-built_in&quot;&gt;launch&lt;/span&gt;()\n    page = browser.&lt;span class=&quot;hljs-built_in&quot;&gt;new_page&lt;/span&gt;()\n    page.&lt;span class=&quot;hljs-built_in&quot;&gt;goto&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;http://whatsmyuseragent.org/&quot;&lt;/span&gt;)\n    ua = page.&lt;span class=&quot;hljs-built_in&quot;&gt;query_selector&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;.user-agent&quot;&lt;/span&gt;);\n    print(ua&lt;span class=&quot;hljs-selector-class&quot;&gt;.text_content&lt;/span&gt;())\n    browser&lt;span class=&quot;hljs-selector-class&quot;&gt;.close&lt;/span&gt;()\n&lt;/code&gt;&lt;/pre&gt;\n    ","\n&lt;p&gt;&lt;strong&gt;Easy and Quick Solution:&lt;/strong&gt;&lt;/p&gt;\n&lt;p&gt;I was dealing with same problem. I want to scrape some data which is build with JavaScript. If I scrape only text from this site with BeautifulSoup then I ended with  tags in text.\nI want to render this  tag and wills to grab information from this.\nAlso, I dont want to use heavy frameworks  like Scrapy and selenium.&lt;/p&gt;\n&lt;p&gt;So, I found that &lt;strong&gt;get&lt;/strong&gt; method of requests &lt;strong&gt;module&lt;/strong&gt; takes urls, and it actually renders the script tag.&lt;/p&gt;\n&lt;p&gt;Example:&lt;/p&gt;\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-makefile&quot;&gt;import requests\ncustom_User_agent = &lt;span class=&quot;hljs-string&quot;&gt;&quot;Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:47.0) Gecko/20100101 Firefox/47.0&quot;&lt;/span&gt;\nurl = &lt;span class=&quot;hljs-string&quot;&gt;&quot;https://www.abc.xyz/your/url&quot;&lt;/span&gt;\nresponse = requests.get(url, headers={&lt;span class=&quot;hljs-string&quot;&gt;&quot;User-Agent&quot;&lt;/span&gt;: custom_User_agent})\nhtml_text = response.text\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;This will renders load site and renders  tags.&lt;/p&gt;\n&lt;p&gt;Hope this will help as quick and easy solution to render site which is loaded with script tags.&lt;/p&gt;\n    "]},"randomTags":[{"name":"http-redirect","slug":"http-redirect"},{"name":"language-agnostic","slug":"language-agnostic"},{"name":"benchmarking","slug":"benchmarking"},{"name":"public","slug":"public"},{"name":"autowired","slug":"autowired"},{"name":"spring","slug":"spring"},{"name":"arrow-functions","slug":"arrow-functions"},{"name":"collision-detection","slug":"collision-detection"},{"name":"variadic-functions","slug":"variadic-functions"},{"name":"subquery","slug":"subquery"},{"name":"global-variables","slug":"global-variables"},{"name":"max","slug":"max"},{"name":"pointers","slug":"pointers"},{"name":"argument-unpacking","slug":"argument-unpacking"},{"name":"magic-methods","slug":"magic-methods"},{"name":"callback","slug":"callback"},{"name":"borrow-checker","slug":"borrow-checker"},{"name":"maps","slug":"maps"},{"name":"swing","slug":"swing"},{"name":"addeventlistener","slug":"addeventlistener"}]},"__N_SSG":true}