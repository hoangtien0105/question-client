{"pageProps":{"data":{"count":1,"rows":[{"id":118,"title":"What does it mean to \"program to an interface\"?","slug":"what-does-it-mean-to-\"program-to-an-interface\"-1657384671665","postType":"QUESTION","createdAt":"2022-07-09T16:37:51.000Z","updatedAt":"2022-07-09T16:37:51.000Z","tags":[{"id":434,"name":"oop","slug":"oop","createdAt":"2022-07-09T16:37:51.000Z","updatedAt":"2022-07-09T16:37:51.000Z","Questions_Tags":{"questionId":118,"tagId":434}}]}]},"slug":"oop","page":1,"answers":{"118":["\n&lt;p&gt;There are some wonderful answers on here to this questions that get into all sorts of great detail about interfaces and loosely coupling code, inversion of control and so on.  There are some fairly heady discussions, so I&apos;d like to take the opportunity to break things down a bit for understanding why an interface is useful.&lt;/p&gt;\n\n&lt;p&gt;When I first started getting exposed to interfaces, I too was confused about their relevance.  I didn&apos;t understand why you needed them.  If we&apos;re using a language like Java or C#, we already have inheritance and I viewed interfaces as a &lt;em&gt;weaker&lt;/em&gt; form of inheritance and thought, &quot;why bother?&quot;  In a sense I was right, you can think of interfaces as sort of a weak form of inheritance, but beyond that I finally understood their use as a language construct by thinking of them as a means of classifying common traits or behaviors that were exhibited by potentially many non-related classes of objects.&lt;/p&gt;\n\n&lt;p&gt;For example -- say you have a SIM game and have the following classes:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-java s-code-block&quot;&gt;&lt;code class=&quot;hljs language-java&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;HouseFly&lt;/span&gt; inherits Insect {\n    &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;FlyAroundYourHead&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt;{}\n    &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;LandOnThings&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt;{}\n}\n\n&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;Telemarketer&lt;/span&gt; inherits Person {\n    &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;CallDuringDinner&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt;{}\n    &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;ContinueTalkingWhenYouSayNo&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt;{}\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Clearly, these two objects have nothing in common in terms of direct inheritance.  But, you could say they are both annoying.  &lt;/p&gt;\n\n&lt;p&gt;Let&apos;s say our game needs to have some sort of random &lt;em&gt;thing&lt;/em&gt; that annoys the game player when they eat dinner.  This could be a &lt;code&gt;HouseFly&lt;/code&gt; or a &lt;code&gt;Telemarketer&lt;/code&gt; or both -- but how do you allow for both with a single function?  And how do you ask each different type of object to &quot;do their annoying thing&quot; in the same way?&lt;/p&gt;\n\n&lt;p&gt;The key to realize is that both a &lt;code&gt;Telemarketer&lt;/code&gt; and &lt;code&gt;HouseFly&lt;/code&gt; share a common loosely interpreted behavior even though they are nothing alike in terms of modeling them.  So, let&apos;s make an interface that both can implement:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-java s-code-block&quot;&gt;&lt;code class=&quot;hljs language-java&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;IPest&lt;/span&gt; {\n    &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;BeAnnoying&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt;;\n}\n\n&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;HouseFly&lt;/span&gt; inherits Insect &lt;span class=&quot;hljs-keyword&quot;&gt;implements&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;IPest&lt;/span&gt; {\n    &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;FlyAroundYourHead&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt;{}\n    &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;LandOnThings&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt;{}\n\n    &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;BeAnnoying&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt; {\n        FlyAroundYourHead();\n        LandOnThings();\n    }\n}\n\n&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;Telemarketer&lt;/span&gt; inherits Person &lt;span class=&quot;hljs-keyword&quot;&gt;implements&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;IPest&lt;/span&gt; {\n    &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;CallDuringDinner&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt;{}\n    &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;ContinueTalkingWhenYouSayNo&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt;{}\n\n    &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;BeAnnoying&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt; {\n        CallDuringDinner();\n        ContinueTalkingWhenYouSayNo();\n    }\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;We now have two classes that can each be annoying in their own way.  And they do not need to derive from the same base class and share common inherent characteristics -- they simply need to satisfy the contract of &lt;code&gt;IPest&lt;/code&gt; -- that contract is simple.  You just have to &lt;code&gt;BeAnnoying&lt;/code&gt;.  In this regard, we can model the following:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-java s-code-block&quot;&gt;&lt;code class=&quot;hljs language-java&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;DiningRoom&lt;/span&gt; {\n\n    DiningRoom(Person[] diningPeople, IPest[] pests) { ... }\n\n    &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;ServeDinner&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt; {\n        when diningPeople are eating,\n\n        foreach pest in pests\n        pest.BeAnnoying();\n    }\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Here we have a dining room that accepts a number of diners and a number of pests -- note the use of the interface.  This means that in our little world, a member of the &lt;code&gt;pests&lt;/code&gt; array could actually be a &lt;code&gt;Telemarketer&lt;/code&gt; object or a &lt;code&gt;HouseFly&lt;/code&gt; object.&lt;/p&gt;\n\n&lt;p&gt;The &lt;code&gt;ServeDinner&lt;/code&gt; method is called when dinner is served and our people in the dining room are supposed to eat.  In our little game, that&apos;s when our pests do their work -- each pest is instructed to be annoying by way of the &lt;code&gt;IPest&lt;/code&gt; interface.  In this way, we can easily have both &lt;code&gt;Telemarketers&lt;/code&gt; and &lt;code&gt;HouseFlys&lt;/code&gt; be annoying in each of their own ways -- we care only that we have something in the &lt;code&gt;DiningRoom&lt;/code&gt; object that is a pest, we don&apos;t really care what it is and they could have nothing in common with other.  &lt;/p&gt;\n\n&lt;p&gt;This very contrived pseudo-code example (that dragged on a lot longer than I anticipated) is simply meant to illustrate the kind of thing that finally turned the light on for me in terms of when we might use an interface.  I apologize in advance for the silliness of the example, but hope that it helps in your understanding.  And, to be sure, the other posted answers you&apos;ve received here really cover the gamut of the use of interfaces today in design patterns and development methodologies.  &lt;/p&gt;\n    ","\n&lt;p&gt;The specific example I used to give to students is that they should write&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;List myList = new ArrayList(); // programming to the List interface\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;instead of&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;ArrayList myList = new ArrayList(); // this is bad\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;These look exactly the same in a short program, but if you go on to use &lt;code&gt;myList&lt;/code&gt; 100 times in your program you can start to see a difference.  The first declaration ensures that you only call methods on &lt;code&gt;myList&lt;/code&gt; that are defined by the &lt;code&gt;List&lt;/code&gt; interface (so no &lt;code&gt;ArrayList&lt;/code&gt; specific methods).  If you&apos;ve programmed to the interface this way, later on you can decide that you really need&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;List myList = new TreeList();\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;and you only have to change your code in that one spot.  You already know that the rest of your code doesn&apos;t do anything that will be broken by changing the &lt;em&gt;implementation&lt;/em&gt; because you programmed to the &lt;em&gt;interface&lt;/em&gt;.&lt;/p&gt;\n\n&lt;p&gt;The benefits are even more obvious (I think) when you&apos;re talking about method parameters and return values.  Take this for example:&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;public ArrayList doSomething(HashMap map);\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;That method declaration ties you to two concrete implementations (&lt;code&gt;ArrayList&lt;/code&gt; and &lt;code&gt;HashMap&lt;/code&gt;). As soon as that method is called from other code, any changes to those types probably mean you&apos;re going to have to change the calling code as well. It would be better to program to the interfaces.&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;public List doSomething(Map map);\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Now it doesn&apos;t matter what kind of &lt;code&gt;List&lt;/code&gt; you return, or what kind of &lt;code&gt;Map&lt;/code&gt; is passed in as a parameter. Changes that you make inside the &lt;code&gt;doSomething&lt;/code&gt; method won&apos;t force you to change the calling code.&lt;/p&gt;\n    ","\n&lt;p&gt;Programming to an interface is saying, &quot;I need this functionality and I don&apos;t care where it comes from.&quot;&lt;/p&gt;\n\n&lt;p&gt;Consider (in Java), the &lt;code&gt;List&lt;/code&gt; interface versus the &lt;code&gt;ArrayList&lt;/code&gt; and &lt;code&gt;LinkedList&lt;/code&gt; concrete classes. If all I care about is that I have a data structure containing multiple data items that I should access via iteration, I&apos;d pick a &lt;code&gt;List&lt;/code&gt; (and that&apos;s 99% of the time). If I know that I need constant-time insert/delete from either end of the list, I might pick the &lt;code&gt;LinkedList&lt;/code&gt; concrete implementation (or more likely, use the &lt;a href=&quot;https://docs.oracle.com/javase/tutorial/collections/interfaces/queue.html&quot; rel=&quot;noreferrer&quot;&gt;Queue&lt;/a&gt; interface). If I know I need random access by index, I&apos;d pick the &lt;code&gt;ArrayList&lt;/code&gt; concrete class.&lt;/p&gt;\n    ","\n&lt;p&gt;Programming to an interface has absolutely nothing to do with abstract interfaces like we see in Java or .NET. It isn&apos;t even an OOP concept.&lt;/p&gt;\n\n&lt;p&gt;What it means is don&apos;t go messing around with the internals of an object or data structure. Use the Abstract Program Interface, or API, to interact with your data. In Java or C# that means using public properties and methods instead of raw field access. For C that means using functions instead of raw pointers.&lt;/p&gt;\n\n&lt;p&gt;&lt;strong&gt;EDIT:&lt;/strong&gt; And with databases it means using views and stored procedures instead of direct table access.&lt;/p&gt;\n    ","\n&lt;p&gt;Using interfaces is a key factor in making your code easily testable in addition to removing unnecessary couplings between your classes.  By creating an interface that defines the operations on your class, you allow classes that want to use that functionality the ability to use it without depending on your implementing class directly.  If later on you decide to change and use a different implementation, you need only change the part of the code where the implementation is instantiated.  The rest of the code need not change because it depends on the interface, not the implementing class.&lt;/p&gt;\n\n&lt;p&gt;This is very useful in creating unit tests.  In the class under test you have it depend on the interface and inject an instance of the interface into the class (or a factory that allows it to build instances of the interface as needed) via the constructor or a property settor.  The class uses the provided (or created) interface in its methods.  When you go to write your tests, you can mock or fake the interface and provide an interface that responds with data configured in your unit test.  You can do this because your class under test deals only with the interface, not your concrete implementation.  Any class implementing the interface, including your mock or fake class, will do.&lt;/p&gt;\n\n&lt;p&gt;&lt;strong&gt;EDIT:&lt;/strong&gt; Below is a link to an article where Erich Gamma discusses his quote, &quot;Program to an interface, not an implementation.&quot;&lt;/p&gt;\n\n&lt;p&gt;&lt;a href=&quot;http://www.artima.com/lejava/articles/designprinciples.html&quot; rel=&quot;noreferrer&quot;&gt;http://www.artima.com/lejava/articles/designprinciples.html&lt;/a&gt;&lt;/p&gt;\n    ","\n&lt;p&gt;You should look into Inversion of Control:&lt;/p&gt;\n\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=&quot;http://martinfowler.com/articles/injection.html&quot; rel=&quot;nofollow noreferrer&quot;&gt;Martin Fowler: Inversion of Control Containers and the Dependency Injection pattern&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Inversion_of_Control&quot; rel=&quot;nofollow noreferrer&quot;&gt;Wikipedia: Inversion of Control&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n\n&lt;p&gt;In such a scenario, you wouldn&apos;t write this:&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;IInterface classRef = new ObjectWhatever();\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;You would write something like this:&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;IInterface classRef = container.Resolve&amp;lt;IInterface&amp;gt;();\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;This would go into a rule-based setup in the &lt;code&gt;container&lt;/code&gt; object, and construct the actual object for you, which could be ObjectWhatever. The important thing is that you could replace this rule with something that used another type of object altogether, and your code would still work.&lt;/p&gt;\n\n&lt;p&gt;If we leave IoC off the table, you can write code that knows that it can talk to an object &lt;em&gt;that does something specific&lt;/em&gt;, but not which type of object or how it does it.&lt;/p&gt;\n\n&lt;p&gt;This would come in handy when passing parameters.&lt;/p&gt;\n\n&lt;p&gt;As for your parenthesized question &quot;Also, how could you write a method that takes in an object that implements an Interface? Is that possible?&quot;, in C# you would simply use the interface type for the parameter type, like this:&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;public void DoSomethingToAnObject(IInterface whatever) { ... }\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;This plugs right into the &quot;talk to an object that does something specific.&quot; The method defined above knows what to expect from the object, that it implements everything in IInterface, but it doesn&apos;t care which type of object it is, only that it adheres to the contract, which is what an interface is.&lt;/p&gt;\n\n&lt;p&gt;For instance, you&apos;re probably familiar with calculators and have probably used quite a few in your days, but most of the time they&apos;re all different. You, on the other hand, knows how a standard calculator should work, so you&apos;re able to use them all, even if you can&apos;t use the specific features that each calculator has that none of the other has.&lt;/p&gt;\n\n&lt;p&gt;This is the beauty of interfaces. You can write a piece of code, that knows that it will get objects passed to it that it can expect certain behavior from. It doesn&apos;t care one hoot what kind of object it is, only that it supports the behavior needed.&lt;/p&gt;\n\n&lt;p&gt;Let me give you a concrete example.&lt;/p&gt;\n\n&lt;p&gt;We have a custom-built translation system for windows forms. This system loops through controls on a form and translate text in each. The system knows how to handle basic controls, like the-type-of-control-that-has-a-Text-property, and similar basic stuff, but for anything basic, it falls short.&lt;/p&gt;\n\n&lt;p&gt;Now, since controls inherit from pre-defined classes that we have no control over, we could do one of three things:&lt;/p&gt;\n\n&lt;ol&gt;\n&lt;li&gt;Build support for our translation system to detect specifically which type of control it is working with, and translate the correct bits (maintenance nightmare)&lt;/li&gt;\n&lt;li&gt;Build support into base classes (impossible, since all the controls inherit from different pre-defined classes)&lt;/li&gt;\n&lt;li&gt;Add interface support&lt;/li&gt;\n&lt;/ol&gt;\n\n&lt;p&gt;So we did nr. 3. All our controls implement ILocalizable, which is an interface that gives us one method, the ability to translate &quot;itself&quot; into a container of translation text/rules. As such, the form doesn&apos;t need to know which kind of control it has found, only that it implements the specific interface, and knows that there is a method where it can call to localize the control.&lt;/p&gt;\n    ","\n&lt;p&gt;&lt;strong&gt;Code to the Interface Not the Implementation has NOTHING to do with Java, nor its Interface construct.&lt;/strong&gt; &lt;/p&gt;\n\n&lt;p&gt;This concept was brought to prominence in the Patterns / Gang of Four books but was most probably around well before that. &lt;em&gt;The concept certainly existed well before Java ever existed.&lt;/em&gt; &lt;/p&gt;\n\n&lt;p&gt;The Java Interface construct was created to aid in this idea (among other things), and people have become too focused on the construct as the centre of the meaning rather than the original intent. However, it is the reason we have public and private methods and attributes in Java, C++, C#, etc.&lt;/p&gt;\n\n&lt;p&gt;It means just interact with an object or system&apos;s public interface. Don&apos;t worry or even anticipate how it does what it does internally. Don&apos;t worry about how it is implemented. In object-oriented code, it is why we have public vs. private methods/attributes. We are intended to use the public methods because the private methods are there only for use internally, within the class. They make up the implementation of the class and can be changed as required without changing the public interface. Assume that regarding functionality, a method on a class will perform the same operation with the same expected result every time you call it with the same parameters. It allows the author to change how the class works, its implementation, without breaking how people interact with it.&lt;/p&gt;\n\n&lt;p&gt;&lt;em&gt;And you can program to the interface, not the implementation without ever using an Interface construct.&lt;/em&gt; You can program to the interface not the implementation in C++, which does not have an Interface construct. You can integrate two massive enterprise systems much more robustly as long as they interact through public interfaces (contracts) rather than calling methods on objects internal to the systems. The interfaces are expected to always react the same expected way given the same input parameters; if implemented to the interface and not the implementation. The concept works in many places.&lt;/p&gt;\n\n&lt;p&gt;Shake the thought that Java Interfaces have anything what-so-ever to do with the concept of &apos;Program to the Interface, Not the Implementation&apos;. They can help apply the concept, but they are &lt;strong&gt;not&lt;/strong&gt; the concept. &lt;/p&gt;\n    ","\n&lt;p&gt;It sounds like you understand how interfaces work but are unsure of when to use them and what advantages they offer. Here are a few examples of when an interface would make sense:&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;// if I want to add search capabilities to my application and support multiple search\n// engines such as Google, Yahoo, Live, etc.\n\ninterface ISearchProvider\n{\n    string Search(string keywords);\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;then I could create GoogleSearchProvider, YahooSearchProvider, LiveSearchProvider, etc.&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;// if I want to support multiple downloads using different protocols\n// HTTP, HTTPS, FTP, FTPS, etc.\ninterface IUrlDownload\n{\n    void Download(string url)\n}\n\n// how about an image loader for different kinds of images JPG, GIF, PNG, etc.\ninterface IImageLoader\n{\n    Bitmap LoadImage(string filename)\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;then create JpegImageLoader, GifImageLoader, PngImageLoader, etc.&lt;/p&gt;\n\n&lt;p&gt;Most add-ins and plugin systems work off interfaces.&lt;/p&gt;\n\n&lt;p&gt;Another popular use is for the Repository pattern. Say I want to load a list of zip codes from different sources&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;interface IZipCodeRepository\n{\n    IList&amp;lt;ZipCode&amp;gt; GetZipCodes(string state);\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;then I could create an XMLZipCodeRepository, SQLZipCodeRepository, CSVZipCodeRepository, etc. For my web applications, I often create XML repositories early on so I can get something up and running before the SQL Database is ready. Once the database is ready I write an SQLRepository to replace the XML version. The rest of my code remains unchanged since it runs solely off of interfaces.&lt;/p&gt;\n\n&lt;p&gt;Methods can accept interfaces such as:&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;PrintZipCodes(IZipCodeRepository zipCodeRepository, string state)\n{\n    foreach (ZipCode zipCode in zipCodeRepository.GetZipCodes(state))\n    {\n        Console.WriteLine(zipCode.ToString());\n    }\n}\n&lt;/code&gt;&lt;/pre&gt;\n    ","\n&lt;p&gt;It makes your code a lot more extensible and easier to maintain when you have sets of similar classes.  I am a junior programmer, so I am no expert, but I just finished a project that required something similar.&lt;/p&gt;\n\n&lt;p&gt;I work on client side software that talks to a server running a medical device.  We are developing a new version of this device that has some new components that the customer must configure at times.  There are two types of new components, and they are different, but they are also very similar.  Basically, I had to create two config forms, two lists classes, two of everything.  &lt;/p&gt;\n\n&lt;p&gt;I decided that it would be best to create an abstract base class for each control type that would hold almost all of the real logic, and then derived types to take care of the differences between the two components.  However, the base classes would not have been able to perform operations on these components if I had to worry about types all of the time (well, they could have, but there would have been an &quot;if&quot; statement or switch in every method).&lt;/p&gt;\n\n&lt;p&gt;I defined a simple interface for these components and all of the base classes talk to this interface.  Now when I change something, it pretty much &apos;just works&apos; everywhere and I have no code duplication.&lt;/p&gt;\n    ","\n&lt;p&gt;A lot of explanation out there, but to make it even more simpler. Take for instance a &lt;code&gt;List&lt;/code&gt;. One can implement a list with as:&lt;/p&gt;\n\n&lt;ol&gt;\n&lt;li&gt;An internal array&lt;/li&gt;\n&lt;li&gt;A linked list&lt;/li&gt;\n&lt;li&gt;Other implementations&lt;/li&gt;\n&lt;/ol&gt;\n\n&lt;p&gt;By building to an interface, say a &lt;code&gt;List&lt;/code&gt;. You only code as to definition of List or what &lt;code&gt;List&lt;/code&gt; means in reality.&lt;/p&gt;\n\n&lt;p&gt;You could use any type of implementation internally say an &lt;code&gt;array&lt;/code&gt; implementation. But suppose you wish to change the implementation for some reason say a bug or performance. Then you just have to change the declaration &lt;code&gt;List&amp;lt;String&amp;gt; ls = new ArrayList&amp;lt;String&amp;gt;()&lt;/code&gt; to &lt;code&gt;List&amp;lt;String&amp;gt; ls = new LinkedList&amp;lt;String&amp;gt;()&lt;/code&gt;.&lt;/p&gt;\n\n&lt;p&gt;Nowhere else in code, will you have to change anything else; Because everything else was built on the definition of &lt;code&gt;List&lt;/code&gt;.&lt;/p&gt;\n    ","\n&lt;p&gt;If you program in Java, JDBC is a good example.  JDBC defines a set of interfaces but says nothing about the implementation.  Your applications can be written against this set of interfaces.  In theory, you pick some JDBC driver and your application would just work.  If you discover there&apos;s a faster or &quot;better&quot; or cheaper JDBC driver or for whatever reason, you can again in theory re-configure your property file, and without having to make any change in your application, your application would still work.&lt;/p&gt;\n    ","\n&lt;p&gt;I am a late comer to this question, but I want to mention here that the line &quot;Program to an interface, not an implementation&quot; had some good discussion in the GoF (Gang of Four) Design Patterns book.&lt;/p&gt;\n\n&lt;p&gt;It stated, on p. 18:&lt;/p&gt;\n\n&lt;blockquote&gt;\n  &lt;p&gt;&lt;strong&gt;Program to an interface, not an implementation&lt;/strong&gt;&lt;/p&gt;\n  \n  &lt;p&gt;Don&apos;t declare variables to be instances of particular concrete classes. Instead, commit only to an interface defined by an abstract class. You will find this to be a common theme of the design patterns in this book.&lt;/p&gt;\n&lt;/blockquote&gt;\n\n&lt;p&gt;and above that, it began with:&lt;/p&gt;\n\n&lt;blockquote&gt;\n  &lt;p&gt;There are two benefits to manipulating objects solely in terms of the interface defined by abstract classes:&lt;/p&gt;\n  \n  &lt;ol&gt;\n  &lt;li&gt;Clients remain unaware of the specific types of objects they use, as long as the objects adhere to the interface that clients expect.&lt;/li&gt;\n  &lt;li&gt;Clients remain unaware of the classes that implement these objects. Clients only know about the abstract class(es) defining the interface.&lt;/li&gt;\n  &lt;/ol&gt;\n&lt;/blockquote&gt;\n\n&lt;p&gt;So in other words, don&apos;t write it your classes so that it has a &lt;code&gt;quack()&lt;/code&gt; method for ducks, and then a &lt;code&gt;bark()&lt;/code&gt; method for dogs, because they are too specific for a particular implementation of a class (or subclass).  Instead, write the method using names that are general enough to be used in the base class, such as &lt;code&gt;giveSound()&lt;/code&gt; or &lt;code&gt;move()&lt;/code&gt;, so that they can be used for ducks, dogs, or even cars, and then the client of your classes can just say &lt;code&gt;.giveSound()&lt;/code&gt; rather than thinking about whether to use &lt;code&gt;quack()&lt;/code&gt; or &lt;code&gt;bark()&lt;/code&gt; or even determine the type before issuing the correct message to be sent to the object.&lt;/p&gt;\n    ","\n&lt;p&gt;Programming to Interfaces is awesome, it promotes loose coupling. As @lassevk mentioned, Inversion of Control is a great use of this.&lt;/p&gt;\n\n&lt;p&gt;&lt;strong&gt;In addition, look into SOLID principals&lt;/strong&gt;. &lt;a href=&quot;http://dimecasts.net/Casts/ByTag/SOLID%20Principle&quot; rel=&quot;nofollow noreferrer&quot;&gt;here is a video series&lt;/a&gt;&lt;/p&gt;\n\n&lt;p&gt;It goes through a hard coded (strongly coupled example) then looks at interfaces, finally progressing to a IoC/DI tool (NInject)&lt;/p&gt;\n    ","\n&lt;p&gt;To add to the existing posts, sometimes coding to interfaces helps on large projects when developers work on separate components simultaneously. All you need is to define interfaces upfront and write code to them while other developers write code to the interface you are implementing.&lt;/p&gt;\n    ","\n&lt;p&gt;It can be advantageous to program to interfaces, even when we are not depending on abstractions.&lt;/p&gt;\n\n&lt;p&gt;Programming to interfaces &lt;strong&gt;forces us to use a contextually appropriate subset of an object&lt;/strong&gt;. That helps because it: &lt;/p&gt;\n\n&lt;ol&gt;\n&lt;li&gt;prevents us from doing contextually inappropriate things, and &lt;/li&gt;\n&lt;li&gt;lets us safely change the implementation in the future.&lt;/li&gt;\n&lt;/ol&gt;\n\n&lt;p&gt;For example, consider a &lt;code&gt;Person&lt;/code&gt; class that implements the &lt;code&gt;Friend&lt;/code&gt; and the &lt;code&gt;Employee&lt;/code&gt; interface.&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;class Person implements AbstractEmployee, AbstractFriend {\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;In the context of the person&apos;s birthday, we program to the &lt;code&gt;Friend&lt;/code&gt; interface, to prevent treating the person like an &lt;code&gt;Employee&lt;/code&gt;.&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;function party() {\n    const friend: Friend = new Person(&quot;Kathryn&quot;);\n    friend.HaveFun();\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;In the context of the person&apos;s work, we program to the &lt;code&gt;Employee&lt;/code&gt; interface, to prevent blurring workplace boundaries.&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;function workplace() {\n    const employee: Employee = new Person(&quot;Kathryn&quot;);\n    employee.DoWork();\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Great. We have behaved appropriately in different contexts, and our software is working well.&lt;/p&gt;\n\n&lt;p&gt;Far into the future, if our business changes to work with dogs, we can change the software fairly easily. First, we create a &lt;code&gt;Dog&lt;/code&gt; class that implements both &lt;code&gt;Friend&lt;/code&gt; and &lt;code&gt;Employee&lt;/code&gt;. Then, we safely change &lt;code&gt;new Person()&lt;/code&gt; to &lt;code&gt;new Dog()&lt;/code&gt;. Even if both functions have thousands of lines of code, that simple edit will work because we know the following are true:&lt;/p&gt;\n\n&lt;ol&gt;\n&lt;li&gt;Function &lt;code&gt;party&lt;/code&gt; uses only the &lt;code&gt;Friend&lt;/code&gt; subset of &lt;code&gt;Person&lt;/code&gt;.&lt;/li&gt;\n&lt;li&gt;Function &lt;code&gt;workplace&lt;/code&gt; uses only the &lt;code&gt;Employee&lt;/code&gt; subset of &lt;code&gt;Person&lt;/code&gt;.&lt;/li&gt;\n&lt;li&gt;Class &lt;code&gt;Dog&lt;/code&gt; implements both the &lt;code&gt;Friend&lt;/code&gt; and &lt;code&gt;Employee&lt;/code&gt; interfaces.&lt;/li&gt;\n&lt;/ol&gt;\n\n&lt;p&gt;On the other hand, if either &lt;code&gt;party&lt;/code&gt; or &lt;code&gt;workplace&lt;/code&gt; were to have programmed against &lt;code&gt;Person&lt;/code&gt;, there would be a risk of both having &lt;code&gt;Person&lt;/code&gt;-specific code. Changing from &lt;code&gt;Person&lt;/code&gt; to &lt;code&gt;Dog&lt;/code&gt; would require us to comb through the code to extirpate any &lt;code&gt;Person&lt;/code&gt;-specific code that &lt;code&gt;Dog&lt;/code&gt; does not support.&lt;/p&gt;\n\n&lt;p&gt;&lt;strong&gt;The moral&lt;/strong&gt;: programming to interfaces helps our code to behave appropriately and to be ready for change. It also prepares our code to depend on abstractions, which brings even more advantages.&lt;/p&gt;\n    ","\n&lt;p&gt;If I&apos;m writing a new class &lt;code&gt;Swimmer&lt;/code&gt; to add the functionality &lt;code&gt;swim()&lt;/code&gt; and need to use an object of class say &lt;code&gt;Dog&lt;/code&gt;, and this &lt;code&gt;Dog&lt;/code&gt; class implements interface &lt;code&gt;Animal&lt;/code&gt; which declares &lt;code&gt;swim()&lt;/code&gt;.&lt;/p&gt;\n\n&lt;p&gt;At the top of the hierarchy (&lt;code&gt;Animal&lt;/code&gt;), it&apos;s very abstract while at the bottom (&lt;code&gt;Dog&lt;/code&gt;) it&apos;s very concrete. The way I think about &quot;programming to interfaces&quot; is that, as I write &lt;code&gt;Swimmer&lt;/code&gt; class, I want to write my code against the interface that&apos;s as far up that hierarchy which in this case is an &lt;code&gt;Animal&lt;/code&gt; object. An interface is free from implementation details and thus makes your code loosely-coupled.&lt;/p&gt;\n\n&lt;p&gt;The implementation details can be changed with time, however, it would not affect the remaining code since all you are interacting with is with the interface and not the implementation. You don&apos;t care what the implementation is like... all you know is that there will be a class that would implement the interface.&lt;/p&gt;\n    ","\n&lt;p&gt;It is also good for Unit Testing, you can inject your own classes (that meet the requirements of the interface) into a class that depends on it&lt;/p&gt;\n    ","\n&lt;p&gt;Short story: A postman is asked to go home after home and receive the covers contains (letters, documents, cheques, gift cards, application, love letter) with the address written on it to deliver.&lt;/p&gt;\n\n&lt;p&gt;Suppose there is no cover and ask the postman to go home after home and receive all the things and deliver to other people, the postman can get confused.&lt;/p&gt;\n\n&lt;p&gt;So better wrap it with cover (in our story it is the interface) then he will do his job fine.&lt;/p&gt;\n\n&lt;p&gt;Now the postman&apos;s job is to receive and deliver the covers only (he wouldn&apos;t bothered what is inside in the cover).&lt;/p&gt;\n\n&lt;p&gt;Create a type of &lt;code&gt;interface&lt;/code&gt; not actual type, but implement it with actual type.&lt;/p&gt;\n\n&lt;p&gt;To create to interface means your components get &lt;strong&gt;Fit into the rest of code easily&lt;/strong&gt;&lt;/p&gt;\n\n&lt;p&gt;I give you an example.&lt;/p&gt;\n\n&lt;p&gt;you have the AirPlane interface as below.&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;interface Airplane{\n    parkPlane();\n    servicePlane();\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Suppose you have methods in your Controller class of Planes like&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;parkPlane(Airplane plane)\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;and&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;servicePlane(Airplane plane)\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;implemented in your program. It will not &lt;strong&gt;BREAK&lt;/strong&gt; your code.\nI mean, it need not to change as long as it accepts arguments as &lt;code&gt;AirPlane&lt;/code&gt;.&lt;/p&gt;\n\n&lt;p&gt;Because it will accept any Airplane despite actual type, &lt;code&gt;flyer&lt;/code&gt;, &lt;code&gt;highflyr&lt;/code&gt;, &lt;code&gt;fighter&lt;/code&gt;, etc.&lt;/p&gt;\n\n&lt;p&gt;Also, in a collection:&lt;/p&gt;\n\n&lt;p&gt;&lt;code&gt;List&amp;lt;Airplane&amp;gt; plane;&lt;/code&gt; // Will take all your planes.&lt;/p&gt;\n\n&lt;p&gt;The following example will clear your understanding.&lt;/p&gt;\n\n&lt;hr&gt;\n\n&lt;p&gt;You have a fighter plane that implements it, so&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;public class Fighter implements Airplane {\n\n    public void  parkPlane(){\n        // Specific implementations for fighter plane to park\n    }\n    public void  servicePlane(){\n        // Specific implementatoins for fighter plane to service.\n    }\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;The same thing for HighFlyer and other clasess:&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;public class HighFlyer implements Airplane {\n\n    public void  parkPlane(){\n        // Specific implementations for HighFlyer plane to park\n    }\n\n    public void  servicePlane(){\n        // specific implementatoins for HighFlyer plane to service.\n    }\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Now think your controller classes using &lt;code&gt;AirPlane&lt;/code&gt; several times,&lt;/p&gt;\n\n&lt;p&gt;Suppose your Controller class is ControlPlane like below,&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;public Class ControlPlane{ \n AirPlane plane;\n // so much method with AirPlane reference are used here...\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Here magic comes as you may make your new &lt;code&gt;AirPlane&lt;/code&gt; type instances as many as you want and you are not changing the code of &lt;code&gt;ControlPlane&lt;/code&gt; class.&lt;/p&gt;\n\n&lt;p&gt;You can add an instance...&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;JumboJetPlane // implementing AirPlane interface.\nAirBus        // implementing AirPlane interface.\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;You may remove instances of previously created types too.&lt;/p&gt;\n    ","\n&lt;p&gt;So, just to get this right, the advantage of a interface is that I can separate the calling of a method from any particular class. Instead creating a instance of the interface, where the implementation is given from whichever class I choose that implements that interface. Thus allowing me to have many classes, which have similar but slightly different functionality and in some cases (the cases related to the intention of the interface) not care which object it is.&lt;/p&gt;\n\n&lt;p&gt;For example, I could have a movement interface. A method which makes something &apos;move&apos; and any object (Person, Car, Cat) that implements the movement interface could be passed in and told to move. Without the method every knowing the type of class it is. &lt;/p&gt;\n    ","\n&lt;p&gt;Imagine you have a product called &apos;Zebra&apos; that can be extended by plugins. It finds the plugins by searching for DLLs in some directory. It loads all those DLLs and uses reflection to find any classes that implement &lt;code&gt;IZebraPlugin&lt;/code&gt;, and then calls the methods of that interface to communicate with the plugins. &lt;/p&gt;\n\n&lt;p&gt;This makes it completely independent of any specific plugin class - it doesn&apos;t care what the classes are. It only cares that they fulfill the interface specification. &lt;/p&gt;\n\n&lt;p&gt;Interfaces are a way of defining points of extensibility like this. Code that talks to an interface is more loosely coupled - in fact it is not coupled at all to any other specific code. It can inter-operate with plugins written years later by people who have never met the original developer.&lt;/p&gt;\n\n&lt;p&gt;You could instead use a base class with virtual functions - all plugins would be derived from the base class. But this is much more limiting because a class can only have one base class, whereas it can implement any number of interfaces.&lt;/p&gt;\n    ","\n&lt;p&gt;C++ explanation.&lt;/p&gt;\n\n&lt;p&gt;Think of an interface as your classes public methods.&lt;/p&gt;\n\n&lt;p&gt;You then could create a template that &apos;depends&apos; on these public methods in order to carry out it&apos;s own function (it makes function calls defined in the classes public interface). Lets say this template is a container, like a Vector class, and the interface it depends on is a search algorithm.&lt;/p&gt;\n\n&lt;p&gt;Any algorithm class that defines the functions/interface Vector makes calls to will satisfy the &apos;contract&apos; (as someone explained in the original reply). The algorithms don&apos;t even need to be of the same base class; the only requirement is that the functions/methods that the Vector depends on (interface) is defined in your algorithm.&lt;/p&gt;\n\n&lt;p&gt;The point of all of this is that you could supply any different search algorithm/class just as long as it supplied the interface that Vector depends on (bubble search, sequential search, quick search).&lt;/p&gt;\n\n&lt;p&gt;You might also want to design other containers (lists, queues) that would harness the same search algorithm as Vector by having them fulfill the interface/contract that your search algorithms depends on.&lt;/p&gt;\n\n&lt;p&gt;This saves time (OOP principle &apos;code reuse&apos;) as you are able to write an algorithm once instead of again and again and again specific to every new object you create without over-complicating the issue with an overgrown inheritance tree.&lt;/p&gt;\n\n&lt;p&gt;As for &apos;missing out&apos; on how things operate; big-time (at least in C++), as this is how most of the Standard TEMPLATE Library&apos;s framework operates.&lt;/p&gt;\n\n&lt;p&gt;Of course when using inheritance and abstract classes the methodology of programming to an interface changes; but the principle is the same, your public functions/methods are your classes interface.&lt;/p&gt;\n\n&lt;p&gt;This is a huge topic and one of the the cornerstone principles of Design Patterns.&lt;/p&gt;\n    ","\n&lt;p&gt;In Java these concrete classes all implement the CharSequence interface:&lt;/p&gt;\n\n&lt;blockquote&gt;\n  &lt;p&gt;CharBuffer, String, StringBuffer, StringBuilder&lt;/p&gt;\n&lt;/blockquote&gt;\n\n&lt;p&gt;These concrete classes do not have a common parent class other than Object, so there is nothing that relates them, other than the fact they each have something to do with arrays of characters, representing such, or manipulating such. For instance, the characters of String cannot be changed once a String object is instantiated, whereas the characters of StringBuffer or StringBuilder can be edited.&lt;/p&gt;\n\n&lt;p&gt;Yet each one of these classes is capable of suitably implementing the CharSequence interface methods:&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;char charAt(int index)\nint length()\nCharSequence subSequence(int start, int end)\nString toString()\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;In some cases, Java class library classes that used to accept String have been revised to now accept the CharSequence interface. So if you have an instance of StringBuilder, instead of extracting a String object (which means instantiating a new object instance), it can instead just pass the StringBuilder itself as it implements the CharSequence interface.&lt;/p&gt;\n\n&lt;p&gt;The Appendable interface that some classes implement has much the same kind of benefit for any situation where characters can be appended to an instance of the underlying concrete class object instance. All of these concrete classes implement the Appendable interface:&lt;/p&gt;\n\n&lt;blockquote&gt;\n  &lt;p&gt;BufferedWriter, CharArrayWriter, CharBuffer, FileWriter, FilterWriter, LogStream, OutputStreamWriter, PipedWriter, PrintStream, PrintWriter, StringBuffer, StringBuilder, StringWriter, Writer&lt;/p&gt;\n&lt;/blockquote&gt;\n    ","\n&lt;p&gt;An interface is like a contract, where you want your implementation class to implement methods written in the contract (interface). Since Java does not provide multiple inheritance, &quot;programming to interface&quot; is a good way to achieve multiple inheritance.&lt;/p&gt;\n\n&lt;p&gt;If you have a class A that is already extending some other class B, but you want that class A to also follow certain guidelines or implement a certain contract, then you can do so by the &quot;programming to interface&quot; strategy.&lt;/p&gt;\n    ","\n&lt;blockquote&gt;\n&lt;p&gt;Q: - ... &quot;Could you use any class that implements an interface?&quot;&lt;br&gt;\nA: - Yes.&lt;/p&gt;\n&lt;p&gt;Q: - ... &quot;When would you need to do that?&quot;&lt;br&gt;\nA: - Each time you need a class(es) that implements interface(s).&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; &lt;em&gt;We couldn&apos;t instantiate an interface not implemented by a class&lt;/em&gt; - &lt;strong&gt;True.&lt;/strong&gt;&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;Why?&lt;/li&gt;\n&lt;li&gt;Because the interface has only method prototypes, not definitions (just functions names, not their logic)&lt;/li&gt;\n&lt;/ul&gt;\n&lt;blockquote&gt;\n&lt;p&gt;&lt;code&gt;AnIntf anInst = new Aclass();&lt;/code&gt;&lt;br&gt;\n// &lt;em&gt;we could do this &lt;strong&gt;only if&lt;/strong&gt; Aclass implements AnIntf.&lt;/em&gt;&lt;br&gt;\n// anInst will have Aclass reference.&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;hr&gt;\n&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; &lt;em&gt;Now we could understand what happened if Bclass and Cclass implemented same Dintf.&lt;/em&gt;&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;Dintf bInst = new Bclass();  \n// now we could call all Dintf functions implemented (defined) in Bclass.\n\nDintf cInst = new Cclass();  \n// now we could call all Dintf functions implemented (defined) in Cclass.\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;&lt;strong&gt;What we have:&lt;/strong&gt; Same interface prototypes (functions names in interface), and call different implementations.&lt;/p&gt;\n&lt;p&gt;&lt;em&gt;Bibliography:&lt;/em&gt;\n&lt;a href=&quot;https://en.wikipedia.org/wiki/Function_prototype&quot; rel=&quot;nofollow noreferrer&quot;&gt;Prototypes - wikipedia&lt;/a&gt;&lt;/p&gt;\n    ","\n&lt;p&gt;Previous answers focus on programming to an abstraction for the sake of extensibility and loose coupling. While these are very important points,\n&lt;strong&gt;readability&lt;/strong&gt; is equally important. Readability allows others (and your future self) to understand the code with minimal effort. This is why readability leverages abstractions.&lt;/p&gt;\n&lt;p&gt;An abstraction is, by definition, simpler than its implementation. An abstraction omits detail in order to convey the essence or purpose of a thing, but nothing more.\nBecause abstractions are simpler, I can fit a lot more of them in my head at one time, compared to implementations.&lt;/p&gt;\n&lt;p&gt;As a programmer (in any language) I walk around with a general idea of a &lt;code&gt;List&lt;/code&gt; in my head at all times. In particular, a &lt;code&gt;List&lt;/code&gt; allows random access, duplicate elements, and maintains order. When I see a declaration like this: &lt;code&gt;List myList = new ArrayList()&lt;/code&gt; I think, &lt;em&gt;cool&lt;/em&gt;, this is a &lt;code&gt;List&lt;/code&gt; that&apos;s being used in the (basic) way that I understand; and I don&apos;t have to think any more about it.&lt;/p&gt;\n&lt;p&gt;On the other hand, I do not carry around the specific implementation details of &lt;code&gt;ArrayList&lt;/code&gt; in my head. So when I see, &lt;code&gt;ArrayList myList = new ArrayList()&lt;/code&gt;. I think, &lt;em&gt;uh-oh&lt;/em&gt;, this &lt;code&gt;ArrayList&lt;/code&gt; must be used in a way that isn&apos;t covered by the &lt;code&gt;List&lt;/code&gt; interface. Now I have to track down all the usages of this &lt;code&gt;ArrayList&lt;/code&gt; to understand why, because otherwise I won&apos;t be able to fully understand this code. It gets even more confusing when I discover that 100% of the usages of this &lt;code&gt;ArrayList&lt;/code&gt; &lt;em&gt;do&lt;/em&gt; conform to the &lt;code&gt;List&lt;/code&gt; interface. Then I&apos;m left wondering... was there some code relying on &lt;code&gt;ArrayList&lt;/code&gt; implementation details that got deleted? Was the programmer who instantiated it just incompetent? Is this application locked into that specific implementation in some way at runtime? A way that I don&apos;t understand?&lt;/p&gt;\n&lt;p&gt;I&apos;m now confused and uncertain about this application, and all we&apos;re talking about is a simple &lt;code&gt;List&lt;/code&gt;. What if this was a complex business object ignoring its interface? Then my knowledge of the business domain is insufficient to understand the purpose of the code.&lt;/p&gt;\n&lt;p&gt;So even when I need a &lt;code&gt;List&lt;/code&gt; strictly within a &lt;code&gt;private&lt;/code&gt; method (nothing that would break other applications if it changed, and I could easily find/replace every usage in my IDE) it still benefits readability to program to an abstraction. Because abstractions are simpler than implementation details. You could say that programming to abstractions is one way of adhering to the &lt;a href=&quot;https://en.wikipedia.org/wiki/KISS_principle&quot; rel=&quot;nofollow noreferrer&quot;&gt;KISS&lt;/a&gt; principle.&lt;/p&gt;\n    ","\n&lt;p&gt;program to an interface is a term from the GOF book. i would not directly say it has to do with java interface but rather real interfaces.  to achieve clean layer separation, you need to create some separation between systems for example:  Let&apos;s say you had a concrete database you want to use, you would never &quot;program to the database&quot;  , instead you would &quot;program to the storage interface&quot;. Likewise you would never &quot;program to a Web Service&quot; but rather you would program to a &quot;client interface&quot;.  this is so you can easily swap things out.&lt;/p&gt;\n&lt;p&gt;i find these rules help me:&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;1&lt;/strong&gt;. we use a java interface when we have multiple types of an object. if i just have single object, i dont see the point. if there are at least two concrete implementations of some idea, then i  would use a java  interface.&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;2&lt;/strong&gt;. if as i stated above, you want to bring decoupling from an external system (storage system) to your own system (local DB) then also  use a interface.&lt;/p&gt;\n&lt;p&gt;notice how there are two ways to consider when to use them.&lt;/p&gt;\n    ","\n&lt;p&gt;&lt;strong&gt;Program to an interface&lt;/strong&gt; allows to change implementation of contract defined by interface seamlessly. It allows loose coupling between contract and specific implementations.&lt;/p&gt;\n&lt;blockquote&gt;\n&lt;p&gt;&lt;code&gt;IInterface classRef = new ObjectWhatever()&lt;/code&gt;&lt;/p&gt;\n&lt;p&gt;You could use any class that implements IInterface? When would you need to do that?&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;p&gt;Have a look at this SE question for good example.&lt;/p&gt;\n&lt;p&gt;&lt;a href=&quot;https://stackoverflow.com/questions/147468/why-should-the-interface-for-a-java-class-be-prefered/41347099#41347099&quot;&gt;Why should the interface for a Java class be preferred?&lt;/a&gt;&lt;/p&gt;\n&lt;blockquote&gt;\n&lt;p&gt;does using an Interface hit performance?&lt;/p&gt;\n&lt;p&gt;if so how much?&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;p&gt;Yes. It will have slight performance overhead in sub-seconds. But if your application has requirement to change the implementation of interface dynamically, don&apos;t worry about performance impact.&lt;/p&gt;\n&lt;blockquote&gt;\n&lt;p&gt;how can you avoid it without having to maintain two bits of code?&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;p&gt;Don&apos;t try to avoid multiple implementations of interface if your application need them. In absence of tight coupling of interface with one specific implementation,  you may have to deploy the patch to change one implementation to other implementation.&lt;/p&gt;\n&lt;p&gt;One good use case: Implementation of Strategy pattern:&lt;/p&gt;\n&lt;p&gt;&lt;a href=&quot;https://stackoverflow.com/questions/370258/real-world-example-of-the-strategy-pattern/35180265#35180265&quot;&gt;Real World Example of the Strategy Pattern&lt;/a&gt;&lt;/p&gt;\n    ","\n&lt;p&gt;&quot;Program to interface&quot; means don&apos;t provide hard code right the way, meaning your code should be extended without breaking the previous functionality. Just extensions, not editing the previous code.&lt;/p&gt;\n    ","\n&lt;p&gt;&lt;strong&gt;Coding to an interface&lt;/strong&gt; is a philosophy, rather than specific language constructs or design patterns - it instructs you what is the correct order of steps to follow in order to create &lt;strong&gt;better software systems&lt;/strong&gt; (e.g. more resilient, more testable, more scalable, more extendible, and other nice traits).&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;What it actually means is:&lt;/strong&gt;&lt;/p&gt;\n&lt;p&gt;===&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;Before jumping to implementations and coding (the HOW) - think of the WHAT:&lt;/strong&gt;&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;What black boxes should make up your system,&lt;/li&gt;\n&lt;li&gt;What is each box&apos; responsibility,&lt;/li&gt;\n&lt;li&gt;What are the ways each &quot;client&quot; (that is, one of those other boxes, 3rd party &quot;boxes&quot;, or even humans) should communicate with it (the API of each box).&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;&lt;strong&gt;After&lt;/strong&gt; you figure the above, go ahead and implement those boxes (the HOW).&lt;/p&gt;\n&lt;p&gt;Thinking first of what a box&apos; is and what its API, leads the developer to distil the box&apos; responsibility, and to mark for himself and future developers the difference between what is its exposed details (&quot;API&quot;) and it&apos;s hidden details (&quot;implementation details&quot;), which is a very important differentiation to have.&lt;/p&gt;\n&lt;p&gt;One immediate and easily noticeable gain is the team can then change and improve implementations without affecting the general architecture. It also makes the system MUCH more testable (it goes well with the TDD approach).&lt;/p&gt;\n&lt;p&gt;===&lt;br&gt;\nBeyond the traits I&apos;ve mentioned above, you also save A LOT OF TIME going this direction.&lt;/p&gt;\n&lt;p&gt;Micro Services and DDD, when done right, are great examples of &quot;Coding to an interface&quot;, however the concept wins in every pattern from monoliths to &quot;serverless&quot;, from BE to FE, from OOP to functional, etc....&lt;/p&gt;\n&lt;p&gt;I strongly recommend this approach for Software Engineering (and I basically believe it makes total sense in other fields as well).&lt;/p&gt;\n    ","\n&lt;p&gt;Also I see a lot of good and explanatory answers here, so I want to give my point of view here, including some extra information what I noticed when using this method.&lt;/p&gt;\n\n&lt;p&gt;&lt;strong&gt;Unit testing&lt;/strong&gt;&lt;/p&gt;\n\n&lt;p&gt;For the last two years, I have written a hobby project and I did not write unit tests for it. After writing about 50K lines I found out it would be really necessary to write unit tests.\nI did not use interfaces (or very sparingly) ... and when I made my first unit test, I found out it was complicated. Why?&lt;/p&gt;\n\n&lt;p&gt;Because I had to make a lot of class instances, used for input as class variables and/or parameters. So the tests look more like integration tests (having to make a complete &apos;framework&apos; of classes since all was tied together).&lt;/p&gt;\n\n&lt;p&gt;&lt;strong&gt;Fear of interfaces&lt;/strong&gt;\nSo I decided to use interfaces. My fear was that I had to implement all functionality everywhere (in all used classes) multiple times. In some way this is true, however, by using inheritance it can be reduced a lot.&lt;/p&gt;\n\n&lt;p&gt;&lt;strong&gt;Combination of interfaces and inheritance&lt;/strong&gt;\nI found out the combination is very good to be used. I give a very simple example.&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;public interface IPricable\n{\n    int Price { get; }\n}\n\npublic interface ICar : IPricable\n\npublic abstract class Article\n{\n    public int Price { get { return ... } }\n}\n\npublic class Car : Article, ICar\n{\n    // Price does not need to be defined here\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;This way copying code is not necessary, while still having the benefit of using a car as interface (ICar).&lt;/p&gt;\n    "]},"randomTags":[{"name":"optimization","slug":"optimization"},{"name":"http-status-code-404","slug":"http-status-code-404"},{"name":"pass-by-value","slug":"pass-by-value"},{"name":"this","slug":"this"},{"name":"mongodb-query","slug":"mongodb-query"},{"name":"invoke","slug":"invoke"},{"name":"identity-operator","slug":"identity-operator"},{"name":"preg-match","slug":"preg-match"},{"name":"jakarta-ee","slug":"jakarta-ee"},{"name":"security","slug":"security"},{"name":"compiler-optimization","slug":"compiler-optimization"},{"name":"unix","slug":"unix"},{"name":"using-directives","slug":"using-directives"},{"name":"async-await","slug":"async-await"},{"name":"chromium","slug":"chromium"},{"name":"android-activity","slug":"android-activity"},{"name":"microbenchmark","slug":"microbenchmark"},{"name":"list-comprehension","slug":"list-comprehension"},{"name":"reshape","slug":"reshape"},{"name":"error-handling","slug":"error-handling"}]},"__N_SSG":true}