{"pageProps":{"data":{"count":1,"rows":[{"id":376,"title":"srand() â€” why call it only once?","slug":"srand()-why-call-it-only-once-1657387794760","postType":"QUESTION","createdAt":"2022-07-09T17:29:54.000Z","updatedAt":"2022-07-09T17:29:54.000Z","tags":[{"id":2062,"name":"srand","slug":"srand","createdAt":"2022-07-09T17:29:54.000Z","updatedAt":"2022-07-09T17:29:54.000Z","Questions_Tags":{"questionId":376,"tagId":2062}}]}]},"slug":"srand","page":"1","answers":{"376":["\n&lt;p&gt;That depends on what you are trying to achieve.&lt;/p&gt;\n\n&lt;p&gt;Randomization is performed as a function that has a starting value, namely &lt;strong&gt;the seed&lt;/strong&gt;.&lt;/p&gt;\n\n&lt;p&gt;So, for the same seed, you will always get the same sequence of values.&lt;/p&gt;\n\n&lt;p&gt;If you try to set the seed every time you need a random value, and the seed is the same number, you will always get the same &quot;random&quot; value.&lt;/p&gt;\n\n&lt;p&gt;Seed is usually taken from the current time, which are the seconds, as in &lt;code&gt;time(NULL)&lt;/code&gt;, so if you always set the seed before taking the random number, you will get the same number as long as you call the srand/rand combo multiple times &lt;strong&gt;in the same second&lt;/strong&gt;.&lt;/p&gt;\n\n&lt;p&gt;To avoid this problem, srand is set only once per application, because it is doubtful that two of the application instances will be initialized in the same second, so each instance will then have a different sequence of random numbers.&lt;/p&gt;\n\n&lt;p&gt;However, there is a slight possibility that you will run your app (especially if it&apos;s a short one, or a command line tool or something like that) many times in a second, then you will have to resort to some other way of choosing a seed (unless the same sequence in different application instances is ok by you). But like I said, that depends on your application context of usage.&lt;/p&gt;\n\n&lt;p&gt;Also, you may want to try to increase the precision to microseconds (minimizing the chance of the same seed), requires (&lt;code&gt;sys/time.h&lt;/code&gt;):&lt;/p&gt;\n\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;&lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;timeval&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;t1&lt;/span&gt;;&lt;/span&gt;\ngettimeofday(&amp;amp;t1, &lt;span class=&quot;hljs-literal&quot;&gt;NULL&lt;/span&gt;);\nsrand(t1.tv_usec * t1.tv_sec);\n&lt;/code&gt;&lt;/pre&gt;\n    ","\n&lt;p&gt;Random numbers are actually pseudo random. A seed is set first, from which each call of &lt;code&gt;rand&lt;/code&gt; gets a random number, and modifies the internal state and this new state is used in the next &lt;code&gt;rand&lt;/code&gt; call to get another number. Because a certain formula is used to generate these &quot;random numbers&quot; therefore setting a certain value of seed after every call to &lt;code&gt;rand&lt;/code&gt; will return the same number from the call. For example &lt;code&gt;srand (1234); rand ();&lt;/code&gt; will return the same value. Initializing once the initial state with the seed value will generate enough random numbers as you do not set the internal state with &lt;code&gt;srand&lt;/code&gt;, thus making the numbers more probable to be random.&lt;/p&gt;\n\n&lt;p&gt;Generally we use the &lt;code&gt;time (NULL)&lt;/code&gt; returned seconds value when initializing the seed value. Say the &lt;code&gt;srand (time (NULL));&lt;/code&gt; is in a loop. Then loop can iterate more than once in one second, therefore the number of times the loop iterates inside the loop in a second &lt;code&gt;rand&lt;/code&gt; call in the loop will return the same &quot;random number&quot;, which is not desired. Initializing it once at program start will set the seed once, and each time &lt;code&gt;rand&lt;/code&gt; is called, a new number is generated and the internal state is modified, so the next call &lt;code&gt;rand&lt;/code&gt; returns a number which is random enough.&lt;/p&gt;\n\n&lt;p&gt;For example this code from &lt;a href=&quot;http://linux.die.net/man/3/rand&quot; rel=&quot;noreferrer&quot;&gt;http://linux.die.net/man/3/rand&lt;/a&gt;:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;long&lt;/span&gt; next = &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;;\n&lt;span class=&quot;hljs-comment&quot;&gt;/* RAND_MAX assumed to be 32767 */&lt;/span&gt;\n&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;myrand&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt;)&lt;/span&gt; {\n    next = next * &lt;span class=&quot;hljs-number&quot;&gt;1103515245&lt;/span&gt; + &lt;span class=&quot;hljs-number&quot;&gt;12345&lt;/span&gt;;\n    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt;((&lt;span class=&quot;hljs-type&quot;&gt;unsigned&lt;/span&gt;)(next/&lt;span class=&quot;hljs-number&quot;&gt;65536&lt;/span&gt;) % &lt;span class=&quot;hljs-number&quot;&gt;32768&lt;/span&gt;);\n}\n&lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;mysrand&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-type&quot;&gt;unsigned&lt;/span&gt; seed)&lt;/span&gt; {\n    next = seed;\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;The internal state &lt;code&gt;next&lt;/code&gt; is declared as global. Each &lt;code&gt;myrand&lt;/code&gt; call will modify the internal state and update it, and return a random number. Every call of &lt;code&gt;myrand&lt;/code&gt; will have a different &lt;code&gt;next&lt;/code&gt; value therefore the the method will return the different numbers every call. &lt;/p&gt;\n\n&lt;p&gt;Look at the &lt;code&gt;mysrand&lt;/code&gt; implementation; it simply sets the seed value you pass to &lt;code&gt;next&lt;/code&gt;. Therefore if you set the &lt;code&gt;next&lt;/code&gt; value the same  everytime before calling &lt;code&gt;rand&lt;/code&gt; it will return the same random value, because of the identical formula applied on it, which is not desirable, as the function is made to be random.&lt;/p&gt;\n\n&lt;p&gt;But depending on your needs you can set the seed to some certain value to generate the same &quot;random sequence&quot; each run, say for some benchmark or others.&lt;/p&gt;\n    ","\n&lt;p&gt;Short answer: calling &lt;code&gt;srand()&lt;/code&gt; is &lt;strong&gt;not&lt;/strong&gt; like &quot;rolling the dice&quot; for the random number generator.  Nor is it like shuffling a deck of cards.  If anything, it&apos;s more like just cutting a deck of cards.&lt;/p&gt;\n&lt;p&gt;Think of it like this.  &lt;code&gt;rand()&lt;/code&gt; deals from a big deck of cards, and every time you call it, all it does is pick the next card off the top of the deck, give you the value, and return that card to the bottom of the deck.  (Yes, that means the &quot;random&quot; sequence will repeat after a while.  It&apos;s a &lt;em&gt;very&lt;/em&gt; big deck, though: typically 4,294,967,296 cards.)&lt;/p&gt;\n&lt;p&gt;Furthermore, every time your program runs, a brand-new pack of cards is bought from the game shop, &lt;em&gt;and&lt;/em&gt; every brand-new pack of cards always has the same sequence.  So unless you do something special, every time your program runs, it will get exactly the same &quot;random&quot; numbers back from &lt;code&gt;rand()&lt;/code&gt;.&lt;/p&gt;\n&lt;p&gt;Now, you might say, &quot;Okay, so how do I shuffle the deck?&quot;  And the answer -- at least as far as &lt;code&gt;rand&lt;/code&gt; and &lt;code&gt;srand&lt;/code&gt; are concerned -- is that there is no way of shuffling the deck.&lt;/p&gt;\n&lt;p&gt;So what does &lt;code&gt;srand&lt;/code&gt; do?  Based on the analogy I&apos;ve been building here, calling &lt;code&gt;srand(n)&lt;/code&gt; is basically like saying, &quot;cut the deck &lt;code&gt;n&lt;/code&gt; cards from the top&quot;.  But wait, one more thing: it&apos;s actually &lt;em&gt;start with another brand-new deck and cut it &lt;code&gt;n&lt;/code&gt; cards from the top&lt;/em&gt;.&lt;/p&gt;\n&lt;p&gt;So if you call &lt;code&gt;srand(n)&lt;/code&gt;, &lt;code&gt;rand()&lt;/code&gt;, &lt;code&gt;srand(n)&lt;/code&gt;, &lt;code&gt;rand()&lt;/code&gt;, ..., with the same &lt;code&gt;n&lt;/code&gt; every time, you won&apos;t just get a not-very-random sequence, you&apos;ll actually get the same number back from &lt;code&gt;rand()&lt;/code&gt; every time.  (Probably not the same number you handed to &lt;code&gt;srand&lt;/code&gt;, but the same number back from &lt;code&gt;rand&lt;/code&gt; over and over.)&lt;/p&gt;\n&lt;p&gt;So the best you can do is to cut the deck &lt;em&gt;once&lt;/em&gt;, that is, call &lt;code&gt;srand()&lt;/code&gt; once, at the beginning of your program, with an &lt;code&gt;n&lt;/code&gt; that&apos;s reasonably random, so that you&apos;ll start at a different random place in the big deck each time your program runs.  With &lt;code&gt;rand()&lt;/code&gt;, that really is the best you can do.&lt;/p&gt;\n&lt;p&gt;[P.S. Yes, I know, in real life, when you buy a brand-new deck of cards it&apos;s typically in order, not in random order.  For the analogy here to work, I&apos;m imagining that each deck you buy from the game shop is in a seemingly random order, but the exact same seemingly-random order as every other deck of cards you buy from that same shop.  Sort of like the identically shuffled decks of cards they use in bridge tournaments.]&lt;/p&gt;\n&lt;hr&gt;\n&lt;p&gt;Addendum: For a very cute demonstration of the fact that for a given PRNG algorithm and a given seed value, you always get the same sequence, see &lt;a href=&quot;https://stackoverflow.com/questions/15182496/why-does-this-code-using-random-strings-print-hello-world&quot;&gt;this question&lt;/a&gt; (which is about Java, not C, but anyway).&lt;/p&gt;\n    ","\n&lt;p&gt;The reason is that &lt;code&gt;srand()&lt;/code&gt; sets the initial state of the random generator, and all the values that generator produces are only &quot;random enough&quot; if you don&apos;t touch the state yourself in between.&lt;/p&gt;\n\n&lt;p&gt;For example you could do:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;getRandomValue&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt;\n{\n    srand(time(&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;));\n    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; rand();\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;and then if you call that function repeatedly so that &lt;code&gt;time()&lt;/code&gt; returns the same values in adjacent calls you just get the same value generated - that&apos;s by design.&lt;/p&gt;\n    ","\n&lt;p&gt;A simpler solution for using &lt;code&gt;srand()&lt;/code&gt; for generating different seeds for application instances run at the same second is as seen.&lt;/p&gt;\n\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;srand(time(&lt;span class=&quot;hljs-literal&quot;&gt;NULL&lt;/span&gt;)-getpid());\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;This method makes your seed very close to random as there is no way to guess at what time your thread started and the pid will be different also.&lt;/p&gt;\n    ","\n&lt;p&gt;srand seeds the pseudorandom number generator.  If you call it more than once, you will reseed the RNG.  And if you call it with the same argument, it will restart the same sequence.&lt;/p&gt;\n&lt;p&gt;To prove it, if you do something simple like this, you will see the same number printed 100 times:&lt;/p&gt;\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&amp;lt;stdlib.h&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt; {\n    &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;; i != &lt;span class=&quot;hljs-number&quot;&gt;100&lt;/span&gt;; ++i) {\n        srand(&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;);\n        &lt;span class=&quot;hljs-built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;%d\\n&quot;&lt;/span&gt;, rand());\n    }\n}\n&lt;/code&gt;&lt;/pre&gt;\n    ","\n&lt;ol&gt;\n&lt;li&gt;&lt;p&gt;It seems that every time &lt;code&gt;rand()&lt;/code&gt; runs, it will set a new seed for the next &lt;code&gt;rand()&lt;/code&gt;.&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;p&gt;If &lt;code&gt;srand()&lt;/code&gt; runs multiple times, the problem is if the two running happen in one second (the &lt;code&gt;time(NULL)&lt;/code&gt; does not change), the next &lt;code&gt;rand()&lt;/code&gt; will be the same as the &lt;code&gt;rand()&lt;/code&gt; right after the previous &lt;code&gt;srand()&lt;/code&gt;.&lt;/p&gt;\n&lt;/li&gt;\n&lt;/ol&gt;\n    "]},"randomTags":[{"name":"full-outer-join","slug":"full-outer-join"},{"name":"performance","slug":"performance"},{"name":"filtering","slug":"filtering"},{"name":"concatenation","slug":"concatenation"},{"name":"theory","slug":"theory"},{"name":"variable-length-array","slug":"variable-length-array"},{"name":"repr","slug":"repr"},{"name":"return-value","slug":"return-value"},{"name":"git-rm","slug":"git-rm"},{"name":"aspect-ratio","slug":"aspect-ratio"},{"name":"listener","slug":"listener"},{"name":"server-side","slug":"server-side"},{"name":"event-propagation","slug":"event-propagation"},{"name":"access-modifiers","slug":"access-modifiers"},{"name":"python-module","slug":"python-module"},{"name":"windows","slug":"windows"},{"name":"tabs","slug":"tabs"},{"name":"tapply","slug":"tapply"},{"name":"nested-lists","slug":"nested-lists"},{"name":"android-intent","slug":"android-intent"}]},"__N_SSG":true}