{"pageProps":{"data":{"count":1,"rows":[{"id":308,"title":"I just assigned a variable, but echo $variable shows something else","slug":"i-just-assigned-a-variable-but-echo-dollarvariable-shows-something-else-1657387574561","postType":"QUESTION","createdAt":"2022-07-09T17:26:14.000Z","updatedAt":"2022-07-09T17:26:14.000Z","tags":[{"id":1828,"name":"sh","slug":"sh","createdAt":"2022-07-09T17:26:14.000Z","updatedAt":"2022-07-09T17:26:14.000Z","Questions_Tags":{"questionId":308,"tagId":1828}}]}]},"slug":"sh","page":1,"answers":{"308":["\n&lt;p&gt;In all of the cases above, the variable is correctly set, but not correctly read! The right way is to &lt;strong&gt;use double quotes &lt;em&gt;when referencing&lt;/em&gt;&lt;/strong&gt;:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-bash s-code-block&quot;&gt;&lt;code class=&quot;hljs language-bash&quot;&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;&lt;span class=&quot;hljs-variable&quot;&gt;$var&lt;/span&gt;&quot;&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;This gives the expected value in all the examples given. Always quote variable references!&lt;/p&gt;\n\n&lt;hr&gt;\n\n&lt;p&gt;Why? &lt;/p&gt;\n\n&lt;p&gt;When a variable is &lt;strong&gt;unquoted&lt;/strong&gt;, it will:&lt;/p&gt;\n\n&lt;ol&gt;\n&lt;li&gt;&lt;p&gt;Undergo &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/009695399/utilities/xcu_chap02.html#tag_02_06_05&quot;&gt;field splitting&lt;/a&gt; where the value is split into multiple words on whitespace (by default):&lt;/p&gt;\n\n&lt;p&gt;Before: &lt;code&gt;/* Foobar is free software */&lt;/code&gt;&lt;/p&gt;\n\n&lt;p&gt;After: &lt;code&gt;/*&lt;/code&gt;, &lt;code&gt;Foobar&lt;/code&gt;, &lt;code&gt;is&lt;/code&gt;, &lt;code&gt;free&lt;/code&gt;, &lt;code&gt;software&lt;/code&gt;, &lt;code&gt;*/&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;\n&lt;li&gt;&lt;p&gt;Each of these words will undergo &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/009695399/utilities/xcu_chap02.html#tag_02_06_06&quot;&gt;pathname expansion&lt;/a&gt;, where patterns are expanded into matching files:&lt;/p&gt;\n\n&lt;p&gt;Before: &lt;code&gt;/*&lt;/code&gt;&lt;/p&gt;\n\n&lt;p&gt;After: &lt;code&gt;/bin&lt;/code&gt;, &lt;code&gt;/boot&lt;/code&gt;, &lt;code&gt;/dev&lt;/code&gt;, &lt;code&gt;/etc&lt;/code&gt;, &lt;code&gt;/home&lt;/code&gt;, ...&lt;/p&gt;&lt;/li&gt;\n&lt;li&gt;&lt;p&gt;Finally, all the arguments are passed to echo, which writes them out &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/utilities/echo.html#tag_20_37_10&quot;&gt;separated by single spaces&lt;/a&gt;, giving&lt;/p&gt;\n\n&lt;pre class=&quot;lang-bash s-code-block&quot;&gt;&lt;code class=&quot;hljs language-bash&quot;&gt;/bin /boot /dev /etc /home Foobar is free software Desktop/ Downloads/\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;instead of the variable&apos;s value.&lt;/p&gt;&lt;/li&gt;\n&lt;/ol&gt;\n\n&lt;p&gt;When the variable is &lt;strong&gt;quoted&lt;/strong&gt; it will:&lt;/p&gt;\n\n&lt;ol&gt;\n&lt;li&gt;Be substituted for its value.&lt;/li&gt;\n&lt;li&gt;There is no step 2.&lt;/li&gt;\n&lt;/ol&gt;\n\n&lt;p&gt;This is why you should &lt;strong&gt;always quote all variable references&lt;/strong&gt;, unless you specifically require word splitting and pathname expansion. Tools like &lt;a href=&quot;http://www.shellcheck.net&quot;&gt;shellcheck&lt;/a&gt; are there to help, and will warn about missing quotes in all the cases above.&lt;/p&gt;\n    ","\n&lt;p&gt;You may want to know why this is happening. Together with &lt;a href=&quot;https://stackoverflow.com/a/29378567/1983854&quot;&gt;the great explanation by that other guy&lt;/a&gt;, find a reference of &lt;a href=&quot;https://unix.stackexchange.com/a/131767/40596&quot;&gt;Why does my shell script choke on whitespace or other special characters?&lt;/a&gt; written by &lt;a href=&quot;https://unix.stackexchange.com/users/885/gilles&quot;&gt;Gilles&lt;/a&gt; in &lt;a href=&quot;https://unix.stackexchange.com/&quot;&gt;Unix &amp;amp; Linux&lt;/a&gt;:&lt;/p&gt;\n\n&lt;blockquote&gt;\n  &lt;h2&gt;Why do I need to write &lt;code&gt;&quot;$foo&quot;&lt;/code&gt;? What happens without the quotes?&lt;/h2&gt;\n  \n  &lt;p&gt;&lt;code&gt;$foo&lt;/code&gt; does not mean take the value of the variable &lt;code&gt;foo&lt;/code&gt;. It means\n  something much more complex:&lt;/p&gt;\n  \n  &lt;ul&gt;\n  &lt;li&gt;First, take the value of the variable.  &lt;/li&gt;\n  &lt;li&gt;Field splitting: treat that value as a whitespace-separated list of fields, and build the resulting list. For example, if the variable\n  contains &lt;code&gt;foo *  bar &lt;/code&gt; then the result of this step is the 3-element\n  list &lt;code&gt;foo&lt;/code&gt;, &lt;code&gt;*&lt;/code&gt;, &lt;code&gt;bar&lt;/code&gt;.  &lt;/li&gt;\n  &lt;li&gt;Filename generation: treat each field as a glob, i.e. as a wildcard pattern, and replace it by the list of file names that match this\n  pattern. If the pattern doesn&apos;t match any files, it is left\n  unmodified. In our example, this results in the list containing &lt;code&gt;foo&lt;/code&gt;,\n  following by the list of files in the current directory, and finally\n  &lt;code&gt;bar&lt;/code&gt;. If the current directory is empty, the result is &lt;code&gt;foo&lt;/code&gt;, &lt;code&gt;*&lt;/code&gt;,\n  &lt;code&gt;bar&lt;/code&gt;.&lt;/li&gt;\n  &lt;/ul&gt;\n  \n  &lt;p&gt;Note that the result is a list of strings. There are two contexts in\n  shell syntax: list context and string context. Field splitting and\n  filename generation only happen in list context, but that&apos;s most of\n  the time. Double quotes delimit a string context: the whole\n  double-quoted string is a single string, not to be split. (Exception:\n  &lt;code&gt;&quot;$@&quot;&lt;/code&gt; to expand to the list of positional parameters, e.g. &lt;code&gt;&quot;$@&quot;&lt;/code&gt; is\n  equivalent to &lt;code&gt;&quot;$1&quot; &quot;$2&quot; &quot;$3&quot;&lt;/code&gt; if there are three positional\n  parameters. See &lt;a href=&quot;https://unix.stackexchange.com/questions/41571/what-is-the-difference-between-and/94200#94200&quot;&gt;What is the difference between $* and $@?&lt;/a&gt;)&lt;/p&gt;\n  \n  &lt;p&gt;The same happens to command substitution with &lt;code&gt;$(foo)&lt;/code&gt; or with &lt;code&gt;\n  `foo`&lt;/code&gt;. On a side note, don&apos;t use &lt;code&gt;`foo`&lt;/code&gt;: its quoting rules are\n  weird and non-portable, and all modern shells support &lt;code&gt;$(foo)&lt;/code&gt; which\n  is absolutely equivalent except for having intuitive quoting rules.&lt;/p&gt;\n  \n  &lt;p&gt;The output of arithmetic substitution also undergoes the same\n  expansions, but that isn&apos;t normally a concern as it only contains\n  non-expandable characters (assuming &lt;code&gt;IFS&lt;/code&gt; doesn&apos;t contain digits or\n  &lt;code&gt;-&lt;/code&gt;).&lt;/p&gt;\n  \n  &lt;p&gt;See &lt;a href=&quot;https://unix.stackexchange.com/questions/68694/when-is-double-quoting-necessary&quot;&gt;When is double-quoting necessary?&lt;/a&gt; for more details about the\n  cases when you can leave out the quotes.&lt;/p&gt;\n  \n  &lt;p&gt;Unless you mean for all this rigmarole to happen, just remember to\n  always use double quotes around variable and command substitutions. Do\n  take care: leaving out the quotes can lead not just to errors but to\n  &lt;a href=&quot;https://unix.stackexchange.com/questions/171346/security-implications-of-forgetting-to-quote-a-variable-in-bash-posix-shells/171347#171347&quot;&gt;security\n  holes&lt;/a&gt;.&lt;/p&gt;\n&lt;/blockquote&gt;\n    ","\n&lt;p&gt;In addition to other issues caused by failing to quote, &lt;code&gt;-n&lt;/code&gt; and &lt;code&gt;-e&lt;/code&gt; can be consumed by &lt;code&gt;echo&lt;/code&gt; as arguments. (Only the former is legal per the POSIX spec for &lt;code&gt;echo&lt;/code&gt;, but several common implementations violate the spec and consume &lt;code&gt;-e&lt;/code&gt; as well).&lt;/p&gt;\n&lt;p&gt;To avoid this, &lt;strong&gt;use &lt;code&gt;printf&lt;/code&gt; instead of &lt;code&gt;echo&lt;/code&gt; when details matter.&lt;/strong&gt;&lt;/p&gt;\n&lt;p&gt;Thus:&lt;/p&gt;\n&lt;pre class=&quot;lang-bash s-code-block&quot;&gt;&lt;code class=&quot;hljs language-bash&quot;&gt;$ vars=&lt;span class=&quot;hljs-string&quot;&gt;&quot;-e -n -a&quot;&lt;/span&gt;\n$ &lt;span class=&quot;hljs-built_in&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;hljs-variable&quot;&gt;$vars&lt;/span&gt;      &lt;span class=&quot;hljs-comment&quot;&gt;# breaks because -e and -n can be treated as arguments to echo&lt;/span&gt;\n-a\n$ &lt;span class=&quot;hljs-built_in&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;&lt;span class=&quot;hljs-variable&quot;&gt;$vars&lt;/span&gt;&quot;&lt;/span&gt;\n-e -n -a\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;However, correct quoting won&apos;t always save you when using &lt;code&gt;echo&lt;/code&gt;:&lt;/p&gt;\n&lt;pre class=&quot;lang-bash s-code-block&quot;&gt;&lt;code class=&quot;hljs language-bash&quot;&gt;$ vars=&lt;span class=&quot;hljs-string&quot;&gt;&quot;-n&quot;&lt;/span&gt;\n$ &lt;span class=&quot;hljs-built_in&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;&lt;span class=&quot;hljs-variable&quot;&gt;$vars&lt;/span&gt;&quot;&lt;/span&gt;\n$ &lt;span class=&quot;hljs-comment&quot;&gt;## not even an empty line was printed&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;...whereas it &lt;strong&gt;will&lt;/strong&gt; save you with &lt;code&gt;printf&lt;/code&gt;:&lt;/p&gt;\n&lt;pre class=&quot;lang-bash s-code-block&quot;&gt;&lt;code class=&quot;hljs language-bash&quot;&gt;$ vars=&lt;span class=&quot;hljs-string&quot;&gt;&quot;-n&quot;&lt;/span&gt;\n$ &lt;span class=&quot;hljs-built_in&quot;&gt;printf&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&apos;%s\\n&apos;&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;&lt;span class=&quot;hljs-variable&quot;&gt;$vars&lt;/span&gt;&quot;&lt;/span&gt;\n-n\n&lt;/code&gt;&lt;/pre&gt;\n    ","\n&lt;p&gt;user double quote to get the exact value. like this:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-bash s-code-block&quot;&gt;&lt;code class=&quot;hljs language-bash&quot;&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;&lt;span class=&quot;hljs-variable&quot;&gt;${var}&lt;/span&gt;&quot;&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;and it will read your value correctly.&lt;/p&gt;\n    ","\n&lt;p&gt;&lt;code&gt;echo $var&lt;/code&gt; output highly depends on the value of &lt;code&gt;IFS&lt;/code&gt; variable. By default it contains space, tab, and newline characters:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-bash s-code-block&quot;&gt;&lt;code class=&quot;hljs language-bash&quot;&gt;[ks@localhost ~]$ &lt;span class=&quot;hljs-built_in&quot;&gt;echo&lt;/span&gt; -n &lt;span class=&quot;hljs-string&quot;&gt;&quot;&lt;span class=&quot;hljs-variable&quot;&gt;$IFS&lt;/span&gt;&quot;&lt;/span&gt; | &lt;span class=&quot;hljs-built_in&quot;&gt;cat&lt;/span&gt; -vte\n ^I$\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;This means that when shell is doing field splitting (or word splitting) it uses all these characters as word separators. This is what happens when referencing a variable without double quotes to echo it (&lt;code&gt;$var&lt;/code&gt;) and thus expected output is altered.&lt;/p&gt;\n\n&lt;p&gt;One way to prevent word splitting (besides using double quotes) is to set &lt;code&gt;IFS&lt;/code&gt; to null. See &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/009695399/utilities/xcu_chap02.html#tag_02_06_05&quot; rel=&quot;nofollow&quot;&gt;http://pubs.opengroup.org/onlinepubs/009695399/utilities/xcu_chap02.html#tag_02_06_05&lt;/a&gt; :&lt;/p&gt;\n\n&lt;blockquote&gt;\n  &lt;p&gt;If the value of IFS is null, no field splitting shall be performed.&lt;/p&gt;\n&lt;/blockquote&gt;\n\n&lt;p&gt;Setting to null means setting to empty \nvalue:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-bash s-code-block&quot;&gt;&lt;code class=&quot;hljs language-bash&quot;&gt;IFS=\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;hr&gt;\n\n&lt;p&gt;Test:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-bash s-code-block&quot;&gt;&lt;code class=&quot;hljs language-bash&quot;&gt;[ks@localhost ~]$ &lt;span class=&quot;hljs-built_in&quot;&gt;echo&lt;/span&gt; -n &lt;span class=&quot;hljs-string&quot;&gt;&quot;&lt;span class=&quot;hljs-variable&quot;&gt;$IFS&lt;/span&gt;&quot;&lt;/span&gt; | &lt;span class=&quot;hljs-built_in&quot;&gt;cat&lt;/span&gt; -vte\n ^I$\n[ks@localhost ~]$ var=$&lt;span class=&quot;hljs-string&quot;&gt;&apos;key\\nvalue&apos;&lt;/span&gt;\n[ks@localhost ~]$ &lt;span class=&quot;hljs-built_in&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;hljs-variable&quot;&gt;$var&lt;/span&gt;\nkey value\n[ks@localhost ~]$ IFS=\n[ks@localhost ~]$ &lt;span class=&quot;hljs-built_in&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;hljs-variable&quot;&gt;$var&lt;/span&gt;\nkey\nvalue\n[ks@localhost ~]$ \n&lt;/code&gt;&lt;/pre&gt;\n    ","\n&lt;p&gt;The &lt;a href=&quot;https://stackoverflow.com/questions/29378566/i-just-assigned-a-variable-but-echo-variable-shows-something-else/33719549#33719549&quot;&gt;answer from ks1322&lt;/a&gt; helped me to identify the issue while using &lt;code&gt;docker-compose exec&lt;/code&gt;:&lt;/p&gt;\n\n&lt;p&gt;If you omit the &lt;code&gt;-T&lt;/code&gt; flag, &lt;code&gt;docker-compose exec&lt;/code&gt; add a special character that break output, we see &lt;code&gt;b&lt;/code&gt; instead of &lt;code&gt;1b&lt;/code&gt;:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-bash s-code-block&quot;&gt;&lt;code class=&quot;hljs language-bash&quot;&gt;$ &lt;span class=&quot;hljs-built_in&quot;&gt;test&lt;/span&gt;=$(/usr/local/bin/docker-compose &lt;span class=&quot;hljs-built_in&quot;&gt;exec&lt;/span&gt; db bash -c &lt;span class=&quot;hljs-string&quot;&gt;&quot;echo 1&quot;&lt;/span&gt;)\n$ &lt;span class=&quot;hljs-built_in&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;&lt;span class=&quot;hljs-variable&quot;&gt;${test}&lt;/span&gt;b&quot;&lt;/span&gt;\nb\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;pre class=&quot;lang-bash s-code-block&quot;&gt;&lt;code class=&quot;hljs language-bash&quot;&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;&lt;span class=&quot;hljs-variable&quot;&gt;${test}&lt;/span&gt;&quot;&lt;/span&gt; | &lt;span class=&quot;hljs-built_in&quot;&gt;cat&lt;/span&gt; -vte\n1^M$\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;With &lt;code&gt;-T&lt;/code&gt; flag, &lt;code&gt;docker-compose exec&lt;/code&gt; works as expected:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-bash s-code-block&quot;&gt;&lt;code class=&quot;hljs language-bash&quot;&gt;$ &lt;span class=&quot;hljs-built_in&quot;&gt;test&lt;/span&gt;=$(/usr/local/bin/docker-compose &lt;span class=&quot;hljs-built_in&quot;&gt;exec&lt;/span&gt; -T db bash -c &lt;span class=&quot;hljs-string&quot;&gt;&quot;echo 1&quot;&lt;/span&gt;)\n$ &lt;span class=&quot;hljs-built_in&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;&lt;span class=&quot;hljs-variable&quot;&gt;${test}&lt;/span&gt;b&quot;&lt;/span&gt;\n1b\n&lt;/code&gt;&lt;/pre&gt;\n    ","\n&lt;p&gt;Additional to putting the variable in quotation, one could also translate the output of the variable using &lt;code&gt;tr&lt;/code&gt; and converting spaces to newlines.&lt;/p&gt;\n\n&lt;pre class=&quot;lang-bash s-code-block&quot;&gt;&lt;code class=&quot;hljs language-bash&quot;&gt;$ &lt;span class=&quot;hljs-built_in&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;hljs-variable&quot;&gt;$var&lt;/span&gt; | &lt;span class=&quot;hljs-built_in&quot;&gt;tr&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&quot; &quot;&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;\\n&quot;&lt;/span&gt;\nfoo\nbar\nbaz\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Although this is a little more convoluted, it does add more diversity with the output as you can substitute any character as the separator between array variables.&lt;/p&gt;\n    "]},"randomTags":[{"name":"floating-point","slug":"floating-point"},{"name":"hover","slug":"hover"},{"name":"interop","slug":"interop"},{"name":"equality","slug":"equality"},{"name":"heap-memory","slug":"heap-memory"},{"name":"fflush","slug":"fflush"},{"name":"expected-condition","slug":"expected-condition"},{"name":"date-parsing","slug":"date-parsing"},{"name":"gprof","slug":"gprof"},{"name":"comparator","slug":"comparator"},{"name":"preg-replace","slug":"preg-replace"},{"name":"utf-8","slug":"utf-8"},{"name":"security","slug":"security"},{"name":"addeventlistener","slug":"addeventlistener"},{"name":"date-formatting","slug":"date-formatting"},{"name":"circular-dependency","slug":"circular-dependency"},{"name":"gcc","slug":"gcc"},{"name":"arrayindexoutofboundsexception","slug":"arrayindexoutofboundsexception"},{"name":"html","slug":"html"},{"name":"z-index","slug":"z-index"}]},"__N_SSG":true}