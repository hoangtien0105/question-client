{"pageProps":{"data":{"count":1,"rows":[{"id":592,"title":"Why are mutable structs “evil”?","slug":"why-are-mutable-structs-\"evil\"-1657388508974","postType":"QUESTION","createdAt":"2022-07-09T17:41:48.000Z","updatedAt":"2022-07-09T17:41:48.000Z","tags":[{"id":2815,"name":"struct","slug":"struct","createdAt":"2022-07-09T17:41:49.000Z","updatedAt":"2022-07-09T17:41:49.000Z","Questions_Tags":{"questionId":592,"tagId":2815}}]}]},"slug":"struct","page":1,"answers":{"592":["\n&lt;p&gt;Structs are value types which means they are copied when they are passed around. &lt;/p&gt;\n\n&lt;p&gt;So if you change a copy you are changing only that copy, not the original and not any other copies which might be around.&lt;/p&gt;\n\n&lt;p&gt;If your struct is immutable then all automatic copies resulting from being passed by value will be the same.&lt;/p&gt;\n\n&lt;p&gt;If you want to change it you have to consciously do it by creating a new instance of the struct with the modified data. (not a copy)&lt;/p&gt;\n    ","\n&lt;p&gt;Where to start ;-p&lt;/p&gt;\n\n&lt;p&gt;&lt;a href=&quot;https://docs.microsoft.com/en-us/archive/blogs/ericlippert/mutating-readonly-structs&quot; rel=&quot;noreferrer&quot;&gt;Eric Lippert&apos;s blog&lt;/a&gt; is always good for a quote:&lt;/p&gt;\n\n&lt;blockquote&gt;\n  &lt;p&gt;This is yet another reason why mutable\n  value types are evil. Try to always\n  make value types immutable.&lt;/p&gt;\n&lt;/blockquote&gt;\n\n&lt;p&gt;First, you tend to lose changes quite easily... for example, getting things out of a list:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cs s-code-block&quot;&gt;&lt;code class=&quot;hljs language-csharp&quot;&gt;Foo foo = list[&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;];\nfoo.Name = &lt;span class=&quot;hljs-string&quot;&gt;&quot;abc&quot;&lt;/span&gt;;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;what did that change? Nothing useful...&lt;/p&gt;\n\n&lt;p&gt;The same with properties:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cs s-code-block&quot;&gt;&lt;code class=&quot;hljs language-csharp&quot;&gt;myObj.SomeProperty.Size = &lt;span class=&quot;hljs-number&quot;&gt;22&lt;/span&gt;; &lt;span class=&quot;hljs-comment&quot;&gt;// the compiler spots this one&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;forcing you to do:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cs s-code-block&quot;&gt;&lt;code class=&quot;hljs language-csharp&quot;&gt;Bar bar = myObj.SomeProperty;\nbar.Size = &lt;span class=&quot;hljs-number&quot;&gt;22&lt;/span&gt;;\nmyObj.SomeProperty = bar;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;less critically, there is a size issue; mutable objects &lt;strong&gt;tend&lt;/strong&gt; to have multiple properties; yet if you have a struct with two &lt;code&gt;int&lt;/code&gt;s, a &lt;code&gt;string&lt;/code&gt;, a &lt;code&gt;DateTime&lt;/code&gt; and a &lt;code&gt;bool&lt;/code&gt;, you can very quickly burn through a lot of memory. With a class, multiple callers can share a reference to the same instance (references are small).&lt;/p&gt;\n    ","\n&lt;p&gt;I wouldn&apos;t say &lt;em&gt;evil&lt;/em&gt; but mutability is often a sign of overeagerness on the part of the programmer to provide a maximum of functionality. In reality, this is often not needed and that, in turn, makes the interface smaller, easier to use and harder to use wrong (= more robust).&lt;/p&gt;\n\n&lt;p&gt;One example of this is read/write and write/write conflicts in race conditions. These simply can&apos;t occur in immutable structures, since a write is not a valid operation.&lt;/p&gt;\n\n&lt;p&gt;&lt;a href=&quot;https://stackoverflow.com/questions/406760/whats-your-most-controversial-programming-opinion/407007#407007&quot;&gt;Also, I claim that &lt;strong&gt;mutability is almost never actually needed&lt;/strong&gt;&lt;/a&gt;, the programmer just &lt;em&gt;thinks&lt;/em&gt; that it &lt;em&gt;might&lt;/em&gt; be in the future. For example, it simply doesn&apos;t make sense to change a date. Rather, create a new date based off the old one. This is a cheap operation, so performance is not a consideration.&lt;/p&gt;\n    ","\n&lt;p&gt;Mutable structs are not evil. &lt;/p&gt;\n\n&lt;p&gt;They are absolutely necessary in high performance circumstances. For example when cache lines and or garbage collection become a bottleneck.&lt;/p&gt;\n\n&lt;p&gt;I would not call the use of a immutable struct in these perfectly valid use-cases &quot;evil&quot;.&lt;/p&gt;\n\n&lt;p&gt;I can see the point that C#&apos;s syntax does not help to distinguish the access of a member of a value type or of a reference type, so I am all for &lt;em&gt;preferring&lt;/em&gt; immutable structs, that enforce immutability, over mutable structs.&lt;/p&gt;\n\n&lt;p&gt;However, instead of simply labelling immutable structs as &quot;evil&quot;, I would advise to embrace the language and advocate more helpful and constructive rule of thumbs.&lt;/p&gt;\n\n&lt;p&gt;For example: &lt;em&gt;&quot;structs are value types, which are copied by default. you need a reference if you don&apos;t want to copy them&quot;&lt;/em&gt; or\n&lt;em&gt;&quot;try to work with readonly structs first&quot;&lt;/em&gt;.&lt;/p&gt;\n    ","\n&lt;p&gt;&lt;b&gt;Structs with public mutable fields or properties are not evil.&lt;/b&gt;&lt;/p&gt;\n\n&lt;p&gt;Struct methods (as distinct from property setters) which mutate &quot;this&quot; are somewhat evil, only because .net doesn&apos;t provide a means of distinguishing them from methods which do not.  Struct methods that do not mutate &quot;this&quot; should be invokable even on read-only structs without any need for defensive copying.  Methods which do mutate &quot;this&quot; should not be invokable at all on read-only structs.  Since .net doesn&apos;t want to forbid struct methods that don&apos;t modify &quot;this&quot; from being invoked on read-only structs, but doesn&apos;t want to allow read-only structs to be mutated, it defensively copies structs in read-only contexts, arguably getting the worst of both worlds.&lt;/p&gt;\n\n&lt;p&gt;Despite the problems with the handling of self-mutating methods in read-only contexts, however, mutable structs often offer semantics far superior to mutable class types.  Consider the following three method signatures:&lt;/p&gt;\n\n&lt;pre&gt;struct PointyStruct {public int x,y,z;};\nclass PointyClass {public int x,y,z;};\n\nvoid Method1(PointyStruct foo);\nvoid Method2(ref PointyStruct foo);\nvoid Method3(PointyClass foo);\n&lt;/pre&gt;\n\n&lt;p&gt;For each method, answer the following questions:&lt;/p&gt;\n\n&lt;ol&gt;&lt;li&gt;Assuming the method doesn&apos;t use any &quot;unsafe&quot; code, might it modify foo?\n&lt;/li&gt;&lt;li&gt;If no outside references to &apos;foo&apos; exist before the method is called, could an outside reference exist after?\n&lt;/li&gt;&lt;/ol&gt;\n\n&lt;p&gt;&lt;sub&gt;Answers:&lt;/sub&gt;&lt;/p&gt;\n\n&lt;blockquote class=&quot;spoiler&quot; data-spoiler=&quot;Reveal spoiler&quot;&gt;\n  &lt;p&gt; Question 1:&lt;br&gt;\n  &lt;code&gt;Method1()&lt;/code&gt;: no &lt;em&gt;(clear intent)&lt;/em&gt;&lt;br&gt;\n  &lt;code&gt;Method2()&lt;/code&gt;: yes &lt;em&gt;(clear intent)&lt;/em&gt;&lt;br&gt;\n  &lt;code&gt;Method3()&lt;/code&gt;: yes &lt;em&gt;(uncertain intent)&lt;/em&gt;&lt;br&gt;\n Question 2:&lt;br&gt;\n  &lt;code&gt;Method1()&lt;/code&gt;: no&lt;br&gt;\n  &lt;code&gt;Method2()&lt;/code&gt;: no &lt;em&gt;(unless unsafe)&lt;/em&gt;&lt;br&gt;\n  &lt;code&gt;Method3()&lt;/code&gt;: yes&lt;/p&gt;\n&lt;/blockquote&gt;\n\n&lt;p&gt;Method1 can&apos;t modify foo, and never gets a reference.  Method2 gets a short-lived reference to foo, which it can use modify the fields of foo any number of times, in any order, until it returns, but it can&apos;t persist that reference.  Before Method2 returns, unless it uses unsafe code, any and all copies that might have been made of its &apos;foo&apos; reference will have disappeared.  Method3, unlike Method2, gets a promiscuously-sharable reference to foo, and there&apos;s no telling what it might do with it.  It might not change foo at all, it might change foo and then return, or it might give a reference to foo to another thread which might mutate it in some arbitrary way at some arbitrary future time.  The only way to limit what Method3 might do to a mutable class object passed into it would be to encapsulate the mutable object into a read-only wrapper, which is ugly and cumbersome.&lt;/p&gt;\n\n&lt;p&gt;Arrays of structures offer wonderful semantics.  Given RectArray[500] of type Rectangle, it&apos;s clear and obvious how to e.g. copy element 123 to element 456 and then some time later set the width of element 123 to 555, without disturbing element 456.  &quot;RectArray[432] = RectArray[321]; ...; RectArray[123].Width = 555;&quot;.  Knowing that Rectangle is a struct with an integer field called Width will tell one all one needs to know about the above statements.&lt;/p&gt;\n\n&lt;p&gt;Now suppose RectClass was a class with the same fields as Rectangle and one wanted to do the same operations on a RectClassArray[500] of type RectClass.  Perhaps the array is supposed to hold 500 pre-initialized immutable references to mutable RectClass objects.  in that case, the proper code would be something like &quot;RectClassArray[321].SetBounds(RectClassArray[456]); ...; RectClassArray[321].X = 555;&quot;.  Perhaps the array is assumed to hold instances that aren&apos;t going to change, so the proper code would be more like &quot;RectClassArray[321] = RectClassArray[456]; ...; RectClassArray[321] = New RectClass(RectClassArray[321]); RectClassArray[321].X = 555;&quot;  To know what one is supposed to do, one would have to know a lot more both about RectClass (e.g. does it support a copy constructor, a copy-from method, etc.) and the intended usage of the array.  Nowhere near as clean as using a struct.&lt;/p&gt;\n\n&lt;p&gt;To be sure, there is unfortunately no nice way for any container class other than an array to offer the clean semantics of a struct array.  The best one could do, if one wanted a collection to be indexed with e.g. a string, would probably be to offer a generic &quot;ActOnItem&quot; method which would accept a string for the index, a generic parameter, and a delegate which would be passed by reference both the generic parameter and the collection item.  That would allow nearly the same semantics as struct arrays, but unless the vb.net and C# people can be pursuaded to offer a nice syntax, the code is going to be clunky-looking even if it is reasonably performance (passing a generic parameter would allow for use of a static delegate and would avoid any need to create any temporary class instances).&lt;/p&gt;\n\n&lt;p&gt;Personally, I&apos;m peeved at the hatred Eric Lippert et al. spew regarding mutable value types.  They offer much cleaner semantics than the promiscuous reference types that are used all over the place.  Despite some of the limitations with .net&apos;s support for value types, there are many cases where mutable value types are a better fit than any other kind of entity.&lt;/p&gt;\n    ","\n&lt;p&gt;There are a couple other corner cases that could lead to unpredictable behavior from the programmer&apos;s point of view.&lt;/p&gt;\n\n&lt;h1&gt;Immutable value types and readonly fields&lt;/h1&gt;\n\n&lt;pre class=&quot;lang-cs s-code-block&quot;&gt;&lt;code class=&quot;hljs language-csharp&quot;&gt;    &lt;span class=&quot;hljs-comment&quot;&gt;// Simple mutable structure. &lt;/span&gt;\n    &lt;span class=&quot;hljs-comment&quot;&gt;// Method IncrementI mutates current state.&lt;/span&gt;\n    &lt;span class=&quot;hljs-keyword&quot;&gt;struct&lt;/span&gt; Mutable\n    {\n        &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;Mutable&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;int&lt;/span&gt; i&lt;/span&gt;) : &lt;span class=&quot;hljs-title&quot;&gt;this&lt;/span&gt;()&lt;/span&gt; \n        {\n            I = i;\n        }\n\n        &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;IncrementI&lt;/span&gt;()&lt;/span&gt; { I++; }\n\n        &lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-built_in&quot;&gt;int&lt;/span&gt; I { &lt;span class=&quot;hljs-keyword&quot;&gt;get&lt;/span&gt;; &lt;span class=&quot;hljs-keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;set&lt;/span&gt;; }\n    }\n\n    &lt;span class=&quot;hljs-comment&quot;&gt;// Simple class that contains Mutable structure&lt;/span&gt;\n    &lt;span class=&quot;hljs-comment&quot;&gt;// as readonly field&lt;/span&gt;\n    &lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;SomeClass&lt;/span&gt; \n    {\n        &lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;readonly&lt;/span&gt; Mutable mutable = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; Mutable(&lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt;);\n    }\n\n    &lt;span class=&quot;hljs-comment&quot;&gt;// Simple class that contains Mutable structure&lt;/span&gt;\n    &lt;span class=&quot;hljs-comment&quot;&gt;// as ordinary (non-readonly) field&lt;/span&gt;\n    &lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;AnotherClass&lt;/span&gt; \n    {\n        &lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; Mutable mutable = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; Mutable(&lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt;);\n    }\n\n    &lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;Program&lt;/span&gt;\n    {\n        &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;Main&lt;/span&gt;()&lt;/span&gt;\n        {\n            &lt;span class=&quot;hljs-comment&quot;&gt;// Case 1. Mutable readonly field&lt;/span&gt;\n            &lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; someClass = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; SomeClass();\n            someClass.mutable.IncrementI();\n            &lt;span class=&quot;hljs-comment&quot;&gt;// still 5, not 6, because SomeClass.mutable field is readonly&lt;/span&gt;\n            &lt;span class=&quot;hljs-comment&quot;&gt;// and compiler creates temporary copy every time when you trying to&lt;/span&gt;\n            &lt;span class=&quot;hljs-comment&quot;&gt;// access this field&lt;/span&gt;\n            Console.WriteLine(someClass.mutable.I);\n\n            &lt;span class=&quot;hljs-comment&quot;&gt;// Case 2. Mutable ordinary field&lt;/span&gt;\n            &lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; anotherClass = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; AnotherClass();\n            anotherClass.mutable.IncrementI();\n\n            &lt;span class=&quot;hljs-comment&quot;&gt;// Prints 6, because AnotherClass.mutable field is not readonly&lt;/span&gt;\n            Console.WriteLine(anotherClass.mutable.I);\n        }\n    }\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;h1&gt;Mutable value types and array&lt;/h1&gt;\n\n&lt;p&gt;Suppose we have an array of our &lt;code&gt;Mutable&lt;/code&gt; struct and we&apos;re calling the &lt;code&gt;IncrementI&lt;/code&gt; method for the first element of that array. What behavior are you expecting from this call? Should it change the array&apos;s value or only a copy?&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cs s-code-block&quot;&gt;&lt;code class=&quot;hljs language-csharp&quot;&gt;    Mutable[] arrayOfMutables = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; Mutable[&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;];\n    arrayOfMutables[&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;] = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; Mutable(&lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt;);\n\n    &lt;span class=&quot;hljs-comment&quot;&gt;// Now we actually accessing reference to the first element&lt;/span&gt;\n    &lt;span class=&quot;hljs-comment&quot;&gt;// without making any additional copy&lt;/span&gt;\n    arrayOfMutables[&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;].IncrementI();\n\n    &lt;span class=&quot;hljs-comment&quot;&gt;// Prints 6!!&lt;/span&gt;\n    Console.WriteLine(arrayOfMutables[&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;].I);\n\n    &lt;span class=&quot;hljs-comment&quot;&gt;// Every array implements IList&amp;lt;T&amp;gt; interface&lt;/span&gt;\n    IList&amp;lt;Mutable&amp;gt; listOfMutables = arrayOfMutables;\n\n    &lt;span class=&quot;hljs-comment&quot;&gt;// But accessing values through this interface lead&lt;/span&gt;\n    &lt;span class=&quot;hljs-comment&quot;&gt;// to different behavior: IList indexer returns a copy&lt;/span&gt;\n    &lt;span class=&quot;hljs-comment&quot;&gt;// instead of an managed reference&lt;/span&gt;\n    listOfMutables[&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;].IncrementI(); &lt;span class=&quot;hljs-comment&quot;&gt;// Should change I to 7&lt;/span&gt;\n\n    &lt;span class=&quot;hljs-comment&quot;&gt;// Nope! we still have 6, because previous line of code&lt;/span&gt;\n    &lt;span class=&quot;hljs-comment&quot;&gt;// mutate a copy instead of a list value&lt;/span&gt;\n    Console.WriteLine(listOfMutables[&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;].I);\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;So, mutable structs are not evil as long as you and the rest of the team clearly understand what you are doing. But there are too many corner cases when the program behavior would be different from what&apos;s expected, that could lead to subtle hard to produce and hard to understand errors.&lt;/p&gt;\n    ","\n&lt;p&gt;Value types basically represents immutable concepts. Fx, it makes no sense to have a mathematical value such as an integer, vector etc. and then be able to modify it. That would be like redefining the meaning of a value. Instead of changing a value type, it makes more sense to assign another unique value. Think about the fact that value types are compared by comparing all the values of its properties. The point is that if the properties are the same then it is the same universal representation of that value.&lt;/p&gt;\n\n&lt;p&gt;As Konrad mentions it doesn&apos;t make sense to change a date either, as the value represents that unique point in time and not an instance of a time object which has any state or context-dependency.&lt;/p&gt;\n\n&lt;p&gt;Hopes this makes any sense to you. It is more about the concept you try to capture with value types than practical details, to be sure. &lt;/p&gt;\n    ","\n&lt;p&gt;If you have ever programmed in a language like C/C++, structs are fine to use as mutable. Just pass them with ref, around and there is nothing that can go wrong. The only problem I find are the restrictions of the C# compiler and that, in some cases, I am unable to force the stupid thing to use a reference to the struct, instead of a Copy(like when a struct is part of a C# class).&lt;/p&gt;\n\n&lt;p&gt;So, mutable structs are not evil, C# has &lt;em&gt;made&lt;/em&gt; them evil. I use mutable structs in C++ all the time and they are very convenient and intuitive. In contrast, C# has made me to completely abandon structs as members of classes because of the way they handle objects. Their convenience has cost us ours.&lt;/p&gt;\n    ","\n&lt;p&gt;If you stick to what structs are intended for (in C#, Visual Basic 6, Pascal/Delphi, C++ struct type (or classes) when they are not used as pointers), you will find that a structure is not more than a &lt;em&gt;compound variable&lt;/em&gt;. This means: you will treat them as a packed set of variables, under a common name (a record variable you reference members from).&lt;/p&gt;\n\n&lt;p&gt;I know that would confuse a lot of people deeply used to OOP, but that&apos;s not enough reason to say such things are inherently evil, if used correctly. Some structures are inmutable as they intend (this is the case of Python&apos;s &lt;code&gt;namedtuple&lt;/code&gt;), but it is another paradigm to consider.&lt;/p&gt;\n\n&lt;p&gt;Yes: structs involve a lot of memory, but it will not be precisely more memory by doing:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cs s-code-block&quot;&gt;&lt;code class=&quot;hljs language-csharp&quot;&gt;point.x = point.x + &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;compared to:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cs s-code-block&quot;&gt;&lt;code class=&quot;hljs language-csharp&quot;&gt;point = Point(point.x + &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;, point.y)\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;The memory consumption will be at least the same, or even more in the inmutable case (although that case would be temporary, for the current stack, depending on the language).&lt;/p&gt;\n\n&lt;p&gt;But, finally, structures are &lt;em&gt;structures&lt;/em&gt;, not objects. In POO, the main property of an object is their &lt;em&gt;identity&lt;/em&gt;, which most of the times is not more than its memory address. Struct stands for data structure (not a proper object, and so they don&apos;t have identity anyhow), and data can be modified. In other languages, &lt;em&gt;record&lt;/em&gt; (instead of &lt;em&gt;struct&lt;/em&gt;, as is the case for Pascal) is the word and holds the same purpose: just a data record variable, intended to be read from files, modified, and dumped into files (that is the main use and, in many languages, you can even define data alignment in the record, while that&apos;s not necessarily the case for properly called Objects).&lt;/p&gt;\n\n&lt;p&gt;Want a good example? Structs are used to read files easily. Python has &lt;a href=&quot;https://docs.python.org/2/library/struct.html&quot;&gt;this library&lt;/a&gt; because, since it is object-oriented and has no support for structs, it had to implement it in another way, which is somewhat ugly. Languages implementing structs have that feature... built-in. Try reading a bitmap header with an appropriate struct in languages like Pascal or C. It will be easy (if the struct is properly built and aligned; in Pascal you would not use a record-based access but functions to read arbitrary binary data). So, for files and direct (local) memory access, structs are better than objects. As for today, we&apos;re used to JSON and XML, and so we forget the use of binary files (and as a side effect, the use of structs). But yes: they exist, and have a purpose.&lt;/p&gt;\n\n&lt;p&gt;They are not evil. Just use them for the right purpose.&lt;/p&gt;\n\n&lt;p&gt;If you think in terms of hammers, you will want to treat screws as nails, to find screws are harder to plunge in the wall, and it will be screws&apos; fault, and they will be the evil ones.&lt;/p&gt;\n    ","\n&lt;p&gt;Imagine you have an array of 1,000,000 structs. Each struct representing an equity with stuff like bid_price, offer_price (perhaps decimals) and so on, this is created by C#/VB.&lt;/p&gt;\n\n&lt;p&gt;Imagine that array is created in a block of memory allocated in the unmanaged heap so that some other native code thread is able to concurrently access the array (perhaps some high-perf code doing math).&lt;/p&gt;\n\n&lt;p&gt;Imagine the C#/VB code is listening to a market feed of price changes, that code may have to access some element of the array (for whichever security) and then modify some price field(s).&lt;/p&gt;\n\n&lt;p&gt;Imagine this is being done tens or even hundreds of thousands of times per second.&lt;/p&gt;\n\n&lt;p&gt;Well lets face facts, in this case we really do want these structs to be mutable, they need to be because they are being shared by some other native code so creating copies isn&apos;t gonna help; they need to be because making a copy of some 120 byte struct at these rates is lunacy, especially when an update may actually impact just a byte or two.&lt;/p&gt;\n\n&lt;p&gt;Hugo&lt;/p&gt;\n    ","\n&lt;p&gt;When something can be mutated, it gains a sense of identity.&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cs s-code-block&quot;&gt;&lt;code class=&quot;hljs language-csharp&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;struct&lt;/span&gt; Person {\n    &lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-built_in&quot;&gt;string&lt;/span&gt; name; &lt;span class=&quot;hljs-comment&quot;&gt;// mutable&lt;/span&gt;\n    &lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; Point position = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; Point(&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;); &lt;span class=&quot;hljs-comment&quot;&gt;// mutable&lt;/span&gt;\n\n    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;Person&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;string&lt;/span&gt; name, Point position&lt;/span&gt;)&lt;/span&gt; { ... }\n}\n\nPerson eric = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; Person(&lt;span class=&quot;hljs-string&quot;&gt;&quot;Eric Lippert&quot;&lt;/span&gt;, &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; Point(&lt;span class=&quot;hljs-number&quot;&gt;4&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;));\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Because &lt;code&gt;Person&lt;/code&gt; is mutable, it&apos;s more natural to think about &lt;em&gt;changing Eric&apos;s position&lt;/em&gt; than &lt;em&gt;cloning Eric, moving the clone, and destroying the original&lt;/em&gt;. Both operations would succeed in changing the contents of &lt;code&gt;eric.position&lt;/code&gt;, but one is more intuitive than the other. Likewise, it&apos;s more intuitive to pass Eric around (as a reference) for methods to modify him. Giving a method a clone of Eric is almost always going to be surprising. Anyone wanting to mutate &lt;code&gt;Person&lt;/code&gt; must remember to ask for a reference to &lt;code&gt;Person&lt;/code&gt; or they&apos;ll be doing the wrong thing.&lt;/p&gt;\n\n&lt;p&gt;If you make the type immutable, the problem goes away; if I can&apos;t modify &lt;code&gt;eric&lt;/code&gt;, it makes no difference to me whether I receive &lt;code&gt;eric&lt;/code&gt; or a clone of &lt;code&gt;eric&lt;/code&gt;. More generally, a type is safe to pass by value if all of its observable state is held in members that are either:&lt;/p&gt;\n\n&lt;ul&gt;\n&lt;li&gt;immutable&lt;/li&gt;\n&lt;li&gt;reference types&lt;/li&gt;\n&lt;li&gt;safe to pass by value&lt;/li&gt;\n&lt;/ul&gt;\n\n&lt;p&gt;If those conditions are met then a mutable value type behaves like a reference type because a shallow copy will still allow the receiver to modify the original data.&lt;/p&gt;\n\n&lt;p&gt;The intuitiveness of an immutable &lt;code&gt;Person&lt;/code&gt; depends on what you&apos;re trying to do though. If &lt;code&gt;Person&lt;/code&gt; just represents a &lt;em&gt;set of data&lt;/em&gt; about a person, there&apos;s nothing unintuitive about it; &lt;code&gt;Person&lt;/code&gt; variables truly represent abstract &lt;em&gt;values&lt;/em&gt;, not objects. (In that case, it&apos;d probably be more appropriate to rename it to &lt;code&gt;PersonData&lt;/code&gt;.) If &lt;code&gt;Person&lt;/code&gt; is actually modeling a person itself, the idea of constantly creating and moving clones is silly even if you&apos;ve avoided the pitfall of thinking you&apos;re modifying the original. In that case it&apos;d probably be more natural to simply make &lt;code&gt;Person&lt;/code&gt; a reference type (that is, a class.) &lt;/p&gt;\n\n&lt;p&gt;Granted, as functional programming has taught us there are benefits to making &lt;em&gt;everything&lt;/em&gt; immutable (no one can secretly hold on to a reference to &lt;code&gt;eric&lt;/code&gt; and mutate him), but since that&apos;s not idiomatic in OOP it&apos;s still going to be unintuitive to anyone else working with your code.&lt;/p&gt;\n    ","\n&lt;p&gt;It doesnt have anything to do with structs (and not with C#, either) but in Java you might get problems with mutable objects when they are e.g. keys in a hash map. If you change them after adding them to a map and it changes its &lt;a href=&quot;http://java.sun.com/j2se/1.5.0/docs/api/java/lang/Object.html#hashCode()&quot; rel=&quot;noreferrer&quot;&gt;hash code&lt;/a&gt;, evil things might happen.&lt;/p&gt;\n    ","\n&lt;p&gt;There are many advantages and disadvantages to mutable data.  The million-dollar disadvantage is aliasing.  If the same value is being used in multiple places, and one of them changes it, then it will appear to have magically changed to the other places that are using it.  This is related to, but not identical with, race conditions.&lt;/p&gt;\n\n&lt;p&gt;The million-dollar advantage is modularity, sometimes.  Mutable state can allow you to hide changing information from code that doesn&apos;t need to know about it.&lt;/p&gt;\n\n&lt;p&gt;&lt;a href=&quot;http://dspace.mit.edu/handle/1721.1/6094&quot; rel=&quot;noreferrer&quot;&gt;The Art of the Interpreter&lt;/a&gt; goes into these trade offs in some detail, and gives some examples.&lt;/p&gt;\n    ","\n&lt;p&gt;Personally when I look at code the following looks pretty clunky to me:&lt;/p&gt;\n\n&lt;p&gt;data.value.set ( data.value.get () + 1 ) ;&lt;/p&gt;\n\n&lt;p&gt;rather than simply&lt;/p&gt;\n\n&lt;p&gt;data.value++ ; or data.value = data.value + 1 ;&lt;/p&gt;\n\n&lt;p&gt;Data encapsulation is useful when passing a class around and you want to ensure the value is modified in a controlled fashion.  However when you have public set and get functions that do little more than set the value to what ever is passed in, how is this an improvement over simply passing a public data structure around?&lt;/p&gt;\n\n&lt;p&gt;When I create a private structure inside a class, I created that structure to organize a set of variables into one group.  I want to be able to modify that structure within the class scope, not get copies of that structure and create new instances.&lt;/p&gt;\n\n&lt;p&gt;To me this prevents a valid use of structures being used to organize public variables, if I wanted access control I&apos;d use a class.&lt;/p&gt;\n    ","\n&lt;p&gt;There are several issues with Mr. Eric Lippert&apos;s example. It is contrived to illustrate the point that structs are copied and how that could be a problem if you are not careful. Looking at the example I see it as a result of a bad programming habit and not really a problem with either struct or the class. &lt;/p&gt;\n\n&lt;ol&gt;\n&lt;li&gt;&lt;p&gt;A struct is supposed to have only public members and should not require any encapsulation. If it does then it really should be a type/class. You really do not need two constructs to say the same thing.&lt;/p&gt;&lt;/li&gt;\n&lt;li&gt;&lt;p&gt;If you have class enclosing a struct, you would call a method in the class to mutate the member struct. This is what I would do as a good programming habit.&lt;/p&gt;&lt;/li&gt;\n&lt;/ol&gt;\n\n&lt;p&gt;A proper implementation would be as follows.&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cs s-code-block&quot;&gt;&lt;code class=&quot;hljs language-csharp&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;struct&lt;/span&gt; Mutable {\n&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-built_in&quot;&gt;int&lt;/span&gt; x;\n}\n\n&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;Test&lt;/span&gt; {\n    &lt;span class=&quot;hljs-keyword&quot;&gt;private&lt;/span&gt; Mutable m = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; Mutable();\n    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-built_in&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;mutate&lt;/span&gt;()&lt;/span&gt;\n    { \n        m.x = m.x + &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;;\n        &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; m.x;\n    }\n  }\n  &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;Main&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;string&lt;/span&gt;[] args&lt;/span&gt;)&lt;/span&gt; {\n        Test t = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; Test();\n        System.Console.WriteLine(t.mutate());\n        System.Console.WriteLine(t.mutate());\n        System.Console.WriteLine(t.mutate());\n    }\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;It looks like it is an issue with programming habit as opposed to an issue with struct itself. Structs are supposed to be mutable, that is the idea and intent.&lt;/p&gt;\n\n&lt;p&gt;The result of the changes voila behaves as expected:&lt;/p&gt;\n\n&lt;p&gt;1\n2\n3\nPress any key to continue . . .&lt;/p&gt;\n    ","\n&lt;p&gt;I don&apos;t believe they&apos;re evil if used correctly. I wouldn&apos;t put it in my production code, but I would for something like structured unit testing mocks, where the lifespan of a struct is relatively small.&lt;/p&gt;\n\n&lt;p&gt;Using the Eric example, perhaps you want to create a second instance of that Eric, but make adjustments, as that&apos;s the nature of your test (ie duplication, then modifying). It doesn&apos;t matter what happens with the first instance of Eric if we&apos;re just using Eric2 for the remainder of the test script, unless you&apos;re planning on using him as a test comparison.&lt;/p&gt;\n\n&lt;p&gt;This would be mostly useful for testing or modifying legacy code that shallow defines a particular object (the point of structs), but by having an immutable struct, this prevents it&apos;s usage annoyingly.&lt;/p&gt;\n    "]},"randomTags":[{"name":"flatten","slug":"flatten"},{"name":"for-loop","slug":"for-loop"},{"name":"w3c","slug":"w3c"},{"name":"excel","slug":"excel"},{"name":"environment-variables","slug":"environment-variables"},{"name":"jsf-2","slug":"jsf-2"},{"name":"utf-8","slug":"utf-8"},{"name":"sql-delete","slug":"sql-delete"},{"name":"jstl","slug":"jstl"},{"name":"merge","slug":"merge"},{"name":"ssl-certificate","slug":"ssl-certificate"},{"name":"c++11","slug":"c++11"},{"name":"asp.net-mvc-4","slug":"asp.net-mvc-4"},{"name":"sqliteopenhelper","slug":"sqliteopenhelper"},{"name":"constructor","slug":"constructor"},{"name":"type-punning","slug":"type-punning"},{"name":"reserved-words","slug":"reserved-words"},{"name":"httpurlconnection","slug":"httpurlconnection"},{"name":"sql-server-2005","slug":"sql-server-2005"},{"name":"overflow","slug":"overflow"}]},"__N_SSG":true}