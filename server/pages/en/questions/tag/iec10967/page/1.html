<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><meta name="twitter:card" content="summary_large_image"/><meta name="twitter:site" content="@solutionschecker.com"/><meta name="twitter:creator" content="@solutionschecker.com"/><meta property="og:url" content="https://solutionschecker.com"/><meta property="og:type" content="website"/><meta property="og:image" content="https://solutionschecker.com/solutions-checker-banner.png"/><meta property="og:image:alt" content="Find the solution to any question. We focus on finding the fastest possible solution for users. Main topics like coding, learning. - solutionschecker.com"/><link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png"/><link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png"/><link rel="manifest" href="/site.webmanifest"/><script type="application/ld+json">{"@context":"https://schema.org","@type":"Organization","logo":"/logo.svg","url":"https://solutionschecker.com"}</script><script type="application/ld+json">{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"item":{"@id":"https://solutionschecker.com","name":"Home"}},{"@type":"ListItem","position":2,"item":{"@id":"https://solutionschecker.com/questions","name":"Questions"}},{"@type":"ListItem","position":3,"item":{"@id":"https://solutionschecker.com/questions/tag/iec10967","name":"Tag"}},{"@type":"ListItem","position":4,"item":{"@id":"https://solutionschecker.com/questions/tag/iec10967/page/1","name":"Page"}}]}</script><title>iec10967 tags | Solution Checker</title><meta name="robots" content="index,follow"/><meta name="description" content="All questions and solutions for iec10967 tags - page 1"/><meta property="og:title" content="iec10967 tags | Solution Checker"/><meta property="og:description" content="All questions and solutions for iec10967 tags - page 1"/><meta name="next-head-count" content="20"/><link rel="preload" href="/_next/static/css/4f7b2847abfe82c6.css" as="style"/><link rel="stylesheet" href="/_next/static/css/4f7b2847abfe82c6.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-0d1b80a048d4787e.js"></script><script src="/_next/static/chunks/webpack-42cdea76c8170223.js" defer=""></script><script src="/_next/static/chunks/framework-4556c45dd113b893.js" defer=""></script><script src="/_next/static/chunks/main-ccfab947c79712f4.js" defer=""></script><script src="/_next/static/chunks/pages/_app-c0d2dcb5e85faf18.js" defer=""></script><script src="/_next/static/chunks/29107295-fbcfe2172188e46f.js" defer=""></script><script src="/_next/static/chunks/294-106ef8570fa99deb.js" defer=""></script><script src="/_next/static/chunks/912-9618bcf05da7091d.js" defer=""></script><script src="/_next/static/chunks/596-971e6593fb286f13.js" defer=""></script><script src="/_next/static/chunks/pages/questions/tag/%5Bslug%5D/page/%5Bpage%5D-7fc07124d72d00c2.js" defer=""></script><script src="/_next/static/eGqQHYKGZKE-nXShFn8wX/_buildManifest.js" defer=""></script><script src="/_next/static/eGqQHYKGZKE-nXShFn8wX/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="wrapper"><header><nav class="bg-white border-gray-200 px-4 lg:px-6 py-2.5 dark:bg-gray-800"><div class="flex flex-wrap justify-between items-center mx-auto max-w-screen-xl"><a class="flex items-center" href="/"><img src="/logo-second.png" class="mr-3 h-6 sm:h-9" alt="Solution Checker Logo"/><h1 class="self-center text-xl font-semibold whitespace-nowrap dark:text-white">Solution Checker</h1></a><div class="flex items-center lg:order-2"><button data-collapse-toggle="mobile-menu-2" type="button" class="inline-flex items-center p-2 ml-1 text-sm text-gray-500 rounded-lg lg:hidden hover:bg-gray-100 focus:outline-none focus:ring-2 focus:ring-gray-200 dark:text-gray-400 dark:hover:bg-gray-700 dark:focus:ring-gray-600" aria-controls="mobile-menu-2" aria-expanded="false"><span class="sr-only">Open main menu</span><svg class="w-6 h-6" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M3 5a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM3 10a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM3 15a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1z" clip-rule="evenodd"></path></svg><svg class="hidden w-6 h-6" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z" clip-rule="evenodd"></path></svg></button></div><div class="hidden justify-between items-center w-full lg:flex lg:w-auto lg:order-1" id="mobile-menu-2"><ul class="flex flex-col mt-4 font-medium lg:flex-row lg:space-x-8 lg:mt-0"><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" aria-current="page" href="/">Home</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/questions?tab=news">Questions</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/post?tab=news">Post</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/questions/tag/iec10967/page/1#">Coding</a></li></ul></div></div></nav></header><div class="main-content"><div class="pagination-page-wrapper"><span class="pagination-buttons previous bg-stone-500 cursor-not-allowed  hover:bg-stone-500 text-white font-bold py-2 px-4 rounded">Previous</span></div><div class="question my-5"><div class="flex items-center justify-center"><div class="rounded-xl border p-5 shadow-md post-layout-inner bg-white"><div class="flex w-full items-center justify-between border-b pb-3"><div class="flex items-center space-x-3"><div class="text-lg font-bold text-slate-700"><a href="/questions/how-to-count-the-number-of-set-bits-in-a-32-bit-integer-1657388437370">How to count the number of set bits in a 32-bit integer?</a></div></div></div><div class="tags-wrap h-max space-x-8"><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/iec10967">iec10967</a></div></div></div><div><div class="flex items-center justify-between text-slate-500"><div class="flex space-x-4 md:space-x-8"><span class="btn bg-stone-500 cursor-pointer mt-5  hover:bg-stone-500 text-white font-bold py-2 px-4 rounded">Show Solution</span></div></div></div></div></div></div><div class="pagination-page-wrapper"><span class="pagination-buttons next bg-stone-500 cursor-not-allowed  hover:bg-stone-500 text-white font-bold py-2 px-4 rounded">Next</span></div><div class="widget"><a href="/questions/tag/identity-operator">identity-operator</a><a href="/questions/tag/attr">attr</a><a href="/questions/tag/multipartform-data">multipartform-data</a><a href="/questions/tag/server-side">server-side</a><a href="/questions/tag/equals">equals</a><a href="/questions/tag/sql">sql</a><a href="/questions/tag/cdi">cdi</a><a href="/questions/tag/abi">abi</a><a href="/questions/tag/click">click</a><a href="/questions/tag/environment-variables">environment-variables</a><a href="/questions/tag/image">image</a><a href="/questions/tag/action">action</a><a href="/questions/tag/threetenabp">threetenabp</a><a href="/questions/tag/pivot-table">pivot-table</a><a href="/questions/tag/php-password-hash">php-password-hash</a><a href="/questions/tag/borrow-checker">borrow-checker</a><a href="/questions/tag/sql-server-2008">sql-server-2008</a><a href="/questions/tag/move-semantics">move-semantics</a><a href="/questions/tag/siblings">siblings</a><a href="/questions/tag/iostream">iostream</a></div></div><span class="cursor-pointer text-lg p-2" style="position:fixed;bottom:20px;left:20px;background:#000;z-index:2000;color:white">Go go top</span></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"data":{"count":1,"rows":[{"id":566,"title":"How to count the number of set bits in a 32-bit integer?","slug":"how-to-count-the-number-of-set-bits-in-a-32-bit-integer-1657388437370","postType":"QUESTION","createdAt":"2022-07-09T17:40:37.000Z","updatedAt":"2022-07-09T17:40:37.000Z","tags":[{"id":2733,"name":"iec10967","slug":"iec10967","createdAt":"2022-07-09T17:40:37.000Z","updatedAt":"2022-07-09T17:40:37.000Z","Questions_Tags":{"questionId":566,"tagId":2733}}]}]},"slug":"iec10967","page":"1","answers":{"566":["\n\u0026lt;p\u0026gt;This is known as the \u0026apos;\u0026lt;a href=\u0026quot;https://en.wikipedia.org/wiki/Hamming_weight\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;Hamming Weight\u0026lt;/a\u0026gt;\u0026apos;, \u0026apos;popcount\u0026apos; or \u0026apos;sideways addition\u0026apos;.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Some CPUs have a single built-in instruction to do it and others have parallel instructions which act on bit vectors.  Instructions like x86\u0026apos;s \u0026lt;a href=\u0026quot;https://www.felixcloutier.com/x86/popcnt\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;\u0026lt;code\u0026gt;popcnt\u0026lt;/code\u0026gt;\u0026lt;/a\u0026gt; (on CPUs where it\u0026apos;s supported) will almost certainly be fastest for a single integer.  Some other architectures may have a slow instruction implemented with a microcoded loop that tests a bit per cycle (\u0026lt;em\u0026gt;citation needed\u0026lt;/em\u0026gt; - hardware popcount is normally fast if it exists at all.).\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;The \u0026apos;best\u0026apos; algorithm really depends on which CPU you are on and what your usage pattern is.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Your compiler may know how to do something that\u0026apos;s good for the specific CPU you\u0026apos;re compiling for, e.g. \u0026lt;a href=\u0026quot;https://en.cppreference.com/w/cpp/numeric/popcount\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;C++20 \u0026lt;code\u0026gt;std::popcount()\u0026lt;/code\u0026gt;\u0026lt;/a\u0026gt;, or C++ \u0026lt;a href=\u0026quot;https://en.cppreference.com/w/cpp/utility/bitset/count\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;\u0026lt;code\u0026gt;std::bitset\u0026amp;lt;32\u0026amp;gt;::count()\u0026lt;/code\u0026gt;\u0026lt;/a\u0026gt;, as a portable way to access builtin / intrinsic functions (see \u0026lt;a href=\u0026quot;https://stackoverflow.com/questions/109023/how-to-count-the-number-of-set-bits-in-a-32-bit-integer/109069#109069\u0026quot;\u0026gt;another answer\u0026lt;/a\u0026gt; on this question).  But your compiler\u0026apos;s choice of fallback for target CPUs that don\u0026apos;t have hardware popcnt might not be optimal for your use-case.  Or your language (e.g. C) might not expose any portable function that could use a CPU-specific popcount when there is one.\u0026lt;/p\u0026gt;\n\u0026lt;hr\u0026gt;\n\u0026lt;h3\u0026gt;Portable algorithms that don\u0026apos;t need (or benefit from) any HW support\u0026lt;/h3\u0026gt;\n\u0026lt;p\u0026gt;A pre-populated table lookup method can be very fast if your CPU has a large cache and you are doing lots of these operations in a tight loop. However it can suffer because of the expense of a \u0026apos;cache miss\u0026apos;, where the CPU has to fetch some of the table from main memory.  (Look up each byte separately to keep the table small.)  If you want popcount for a contiguous range of numbers, only the low byte is changing for groups of 256 numbers, \u0026lt;a href=\u0026quot;https://stackoverflow.com/questions/66520106/count-integers-in-1-n-with-k-zero-bits-below-the-leading-1-popcount-for-a-c/66532113#66532113\u0026quot;\u0026gt;making this very good\u0026lt;/a\u0026gt;.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;If you know that your bytes will be mostly 0\u0026apos;s or mostly 1\u0026apos;s then there are efficient algorithms for these scenarios, e.g. clearing the lowest set with a bithack in a loop until it becomes zero.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;I believe a very good general purpose algorithm is the following, known as \u0026apos;parallel\u0026apos; or \u0026apos;variable-precision SWAR algorithm\u0026apos;. I have expressed this in a C-like pseudo language, you may need to adjust it to work for a particular language (e.g. using uint32_t for C++ and \u0026amp;gt;\u0026amp;gt;\u0026amp;gt; in Java):\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;GCC10 and clang 10.0 can recognize this pattern / idiom and compile it to a hardware popcnt or equivalent instruction when available, giving you the best of both worlds. (\u0026lt;a href=\u0026quot;https://godbolt.org/z/qGdh1dvKK\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;https://godbolt.org/z/qGdh1dvKK\u0026lt;/a\u0026gt;)\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;numberOfSetBits\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;uint32_t\u0026lt;/span\u0026gt; i)\u0026lt;/span\u0026gt;\n{\n     \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Java: use int, and use \u0026amp;gt;\u0026amp;gt;\u0026amp;gt; instead of \u0026amp;gt;\u0026amp;gt;. Or use Integer.bitCount()\u0026lt;/span\u0026gt;\n     \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// C or C++: use uint32_t\u0026lt;/span\u0026gt;\n     i = i - ((i \u0026amp;gt;\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;) \u0026amp;amp; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0x55555555\u0026lt;/span\u0026gt;);        \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// add pairs of bits\u0026lt;/span\u0026gt;\n     i = (i \u0026amp;amp; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0x33333333\u0026lt;/span\u0026gt;) + ((i \u0026amp;gt;\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;) \u0026amp;amp; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0x33333333\u0026lt;/span\u0026gt;);  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// quads\u0026lt;/span\u0026gt;\n     i = (i + (i \u0026amp;gt;\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;4\u0026lt;/span\u0026gt;)) \u0026amp;amp; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0x0F0F0F0F\u0026lt;/span\u0026gt;;        \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// groups of 8\u0026lt;/span\u0026gt;\n     \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; (i * \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0x01010101\u0026lt;/span\u0026gt;) \u0026amp;gt;\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;24\u0026lt;/span\u0026gt;;          \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// horizontal sum of bytes\u0026lt;/span\u0026gt;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;For JavaScript: \u0026lt;a href=\u0026quot;https://stackoverflow.com/questions/109023/how-to-count-the-number-of-set-bits-in-a-32-bit-integer/109025#comment103845611_109025\u0026quot;\u0026gt;coerce to integer\u0026lt;/a\u0026gt; with \u0026lt;code\u0026gt;|0\u0026lt;/code\u0026gt; for performance: change the first line to \u0026lt;code\u0026gt;i = (i|0) - ((i \u0026amp;gt;\u0026amp;gt; 1) \u0026amp;amp; 0x55555555);\u0026lt;/code\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;This has the best worst-case behaviour of any of the algorithms discussed, so will efficiently deal with any usage pattern or values you throw at it.  (Its performance is not data-dependent on normal CPUs where all integer operations including multiply are constant-time.  It doesn\u0026apos;t get any faster with \u0026quot;simple\u0026quot; inputs, but it\u0026apos;s still pretty decent.)\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;References:\u0026lt;/p\u0026gt;\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;a href=\u0026quot;https://graphics.stanford.edu/%7Eseander/bithacks.html#CountBitsSetParallel\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;https://graphics.stanford.edu/~seander/bithacks.html\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;a href=\u0026quot;https://en.wikipedia.org/wiki/Hamming_weight\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;https://en.wikipedia.org/wiki/Hamming_weight\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;a href=\u0026quot;http://gurmeet.net/puzzles/fast-bit-counting-routines/\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;http://gurmeet.net/puzzles/fast-bit-counting-routines/\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;a href=\u0026quot;http://aggregate.ee.engr.uky.edu/MAGIC/#Population%20Count%20(Ones%20Count)\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;http://aggregate.ee.engr.uky.edu/MAGIC/#Population%20Count%20(Ones%20Count)\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;hr\u0026gt;\n\u0026lt;h3\u0026gt;How this SWAR bithack works:\u0026lt;/h3\u0026gt;\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;i = i - ((i \u0026amp;gt;\u0026amp;gt; 1) \u0026amp;amp; 0x55555555);\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;The first step is an optimized version of masking to isolate the odd / even bits, shifting to line them up, and adding.  This effectively does 16 separate additions in 2-bit accumulators (\u0026lt;a href=\u0026quot;https://en.wikipedia.org/wiki/SWAR\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;SWAR = SIMD Within A Register\u0026lt;/a\u0026gt;).  Like \u0026lt;code\u0026gt;(i \u0026amp;amp; 0x55555555) + ((i\u0026amp;gt;\u0026amp;gt;1) \u0026amp;amp; 0x55555555)\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;The next step takes the odd/even eight of those 16x 2-bit accumulators and adds again, producing 8x 4-bit sums.  The \u0026lt;code\u0026gt;i - ...\u0026lt;/code\u0026gt; optimization isn\u0026apos;t possible this time so it does just mask before / after shifting.  Using the same \u0026lt;code\u0026gt;0x33...\u0026lt;/code\u0026gt; constant both times instead of \u0026lt;code\u0026gt;0xccc...\u0026lt;/code\u0026gt; before shifting is a good thing when compiling for ISAs that need to construct 32-bit constants in registers separately.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;The final shift-and-add step of \u0026lt;code\u0026gt;(i + (i \u0026amp;gt;\u0026amp;gt; 4)) \u0026amp;amp; 0x0F0F0F0F\u0026lt;/code\u0026gt; widens to 4x 8-bit accumulators.  It masks \u0026lt;em\u0026gt;after\u0026lt;/em\u0026gt; adding instead of before, because the maximum value in any 4-bit accumulator is \u0026lt;code\u0026gt;4\u0026lt;/code\u0026gt;, if all 4 bits of the corresponding input bits were set.  4+4 = 8 which still fits in 4 bits, so carry between nibble elements is impossible in \u0026lt;code\u0026gt;i + (i \u0026amp;gt;\u0026amp;gt; 4)\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;So far this is just fairly normal SIMD using SWAR techniques with a few clever optimizations.  Continuing on with the same pattern for 2 more steps can widen to 2x 16-bit then 1x 32-bit counts.  But there is a more efficient way on machines with fast hardware multiply:\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Once we have few enough \u0026quot;elements\u0026quot;, \u0026lt;strong\u0026gt;a multiply with a magic constant can sum all the elements into the top element\u0026lt;/strong\u0026gt;.  In this case byte elements.  Multiply is done by left-shifting and adding, so \u0026lt;strong\u0026gt;a multiply of \u0026lt;code\u0026gt;x * 0x01010101\u0026lt;/code\u0026gt; results in \u0026lt;code\u0026gt;x + (x\u0026amp;lt;\u0026amp;lt;8) + (x\u0026amp;lt;\u0026amp;lt;16) + (x\u0026amp;lt;\u0026amp;lt;24)\u0026lt;/code\u0026gt;.\u0026lt;/strong\u0026gt;  Our 8-bit elements are wide enough (and holding small enough counts) that this doesn\u0026apos;t produce carry \u0026lt;em\u0026gt;into\u0026lt;/em\u0026gt; that top 8 bits.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;A 64-bit version of this\u0026lt;/strong\u0026gt; can do 8x 8-bit elements in a 64-bit integer with a 0x0101010101010101 multiplier, and extract the high byte with \u0026lt;code\u0026gt;\u0026amp;gt;\u0026amp;gt;56\u0026lt;/code\u0026gt;.  So it doesn\u0026apos;t take any extra steps, just wider constants.  This is what GCC uses for \u0026lt;code\u0026gt;__builtin_popcountll\u0026lt;/code\u0026gt; on x86 systems when the hardware \u0026lt;code\u0026gt;popcnt\u0026lt;/code\u0026gt; instruction isn\u0026apos;t enabled.  If you can use builtins or intrinsics for this, do so to give the compiler a chance to do target-specific optimizations.\u0026lt;/p\u0026gt;\n\u0026lt;hr\u0026gt;\n\u0026lt;h3\u0026gt;With full SIMD for wider vectors (e.g. counting a whole array)\u0026lt;/h3\u0026gt;\n\u0026lt;p\u0026gt;This bitwise-SWAR algorithm could parallelize to be done in multiple vector elements at once, instead of in a single integer register, for a speedup on CPUs with SIMD but no usable popcount instruction.  (e.g. x86-64 code that has to run on any CPU, not just Nehalem or later.)\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;However, the best way to use vector instructions for popcount is usually by using a variable-shuffle to do a table-lookup for 4 bits at a time of each byte in parallel.  (The 4 bits index a 16 entry table held in a vector register).\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;On Intel CPUs, the hardware 64bit popcnt instruction can outperform an \u0026lt;a href=\u0026quot;http://wm.ite.pl/articles/sse-popcount.html\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;SSSE3 \u0026lt;code\u0026gt;PSHUFB\u0026lt;/code\u0026gt; bit-parallel implementation\u0026lt;/a\u0026gt; by about a factor of 2, but only \u0026lt;a href=\u0026quot;http://danluu.com/assembly-intrinsics/\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;if your compiler gets it just right\u0026lt;/a\u0026gt;.  Otherwise SSE can come out significantly ahead.  Newer compiler versions are aware of the \u0026lt;a href=\u0026quot;https://stackoverflow.com/a/25089720/224132\u0026quot;\u0026gt;popcnt false dependency\u0026lt;/a\u0026gt; \u0026lt;a href=\u0026quot;https://gcc.gnu.org/bugzilla/show_bug.cgi?id=62011\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;problem on Intel\u0026lt;/a\u0026gt;.\u0026lt;/p\u0026gt;\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;a href=\u0026quot;https://github.com/WojciechMula/sse-popcount\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;https://github.com/WojciechMula/sse-popcount\u0026lt;/a\u0026gt; state-of-the-art x86 SIMD popcount for SSSE3, AVX2, AVX512BW, AVX512VBMI, or AVX512 VPOPCNT.  Using Harley-Seal across vectors to defer popcount within an element.  (Also ARM NEON)\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;a href=\u0026quot;https://stackoverflow.com/questions/50081465/counting-1-bits-population-count-on-large-data-using-avx-512-or-avx-2\u0026quot;\u0026gt;Counting 1 bits (population count) on large data using AVX-512 or AVX-2\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;related: \u0026lt;a href=\u0026quot;https://github.com/mklarqvist/positional-popcount\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;https://github.com/mklarqvist/positional-popcount\u0026lt;/a\u0026gt; - separate counts for each bit-position of multiple 8, 16, 32, or 64-bit integers.  (Again, x86 SIMD including AVX-512 which is really good at this, with \u0026lt;code\u0026gt;vpternlogd\u0026lt;/code\u0026gt; making Harley-Seal \u0026lt;em\u0026gt;very\u0026lt;/em\u0026gt; good.)\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Some languages portably expose the operation in a way that \u0026lt;em\u0026gt;can\u0026lt;/em\u0026gt; use efficient hardware support if available, otherwise some library fallback that\u0026apos;s hopefully decent.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;For example (from \u0026lt;a href=\u0026quot;https://en.wikichip.org/wiki/population_count#Software_support\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;a table by language\u0026lt;/a\u0026gt;):\u0026lt;/p\u0026gt;\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;C++ has \u0026lt;code\u0026gt;std::bitset\u0026amp;lt;\u0026amp;gt;::count()\u0026lt;/code\u0026gt;, or  \u0026lt;a href=\u0026quot;https://en.cppreference.com/w/cpp/numeric/popcount\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;C++20 \u0026lt;code\u0026gt;std::popcount(T x)\u0026lt;/code\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Java has \u0026lt;code\u0026gt;java.lang.Integer.bitCount()\u0026lt;/code\u0026gt; (also for Long or BigInteger)\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;C# has \u0026lt;code\u0026gt;System.Numerics.BitOperations.PopCount()\u0026lt;/code\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Python has \u0026lt;code\u0026gt;int.bit_count()\u0026lt;/code\u0026gt; (since 3.10)\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;p\u0026gt;Not all compilers / libraries actually manage to use HW support when it\u0026apos;s available, though. (Notably MSVC, even with options that make std::popcount inline as x86 popcnt, its std::bitset::count still always uses a lookup table.  This will hopefully change in future versions.)\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Also consider the built-in functions of your compiler when the portable language doesn\u0026apos;t have this basic bit operation.  In GNU C for example:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c++ s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; __builtin_popcount (\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;unsigned\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; x);\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; __builtin_popcountll (\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;unsigned\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;long\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;long\u0026lt;/span\u0026gt; x);\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;In the worst case (no single-instruction HW support) the compiler will generate a call to a function (which in current GCC uses a shift/and bit-hack \u0026lt;a href=\u0026quot;https://stackoverflow.com/questions/109023/how-to-count-the-number-of-set-bits-in-a-32-bit-integer/109025#109025\u0026quot;\u0026gt;like this answer\u0026lt;/a\u0026gt;, at least for x86). In the best case the compiler will emit a cpu instruction to do the job. (Just like a \u0026lt;code\u0026gt;*\u0026lt;/code\u0026gt; or \u0026lt;code\u0026gt;/\u0026lt;/code\u0026gt; operator - GCC will use a hardware multiply or divide instruction if available, otherwise will call a libgcc helper function.)  Or even better, if the operand is a compile-time constant after inlining, it can do constant-propagation to get a compile-time-constant popcount result.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;The GCC builtins even work across multiple platforms. Popcount has almost become mainstream in the x86 architecture, so it makes sense to start using the builtin now so you can recompile to let it inline a hardware instruction when you compile with \u0026lt;code\u0026gt;-mpopcnt\u0026lt;/code\u0026gt; or something that includes that (e.g. \u0026lt;a href=\u0026quot;https://godbolt.org/z/Ma5e5a\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;https://godbolt.org/z/Ma5e5a\u0026lt;/a\u0026gt;). Other architectures have had popcount for years, but in the x86 world there are still some ancient Core 2 and similar vintage AMD CPUs in use.\u0026lt;/p\u0026gt;\n\u0026lt;hr\u0026gt;\n\u0026lt;p\u0026gt;On x86, you can tell the compiler that it can assume support for \u0026lt;code\u0026gt;popcnt\u0026lt;/code\u0026gt; instruction with \u0026lt;code\u0026gt;-mpopcnt\u0026lt;/code\u0026gt; (also implied by \u0026lt;code\u0026gt;-msse4.2\u0026lt;/code\u0026gt;).  See \u0026lt;a href=\u0026quot;https://gcc.gnu.org/onlinedocs/gcc/x86-Options.html\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;GCC x86 options\u0026lt;/a\u0026gt;.  \u0026lt;code\u0026gt;-march=nehalem -mtune=skylake\u0026lt;/code\u0026gt; (or \u0026lt;code\u0026gt;-march=\u0026lt;/code\u0026gt; whatever CPU you want your code to assume and to tune for) could be a good choice.   Running the resulting binary on an older CPU will result in an illegal-instruction fault.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;To make binaries optimized for the machine you build them on, \u0026lt;strong\u0026gt;use \u0026lt;code\u0026gt;-march=native\u0026lt;/code\u0026gt;\u0026lt;/strong\u0026gt;  (with gcc, clang, or ICC).\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;a href=\u0026quot;https://stackoverflow.com/questions/3849337/msvc-equivalent-to-builtin-popcount\u0026quot;\u0026gt;MSVC provides an intrinsic for the x86 \u0026lt;code\u0026gt;popcnt\u0026lt;/code\u0026gt; instruction\u0026lt;/a\u0026gt;, but unlike gcc it\u0026apos;s really an intrinsic for the hardware instruction and requires hardware support.\u0026lt;/p\u0026gt;\n\u0026lt;hr\u0026gt;\n\u0026lt;h2\u0026gt;Using \u0026lt;code\u0026gt;std::bitset\u0026amp;lt;\u0026amp;gt;::count()\u0026lt;/code\u0026gt; instead of a built-in\u0026lt;/h2\u0026gt;\n\u0026lt;p\u0026gt;In theory, any compiler that knows how to popcount efficiently for the target CPU should expose that functionality through ISO C++ \u0026lt;a href=\u0026quot;http://en.cppreference.com/w/cpp/utility/bitset/count\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;\u0026lt;code\u0026gt;std::bitset\u0026amp;lt;\u0026amp;gt;\u0026lt;/code\u0026gt;\u0026lt;/a\u0026gt;.  In practice, you might be better off with the bit-hack AND/shift/ADD in some cases for some target CPUs.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;For target architectures where hardware popcount is an optional extension (like x86), not all compilers have a \u0026lt;code\u0026gt;std::bitset\u0026lt;/code\u0026gt; that takes advantage of it when available.  For example, MSVC has no way to enable \u0026lt;code\u0026gt;popcnt\u0026lt;/code\u0026gt; support at compile time, and it\u0026apos;s \u0026lt;code\u0026gt;std::bitset\u0026amp;lt;\u0026amp;gt;::count\u0026lt;/code\u0026gt; always uses \u0026lt;a href=\u0026quot;https://stackoverflow.com/questions/12324081/how-does-this-implementation-of-bitsetcount-work\u0026quot;\u0026gt;a table lookup\u0026lt;/a\u0026gt;, even with \u0026lt;code\u0026gt;/Ox /arch:AVX\u0026lt;/code\u0026gt; (which implies SSE4.2, which in turn implies the popcnt feature.)  (Update: see below; that \u0026lt;em\u0026gt;does\u0026lt;/em\u0026gt; get MSVC\u0026apos;s C++20 \u0026lt;code\u0026gt;std::popcount\u0026lt;/code\u0026gt; to use x86 \u0026lt;code\u0026gt;popcnt\u0026lt;/code\u0026gt;, but still not its bitset\u0026amp;lt;\u0026amp;gt;::count.  MSVC could fix that by updating their standard library headers to use std::popcount when available.)\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;But at least you get something portable that works everywhere, and with gcc/clang with the right target options, you get hardware popcount for architectures that support it.\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-c++ s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;bitset\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;limits\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;type_traits\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\ntemplate\u0026amp;lt;typename T\u0026amp;gt;\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//static inline  // static if you want to compile with -mpopcnt in one compilation unit but not others\u0026lt;/span\u0026gt;\ntypename \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;std\u0026lt;/span\u0026gt;::enable_if\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;std\u0026lt;/span\u0026gt;::is_integral\u0026amp;lt;T\u0026amp;gt;::value,  \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;unsigned\u0026lt;/span\u0026gt; \u0026amp;gt;::type \n\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;popcount\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(T x)\u0026lt;/span\u0026gt;\n{\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;static_assert\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;std\u0026lt;/span\u0026gt;::numeric_limits\u0026amp;lt;T\u0026amp;gt;::radix == \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;non-binary type\u0026quot;\u0026lt;/span\u0026gt;);\n\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// sizeof(x)*CHAR_BIT\u0026lt;/span\u0026gt;\n    constexpr \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; bitwidth = \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;std\u0026lt;/span\u0026gt;::numeric_limits\u0026amp;lt;T\u0026amp;gt;::digits + \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;std\u0026lt;/span\u0026gt;::numeric_limits\u0026amp;lt;T\u0026amp;gt;::is_signed;\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// std::bitset constructor was only unsigned long before C++11.  Beware if porting to C++03\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;static_assert\u0026lt;/span\u0026gt;(bitwidth \u0026amp;lt;= \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;std\u0026lt;/span\u0026gt;::numeric_limits\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;unsigned\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;long\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;long\u0026lt;/span\u0026gt;\u0026amp;gt;::digits, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;arg too wide for std::bitset() constructor\u0026quot;\u0026lt;/span\u0026gt;);\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typedef\u0026lt;/span\u0026gt; typename \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;std\u0026lt;/span\u0026gt;::make_unsigned\u0026amp;lt;T\u0026amp;gt;::type UT;        \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// probably not needed, bitset width chops after sign-extension\u0026lt;/span\u0026gt;\n\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;std\u0026lt;/span\u0026gt;::\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;bitset\u0026lt;/span\u0026gt;\u0026amp;lt;bitwidth\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;bs\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;( static_cast\u0026amp;lt;UT\u0026amp;gt;(x) )\u0026lt;/span\u0026gt;;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; bs.count();\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;See \u0026lt;a href=\u0026quot;https://gcc.godbolt.org/#z:OYLghAFBqd5TKALEBjA9gEwKYFFMCWALugE4A0BIEAViAIzkDO6ArqatiAOQCkATAGYCAO1QAbVjgDUvQQGEARsSbYic3LwAMAQQHCxkmXPniCAWxUbteoaIlTsshUQCeAB2wB9IqQCGVoKaugD0IdIAqqrSREhOSOieAGas4uKuALTA6FjSTESYICDKRKpERRisIkQQAJTSFu7i2ObY1X5EBOgi0klk0n6kJf6krg3V2MDYpDEe2Ew2YdI6AG7oBJhMeQTAIhnYAB5EbYQiwNu72Jizngu6i%2BEA8j3AqKgDItcSfmfk0tgAR1YBBWfma1Ri6GkXi8imB4k6Ii87kSlWqaTqD2kmHQAHcREwNlwBuJcX5XFtWKotgA2AAsGRK0kS0x%2BmAyhIAXk4IN1pPTGcRpPIAApRWpYgBiZE4W25pHQ%2ByObUJfJI/IZJQAdFidOIWHlxHjptJccQEqwiNIkINMGTSE4Ue40UQ/vNPKgCGD0qbzQMYn5FM0Mkb0ABrVjuaSh9w60JPHoHAAcNL%2BuLI0ViCtYwCQ7ktzJ6OgAsgARaQAIVS4hx8oyST8lh9sR%2B0kE/EFVqdqGquv1ULJ%2BXm/oASrgABrSdwOpIEA5xvS6Y7mJodbAmNyeESNpwAFWs8fyHQI71EZhETmkSyPnVPSWkrjYpp%2BVvVGBXBGavti0gyK9REKiIWTjvu4n7HnyVRCnCVoiOgVrwXEpB3Dom5tDueQFEU6FBt4BBJCY%2BSFCABBMF4ojHMA/jiCY%2B5BEUoKSNgfzSFUhKXNcGhFGhsi6N2bDVBAu7SAcEr3AA7BWNjaAAnDeJ5eH4TCqKQNREUUIisK0pAKWYlilLRXEgP4hAHM4pZyOW/B/AI/BwXsyjbqMNzrvw/ASoIUn3N5MnXgQ3LoEkECiQAVPIAASOgjl4FYAJL7j5GAEscBzTuMVolGamA/pZmHEZp2m6RYgTyHRuBFIQwAqLI/AVnlGladMRX6QsChlUUpFeOxF6YHIXmLr54TqcUKhqNISX5KQrCoCQMyDoWPpsTsPXRt05yKNgfQOsKAhSbV9D0Fq0iVtg9pOPhU5kIi5zqvIu27Vogg2Mdx3yaginKdMNSZRsOUKLlw0FU1716SVS0catZyQ8ARmVSoNluYMN05L6MhbfVI2lGodTjd0k3TbNtkef10laDJaE4PeaHbq0GPmH4YbeODPWGfRIA8REdF1S9PNLNO6CKIGPpwbB2BXFcfwlGUqM/qgCTuFsfhJMcMzdUqxwEl0Iik3JWGY2UJg/dlSAaNIihMBAmHHu9qBKeoCicxowX1MTOsOkQ7A9ObWoupinnSeJFneYuOjM1cMTzEQyKogJUdMAkqkQPHV0DPUvCSdI7ue5dzqxxAfjE7Igc2GH1zHPk0e51UUcURAFGp0XdVZ6QPT8dX%2BeF%2BnQc6GEpcRxXbfVF4pcQH3BeN5najZ4PNQF31Rfd335dRzP9IQEaUMb%2Bc4/p03U8tznvtz55C9YjhzTkfe%2BSJFssSkb0CrmLjH7nsj/o4qwuEZBofdJSs0yqm1vGJekdK7vQ/rhCAECvw7wzs3VuMd27Hzql3UmId659HQEnBOVo/B/C3tDM2adJJu33j0HWh8847x8rtSh7dFCu10C9PqAdu5oKWDCCi9B%2BBJgaFsLKJoWw9D7gQre0k7D3noDVGkAgaTYk2qIK4EAYQAGVYoAC1cCPElF4WKAA5Xc3CkwwjEj3cIsQnBvQ%2BipK018FYxCQPfJIj9n5gVftICA6pug%2BhdA4pwRpcTWjBEkUxvdNYQ2XmA2ORjlHkWqEYhuu9J4ewPjPDu89UHByWLuRxWwbSoDDKaMgYYth8leKgEI3wzggAGMpRqZtRpWnvmCMkFJejiA6NIVo5gyCuBAM9F6SxYrRk2q%2BXJzICyBT8RHFcHTjhm2wLbKk50iBgG4FsEWl1VJC3XD5MI%2BEk7%2BWwIFZ2zhcDbACkFERa1oa1DTns8IL1umoHcK4CAsjzYIxpAcP4XJjlBXNnclhwd9D2CME4EwqBJqiBhkEEu4SVr5LDFE6uMTOHxJ4YkkhPlhpSzUCYIxptzbpP9j5Z5rz3n8BpJ86ReCLn/IgICwuV5wj2hEDCmpGBXkwo%2BMyRQNBFkIXvPZDIvgQRenEC5DxZofww1qrtUxsl4FmyYD7POjC9DF3uEIE4%2BEbDcFqOQcQPAACs3ByAiB4Foc16AeB3XlbVPIbAOAQqEPQc15RuDWrueQMMIBBBJi1FoGk4lxL0BkgGmkSYkxaC0HSI1PA6TmvMCAcSWgtT0BpDSdsWhM3Zv4Lm1MlqvU2p4OapgIAtDkE9d68gcBYAoFAp%2BaYlBqBNuaKQEA7hnT0maMAbNVbZwIgAdQRQVrzXvlaNUZ46Rx3kEIA6GaIJ5hzootgY1JbDVmHNvAQ1iROh4x4BkAA6t6X8jxBC/iIpZXYrB7r7XdcwZ1nAGBbtNea4t1ryC2u4CKY0pARTyA1PyLUggg0ePwMQfo%2BhGDCnQC/E0MHagevHT6uIfgcCdrqAm7gSbyApv4DJLUSZBCCBDTJEjZHxIUYDRaudP7y2Vurahw1fqA1BpDWGiNKZo2xvjRuwQH76NluY5uutiB63IDQPBtxLaqAQHbdMNAHSzhkZ%2BUOlWFbGVzsnW0IgM6%2BklvnQQRdnR/4VqM2ujdtbt0VsgHu9wB6CRHuvYIUst770VgOlego27LLbtQJ538p60jnsvX%2BbsEI/yDDlpZG0TBcTrvEOW59XBGBkmnY52KIg%2Bg8HdW%2B7gZq6NGZ/cmGkGR6TjRU%2BcMDciICQdmjVQQsH5AyebTMfQghkOie9Ya9DmHqCsf9YGmSdIkwmpkuJJMdITUxqozhvDKbSPEfoLm3NMkZLcJNVNmSxWv0MeYExmtBrxPwAgI2trHbW0Kcu0p4AdJRvkA0yO2JXgtCDfIGOozunp0iFnUZhdgrl0Wa/VZudNAgTTEM2B/gGbzXgmALEBg5BpzYBWI8flgrqAwje9QLknJmj0BNcG4Nm2TV0jG4IagVRKaKMKOvSYJx4D0HEoINNu2q3cHy3crdbREcoEYKj9HmOZrY5hO92gABFVgUP2yrZI4RmSNJHoza0MTjbJr6DUEIEwVchmTv48J8T5XNIycU5I9Tz4CierUD7UzyALO2dk3IJz7nPqEdI/oDzo1BAd32e/Y5rWFmT1noyBenzvU3MeYdV5qREWAJWmixwE2bn4uJbSCl9gL6vc4aK5%2B0t3AysVbpNIcp0g6RaiIyX%2BrhBGswb%2BK1hDHWhAmu68d93ibk3%2BpNcRmkE2c1K7I3SAtJq9sF8Y1W9vp2G3Sab9dxTnaTyoBZ09z8mmxe4%2Bw19r9P39N/cM1%2BwHS7zOromNZ81EOZejB4DDuHRq%2Bee5Rw6YXArRevYl4b7AROSem6J%2Bbqno8Vus4NuDOUwnwzO4kBaq2Lu5AXOBq3uHuAuT%2BaOGOr%2B5Q7%2B1ANA0usu/A8u7YG2yuggqu6uMkmu2upEeuZahqn%2B3%2BJuZulOlutOIBdu4BDukBa2MBcBPOvOZwnuCBvudm2G%2B6QeR6IWkqYe4Wrm7mmknm3m8ezoUW9Myelk24Zm2AmeLqr6ueQmJWPARelWS%2B0gLOEGte0GbqDet2zeRBbeLG5A/WSm2GG6i2/q6a7YggSuE23CbO1GY%2B36ImFak%2BthbGYGY2fej0SYrO/AkBYaOGgmvhB2U%2Bkm52s%2BsmFA8mC%2Bym4aXg9Iq%2Bw6yEo6Om8GU6e%2B/2h%2BJmQOJ%2BlmZ%2BqGPufuQhgeh63AIQjwZkIQMWKAOgAAauOBodnuQBlvplljlj%2BvltofEXoSmMXsKAADJGEyTSBQHiTSAji7jHomFQZWEtaWFNbuQoabpDY8JagU7bbiQhruHTaQF94LY6H7b%2BFHa2Ebr8Bd6rZVr55%2BHcB7G9bkD/zIRawgB0hAA%3D\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;asm from gcc, clang, icc, and MSVC\u0026lt;/a\u0026gt; on the Godbolt compiler explorer.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;x86-64 \u0026lt;code\u0026gt;gcc -O3 -std=gnu++11 -mpopcnt\u0026lt;/code\u0026gt; emits this:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-c++ s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;unsigned\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;test_short\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;short\u0026lt;/span\u0026gt; a)\u0026lt;/span\u0026gt; { \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; popcount(a); }\n    movzx   eax, di      \u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;# note zero-extension, not sign-extension\u0026lt;/span\u0026gt;\n    popcnt  rax, rax\n    ret\n\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;unsigned\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;test_int\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; a)\u0026lt;/span\u0026gt; { \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; popcount(a); }\n    mov     eax, edi\n    popcnt  rax, rax        \u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;# unnecessary 64-bit operand size\u0026lt;/span\u0026gt;\n    ret\n\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;unsigned\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;test_u64\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;unsigned\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;long\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;long\u0026lt;/span\u0026gt; a)\u0026lt;/span\u0026gt; { \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; popcount(a); }\n    xor     eax, eax     \u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;# gcc avoids false dependencies for Intel CPUs\u0026lt;/span\u0026gt;\n    popcnt  rax, rdi\n    ret\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;PowerPC64 \u0026lt;code\u0026gt;gcc -O3 -std=gnu++11\u0026lt;/code\u0026gt; emits (for the \u0026lt;code\u0026gt;int\u0026lt;/code\u0026gt; arg version):\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-c++ s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;    rldicl \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3\u0026lt;/span\u0026gt;,\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3\u0026lt;/span\u0026gt;,\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;,\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;32\u0026lt;/span\u0026gt;     \u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;# zero-extend from 32 to 64-bit\u0026lt;/span\u0026gt;\n    popcntd \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3\u0026lt;/span\u0026gt;,\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3\u0026lt;/span\u0026gt;         \u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;# popcount\u0026lt;/span\u0026gt;\n    blr\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;This source isn\u0026apos;t x86-specific or GNU-specific at all, but only compiles well with gcc/clang/icc, at least when targeting x86 (including x86-64).\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Also note that gcc\u0026apos;s fallback for architectures without single-instruction popcount is a byte-at-a-time table lookup.  This isn\u0026apos;t wonderful \u0026lt;a href=\u0026quot;https://stackoverflow.com/questions/15736602/fastest-way-to-count-number-of-1s-in-a-register-arm-assembly\u0026quot;\u0026gt;for ARM, for example\u0026lt;/a\u0026gt;.\u0026lt;/p\u0026gt;\n\u0026lt;h2\u0026gt;\u0026lt;a href=\u0026quot;https://en.cppreference.com/w/cpp/numeric/popcount\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;C++20 has \u0026lt;code\u0026gt;std::popcount(T)\u0026lt;/code\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/h2\u0026gt;\n\u0026lt;p\u0026gt;Current libstdc++ headers unfortunately define it with a special case \u0026lt;code\u0026gt;if(x==0) return 0;\u0026lt;/code\u0026gt; at the start, which clang doesn\u0026apos;t optimize away when compiling for x86:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-c++ s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;bit\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;bar\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;unsigned\u0026lt;/span\u0026gt; x)\u0026lt;/span\u0026gt; {\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;std\u0026lt;/span\u0026gt;::popcount(x);\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;clang 11.0.1 \u0026lt;code\u0026gt;-O3  -std=gnu++20 -march=nehalem\u0026lt;/code\u0026gt;  (\u0026lt;a href=\u0026quot;https://godbolt.org/z/arMe5a\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;https://godbolt.org/z/arMe5a\u0026lt;/a\u0026gt;)\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-c++ s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;# clang 11\u0026lt;/span\u0026gt;\n    bar(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;unsigned\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;):                                # @bar(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;unsigned\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;)\n        popcnt  eax, edi\n        cmove   eax, edi         \u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;# redundant: \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; popcnt result is 0, return the original 0 instead of the popcnt-generated 0...\u0026lt;/span\u0026gt;\n        ret\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;But GCC compiles nicely:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-c++ s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;# gcc 10\u0026lt;/span\u0026gt;\n        xor     eax, eax         \u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;# break false dependency on Intel SnB-family before Ice Lake.\u0026lt;/span\u0026gt;\n        popcnt  eax, edi\n        ret\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;Even MSVC does well with it, as long as you use \u0026lt;code\u0026gt;-arch:AVX\u0026lt;/code\u0026gt;  or later (and enable C++20 with \u0026lt;code\u0026gt;-std:c++latest\u0026lt;/code\u0026gt;). \u0026lt;a href=\u0026quot;https://godbolt.org/z/7K4Gef\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;https://godbolt.org/z/7K4Gef\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-c++ s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;bar\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;unsigned\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;)\u0026lt;/span\u0026gt; PROC                                 ; bar, COMDAT\n        popcnt  eax, ecx\n        ret     \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;bar\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;unsigned\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;)\u0026lt;/span\u0026gt; ENDP                                 ; bar\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;In my opinion, the \u0026quot;best\u0026quot; solution is the one that can be read by another programmer (or the original programmer two years later) without copious comments.  You may well want the fastest or cleverest solution which some have already provided but I prefer readability over cleverness any time.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;unsigned int bitCount (unsigned int value) {\n    unsigned int count = 0;\n    while (value \u0026amp;gt; 0) {           // until all bits are zero\n        if ((value \u0026amp;amp; 1) == 1)     // check lower bit\n            count++;\n        value \u0026amp;gt;\u0026amp;gt;= 1;              // shift bits, removing lower bit\n    }\n    return count;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;If you want more speed (and assuming you document it well to help out your successors), you could use a table lookup:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;// Lookup table for fast calculation of bits set in 8-bit unsigned char.\n\nstatic unsigned char oneBitsInUChar[] = {\n//  0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F (\u0026amp;lt;- n)\n//  =====================================================\n    0, 1, 1, 2, 1, 2, 2, 3, 1, 2, 2, 3, 2, 3, 3, 4, // 0n\n    1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5, // 1n\n    : : :\n    4, 5, 5, 6, 5, 6, 6, 7, 5, 6, 6, 7, 6, 7, 7, 8, // Fn\n};\n\n// Function for fast calculation of bits set in 16-bit unsigned short.\n\nunsigned char oneBitsInUShort (unsigned short x) {\n    return oneBitsInUChar [x \u0026amp;gt;\u0026amp;gt;    8]\n         + oneBitsInUChar [x \u0026amp;amp;  0xff];\n}\n\n// Function for fast calculation of bits set in 32-bit unsigned int.\n\nunsigned char oneBitsInUInt (unsigned int x) {\n    return oneBitsInUShort (x \u0026amp;gt;\u0026amp;gt;     16)\n         + oneBitsInUShort (x \u0026amp;amp;  0xffff);\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Although these rely on specific data type sizes so they\u0026apos;re not that portable. But, since many performance optimisations aren\u0026apos;t portable anyway, that may not be an issue. If you want portability, I\u0026apos;d stick to the readable solution.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;\u0026lt;a href=\u0026quot;http://books.google.com/books?id=iBNKMspIlqEC\u0026amp;amp;pg=PA66\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;From Hacker\u0026apos;s Delight, p. 66, Figure 5-2\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;int pop(unsigned x)\n{\n    x = x - ((x \u0026amp;gt;\u0026amp;gt; 1) \u0026amp;amp; 0x55555555);\n    x = (x \u0026amp;amp; 0x33333333) + ((x \u0026amp;gt;\u0026amp;gt; 2) \u0026amp;amp; 0x33333333);\n    x = (x + (x \u0026amp;gt;\u0026amp;gt; 4)) \u0026amp;amp; 0x0F0F0F0F;\n    x = x + (x \u0026amp;gt;\u0026amp;gt; 8);\n    x = x + (x \u0026amp;gt;\u0026amp;gt; 16);\n    return x \u0026amp;amp; 0x0000003F;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Executes in ~20-ish instructions (arch dependent), no branching.\u0026lt;br\u0026gt;\u0026lt;br\u0026gt;\u0026lt;a href=\u0026quot;http://books.google.com/books?id=iBNKMspIlqEC\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;Hacker\u0026apos;s Delight\u0026lt;/a\u0026gt; \u0026lt;em\u0026gt;is\u0026lt;/em\u0026gt; delightful! Highly recommended.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;I think the fastest waywithout using lookup tables and \u0026lt;em\u0026gt;popcount\u0026lt;/em\u0026gt;is the following. It counts the set bits with just 12 operations.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;int popcount(int v) {\n    v = v - ((v \u0026amp;gt;\u0026amp;gt; 1) \u0026amp;amp; 0x55555555);                // put count of each 2 bits into those 2 bits\n    v = (v \u0026amp;amp; 0x33333333) + ((v \u0026amp;gt;\u0026amp;gt; 2) \u0026amp;amp; 0x33333333); // put count of each 4 bits into those 4 bits  \n    return c = ((v + (v \u0026amp;gt;\u0026amp;gt; 4) \u0026amp;amp; 0xF0F0F0F) * 0x1010101) \u0026amp;gt;\u0026amp;gt; 24;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;It works because you can count the total number of set bits by dividing in two halves, counting the number of set bits in both halves and then adding them up. Also know as \u0026lt;code\u0026gt;Divide and Conquer\u0026lt;/code\u0026gt; paradigm. Let\u0026apos;s get into detail.. \u0026lt;/p\u0026gt;\n\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;v = v - ((v \u0026amp;gt;\u0026amp;gt; 1) \u0026amp;amp; 0x55555555); \n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;The number of bits in two bits can be \u0026lt;code\u0026gt;0b00\u0026lt;/code\u0026gt;, \u0026lt;code\u0026gt;0b01\u0026lt;/code\u0026gt; or \u0026lt;code\u0026gt;0b10\u0026lt;/code\u0026gt;. Lets try to work this out on 2 bits.. \u0026lt;/p\u0026gt;\n\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt; ---------------------------------------------\n |   v    |   (v \u0026amp;gt;\u0026amp;gt; 1) \u0026amp;amp; 0b0101   |  v - x   |\n ---------------------------------------------\n   0b00           0b00               0b00   \n   0b01           0b00               0b01     \n   0b10           0b01               0b01\n   0b11           0b01               0b10\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;This is what was required: the last column shows the count of set bits in every two bit pair. If the two bit number is \u0026lt;code\u0026gt;\u0026amp;gt;= 2 (0b10)\u0026lt;/code\u0026gt; then \u0026lt;code\u0026gt;and\u0026lt;/code\u0026gt; produces \u0026lt;code\u0026gt;0b01\u0026lt;/code\u0026gt;, else it produces \u0026lt;code\u0026gt;0b00\u0026lt;/code\u0026gt;. \u0026lt;/p\u0026gt;\n\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;v = (v \u0026amp;amp; 0x33333333) + ((v \u0026amp;gt;\u0026amp;gt; 2) \u0026amp;amp; 0x33333333); \n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;This statement should be easy to understand. After the first operation we have the count of set bits in every two bits, now we sum up that count in every 4 bits.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;v \u0026amp;amp; 0b00110011         //masks out even two bits\n(v \u0026amp;gt;\u0026amp;gt; 2) \u0026amp;amp; 0b00110011  // masks out odd two bits\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;We then sum up the above result, giving us the total count of set bits in 4 bits. The last statement is the most tricky.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;c = ((v + (v \u0026amp;gt;\u0026amp;gt; 4) \u0026amp;amp; 0xF0F0F0F) * 0x1010101) \u0026amp;gt;\u0026amp;gt; 24;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Let\u0026apos;s break it down further... \u0026lt;/p\u0026gt;\n\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;v + (v \u0026amp;gt;\u0026amp;gt; 4)\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;It\u0026apos;s similar to the second statement; we are counting the set bits in groups of 4 instead. We knowbecause of our previous operationsthat every nibble has the count of set bits in it. Let\u0026apos;s look an example. Suppose we have the byte \u0026lt;code\u0026gt;0b01000010\u0026lt;/code\u0026gt;. It means the first nibble has its 4bits set and the second one has its 2bits set. Now we add those nibbles together. \u0026lt;/p\u0026gt;\n\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;0b01000010 + 0b01000000\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;It gives us the count of set bits in a byte, in the first nibble \u0026lt;code\u0026gt;0b01100010\u0026lt;/code\u0026gt; and therefore we mask the last four bytes of all the bytes in the number (discarding them).\u0026lt;/p\u0026gt;\n\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;0b01100010 \u0026amp;amp; 0xF0 = 0b01100000\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Now every byte has the count of set bits in it. We need to add them up all together. The trick is to multiply the result by \u0026lt;code\u0026gt;0b10101010\u0026lt;/code\u0026gt; which has an interesting property. If our number has four bytes, \u0026lt;code\u0026gt;A B C D\u0026lt;/code\u0026gt;, it will result in a new number with these bytes \u0026lt;code\u0026gt;A+B+C+D B+C+D C+D D\u0026lt;/code\u0026gt;. A 4 byte number can have maximum of 32 bits set, which can be represented as \u0026lt;code\u0026gt;0b00100000\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;All we need now is the first byte which has the sum of all set bits in all the bytes, and we get it by  \u0026lt;code\u0026gt;\u0026amp;gt;\u0026amp;gt; 24\u0026lt;/code\u0026gt;. This algorithm was designed for \u0026lt;code\u0026gt;32 bit\u0026lt;/code\u0026gt; words but can be easily modified for \u0026lt;code\u0026gt;64 bit\u0026lt;/code\u0026gt; words.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;If you happen to be using Java, the built-in method \u0026lt;code\u0026gt;Integer.bitCount\u0026lt;/code\u0026gt; will do that.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;I got bored, and timed a billion iterations of three approaches. Compiler is gcc -O3. CPU is whatever they put in the 1st gen Macbook Pro.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Fastest is the following, at 3.7 seconds:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;static unsigned char wordbits[65536] = { bitcounts of ints between 0 and 65535 };\nstatic int popcount( unsigned int i )\n{\n    return( wordbits[i\u0026amp;amp;0xFFFF] + wordbits[i\u0026amp;gt;\u0026amp;gt;16] );\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Second place goes to the same code but looking up 4 bytes instead of 2 halfwords. That took around 5.5 seconds.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Third place goes to the bit-twiddling \u0026apos;sideways addition\u0026apos; approach, which took 8.6 seconds.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Fourth place goes to GCC\u0026apos;s __builtin_popcount(), at a shameful 11 seconds.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;The counting one-bit-at-a-time approach was waaaay slower, and I got bored of waiting for it to complete.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;So if you care about performance above all else then use the first approach. If you care, but not enough to spend 64Kb of RAM on it, use the second approach. Otherwise use the readable (but slow) one-bit-at-a-time approach.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;It\u0026apos;s hard to think of a situation where you\u0026apos;d want to use the bit-twiddling approach.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Edit: Similar results \u0026lt;a href=\u0026quot;http://www.dalkescientific.com/writings/diary/archive/2008/07/03/hakmem_and_other_popcounts.html\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;here\u0026lt;/a\u0026gt;.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;unsigned int count_bit(unsigned int x)\n{\n  x = (x \u0026amp;amp; 0x55555555) + ((x \u0026amp;gt;\u0026amp;gt; 1) \u0026amp;amp; 0x55555555);\n  x = (x \u0026amp;amp; 0x33333333) + ((x \u0026amp;gt;\u0026amp;gt; 2) \u0026amp;amp; 0x33333333);\n  x = (x \u0026amp;amp; 0x0F0F0F0F) + ((x \u0026amp;gt;\u0026amp;gt; 4) \u0026amp;amp; 0x0F0F0F0F);\n  x = (x \u0026amp;amp; 0x00FF00FF) + ((x \u0026amp;gt;\u0026amp;gt; 8) \u0026amp;amp; 0x00FF00FF);\n  x = (x \u0026amp;amp; 0x0000FFFF) + ((x \u0026amp;gt;\u0026amp;gt; 16)\u0026amp;amp; 0x0000FFFF);\n  return x;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Let me explain this algorithm.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;This algorithm is based on Divide and Conquer Algorithm. Suppose there is a 8bit integer 213(11010101 in binary), the algorithm works like this(each time merge two neighbor blocks):\u0026lt;/p\u0026gt;\n\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;+-------------------------------+\n| 1 | 1 | 0 | 1 | 0 | 1 | 0 | 1 |  \u0026amp;lt;- x\n|  1 0  |  0 1  |  0 1  |  0 1  |  \u0026amp;lt;- first time merge\n|    0 0 1 1    |    0 0 1 0    |  \u0026amp;lt;- second time merge\n|        0 0 0 0 0 1 0 1        |  \u0026amp;lt;- third time ( answer = 00000101 = 5)\n+-------------------------------+\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Why not iteratively divide by 2?\u0026lt;/p\u0026gt;\n\n\u0026lt;pre\u0026gt;count = 0\nwhile n \u0026amp;gt; 0\n  if (n % 2) == 1\n    count += 1\n  n /= 2  \n\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;I agree that this isn\u0026apos;t the fastest, but \u0026quot;best\u0026quot; is somewhat ambiguous. I\u0026apos;d argue though that \u0026quot;best\u0026quot; should have an element of clarity\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;This is one of those questions where it helps to know your micro-architecture.   I just timed two variants under gcc 4.3.3 compiled with -O3 using C++ inlines to eliminate function call overhead, one billion iterations, keeping the running sum of all counts to ensure the compiler doesn\u0026apos;t remove anything important, using rdtsc for timing (clock cycle precise).  \u0026lt;/p\u0026gt;\n\n\u0026lt;pre\u0026gt;inline int pop2(unsigned x, unsigned y)\n{\n    x = x - ((x \u0026amp;gt;\u0026amp;gt; 1) \u0026amp;amp; 0x55555555);\n    y = y - ((y \u0026amp;gt;\u0026amp;gt; 1) \u0026amp;amp; 0x55555555);\n    x = (x \u0026amp;amp; 0x33333333) + ((x \u0026amp;gt;\u0026amp;gt; 2) \u0026amp;amp; 0x33333333);\n    y = (y \u0026amp;amp; 0x33333333) + ((y \u0026amp;gt;\u0026amp;gt; 2) \u0026amp;amp; 0x33333333);\n    x = (x + (x \u0026amp;gt;\u0026amp;gt; 4)) \u0026amp;amp; 0x0F0F0F0F;\n    y = (y + (y \u0026amp;gt;\u0026amp;gt; 4)) \u0026amp;amp; 0x0F0F0F0F;\n    x = x + (x \u0026amp;gt;\u0026amp;gt; 8);\n    y = y + (y \u0026amp;gt;\u0026amp;gt; 8);\n    x = x + (x \u0026amp;gt;\u0026amp;gt; 16);\n    y = y + (y \u0026amp;gt;\u0026amp;gt; 16);\n    return (x+y) \u0026amp;amp; 0x000000FF;\n}\n\u0026lt;/pre\u0026gt; \n\n\u0026lt;p\u0026gt;The unmodified Hacker\u0026apos;s Delight took 12.2 gigacycles.  My parallel version (counting twice as many bits) runs in 13.0 gigacycles.  10.5s total elapsed for both together on a 2.4GHz Core Duo.  25 gigacycles = just over 10 seconds at this clock frequency, so I\u0026apos;m confident my timings are right.  \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;This has to do with instruction dependency chains, which are very bad for this algorithm.  I could nearly double the speed again by using a pair of 64-bit registers.  In fact, if I was clever and added x+y a little sooner I could shave off some shifts.  The 64-bit version with some small tweaks would come out about even, but count twice as many bits again.  \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;With 128 bit SIMD registers, yet another factor of two, and the SSE instruction sets often have clever short-cuts, too.  \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;There\u0026apos;s no reason for the code to be especially transparent.  The interface is simple, the algorithm can be referenced on-line in many places, and it\u0026apos;s amenable to comprehensive unit test.  The programmer who stumbles upon it might even learn something.  These bit operations are extremely natural at the machine level.  \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;OK, I decided to bench the tweaked 64-bit version.  For this one  sizeof(unsigned long) == 8 \u0026lt;/p\u0026gt;\n\n\u0026lt;pre\u0026gt;inline int pop2(unsigned long x, unsigned long y)\n{\n    x = x - ((x \u0026amp;gt;\u0026amp;gt; 1) \u0026amp;amp; 0x5555555555555555);\n    y = y - ((y \u0026amp;gt;\u0026amp;gt; 1) \u0026amp;amp; 0x5555555555555555);\n    x = (x \u0026amp;amp; 0x3333333333333333) + ((x \u0026amp;gt;\u0026amp;gt; 2) \u0026amp;amp; 0x3333333333333333);\n    y = (y \u0026amp;amp; 0x3333333333333333) + ((y \u0026amp;gt;\u0026amp;gt; 2) \u0026amp;amp; 0x3333333333333333);\n    x = (x + (x \u0026amp;gt;\u0026amp;gt; 4)) \u0026amp;amp; 0x0F0F0F0F0F0F0F0F;\n    y = (y + (y \u0026amp;gt;\u0026amp;gt; 4)) \u0026amp;amp; 0x0F0F0F0F0F0F0F0F;\n    x = x + y; \n    x = x + (x \u0026amp;gt;\u0026amp;gt; 8);\n    x = x + (x \u0026amp;gt;\u0026amp;gt; 16);\n    x = x + (x \u0026amp;gt;\u0026amp;gt; 32); \n    return x \u0026amp;amp; 0xFF;\n}\n\u0026lt;/pre\u0026gt; \n\n\u0026lt;p\u0026gt;That looks about right (I\u0026apos;m not testing carefully, though).   Now the timings come out at 10.70 gigacycles / 14.1 gigacycles.   That later number summed 128 billion bits and corresponds to 5.9s elapsed on this machine.   The non-parallel version speeds up a tiny bit because I\u0026apos;m running in 64-bit mode and it likes 64-bit registers slightly better than 32-bit registers.  \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Let\u0026apos;s see if there\u0026apos;s a bit more OOO pipelining to be had here.   This was a bit more involved, so I actually tested a bit.  Each term alone sums to 64, all combined sum to 256.  \u0026lt;/p\u0026gt;\n\n\u0026lt;pre\u0026gt;inline int pop4(unsigned long x, unsigned long y, \n                unsigned long u, unsigned long v)\n{\n  enum { m1 = 0x5555555555555555, \n         m2 = 0x3333333333333333, \n         m3 = 0x0F0F0F0F0F0F0F0F, \n         m4 = 0x000000FF000000FF };\n\n    x = x - ((x \u0026amp;gt;\u0026amp;gt; 1) \u0026amp;amp; m1);\n    y = y - ((y \u0026amp;gt;\u0026amp;gt; 1) \u0026amp;amp; m1);\n    u = u - ((u \u0026amp;gt;\u0026amp;gt; 1) \u0026amp;amp; m1);\n    v = v - ((v \u0026amp;gt;\u0026amp;gt; 1) \u0026amp;amp; m1);\n    x = (x \u0026amp;amp; m2) + ((x \u0026amp;gt;\u0026amp;gt; 2) \u0026amp;amp; m2);\n    y = (y \u0026amp;amp; m2) + ((y \u0026amp;gt;\u0026amp;gt; 2) \u0026amp;amp; m2);\n    u = (u \u0026amp;amp; m2) + ((u \u0026amp;gt;\u0026amp;gt; 2) \u0026amp;amp; m2);\n    v = (v \u0026amp;amp; m2) + ((v \u0026amp;gt;\u0026amp;gt; 2) \u0026amp;amp; m2);\n    x = x + y; \n    u = u + v; \n    x = (x \u0026amp;amp; m3) + ((x \u0026amp;gt;\u0026amp;gt; 4) \u0026amp;amp; m3);\n    u = (u \u0026amp;amp; m3) + ((u \u0026amp;gt;\u0026amp;gt; 4) \u0026amp;amp; m3);\n    x = x + u; \n    x = x + (x \u0026amp;gt;\u0026amp;gt; 8);\n    x = x + (x \u0026amp;gt;\u0026amp;gt; 16);\n    x = x \u0026amp;amp; m4; \n    x = x + (x \u0026amp;gt;\u0026amp;gt; 32);\n    return x \u0026amp;amp; 0x000001FF;\n}\n\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;I was excited for a moment, but it turns out gcc is playing inline tricks with -O3 even though I\u0026apos;m not using the inline keyword in some tests.  When I let gcc play tricks, a billion calls to pop4() takes 12.56 gigacycles, but I determined it was folding arguments as constant expressions.   A more realistic number appears to be 19.6gc for another 30% speed-up.  My test loop now looks like this, making sure each argument is different enough to stop gcc from playing tricks.   \u0026lt;/p\u0026gt;\n\n\u0026lt;pre\u0026gt;   hitime b4 = rdtsc(); \n   for (unsigned long i = 10L * 1000*1000*1000; i \u0026amp;lt; 11L * 1000*1000*1000; ++i) \n      sum += pop4 (i,  i^1, ~i, i|1); \n   hitime e4 = rdtsc(); \n\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;256 billion bits summed in 8.17s elapsed.  Works out to 1.02s for 32 million bits as benchmarked in the 16-bit table lookup.  Can\u0026apos;t compare directly, because the other bench doesn\u0026apos;t give a clock speed, but looks like I\u0026apos;ve slapped the snot out of the 64KB table edition, which is a tragic use of L1 cache in the first place.  \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Update: decided to do the obvious and create pop6() by adding four more duplicated lines.  Came out to 22.8gc, 384 billion bits summed in 9.5s elapsed.   So there\u0026apos;s another 20%   Now at 800ms for 32 billion bits.  \u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;The Hacker\u0026apos;s Delight bit-twiddling becomes so much clearer when you write out the bit patterns.  \u0026lt;/p\u0026gt;\n\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;unsigned int bitCount(unsigned int x)\n{\n  x = ((x \u0026amp;gt;\u0026amp;gt; 1) \u0026amp;amp; 0b01010101010101010101010101010101)\n     + (x       \u0026amp;amp; 0b01010101010101010101010101010101);\n  x = ((x \u0026amp;gt;\u0026amp;gt; 2) \u0026amp;amp; 0b00110011001100110011001100110011)\n     + (x       \u0026amp;amp; 0b00110011001100110011001100110011); \n  x = ((x \u0026amp;gt;\u0026amp;gt; 4) \u0026amp;amp; 0b00001111000011110000111100001111)\n     + (x       \u0026amp;amp; 0b00001111000011110000111100001111); \n  x = ((x \u0026amp;gt;\u0026amp;gt; 8) \u0026amp;amp; 0b00000000111111110000000011111111)\n     + (x       \u0026amp;amp; 0b00000000111111110000000011111111); \n  x = ((x \u0026amp;gt;\u0026amp;gt; 16)\u0026amp;amp; 0b00000000000000001111111111111111)\n     + (x       \u0026amp;amp; 0b00000000000000001111111111111111); \n  return x;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;The first step adds the even bits to the odd bits, producing a sum of bits in each two.  The other steps add high-order chunks to low-order chunks, doubling the chunk size all the way up, until we have the final count taking up the entire int.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;For a happy medium between a 2\u0026lt;sup\u0026gt;32\u0026lt;/sup\u0026gt; lookup table and iterating through each bit individually:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;int bitcount(unsigned int num){\n    int count = 0;\n    static int nibblebits[] =\n        {0, 1, 1, 2, 1, 2, 2, 3, 1, 2, 2, 3, 2, 3, 3, 4};\n    for(; num != 0; num \u0026amp;gt;\u0026amp;gt;= 4)\n        count += nibblebits[num \u0026amp;amp; 0x0f];\n    return count;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;From \u0026lt;a href=\u0026quot;http://ctips.pbwiki.com/CountBits\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;http://ctips.pbwiki.com/CountBits\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;This can be done in \u0026lt;code\u0026gt;O(k)\u0026lt;/code\u0026gt;, where \u0026lt;code\u0026gt;k\u0026lt;/code\u0026gt; is the number of bits set.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;int NumberOfSetBits(int n)\n{\n    int count = 0;\n\n    while (n){\n        ++ count;\n        n = (n - 1) \u0026amp;amp; n;\n    }\n\n    return count;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;It\u0026apos;s not the fastest or best solution, but I found the same question in my way, and I started to think and think. finally I realized that it can be done like this if you get the problem from mathematical side, and draw a graph, then you find that it\u0026apos;s a function which has some periodic part, and then you realize the difference between the periods... so here you go:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;unsigned int f(unsigned int x)\n{\n    switch (x) {\n        case 0:\n            return 0;\n        case 1:\n            return 1;\n        case 2:\n            return 1;\n        case 3:\n            return 2;\n        default:\n            return f(x/4) + f(x%4);\n    }\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;I think the \u0026lt;a href=\u0026quot;https://graphics.stanford.edu/~seander/bithacks.html#CountBitsSetKernighan\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;Brian Kernighan\u0026apos;s\u0026lt;/a\u0026gt; method will be useful too...\nIt goes through as many iterations as there are set bits. So if we have a 32-bit word with only the high bit set, then it will only go once through the loop.  \u0026lt;/p\u0026gt;\n\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;int countSetBits(unsigned int n) { \n    unsigned int n; // count the number of bits set in n\n    unsigned int c; // c accumulates the total bits set in n\n    for (c=0;n\u0026amp;gt;0;n=n\u0026amp;amp;(n-1)) c++; \n    return c; \n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;Published in 1988, the C Programming Language 2nd Ed. (by Brian W. Kernighan and Dennis M. Ritchie) mentions this in exercise 2-9. On April 19, 2006 Don Knuth pointed out to me that this method \u0026quot;was first published by Peter Wegner in CACM 3 (1960), 322. (Also discovered independently by Derrick Lehmer and published in 1964 in a book edited by Beckenbach.)\u0026quot;\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n    ","\n\u0026lt;p\u0026gt;The function you are looking for is often called the \u0026quot;sideways sum\u0026quot; or \u0026quot;population count\u0026quot; of a binary number.  Knuth discusses it in pre-Fascicle 1A, pp11-12 (although there was a brief reference in Volume 2, 4.6.3-(7).)\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;The \u0026lt;em\u0026gt;locus classicus\u0026lt;/em\u0026gt; is Peter Wegner\u0026apos;s article \u0026quot;A Technique for Counting Ones in a Binary Computer\u0026quot;, from the \u0026lt;a href=\u0026quot;http://cacm.acm.org/magazines/1960/5/14709-a-technique-for-counting-ones-in-a-binary-computer/abstract\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;\u0026lt;em\u0026gt;Communications of the ACM\u0026lt;/em\u0026gt;, Volume 3 (1960) Number 5, page 322\u0026lt;/a\u0026gt;.  He gives two different algorithms there, one optimized for numbers expected to be \u0026quot;sparse\u0026quot; (i.e., have a small number of ones) and one for the opposite case.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;pre class=\u0026quot;lang-java s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-java\u0026quot;\u0026gt;  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;private\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;get_bits_set\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; v)\u0026lt;/span\u0026gt;\n    {\n      \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; c; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// c accumulates the total bits set in v\u0026lt;/span\u0026gt;\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt; (c = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;; v\u0026amp;gt;\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;; c++)\n        {\n            v \u0026amp;amp;= v - \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// clear the least significant bit set\u0026lt;/span\u0026gt;\n        }\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; c;\n    }\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Few open questions:-\u0026lt;/p\u0026gt;\n\n\u0026lt;ol\u0026gt;\n\u0026lt;li\u0026gt;If the number is negative then?\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;If the number is 1024 , then the \u0026quot;iteratively divide by 2\u0026quot; method will iterate 10 times.\u0026lt;/li\u0026gt;\n\u0026lt;/ol\u0026gt;\n\n\u0026lt;p\u0026gt;we can modify the algo to support the negative number as follows:-\u0026lt;/p\u0026gt;\n\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;count = 0\nwhile n != 0\nif ((n % 2) == 1 || (n % 2) == -1\n    count += 1\n  n /= 2  \nreturn count\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;now to overcome the second problem we can write the algo like:-\u0026lt;/p\u0026gt;\n\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;int bit_count(int num)\n{\n    int count=0;\n    while(num)\n    {\n        num=(num)\u0026amp;amp;(num-1);\n        count++;\n    }\n    return count;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;for complete reference see :\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;a href=\u0026quot;http://goursaha.freeoda.com/Miscellaneous/IntegerBitCount.html\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;http://goursaha.freeoda.com/Miscellaneous/IntegerBitCount.html\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;I use the below code which is more intuitive.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;int countSetBits(int n) {\n    return !n ? 0 : 1 + countSetBits(n \u0026amp;amp; (n-1));\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Logic : n \u0026amp;amp; (n-1)  resets the last set bit of n.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;P.S : I know this is not O(1) solution, albeit an interesting solution.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;What do you means with \u0026quot;Best algorithm\u0026quot;? The shorted code or the fasted code? Your code look very elegant and it has a constant execution time. The code is also very short.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;But if the speed is the major factor and not the code size then I think the follow can be faster:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;       static final int[] BIT_COUNT = { 0, 1, 1, ... 256 values with a bitsize of a byte ... };\n        static int bitCountOfByte( int value ){\n            return BIT_COUNT[ value \u0026amp;amp; 0xFF ];\n        }\n\n        static int bitCountOfInt( int value ){\n            return bitCountOfByte( value ) \n                 + bitCountOfByte( value \u0026amp;gt;\u0026amp;gt; 8 ) \n                 + bitCountOfByte( value \u0026amp;gt;\u0026amp;gt; 16 ) \n                 + bitCountOfByte( value \u0026amp;gt;\u0026amp;gt; 24 );\n        }\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;I think that this will not more faster for a 64 bit value but a 32 bit value can be faster.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;I wrote a fast bitcount macro for RISC machines in about 1990.  It does not use advanced arithmetic (multiplication, division, %), memory fetches (way too slow), branches (way too slow), but it does assume the CPU has a 32-bit barrel shifter (in other words, \u0026amp;gt;\u0026amp;gt; 1 and \u0026amp;gt;\u0026amp;gt; 32 take the same amount of cycles.)  It assumes that small constants (such as 6, 12, 24) cost nothing to load into the registers, or are stored in temporaries and reused over and over again.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;With these assumptions, it counts 32 bits in about 16 cycles/instructions on most RISC machines.  Note that 15 instructions/cycles is close to a lower bound on the number of cycles or instructions, because it seems to take at least 3 instructions (mask, shift, operator) to cut the number of addends in half, so log_2(32) = 5, 5 x 3 = 15 instructions is a quasi-lowerbound.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;#define BitCount(X,Y)           \\\n                Y = X - ((X \u0026amp;gt;\u0026amp;gt; 1) \u0026amp;amp; 033333333333) - ((X \u0026amp;gt;\u0026amp;gt; 2) \u0026amp;amp; 011111111111); \\\n                Y = ((Y + (Y \u0026amp;gt;\u0026amp;gt; 3)) \u0026amp;amp; 030707070707); \\\n                Y =  (Y + (Y \u0026amp;gt;\u0026amp;gt; 6)); \\\n                Y = (Y + (Y \u0026amp;gt;\u0026amp;gt; 12) + (Y \u0026amp;gt;\u0026amp;gt; 24)) \u0026amp;amp; 077;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Here is a secret to the first and most complex step:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;input output\nAB    CD             Note\n00    00             = AB\n01    01             = AB\n10    01             = AB - (A \u0026amp;gt;\u0026amp;gt; 1) \u0026amp;amp; 0x1\n11    10             = AB - (A \u0026amp;gt;\u0026amp;gt; 1) \u0026amp;amp; 0x1\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;so if I take the 1st column (A) above, shift it right 1 bit, and subtract it from AB, I get the output (CD).  The extension to 3 bits is similar; you can check it with an 8-row boolean table like mine above if you wish.\u0026lt;/p\u0026gt;\n\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;Don Gillies\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n    ","\n\u0026lt;p\u0026gt;if you\u0026apos;re using C++ another option is to use template metaprogramming:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;// recursive template to sum bits in an int\ntemplate \u0026amp;lt;int BITS\u0026amp;gt;\nint countBits(int val) {\n        // return the least significant bit plus the result of calling ourselves with\n        // .. the shifted value\n        return (val \u0026amp;amp; 0x1) + countBits\u0026amp;lt;BITS-1\u0026amp;gt;(val \u0026amp;gt;\u0026amp;gt; 1);\n}\n\n// template specialisation to terminate the recursion when there\u0026apos;s only one bit left\ntemplate\u0026amp;lt;\u0026amp;gt;\nint countBits\u0026amp;lt;1\u0026amp;gt;(int val) {\n        return val \u0026amp;amp; 0x1;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;usage would be:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;// to count bits in a byte/char (this returns 8)\ncountBits\u0026amp;lt;8\u0026amp;gt;( 255 )\n\n// another byte (this returns 7)\ncountBits\u0026amp;lt;8\u0026amp;gt;( 254 )\n\n// counting bits in a word/short (this returns 1)\ncountBits\u0026amp;lt;16\u0026amp;gt;( 256 )\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;you could of course further expand this template to use different types (even auto-detecting bit size) but I\u0026apos;ve kept it simple for clarity.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;edit: forgot to mention this is good because it \u0026lt;em\u0026gt;should\u0026lt;/em\u0026gt; work in any C++ compiler and it basically just unrolls your loop for you if a constant value is used for the bit count\u0026lt;/strong\u0026gt; (in other words, I\u0026apos;m pretty sure it\u0026apos;s the fastest general method you\u0026apos;ll find)\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;what you can do is \u0026lt;/p\u0026gt;\n\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;while(n){\n    n=n\u0026amp;amp;(n-1);\n    count++;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;the logic behind this is the bits of n-1 is inverted from rightmost set bit of n.\nif n=6 i.e 110\nthen 5 is 101 the bits are inverted from rightmost set bit of n.\nso if we \u0026amp;amp; these two we will make the rightmost bit 0 in every iteration and always go to the next rightmost set bit.Hence, counting the set bit.The worst time complexity will be O(logn) when every bit is set.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;I\u0026apos;m particularly fond of this example from the fortune file:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre\u0026gt;#define BITCOUNT(x)    (((BX_(x)+(BX_(x)\u0026amp;gt;\u0026amp;gt;4)) \u0026amp;amp; 0x0F0F0F0F) % 255)\n#define BX_(x)         ((x) - (((x)\u0026amp;gt;\u0026amp;gt;1)\u0026amp;amp;0x77777777)\n                             - (((x)\u0026amp;gt;\u0026amp;gt;2)\u0026amp;amp;0x33333333)\n                             - (((x)\u0026amp;gt;\u0026amp;gt;3)\u0026amp;amp;0x11111111))\n\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;I like it best because it\u0026apos;s so pretty!\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Java JDK1.5\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Integer.bitCount(n);\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;where n is the number whose 1\u0026apos;s are to be counted.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;check also,\u0026lt;/p\u0026gt;\n\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;Integer.highestOneBit(n);\nInteger.lowestOneBit(n);\nInteger.numberOfLeadingZeros(n);\nInteger.numberOfTrailingZeros(n);\n\n//Beginning with the value 1, rotate left 16 times\n     n = 1;\n         for (int i = 0; i \u0026amp;lt; 16; i++) {\n            n = Integer.rotateLeft(n, 1);\n            System.out.println(n);\n         }\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Fast C# solution using pre-calculated table of Byte bit counts with branching on input size.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;public static class BitCount\n{\n    public static uint GetSetBitsCount(uint n)\n    {\n        var counts = BYTE_BIT_COUNTS;\n        return n \u0026amp;lt;= 0xff ? counts[n]\n             : n \u0026amp;lt;= 0xffff ? counts[n \u0026amp;amp; 0xff] + counts[n \u0026amp;gt;\u0026amp;gt; 8]\n             : n \u0026amp;lt;= 0xffffff ? counts[n \u0026amp;amp; 0xff] + counts[(n \u0026amp;gt;\u0026amp;gt; 8) \u0026amp;amp; 0xff] + counts[(n \u0026amp;gt;\u0026amp;gt; 16) \u0026amp;amp; 0xff]\n             : counts[n \u0026amp;amp; 0xff] + counts[(n \u0026amp;gt;\u0026amp;gt; 8) \u0026amp;amp; 0xff] + counts[(n \u0026amp;gt;\u0026amp;gt; 16) \u0026amp;amp; 0xff] + counts[(n \u0026amp;gt;\u0026amp;gt; 24) \u0026amp;amp; 0xff];\n    }\n\n    public static readonly uint[] BYTE_BIT_COUNTS = \n    {\n        0, 1, 1, 2, 1, 2, 2, 3, 1, 2, 2, 3, 2, 3, 3, 4,\n        1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5,\n        1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5,\n        2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,\n        1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5,\n        2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,\n        2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,\n        3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7,\n        1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5,\n        2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,\n        2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,\n        3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7,\n        2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,\n        3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7,\n        3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7,\n        4, 5, 5, 6, 5, 6, 6, 7, 5, 6, 6, 7, 6, 7, 7, 8\n    };\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;I found an implementation of bit counting in an array with using of SIMD instruction (SSSE3 and AVX2). It has in 2-2.5 times better performance than if it will use __popcnt64 intrinsic function.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;SSSE3 version:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;#include \u0026amp;lt;smmintrin.h\u0026amp;gt;\n#include \u0026amp;lt;stdint.h\u0026amp;gt;\n\nconst __m128i Z = _mm_set1_epi8(0x0);\nconst __m128i F = _mm_set1_epi8(0xF);\n//Vector with pre-calculated bit count:\nconst __m128i T = _mm_setr_epi8(0, 1, 1, 2, 1, 2, 2, 3, 1, 2, 2, 3, 2, 3, 3, 4);\n\nuint64_t BitCount(const uint8_t * src, size_t size)\n{\n    __m128i _sum =  _mm128_setzero_si128();\n    for (size_t i = 0; i \u0026amp;lt; size; i += 16)\n    {\n        //load 16-byte vector\n        __m128i _src = _mm_loadu_si128((__m128i*)(src + i));\n        //get low 4 bit for every byte in vector\n        __m128i lo = _mm_and_si128(_src, F);\n        //sum precalculated value from T\n        _sum = _mm_add_epi64(_sum, _mm_sad_epu8(Z, _mm_shuffle_epi8(T, lo)));\n        //get high 4 bit for every byte in vector\n        __m128i hi = _mm_and_si128(_mm_srli_epi16(_src, 4), F);\n        //sum precalculated value from T\n        _sum = _mm_add_epi64(_sum, _mm_sad_epu8(Z, _mm_shuffle_epi8(T, hi)));\n    }\n    uint64_t sum[2];\n    _mm_storeu_si128((__m128i*)sum, _sum);\n    return sum[0] + sum[1];\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;AVX2 version:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;#include \u0026amp;lt;immintrin.h\u0026amp;gt;\n#include \u0026amp;lt;stdint.h\u0026amp;gt;\n\nconst __m256i Z = _mm256_set1_epi8(0x0);\nconst __m256i F = _mm256_set1_epi8(0xF);\n//Vector with pre-calculated bit count:\nconst __m256i T = _mm256_setr_epi8(0, 1, 1, 2, 1, 2, 2, 3, 1, 2, 2, 3, 2, 3, 3, 4, \n                                   0, 1, 1, 2, 1, 2, 2, 3, 1, 2, 2, 3, 2, 3, 3, 4);\n\nuint64_t BitCount(const uint8_t * src, size_t size)\n{\n    __m256i _sum =  _mm256_setzero_si256();\n    for (size_t i = 0; i \u0026amp;lt; size; i += 32)\n    {\n        //load 32-byte vector\n        __m256i _src = _mm256_loadu_si256((__m256i*)(src + i));\n        //get low 4 bit for every byte in vector\n        __m256i lo = _mm256_and_si256(_src, F);\n        //sum precalculated value from T\n        _sum = _mm256_add_epi64(_sum, _mm256_sad_epu8(Z, _mm256_shuffle_epi8(T, lo)));\n        //get high 4 bit for every byte in vector\n        __m256i hi = _mm256_and_si256(_mm256_srli_epi16(_src, 4), F);\n        //sum precalculated value from T\n        _sum = _mm256_add_epi64(_sum, _mm256_sad_epu8(Z, _mm256_shuffle_epi8(T, hi)));\n    }\n    uint64_t sum[4];\n    _mm256_storeu_si256((__m256i*)sum, _sum);\n    return sum[0] + sum[1] + sum[2] + sum[3];\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;I always use this in Competitive Programming and it\u0026apos;s easy to write and efficient:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;#include \u0026amp;lt;bits/stdc++.h\u0026amp;gt;\n\nusing namespace std;\n\nint countOnes(int n) {\n    bitset\u0026amp;lt;32\u0026amp;gt; b(n);\n    return b.count();\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;C++20 \u0026lt;code\u0026gt;std::popcount\u0026lt;/code\u0026gt;\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;The following proposal has been merged \u0026lt;a href=\u0026quot;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p0553r4.html\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p0553r4.html\u0026lt;/a\u0026gt; and should add it to a the \u0026lt;code\u0026gt;\u0026amp;lt;bit\u0026amp;gt;\u0026lt;/code\u0026gt; header.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;I expect the usage to be like:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;#include \u0026amp;lt;bit\u0026amp;gt;\n#include \u0026amp;lt;iostream\u0026amp;gt;\n\nint main() {\n    std::cout \u0026amp;lt;\u0026amp;lt; std::popcount(0x55) \u0026amp;lt;\u0026amp;lt; std::endl;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;I\u0026apos;ll give it a try when support arrives to GCC, GCC 9.1.0 with \u0026lt;code\u0026gt;g++-9 -std=c++2a\u0026lt;/code\u0026gt; still doesn\u0026apos;t support it.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;The proposal says:\u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;Header: \u0026lt;code\u0026gt;\u0026amp;lt;bit\u0026amp;gt;\u0026lt;/code\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;namespace std {\n\n  // 25.5.6, counting\n  template\u0026amp;lt;class T\u0026amp;gt;\n    constexpr int popcount(T x) noexcept;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;p\u0026gt;and:\u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;template\u0026amp;lt;class T\u0026amp;gt;\n  constexpr int popcount(T x) noexcept;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n  \n  \u0026lt;p\u0026gt;Constraints: T is an unsigned integer type (3.9.1 [basic.fundamental]).\u0026lt;/p\u0026gt;\n  \n  \u0026lt;p\u0026gt;Returns: The number of 1 bits in the value of x.\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;code\u0026gt;std::rotl\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;std::rotr\u0026lt;/code\u0026gt; were also added to do circular bit rotations: \u0026lt;a href=\u0026quot;https://stackoverflow.com/questions/776508/best-practices-for-circular-shift-rotate-operations-in-c/57285854#57285854\u0026quot;\u0026gt;Best practices for circular shift (rotate) operations in C++\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;There are many algorithm to count the set bits; but i think the best one is the faster one!\nYou can see the detailed on this page:\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;a href=\u0026quot;http://graphics.stanford.edu/~seander/bithacks.html\u0026quot;\u0026gt;Bit Twiddling Hacks\u0026lt;/a\u0026gt; \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;I suggest this one:\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Counting bits set in 14, 24, or 32-bit words using 64-bit instructions\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;unsigned int v; // count the number of bits set in v\nunsigned int c; // c accumulates the total bits set in v\n\n// option 1, for at most 14-bit values in v:\nc = (v * 0x200040008001ULL \u0026amp;amp; 0x111111111111111ULL) % 0xf;\n\n// option 2, for at most 24-bit values in v:\nc =  ((v \u0026amp;amp; 0xfff) * 0x1001001001001ULL \u0026amp;amp; 0x84210842108421ULL) % 0x1f;\nc += (((v \u0026amp;amp; 0xfff000) \u0026amp;gt;\u0026amp;gt; 12) * 0x1001001001001ULL \u0026amp;amp; 0x84210842108421ULL) \n     % 0x1f;\n\n// option 3, for at most 32-bit values in v:\nc =  ((v \u0026amp;amp; 0xfff) * 0x1001001001001ULL \u0026amp;amp; 0x84210842108421ULL) % 0x1f;\nc += (((v \u0026amp;amp; 0xfff000) \u0026amp;gt;\u0026amp;gt; 12) * 0x1001001001001ULL \u0026amp;amp; 0x84210842108421ULL) % \n     0x1f;\nc += ((v \u0026amp;gt;\u0026amp;gt; 24) * 0x1001001001001ULL \u0026amp;amp; 0x84210842108421ULL) % 0x1f;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;This method requires a 64-bit CPU with fast modulus division to be efficient. The first option takes only 3 operations; the second option takes 10; and the third option takes 15. \u0026lt;/p\u0026gt;\n    "]},"randomTags":[{"name":"identity-operator","slug":"identity-operator"},{"name":"attr","slug":"attr"},{"name":"multipartform-data","slug":"multipartform-data"},{"name":"server-side","slug":"server-side"},{"name":"equals","slug":"equals"},{"name":"sql","slug":"sql"},{"name":"cdi","slug":"cdi"},{"name":"abi","slug":"abi"},{"name":"click","slug":"click"},{"name":"environment-variables","slug":"environment-variables"},{"name":"image","slug":"image"},{"name":"action","slug":"action"},{"name":"threetenabp","slug":"threetenabp"},{"name":"pivot-table","slug":"pivot-table"},{"name":"php-password-hash","slug":"php-password-hash"},{"name":"borrow-checker","slug":"borrow-checker"},{"name":"sql-server-2008","slug":"sql-server-2008"},{"name":"move-semantics","slug":"move-semantics"},{"name":"siblings","slug":"siblings"},{"name":"iostream","slug":"iostream"}]},"__N_SSG":true},"page":"/questions/tag/[slug]/page/[page]","query":{"slug":"iec10967","page":"1"},"buildId":"eGqQHYKGZKE-nXShFn8wX","isFallback":false,"gsp":true,"locale":"en","locales":["en"],"defaultLocale":"en","scriptLoader":[]}</script></body></html>