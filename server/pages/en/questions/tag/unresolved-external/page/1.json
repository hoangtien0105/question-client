{"pageProps":{"data":{"count":1,"rows":[{"id":11,"title":"What is an undefined reference/unresolved external symbol error and how do I fix it?","slug":"what-is-an-undefined-referenceunresolved-external-symbol-error-and-how-do-i-fix-it-1657384255179","postType":"QUESTION","createdAt":"2022-07-09T16:30:55.000Z","updatedAt":"2022-07-09T16:30:55.000Z","tags":[{"id":39,"name":"unresolved-external","slug":"unresolved-external","createdAt":"2022-07-09T16:30:55.000Z","updatedAt":"2022-07-09T16:30:55.000Z","Questions_Tags":{"questionId":11,"tagId":39}}]}]},"slug":"unresolved-external","page":"1","answers":{"11":["\n&lt;p&gt;Compiling a C++ program takes place in several steps, as specified by &lt;strong&gt;2.2&lt;/strong&gt; &lt;a href=&quot;https://stackoverflow.com/a/8834196&quot;&gt;(credits to Keith Thompson for the reference)&lt;/a&gt;:&lt;/p&gt;\n&lt;blockquote&gt;\n&lt;p&gt;The precedence among the syntax rules of translation is specified by the following phases &lt;em&gt;[see footnote]&lt;/em&gt;.&lt;/p&gt;\n&lt;ol&gt;\n&lt;li&gt;Physical source file characters are mapped, in an implementation-defined manner, to the basic source character set\n(introducing new-line characters for end-of-line indicators) if\nnecessary. &lt;em&gt;[SNIP]&lt;/em&gt;&lt;/li&gt;\n&lt;li&gt;Each instance of a backslash character (\\) immediately followed by a new-line character is deleted, splicing physical source lines to\nform logical source lines. &lt;em&gt;[SNIP]&lt;/em&gt;&lt;/li&gt;\n&lt;li&gt;The source file is decomposed into preprocessing tokens (2.5) and sequences of white-space characters (including comments). &lt;em&gt;[SNIP]&lt;/em&gt;&lt;/li&gt;\n&lt;li&gt;Preprocessing directives are executed, macro invocations are expanded, and _Pragma unary operator expressions are executed. &lt;em&gt;[SNIP]&lt;/em&gt;&lt;/li&gt;\n&lt;li&gt;Each source character set member in a character literal or a string literal, as well as each escape sequence and universal-character-name\nin a character literal or a non-raw string literal, is converted to\nthe corresponding member of the execution character set; &lt;em&gt;[SNIP]&lt;/em&gt;&lt;/li&gt;\n&lt;li&gt;Adjacent string literal tokens are concatenated.&lt;/li&gt;\n&lt;li&gt;White-space characters separating tokens are no longer significant. Each preprocessing token is converted into a token. (2.7). The\nresulting tokens are syntactically and semantically analyzed and\ntranslated as a translation unit. &lt;em&gt;[SNIP]&lt;/em&gt;&lt;/li&gt;\n&lt;li&gt;Translated translation units and instantiation units are combined as follows: &lt;em&gt;[SNIP]&lt;/em&gt;&lt;/li&gt;\n&lt;li&gt;&lt;strong&gt;All external entity references are resolved. Library components are linked to satisfy external references to entities not defined in the\ncurrent translation. All such translator output is collected into a\nprogram image which contains information needed for execution in its\nexecution environment.&lt;/strong&gt; (emphasis mine)&lt;/li&gt;\n&lt;/ol&gt;\n&lt;p&gt;&lt;em&gt;[footnote]&lt;/em&gt; Implementations must behave as if these separate phases occur, although in practice different phases might be folded together.&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;p&gt;The specified errors occur during this last stage of compilation, most commonly referred to as linking. It basically means that you compiled a bunch of implementation files into object files or libraries and now you want to get them to work together.&lt;/p&gt;\n&lt;p&gt;Say you defined symbol &lt;code&gt;a&lt;/code&gt; in &lt;code&gt;a.cpp&lt;/code&gt;. Now, &lt;code&gt;b.cpp&lt;/code&gt; &lt;em&gt;declared&lt;/em&gt; that symbol and used it. Before linking, it simply assumes that that symbol was defined &lt;em&gt;somewhere&lt;/em&gt;, but it doesn&apos;t yet care where. The linking phase is responsible for finding the symbol and correctly linking it to &lt;code&gt;b.cpp&lt;/code&gt; (well, actually to the object or library that uses it).&lt;/p&gt;\n&lt;p&gt;If you&apos;re using Microsoft Visual Studio, you&apos;ll see that projects generate &lt;code&gt;.lib&lt;/code&gt; files. These contain a table of exported symbols, and a table of imported symbols. The imported symbols are resolved against the libraries you link against, and the exported symbols are provided for the libraries that use that &lt;code&gt;.lib&lt;/code&gt; (if any).&lt;/p&gt;\n&lt;p&gt;Similar mechanisms exist for other compilers/ platforms.&lt;/p&gt;\n&lt;p&gt;Common error messages are &lt;code&gt;error LNK2001&lt;/code&gt;, &lt;code&gt;error LNK1120&lt;/code&gt;, &lt;code&gt;error LNK2019&lt;/code&gt; for &lt;strong&gt;Microsoft Visual Studio&lt;/strong&gt; and &lt;code&gt;undefined reference to&lt;/code&gt; &lt;em&gt;symbolName&lt;/em&gt; for &lt;strong&gt;GCC&lt;/strong&gt;.&lt;/p&gt;\n&lt;p&gt;The code:&lt;/p&gt;\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;X&lt;/span&gt;\n{\n   &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;virtual&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;;\n};\n&lt;span class=&quot;hljs-keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;Y&lt;/span&gt; : X\n{\n   &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;{}\n};\n&lt;span class=&quot;hljs-keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;A&lt;/span&gt;\n{\n   &lt;span class=&quot;hljs-keyword&quot;&gt;virtual&lt;/span&gt; ~&lt;span class=&quot;hljs-built_in&quot;&gt;A&lt;/span&gt;() = &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;;\n};\n&lt;span class=&quot;hljs-keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;B&lt;/span&gt;: A\n{\n   &lt;span class=&quot;hljs-keyword&quot;&gt;virtual&lt;/span&gt; ~&lt;span class=&quot;hljs-built_in&quot;&gt;B&lt;/span&gt;(){}\n};\n&lt;span class=&quot;hljs-keyword&quot;&gt;extern&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; x;\n&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;;\n&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt;\n&lt;/span&gt;{\n   x = &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;;\n   &lt;span class=&quot;hljs-built_in&quot;&gt;foo&lt;/span&gt;();\n   Y y;\n   B b;\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;will generate the following errors with &lt;strong&gt;GCC&lt;/strong&gt;:&lt;/p&gt;\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;/home/AbiSfw/ccvvuHoX.o: In function `main&lt;span class=&quot;hljs-number&quot;&gt;&apos;&lt;/span&gt;:\nprog.cpp:(.text+&lt;span class=&quot;hljs-number&quot;&gt;0x10&lt;/span&gt;): undefined reference to `x&lt;span class=&quot;hljs-number&quot;&gt;&apos;&lt;/span&gt;\nprog.cpp:(.text+&lt;span class=&quot;hljs-number&quot;&gt;0x19&lt;/span&gt;): undefined reference to `&lt;span class=&quot;hljs-built_in&quot;&gt;foo&lt;/span&gt;()&apos;\nprog.cpp:(.text+&lt;span class=&quot;hljs-number&quot;&gt;0x2d&lt;/span&gt;): undefined reference to `A::~&lt;span class=&quot;hljs-built_in&quot;&gt;A&lt;/span&gt;()&apos;\n/home/AbiSfw/ccvvuHoX.o: In function `B::~&lt;span class=&quot;hljs-built_in&quot;&gt;B&lt;/span&gt;()&lt;span class=&quot;hljs-string&quot;&gt;&apos;:\nprog.cpp:(.text._ZN1BD1Ev[B::~B()]+0xb): undefined reference to `A::~A()&apos;&lt;/span&gt;\n/home/AbiSfw/ccvvuHoX.o: In function `B::~&lt;span class=&quot;hljs-built_in&quot;&gt;B&lt;/span&gt;()&lt;span class=&quot;hljs-string&quot;&gt;&apos;:\nprog.cpp:(.text._ZN1BD0Ev[B::~B()]+0x12): undefined reference to `A::~A()&apos;&lt;/span&gt;\n/home/AbiSfw/ccvvuHoX.o:(.rodata._ZTI1Y[typeinfo &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; Y]+&lt;span class=&quot;hljs-number&quot;&gt;0x8&lt;/span&gt;): undefined reference to `typeinfo &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; X&lt;span class=&quot;hljs-number&quot;&gt;&apos;&lt;/span&gt;\n/home/AbiSfw/ccvvuHoX.o:(.rodata._ZTI1B[typeinfo &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; B]+&lt;span class=&quot;hljs-number&quot;&gt;0x8&lt;/span&gt;): undefined reference to `typeinfo &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; A&lt;span class=&quot;hljs-number&quot;&gt;&apos;&lt;/span&gt;\ncollect2: ld returned &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt; exit status\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;and similar errors with &lt;strong&gt;Microsoft Visual Studio&lt;/strong&gt;:&lt;/p&gt;\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;&amp;gt;test2.obj : error LNK2001: unresolved external symbol &lt;span class=&quot;hljs-string&quot;&gt;&quot;void __cdecl foo(void)&quot;&lt;/span&gt; (?foo@@YAXXZ)\n&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;&amp;gt;test2.obj : error LNK2001: unresolved external symbol &lt;span class=&quot;hljs-string&quot;&gt;&quot;int x&quot;&lt;/span&gt; (?x@@&lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;HA)\n&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;&amp;gt;test2.obj : error LNK2001: unresolved external symbol &lt;span class=&quot;hljs-string&quot;&gt;&quot;public: virtual __thiscall A::~A(void)&quot;&lt;/span&gt; (??&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;A@@UAE@XZ)\n&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;&amp;gt;test2.obj : error LNK2001: unresolved external symbol &lt;span class=&quot;hljs-string&quot;&gt;&quot;public: virtual void __thiscall X::foo(void)&quot;&lt;/span&gt; (?foo@X@@UAEXXZ)\n&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;&amp;gt;...\\test2.exe : fatal error LNK1120: &lt;span class=&quot;hljs-number&quot;&gt;4&lt;/span&gt; unresolved externals\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;Common causes include:&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=&quot;https://stackoverflow.com/a/12574400&quot;&gt;Failure to link against appropriate libraries/object files or compile implementation files&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=&quot;https://stackoverflow.com/a/12574403&quot;&gt;Declared and undefined variable or function.&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=&quot;https://stackoverflow.com/a/12574407&quot;&gt;Common issues with class-type members&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=&quot;https://stackoverflow.com/a/12574417&quot;&gt;Template implementations not visible.&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=&quot;https://stackoverflow.com/a/12574420&quot;&gt;Symbols were defined in a C program and used in C++ code.&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=&quot;https://stackoverflow.com/a/12574423&quot;&gt;Incorrectly importing/exporting methods/classes across modules/dll. (MSVS specific)&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=&quot;https://stackoverflow.com/a/20358542&quot;&gt;Circular library dependency&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=&quot;https://stackoverflow.com/questions/5259714/undefined-reference-to-winmain16/5260237#5260237&quot;&gt;undefined reference to `WinMain@16&apos;&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=&quot;https://stackoverflow.com/a/24675715&quot;&gt;Interdependent library order&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=&quot;https://stackoverflow.com/questions/14364362/visualstudio-project-with-multiple-sourcefiles-of-the-same-name&quot;&gt;Multiple source files of the same name&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=&quot;https://stackoverflow.com/a/25744263&quot;&gt;Mistyping or not including the .lib extension when using the &lt;code&gt;#pragma&lt;/code&gt; (Microsoft Visual Studio)&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=&quot;https://stackoverflow.com/a/35891188&quot;&gt;Problems with template friends&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=&quot;https://stackoverflow.com/a/36475406&quot;&gt;Inconsistent &lt;code&gt;UNICODE&lt;/code&gt; definitions&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=&quot;https://stackoverflow.com/a/45478255&quot;&gt;Missing &quot;extern&quot; in const variable declarations/definitions (C++ only)&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=&quot;https://stackoverflow.com/a/72328407/775806&quot;&gt;Visual Studio Code not configured for a multiple file project&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n    ","\n&lt;h2&gt;Class members:&lt;/h2&gt;\n\n&lt;h3&gt;A pure &lt;code&gt;virtual&lt;/code&gt; destructor needs an implementation.&lt;/h3&gt;\n\n&lt;p&gt;Declaring a destructor pure still requires you to define it (unlike a regular function):&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;X&lt;/span&gt;\n{\n    &lt;span class=&quot;hljs-keyword&quot;&gt;virtual&lt;/span&gt; ~&lt;span class=&quot;hljs-built_in&quot;&gt;X&lt;/span&gt;() = &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;;\n};\n&lt;span class=&quot;hljs-keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;Y&lt;/span&gt; : X\n{\n    ~&lt;span class=&quot;hljs-built_in&quot;&gt;Y&lt;/span&gt;() {}\n};\n&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt;\n&lt;/span&gt;{\n    Y y;\n}\n&lt;span class=&quot;hljs-comment&quot;&gt;//X::~X(){} //uncomment this line for successful definition&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;This happens because base class destructors are called when the object is destroyed implicitly, so a definition is required.    &lt;/p&gt;\n\n&lt;h3&gt;&lt;code&gt;virtual&lt;/code&gt; methods must either be implemented or defined as pure.&lt;/h3&gt;\n\n&lt;p&gt;This is similar to non-&lt;code&gt;virtual&lt;/code&gt; methods with no definition, with the added reasoning that \nthe pure declaration generates a dummy vtable and you might get the linker error without using the function:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;X&lt;/span&gt;\n{\n    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;virtual&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;;\n};\n&lt;span class=&quot;hljs-keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;Y&lt;/span&gt; : X\n{\n   &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;{}\n};\n&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt;\n&lt;/span&gt;{\n   Y y; &lt;span class=&quot;hljs-comment&quot;&gt;//linker error although there was no call to X::foo&lt;/span&gt;\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;For this to work, declare &lt;code&gt;X::foo()&lt;/code&gt; as pure:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;X&lt;/span&gt;\n{\n    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;virtual&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;= &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;;\n};\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;h3&gt;Non-&lt;code&gt;virtual&lt;/code&gt; class members&lt;/h3&gt;\n\n&lt;p&gt;Some members need to be defined even if not used explicitly:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;A&lt;/span&gt;\n{ \n    ~&lt;span class=&quot;hljs-built_in&quot;&gt;A&lt;/span&gt;();\n};\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;The following would yield the error:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;A a;      &lt;span class=&quot;hljs-comment&quot;&gt;//destructor undefined&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;The implementation can be inline, in the class definition itself:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;A&lt;/span&gt;\n{ \n    ~&lt;span class=&quot;hljs-built_in&quot;&gt;A&lt;/span&gt;() {}\n};\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;or outside:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;A::~&lt;span class=&quot;hljs-built_in&quot;&gt;A&lt;/span&gt;() {}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;If the implementation is outside the class definition, but in a header, the methods have to be marked as &lt;code&gt;inline&lt;/code&gt; to prevent a multiple definition.&lt;/p&gt;\n\n&lt;p&gt;All used member methods need to be defined if used.&lt;/p&gt;\n\n&lt;h3&gt;A common mistake is forgetting to qualify the name:&lt;/h3&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;A&lt;/span&gt;\n{\n   &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;;\n};\n\n&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;{}\n\n&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt;\n&lt;/span&gt;{\n   A a;\n   a.&lt;span class=&quot;hljs-built_in&quot;&gt;foo&lt;/span&gt;();\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;The definition should be&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;A::foo&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;{}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;h3&gt;&lt;code&gt;static&lt;/code&gt; data members must be defined outside the class in a &lt;strong&gt;single translation unit&lt;/strong&gt;:&lt;/h3&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;X&lt;/span&gt;\n{\n    &lt;span class=&quot;hljs-type&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; x;\n};\n&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt;\n&lt;/span&gt;{\n    &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; x = X::x;\n}\n&lt;span class=&quot;hljs-comment&quot;&gt;//int X::x; //uncomment this line to define X::x&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;An initializer can be provided for a &lt;code&gt;static&lt;/code&gt; &lt;code&gt;const&lt;/code&gt; data member of integral or enumeration type within the class definition; however, odr-use of this member will still require a namespace scope definition as described above. C++11 allows initialization inside the class for all &lt;code&gt;static const&lt;/code&gt; data members.&lt;/p&gt;\n    ","\n&lt;h3&gt;Failure to link against appropriate libraries/object files or compile implementation files&lt;/h3&gt;\n&lt;p&gt;Commonly, each translation unit will generate an object file that contains the definitions of the symbols defined in that translation unit.\nTo use those symbols, you have to link against those object files.&lt;/p&gt;\n&lt;p&gt;Under &lt;strong&gt;gcc&lt;/strong&gt; you would specify all object files that are to be linked together in the command line, or compile the implementation files together.&lt;/p&gt;\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;g++ -o test objectFile1.o objectFile2.o -lLibraryName\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;&lt;code&gt;-l...&lt;/code&gt; must be to the right of any &lt;code&gt;.o&lt;/code&gt;/&lt;code&gt;.c&lt;/code&gt;/&lt;code&gt;.cpp&lt;/code&gt; files.&lt;/p&gt;\n&lt;p&gt;The &lt;code&gt;libraryName&lt;/code&gt; here is just the bare name of the library, without platform-specific additions. So e.g. on Linux library files are usually called &lt;code&gt;libfoo.so&lt;/code&gt; but you&apos;d only write &lt;code&gt;-lfoo&lt;/code&gt;. On Windows that same file might be called &lt;code&gt;foo.lib&lt;/code&gt;, but you&apos;d use the same argument. You might have to add the directory where those files can be found using &lt;code&gt;-Ldirectory&lt;/code&gt;. Make sure to not write a space after &lt;code&gt;-l&lt;/code&gt; or &lt;code&gt;-L&lt;/code&gt;.&lt;/p&gt;\n&lt;p&gt;For &lt;strong&gt;XCode&lt;/strong&gt;:  Add the User Header Search Paths -&amp;gt; add the Library Search Path -&amp;gt; drag and drop the actual library reference into the project folder.&lt;/p&gt;\n&lt;p&gt;Under &lt;strong&gt;MSVS&lt;/strong&gt;, files added to a project automatically have their object files linked together and a &lt;code&gt;lib&lt;/code&gt; file would be generated (in common usage). To use the symbols in a separate project, you&apos;d\nneed to include the &lt;code&gt;lib&lt;/code&gt; files in the project settings. This is done in the Linker section of the project properties, in &lt;code&gt;Input -&amp;gt; Additional Dependencies&lt;/code&gt;. (the path to the &lt;code&gt;lib&lt;/code&gt; file should be\nadded in &lt;code&gt;Linker -&amp;gt; General -&amp;gt; Additional Library Directories&lt;/code&gt;) When using a third-party library that is provided with a &lt;code&gt;lib&lt;/code&gt; file, failure to do so usually results in the error.&lt;/p&gt;\n&lt;p&gt;It can also happen that you forget to add the file to the compilation, in which case the object file won&apos;t be generated. In &lt;strong&gt;gcc&lt;/strong&gt; you&apos;d add the files to the command line. In &lt;strong&gt;MSVS&lt;/strong&gt; adding the file to the project will make it compile it automatically (albeit files can, manually, be individually excluded from the build).&lt;/p&gt;\n&lt;p&gt;In Windows programming, the tell-tale sign that you did not link a necessary library is that the name of the unresolved symbol begins with &lt;code&gt;__imp_&lt;/code&gt;. Look up the name of the function in the documentation, and it should say which library you need to use. For example, MSDN puts the information in a box at the bottom of each function in a section called &quot;Library&quot;.&lt;/p&gt;\n    ","\n&lt;h3&gt;Declared but did not define a variable or function.&lt;/h3&gt;\n&lt;p&gt;A typical variable declaration is&lt;/p&gt;\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;extern&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; x;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;As this is only a declaration, a &lt;strong&gt;single definition&lt;/strong&gt; is needed. A corresponding definition would be:&lt;/p&gt;\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; x;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;For example, the following would generate an error:&lt;/p&gt;\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;extern&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; x;\n&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt;\n&lt;/span&gt;{\n    x = &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;;\n}\n&lt;span class=&quot;hljs-comment&quot;&gt;//int x; // uncomment this line for successful definition&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;Similar remarks apply to functions. Declaring a function without defining it leads to the error:&lt;/p&gt;\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;; &lt;span class=&quot;hljs-comment&quot;&gt;// declaration only&lt;/span&gt;\n&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt;\n&lt;/span&gt;{\n   &lt;span class=&quot;hljs-built_in&quot;&gt;foo&lt;/span&gt;();\n}\n&lt;span class=&quot;hljs-comment&quot;&gt;//void foo() {} //uncomment this line for successful definition&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;Be careful that the function you implement exactly matches the one you declared. For example, you may have mismatched cv-qualifiers:&lt;/p&gt;\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt;&amp;amp; x)&lt;/span&gt;&lt;/span&gt;;\n&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt;\n&lt;/span&gt;{\n   &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; x;\n   &lt;span class=&quot;hljs-built_in&quot;&gt;foo&lt;/span&gt;(x);\n}\n&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-type&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt;&amp;amp; x)&lt;/span&gt; &lt;/span&gt;{} &lt;span class=&quot;hljs-comment&quot;&gt;//different function, doesn&apos;t provide a definition&lt;/span&gt;\n                          &lt;span class=&quot;hljs-comment&quot;&gt;//for void foo(int&amp;amp; x)&lt;/span&gt;\n                          \n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;Other examples of mismatches include&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;Function/variable declared in one namespace, defined in another.&lt;/li&gt;\n&lt;li&gt;Function/variable declared as class member, defined as global (or vice versa).&lt;/li&gt;\n&lt;li&gt;Function return type, parameter number and types, and calling convention do not all exactly agree.&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;The error message from the compiler will often give you the full declaration of the variable or function that was declared but never defined. Compare it closely to the definition you provided. &lt;em&gt;Make sure every detail matches.&lt;/em&gt;&lt;/p&gt;\n    ","\n&lt;h3&gt;The order in which interdependent linked libraries are specified is wrong.&lt;/h3&gt;\n&lt;p&gt;The order in which libraries are linked DOES matter if the libraries depend on each other. In general, if library &lt;code&gt;A&lt;/code&gt; depends on library &lt;code&gt;B&lt;/code&gt;, then &lt;code&gt;libA&lt;/code&gt; &lt;strong&gt;MUST&lt;/strong&gt; appear before &lt;code&gt;libB&lt;/code&gt; in the linker flags.&lt;/p&gt;\n&lt;p&gt;For example:&lt;/p&gt;\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-comment&quot;&gt;// B.h&lt;/span&gt;\n&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;ifndef&lt;/span&gt; B_H&lt;/span&gt;\n&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;define&lt;/span&gt; B_H&lt;/span&gt;\n\n&lt;span class=&quot;hljs-keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;B&lt;/span&gt; {\n    &lt;span class=&quot;hljs-built_in&quot;&gt;B&lt;/span&gt;(&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt;);\n    &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; x;\n};\n\n&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;endif&lt;/span&gt;&lt;/span&gt;\n\n&lt;span class=&quot;hljs-comment&quot;&gt;// B.cpp&lt;/span&gt;\n&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;B.h&quot;&lt;/span&gt;&lt;/span&gt;\nB::&lt;span class=&quot;hljs-built_in&quot;&gt;B&lt;/span&gt;(&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; xx) : &lt;span class=&quot;hljs-built_in&quot;&gt;x&lt;/span&gt;(xx) {}\n\n&lt;span class=&quot;hljs-comment&quot;&gt;// A.h&lt;/span&gt;\n&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;B.h&quot;&lt;/span&gt;&lt;/span&gt;\n\n&lt;span class=&quot;hljs-keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;A&lt;/span&gt; {\n    &lt;span class=&quot;hljs-built_in&quot;&gt;A&lt;/span&gt;(&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; x);\n    B b;\n};\n\n&lt;span class=&quot;hljs-comment&quot;&gt;// A.cpp&lt;/span&gt;\n&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;A.h&quot;&lt;/span&gt;&lt;/span&gt;\n\nA::&lt;span class=&quot;hljs-built_in&quot;&gt;A&lt;/span&gt;(&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; x) : &lt;span class=&quot;hljs-built_in&quot;&gt;b&lt;/span&gt;(x) {}\n\n&lt;span class=&quot;hljs-comment&quot;&gt;// main.cpp&lt;/span&gt;\n&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;A.h&quot;&lt;/span&gt;&lt;/span&gt;\n\n&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;{\n    &lt;span class=&quot;hljs-function&quot;&gt;A &lt;span class=&quot;hljs-title&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;;\n    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;;\n};\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;Create the libraries:&lt;/p&gt;\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;$ g++ -c A.cpp\n$ g++ -c B.cpp\n$ ar rvs libA.a A.o \nar: creating libA.a\na - A.o\n$ ar rvs libB.a B.o \nar: creating libB.a\na - B.o\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;Compile:&lt;/p&gt;\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;$ g++ main.cpp -L. -lB -lA\n./libA.&lt;span class=&quot;hljs-built_in&quot;&gt;a&lt;/span&gt;(A.o): In function `A::&lt;span class=&quot;hljs-built_in&quot;&gt;A&lt;/span&gt;(&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt;)&lt;span class=&quot;hljs-string&quot;&gt;&apos;:\nA.cpp:(.text+0x1c): undefined reference to `B::B(int)&apos;&lt;/span&gt;\ncollect2: error: ld returned &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt; exit status\n$ g++ main.cpp -L. -lA -lB\n$ ./a.out\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;So to repeat again, the order &lt;strong&gt;DOES&lt;/strong&gt; matter!&lt;/p&gt;\n    ","\n&lt;p&gt;&lt;strong&gt;what is an &quot;undefined reference/unresolved external symbol&quot;&lt;/strong&gt;&lt;/p&gt;\n\n&lt;p&gt;I&apos;ll try to explain what is an &quot;undefined reference/unresolved external symbol&quot;.&lt;/p&gt;\n\n&lt;blockquote&gt;\n  &lt;p&gt;note: i use g++ and Linux and all examples is for it &lt;/p&gt;\n&lt;/blockquote&gt;\n\n&lt;p&gt;For example we have some code&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-comment&quot;&gt;// src1.cpp&lt;/span&gt;\n&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;;\n\n&lt;span class=&quot;hljs-type&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; local_var_name; &lt;span class=&quot;hljs-comment&quot;&gt;// &apos;static&apos; makes variable not visible for other modules&lt;/span&gt;\n&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; global_var_name = &lt;span class=&quot;hljs-number&quot;&gt;123&lt;/span&gt;;\n\n&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt;\n&lt;/span&gt;{\n    &lt;span class=&quot;hljs-built_in&quot;&gt;print&lt;/span&gt;();\n    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;;\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;and&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-comment&quot;&gt;// src2.cpp&lt;/span&gt;\n&lt;span class=&quot;hljs-keyword&quot;&gt;extern&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;C&quot;&lt;/span&gt; &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;printf&lt;/span&gt; &lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-type&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;char&lt;/span&gt;*, ...)&lt;/span&gt;&lt;/span&gt;;\n\n&lt;span class=&quot;hljs-keyword&quot;&gt;extern&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; global_var_name;\n&lt;span class=&quot;hljs-comment&quot;&gt;//extern int local_var_name;&lt;/span&gt;\n\n&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt;\n&lt;/span&gt;{\n    &lt;span class=&quot;hljs-comment&quot;&gt;// printf(&quot;%d%d\\n&quot;, global_var_name, local_var_name);&lt;/span&gt;\n    &lt;span class=&quot;hljs-built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;%d\\n&quot;&lt;/span&gt;, global_var_name);\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Make object files&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;$ g++ -c src1.cpp -o src1.o\n$ g++ -c src2.cpp -o src2.o\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;After the assembler phase we have an object file, which contains any symbols to export. \nLook at the symbols&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;$ readelf --symbols src1.o\n  Num:    Value          Size Type    Bind   Vis      Ndx Name\n     &lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt;: &lt;span class=&quot;hljs-number&quot;&gt;0000000000000000&lt;/span&gt;     &lt;span class=&quot;hljs-number&quot;&gt;4&lt;/span&gt; OBJECT  LOCAL  DEFAULT    &lt;span class=&quot;hljs-number&quot;&gt;4&lt;/span&gt; _ZL14local_var_name # [&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;]\n     &lt;span class=&quot;hljs-number&quot;&gt;9&lt;/span&gt;: &lt;span class=&quot;hljs-number&quot;&gt;0000000000000000&lt;/span&gt;     &lt;span class=&quot;hljs-number&quot;&gt;4&lt;/span&gt; OBJECT  GLOBAL DEFAULT    &lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt; global_var_name     # [&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;]\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;I&apos;ve rejected some lines from output, because they do not matter&lt;/p&gt;\n\n&lt;p&gt;So, we see follow symbols to export.&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;[&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;] - &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;this&lt;/span&gt; is our &lt;span class=&quot;hljs-title&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;hljs-params&quot;&gt;(local)&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;variable&lt;/span&gt; &lt;span class=&quot;hljs-params&quot;&gt;(important - Bind has a type &lt;span class=&quot;hljs-string&quot;&gt;&quot;LOCAL&quot;&lt;/span&gt;)&lt;/span&gt;\n[2] - &lt;span class=&quot;hljs-keyword&quot;&gt;this&lt;/span&gt; is our global variable\n&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;src2.cpp exports nothing and we have seen no its symbols&lt;/p&gt;\n\n&lt;p&gt;Link our object files&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;$ g++ src1.o src2.o -o prog\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;and run it&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;$ ./prog\n&lt;span class=&quot;hljs-number&quot;&gt;123&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Linker sees exported symbols and links it. Now we try to uncomment lines in src2.cpp like here&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-comment&quot;&gt;// src2.cpp&lt;/span&gt;\n&lt;span class=&quot;hljs-keyword&quot;&gt;extern&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;C&quot;&lt;/span&gt; &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;printf&lt;/span&gt; &lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-type&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;char&lt;/span&gt;*, ...)&lt;/span&gt;&lt;/span&gt;;\n\n&lt;span class=&quot;hljs-keyword&quot;&gt;extern&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; global_var_name;\n&lt;span class=&quot;hljs-keyword&quot;&gt;extern&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; local_var_name;\n\n&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt;\n&lt;/span&gt;{\n    &lt;span class=&quot;hljs-built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;%d%d\\n&quot;&lt;/span&gt;, global_var_name, local_var_name);\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;and rebuild an object file&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;$ g++ -c src2.cpp -o src2.o\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;OK (no errors), because we only build object file, linking is not done yet.\nTry to link&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;$ g++ src1.o src2.o -o prog\nsrc2.o: In function `&lt;span class=&quot;hljs-built_in&quot;&gt;print&lt;/span&gt;()&lt;span class=&quot;hljs-string&quot;&gt;&apos;:\nsrc2.cpp:(.text+0x6): undefined reference to `local_var_name&apos;&lt;/span&gt;\ncollect2: error: ld returned &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt; exit status\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;It has happened because our local_var_name is static, i.e. it is not visible for other modules. \nNow more deeply. Get the translation phase output&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;$ g++ -S src1.cpp -o src1.s\n\n&lt;span class=&quot;hljs-comment&quot;&gt;// src1.s&lt;/span&gt;\nlook src1.s\n\n    .file   &lt;span class=&quot;hljs-string&quot;&gt;&quot;src1.cpp&quot;&lt;/span&gt;\n    .local  _ZL14local_var_name\n    .comm   _ZL14local_var_name,&lt;span class=&quot;hljs-number&quot;&gt;4&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;4&lt;/span&gt;\n    .globl  global_var_name\n    .data\n    .align &lt;span class=&quot;hljs-number&quot;&gt;4&lt;/span&gt;\n    .type   global_var_name, @object\n    .size   global_var_name, &lt;span class=&quot;hljs-number&quot;&gt;4&lt;/span&gt;\nglobal_var_name:\n    .&lt;span class=&quot;hljs-type&quot;&gt;long&lt;/span&gt;   &lt;span class=&quot;hljs-number&quot;&gt;123&lt;/span&gt;\n    .text\n    .globl  main\n    .type   main, @function\nmain:\n; assembler code, &lt;span class=&quot;hljs-keyword&quot;&gt;not&lt;/span&gt; interesting &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; us\n.LFE0:\n    .size   main, .-main\n    .ident  &lt;span class=&quot;hljs-string&quot;&gt;&quot;GCC: (Ubuntu 4.8.2-19ubuntu1) 4.8.2&quot;&lt;/span&gt;\n    .section    .note.GNU-stack,&lt;span class=&quot;hljs-string&quot;&gt;&quot;&quot;&lt;/span&gt;,@progbits\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;So, we&apos;ve seen there is no label for local_var_name, that&apos;s why linker hasn&apos;t found it. But we are hackers :) and we can fix it. Open src1.s in your text editor and change&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;.local  _ZL14local_var_name\n.comm   _ZL14local_var_name,&lt;span class=&quot;hljs-number&quot;&gt;4&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;4&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;to &lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;    .globl  local_var_name\n    .data\n    .align &lt;span class=&quot;hljs-number&quot;&gt;4&lt;/span&gt;\n    .type   local_var_name, @object\n    .size   local_var_name, &lt;span class=&quot;hljs-number&quot;&gt;4&lt;/span&gt;\nlocal_var_name:\n    .&lt;span class=&quot;hljs-type&quot;&gt;long&lt;/span&gt;   &lt;span class=&quot;hljs-number&quot;&gt;456789&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;i.e. you should have like below&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;    .file   &lt;span class=&quot;hljs-string&quot;&gt;&quot;src1.cpp&quot;&lt;/span&gt;\n    .globl  local_var_name\n    .data\n    .align &lt;span class=&quot;hljs-number&quot;&gt;4&lt;/span&gt;\n    .type   local_var_name, @object\n    .size   local_var_name, &lt;span class=&quot;hljs-number&quot;&gt;4&lt;/span&gt;\nlocal_var_name:\n    .&lt;span class=&quot;hljs-type&quot;&gt;long&lt;/span&gt;   &lt;span class=&quot;hljs-number&quot;&gt;456789&lt;/span&gt;\n    .globl  global_var_name\n    .align &lt;span class=&quot;hljs-number&quot;&gt;4&lt;/span&gt;\n    .type   global_var_name, @object\n    .size   global_var_name, &lt;span class=&quot;hljs-number&quot;&gt;4&lt;/span&gt;\nglobal_var_name:\n    .&lt;span class=&quot;hljs-type&quot;&gt;long&lt;/span&gt;   &lt;span class=&quot;hljs-number&quot;&gt;123&lt;/span&gt;\n    .text\n    .globl  main\n    .type   main, @function\nmain:\n; ...\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;we have changed the visibility of local_var_name and set its value to 456789.\nTry to build an object file from it&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;$ g++ -c src1.s -o src2.o\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;ok, see readelf output (symbols)&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;$ readelf --symbols src1.o\n&lt;span class=&quot;hljs-number&quot;&gt;8&lt;/span&gt;: &lt;span class=&quot;hljs-number&quot;&gt;0000000000000000&lt;/span&gt;     &lt;span class=&quot;hljs-number&quot;&gt;4&lt;/span&gt; OBJECT  GLOBAL DEFAULT    &lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt; local_var_name\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;now local_var_name has Bind GLOBAL (was LOCAL)&lt;/p&gt;\n\n&lt;p&gt;link&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;$ g++ src1.o src2.o -o prog\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;and run it&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;$ ./prog \n&lt;span class=&quot;hljs-number&quot;&gt;123456789&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;ok, we hack it :)&lt;/p&gt;\n\n&lt;p&gt;So, as a result - an &quot;undefined reference/unresolved external symbol error&quot; happens when the linker cannot find global symbols in the object files.&lt;/p&gt;\n    ","\n&lt;h3&gt;Symbols were defined in a C program and used in C++ code.&lt;/h3&gt;\n&lt;p&gt;The function (or variable) &lt;code&gt;void foo()&lt;/code&gt; was defined in a C program and you attempt to use it in a C++ program:&lt;/p&gt;\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;;\n&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt;\n&lt;/span&gt;{\n    &lt;span class=&quot;hljs-built_in&quot;&gt;foo&lt;/span&gt;();\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;The C++ linker expects names to be mangled, so you have to declare the function as:&lt;/p&gt;\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;extern&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;C&quot;&lt;/span&gt; &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;;\n&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt;\n&lt;/span&gt;{\n    &lt;span class=&quot;hljs-built_in&quot;&gt;foo&lt;/span&gt;();\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;Equivalently, instead of being defined in a C program, the function (or variable) &lt;code&gt;void foo()&lt;/code&gt; was defined in C++ but with C linkage:&lt;/p&gt;\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;extern&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;C&quot;&lt;/span&gt; &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;and you attempt to use it in a C++ program with C++ linkage.&lt;/p&gt;\n&lt;p&gt;If an entire library is included in a header file (and was compiled as C code); the include will need to be as follows;&lt;/p&gt;\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;extern&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;C&quot;&lt;/span&gt; {\n    &lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;cheader.h&quot;&lt;/span&gt;&lt;/span&gt;\n}\n&lt;/code&gt;&lt;/pre&gt;\n    ","\n&lt;p&gt;&lt;strong&gt;If all else fails, recompile.&lt;/strong&gt;&lt;/p&gt;\n\n&lt;p&gt;I was recently able to get rid of an unresolved external error in Visual Studio 2012 just by recompiling the offending file. When I re-built, the error went away. &lt;/p&gt;\n\n&lt;p&gt;This usually happens when two (or more) libraries have a cyclic dependency. Library A attempts to use symbols in B.lib and library B attempts to use symbols from A.lib. Neither exist to start off with. When you attempt to compile A, the link step will fail because it can&apos;t find B.lib. A.lib will be generated, but no dll. You then compile B, which will succeed and generate B.lib. Re-compiling A will now work because B.lib is now found.&lt;/p&gt;\n    ","\n&lt;h3&gt;Template implementations not visible.&lt;/h3&gt;\n&lt;p&gt;Unspecialized templates must have their definitions visible to all translation units that use them. That means you can&apos;t separate the definition of a template\nto an implementation file. If you must separate the implementation, the usual workaround is to have an &lt;code&gt;impl&lt;/code&gt; file which you include at the end of the header that\ndeclares the template. A common situation is:&lt;/p&gt;\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;template&lt;/span&gt;&amp;lt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;T&lt;/span&gt;&amp;gt;\n&lt;span class=&quot;hljs-keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;X&lt;/span&gt;\n{\n    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;;\n};\n\n&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt;\n&lt;/span&gt;{\n    X&amp;lt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt;&amp;gt; x;\n    x.&lt;span class=&quot;hljs-built_in&quot;&gt;foo&lt;/span&gt;();\n}\n\n&lt;span class=&quot;hljs-comment&quot;&gt;//differentImplementationFile.cpp&lt;/span&gt;\n&lt;span class=&quot;hljs-keyword&quot;&gt;template&lt;/span&gt;&amp;lt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;T&lt;/span&gt;&amp;gt;\n&lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt; X&amp;lt;T&amp;gt;::&lt;span class=&quot;hljs-built_in&quot;&gt;foo&lt;/span&gt;()\n{\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;To fix this, you must move the definition of &lt;code&gt;X::foo&lt;/code&gt; to the header file or some place visible to the translation unit that uses it.&lt;/p&gt;\n&lt;p&gt;Specialized templates can be implemented in an implementation file and the implementation doesn&apos;t have to be visible, but the specialization must be previously declared.&lt;/p&gt;\n&lt;p&gt;For further explanation and another possible solution (explicit instantiation) see &lt;a href=&quot;https://stackoverflow.com/questions/495021&quot;&gt;this question and answer&lt;/a&gt;.&lt;/p&gt;\n    ","\n&lt;p&gt;This is one of most confusing error messages that every VC++ programmers have seen time and time again. Lets make things clarity first.&lt;/p&gt;\n\n&lt;p&gt;&lt;strong&gt;A. What is symbol?&lt;/strong&gt;\nIn short, a symbol is a name. It can be a variable name, a function name, a class name, a typedef name, or anything except those names and signs that belong to C++ language. It is user defined or introduced by a dependency library (another user-defined).&lt;/p&gt;\n\n&lt;p&gt;&lt;strong&gt;B. What is external?&lt;/strong&gt;\nIn VC++, every source file (.cpp,.c,etc.) is considered as a translation unit, the compiler compiles one unit at a time, and generate one object file(.obj) for the current translation unit. (Note that every header file that this source file included will be preprocessed and will be considered as part of this translation unit)Everything within a translation unit is considered as internal, everything else is considered as external. In C++, you may reference an external symbol by using keywords like &lt;code&gt;extern&lt;/code&gt;, &lt;code&gt;__declspec (dllimport)&lt;/code&gt; and so on.&lt;/p&gt;\n\n&lt;p&gt;&lt;strong&gt;C. What is resolve?&lt;/strong&gt;\nResolve is a linking-time term. In linking-time, linker attempts to find the external definition for every symbol in object files that cannot find its definition internally. The scope of this searching process including:&lt;/p&gt;\n\n&lt;ul&gt;\n&lt;li&gt;All object files that generated in compiling time&lt;/li&gt;\n&lt;li&gt;All libraries (.lib) that are either explicitly or implicitly\nspecified as additional dependencies of this building application.&lt;/li&gt;\n&lt;/ul&gt;\n\n&lt;p&gt;This searching process is called resolve.&lt;/p&gt;\n\n&lt;p&gt;&lt;strong&gt;D. Finally, why Unresolved External Symbol?&lt;/strong&gt;\nIf the linker cannot find the external definition for a symbol that has no definition internally, it reports an Unresolved External Symbol error.&lt;/p&gt;\n\n&lt;p&gt;&lt;strong&gt;E. Possible causes of LNK2019&lt;/strong&gt;: Unresolved External Symbol error.\nWe already know that this error is due to the linker failed to find the definition of external symbols, the possible causes can be sorted as:&lt;/p&gt;\n\n&lt;ol&gt;\n&lt;li&gt;Definition exists&lt;/li&gt;\n&lt;/ol&gt;\n\n&lt;p&gt;For example, if we have a function called foo defined in a.cpp:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt;\n&lt;/span&gt;{\n    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;;\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;In b.cpp we want to call function foo, so we add&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;to declare function foo(), and call it in another function body, say &lt;code&gt;bar()&lt;/code&gt;:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;bar&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt;\n&lt;/span&gt;{\n    &lt;span class=&quot;hljs-built_in&quot;&gt;foo&lt;/span&gt;();\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Now when you build this code you will get a LNK2019 error complaining that foo is an unresolved symbol. In this case, we know that foo() has its definition in a.cpp, but different from the one we are calling(different return value). This is the case that definition exists.&lt;/p&gt;\n\n&lt;ol start=&quot;2&quot;&gt;\n&lt;li&gt;Definition does not exist&lt;/li&gt;\n&lt;/ol&gt;\n\n&lt;p&gt;If we want to call some functions in a library, but the import library is not added into the additional dependency list (set from: &lt;code&gt;Project | Properties | Configuration Properties | Linker | Input | Additional Dependency&lt;/code&gt;) of your project setting. Now the linker will report a LNK2019 since the definition does not exist in current searching scope.&lt;/p&gt;\n    ","\n&lt;h3&gt;Incorrectly importing/exporting methods/classes across modules/dll (compiler specific).&lt;/h3&gt;\n&lt;p&gt;MSVS requires you to specify which symbols to export and import using &lt;code&gt;__declspec(dllexport)&lt;/code&gt; and &lt;code&gt;__declspec(dllimport)&lt;/code&gt;.&lt;/p&gt;\n&lt;p&gt;This dual functionality is usually obtained through the use of a macro:&lt;/p&gt;\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;ifdef&lt;/span&gt; THIS_MODULE&lt;/span&gt;\n&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;define&lt;/span&gt; DLLIMPEXP __declspec(dllexport)&lt;/span&gt;\n&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;else&lt;/span&gt;&lt;/span&gt;\n&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;define&lt;/span&gt; DLLIMPEXP __declspec(dllimport)&lt;/span&gt;\n&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;endif&lt;/span&gt;&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;The macro &lt;code&gt;THIS_MODULE&lt;/code&gt; would only be defined in the module that exports the function. That way, the declaration:&lt;/p&gt;\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;DLLIMPEXP &lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;expands to&lt;/p&gt;\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;__declspec(dllexport) &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;and tells the compiler to export the function, as the current module contains its definition. When including the declaration in a different module, it would expand to&lt;/p&gt;\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;__declspec(dllimport) &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;and tells the compiler that the definition is in one of the libraries you linked against (also see &lt;strong&gt;1)&lt;/strong&gt;).&lt;/p&gt;\n&lt;p&gt;You can similary import/export classes:&lt;/p&gt;\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;DLLIMPEXP&lt;/span&gt; X\n{\n};\n&lt;/code&gt;&lt;/pre&gt;\n    ","\n&lt;p&gt;&lt;strong&gt;undefined reference to &lt;code&gt;WinMain@16&lt;/code&gt; or similar &lt;em&gt;&apos;unusual&apos;&lt;/em&gt; &lt;code&gt;main()&lt;/code&gt; entry point reference&lt;/strong&gt; (especially for &lt;a href=&quot;/questions/tagged/visual-studio&quot; class=&quot;post-tag&quot; title=&quot;show questions tagged &apos;visual-studio&apos;&quot; rel=&quot;tag&quot;&gt;visual-studio&lt;/a&gt;).&lt;/p&gt;\n\n&lt;p&gt;You may have missed to choose the right project type with your actual IDE. The IDE may want to bind e.g. Windows Application projects to such entry point function (as specified in the missing reference above), instead of the commonly used &lt;code&gt;int main(int argc, char** argv);&lt;/code&gt; signature.&lt;/p&gt;\n\n&lt;p&gt;If your IDE supports &lt;em&gt;Plain Console Projects&lt;/em&gt; you might want to choose this project type, instead of a windows application project.&lt;/p&gt;\n\n&lt;hr&gt;\n\n&lt;p&gt;Here are &lt;a href=&quot;https://stackoverflow.com/questions/24715864/problems-importing-libraries-to-my-c-project-how-to-fix-this/24715865#24715865&quot;&gt;case1&lt;/a&gt; and &lt;a href=&quot;https://stackoverflow.com/questions/5259714/undefined-reference-to-winmain16&quot;&gt;case2&lt;/a&gt; handled in more detail from a &lt;em&gt;real world&lt;/em&gt; problem.&lt;/p&gt;\n    ","\n&lt;p&gt;Also if you&apos;re using 3rd party libraries make sure you have the correct 32/64 bit binaries&lt;/p&gt;\n    ","\n&lt;p&gt;Microsoft offers a &lt;code&gt;#pragma&lt;/code&gt; to reference the correct library at link time;&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;pragma&lt;/span&gt; comment(lib, &lt;span class=&quot;hljs-string&quot;&gt;&quot;libname.lib&quot;&lt;/span&gt;)&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;In addition to the library path including the directory of the library, this should be the full name of the library.&lt;/p&gt;\n    ","\n&lt;p&gt;&lt;strong&gt;Visual Studio NuGet package needs to be updated for new toolset version&lt;/strong&gt;&lt;/p&gt;\n\n&lt;p&gt;I just had this problem trying to link libpng with Visual Studio 2013.  The problem is that the package file only had libraries for Visual Studio 2010 and 2012.&lt;/p&gt;\n\n&lt;p&gt;The correct solution is to hope the developer releases an updated package and then upgrade, but it worked for me by hacking in an extra setting for VS2013, pointing at the VS2012 library files.&lt;/p&gt;\n\n&lt;p&gt;I edited the package (in the &lt;code&gt;packages&lt;/code&gt; folder inside the solution&apos;s directory) by finding &lt;code&gt;packagename\\build\\native\\packagename.targets&lt;/code&gt; and inside that file, copying all the &lt;code&gt;v110&lt;/code&gt; sections.  I changed the &lt;code&gt;v110&lt;/code&gt; to &lt;code&gt;v120&lt;/code&gt; in &lt;strong&gt;the condition fields only&lt;/strong&gt; being very careful to leave the filename paths all as &lt;code&gt;v110&lt;/code&gt;.  This simply allowed Visual Studio 2013 to link to the libraries for 2012, and in this case, it worked.&lt;/p&gt;\n    ","\n&lt;p&gt;Suppose you have a big project written in c++ which has a thousand of .cpp files and a thousand of .h files.And let&apos;s says the project also depends on ten static libraries. Let&apos;s says we are on Windows and we build our project in Visual Studio 20xx. When you press Ctrl + F7 Visual Studio to start compiling the whole solution ( suppose we have just one project in the solution )&lt;/p&gt;\n\n&lt;p&gt;&lt;strong&gt;What&apos;s the meaning of compilation ?&lt;/strong&gt;&lt;/p&gt;\n\n&lt;ul&gt;\n&lt;li&gt;Visual Studio search into file &lt;strong&gt;.vcxproj&lt;/strong&gt; and start compiling each file which has the extension .cpp. Order of compilation is undefined.So you must not assume that the file main.cpp is compiled first&lt;/li&gt;\n&lt;li&gt;If .cpp files depends on   additional .h files  in order to find symbols\nthat may or may not be defined in the file .cpp&lt;/li&gt;\n&lt;li&gt;If exists one .cpp file in which the compiler could not find one symbol, a &lt;strong&gt;compiler time error&lt;/strong&gt; raises the message &lt;em&gt;Symbol x could not be found&lt;/em&gt;&lt;/li&gt;\n&lt;li&gt;For each file with extension .cpp is generated an object file .o and also Visual Studio writes the output in a file named &lt;em&gt;ProjectName.Cpp.Clean.txt&lt;/em&gt; which contains all object files that must be processed by the linker.&lt;/li&gt;\n&lt;/ul&gt;\n\n&lt;p&gt;The Second step of compilation is done by Linker.Linker should merge all the object file and build finally the output ( which may be an executable or a library)&lt;/p&gt;\n\n&lt;p&gt;&lt;strong&gt;Steps In Linking a project&lt;/strong&gt;    &lt;/p&gt;\n\n&lt;ul&gt;\n&lt;li&gt;Parse all the object files and find the definition which was only declared in headers ( eg: The code of one method of a class as is mentioned in previous answers, or event the initialization of a static variable which is member inside a class)&lt;/li&gt;\n&lt;li&gt;If one symbol could not be found in object files he also is searched in Additional Libraries.For adding a new library to a project &lt;strong&gt;Configuration properties&lt;/strong&gt; -&amp;gt; &lt;strong&gt;VC++ Directories&lt;/strong&gt;  -&amp;gt; &lt;strong&gt;Library Directories&lt;/strong&gt; and here you specified additional folder for searching libraries and &lt;strong&gt;Configuration properties&lt;/strong&gt; -&amp;gt; &lt;strong&gt;Linker&lt;/strong&gt; -&amp;gt; &lt;strong&gt;Input&lt;/strong&gt; for specifying the name of the library. \n-If the Linker could not find the symbol which you write in one .cpp he raises a &lt;strong&gt;linker time error&lt;/strong&gt; which may sound like \n&lt;code&gt;error LNK2001: unresolved external symbol &quot;void __cdecl foo(void)&quot; (?foo@@YAXXZ)&lt;/code&gt;&lt;/li&gt;\n&lt;/ul&gt;\n\n&lt;p&gt;&lt;strong&gt;Observation&lt;/strong&gt;&lt;/p&gt;\n\n&lt;ol&gt;\n&lt;li&gt;Once the Linker find one symbol he doesn&apos;t search in other libraries for it&lt;/li&gt;\n&lt;li&gt;The order of linking libraries &lt;strong&gt;does matter&lt;/strong&gt;.&lt;/li&gt;\n&lt;li&gt;If Linker finds an external symbol in one static library he includes the symbol in the output of the project.However, if the library is shared( dynamic ) he doesn&apos;t include the code ( symbols ) in output, but  &lt;em&gt;Run-Time&lt;/em&gt; crashes may occur&lt;/li&gt;\n&lt;/ol&gt;\n\n&lt;p&gt;&lt;strong&gt;How To Solve this kind of error&lt;/strong&gt;&lt;/p&gt;\n\n&lt;p&gt;Compiler Time Error : &lt;/p&gt;\n\n&lt;ul&gt;\n&lt;li&gt;Make sure you write your c++ project syntactical correct.&lt;/li&gt;\n&lt;/ul&gt;\n\n&lt;p&gt;Linker Time Error&lt;/p&gt;\n\n&lt;ul&gt;\n&lt;li&gt;Define all your symbol which you declare in your header files&lt;/li&gt;\n&lt;li&gt;Use &lt;code&gt;#pragma once&lt;/code&gt; for allowing compiler not to include one header if it was already included in the current .cpp which are compiled&lt;/li&gt;\n&lt;li&gt;Make sure that your external library doesn&apos;t contain symbols that may enter into conflict with other symbols you defined in your header files&lt;/li&gt;\n&lt;li&gt;When you use the template to make sure you include the definition of each template function in the header file for allowing the compiler to generate appropriate code for any instantiations.  &lt;/li&gt;\n&lt;/ul&gt;\n    ","\n&lt;h2&gt;Use the linker to help diagnose the error&lt;/h2&gt;\n&lt;p&gt;Most modern linkers include a verbose option that prints out to varying degrees;&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;Link invocation (command line),&lt;/li&gt;\n&lt;li&gt;Data on what libraries are included in the link stage,&lt;/li&gt;\n&lt;li&gt;The location of the libraries,&lt;/li&gt;\n&lt;li&gt;Search paths used.&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;For gcc and clang; you would typically add &lt;code&gt;-v -Wl,--verbose&lt;/code&gt; or &lt;code&gt;-v -Wl,-v&lt;/code&gt; to the command line. More details can be found here;&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;Linux &lt;a href=&quot;http://linux.die.net/man/1/ld&quot; rel=&quot;noreferrer&quot;&gt;ld man page&lt;/a&gt;.&lt;/li&gt;\n&lt;li&gt;LLVM &lt;a href=&quot;http://llvm.org/releases/3.6.2/docs/CommandGuide/llvm-link.html#cmdoption-v&quot; rel=&quot;noreferrer&quot;&gt;linker page&lt;/a&gt;.&lt;/li&gt;\n&lt;li&gt;&quot;An introduction to GCC&quot; &lt;a href=&quot;http://www.network-theory.co.uk/docs/gccintro/gccintro_75.html&quot; rel=&quot;noreferrer&quot;&gt;chapter 9&lt;/a&gt;.&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;For MSVC, &lt;code&gt;/VERBOSE&lt;/code&gt; (in particular &lt;code&gt;/VERBOSE:LIB&lt;/code&gt;) is added to the link command line.&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;The MSDN page on the &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/wdsk6as6.aspx&quot; rel=&quot;noreferrer&quot;&gt;&lt;code&gt;/VERBOSE&lt;/code&gt; linker option&lt;/a&gt;.&lt;/li&gt;\n&lt;/ul&gt;\n    ","\n&lt;h2&gt;A bug in the compiler/IDE&lt;/h2&gt;\n\n&lt;p&gt;I recently had this problem, and it turned out &lt;a href=&quot;https://stackoverflow.com/questions/27748699/unresolved-reference-to-constructor-which-is-defined/27748920#27748920&quot;&gt;it was a bug in Visual Studio Express 2013&lt;/a&gt;. I had to remove a source file from the project and re-add it to overcome the bug.&lt;/p&gt;\n\n&lt;p&gt;Steps to try if you believe it could be a bug in compiler/IDE:&lt;/p&gt;\n\n&lt;ul&gt;\n&lt;li&gt;Clean the project (some IDEs have an option to do this, you can also\nmanually do it by deleting the object files)&lt;/li&gt;\n&lt;li&gt;Try start a new project,\ncopying all source code from the original one.&lt;/li&gt;\n&lt;/ul&gt;\n    ","\n&lt;p&gt;&lt;strong&gt;Linked .lib file is associated to a .dll&lt;/strong&gt;&lt;/p&gt;\n\n&lt;p&gt;I had the same issue. Say i have projects MyProject and TestProject. I had effectively linked the lib file for MyProject to the TestProject. However, this lib file was produced as the DLL for the MyProject was built. Also, I did not contain source code for all methods in the MyProject, but only access to the DLL&apos;s entry points. &lt;/p&gt;\n\n&lt;p&gt;To solve the issue, i built the MyProject as a LIB, and linked TestProject to this .lib file (i copy paste the generated .lib file into the TestProject folder). I can then build again MyProject as a DLL. It is compiling since the lib to which TestProject is linked does contain code for all methods in classes in MyProject. &lt;/p&gt;\n    ","\n&lt;p&gt;Since people seem to be directed to this question when it comes to linker errors I am going to add this here.&lt;/p&gt;\n\n&lt;p&gt;One possible reason for linker errors with GCC 5.2.0 is that a new libstdc++ library ABI is now chosen by default.&lt;/p&gt;\n\n&lt;blockquote&gt;\n  &lt;p&gt;If you get linker errors about undefined references to symbols that involve types in the std::__cxx11 namespace or the tag [abi:cxx11] then it probably indicates that you are trying to link together object files that were compiled with different values for the _GLIBCXX_USE_CXX11_ABI macro. This commonly happens when linking to a third-party library that was compiled with an older version of GCC. If the third-party library cannot be rebuilt with the new ABI then you will need to recompile your code with the old ABI.&lt;/p&gt;\n&lt;/blockquote&gt;\n\n&lt;p&gt;So if you suddenly get linker errors when switching to a GCC after 5.1.0 this would be a thing to check out.&lt;/p&gt;\n    ","\n&lt;h2&gt;Your linkage consumes libraries before the object files that refer to them&lt;/h2&gt;\n\n&lt;ul&gt;\n&lt;li&gt;You are trying to compile and link your program with the GCC toolchain.&lt;/li&gt;\n&lt;li&gt;Your linkage specifies all of the necessary libraries and library search paths&lt;/li&gt;\n&lt;li&gt;If &lt;code&gt;libfoo&lt;/code&gt; depends on &lt;code&gt;libbar&lt;/code&gt;, then your linkage correctly puts &lt;code&gt;libfoo&lt;/code&gt; before &lt;code&gt;libbar&lt;/code&gt;.&lt;/li&gt;\n&lt;li&gt;Your linkage fails with &lt;code&gt;undefined reference to&lt;/code&gt; &lt;em&gt;something&lt;/em&gt; errors.&lt;/li&gt;\n&lt;li&gt;But all the undefined &lt;em&gt;something&lt;/em&gt;s are declared in the header files you have\n&lt;code&gt;#include&lt;/code&gt;d and are in fact defined in the libraries that you are linking.&lt;/li&gt;\n&lt;/ul&gt;\n\n&lt;p&gt;Examples are in C. They could equally well be C++&lt;/p&gt;\n\n&lt;h3&gt;A minimal example involving a static library you built yourself&lt;/h3&gt;\n\n&lt;p&gt;&lt;strong&gt;my_lib.c&lt;/strong&gt;&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;my_lib.h&quot;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;/span&gt;\n\n&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;hw&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt;)&lt;/span&gt;\n&lt;/span&gt;{\n    &lt;span class=&quot;hljs-built_in&quot;&gt;puts&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;Hello World&quot;&lt;/span&gt;);\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;&lt;strong&gt;my_lib.h&lt;/strong&gt;&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;ifndef&lt;/span&gt; MY_LIB_H&lt;/span&gt;\n&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;define&lt;/span&gt; MT_LIB_H&lt;/span&gt;\n\n&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;extern&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;hw&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;;\n\n&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;endif&lt;/span&gt;&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;&lt;strong&gt;eg1.c&lt;/strong&gt;&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&amp;lt;my_lib.h&amp;gt;&lt;/span&gt;&lt;/span&gt;\n\n&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt;\n&lt;/span&gt;{\n    &lt;span class=&quot;hljs-built_in&quot;&gt;hw&lt;/span&gt;();\n    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;;\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;You build your static library:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;$ gcc -c -o my_lib.o my_lib.c\n$ ar rcs libmy_lib.a my_lib.o\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;You compile your program:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;$ gcc -I. -c -o eg1.o eg1.c\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;You try to link it with &lt;code&gt;libmy_lib.a&lt;/code&gt; and fail:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;$ gcc -o eg1 -L. -lmy_lib eg1.o \neg1.o: In function `main&lt;span class=&quot;hljs-number&quot;&gt;&apos;&lt;/span&gt;:\neg1.c:(.text+&lt;span class=&quot;hljs-number&quot;&gt;0x5&lt;/span&gt;): undefined reference to `hw&lt;span class=&quot;hljs-number&quot;&gt;&apos;&lt;/span&gt;\ncollect2: error: ld returned &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt; exit status\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;The same result if you compile and link in one step, like:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;$ gcc -o eg1 -I. -L. -lmy_lib eg1.c\n/tmp/ccQk1tvs.o: In function `main&lt;span class=&quot;hljs-number&quot;&gt;&apos;&lt;/span&gt;:\neg1.c:(.text+&lt;span class=&quot;hljs-number&quot;&gt;0x5&lt;/span&gt;): undefined reference to `hw&lt;span class=&quot;hljs-number&quot;&gt;&apos;&lt;/span&gt;\ncollect2: error: ld returned &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt; exit status\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;h3&gt;A minimal example involving a shared system library, the compression library &lt;code&gt;libz&lt;/code&gt;&lt;/h3&gt;\n\n&lt;p&gt;&lt;strong&gt;eg2.c&lt;/strong&gt;&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&amp;lt;zlib.h&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;/span&gt;\n\n&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt;\n&lt;/span&gt;{\n    &lt;span class=&quot;hljs-built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;%s\\n&quot;&lt;/span&gt;,&lt;span class=&quot;hljs-built_in&quot;&gt;zlibVersion&lt;/span&gt;());\n    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;;\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Compile your program:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;$ gcc -c -o eg2.o eg2.c\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Try to link your program with &lt;code&gt;libz&lt;/code&gt; and fail:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;$ gcc -o eg2 -lz eg2.o \neg2.o: In function `main&lt;span class=&quot;hljs-number&quot;&gt;&apos;&lt;/span&gt;:\neg2.c:(.text+&lt;span class=&quot;hljs-number&quot;&gt;0x5&lt;/span&gt;): undefined reference to `zlibVersion&lt;span class=&quot;hljs-number&quot;&gt;&apos;&lt;/span&gt;\ncollect2: error: ld returned &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt; exit status\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Same if you compile and link in one go:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;$ gcc -o eg2 -I. -lz eg2.c\n/tmp/ccxCiGn7.o: In function `main&lt;span class=&quot;hljs-number&quot;&gt;&apos;&lt;/span&gt;:\neg2.c:(.text+&lt;span class=&quot;hljs-number&quot;&gt;0x5&lt;/span&gt;): undefined reference to `zlibVersion&lt;span class=&quot;hljs-number&quot;&gt;&apos;&lt;/span&gt;\ncollect2: error: ld returned &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt; exit status\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;And a variation on example 2 involving &lt;code&gt;pkg-config&lt;/code&gt;:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;$ gcc -o eg2 $(pkg-config --libs zlib) eg2.o \neg2.o: In function `main&lt;span class=&quot;hljs-number&quot;&gt;&apos;&lt;/span&gt;:\neg2.c:(.text+&lt;span class=&quot;hljs-number&quot;&gt;0x5&lt;/span&gt;): undefined reference to `zlibVersion&lt;span class=&quot;hljs-number&quot;&gt;&apos;&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;h3&gt;What are you doing wrong?&lt;/h3&gt;\n\n&lt;p&gt;In the sequence of object files and libraries you want to link to make your\nprogram, you are placing the libraries before the object files that refer to\nthem. You need to place the libraries &lt;em&gt;after&lt;/em&gt; the object files that refer\nto them.&lt;/p&gt;\n\n&lt;p&gt;Link example 1 correctly:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;$ gcc -o eg1 eg1.o -L. -lmy_lib\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Success:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;$ ./eg1 \nHello World\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Link example 2 correctly:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;$ gcc -o eg2 eg2.o -lz\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Success:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;$ ./eg2 \n&lt;span class=&quot;hljs-number&quot;&gt;1.2&lt;/span&gt;&lt;span class=&quot;hljs-number&quot;&gt;.8&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Link the example 2 &lt;code&gt;pkg-config&lt;/code&gt; variation correctly:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;$ gcc -o eg2 eg2.o $(pkg-config --libs zlib) \n$ ./eg2\n&lt;span class=&quot;hljs-number&quot;&gt;1.2&lt;/span&gt;&lt;span class=&quot;hljs-number&quot;&gt;.8&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;h3&gt;The explanation&lt;/h3&gt;\n\n&lt;p&gt;&lt;em&gt;Reading is optional from here on&lt;/em&gt;.&lt;/p&gt;\n\n&lt;p&gt;By default, a linkage command generated by GCC, on your distro,\nconsumes the files in the linkage from left to right in\ncommandline sequence. When it finds that a file refers to &lt;em&gt;something&lt;/em&gt;\nand does not contain a definition for it, to will search for a definition\nin files further to the right. If it eventually finds a definition, the\nreference is resolved. If any references remain unresolved at the end,\nthe linkage fails: the linker does not search backwards.&lt;/p&gt;\n\n&lt;p&gt;First, &lt;strong&gt;example 1&lt;/strong&gt;, with static library &lt;code&gt;my_lib.a&lt;/code&gt;&lt;/p&gt;\n\n&lt;p&gt;A static library is an indexed archive of object files. When the linker\nfinds &lt;code&gt;-lmy_lib&lt;/code&gt; in the linkage sequence and figures out that this refers\nto the static library &lt;code&gt;./libmy_lib.a&lt;/code&gt;, it wants to know whether your program\nneeds any of the object files in &lt;code&gt;libmy_lib.a&lt;/code&gt;.&lt;/p&gt;\n\n&lt;p&gt;There is only object file in &lt;code&gt;libmy_lib.a&lt;/code&gt;, namely &lt;code&gt;my_lib.o&lt;/code&gt;, and there&apos;s only one thing defined\nin &lt;code&gt;my_lib.o&lt;/code&gt;, namely the function &lt;code&gt;hw&lt;/code&gt;.&lt;/p&gt;\n\n&lt;p&gt;The linker will decide that your program needs &lt;code&gt;my_lib.o&lt;/code&gt; if and only if it already knows that\nyour program refers to &lt;code&gt;hw&lt;/code&gt;, in one or more of the object files it has already\nadded to the program, and that none of the object files it has already added\ncontains a definition for &lt;code&gt;hw&lt;/code&gt;.&lt;/p&gt;\n\n&lt;p&gt;If that is true, then the linker will extract a copy of &lt;code&gt;my_lib.o&lt;/code&gt; from the library and\nadd it to your program. Then, your program contains a definition for &lt;code&gt;hw&lt;/code&gt;, so\nits references to &lt;code&gt;hw&lt;/code&gt; are &lt;em&gt;resolved&lt;/em&gt;.&lt;/p&gt;\n\n&lt;p&gt;When you try to link the program like:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;$ gcc -o eg1 -L. -lmy_lib eg1.o\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;the linker &lt;em&gt;has not added&lt;/em&gt; &lt;code&gt;eg1.o&lt;/code&gt; &lt;em&gt;to the program&lt;/em&gt; when it sees\n&lt;code&gt;-lmy_lib&lt;/code&gt;. Because at that point, it has not seen &lt;code&gt;eg1.o&lt;/code&gt;.\nYour program does not yet make any references to &lt;code&gt;hw&lt;/code&gt;: it\ndoes not yet make any references &lt;em&gt;at all&lt;/em&gt;, because all the references it makes\nare in &lt;code&gt;eg1.o&lt;/code&gt;.&lt;/p&gt;\n\n&lt;p&gt;So the linker does not add &lt;code&gt;my_lib.o&lt;/code&gt; to the program and has no further\nuse for &lt;code&gt;libmy_lib.a&lt;/code&gt;.&lt;/p&gt;\n\n&lt;p&gt;Next, it finds &lt;code&gt;eg1.o&lt;/code&gt;, and adds it to be program. An object file in the\nlinkage sequence is always added to the program. Now, the program makes\na reference to &lt;code&gt;hw&lt;/code&gt;, and does not contain a definition of &lt;code&gt;hw&lt;/code&gt;; but\nthere is nothing left in the linkage sequence that could provide the missing\ndefinition. The reference to &lt;code&gt;hw&lt;/code&gt; ends up &lt;em&gt;unresolved&lt;/em&gt;, and the linkage fails.&lt;/p&gt;\n\n&lt;p&gt;Second, &lt;strong&gt;example 2&lt;/strong&gt;, with shared library &lt;code&gt;libz&lt;/code&gt;&lt;/p&gt;\n\n&lt;p&gt;A shared library isn&apos;t an archive of object files or anything like it. It&apos;s\nmuch more like a &lt;em&gt;program&lt;/em&gt; that doesn&apos;t have a &lt;code&gt;main&lt;/code&gt; function and\ninstead exposes multiple other symbols that it defines, so that other\nprograms can use them at runtime.&lt;/p&gt;\n\n&lt;p&gt;Many Linux distros today configure their GCC toolchain so that its language drivers (&lt;code&gt;gcc&lt;/code&gt;,&lt;code&gt;g++&lt;/code&gt;,&lt;code&gt;gfortran&lt;/code&gt; etc)\ninstruct the system linker (&lt;code&gt;ld&lt;/code&gt;) to link shared libraries on an &lt;em&gt;as-needed&lt;/em&gt; basis.\nYou have got one of those distros.&lt;/p&gt;\n\n&lt;p&gt;This means that when the linker finds &lt;code&gt;-lz&lt;/code&gt; in the linkage sequence, and figures out that this refers \nto the shared library (say) &lt;code&gt;/usr/lib/x86_64-linux-gnu/libz.so&lt;/code&gt;, it wants to know whether any references that it has added to your program that aren&apos;t yet defined have definitions that are exported by &lt;code&gt;libz&lt;/code&gt;&lt;/p&gt;\n\n&lt;p&gt;If that is true, then the linker will &lt;em&gt;not&lt;/em&gt; copy any chunks out of &lt;code&gt;libz&lt;/code&gt; and\nadd them to your program; instead, it will just doctor the code of your program \nso that:-&lt;/p&gt;\n\n&lt;ul&gt;\n&lt;li&gt;&lt;p&gt;At runtime, the system program loader will load a copy of &lt;code&gt;libz&lt;/code&gt; into the\nsame process as your program whenever it loads a copy of your program, to run it.&lt;/p&gt;&lt;/li&gt;\n&lt;li&gt;&lt;p&gt;At runtime, whenever your program refers to something that is defined in\n&lt;code&gt;libz&lt;/code&gt;, that reference uses the definition exported by the copy of &lt;code&gt;libz&lt;/code&gt; in\nthe same process.&lt;/p&gt;&lt;/li&gt;\n&lt;/ul&gt;\n\n&lt;p&gt;Your program wants to refer to just one thing that has a definition exported by &lt;code&gt;libz&lt;/code&gt;,\nnamely the function &lt;code&gt;zlibVersion&lt;/code&gt;, which is referred to just once, in &lt;code&gt;eg2.c&lt;/code&gt;.\nIf the linker adds that reference to your program, and then finds the definition\nexported by &lt;code&gt;libz&lt;/code&gt;, the reference is &lt;em&gt;resolved&lt;/em&gt; &lt;/p&gt;\n\n&lt;p&gt;But when you try to link the program like:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;gcc -o eg2 -lz eg2.o\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;the order of events is wrong in just the same way as with example 1.\nAt the point when the linker finds &lt;code&gt;-lz&lt;/code&gt;, there are &lt;em&gt;no&lt;/em&gt; references to anything\nin the program: they are all in &lt;code&gt;eg2.o&lt;/code&gt;, which has not yet been seen. So the\nlinker decides it has no use for &lt;code&gt;libz&lt;/code&gt;. When it reaches &lt;code&gt;eg2.o&lt;/code&gt;, adds it to the program,\nand then has undefined reference to &lt;code&gt;zlibVersion&lt;/code&gt;, the linkage sequence is finished;\nthat reference is unresolved, and the linkage fails.&lt;/p&gt;\n\n&lt;p&gt;Lastly, the &lt;code&gt;pkg-config&lt;/code&gt; variation of example 2 has a now obvious explanation.\nAfter shell-expansion:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;gcc -o eg2 $(pkg-config --libs zlib) eg2.o\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;becomes:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;gcc -o eg2 -lz eg2.o\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;which is just example 2 again.&lt;/p&gt;\n\n&lt;h3&gt;I can reproduce the problem in example 1, but not in example 2&lt;/h3&gt;\n\n&lt;p&gt;The linkage:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;gcc -o eg2 -lz eg2.o\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;works just fine for you!&lt;/p&gt;\n\n&lt;p&gt;(Or: That linkage worked fine for you on, say, Fedora 23, but fails on Ubuntu 16.04)&lt;/p&gt;\n\n&lt;p&gt;That&apos;s because the distro on which the linkage works is one of the ones that \ndoes not configure its GCC toolchain to link shared libraries &lt;em&gt;as-needed&lt;/em&gt;.&lt;/p&gt;\n\n&lt;p&gt;Back in the day, it was normal for unix-like systems to link static and shared \nlibraries by different rules. Static libraries in a linkage sequence were linked \non the &lt;em&gt;as-needed&lt;/em&gt; basis explained in example 1, but shared libraries were linked unconditionally.&lt;/p&gt;\n\n&lt;p&gt;This behaviour is economical at linktime because the linker doesn&apos;t have to ponder\nwhether a shared library is needed by the program: if it&apos;s a shared library,\nlink it. And most libraries in most linkages are shared libraries. But there are disadvantages too:-&lt;/p&gt;\n\n&lt;ul&gt;\n&lt;li&gt;&lt;p&gt;It is uneconomical at &lt;em&gt;runtime&lt;/em&gt;, because it can cause shared libraries to be\nloaded along with a program even if doesn&apos;t need them.&lt;/p&gt;&lt;/li&gt;\n&lt;li&gt;&lt;p&gt;The different linkage rules for static and shared libraries can be confusing\nto inexpert programmers, who may not know whether &lt;code&gt;-lfoo&lt;/code&gt; in their linkage\nis going to resolve to &lt;code&gt;/some/where/libfoo.a&lt;/code&gt; or to &lt;code&gt;/some/where/libfoo.so&lt;/code&gt;,\nand might not understand the difference between shared and static libraries\nanyway.&lt;/p&gt;&lt;/li&gt;\n&lt;/ul&gt;\n\n&lt;p&gt;This trade-off has led to the schismatic situation today. Some distros have\nchanged their GCC linkage rules for shared libraries so that the &lt;em&gt;as-needed&lt;/em&gt;\nprinciple applies for all libraries. Some distros have stuck with the old\nway.&lt;/p&gt;\n\n&lt;h3&gt;Why do I still get this problem even if I compile-and-link at the same time?&lt;/h3&gt;\n\n&lt;p&gt;If I just do:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;$ gcc -o eg1 -I. -L. -lmy_lib eg1.c\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;surely gcc has to compile &lt;code&gt;eg1.c&lt;/code&gt; first, and then link the resulting\nobject file with &lt;code&gt;libmy_lib.a&lt;/code&gt;.  So how can it not know that object file\nis needed when it&apos;s doing the linking?&lt;/p&gt;\n\n&lt;p&gt;Because compiling and linking with a single command does not change the\norder of the linkage sequence.&lt;/p&gt;\n\n&lt;p&gt;When you run the command above, &lt;code&gt;gcc&lt;/code&gt; figures out that you want compilation +\nlinkage. So behind the scenes, it generates a compilation command, and runs\nit, then generates a linkage command, and runs it, as if &lt;em&gt;you&lt;/em&gt; had run the\ntwo commands:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;$ gcc -I. -c -o eg1.o eg1.c\n$ gcc -o eg1 -L. -lmy_lib eg1.o\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;So the linkage fails just as it does if you &lt;em&gt;do&lt;/em&gt; run those two commands. The\nonly difference you notice in the failure is that gcc has generated a\ntemporary object file in the compile + link case, because you&apos;re not telling it\nto use &lt;code&gt;eg1.o&lt;/code&gt;. We see:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;/tmp/ccQk1tvs.o: In function `main&lt;span class=&quot;hljs-number&quot;&gt;&apos;&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;instead of:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;eg1.o: In function `main&lt;span class=&quot;hljs-number&quot;&gt;&apos;&lt;/span&gt;:\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;h3&gt;See also&lt;/h3&gt;\n\n&lt;p&gt;&lt;a href=&quot;https://stackoverflow.com/a/24675715/1362568&quot;&gt;The order in which interdependent linked libraries are specified is wrong&lt;/a&gt;&lt;/p&gt;\n\n&lt;p&gt;Putting interdependent libraries in the wrong order is just one way\nin which you can get files that &lt;em&gt;need&lt;/em&gt; definitions of things coming\nlater in the linkage than the files that &lt;em&gt;provide&lt;/em&gt; the definitions. Putting libraries before the \nobject files that refer to them is another way of making the same mistake.&lt;/p&gt;\n    ","\n&lt;p&gt;&lt;strong&gt;A wrapper around GNU ld that doesn&apos;t support linker scripts&lt;/strong&gt;&lt;/p&gt;\n\n&lt;p&gt;Some .so files are actually &lt;a href=&quot;https://access.redhat.com/documentation/en-US/Red_Hat_Enterprise_Linux/4/html/Using_ld_the_GNU_Linker/simple-commands.html&quot;&gt;GNU ld linker scripts&lt;/a&gt;, e.g. &lt;a href=&quot;https://www.threadingbuildingblocks.org/download&quot;&gt;libtbb.so&lt;/a&gt; file is an ASCII text file with this contents:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;INPUT&lt;/span&gt; (libtbb.so&lt;span class=&quot;hljs-number&quot;&gt;.2&lt;/span&gt;)\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Some more complex builds may not support this. For example, if you include -v in the compiler options, you can see that the &lt;a href=&quot;http://www.mainsoft.com/content/mainsoft-unix-and-linux-overview&quot;&gt;mainwin gcc wrapper mwdip&lt;/a&gt; discards linker script command files in the verbose output list of libraries to link in. A simple work around is to replace the linker script input command file with a copy of the file instead (or a symlink), e.g.&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;cp libtbb.so&lt;span class=&quot;hljs-number&quot;&gt;.2&lt;/span&gt; libtbb.so\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Or you could replace the -l argument with the full path of the .so, e.g. instead of &lt;code&gt;-ltbb&lt;/code&gt; do &lt;code&gt;/home/foo/tbb-4.3/linux/lib/intel64/gcc4.4/libtbb.so.2&lt;/code&gt;&lt;/p&gt;\n    ","\n&lt;h2&gt;Befriending templates...&lt;/h2&gt;\n\n&lt;p&gt;Given the code snippet of a template type with a friend operator (or function);&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;template&lt;/span&gt; &amp;lt;&lt;span class=&quot;hljs-keyword&quot;&gt;typename&lt;/span&gt; T&amp;gt;\n&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;Foo&lt;/span&gt; {\n    &lt;span class=&quot;hljs-keyword&quot;&gt;friend&lt;/span&gt; std::ostream&amp;amp; &lt;span class=&quot;hljs-keyword&quot;&gt;operator&lt;/span&gt;&amp;lt;&amp;lt; (std::ostream&amp;amp; os, &lt;span class=&quot;hljs-type&quot;&gt;const&lt;/span&gt; Foo&amp;lt;T&amp;gt;&amp;amp; a);\n};\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;The &lt;code&gt;operator&amp;lt;&amp;lt;&lt;/code&gt; is being declared as a non-template function. For every type &lt;code&gt;T&lt;/code&gt; used with &lt;code&gt;Foo&lt;/code&gt;, there needs to be a non-templated &lt;code&gt;operator&amp;lt;&amp;lt;&lt;/code&gt;. For example, if there is a type &lt;code&gt;Foo&amp;lt;int&amp;gt;&lt;/code&gt; declared, then there must be an operator implementation as follows;&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;std::ostream&amp;amp; &lt;span class=&quot;hljs-keyword&quot;&gt;operator&lt;/span&gt;&amp;lt;&amp;lt; (std::ostream&amp;amp; os, &lt;span class=&quot;hljs-type&quot;&gt;const&lt;/span&gt; Foo&amp;lt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt;&amp;gt;&amp;amp; a) {&lt;span class=&quot;hljs-comment&quot;&gt;/*...*/&lt;/span&gt;}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Since it is not implemented, the linker fails to find it and results in the error.&lt;/p&gt;\n\n&lt;p&gt;To correct this, you can declare a template operator before the &lt;code&gt;Foo&lt;/code&gt; type and then declare as a friend, the appropriate instantiation. The syntax is a little awkward, but is looks as follows;&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-comment&quot;&gt;// forward declare the Foo&lt;/span&gt;\n&lt;span class=&quot;hljs-keyword&quot;&gt;template&lt;/span&gt; &amp;lt;&lt;span class=&quot;hljs-keyword&quot;&gt;typename&lt;/span&gt;&amp;gt;\n&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;Foo&lt;/span&gt;;\n\n&lt;span class=&quot;hljs-comment&quot;&gt;// forward declare the operator &amp;lt;&amp;lt;&lt;/span&gt;\n&lt;span class=&quot;hljs-keyword&quot;&gt;template&lt;/span&gt; &amp;lt;&lt;span class=&quot;hljs-keyword&quot;&gt;typename&lt;/span&gt; T&amp;gt;\nstd::ostream&amp;amp; &lt;span class=&quot;hljs-keyword&quot;&gt;operator&lt;/span&gt;&amp;lt;&amp;lt;(std::ostream&amp;amp;, &lt;span class=&quot;hljs-type&quot;&gt;const&lt;/span&gt; Foo&amp;lt;T&amp;gt;&amp;amp;);\n\n&lt;span class=&quot;hljs-keyword&quot;&gt;template&lt;/span&gt; &amp;lt;&lt;span class=&quot;hljs-keyword&quot;&gt;typename&lt;/span&gt; T&amp;gt;\n&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;Foo&lt;/span&gt; {\n    &lt;span class=&quot;hljs-keyword&quot;&gt;friend&lt;/span&gt; std::ostream&amp;amp; &lt;span class=&quot;hljs-keyword&quot;&gt;operator&lt;/span&gt;&amp;lt;&amp;lt; &amp;lt;&amp;gt;(std::ostream&amp;amp; os, &lt;span class=&quot;hljs-type&quot;&gt;const&lt;/span&gt; Foo&amp;lt;T&amp;gt;&amp;amp; a);\n    &lt;span class=&quot;hljs-comment&quot;&gt;// note the required &amp;lt;&amp;gt;        ^^^^&lt;/span&gt;\n    &lt;span class=&quot;hljs-comment&quot;&gt;// ...&lt;/span&gt;\n};\n\n&lt;span class=&quot;hljs-keyword&quot;&gt;template&lt;/span&gt; &amp;lt;&lt;span class=&quot;hljs-keyword&quot;&gt;typename&lt;/span&gt; T&amp;gt;\nstd::ostream&amp;amp; &lt;span class=&quot;hljs-keyword&quot;&gt;operator&lt;/span&gt;&amp;lt;&amp;lt;(std::ostream&amp;amp;, &lt;span class=&quot;hljs-type&quot;&gt;const&lt;/span&gt; Foo&amp;lt;T&amp;gt;&amp;amp;)\n{\n  &lt;span class=&quot;hljs-comment&quot;&gt;// ... implement the operator&lt;/span&gt;\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;The above code limits the friendship of the operator to the corresponding instantiation of &lt;code&gt;Foo&lt;/code&gt;, i.e. the &lt;code&gt;operator&amp;lt;&amp;lt; &amp;lt;int&amp;gt;&lt;/code&gt; instantiation is limited to access the private members of the instantiation of &lt;code&gt;Foo&amp;lt;int&amp;gt;&lt;/code&gt;.&lt;/p&gt;\n\n&lt;p&gt;Alternatives include;&lt;/p&gt;\n\n&lt;ul&gt;\n&lt;li&gt;&lt;p&gt;Allowing the friendship to extend to all instantiations of the templates, as follows;&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;template&lt;/span&gt; &amp;lt;&lt;span class=&quot;hljs-keyword&quot;&gt;typename&lt;/span&gt; T&amp;gt;\n&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;Foo&lt;/span&gt; {\n    &lt;span class=&quot;hljs-keyword&quot;&gt;template&lt;/span&gt; &amp;lt;&lt;span class=&quot;hljs-keyword&quot;&gt;typename&lt;/span&gt; T1&amp;gt;\n    &lt;span class=&quot;hljs-keyword&quot;&gt;friend&lt;/span&gt; std::ostream&amp;amp; &lt;span class=&quot;hljs-keyword&quot;&gt;operator&lt;/span&gt;&amp;lt;&amp;lt;(std::ostream&amp;amp; os, &lt;span class=&quot;hljs-type&quot;&gt;const&lt;/span&gt; Foo&amp;lt;T1&amp;gt;&amp;amp; a);\n    &lt;span class=&quot;hljs-comment&quot;&gt;// ...&lt;/span&gt;\n};\n&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;\n&lt;li&gt;&lt;p&gt;Or, the implementation for the &lt;code&gt;operator&amp;lt;&amp;lt;&lt;/code&gt; can be done inline inside the class definition;&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;template&lt;/span&gt; &amp;lt;&lt;span class=&quot;hljs-keyword&quot;&gt;typename&lt;/span&gt; T&amp;gt;\n&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;Foo&lt;/span&gt; {\n    &lt;span class=&quot;hljs-keyword&quot;&gt;friend&lt;/span&gt; std::ostream&amp;amp; &lt;span class=&quot;hljs-keyword&quot;&gt;operator&lt;/span&gt;&amp;lt;&amp;lt;(std::ostream&amp;amp; os, &lt;span class=&quot;hljs-type&quot;&gt;const&lt;/span&gt; Foo&amp;amp; a)\n    { &lt;span class=&quot;hljs-comment&quot;&gt;/*...*/&lt;/span&gt; }\n    &lt;span class=&quot;hljs-comment&quot;&gt;// ...&lt;/span&gt;\n};\n&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;\n&lt;/ul&gt;\n\n&lt;p&gt;&lt;em&gt;Note&lt;/em&gt;, when the declaration of the operator (or function) only appears in the class, the name is not available for &quot;normal&quot; lookup, only for argument dependent lookup, from &lt;a href=&quot;http://en.cppreference.com/w/cpp/language/friend&quot; rel=&quot;noreferrer&quot;&gt;cppreference&lt;/a&gt;;&lt;/p&gt;\n\n&lt;blockquote&gt;\n  &lt;p&gt;A name first declared in a friend declaration within class or class template X becomes a member of the innermost enclosing namespace of X, but is not accessible for lookup (except argument-dependent lookup that considers X) unless a matching declaration at the namespace scope is provided...&lt;/p&gt;\n&lt;/blockquote&gt;\n\n&lt;p&gt;There is further reading on template friends at &lt;a href=&quot;http://en.cppreference.com/w/cpp/language/friend#Template_friends&quot; rel=&quot;noreferrer&quot;&gt;cppreference&lt;/a&gt; and the &lt;a href=&quot;https://isocpp.org/wiki/faq/templates#template-friends&quot; rel=&quot;noreferrer&quot;&gt;C++ FAQ&lt;/a&gt;.&lt;/p&gt;\n\n&lt;p&gt;&lt;a href=&quot;http://coliru.stacked-crooked.com/a/e9221c4bb23f9cd0&quot; rel=&quot;noreferrer&quot;&gt;Code listing showing the techniques above&lt;/a&gt;.&lt;/p&gt;\n\n&lt;hr&gt;\n\n&lt;p&gt;&lt;em&gt;As a side note to the failing code sample; g++ warns about this as follows&lt;/em&gt;&lt;/p&gt;\n\n&lt;blockquote&gt;\n  &lt;p&gt;&lt;code&gt;warning: friend declaration &apos;std::ostream&amp;amp; operator&amp;lt;&amp;lt;(...)&apos; declares a non-template function [-Wnon-template-friend]&lt;/code&gt;&lt;/p&gt;\n  \n  &lt;p&gt;&lt;code&gt;note: (if this is not what you intended, make sure the function template has already been declared and add &amp;lt;&amp;gt; after the function name here)&lt;/code&gt; &lt;/p&gt;\n&lt;/blockquote&gt;\n    ","\n&lt;h1&gt;When your include paths are different&lt;/h1&gt;\n&lt;p&gt;Linker errors can happen when a header file and its associated shared library (.lib file) go out of sync. Let me explain.&lt;/p&gt;\n&lt;p&gt;How do linkers work? The linker matches a function declaration (declared in the header) with its definition (in the shared library) by comparing their signatures. You can get a linker error if the linker doesn&apos;t find a function definition that matches perfectly.&lt;/p&gt;\n&lt;p&gt;Is it possible to still get a linker error even though the declaration and the definition seem to match? Yes! They might look the same in source code, but it really depends on what the compiler sees. Essentially you could end up with a situation like this:&lt;/p&gt;\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-comment&quot;&gt;// header1.h&lt;/span&gt;\n&lt;span class=&quot;hljs-keyword&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; Number;\n&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(Number)&lt;/span&gt;&lt;/span&gt;;\n\n&lt;span class=&quot;hljs-comment&quot;&gt;// header2.h&lt;/span&gt;\n&lt;span class=&quot;hljs-keyword&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;float&lt;/span&gt; Number;\n&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(Number)&lt;/span&gt;&lt;/span&gt;; &lt;span class=&quot;hljs-comment&quot;&gt;// this only looks the same lexically&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;Note how even though both the function declarations look identical in source code, but they are really different according to the compiler.&lt;/p&gt;\n&lt;p&gt;You might ask how one ends up in a situation like that? &lt;strong&gt;Include paths&lt;/strong&gt; of course! If when compiling the shared library, the include path leads to &lt;code&gt;header1.h&lt;/code&gt; and you end up using &lt;code&gt;header2.h&lt;/code&gt; in your own program, you&apos;ll be left scratching your header wondering what happened (pun intended).&lt;/p&gt;\n&lt;p&gt;An example of how this can happen in the real world is explained below.&lt;/p&gt;\n&lt;h2&gt;Further elaboration with an example&lt;/h2&gt;\n&lt;p&gt;I have two projects: &lt;code&gt;graphics.lib&lt;/code&gt; and &lt;code&gt;main.exe&lt;/code&gt;. Both projects depend on &lt;code&gt;common_math.h&lt;/code&gt;. Suppose the library exports the following function:&lt;/p&gt;\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-comment&quot;&gt;// graphics.lib    &lt;/span&gt;\n&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;common_math.h&quot;&lt;/span&gt; &lt;/span&gt;\n   \n&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;draw&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(vec3 p)&lt;/span&gt; &lt;/span&gt;{ ... } &lt;span class=&quot;hljs-comment&quot;&gt;// vec3 comes from common_math.h&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;And then you go ahead and include the library in your own project.&lt;/p&gt;\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-comment&quot;&gt;// main.exe&lt;/span&gt;\n&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;other/common_math.h&quot;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;graphics.h&quot;&lt;/span&gt;&lt;/span&gt;\n\n&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;{\n    &lt;span class=&quot;hljs-built_in&quot;&gt;draw&lt;/span&gt;(...);\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;Boom! You get a linker error and you have no idea why it&apos;s failing. The reason is that the common library uses different versions of the same include &lt;code&gt;common_math.h&lt;/code&gt; (I have made it obvious here in the example by including a different path, but it might not always be so obvious. Maybe the include path is different in the compiler settings).&lt;/p&gt;\n&lt;p&gt;Note in this example, the linker would tell you it couldn&apos;t find &lt;code&gt;draw()&lt;/code&gt;, when in reality you know it obviously is being exported by the library. You could spend hours scratching your head wondering what went wrong. The thing is, the linker sees a different signature because the parameter types are slightly different. In the example, &lt;code&gt;vec3&lt;/code&gt; is a different type in both projects as far as the compiler is concerned. This could happen because they come from two slightly different include files (maybe the include files come from two different versions of the library).&lt;/p&gt;\n&lt;h2&gt;Debugging the linker&lt;/h2&gt;\n&lt;p&gt;DUMPBIN is your friend, if you are using Visual Studio. I&apos;m sure other compilers have other similar tools.&lt;/p&gt;\n&lt;p&gt;The process goes like this:&lt;/p&gt;\n&lt;ol&gt;\n&lt;li&gt;Note the weird mangled name given in the linker error. (eg. draw@graphics@XYZ).&lt;/li&gt;\n&lt;li&gt;Dump the exported symbols from the library into a text file.&lt;/li&gt;\n&lt;li&gt;Search for the exported symbol of interest, and notice that the mangled name is different.&lt;/li&gt;\n&lt;li&gt;Pay attention to why the mangled names ended up different. You would be able to see that the parameter types are different, even though they look the same in the source code.&lt;/li&gt;\n&lt;li&gt;Reason why they are different. In the example given above, they are different because of different include files.&lt;/li&gt;\n&lt;/ol&gt;\n&lt;p&gt;[1] By project I mean a set of source files that are linked together to produce either a library or an executable.&lt;/p&gt;\n&lt;p&gt;EDIT 1: Rewrote first section to be easier to understand. Please comment below to let me know if something else needs to be fixed. Thanks!&lt;/p&gt;\n    ","\n&lt;h2&gt;Inconsistent &lt;code&gt;UNICODE&lt;/code&gt; definitions&lt;/h2&gt;\n\n&lt;p&gt;A Windows UNICODE build is built with &lt;code&gt;TCHAR&lt;/code&gt; etc. being defined as &lt;code&gt;wchar_t&lt;/code&gt; etc. When not building with &lt;code&gt;UNICODE&lt;/code&gt; defined as build with &lt;code&gt;TCHAR&lt;/code&gt; defined as &lt;code&gt;char&lt;/code&gt; etc. These &lt;code&gt;UNICODE&lt;/code&gt; and &lt;code&gt;_UNICODE&lt;/code&gt; defines affect all the &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/windows/desktop/dd374131(v=vs.85).aspx&quot; rel=&quot;noreferrer&quot;&gt;&quot;&lt;code&gt;T&lt;/code&gt;&quot; string types&lt;/a&gt;; &lt;code&gt;LPTSTR&lt;/code&gt;, &lt;code&gt;LPCTSTR&lt;/code&gt; and their elk.&lt;/p&gt;\n\n&lt;p&gt;Building one library with &lt;code&gt;UNICODE&lt;/code&gt; defined and attempting to link it in a project where &lt;code&gt;UNICODE&lt;/code&gt; is not defined will result in linker errors since there will be a mismatch in the definition of &lt;code&gt;TCHAR&lt;/code&gt;; &lt;code&gt;char&lt;/code&gt; vs. &lt;code&gt;wchar_t&lt;/code&gt;.&lt;/p&gt;\n\n&lt;p&gt;The error usually includes a function a value with a &lt;code&gt;char&lt;/code&gt; or &lt;code&gt;wchar_t&lt;/code&gt; derived type, these could include &lt;code&gt;std::basic_string&amp;lt;&amp;gt;&lt;/code&gt; etc. as well. When browsing through the affected function in the code, there will often be a reference to &lt;code&gt;TCHAR&lt;/code&gt; or &lt;code&gt;std::basic_string&amp;lt;TCHAR&amp;gt;&lt;/code&gt; etc. This is a tell-tale sign that the code was originally intended for both a UNICODE and a Multi-Byte Character (or &quot;narrow&quot;) build.&lt;/p&gt;\n\n&lt;p&gt;To correct this, build all the required libraries and projects with a consistent definition of &lt;code&gt;UNICODE&lt;/code&gt; (and &lt;code&gt;_UNICODE&lt;/code&gt;).&lt;/p&gt;\n\n&lt;ol&gt;\n&lt;li&gt;&lt;p&gt;This can be done with either;&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;define&lt;/span&gt; UNICODE&lt;/span&gt;\n&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;define&lt;/span&gt; _UNICODE&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;\n&lt;li&gt;&lt;p&gt;Or in the project settings;&lt;/p&gt;\n\n&lt;blockquote&gt;\n  &lt;p&gt;Project Properties &amp;gt; General &amp;gt; Project Defaults &amp;gt; Character Set&lt;/p&gt;\n&lt;/blockquote&gt;&lt;/li&gt;\n&lt;li&gt;&lt;p&gt;Or on the command line;&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;/DUNICODE /D_UNICODE\n&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;\n&lt;/ol&gt;\n\n&lt;p&gt;The alternative is applicable as well, if UNICODE is not intended to be used, make sure the defines are not set, and/or the multi-character setting is used in the projects and consistently applied.&lt;/p&gt;\n\n&lt;p&gt;Do not forget to be consistent between the &quot;Release&quot; and &quot;Debug&quot; builds as well.&lt;/p&gt;\n    ","\n&lt;h2&gt;Clean and rebuild&lt;/h2&gt;\n&lt;p&gt;A &quot;clean&quot; of the build can remove the &quot;dead wood&quot; that may be left lying around from previous builds, failed builds, incomplete builds and other build system related build issues.&lt;/p&gt;\n&lt;p&gt;In general the IDE or build will include some form of &quot;clean&quot; function, but this may not be correctly configured (e.g. in a manual makefile) or may fail (e.g. the intermediate or resultant binaries are read-only).&lt;/p&gt;\n&lt;p&gt;Once the &quot;clean&quot; has completed, verify that the &quot;clean&quot; has succeeded and all the generated intermediate file (e.g. an automated makefile) have been successfully removed.&lt;/p&gt;\n&lt;p&gt;This &lt;em&gt;process can be seen as a final resort, but is often a good first step&lt;/em&gt;; especially if the code related to the error has recently been added (either locally or from the source repository).&lt;/p&gt;\n    ","\n&lt;h2&gt;Missing &quot;extern&quot; in &lt;code&gt;const&lt;/code&gt; variable declarations/definitions (C++ only)&lt;/h2&gt;\n\n&lt;p&gt;For people coming from C it might be a surprise that in C++ global &lt;code&gt;const&lt;/code&gt;variables have internal (or static) linkage. In C this was not the case, as all global variables are implicitly &lt;code&gt;extern&lt;/code&gt; (i.e. when the &lt;code&gt;static&lt;/code&gt; keyword is missing).&lt;/p&gt;\n\n&lt;p&gt;Example: &lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-comment&quot;&gt;// file1.cpp&lt;/span&gt;\n&lt;span class=&quot;hljs-type&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; test = &lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt;;    &lt;span class=&quot;hljs-comment&quot;&gt;// in C++ same as &quot;static const int test = 5&quot;&lt;/span&gt;\n&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; test2 = &lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt;;\n\n&lt;span class=&quot;hljs-comment&quot;&gt;// file2.cpp&lt;/span&gt;\n&lt;span class=&quot;hljs-keyword&quot;&gt;extern&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; test;\n&lt;span class=&quot;hljs-keyword&quot;&gt;extern&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; test2;\n\n&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt;\n&lt;/span&gt;{\n &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; x = test;   &lt;span class=&quot;hljs-comment&quot;&gt;// linker error in C++ , no error in C&lt;/span&gt;\n &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; y = test2;  &lt;span class=&quot;hljs-comment&quot;&gt;// no problem&lt;/span&gt;\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;correct would be to use a header file and include it in file2.cpp &lt;em&gt;and&lt;/em&gt; file1.cpp&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;extern&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; test;\n&lt;span class=&quot;hljs-keyword&quot;&gt;extern&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; test2;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Alternatively one could declare the &lt;code&gt;const&lt;/code&gt; variable in file1.cpp with explicit &lt;code&gt;extern&lt;/code&gt;&lt;/p&gt;\n    ","\n&lt;p&gt;Even though this is a pretty old questions with multiple accepted answers, I&apos;d like to share how to resolve an &lt;strong&gt;obscure&lt;/strong&gt; &quot;undefined reference to&quot; error.  &lt;/p&gt;\n\n&lt;h1&gt;Different versions of libraries&lt;/h1&gt;\n\n&lt;p&gt;I was using an alias to refer to &lt;code&gt;std::filesystem::path&lt;/code&gt;: filesystem is in the standard library since C++17 but my program needed to &lt;strong&gt;also compile in C++14&lt;/strong&gt; so I decided to use a variable alias:  &lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (defined _GLIBCXX_EXPERIMENTAL_FILESYSTEM) &lt;span class=&quot;hljs-comment&quot;&gt;//is the included filesystem library experimental? (C++14 and newer: &amp;lt;experimental/filesystem&amp;gt;)&lt;/span&gt;&lt;/span&gt;\n&lt;span class=&quot;hljs-keyword&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;path_t&lt;/span&gt; = std::experimental::filesystem::path;\n&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;elif&lt;/span&gt; (defined _GLIBCXX_FILESYSTEM) &lt;span class=&quot;hljs-comment&quot;&gt;//not experimental (C++17 and newer: &amp;lt;filesystem&amp;gt;)&lt;/span&gt;&lt;/span&gt;\n&lt;span class=&quot;hljs-keyword&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;path_t&lt;/span&gt; = std::filesystem::path;\n&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;endif&lt;/span&gt;&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Let&apos;s say I have three files: main.cpp, file.h, file.cpp:&lt;/p&gt;\n\n&lt;ul&gt;\n&lt;li&gt;&lt;strong&gt;file.h&lt;/strong&gt; #include&apos;s &amp;lt;&lt;strong&gt;experimental::filesystem&lt;/strong&gt;&amp;gt; and contains the code above  &lt;/li&gt;\n&lt;li&gt;&lt;strong&gt;file.cpp&lt;/strong&gt;, the implementation of file.h, #include&apos;s &quot;&lt;strong&gt;file.h&lt;/strong&gt;&quot;  &lt;/li&gt;\n&lt;li&gt;&lt;strong&gt;main.cpp&lt;/strong&gt; #include&apos;s &amp;lt;&lt;strong&gt;filesystem&lt;/strong&gt;&amp;gt; and &quot;&lt;strong&gt;file.h&lt;/strong&gt;&quot;&lt;/li&gt;\n&lt;/ul&gt;\n\n&lt;p&gt;Note the &lt;strong&gt;different libraries&lt;/strong&gt; used in main.cpp and file.h. Since main.cpp #include&apos;d &quot;&lt;strong&gt;file.h&lt;/strong&gt;&quot; after &amp;lt;&lt;strong&gt;filesystem&lt;/strong&gt;&amp;gt;, the version of filesystem used there was &lt;strong&gt;the C++17 one&lt;/strong&gt;. I used to compile the program with the following commands:&lt;/p&gt;\n\n&lt;p&gt;$ &lt;code&gt;g++ -g -std=c++17 -c main.cpp&lt;/code&gt; -&amp;gt; compiles main.cpp to main.o&lt;br&gt;\n$ &lt;code&gt;g++ -g -std=c++17 -c file.cpp&lt;/code&gt; -&amp;gt; compiles file.cpp and file.h to file.o&lt;br&gt;\n$ &lt;code&gt;g++ -g -std=c++17 -o executable main.o file.o -lstdc++fs&lt;/code&gt; -&amp;gt; links main.o and file.o  &lt;/p&gt;\n\n&lt;p&gt;This way &lt;strong&gt;any function&lt;/strong&gt; contained in file.o and used in main.o that &lt;strong&gt;required &lt;code&gt;path_t&lt;/code&gt;&lt;/strong&gt; gave &quot;undefined reference&quot; errors because &lt;strong&gt;main.o&lt;/strong&gt; referred to &lt;strong&gt;&lt;code&gt;std::filesystem::path&lt;/code&gt;&lt;/strong&gt; but &lt;strong&gt;file.o&lt;/strong&gt; to &lt;strong&gt;&lt;code&gt;std::experimental::filesystem::path&lt;/code&gt;&lt;/strong&gt;.  &lt;/p&gt;\n\n&lt;h1&gt;Resolution&lt;/h1&gt;\n\n&lt;p&gt;To fix this I just needed to &lt;strong&gt;change &amp;lt;experimental::filesystem&amp;gt; in file.h to &amp;lt;filesystem&amp;gt;&lt;/strong&gt;.&lt;/p&gt;\n    ","\n&lt;h2&gt;When linking against shared libraries, make sure that the used symbols are not hidden.&lt;/h2&gt;\n\n&lt;p&gt;The default behavior of gcc is that all symbols are visible. However, when the translation units are built with option &lt;code&gt;-fvisibility=hidden&lt;/code&gt;, only functions/symbols marked with &lt;code&gt;__attribute__ ((visibility (&quot;default&quot;)))&lt;/code&gt; are external in the resulting shared object.&lt;/p&gt;\n\n&lt;p&gt;You can check whether the symbols your are looking for are external by invoking:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;# -&lt;span class=&quot;hljs-function&quot;&gt;D &lt;span class=&quot;hljs-title&quot;&gt;shows&lt;/span&gt; &lt;span class=&quot;hljs-params&quot;&gt;(global)&lt;/span&gt; dynamic symbols that can be used from the outside of XXX.so\nnm -D XXX.so | grep MY_SYMBOL \n&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;the hidden/local symbols are shown by &lt;code&gt;nm&lt;/code&gt; with lowercase symbol type, for example &lt;code&gt;t&lt;/code&gt; instead of `T for code-section:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;nm XXX.so\n&lt;span class=&quot;hljs-number&quot;&gt;00000000000005&lt;/span&gt;a7 t HIDDEN_SYMBOL\n&lt;span class=&quot;hljs-number&quot;&gt;00000000000005f&lt;/span&gt;8 T VISIBLE_SYMBOL\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;You can also use &lt;code&gt;nm&lt;/code&gt; with the option &lt;code&gt;-C&lt;/code&gt; to demangle the names (if C++ was used).&lt;/p&gt;\n\n&lt;p&gt;Similar to Windows-dlls, one would mark public functions with a define, for example &lt;code&gt;DLL_PUBLIC&lt;/code&gt; defined as:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;define&lt;/span&gt; DLL_PUBLIC __attribute__ ((visibility (&lt;span class=&quot;hljs-string&quot;&gt;&quot;default&quot;&lt;/span&gt;)))&lt;/span&gt;\n\n&lt;span class=&quot;hljs-function&quot;&gt;DLL_PUBLIC &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;my_public_function&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;{\n  ...\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Which roughly corresponds to Windows&apos;/MSVC-version:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;ifdef&lt;/span&gt; BUILDING_DLL&lt;/span&gt;\n    &lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;define&lt;/span&gt; DLL_PUBLIC __declspec(dllexport) &lt;/span&gt;\n&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;else&lt;/span&gt;&lt;/span&gt;\n    &lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;define&lt;/span&gt; DLL_PUBLIC __declspec(dllimport) &lt;/span&gt;\n&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;endif&lt;/span&gt;&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;More &lt;a href=&quot;https://gcc.gnu.org/wiki/Visibility&quot; rel=&quot;noreferrer&quot;&gt;information about visibility&lt;/a&gt; can be found on the gcc wiki.&lt;/p&gt;\n\n&lt;hr&gt;\n\n&lt;p&gt;When a translation unit is compiled with &lt;code&gt;-fvisibility=hidden&lt;/code&gt; the resulting symbols have still external linkage (shown with upper case symbol type by &lt;code&gt;nm&lt;/code&gt;) and can be used for external linkage without problem if the object files become part of a static libraries. The linkage becomes local only when the object files are linked into a shared library.&lt;/p&gt;\n\n&lt;p&gt;To find which symbols in an object file are hidden run:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&amp;gt;&amp;gt;&amp;gt; objdump -t XXXX.o | grep hidden\n&lt;span class=&quot;hljs-number&quot;&gt;0000000000000000&lt;/span&gt; g     F .text  &lt;span class=&quot;hljs-number&quot;&gt;000000000000000b&lt;/span&gt; .hidden HIDDEN_SYMBOL1\n&lt;span class=&quot;hljs-number&quot;&gt;000000000000000b&lt;/span&gt; g     F .text  &lt;span class=&quot;hljs-number&quot;&gt;000000000000000b&lt;/span&gt; .hidden HIDDEN_SYMBOL2\n&lt;/code&gt;&lt;/pre&gt;\n    ","\n&lt;h2&gt;Functions or class-methods are defined in source files with the &lt;code&gt;inline&lt;/code&gt; specifier.&lt;/h2&gt;\n&lt;p&gt;An example:-&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;main.cpp&lt;/strong&gt;&lt;/p&gt;\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;gum.h&quot;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;foo.h&quot;&lt;/span&gt;&lt;/span&gt;\n\n&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt;\n&lt;/span&gt;{\n    &lt;span class=&quot;hljs-built_in&quot;&gt;gum&lt;/span&gt;();\n    foo f;\n    f.&lt;span class=&quot;hljs-built_in&quot;&gt;bar&lt;/span&gt;();\n    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;;\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;&lt;strong&gt;foo.h (1)&lt;/strong&gt;&lt;/p&gt;\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;pragma&lt;/span&gt; once&lt;/span&gt;\n\n&lt;span class=&quot;hljs-keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;foo&lt;/span&gt; {\n    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;bar&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;const&lt;/span&gt;&lt;/span&gt;;\n};\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;&lt;strong&gt;gum.h (1)&lt;/strong&gt;&lt;/p&gt;\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;pragma&lt;/span&gt; once&lt;/span&gt;\n\n&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;extern&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;gum&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;&lt;strong&gt;foo.cpp (1)&lt;/strong&gt;&lt;/p&gt;\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;foo.h&quot;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;/span&gt;\n\n&lt;span class=&quot;hljs-keyword&quot;&gt;inline&lt;/span&gt; &lt;span class=&quot;hljs-comment&quot;&gt;/* &amp;lt;- wrong! */&lt;/span&gt; &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;foo::bar&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;const&lt;/span&gt; &lt;/span&gt;{\n    std::cout &amp;lt;&amp;lt; __PRETTY_FUNCTION__ &amp;lt;&amp;lt; std::endl;\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;&lt;strong&gt;gum.cpp (1)&lt;/strong&gt;&lt;/p&gt;\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;gum.h&quot;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;/span&gt;\n\n&lt;span class=&quot;hljs-keyword&quot;&gt;inline&lt;/span&gt; &lt;span class=&quot;hljs-comment&quot;&gt;/* &amp;lt;- wrong! */&lt;/span&gt; &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;gum&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt;\n&lt;/span&gt;{\n    std::cout &amp;lt;&amp;lt; __PRETTY_FUNCTION__ &amp;lt;&amp;lt; std::endl;\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;If you specify that &lt;code&gt;gum&lt;/code&gt; (similarly, &lt;code&gt;foo::bar&lt;/code&gt;) is &lt;code&gt;inline&lt;/code&gt; at its definition then\nthe compiler will inline &lt;code&gt;gum&lt;/code&gt; (if it chooses to), by:-&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;not emitting any unique definition of &lt;code&gt;gum&lt;/code&gt;, and therefore&lt;/li&gt;\n&lt;li&gt;not emitting any symbol by which the linker can refer to the definition of &lt;code&gt;gum&lt;/code&gt;, and instead&lt;/li&gt;\n&lt;li&gt;replacing all calls to &lt;code&gt;gum&lt;/code&gt; with inline copies of the compiled body of &lt;code&gt;gum&lt;/code&gt;.&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;As a result, if you define &lt;code&gt;gum&lt;/code&gt; inline in a source file &lt;code&gt;gum.cpp&lt;/code&gt;, it is\ncompiled to an object file &lt;code&gt;gum.o&lt;/code&gt; in which all calls to &lt;code&gt;gum&lt;/code&gt; are inlined\nand no symbol is defined by which the linker can refer to &lt;code&gt;gum&lt;/code&gt;. When you\nlink &lt;code&gt;gum.o&lt;/code&gt; into a program together with another object file, e.g. &lt;code&gt;main.o&lt;/code&gt;\nthat make references to an external symbol &lt;code&gt;gum&lt;/code&gt;, the linker cannot resolve\nthose references. So the linkage fails:&lt;/p&gt;\n&lt;p&gt;Compile:&lt;/p&gt;\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;g++ -c  main.cpp foo.cpp gum.cpp\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;Link:&lt;/p&gt;\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;$ g++ -o prog main.o foo.o gum.o\nmain.o: In function `main&lt;span class=&quot;hljs-number&quot;&gt;&apos;&lt;/span&gt;:\nmain.cpp:(.text+&lt;span class=&quot;hljs-number&quot;&gt;0x18&lt;/span&gt;): undefined reference to `&lt;span class=&quot;hljs-built_in&quot;&gt;gum&lt;/span&gt;()&apos;\nmain.cpp:(.text+&lt;span class=&quot;hljs-number&quot;&gt;0x24&lt;/span&gt;): undefined reference to `foo::&lt;span class=&quot;hljs-built_in&quot;&gt;bar&lt;/span&gt;() &lt;span class=&quot;hljs-type&quot;&gt;const&lt;/span&gt;&lt;span class=&quot;hljs-number&quot;&gt;&apos;&lt;/span&gt;\ncollect2: error: ld returned &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt; exit status\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;You can only define &lt;code&gt;gum&lt;/code&gt; as &lt;code&gt;inline&lt;/code&gt; if the compiler can see its definition in every source file in which &lt;code&gt;gum&lt;/code&gt; may be called. That means its inline definition needs to exist in a &lt;em&gt;header&lt;/em&gt; file that you &lt;em&gt;include&lt;/em&gt; in every source file\nyou compile in which &lt;code&gt;gum&lt;/code&gt; may be called. Do one of two things:&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;Either don&apos;t inline the definitions&lt;/strong&gt;&lt;/p&gt;\n&lt;p&gt;Remove the &lt;code&gt;inline&lt;/code&gt; specifier from the source file definition:&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;foo.cpp (2)&lt;/strong&gt;&lt;/p&gt;\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;foo.h&quot;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;/span&gt;\n\n&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;foo::bar&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;const&lt;/span&gt; &lt;/span&gt;{\n    std::cout &amp;lt;&amp;lt; __PRETTY_FUNCTION__ &amp;lt;&amp;lt; std::endl;\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;&lt;strong&gt;gum.cpp (2)&lt;/strong&gt;&lt;/p&gt;\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;gum.h&quot;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;/span&gt;\n\n&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;gum&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt;\n&lt;/span&gt;{\n    std::cout &amp;lt;&amp;lt; __PRETTY_FUNCTION__ &amp;lt;&amp;lt; std::endl;\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;Rebuild with that:&lt;/p&gt;\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;$ g++ -c  main.cpp foo.cpp gum.cpp\nimk@imk-Inspiron&lt;span class=&quot;hljs-number&quot;&gt;-7559&lt;/span&gt;:~/develop/so/scrap1$ g++ -o prog main.o foo.o gum.o\nimk@imk-Inspiron&lt;span class=&quot;hljs-number&quot;&gt;-7559&lt;/span&gt;:~/develop/so/scrap1$ ./&lt;span class=&quot;hljs-function&quot;&gt;prog\n&lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;gum&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt;\n&lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;foo::bar&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;const&lt;/span&gt;\n&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;Success.&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;Or inline correctly&lt;/strong&gt;&lt;/p&gt;\n&lt;p&gt;Inline definitions in header files:&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;foo.h (2)&lt;/strong&gt;&lt;/p&gt;\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;pragma&lt;/span&gt; once&lt;/span&gt;\n&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;/span&gt;\n\n&lt;span class=&quot;hljs-keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;foo&lt;/span&gt; {\n    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;bar&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;const&lt;/span&gt;  &lt;/span&gt;{ &lt;span class=&quot;hljs-comment&quot;&gt;// In-class definition is implicitly inline&lt;/span&gt;\n        std::cout &amp;lt;&amp;lt; __PRETTY_FUNCTION__ &amp;lt;&amp;lt; std::endl;\n    }\n};\n&lt;span class=&quot;hljs-comment&quot;&gt;// Alternatively...&lt;/span&gt;\n&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; 0&lt;/span&gt;\n&lt;span class=&quot;hljs-keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;foo&lt;/span&gt; {\n    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;bar&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;const&lt;/span&gt;&lt;/span&gt;;\n};\n&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;inline&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;foo::bar&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;const&lt;/span&gt;  &lt;/span&gt;{\n    std::cout &amp;lt;&amp;lt; __PRETTY_FUNCTION__ &amp;lt;&amp;lt; std::endl;\n}\n&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;endif&lt;/span&gt;&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;&lt;strong&gt;gum.h (2)&lt;/strong&gt;&lt;/p&gt;\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;pragma&lt;/span&gt; once&lt;/span&gt;\n&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;/span&gt;\n\n&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;inline&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;gum&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;{\n    std::cout &amp;lt;&amp;lt; __PRETTY_FUNCTION__ &amp;lt;&amp;lt; std::endl;\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;Now we don&apos;t need &lt;code&gt;foo.cpp&lt;/code&gt; or &lt;code&gt;gum.cpp&lt;/code&gt;:&lt;/p&gt;\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;$ g++ -c main.cpp\n$ g++ -o prog main.o\n$ ./&lt;span class=&quot;hljs-function&quot;&gt;prog\n&lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;gum&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt;\n&lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;foo::bar&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;const&lt;/span&gt;\n&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;\n    "]},"randomTags":[{"name":"cpu-architecture","slug":"cpu-architecture"},{"name":"timezone","slug":"timezone"},{"name":"jquery-selectors","slug":"jquery-selectors"},{"name":"tidyr","slug":"tidyr"},{"name":"precision","slug":"precision"},{"name":"integer-division","slug":"integer-division"},{"name":"if-statement","slug":"if-statement"},{"name":"subprocess","slug":"subprocess"},{"name":"extern","slug":"extern"},{"name":"blob","slug":"blob"},{"name":"werkzeug","slug":"werkzeug"},{"name":"algorithm","slug":"algorithm"},{"name":"generic-list","slug":"generic-list"},{"name":"c-strings","slug":"c-strings"},{"name":"floating-point","slug":"floating-point"},{"name":"url-parameters","slug":"url-parameters"},{"name":"networkonmainthread","slug":"networkonmainthread"},{"name":"text","slug":"text"},{"name":"raw-types","slug":"raw-types"},{"name":"operator-precedence","slug":"operator-precedence"}]},"__N_SSG":true}