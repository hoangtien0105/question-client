{"pageProps":{"data":{"count":1,"rows":[{"id":429,"title":"With arrays, why is it the case that a[5] == 5[a]?","slug":"with-arrays-why-is-it-the-case-that-a5-5a-1657387956216","postType":"QUESTION","createdAt":"2022-07-09T17:32:36.000Z","updatedAt":"2022-07-09T17:32:36.000Z","tags":[{"id":2254,"name":"pointer-arithmetic","slug":"pointer-arithmetic","createdAt":"2022-07-09T17:32:36.000Z","updatedAt":"2022-07-09T17:32:36.000Z","Questions_Tags":{"questionId":429,"tagId":2254}}]}]},"slug":"pointer-arithmetic","page":1,"answers":{"429":["\n&lt;p&gt;The C standard defines the &lt;code&gt;[]&lt;/code&gt; operator as follows:&lt;/p&gt;\n\n&lt;p&gt;&lt;code&gt;a[b] == *(a + b)&lt;/code&gt;&lt;/p&gt;\n\n&lt;p&gt;Therefore &lt;code&gt;a[5]&lt;/code&gt; will evaluate to:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;*(a + &lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt;)\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;and &lt;code&gt;5[a]&lt;/code&gt; will evaluate to:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;*(&lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt; + a)\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;&lt;code&gt;a&lt;/code&gt; is a pointer to the first element of the array. &lt;code&gt;a[5]&lt;/code&gt; is the value that&apos;s 5 &lt;strong&gt;elements&lt;/strong&gt; further from &lt;code&gt;a&lt;/code&gt;, which is the same as &lt;code&gt;*(a + 5)&lt;/code&gt;, and from elementary school math we know those are equal (addition is &lt;a href=&quot;https://en.wikipedia.org/wiki/commutative&quot; rel=&quot;noreferrer&quot;&gt;commutative&lt;/a&gt;).&lt;/p&gt;\n    ","\n&lt;p&gt;Because array access is defined in terms of pointers.  &lt;code&gt;a[i]&lt;/code&gt; is defined to mean &lt;code&gt;*(a + i)&lt;/code&gt;, which is commutative.&lt;/p&gt;\n    ","\n&lt;p&gt;I think something is being missed by the other answers.&lt;/p&gt;\n\n&lt;p&gt;Yes, &lt;code&gt;p[i]&lt;/code&gt; is by definition equivalent to &lt;code&gt;*(p+i)&lt;/code&gt;, which (because addition is commutative) is equivalent to &lt;code&gt;*(i+p)&lt;/code&gt;, which (again, by the definition of the &lt;code&gt;[]&lt;/code&gt; operator) is equivalent to &lt;code&gt;i[p]&lt;/code&gt;.&lt;/p&gt;\n\n&lt;p&gt;(And in &lt;code&gt;array[i]&lt;/code&gt;, the array name is implicitly converted to a pointer to the array&apos;s first element.)&lt;/p&gt;\n\n&lt;p&gt;But the commutativity of addition is not all that obvious in this case.&lt;/p&gt;\n\n&lt;p&gt;When both operands are of the same type, or even of different numeric types that are promoted to a common type, commutativity makes perfect sense: &lt;code&gt;x + y == y + x&lt;/code&gt;.&lt;/p&gt;\n\n&lt;p&gt;But in this case we&apos;re talking specifically about pointer arithmetic, where one operand is a pointer and the other is an integer. (Integer + integer is a different operation, and pointer + pointer is nonsense.)&lt;/p&gt;\n\n&lt;p&gt;The C standard&apos;s description of the &lt;code&gt;+&lt;/code&gt; operator (&lt;a href=&quot;http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1570.pdf&quot;&gt;N1570&lt;/a&gt; 6.5.6) says:&lt;/p&gt;\n\n&lt;blockquote&gt;\n  &lt;p&gt;For addition, either both operands shall have arithmetic type, or one\n  operand shall be a pointer to a complete object type and the other\n  shall have integer type.&lt;/p&gt;\n&lt;/blockquote&gt;\n\n&lt;p&gt;It could just as easily have said:&lt;/p&gt;\n\n&lt;blockquote&gt;\n  &lt;p&gt;For addition, either both operands shall have arithmetic type, or &lt;em&gt;the left&lt;/em&gt;\n  operand shall be a pointer to a complete object type and the &lt;em&gt;right operand&lt;/em&gt;\n  shall have integer type.&lt;/p&gt;\n&lt;/blockquote&gt;\n\n&lt;p&gt;in which case both &lt;code&gt;i + p&lt;/code&gt; and &lt;code&gt;i[p]&lt;/code&gt; would be illegal.&lt;/p&gt;\n\n&lt;p&gt;In C++ terms, we really have two sets of overloaded &lt;code&gt;+&lt;/code&gt; operators, which can be loosely described as:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;pointer operator+(pointer p, integer i);\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;and&lt;/p&gt;\n\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;pointer operator+(integer i, pointer p);\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;of which only the first is really necessary.&lt;/p&gt;\n\n&lt;p&gt;So why is it this way?&lt;/p&gt;\n\n&lt;p&gt;C++ inherited this definition from C, which got it from B (the commutativity of array indexing is explicitly mentioned in the 1972 &lt;a href=&quot;https://www.bell-labs.com/usr/dmr/www/kbman.html&quot;&gt;Users&apos; Reference to B&lt;/a&gt;), which got it from &lt;a href=&quot;https://www.bell-labs.com/usr/dmr/www/bcpl.html&quot;&gt;BCPL&lt;/a&gt; (manual dated 1967), which may well have gotten it from even earlier languages (CPL? Algol?).&lt;/p&gt;\n\n&lt;p&gt;So the idea that array indexing is defined in terms of addition, and that addition, even of a pointer and an integer, is commutative, goes back many decades, to C&apos;s ancestor languages.&lt;/p&gt;\n\n&lt;p&gt;Those languages were much less strongly typed than modern C is. In particular, the distinction between pointers and integers was often ignored. (Early C programmers sometimes used pointers as unsigned integers, before the &lt;code&gt;unsigned&lt;/code&gt; keyword was added to the language.) So the idea of making addition non-commutative because the operands are of different types probably wouldn&apos;t have occurred to the designers of those languages. If a user wanted to add two &quot;things&quot;, whether those &quot;things&quot; are integers, pointers, or something else, it wasn&apos;t up to the language to prevent it.&lt;/p&gt;\n\n&lt;p&gt;And over the years, any change to that rule would have broken existing code (though the 1989 ANSI C standard might have been a good opportunity).&lt;/p&gt;\n\n&lt;p&gt;Changing C and/or C++ to require putting the pointer on the left and the integer on the right might break some existing code, but there would be no loss of real expressive power.&lt;/p&gt;\n\n&lt;p&gt;So now we have &lt;code&gt;arr[3]&lt;/code&gt; and &lt;code&gt;3[arr]&lt;/code&gt; meaning exactly the same thing, though the latter form should never appear outside the &lt;a href=&quot;http://ioccc.org/&quot;&gt;IOCCC&lt;/a&gt;.&lt;/p&gt;\n    ","\n&lt;p&gt;And, of course&lt;/p&gt;\n\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt; (&lt;span class=&quot;hljs-string&quot;&gt;&quot;ABCD&quot;&lt;/span&gt;[&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;] == &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;[&lt;span class=&quot;hljs-string&quot;&gt;&quot;ABCD&quot;&lt;/span&gt;]) &amp;amp;&amp;amp; (&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;[&lt;span class=&quot;hljs-string&quot;&gt;&quot;ABCD&quot;&lt;/span&gt;] == &lt;span class=&quot;hljs-string&quot;&gt;&apos;C&apos;&lt;/span&gt;) &amp;amp;&amp;amp; (&lt;span class=&quot;hljs-string&quot;&gt;&quot;ABCD&quot;&lt;/span&gt;[&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;] == &lt;span class=&quot;hljs-string&quot;&gt;&apos;C&apos;&lt;/span&gt;)\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;The main reason for this was that back in the 70&apos;s when C was designed, computers didn&apos;t have much memory (64KB was a lot), so the C compiler didn&apos;t do much syntax checking.  Hence &quot;&lt;code&gt;X[Y]&lt;/code&gt;&quot; was rather blindly translated into &quot;&lt;code&gt;*(X+Y)&lt;/code&gt;&quot;  &lt;/p&gt;\n\n&lt;p&gt;This also explains the &quot;&lt;code&gt;+=&lt;/code&gt;&quot; and &quot;&lt;code&gt;++&lt;/code&gt;&quot; syntaxes.  Everything in the form &quot;&lt;code&gt;A = B + C&lt;/code&gt;&quot; had the same compiled form.  But, if B was the same object as A, then an assembly level optimization was available.  But the compiler wasn&apos;t bright enough to recognize it, so the developer had to (&lt;code&gt;A += C&lt;/code&gt;).   Similarly, if &lt;code&gt;C&lt;/code&gt; was &lt;code&gt;1&lt;/code&gt;, a different assembly level optimization was available, and again the developer had to make it explicit, because the compiler didn&apos;t recognize it.   (More recently compilers do, so those syntaxes are largely unnecessary these days)&lt;/p&gt;\n    ","\n&lt;p&gt;One thing no-one seems to have mentioned about Dinah&apos;s problem with &lt;code&gt;sizeof&lt;/code&gt;:&lt;/p&gt;\n\n&lt;p&gt;You can only add an integer to a pointer, you can&apos;t add two pointers together. That way when adding a pointer to an integer, or an integer to a pointer, the compiler always knows which bit has a size that needs to be taken into account.&lt;/p&gt;\n    ","\n&lt;p&gt;To answer the question literally. It is not always true that &lt;code&gt;x == x&lt;/code&gt;&lt;/p&gt;\n\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;double&lt;/span&gt; zero = &lt;span class=&quot;hljs-number&quot;&gt;0.0&lt;/span&gt;;\n&lt;span class=&quot;hljs-type&quot;&gt;double&lt;/span&gt; a[] = { &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;, zero/zero}; &lt;span class=&quot;hljs-comment&quot;&gt;// NaN&lt;/span&gt;\n&lt;span class=&quot;hljs-built_in&quot;&gt;cout&lt;/span&gt; &amp;lt;&amp;lt; (a[&lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt;] == &lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt;[a] ? &lt;span class=&quot;hljs-string&quot;&gt;&quot;true&quot;&lt;/span&gt; : &lt;span class=&quot;hljs-string&quot;&gt;&quot;false&quot;&lt;/span&gt;) &amp;lt;&amp;lt; &lt;span class=&quot;hljs-built_in&quot;&gt;endl&lt;/span&gt;;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;prints&lt;/p&gt;\n\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;&lt;span class=&quot;hljs-literal&quot;&gt;false&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n    ","\n&lt;p&gt;I just find out this ugly syntax could be &quot;useful&quot;, or at least very fun to play with when you want to deal with an array of indexes which refer to positions into the same array. It can replace nested square brackets and make the code more readable !&lt;/p&gt;\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; a[] = { &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt; , &lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt; , &lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt; , &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt; , &lt;span class=&quot;hljs-number&quot;&gt;4&lt;/span&gt; };\n&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; s = &lt;span class=&quot;hljs-keyword&quot;&gt;sizeof&lt;/span&gt; a / &lt;span class=&quot;hljs-keyword&quot;&gt;sizeof&lt;/span&gt; *a;  &lt;span class=&quot;hljs-comment&quot;&gt;//  s == 5&lt;/span&gt;\n\n&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt; ; i &amp;lt; s ; ++i) {  \n           \n    &lt;span class=&quot;hljs-built_in&quot;&gt;cout&lt;/span&gt; &amp;lt;&amp;lt; a[a[a[i]]] &amp;lt;&amp;lt; &lt;span class=&quot;hljs-built_in&quot;&gt;endl&lt;/span&gt;;\n    &lt;span class=&quot;hljs-comment&quot;&gt;// ... is equivalent to ...&lt;/span&gt;\n    &lt;span class=&quot;hljs-built_in&quot;&gt;cout&lt;/span&gt; &amp;lt;&amp;lt; i[a][a][a] &amp;lt;&amp;lt; &lt;span class=&quot;hljs-built_in&quot;&gt;endl&lt;/span&gt;;  &lt;span class=&quot;hljs-comment&quot;&gt;// but I prefer this one, it&apos;s easier to increase the level of indirection (without loop)&lt;/span&gt;\n    \n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;Of course, I&apos;m quite sure that there is no use case for that in real code, but I found it interesting anyway :)&lt;/p&gt;\n    ","\n&lt;p&gt;Nice question/answers.&lt;/p&gt;\n\n&lt;p&gt;Just want to point out that C pointers and arrays are not the &lt;em&gt;same&lt;/em&gt;, although in this case the difference is not essential. &lt;/p&gt;\n\n&lt;p&gt;Consider the following declarations:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; a[&lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;];\n&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt;* p = a;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;In &lt;code&gt;a.out&lt;/code&gt;, the symbol &lt;code&gt;a&lt;/code&gt; is at an address that&apos;s the beginning of the array, and symbol &lt;code&gt;p&lt;/code&gt; is at an address where a pointer is stored, and the value of the pointer at that memory location is the beginning of the array. &lt;/p&gt;\n    ","\n&lt;p&gt;For pointers in C, we have&lt;/p&gt;\n\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;a[&lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt;] == *(a + &lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt;)\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;and also&lt;/p&gt;\n\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;&lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt;[a] == *(&lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt; + a)\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Hence it is true that &lt;code&gt;a[5] == 5[a].&lt;/code&gt;&lt;/p&gt;\n    ","\n&lt;p&gt;Not an answer, but just some food for thought.\nIf class is having overloaded index/subscript operator, the expression &lt;code&gt;0[x]&lt;/code&gt; will not work:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;&lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;Sub&lt;/span&gt;\n{&lt;/span&gt;\npublic:\n    &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; operator [](&lt;span class=&quot;hljs-type&quot;&gt;size_t&lt;/span&gt; nIndex)\n    {\n        &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;;\n    }   \n};\n\n&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt;\n{\n    Sub s;\n    s[&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;];\n    &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;[s]; &lt;span class=&quot;hljs-comment&quot;&gt;// ERROR &lt;/span&gt;\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Since we dont have access to &lt;strong&gt;int&lt;/strong&gt; class, this cannot be done:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;&lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;int&lt;/span&gt;\n{&lt;/span&gt;\n   &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; operator[](&lt;span class=&quot;hljs-type&quot;&gt;const&lt;/span&gt; Sub&amp;amp;);\n};\n&lt;/code&gt;&lt;/pre&gt;\n    ","\n&lt;p&gt;It has very good explanation in &lt;em&gt;A TUTORIAL ON POINTERS AND ARRAYS IN C&lt;/em&gt;\nby Ted Jensen.&lt;/p&gt;\n\n&lt;p&gt;Ted Jensen explained it as:&lt;/p&gt;\n\n&lt;blockquote&gt;\n  &lt;p&gt;In fact, this is true, i.e wherever one writes &lt;code&gt;a[i]&lt;/code&gt; it can be\n  replaced with &lt;code&gt;*(a + i)&lt;/code&gt;  without any problems. In fact, the compiler\n  will create the same code in either case. Thus we see that pointer\n  arithmetic is the same thing as array indexing. Either syntax produces\n  the same result.&lt;/p&gt;\n  \n  &lt;p&gt;This is NOT saying that pointers and arrays\n  are the same thing, they are not. We are only saying that to identify\n  a given element of an array we have the choice of two syntaxes, one\n  using array indexing and the other using pointer arithmetic, which\n  yield identical results.&lt;/p&gt;\n  \n  &lt;p&gt;Now, looking at this last\n  expression, part of it.. &lt;code&gt;(a + i)&lt;/code&gt;, is a simple addition using the +\n  operator and the rules of C state that such an expression is\n  commutative. That is (a + i) is identical to &lt;code&gt;(i + a)&lt;/code&gt;. Thus we could\n  write &lt;code&gt;*(i + a)&lt;/code&gt; just as easily as &lt;code&gt;*(a + i)&lt;/code&gt;.\n  But &lt;code&gt;*(i + a)&lt;/code&gt; could have come from &lt;code&gt;i[a]&lt;/code&gt; ! From all of this comes the curious\n  truth that if:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;char&lt;/span&gt; a[&lt;span class=&quot;hljs-number&quot;&gt;20&lt;/span&gt;];\n&lt;/code&gt;&lt;/pre&gt;\n  \n  &lt;p&gt;writing&lt;/p&gt;\n\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;a[&lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;] = &lt;span class=&quot;hljs-string&quot;&gt;&apos;x&apos;&lt;/span&gt;;\n&lt;/code&gt;&lt;/pre&gt;\n  \n  &lt;p&gt;is the same as writing&lt;/p&gt;\n\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;&lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;[a] = &lt;span class=&quot;hljs-string&quot;&gt;&apos;x&apos;&lt;/span&gt;;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;/blockquote&gt;\n    ","\n&lt;p&gt;I know the question is answered, but I couldn&apos;t resist sharing this explanation.&lt;/p&gt;\n\n&lt;p&gt;I remember Principles of Compiler design,\nLet&apos;s assume &lt;code&gt;a&lt;/code&gt; is an &lt;code&gt;int&lt;/code&gt; array and size of &lt;code&gt;int&lt;/code&gt; is 2 bytes,\n&amp;amp; Base address for &lt;code&gt;a&lt;/code&gt; is 1000.&lt;/p&gt;\n\n&lt;p&gt;How &lt;code&gt;a[5]&lt;/code&gt; will work -&amp;gt;&lt;/p&gt;\n\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;Base Address of your Array a + (&lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt;*size of(data type &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;hljs-built_in&quot;&gt;array&lt;/span&gt; a))\ni.e. &lt;span class=&quot;hljs-number&quot;&gt;1000&lt;/span&gt; + (&lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt;*&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;) = &lt;span class=&quot;hljs-number&quot;&gt;1010&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;So, &lt;/p&gt;\n\n&lt;p&gt;Similarly when the c code is broken down into 3-address code, \n&lt;code&gt;5[a]&lt;/code&gt; will become -&amp;gt;&lt;/p&gt;\n\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;Base Address of your Array a + (size of(data type &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;hljs-built_in&quot;&gt;array&lt;/span&gt; a)*&lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt;)\ni.e. &lt;span class=&quot;hljs-number&quot;&gt;1000&lt;/span&gt; + (&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;*&lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt;) = &lt;span class=&quot;hljs-number&quot;&gt;1010&lt;/span&gt; \n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;So basically both the statements are pointing to the same location in memory and hence, &lt;code&gt;a[5] = 5[a]&lt;/code&gt;.&lt;/p&gt;\n\n&lt;p&gt;This explanation is also the reason why negative indexes in arrays work in C.&lt;/p&gt;\n\n&lt;p&gt;i.e. if I access &lt;code&gt;a[-5]&lt;/code&gt; it will give me&lt;/p&gt;\n\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;Base Address of your Array a + (&lt;span class=&quot;hljs-number&quot;&gt;-5&lt;/span&gt; * size of(data type &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;hljs-built_in&quot;&gt;array&lt;/span&gt; a))\ni.e. &lt;span class=&quot;hljs-number&quot;&gt;1000&lt;/span&gt; + (&lt;span class=&quot;hljs-number&quot;&gt;-5&lt;/span&gt;*&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;) = &lt;span class=&quot;hljs-number&quot;&gt;990&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;It will return me object at location 990.&lt;/p&gt;\n    ","\n&lt;p&gt;in c compiler &lt;/p&gt;\n\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;a[i]\ni[a]\n*(a+i)\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;are different ways to refer to  an element in an array ! (NOT AT ALL WEIRD)&lt;/p&gt;\n    ","\n&lt;p&gt;In C arrays, &lt;code&gt;arr[3]&lt;/code&gt; and &lt;code&gt;3[arr]&lt;/code&gt; are the same, and their equivalent pointer notations are &lt;code&gt;*(arr + 3)&lt;/code&gt; to &lt;code&gt;*(3 + arr)&lt;/code&gt;. But on the contrary &lt;code&gt;[arr]3&lt;/code&gt; or &lt;code&gt;[3]arr&lt;/code&gt; is not correct and will result into syntax error, as &lt;code&gt;(arr + 3)*&lt;/code&gt; and &lt;code&gt;(3 + arr)*&lt;/code&gt; are not valid expressions. The reason is dereference operator should be placed before the address yielded by the expression, not after the address.&lt;/p&gt;\n    ","\n&lt;p&gt;A little bit of history now.  Among other languages, BCPL had a fairly major influence on C&apos;s early development.  If you declared an array in BCPL with something like:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;let V = vec &lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;that actually allocated 11 words of memory, not 10.  Typically V was the first, and contained the address of the immediately following word.  So unlike C, naming V went to that location and picked up the address of the zeroeth element of the array.  Therefore array indirection in BCPL, expressed as&lt;/p&gt;\n\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;let J = V!&lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;really did have to do &lt;code&gt;J = !(V + 5)&lt;/code&gt; (using BCPL syntax) since it was necessary to fetch V to get the base address of the array.  Thus &lt;code&gt;V!5&lt;/code&gt; and &lt;code&gt;5!V&lt;/code&gt; were synonymous.  As an anecdotal observation, WAFL (Warwick Functional Language) was written in BCPL, and to the best of my memory tended to use the latter syntax rather than the former for accessing the nodes used as data storage.  Granted this is from somewhere between 35 and 40 years ago, so my memory is a little rusty. :)&lt;/p&gt;\n\n&lt;p&gt;The innovation of dispensing with the extra word of storage and having the compiler insert the base address of the array when it was named came later.  According to the C history paper this happened at about the time structures were added to C.&lt;/p&gt;\n\n&lt;p&gt;Note that &lt;code&gt;!&lt;/code&gt; in BCPL was both a unary prefix operator and a binary infix operator, in both cases doing indirection. just that the binary form included an addition of the two operands before doing the indirection.  Given the word oriented nature of BCPL (and B) this actually made a lot of sense.  The restriction of &quot;pointer and integer&quot; was made necessary in C when it gained data types, and &lt;code&gt;sizeof&lt;/code&gt; became a thing.&lt;/p&gt;\n    ","\n&lt;p&gt;Well, this is a feature that is only possible because of the language support.&lt;/p&gt;\n\n&lt;p&gt;The compiler interprets &lt;code&gt;a[i]&lt;/code&gt; as &lt;code&gt;*(a+i)&lt;/code&gt; and the expression &lt;code&gt;5[a]&lt;/code&gt; evaluates to &lt;code&gt;*(5+a)&lt;/code&gt;. Since addition is commutative it turns out that both are equal. Hence the expression evaluates to &lt;code&gt;true&lt;/code&gt;.&lt;/p&gt;\n    ","\n&lt;p&gt;In C&lt;/p&gt;\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt; &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; a[]={&lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;20&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;30&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;40&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;50&lt;/span&gt;};\n &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; *p=a;\n &lt;span class=&quot;hljs-built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;%d\\n&quot;&lt;/span&gt;,*p++);&lt;span class=&quot;hljs-comment&quot;&gt;//output will be 10&lt;/span&gt;\n &lt;span class=&quot;hljs-built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;%d\\n&quot;&lt;/span&gt;,*a++);&lt;span class=&quot;hljs-comment&quot;&gt;//will give an error&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;Pointer &lt;code&gt;p&lt;/code&gt; is a &quot;variable&quot;, array name &lt;code&gt;a&lt;/code&gt; is a &quot;mnemonic&quot; or &quot;synonym&quot;,\nso &lt;code&gt;p++&lt;/code&gt; is valid but &lt;code&gt;a++&lt;/code&gt; is invalid.&lt;/p&gt;\n&lt;p&gt;&lt;code&gt;a[2]&lt;/code&gt; is equals to &lt;code&gt;2[a]&lt;/code&gt; because the internal operation on both of this is &quot;Pointer Arithmetic&quot; internally calculated as &lt;code&gt;*(a+2)&lt;/code&gt; equals &lt;code&gt;*(2+a)&lt;/code&gt;&lt;/p&gt;\n    ","\n&lt;p&gt;Because C compiler always convert array notation in pointer notation.\n&lt;code&gt;a[5] = *(a + 5)&lt;/code&gt;  also &lt;code&gt;5[a] = *(5 + a) = *(a + 5)&lt;/code&gt;\nSo, both are equal.&lt;/p&gt;\n    ","\n&lt;p&gt;Because it&apos;s useful to avoid confusing nesting.&lt;/p&gt;\n&lt;p&gt;Would you rather read this:&lt;/p&gt;\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;array&lt;/span&gt;[&lt;span class=&quot;hljs-built_in&quot;&gt;array&lt;/span&gt;[head].next].prev\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;or this:&lt;/p&gt;\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;head[&lt;span class=&quot;hljs-built_in&quot;&gt;array&lt;/span&gt;].next[&lt;span class=&quot;hljs-built_in&quot;&gt;array&lt;/span&gt;].prev\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;Incidentally, C++ has a similar commutative property for function calls. Rather than writing &lt;code&gt;g(f(x))&lt;/code&gt; as you must in C, you may use member functions to write &lt;code&gt;x.f().g()&lt;/code&gt;. Replace f and g with lookup tables and you can write &lt;code&gt;g[f[x]]&lt;/code&gt; (functional style) or &lt;code&gt;(x[f])[g]&lt;/code&gt; (oop style). The latter gets really nice with structs containing indices: &lt;code&gt;x[xs].y[ys].z[zs]&lt;/code&gt;. Using the more common notation that&apos;s &lt;code&gt;zs[ys[xs[x].y].z]&lt;/code&gt;.&lt;/p&gt;\n    "]},"randomTags":[{"name":"getter","slug":"getter"},{"name":"hash","slug":"hash"},{"name":"server-side","slug":"server-side"},{"name":"httpurlconnection","slug":"httpurlconnection"},{"name":"http-status-code-404","slug":"http-status-code-404"},{"name":"path","slug":"path"},{"name":"language-lawyer","slug":"language-lawyer"},{"name":"pythonpath","slug":"pythonpath"},{"name":"facelets","slug":"facelets"},{"name":"nested","slug":"nested"},{"name":"ctor-initializer","slug":"ctor-initializer"},{"name":"git-revert","slug":"git-revert"},{"name":"object-literal","slug":"object-literal"},{"name":"command-line","slug":"command-line"},{"name":"identity-operator","slug":"identity-operator"},{"name":"sh","slug":"sh"},{"name":"copy-constructor","slug":"copy-constructor"},{"name":"android-permissions","slug":"android-permissions"},{"name":"timezone","slug":"timezone"},{"name":"winforms","slug":"winforms"}]},"__N_SSG":true}