{"pageProps":{"data":{"count":1,"rows":[{"id":35,"title":"Why is iostream::eof inside a loop condition (i.e. `while (!stream.eof())`) considered wrong?","slug":"why-is-iostream::eof-inside-a-loop-condition-(i.e.-while-(!stream.eof()))-considered-wrong-1657384355427","postType":"QUESTION","createdAt":"2022-07-09T16:32:35.000Z","updatedAt":"2022-07-09T16:32:35.000Z","tags":[{"id":122,"name":"iostream","slug":"iostream","createdAt":"2022-07-09T16:32:35.000Z","updatedAt":"2022-07-09T16:32:35.000Z","Questions_Tags":{"questionId":35,"tagId":122}}]}]},"slug":"iostream","page":"1","answers":{"35":["\n&lt;p&gt;Because &lt;code&gt;iostream::eof&lt;/code&gt; will only return &lt;code&gt;true&lt;/code&gt; &lt;em&gt;after&lt;/em&gt; reading the end of the stream. It does &lt;em&gt;not&lt;/em&gt; indicate, that the next read will be the end of the stream.&lt;/p&gt;\n\n&lt;p&gt;Consider this (and assume then next read will be at the end of the stream):&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;while&lt;/span&gt;(!inStream.&lt;span class=&quot;hljs-built_in&quot;&gt;eof&lt;/span&gt;()){\n  &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; data;\n  &lt;span class=&quot;hljs-comment&quot;&gt;// yay, not end of stream yet, now read ...&lt;/span&gt;\n  inStream &amp;gt;&amp;gt; data;\n  &lt;span class=&quot;hljs-comment&quot;&gt;// oh crap, now we read the end and *only* now the eof bit will be set (as well as the fail bit)&lt;/span&gt;\n  &lt;span class=&quot;hljs-comment&quot;&gt;// do stuff with (now uninitialized) data&lt;/span&gt;\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Against this:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; data;\n&lt;span class=&quot;hljs-keyword&quot;&gt;while&lt;/span&gt;(inStream &amp;gt;&amp;gt; data){\n  &lt;span class=&quot;hljs-comment&quot;&gt;// when we land here, we can be sure that the read was successful.&lt;/span&gt;\n  &lt;span class=&quot;hljs-comment&quot;&gt;// if it wasn&apos;t, the returned stream from operator&amp;gt;&amp;gt; would be converted to false&lt;/span&gt;\n  &lt;span class=&quot;hljs-comment&quot;&gt;// and the loop wouldn&apos;t even be entered&lt;/span&gt;\n  &lt;span class=&quot;hljs-comment&quot;&gt;// do stuff with correctly initialized data (hopefully)&lt;/span&gt;\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;And on your second question: Because&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt;(&lt;span class=&quot;hljs-built_in&quot;&gt;scanf&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;...&quot;&lt;/span&gt;,...)!=EOF)\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;is the same as&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt;(!(inStream &amp;gt;&amp;gt; data).&lt;span class=&quot;hljs-built_in&quot;&gt;eof&lt;/span&gt;())\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;and &lt;strong&gt;not&lt;/strong&gt; the same as&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt;(!inStream.&lt;span class=&quot;hljs-built_in&quot;&gt;eof&lt;/span&gt;())\n    inFile &amp;gt;&amp;gt; data\n&lt;/code&gt;&lt;/pre&gt;\n    ","\n&lt;p&gt;&lt;strong&gt;Bottom-line top:&lt;/strong&gt;  With proper handling of white-space, the following is how &lt;code&gt;eof&lt;/code&gt; can be used (and even, be more reliable than &lt;code&gt;fail()&lt;/code&gt; for error checking):&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;while&lt;/span&gt;( !(in&amp;gt;&amp;gt;std::ws).&lt;span class=&quot;hljs-built_in&quot;&gt;eof&lt;/span&gt;() ) {  \n   &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; data;\n   in &amp;gt;&amp;gt; data;\n   &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; ( in.&lt;span class=&quot;hljs-built_in&quot;&gt;fail&lt;/span&gt;() ) &lt;span class=&quot;hljs-comment&quot;&gt;/* handle with break or throw */&lt;/span&gt;; \n   &lt;span class=&quot;hljs-comment&quot;&gt;// now use data&lt;/span&gt;\n}    \n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;(&lt;em&gt;Thanks Tony D for the suggestion to highlight the answer. See his comment below for an example to why this is more robust.&lt;/em&gt;)&lt;/p&gt;\n\n&lt;hr&gt;\n\n&lt;p&gt;The main argument against using &lt;code&gt;eof()&lt;/code&gt; seems to be missing an important subtlety about the role of white space. My proposition is that, checking &lt;code&gt;eof()&lt;/code&gt; explicitly is not only not &quot;&lt;em&gt;always wrong&lt;/em&gt;&quot; -- which seems to be an overriding opinion in this and similar SO threads --, but with proper handling of white-space, it provides for a cleaner and more reliable error handling, and is the &lt;em&gt;always correct&lt;/em&gt; solution (although, not necessarily the tersest).&lt;/p&gt;\n\n&lt;p&gt;To summarize what is being suggested as the &quot;proper&quot; termination and read order is the following:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; data;\n&lt;span class=&quot;hljs-keyword&quot;&gt;while&lt;/span&gt;(in &amp;gt;&amp;gt; data) {  &lt;span class=&quot;hljs-comment&quot;&gt;/* ... */&lt;/span&gt; }\n\n&lt;span class=&quot;hljs-comment&quot;&gt;// which is equivalent to &lt;/span&gt;\n&lt;span class=&quot;hljs-keyword&quot;&gt;while&lt;/span&gt;( !(in &amp;gt;&amp;gt; data).&lt;span class=&quot;hljs-built_in&quot;&gt;fail&lt;/span&gt;() )  {  &lt;span class=&quot;hljs-comment&quot;&gt;/* ... */&lt;/span&gt; }\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;The failure due to read attempt beyond eof is taken as the termination condition.  This means is that there is no easy way to distinguish between a successful stream and one that really fails for reasons other than eof. Take the following streams: &lt;/p&gt;\n\n&lt;ul&gt;\n&lt;li&gt;&lt;code&gt;1 2 3 4 5&amp;lt;eof&amp;gt;&lt;/code&gt;&lt;/li&gt;\n&lt;li&gt;&lt;code&gt;1 2 a 3 4 5&amp;lt;eof&amp;gt;&lt;/code&gt; &lt;/li&gt;\n&lt;li&gt;&lt;code&gt;a&amp;lt;eof&amp;gt;&lt;/code&gt;&lt;/li&gt;\n&lt;/ul&gt;\n\n&lt;p&gt;&lt;code&gt;while(in&amp;gt;&amp;gt;data)&lt;/code&gt; terminates with a set &lt;code&gt;failbit&lt;/code&gt; for &lt;em&gt;all&lt;/em&gt; three input. In the first and third, &lt;code&gt;eofbit&lt;/code&gt; is also set. So past the loop one needs very ugly extra logic to distinguish a proper input (1st) from improper ones (2nd and 3rd).&lt;/p&gt;\n\n&lt;p&gt;Whereas, take the following: &lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;while&lt;/span&gt;( !in.&lt;span class=&quot;hljs-built_in&quot;&gt;eof&lt;/span&gt;() ) \n{  \n   &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; data;\n   in &amp;gt;&amp;gt; data;\n   &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; ( in.&lt;span class=&quot;hljs-built_in&quot;&gt;fail&lt;/span&gt;() ) &lt;span class=&quot;hljs-comment&quot;&gt;/* handle with break or throw */&lt;/span&gt;; \n   &lt;span class=&quot;hljs-comment&quot;&gt;// now use data&lt;/span&gt;\n}    \n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Here, &lt;code&gt;in.fail()&lt;/code&gt; verifies that as long as there is something to read, it is the correct one. It&apos;s purpose is not a mere while-loop terminator. &lt;/p&gt;\n\n&lt;p&gt;So far so good, but what happens if there is trailing space in the stream -- what sounds like the major concern against &lt;code&gt;eof()&lt;/code&gt; as terminator?&lt;/p&gt;\n\n&lt;p&gt;We don&apos;t need to surrender our error handling; just eat up the white-space:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;while&lt;/span&gt;( !in.&lt;span class=&quot;hljs-built_in&quot;&gt;eof&lt;/span&gt;() ) \n{  \n   &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; data;\n   in &amp;gt;&amp;gt; data &amp;gt;&amp;gt; ws; &lt;span class=&quot;hljs-comment&quot;&gt;// eat whitespace with std::ws&lt;/span&gt;\n   &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; ( in.&lt;span class=&quot;hljs-built_in&quot;&gt;fail&lt;/span&gt;() ) &lt;span class=&quot;hljs-comment&quot;&gt;/* handle with break or throw */&lt;/span&gt;; \n   &lt;span class=&quot;hljs-comment&quot;&gt;// now use data&lt;/span&gt;\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;&lt;code&gt;std::ws&lt;/code&gt; skips any potential (zero or more) trailing space in the stream while setting the &lt;code&gt;eofbit&lt;/code&gt;, and &lt;strong&gt;not the &lt;code&gt;failbit&lt;/code&gt;&lt;/strong&gt;.  So, &lt;code&gt;in.fail()&lt;/code&gt; works as expected, as long as there is at least one data to read. If all-blank streams are also acceptable, then the correct form is:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;while&lt;/span&gt;( !(in&amp;gt;&amp;gt;ws).&lt;span class=&quot;hljs-built_in&quot;&gt;eof&lt;/span&gt;() ) \n{  \n   &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; data;\n   in &amp;gt;&amp;gt; data; \n   &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; ( in.&lt;span class=&quot;hljs-built_in&quot;&gt;fail&lt;/span&gt;() ) &lt;span class=&quot;hljs-comment&quot;&gt;/* handle with break or throw */&lt;/span&gt;; \n   &lt;span class=&quot;hljs-comment&quot;&gt;/* this will never fire if the eof is reached cleanly */&lt;/span&gt;\n   &lt;span class=&quot;hljs-comment&quot;&gt;// now use data&lt;/span&gt;\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;&lt;strong&gt;Summary:&lt;/strong&gt; A properly constructed &lt;code&gt;while(!eof)&lt;/code&gt; is not only possible and not wrong, but allows data to be localized within scope, and provides a cleaner separation of error checking from business as usual.  That being said, &lt;code&gt;while(!fail)&lt;/code&gt; is inarguably a more common and terse idiom, and may be preferred in simple (single data per read type of) scenarios. &lt;/p&gt;\n    ","\n&lt;p&gt;Because if programmers don&apos;t write &lt;code&gt;while(stream &amp;gt;&amp;gt; n)&lt;/code&gt;, they possibly write this:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;while&lt;/span&gt;(!stream.&lt;span class=&quot;hljs-built_in&quot;&gt;eof&lt;/span&gt;())\n{\n    stream &amp;gt;&amp;gt; n;\n    &lt;span class=&quot;hljs-comment&quot;&gt;//some work on n;&lt;/span&gt;\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Here the problem is, you cannot do &lt;code&gt;some work on n&lt;/code&gt; without first checking if the stream read was successful, because if it was unsuccessful, your &lt;code&gt;some work on n&lt;/code&gt; would produce undesired result.&lt;/p&gt;\n\n&lt;p&gt;The whole point is that, &lt;code&gt;eofbit&lt;/code&gt;, &lt;code&gt;badbit&lt;/code&gt;, or &lt;code&gt;failbit&lt;/code&gt; are set &lt;strong&gt;after an attempt is made to read from the stream.&lt;/strong&gt; So if &lt;code&gt;stream &amp;gt;&amp;gt; n&lt;/code&gt; fails, then &lt;code&gt;eofbit&lt;/code&gt;, &lt;code&gt;badbit&lt;/code&gt;, or &lt;code&gt;failbit&lt;/code&gt; is set immediately, so its more idiomatic if you write &lt;code&gt;while (stream &amp;gt;&amp;gt; n)&lt;/code&gt;, because the returned object &lt;code&gt;stream&lt;/code&gt; converts to &lt;code&gt;false&lt;/code&gt; if there was some failure in reading from the stream and consequently the loop stops. And it converts to &lt;code&gt;true&lt;/code&gt; if the read was successful and the loop continues.&lt;/p&gt;\n    ","\n&lt;p&gt;The other answers have explained why the logic is wrong in &lt;code&gt;while (!stream.eof())&lt;/code&gt; and how to fix it. I want to focus on something different:&lt;/p&gt;\n\n&lt;blockquote&gt;\n  &lt;p&gt;why is checking for eof explicitly using &lt;code&gt;iostream::eof&lt;/code&gt; wrong?&lt;/p&gt;\n&lt;/blockquote&gt;\n\n&lt;p&gt;In general terms, checking for &lt;code&gt;eof&lt;/code&gt; &lt;em&gt;only&lt;/em&gt; is wrong because stream extraction (&lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt;) can fail without hitting the end of the file. If you have e.g. &lt;code&gt;int n; cin &amp;gt;&amp;gt; n;&lt;/code&gt; and the stream contains &lt;code&gt;hello&lt;/code&gt;, then &lt;code&gt;h&lt;/code&gt; is not a valid digit, so extraction will fail without reaching the end of the input.&lt;/p&gt;\n\n&lt;p&gt;This issue, combined with the general logic error of checking the stream state &lt;em&gt;before&lt;/em&gt; attempting to read from it, which means for N input items the loop will run N+1 times, leads to the following symptoms:&lt;/p&gt;\n\n&lt;ul&gt;\n&lt;li&gt;&lt;p&gt;If the stream is empty, the loop will run once. &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; will fail (there is no input to be read) and all variables that were supposed to be set (by &lt;code&gt;stream &amp;gt;&amp;gt; x&lt;/code&gt;) are actually uninitialized. This leads to garbage data being processed, which can manifest as nonsensical results (often huge numbers).&lt;/p&gt;\n\n&lt;p&gt;(If your standard library conforms to C++11, things are a bit different now: A failed &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; now sets numeric variables to &lt;code&gt;0&lt;/code&gt; instead of leaving them uninitialized (except for &lt;code&gt;char&lt;/code&gt;s).)&lt;/p&gt;&lt;/li&gt;\n&lt;li&gt;&lt;p&gt;If the stream is not empty, the loop will run again after the last valid input. Since in the last iteration all &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; operations fail, variables are likely to keep their value from the previous iteration. This can manifest as &quot;the last line is printed twice&quot; or &quot;the last input record is processed twice&quot;.&lt;/p&gt;\n\n&lt;p&gt;(This should manifest a bit differently since C++11 (see above): Now you get a &quot;phantom record&quot; of zeroes instead of a repeated last line.)&lt;/p&gt;&lt;/li&gt;\n&lt;li&gt;&lt;p&gt;If the stream contains malformed data but you only check for &lt;code&gt;.eof&lt;/code&gt;, you end up with an infinite loop. &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; will fail to extract any data from the stream, so the loop spins in place without ever reaching the end.&lt;/p&gt;&lt;/li&gt;\n&lt;/ul&gt;\n\n&lt;hr&gt;\n\n&lt;p&gt;To recap: The solution is to test the success of the &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; operation itself, not to use a separate &lt;code&gt;.eof()&lt;/code&gt; method: &lt;code&gt;while (stream &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m) { ... }&lt;/code&gt;, just as in C you test the success of the &lt;code&gt;scanf&lt;/code&gt; call itself: &lt;code&gt;while (scanf(&quot;%d%d&quot;, &amp;amp;n, &amp;amp;m) == 2) { ... }&lt;/code&gt;.&lt;/p&gt;\n    ","\n&lt;p&gt;The important thing to remember is that, &lt;code&gt;inFile.eof()&lt;/code&gt; doesnt become &lt;code&gt;True&lt;/code&gt; until &lt;em&gt;&lt;strong&gt;after&lt;/strong&gt;&lt;/em&gt; an attempted read fails, because youve reached the end of the file. So, in this example, youll get an error.&lt;/p&gt;\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;while&lt;/span&gt; (!inFile.&lt;span class=&quot;hljs-built_in&quot;&gt;eof&lt;/span&gt;()){\n    inFile &amp;gt;&amp;gt; x;\n        &lt;span class=&quot;hljs-built_in&quot;&gt;process&lt;/span&gt;(x);\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;The way to make this loop correct, is to combine reading and checking into a single operation, like so&lt;/p&gt;\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;while&lt;/span&gt; (inFile &amp;gt;&amp;gt; x)&amp;nbsp;\n    &lt;span class=&quot;hljs-built_in&quot;&gt;process&lt;/span&gt;(x);&amp;nbsp;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;By convention, &lt;code&gt;operator&amp;gt;&amp;gt;&lt;/code&gt; returns the stream we read from, and a Boolean test on a stream returns &lt;code&gt;False&lt;/code&gt; when the stream fails (such as reaching end of file).&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;So this gives us the correct sequence :&lt;/strong&gt;&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;read&lt;/li&gt;\n&lt;li&gt;test whether the read succeeds&lt;/li&gt;\n&lt;li&gt;if and only if the test succeeds, process what weve read&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;If you happen to encounter some &lt;em&gt;other&lt;/em&gt; problem that prevents you from reading from the file correctly, you will not be able to reach &lt;code&gt;eof()&lt;/code&gt; as such. For example, lets look at something like this&lt;/p&gt;\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; x;&amp;nbsp;\n&lt;span class=&quot;hljs-keyword&quot;&gt;while&lt;/span&gt; (!inFile.&lt;span class=&quot;hljs-built_in&quot;&gt;eof&lt;/span&gt;()) {&amp;nbsp;\n    inFile &amp;gt;&amp;gt; x;&amp;nbsp;\n    &lt;span class=&quot;hljs-built_in&quot;&gt;process&lt;/span&gt;(x);\n}&amp;nbsp;\n    \n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;Let us trace through the working of the above code, with an example&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;Assume the contents of the file are &lt;code&gt;&apos;1&apos;, &apos;2&apos;, &apos;3&apos;, &apos;a&apos;, &apos;b&apos;&lt;/code&gt;.&lt;/li&gt;\n&lt;li&gt;The loop will read the 1, 2, and 3 correctly.&lt;/li&gt;\n&lt;li&gt;Then itll get to &lt;code&gt;a&lt;/code&gt;.&lt;/li&gt;\n&lt;li&gt;When it tries to extract &lt;code&gt;a&lt;/code&gt; as an int, itll fail.&lt;/li&gt;\n&lt;li&gt;The stream is now in a failed state, until or unless we &lt;code&gt;clear&lt;/code&gt; the stream, all attempts at reading from it will fail.&lt;/li&gt;\n&lt;li&gt;But, when we test for eof(), itll return &lt;code&gt;False&lt;/code&gt;, because were not at the end of the file, because theres still &lt;code&gt;a&lt;/code&gt; waiting to be read.&lt;/li&gt;\n&lt;li&gt;The loop will keep trying to read from the file, and fail every time, so it &lt;strong&gt;never&lt;/strong&gt; reaches the end of the file.&lt;/li&gt;\n&lt;li&gt;So, the loop above will run forever.&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;But, if we use a loop like this, we will get the required output.&lt;/p&gt;\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;while&lt;/span&gt; (inFile &amp;gt;&amp;gt; x)\n    &lt;span class=&quot;hljs-built_in&quot;&gt;process&lt;/span&gt;(x);\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;In this case, the stream will convert to &lt;code&gt;False&lt;/code&gt; not only in case of end of file, but also in case of a failed conversion, such as the &lt;code&gt;a&lt;/code&gt; that we cant read as an integer.&lt;/p&gt;\n    "]},"randomTags":[{"name":"async-await","slug":"async-await"},{"name":"maps","slug":"maps"},{"name":"commandlink","slug":"commandlink"},{"name":"operators","slug":"operators"},{"name":"eclipse","slug":"eclipse"},{"name":"bounded-wildcard","slug":"bounded-wildcard"},{"name":"iterator","slug":"iterator"},{"name":"event-bubbling","slug":"event-bubbling"},{"name":"semantics","slug":"semantics"},{"name":"vba","slug":"vba"},{"name":"json.net","slug":"json.net"},{"name":"awk","slug":"awk"},{"name":"branch-prediction","slug":"branch-prediction"},{"name":"git-commit","slug":"git-commit"},{"name":"local-variables","slug":"local-variables"},{"name":"multiline","slug":"multiline"},{"name":"identity-operator","slug":"identity-operator"},{"name":"mysql","slug":"mysql"},{"name":"observable","slug":"observable"},{"name":"command-line","slug":"command-line"}]},"__N_SSG":true}