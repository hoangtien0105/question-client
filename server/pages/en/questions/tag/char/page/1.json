{"pageProps":{"data":{"count":1,"rows":[{"id":386,"title":"What is the difference between char s[] and char *s?","slug":"what-is-the-difference-between-char-s-and-char-*s-1657387823570","postType":"QUESTION","createdAt":"2022-07-09T17:30:23.000Z","updatedAt":"2022-07-09T17:30:23.000Z","tags":[{"id":2098,"name":"char","slug":"char","createdAt":"2022-07-09T17:30:23.000Z","updatedAt":"2022-07-09T17:30:23.000Z","Questions_Tags":{"questionId":386,"tagId":2098}}]}]},"slug":"char","page":"1","answers":{"386":["\n&lt;p&gt;The difference here is that &lt;/p&gt;\n\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;char&lt;/span&gt; *s = &lt;span class=&quot;hljs-string&quot;&gt;&quot;Hello world&quot;&lt;/span&gt;;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;will place &lt;code&gt;&quot;Hello world&quot;&lt;/code&gt; in the &lt;em&gt;read-only parts of the memory&lt;/em&gt;, and making &lt;code&gt;s&lt;/code&gt; a pointer to that makes any writing operation on this memory illegal. &lt;/p&gt;\n\n&lt;p&gt;While doing:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;char&lt;/span&gt; s[] = &lt;span class=&quot;hljs-string&quot;&gt;&quot;Hello world&quot;&lt;/span&gt;;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;puts the literal string in read-only memory and copies the string to newly allocated memory on the stack. Thus making&lt;/p&gt;\n\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;s[&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;] = &lt;span class=&quot;hljs-string&quot;&gt;&apos;J&apos;&lt;/span&gt;;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;legal.&lt;/p&gt;\n    ","\n&lt;p&gt;First off, in function arguments, they are exactly equivalent:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-type&quot;&gt;char&lt;/span&gt; *x)&lt;/span&gt;;\n&lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-type&quot;&gt;char&lt;/span&gt; x[])&lt;/span&gt;; &lt;span class=&quot;hljs-comment&quot;&gt;// exactly the same in all respects&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;In other contexts, &lt;code&gt;char *&lt;/code&gt; allocates a pointer, while &lt;code&gt;char []&lt;/code&gt; allocates an array. Where does the string go in the former case, you ask? The compiler secretly allocates a static anonymous array to hold the string literal. So:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;char&lt;/span&gt; *x = &lt;span class=&quot;hljs-string&quot;&gt;&quot;Foo&quot;&lt;/span&gt;;\n&lt;span class=&quot;hljs-comment&quot;&gt;// is approximately equivalent to:&lt;/span&gt;\n&lt;span class=&quot;hljs-type&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;char&lt;/span&gt; __secret_anonymous_array[] = &lt;span class=&quot;hljs-string&quot;&gt;&quot;Foo&quot;&lt;/span&gt;;\n&lt;span class=&quot;hljs-type&quot;&gt;char&lt;/span&gt; *x = (&lt;span class=&quot;hljs-type&quot;&gt;char&lt;/span&gt; *) __secret_anonymous_array;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Note that you must not ever attempt to modify the contents of this anonymous array via this pointer; the effects are undefined (often meaning a crash):&lt;/p&gt;\n\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;x[&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;] = &lt;span class=&quot;hljs-string&quot;&gt;&apos;O&apos;&lt;/span&gt;; &lt;span class=&quot;hljs-comment&quot;&gt;// BAD. DON&apos;T DO THIS.&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Using the array syntax directly allocates it into new memory. Thus modification is safe:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;char&lt;/span&gt; x[] = &lt;span class=&quot;hljs-string&quot;&gt;&quot;Foo&quot;&lt;/span&gt;;\nx[&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;] = &lt;span class=&quot;hljs-string&quot;&gt;&apos;O&apos;&lt;/span&gt;; &lt;span class=&quot;hljs-comment&quot;&gt;// No problem.&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;However the array only lives as long as its contaning scope, so if you do this in a function, don&apos;t return or leak a pointer to this array - make a copy instead with &lt;code&gt;strdup()&lt;/code&gt; or similar. If the array is allocated in global scope, of course, no problem.&lt;/p&gt;\n    ","\n&lt;p&gt;This declaration:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;char&lt;/span&gt; s[] = &lt;span class=&quot;hljs-string&quot;&gt;&quot;hello&quot;&lt;/span&gt;;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Creates &lt;em&gt;one&lt;/em&gt; object - a &lt;code&gt;char&lt;/code&gt; array of size 6, called &lt;code&gt;s&lt;/code&gt;, initialised with the values &lt;code&gt;&apos;h&apos;, &apos;e&apos;, &apos;l&apos;, &apos;l&apos;, &apos;o&apos;, &apos;\\0&apos;&lt;/code&gt;.  Where this array is allocated in memory, and how long it lives for, depends on where the declaration appears.  If the declaration is within a function, it will live until the end of the block that it is declared in, and almost certainly be allocated on the stack; if it&apos;s outside a function, it will &lt;em&gt;probably&lt;/em&gt; be stored within an &quot;initialised data segment&quot; that is loaded from the executable file into writeable memory when the program is run.&lt;/p&gt;\n\n&lt;p&gt;On the other hand, this declaration:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;char&lt;/span&gt; *s =&lt;span class=&quot;hljs-string&quot;&gt;&quot;hello&quot;&lt;/span&gt;;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Creates &lt;em&gt;two&lt;/em&gt; objects:&lt;/p&gt;\n\n&lt;ul&gt;\n&lt;li&gt;a &lt;strong&gt;read-only&lt;/strong&gt; array of 6 &lt;code&gt;char&lt;/code&gt;s containing the values &lt;code&gt;&apos;h&apos;, &apos;e&apos;, &apos;l&apos;, &apos;l&apos;, &apos;o&apos;, &apos;\\0&apos;&lt;/code&gt;, which has no name and has &lt;em&gt;static storage duration&lt;/em&gt; (meaning that it lives for the entire life of the program); and&lt;/li&gt;\n&lt;li&gt;a variable of type pointer-to-char, called &lt;code&gt;s&lt;/code&gt;, which is initialised with the location of the first character in that unnamed, read-only array.&lt;/li&gt;\n&lt;/ul&gt;\n\n&lt;p&gt;The unnamed read-only array is typically located in the &quot;text&quot; segment of the program, which means it is loaded from disk into read-only memory, along with the code itself.  The location of the &lt;code&gt;s&lt;/code&gt; pointer variable in memory depends on where the declaration appears (just like in the first example).&lt;/p&gt;\n    ","\n&lt;p&gt;Given the declarations&lt;/p&gt;\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;char&lt;/span&gt; *s0 = &lt;span class=&quot;hljs-string&quot;&gt;&quot;hello world&quot;&lt;/span&gt;;\n&lt;span class=&quot;hljs-type&quot;&gt;char&lt;/span&gt; s1[] = &lt;span class=&quot;hljs-string&quot;&gt;&quot;hello world&quot;&lt;/span&gt;;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;assume the following hypothetical memory map (the columns represent characters at offsets 0 to 3 from the given row address, so e.g. the &lt;code&gt;0x00&lt;/code&gt; in the bottom right corner is at address &lt;code&gt;0x0001000C + 3&lt;/code&gt; = &lt;code&gt;0x0001000F&lt;/code&gt;):&lt;/p&gt;\n&lt;pre&gt;                     +0    +1    +2    +3\n        0x00008000: &apos;h&apos;   &apos;e&apos;   &apos;l&apos;   &apos;l&apos;\n        0x00008004: &apos;o&apos;   &apos; &apos;   &apos;w&apos;   &apos;o&apos;\n        0x00008008: &apos;r&apos;   &apos;l&apos;   &apos;d&apos;   0x00\n        ...\ns0:     0x00010000: 0x00  0x00  0x80  0x00\ns1:     0x00010004: &apos;h&apos;   &apos;e&apos;   &apos;l&apos;   &apos;l&apos;\n        0x00010008: &apos;o&apos;   &apos; &apos;   &apos;w&apos;   &apos;o&apos;\n        0x0001000C: &apos;r&apos;   &apos;l&apos;   &apos;d&apos;   0x00\n&lt;/pre&gt;\n&lt;p&gt;The string literal &lt;code&gt;&quot;hello world&quot;&lt;/code&gt; is a 12-element array of &lt;code&gt;char&lt;/code&gt; (&lt;code&gt;const char&lt;/code&gt; in C++) with static storage duration, meaning that the memory for it is allocated when the program starts up and remains allocated until the program terminates.  Attempting to modify the contents of a string literal invokes undefined behavior.&lt;/p&gt;\n&lt;p&gt;The line&lt;/p&gt;\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;char&lt;/span&gt; *s0 = &lt;span class=&quot;hljs-string&quot;&gt;&quot;hello world&quot;&lt;/span&gt;;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;defines &lt;code&gt;s0&lt;/code&gt; as a pointer to &lt;code&gt;char&lt;/code&gt; with auto storage duration (meaning the variable &lt;code&gt;s0&lt;/code&gt; only exists for the scope in which it is declared) and copies the &lt;em&gt;address&lt;/em&gt; of the string literal (&lt;code&gt;0x00008000&lt;/code&gt; in this example) to it. Note that since &lt;code&gt;s0&lt;/code&gt; points to a string literal, it should not be used as an argument to any function that would try to modify it (e.g., &lt;code&gt;strtok()&lt;/code&gt;, &lt;code&gt;strcat()&lt;/code&gt;, &lt;code&gt;strcpy()&lt;/code&gt;, etc.).&lt;/p&gt;\n&lt;p&gt;The line&lt;/p&gt;\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;char&lt;/span&gt; s1[] = &lt;span class=&quot;hljs-string&quot;&gt;&quot;hello world&quot;&lt;/span&gt;;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;defines &lt;code&gt;s1&lt;/code&gt; as a 12-element array of &lt;code&gt;char&lt;/code&gt; (length is taken from the string literal) with auto storage duration and copies the &lt;em&gt;contents&lt;/em&gt; of the literal to the array.  As you can see from the memory map, we have two copies of the string &lt;code&gt;&quot;hello world&quot;&lt;/code&gt;; the difference is that you can modify the string contained in &lt;code&gt;s1&lt;/code&gt;.&lt;/p&gt;\n&lt;p&gt;&lt;code&gt;s0&lt;/code&gt; and &lt;code&gt;s1&lt;/code&gt; are interchangeable in most contexts; here are the exceptions:&lt;/p&gt;\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;sizeof&lt;/span&gt; s0 == &lt;span class=&quot;hljs-keyword&quot;&gt;sizeof&lt;/span&gt; (&lt;span class=&quot;hljs-type&quot;&gt;char&lt;/span&gt;*)\n&lt;span class=&quot;hljs-keyword&quot;&gt;sizeof&lt;/span&gt; s1 == &lt;span class=&quot;hljs-number&quot;&gt;12&lt;/span&gt;\n\ntype of &amp;amp;s0 == &lt;span class=&quot;hljs-type&quot;&gt;char&lt;/span&gt; **\ntype of &amp;amp;s1 == &lt;span class=&quot;hljs-type&quot;&gt;char&lt;/span&gt; (*)[&lt;span class=&quot;hljs-number&quot;&gt;12&lt;/span&gt;] &lt;span class=&quot;hljs-comment&quot;&gt;// pointer to a 12-element array of char&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;You can reassign the variable &lt;code&gt;s0&lt;/code&gt; to point to a different string literal or to another variable.  You cannot reassign the variable &lt;code&gt;s1&lt;/code&gt; to point to a different array.&lt;/p&gt;\n    ","\n&lt;p&gt;&lt;strong&gt;C99 N1256 draft&lt;/strong&gt;&lt;/p&gt;\n\n&lt;p&gt;There are two different uses of character string literals:&lt;/p&gt;\n\n&lt;ol&gt;\n&lt;li&gt;&lt;p&gt;Initialize &lt;code&gt;char[]&lt;/code&gt;:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;char&lt;/span&gt; c[] = &lt;span class=&quot;hljs-string&quot;&gt;&quot;abc&quot;&lt;/span&gt;;      \n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;This is &quot;more magic&quot;, and described at 6.7.8/14 &quot;Initialization&quot;:&lt;/p&gt;\n\n&lt;blockquote&gt;\n  &lt;p&gt;An array of character type may be initialized by a character string literal, optionally\n  enclosed in braces. Successive characters of the character string literal (including the\n  terminating null character if there is room or if the array is of unknown size) initialize the\n  elements of the array.&lt;/p&gt;\n&lt;/blockquote&gt;\n\n&lt;p&gt;So this is just a shortcut for:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;char&lt;/span&gt; c[] = {&lt;span class=&quot;hljs-string&quot;&gt;&apos;a&apos;&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&apos;b&apos;&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&apos;c&apos;&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&apos;\\0&apos;&lt;/span&gt;};\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Like any other regular array, &lt;code&gt;c&lt;/code&gt; can be modified.&lt;/p&gt;&lt;/li&gt;\n&lt;li&gt;&lt;p&gt;Everywhere else: it generates an:&lt;/p&gt;\n\n&lt;ul&gt;\n&lt;li&gt;unnamed&lt;/li&gt;\n&lt;li&gt;array of char &lt;a href=&quot;https://stackoverflow.com/questions/2245664/what-is-the-type-of-string-literals-in-c-c&quot;&gt;What is the type of string literals in C and C++?&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;with static storage&lt;/li&gt;\n&lt;li&gt;that gives UB if modified&lt;/li&gt;\n&lt;/ul&gt;\n\n&lt;p&gt;So when you write:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;char&lt;/span&gt; *c = &lt;span class=&quot;hljs-string&quot;&gt;&quot;abc&quot;&lt;/span&gt;;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;This is similar to:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;&lt;span class=&quot;hljs-comment&quot;&gt;/* __unnamed is magic because modifying it gives UB. */&lt;/span&gt;\n&lt;span class=&quot;hljs-type&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;char&lt;/span&gt; __unnamed[] = &lt;span class=&quot;hljs-string&quot;&gt;&quot;abc&quot;&lt;/span&gt;;\n&lt;span class=&quot;hljs-type&quot;&gt;char&lt;/span&gt; *c = __unnamed;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Note the implicit cast from &lt;code&gt;char[]&lt;/code&gt; to &lt;code&gt;char *&lt;/code&gt;, which is always legal.&lt;/p&gt;\n\n&lt;p&gt;Then if you modify &lt;code&gt;c[0]&lt;/code&gt;, you also modify &lt;code&gt;__unnamed&lt;/code&gt;, which is UB.&lt;/p&gt;\n\n&lt;p&gt;This is documented at 6.4.5 &quot;String literals&quot;:&lt;/p&gt;\n\n&lt;blockquote&gt;\n  &lt;p&gt;5 In translation phase 7, a byte or code of value zero is appended to each multibyte\n  character sequence that results from a string literal or literals. The multibyte character\n  sequence is then used to initialize an array of static storage duration and length just\n  sufficient to contain the sequence. For character string literals, the array elements have\n  type char, and are initialized with the individual bytes of the multibyte character\n  sequence [...]&lt;/p&gt;\n  \n  &lt;p&gt;6 It is unspecified whether these arrays are distinct provided their elements have the\n  appropriate values. If the program attempts to modify such an array, the behavior is\n  undefined.&lt;/p&gt;\n&lt;/blockquote&gt;&lt;/li&gt;\n&lt;/ol&gt;\n\n&lt;p&gt;6.7.8/32 &quot;Initialization&quot; gives a direct example:&lt;/p&gt;\n\n&lt;blockquote&gt;\n  &lt;p&gt;EXAMPLE 8: The declaration&lt;/p&gt;\n\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;char&lt;/span&gt; s[] = &lt;span class=&quot;hljs-string&quot;&gt;&quot;abc&quot;&lt;/span&gt;, t[&lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;] = &lt;span class=&quot;hljs-string&quot;&gt;&quot;abc&quot;&lt;/span&gt;;\n&lt;/code&gt;&lt;/pre&gt;\n  \n  &lt;p&gt;defines &quot;plain&quot; char array objects &lt;code&gt;s&lt;/code&gt; and &lt;code&gt;t&lt;/code&gt; whose elements are initialized with character string literals.&lt;/p&gt;\n  \n  &lt;p&gt;This declaration is identical to&lt;/p&gt;\n\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;char&lt;/span&gt; s[] = { &lt;span class=&quot;hljs-string&quot;&gt;&apos;a&apos;&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&apos;b&apos;&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&apos;c&apos;&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&apos;\\0&apos;&lt;/span&gt; },\nt[] = { &lt;span class=&quot;hljs-string&quot;&gt;&apos;a&apos;&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&apos;b&apos;&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&apos;c&apos;&lt;/span&gt; };\n&lt;/code&gt;&lt;/pre&gt;\n  \n  &lt;p&gt;The contents of the arrays are modifiable. On the other hand, the declaration&lt;/p&gt;\n\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;char&lt;/span&gt; *p = &lt;span class=&quot;hljs-string&quot;&gt;&quot;abc&quot;&lt;/span&gt;;\n&lt;/code&gt;&lt;/pre&gt;\n  \n  &lt;p&gt;defines &lt;code&gt;p&lt;/code&gt; with type &quot;pointer to char&quot; and initializes it to point to an object with type &quot;array of char&quot; with length 4 whose elements are initialized with a character string literal. If an attempt is made to use &lt;code&gt;p&lt;/code&gt; to modify the contents of the array, the behavior is undefined.&lt;/p&gt;\n&lt;/blockquote&gt;\n\n&lt;p&gt;&lt;strong&gt;GCC 4.8 x86-64 ELF implementation&lt;/strong&gt;&lt;/p&gt;\n\n&lt;p&gt;Program:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;/span&gt;\n\n&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt;)&lt;/span&gt; {\n    &lt;span class=&quot;hljs-type&quot;&gt;char&lt;/span&gt; *s = &lt;span class=&quot;hljs-string&quot;&gt;&quot;abc&quot;&lt;/span&gt;;\n    &lt;span class=&quot;hljs-built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;%s\\n&quot;&lt;/span&gt;, s);\n    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;;\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Compile and decompile:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;gcc -ggdb -&lt;span class=&quot;hljs-built_in&quot;&gt;std&lt;/span&gt;=c99 -c main.c\nobjdump -Sr main.o\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Output contains:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt; &lt;span class=&quot;hljs-type&quot;&gt;char&lt;/span&gt; *s = &lt;span class=&quot;hljs-string&quot;&gt;&quot;abc&quot;&lt;/span&gt;;\n&lt;span class=&quot;hljs-number&quot;&gt;8&lt;/span&gt;:  &lt;span class=&quot;hljs-number&quot;&gt;48&lt;/span&gt; c7 &lt;span class=&quot;hljs-number&quot;&gt;45&lt;/span&gt; f8 &lt;span class=&quot;hljs-number&quot;&gt;00&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;00&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;00&lt;/span&gt;    movq   $&lt;span class=&quot;hljs-number&quot;&gt;0x0&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;-0x8&lt;/span&gt;(%rbp)\nf:  &lt;span class=&quot;hljs-number&quot;&gt;00&lt;/span&gt; \n        c: R_X86_64_32S .rodata\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Conclusion: GCC stores &lt;code&gt;char*&lt;/code&gt; it in &lt;code&gt;.rodata&lt;/code&gt; section, not in &lt;code&gt;.text&lt;/code&gt;.&lt;/p&gt;\n\n&lt;p&gt;Note however that the default linker script puts &lt;code&gt;.rodata&lt;/code&gt; and &lt;code&gt;.text&lt;/code&gt; in the same &lt;a href=&quot;https://stackoverflow.com/questions/14361248/whats-the-difference-of-section-and-segment-in-elf-file-format/38117710#38117710&quot;&gt;segment&lt;/a&gt;, which has execute but no write permission. This can be observed with:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;readelf -l a.out\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;which contains:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt; Section to Segment mapping:\n  Segment Sections...\n   &lt;span class=&quot;hljs-number&quot;&gt;02&lt;/span&gt;     .text .rodata\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;If we do the same for &lt;code&gt;char[]&lt;/code&gt;:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt; &lt;span class=&quot;hljs-type&quot;&gt;char&lt;/span&gt; s[] = &lt;span class=&quot;hljs-string&quot;&gt;&quot;abc&quot;&lt;/span&gt;;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;we obtain:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;&lt;span class=&quot;hljs-number&quot;&gt;17&lt;/span&gt;:   c7 &lt;span class=&quot;hljs-number&quot;&gt;45&lt;/span&gt; f0 &lt;span class=&quot;hljs-number&quot;&gt;61&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;62&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;63&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;00&lt;/span&gt;    movl   $&lt;span class=&quot;hljs-number&quot;&gt;0x636261&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;-0x10&lt;/span&gt;(%rbp)\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;so it gets stored in the stack (relative to &lt;code&gt;%rbp&lt;/code&gt;).&lt;/p&gt;\n    ","\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;char&lt;/span&gt; s[] = &lt;span class=&quot;hljs-string&quot;&gt;&quot;hello&quot;&lt;/span&gt;;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;declares &lt;code&gt;s&lt;/code&gt; to be an array of &lt;code&gt;char&lt;/code&gt; which is long enough to hold the initializer (5 + 1 &lt;code&gt;char&lt;/code&gt;s) and initializes the array by copying the members of the given string literal into the array.&lt;/p&gt;\n\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;char&lt;/span&gt; *s = &lt;span class=&quot;hljs-string&quot;&gt;&quot;hello&quot;&lt;/span&gt;;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;declares &lt;code&gt;s&lt;/code&gt; to be a pointer to one or more (in this case more) &lt;code&gt;char&lt;/code&gt;s and points it directly at a fixed (read-only) location containing the literal &lt;code&gt;&quot;hello&quot;&lt;/code&gt;.&lt;/p&gt;\n    ","\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;char&lt;/span&gt; s[] = &lt;span class=&quot;hljs-string&quot;&gt;&quot;Hello world&quot;&lt;/span&gt;;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Here, &lt;code&gt;s&lt;/code&gt; is an array of characters, which can be overwritten if we wish.&lt;/p&gt;\n\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;char&lt;/span&gt; *s = &lt;span class=&quot;hljs-string&quot;&gt;&quot;hello&quot;&lt;/span&gt;;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;A string literal is used to create these character blocks somewhere in the memory which this pointer &lt;code&gt;s&lt;/code&gt; is pointing to. We can here reassign the object it is pointing to by changing that, but as long as it points to a string literal the block of characters to which it points can&apos;t be changed.&lt;/p&gt;\n    ","\n&lt;p&gt;As an addition, consider that, as for read-only purposes the use of both is identical, you can access a char by indexing either with &lt;code&gt;[]&lt;/code&gt; or &lt;code&gt;*(&amp;lt;var&amp;gt; + &amp;lt;index&amp;gt;)&lt;/code&gt;\nformat:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;%c&quot;&lt;/span&gt;, x[&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;]);     &lt;span class=&quot;hljs-comment&quot;&gt;//Prints r&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;And:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;%c&quot;&lt;/span&gt;, *(x + &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;)); &lt;span class=&quot;hljs-comment&quot;&gt;//Prints r&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Obviously, if you attempt to do&lt;/p&gt;\n\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;*(x + &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;) = &lt;span class=&quot;hljs-string&quot;&gt;&apos;a&apos;&lt;/span&gt;;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;You will probably get a Segmentation Fault, as you are trying to access read-only memory.&lt;/p&gt;\n    ","\n&lt;p&gt;Just to add: you also get different values for their sizes.&lt;/p&gt;\n\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;sizeof s[] = %zu\\n&quot;&lt;/span&gt;, &lt;span class=&quot;hljs-keyword&quot;&gt;sizeof&lt;/span&gt;(s));  &lt;span class=&quot;hljs-comment&quot;&gt;//6&lt;/span&gt;\n&lt;span class=&quot;hljs-built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;sizeof *s  = %zu\\n&quot;&lt;/span&gt;, &lt;span class=&quot;hljs-keyword&quot;&gt;sizeof&lt;/span&gt;(s));  &lt;span class=&quot;hljs-comment&quot;&gt;//4 or 8&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;As mentioned above, for an array &lt;code&gt;&apos;\\0&apos;&lt;/code&gt; will be allocated as the final element.&lt;/p&gt;\n    ","\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;char&lt;/span&gt; *str = &lt;span class=&quot;hljs-string&quot;&gt;&quot;Hello&quot;&lt;/span&gt;;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;The above sets str to point to the literal value &quot;Hello&quot; which is hard-coded in the program&apos;s binary image, which is flagged as read-only in memory, means any change in this String literal is illegal and that would throw segmentation faults.&lt;/p&gt;\n\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;char&lt;/span&gt; str[] = &lt;span class=&quot;hljs-string&quot;&gt;&quot;Hello&quot;&lt;/span&gt;;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;copies the string to newly allocated memory on the stack. Thus making any change in it is allowed and legal.&lt;/p&gt;\n\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;means str[&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;] = &lt;span class=&quot;hljs-string&quot;&gt;&apos;M&apos;&lt;/span&gt;;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;will change the str to &quot;Mello&quot;.&lt;/p&gt;\n\n&lt;p&gt;For more details, please go through the similar question:&lt;/p&gt;\n\n&lt;p&gt;&lt;a href=&quot;https://stackoverflow.com/questions/164194/why-do-i-get-a-segmentation-fault-when-writing-to-a-string-initialized-with-cha&quot;&gt;Why do I get a segmentation fault when writing to a string initialized with &quot;char *s&quot; but not &quot;char s[]&quot;?&lt;/a&gt;&lt;/p&gt;\n    ","\n&lt;p&gt;An example to the difference:&lt;/p&gt;\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;hello&quot;&lt;/span&gt; + &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;); &lt;span class=&quot;hljs-comment&quot;&gt;//llo&lt;/span&gt;\n&lt;span class=&quot;hljs-type&quot;&gt;char&lt;/span&gt; a[] = &lt;span class=&quot;hljs-string&quot;&gt;&quot;hello&quot;&lt;/span&gt; + &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;; &lt;span class=&quot;hljs-comment&quot;&gt;//error&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;In the first case pointer arithmetics are working (arrays passed to a function decay to pointers).&lt;/p&gt;\n    ","\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;char&lt;/span&gt; *s1 = &lt;span class=&quot;hljs-string&quot;&gt;&quot;Hello world&quot;&lt;/span&gt;; &lt;span class=&quot;hljs-comment&quot;&gt;// Points to fixed character string which is not allowed to modify&lt;/span&gt;\n&lt;span class=&quot;hljs-type&quot;&gt;char&lt;/span&gt; s2[] = &lt;span class=&quot;hljs-string&quot;&gt;&quot;Hello world&quot;&lt;/span&gt;; &lt;span class=&quot;hljs-comment&quot;&gt;// As good as fixed array of characters in string so allowed to modify&lt;/span&gt;\n\n&lt;span class=&quot;hljs-comment&quot;&gt;// s1[0] = &apos;J&apos;; // Illegal&lt;/span&gt;\ns2[&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;] = &lt;span class=&quot;hljs-string&quot;&gt;&apos;J&apos;&lt;/span&gt;; &lt;span class=&quot;hljs-comment&quot;&gt;// Legal&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n    ","\n&lt;p&gt;In the case of:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;char&lt;/span&gt; *x = &lt;span class=&quot;hljs-string&quot;&gt;&quot;fred&quot;&lt;/span&gt;;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;x is an &lt;a href=&quot;http://en.wikipedia.org/wiki/Lvalue&quot; rel=&quot;nofollow noreferrer&quot;&gt;lvalue&lt;/a&gt; -- it can be assigned to. But in the case of:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;char&lt;/span&gt; x[] = &lt;span class=&quot;hljs-string&quot;&gt;&quot;fred&quot;&lt;/span&gt;;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;x is not an lvalue, it is an rvalue -- you cannot assign to it.&lt;/p&gt;\n    ","\n&lt;p&gt;In the light of comments here it should be obvious that : char * s = &quot;hello&quot; ;\nIs a bad idea, and should be used in very narrow scope. &lt;/p&gt;\n\n&lt;p&gt;This might be a good opportunity to point out that &quot;const correctness&quot; is a &quot;good thing&quot;. Whenever and wherever You can, use the &quot;const&quot; keyword to protect your code, from &quot;relaxed&quot; callers or programmers, which are usually most &quot;relaxed&quot; when pointers come into play.&lt;/p&gt;\n\n&lt;p&gt;Enough melodrama, here is what one can achieve when adorning pointers with &quot;const&quot;.\n(Note: One has to read pointer declarations right-to-left.)\nHere are the 3 different ways to protect yourself when playing with pointers :&lt;/p&gt;\n\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;const&lt;/span&gt; DBJ* p means &lt;span class=&quot;hljs-string&quot;&gt;&quot;p points to a DBJ that is const&quot;&lt;/span&gt; \n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt; that is, the DBJ object can&apos;t be changed via p.&lt;/p&gt;\n\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;DBJ* &lt;span class=&quot;hljs-type&quot;&gt;const&lt;/span&gt; p means &lt;span class=&quot;hljs-string&quot;&gt;&quot;p is a const pointer to a DBJ&quot;&lt;/span&gt; \n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt; that is, you can change the DBJ object via p, but you can&apos;t change the pointer p itself.&lt;/p&gt;\n\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;const&lt;/span&gt; DBJ* &lt;span class=&quot;hljs-type&quot;&gt;const&lt;/span&gt; p means &lt;span class=&quot;hljs-string&quot;&gt;&quot;p is a const pointer to a const DBJ&quot;&lt;/span&gt; \n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt; that is, you can&apos;t change the pointer p itself, nor can you change the DBJ object via p.&lt;/p&gt;\n\n&lt;p&gt;The errors related to attempted const-ant mutations are caught at compile time. There is no runtime space or speed penalty for const.&lt;/p&gt;\n\n&lt;p&gt;(Assumption is you are using C++ compiler, of course ?)&lt;/p&gt;\n\n&lt;p&gt;--DBJ&lt;/p&gt;\n    "]},"randomTags":[{"name":"object-literal","slug":"object-literal"},{"name":"return-value","slug":"return-value"},{"name":"user-interface","slug":"user-interface"},{"name":"jstl","slug":"jstl"},{"name":"equals","slug":"equals"},{"name":"youtube-api","slug":"youtube-api"},{"name":"commandlink","slug":"commandlink"},{"name":"utc","slug":"utc"},{"name":"scanf","slug":"scanf"},{"name":"content-script","slug":"content-script"},{"name":"google-chrome-extension","slug":"google-chrome-extension"},{"name":"platform-detection","slug":"platform-detection"},{"name":"collections","slug":"collections"},{"name":"hover","slug":"hover"},{"name":"networkonmainthread","slug":"networkonmainthread"},{"name":"copy-and-swap","slug":"copy-and-swap"},{"name":"certificate","slug":"certificate"},{"name":"non-greedy","slug":"non-greedy"},{"name":"http","slug":"http"},{"name":"download","slug":"download"}]},"__N_SSG":true}