{"pageProps":{"data":{"count":1,"rows":[{"id":242,"title":"HTTP GET with request body","slug":"http-get-with-request-body-1657387379038","postType":"QUESTION","createdAt":"2022-07-09T17:22:59.000Z","updatedAt":"2022-07-09T17:22:59.000Z","tags":[{"id":1594,"name":"rest","slug":"rest","createdAt":"2022-07-09T17:22:59.000Z","updatedAt":"2022-07-09T17:22:59.000Z","Questions_Tags":{"questionId":242,"tagId":1594}}]}]},"slug":"rest","page":"1","answers":{"242":["\n&lt;p&gt;&lt;a href=&quot;https://groups.yahoo.com/neo/groups/rest-discuss/conversations/messages/9962&quot; rel=&quot;noreferrer&quot;&gt;Roy Fielding&apos;s comment about including a body with a GET request&lt;/a&gt;.&lt;/p&gt;\n&lt;blockquote&gt;\n&lt;p&gt;Yes. In other words, any HTTP request message is allowed to contain a message body, and thus must parse messages with that in mind. Server semantics for GET, however, are restricted such that a body, if any, has no semantic meaning to the request. The requirements on parsing are separate from the requirements on method semantics.&lt;/p&gt;\n&lt;p&gt;So, yes, you can send a body with GET, and no, it is never useful to do so.&lt;/p&gt;\n&lt;p&gt;This is part of the layered design of HTTP/1.1 that will become clear again once the spec is partitioned (work in progress).&lt;/p&gt;\n&lt;p&gt;....Roy&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;p&gt;Yes, you can send a request body with GET but it should not have any meaning. If you give it meaning by parsing it on the server and &lt;em&gt;changing your response based on its contents&lt;/em&gt;, then you are ignoring this recommendation in &lt;a href=&quot;https://www.rfc-editor.org/rfc/rfc2616#section-4.3&quot; rel=&quot;noreferrer&quot;&gt;the HTTP/1.1 spec, section 4.3&lt;/a&gt;:&lt;/p&gt;\n&lt;blockquote&gt;\n&lt;p&gt;...if the request method does not include defined semantics for an entity-body, then the message-body &lt;a href=&quot;https://www.ietf.org/rfc/rfc2119.txt&quot; rel=&quot;noreferrer&quot;&gt;SHOULD&lt;/a&gt; be ignored when handling the request.&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;p&gt;And the description of the GET method in &lt;a href=&quot;https://www.rfc-editor.org/rfc/rfc2616#section-9.3&quot; rel=&quot;noreferrer&quot;&gt;the HTTP/1.1 spec, section 9.3&lt;/a&gt;:&lt;/p&gt;\n&lt;blockquote&gt;\n&lt;p&gt;The GET method means retrieve whatever information ([...]) is identified by the Request-URI.&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;p&gt;which states that the request-body is not part of the identification of the resource in a GET request, only the request URI.&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;Update&lt;/strong&gt;&lt;/p&gt;\n&lt;p&gt;The RFC2616 referenced as &quot;HTTP/1.1 spec&quot; is now obsolete. In 2014 it was replaced by RFCs 7230-7237. Quote &quot;the message-body SHOULD be ignored when handling the request&quot; has been deleted. It&apos;s now just &quot;Request message framing is independent of method semantics, even if the method doesn&apos;t define any use for a message body&quot; The 2nd quote &quot;The GET method means retrieve whatever information ... is identified by the Request-URI&quot; was deleted.  - From a comment&lt;/p&gt;\n&lt;p&gt;From the &lt;a href=&quot;https://www.rfc-editor.org/rfc/rfc7231#page-24&quot; rel=&quot;noreferrer&quot;&gt;HTTP 1.1 2014 Spec&lt;/a&gt;:&lt;/p&gt;\n&lt;blockquote&gt;\n&lt;p&gt;A payload within a GET request message has no defined semantics; sending a payload body on a GET request might cause some existing implementations to reject the request.&lt;/p&gt;\n&lt;/blockquote&gt;\n    ","\n&lt;p&gt;While you &lt;em&gt;can&lt;/em&gt; do that, insofar as it isn&apos;t explicitly precluded by the HTTP specification, I would suggest avoiding it simply because people don&apos;t expect things to work that way.  There are many phases in an HTTP request chain and while they &quot;mostly&quot; conform to the HTTP spec, the only thing you&apos;re assured is that they will behave as traditionally used by web browsers.  (I&apos;m thinking of things like transparent proxies, accelerators, A/V toolkits, etc.)&lt;/p&gt;\n\n&lt;p&gt;This is the spirit behind the &lt;a href=&quot;http://en.wikipedia.org/wiki/Robustness_Principle&quot; rel=&quot;noreferrer&quot;&gt;Robustness Principle&lt;/a&gt; roughly &quot;be liberal in what you accept, and conservative in what you send&quot;, you don&apos;t want to push the boundaries of a specification without good reason.  &lt;/p&gt;\n\n&lt;p&gt;However, if you have a good reason, go for it.&lt;/p&gt;\n    ","\n&lt;p&gt;You will likely encounter problems if you ever try to take advantage of caching. Proxies are not going to look in the &lt;code&gt;GET&lt;/code&gt; body to see if the parameters have an impact on the response.&lt;/p&gt;\n    ","\n&lt;p&gt;Neither &lt;a href=&quot;http://restclient.net&quot; rel=&quot;noreferrer&quot;&gt;restclient&lt;/a&gt; nor &lt;a href=&quot;https://chrome.google.com/webstore/detail/rest-console/cokgbflfommojglbmbpenpphppikmonn&quot; rel=&quot;noreferrer&quot;&gt;REST console&lt;/a&gt; support this but curl does.&lt;/p&gt;\n\n&lt;p&gt;The &lt;a href=&quot;http://www.w3.org/Protocols/rfc2616/rfc2616-sec4.html#sec4.3&quot; rel=&quot;noreferrer&quot;&gt;HTTP specification&lt;/a&gt; says in section 4.3&lt;/p&gt;\n\n&lt;blockquote&gt;\n  &lt;p&gt;A message-body MUST NOT be included in a request if the specification of the request method (section 5.1.1) does not allow sending an entity-body in requests.&lt;/p&gt;\n&lt;/blockquote&gt;\n\n&lt;p&gt;&lt;a href=&quot;http://www.w3.org/Protocols/rfc2616/rfc2616-sec5.html#sec5.1.1&quot; rel=&quot;noreferrer&quot;&gt;Section 5.1.1&lt;/a&gt; redirects us to section 9.x for the various methods. None of them explicitly prohibit the inclusion of a message body. However...&lt;/p&gt;\n\n&lt;p&gt;&lt;a href=&quot;http://www.w3.org/Protocols/rfc2616/rfc2616-sec5.html#sec5.2&quot; rel=&quot;noreferrer&quot;&gt;Section 5.2&lt;/a&gt; says &lt;/p&gt;\n\n&lt;blockquote&gt;\n  &lt;p&gt;The exact resource identified by an Internet request is determined by examining both the Request-URI and the Host header field.&lt;/p&gt;\n&lt;/blockquote&gt;\n\n&lt;p&gt;and &lt;a href=&quot;http://www.w3.org/Protocols/rfc2616/rfc2616-sec5.html#sec9.3&quot; rel=&quot;noreferrer&quot;&gt;Section 9.3&lt;/a&gt; says&lt;/p&gt;\n\n&lt;blockquote&gt;\n  &lt;p&gt;The GET method means retrieve whatever information (in the form of an entity) is identified by the Request-URI.&lt;/p&gt;\n&lt;/blockquote&gt;\n\n&lt;p&gt;Which together suggest that when processing a GET request, a server is not &lt;em&gt;required&lt;/em&gt; to examine anything other that the Request-URI and Host header field.&lt;/p&gt;\n\n&lt;p&gt;In summary, the HTTP spec doesn&apos;t prevent you from sending a message-body with GET but there is sufficient ambiguity that it wouldn&apos;t surprise me if it was not supported by all servers. &lt;/p&gt;\n    ","\n&lt;p&gt;Elasticsearch accepts GET requests with a body. It even seems that this is the preferred way: &lt;a href=&quot;https://www.elastic.co/guide/en/elasticsearch/guide/current/_empty_search.html#get_vs_post&quot; rel=&quot;noreferrer&quot;&gt;Elasticsearch guide&lt;/a&gt;&lt;/p&gt;\n\n&lt;p&gt;Some client libraries (like the Ruby driver) can log the cry command to stdout in development mode and it is using this syntax extensively.&lt;/p&gt;\n    ","\n&lt;p&gt;You can either send a GET with a body or send a POST and give up RESTish religiosity (it&apos;s not so bad, 5 years ago there was only one member of that faith -- his comments linked above).&lt;/p&gt;\n\n&lt;p&gt;Neither are great decisions, but sending a GET body may prevent problems for some clients -- and some servers.  &lt;/p&gt;\n\n&lt;p&gt;Doing a POST might have obstacles with some RESTish frameworks. &lt;/p&gt;\n\n&lt;p&gt;Julian Reschke suggested above using a non-standard HTTP header like &quot;SEARCH&quot; which could be an elegant solution, except that it&apos;s even less likely to be supported.&lt;/p&gt;\n\n&lt;p&gt;It might be most productive to list clients that can and cannot do each of the above.&lt;/p&gt;\n\n&lt;p&gt;Clients that cannot send a GET with body (that I know of):&lt;/p&gt;\n\n&lt;ul&gt;\n&lt;li&gt;XmlHTTPRequest Fiddler&lt;/li&gt;\n&lt;/ul&gt;\n\n&lt;p&gt;Clients that can send a GET with body:&lt;/p&gt;\n\n&lt;ul&gt;\n&lt;li&gt;most browsers&lt;/li&gt;\n&lt;/ul&gt;\n\n&lt;p&gt;Servers &amp;amp; libraries that can retrieve a body from GET:&lt;/p&gt;\n\n&lt;ul&gt;\n&lt;li&gt;Apache&lt;/li&gt;\n&lt;li&gt;PHP&lt;/li&gt;\n&lt;/ul&gt;\n\n&lt;p&gt;Servers (and proxies) that strip a body from GET:&lt;/p&gt;\n\n&lt;ul&gt;\n&lt;li&gt;?&lt;/li&gt;\n&lt;/ul&gt;\n    ","\n&lt;p&gt;What you&apos;re trying to achieve has been done for a long time with a much more common method, and one that doesn&apos;t rely on using a payload with GET.&lt;/p&gt;\n\n&lt;p&gt;You can simply build your specific search mediatype, or if you want to be more RESTful, use something like OpenSearch, and POST the request to the URI the server instructed, say /search. The server can then generate the search result or build the final URI and redirect using a 303.&lt;/p&gt;\n\n&lt;p&gt;This has the advantage of following the traditional PRG method, helps cache intermediaries cache the results, etc.&lt;/p&gt;\n\n&lt;p&gt;That said, URIs are encoded anyway for anything that is not ASCII, and so are application/x-www-form-urlencoded and multipart/form-data. I&apos;d recommend using this rather than creating yet another custom json format if your intention is to support ReSTful scenarios.&lt;/p&gt;\n    ","\n&lt;p&gt;I put this question to the IETF HTTP WG.  The comment from Roy Fielding (author of http/1.1 document in 1998) was that&lt;/p&gt;\n\n&lt;blockquote&gt;\n  &lt;p&gt;&quot;... an implementation would be broken to do anything other than to parse and discard that body if received&quot;&lt;/p&gt;\n&lt;/blockquote&gt;\n\n&lt;p&gt;RFC 7213 (HTTPbis) states:&lt;/p&gt;\n\n&lt;blockquote&gt;\n  &lt;p&gt;&quot;A payload within a GET request message has no defined semantics;&quot;&lt;/p&gt;\n&lt;/blockquote&gt;\n\n&lt;p&gt;It seems clear now that the intention was that semantic meaning on GET request bodies is prohibited, which means that the request body can&apos;t be used to affect the result.&lt;/p&gt;\n\n&lt;p&gt;There are proxies out there that will &lt;strong&gt;definitely&lt;/strong&gt; break your request in various ways if you include a body on GET.&lt;/p&gt;\n\n&lt;p&gt;So in summary, don&apos;t do it.&lt;/p&gt;\n    ","\n&lt;h2&gt;&lt;code&gt;GET&lt;/code&gt;, with a body!?&lt;/h2&gt;\n&lt;p&gt;Specification-wise you could, but, it&apos;s not a good idea to do so injudiciously, as we shall see.&lt;/p&gt;\n&lt;p&gt;&lt;a href=&quot;https://datatracker.ietf.org/doc/html/rfc7231#section-4.3.1&quot; rel=&quot;noreferrer&quot;&gt;RFC 7231 §4.3.1&lt;/a&gt; states that a body &quot;has no defined semantics&quot;, but that&apos;s not to say it is forbidden. If you attach a body to the request and what your server/app makes out of it is up to you. The RFC goes on to state that GET can be &quot;a programmatic view on various database records&quot;. Obviously such view is many times tailored by a large number of input parameters, which are not always convenient or even safe to put in the query component of the request-target.&lt;/p&gt;\n&lt;p&gt;&lt;em&gt;The good:&lt;/em&gt; I like the verbiage. It&apos;s clear that one read/get a resource without any observable side-effects on the server (the method is &quot;safe&quot;), and, the request can be repeated with the same intended effect regardless of the outcome of the first request (the method is &quot;idempotent&quot;).&lt;/p&gt;\n&lt;p&gt;&lt;em&gt;The bad:&lt;/em&gt; An early draft of HTTP/1.1 forbade GET to have a body, and - allegedly - some implementations will even up until today drop the body, ignore the body or reject the message. For example, a dumb HTTP cache may construct a cache key out of the request-target only, being oblivious to the presence or content of a body. An even dumber server could be so ignorant that it treats the body as a new request, which effectively is called &quot;request smuggling&quot; (which is the act of sending &quot;a request to one device without the other device being aware of it&quot; - &lt;a href=&quot;https://www.cgisecurity.com/lib/HTTP-Request-Smuggling.pdf&quot; rel=&quot;noreferrer&quot;&gt;source&lt;/a&gt;).&lt;/p&gt;\n&lt;p&gt;Due to what I believe is primarily a concern with inoperability amongst implementations, &lt;a href=&quot;https://httpwg.org/http-core/draft-ietf-httpbis-semantics-latest.html#rfc.section.9.3.1&quot; rel=&quot;noreferrer&quot;&gt;work in progress&lt;/a&gt; suggests to categorize a GET body as a &quot;SHOULD NOT&quot;, &quot;&lt;strong&gt;unless&lt;/strong&gt; [the request] is made directly to an origin server that has previously indicated, in or out of band, that such a request has a purpose and will be adequately supported&quot; (emphasis mine).&lt;/p&gt;\n&lt;p&gt;&lt;em&gt;The fix:&lt;/em&gt; There&apos;s a few hacks that can be employed for some of the problems with this approach. For example, body-unaware caches can indirectly become body-aware simply by appending a hash derived from the body to the query component, or disable caching altogether by responding a &lt;code&gt;cache-control: no-cache&lt;/code&gt; header from the server.&lt;/p&gt;\n&lt;p&gt;Alas when it comes to the request chain, one is often not in control of- or even aware, of all present and future HTTP intermediaries and how they will deal with a GET body. That&apos;s why this approach must be considered generally unreliable.&lt;/p&gt;\n&lt;h2&gt;But &lt;code&gt;POST&lt;/code&gt;, is not idempotent!&lt;/h2&gt;\n&lt;p&gt;&lt;code&gt;POST&lt;/code&gt; is an alternative. The POST request usually includes a message body (just for the record, body is not a requirement, see &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.3.2&quot; rel=&quot;noreferrer&quot;&gt;RFC 7230 §3.3.2&lt;/a&gt;). The very first use case example from RFC 7231 (&lt;a href=&quot;https://datatracker.ietf.org/doc/html/rfc7231#section-4.3.3&quot; rel=&quot;noreferrer&quot;&gt;§4.3.3&lt;/a&gt;) is &quot;providing a block of data [...] to a data-handling process&quot;. So just like GET with a body, what happens with the body on the back-end side is up to you.&lt;/p&gt;\n&lt;p&gt;&lt;em&gt;The good:&lt;/em&gt; Perhaps a more common method to apply when one wish to send a request body, for whatever purpose, and so, will likely yield the least amount of noise from your team members (some may still falsely believe that POST must create a resource).&lt;/p&gt;\n&lt;p&gt;Also, what we often pass parameters to is a search function operating upon constantly evolving data, and a POST response is only cacheable if explicit freshness information is provided in the response.&lt;/p&gt;\n&lt;p&gt;&lt;em&gt;The bad:&lt;/em&gt; POST requests are not defined as idempotent, leading to request retry hesitancy. For example, on page reload, browsers are unwilling to resubmit an HTML form without prompting the user with a nonreadable cryptic message.&lt;/p&gt;\n&lt;p&gt;&lt;em&gt;The fix:&lt;/em&gt; Well, just because POST is not defined to be idempotent doesn&apos;t mean it mustn&apos;t be. Indeed, &lt;a href=&quot;https://datatracker.ietf.org/doc/html/rfc7230#section-6.3.1&quot; rel=&quot;noreferrer&quot;&gt;RFC 7230 §6.3.1&lt;/a&gt; writes: &quot;a user agent that knows (through design or configuration) that a POST request to a given resource is safe can repeat that request automatically&quot;. So, unless your client is an HTML form, this is probably not a real problem.&lt;/p&gt;\n&lt;h2&gt;&lt;code&gt;QUERY&lt;/code&gt; is the holy grail&lt;/h2&gt;\n&lt;p&gt;There&apos;s a proposal for a new method &lt;code&gt;QUERY&lt;/code&gt; which does define semantics for a message body &lt;em&gt;and&lt;/em&gt; defines the method as idempotent. See &lt;a href=&quot;https://www.ietf.org/id/draft-ietf-httpbis-safe-method-w-body-02.html&quot; rel=&quot;noreferrer&quot;&gt;this&lt;/a&gt;.&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;Edit&lt;/strong&gt;: As a side-note, I stumbled into this StackOverflow question after having discovered a codebase where they solely used &lt;code&gt;PUT&lt;/code&gt; requests for server-side search functions. This were their idea to include a body with parameters and also be idempotent. Alas the problem with PUT is that the request body has very precise semantics. Specifically, the PUT &quot;requests that the state of the target resource be created or replaced with the state [in the body]&quot; (&lt;a href=&quot;https://datatracker.ietf.org/doc/html/rfc7231#section-4.3.4&quot; rel=&quot;noreferrer&quot;&gt;RFC 7231 §4.3.4&lt;/a&gt;). Clearly, this excludes PUT as a viable option.&lt;/p&gt;\n    ","\n&lt;p&gt;From &lt;a href=&quot;https://www.rfc-editor.org/rfc/rfc2616#section-4.3&quot; rel=&quot;nofollow noreferrer&quot;&gt;RFC 2616, section 4.3&lt;/a&gt;, &quot;Message Body&quot;:&lt;/p&gt;\n&lt;blockquote&gt;\n&lt;p&gt;A server SHOULD read and forward a message-body on any request; if the\nrequest method does not include defined semantics for an entity-body,\nthen the message-body SHOULD be ignored when handling the request.&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;p&gt;That is, servers should always read any provided request body from the network (check Content-Length or read a chunked body, etc). Also, proxies should forward any such request body they receive. Then, if the RFC defines semantics for the body for the given method, the server can actually use the request body in generating a response. However, if the RFC &lt;em&gt;does not&lt;/em&gt; define semantics for the body, then the server should ignore it.&lt;/p&gt;\n&lt;p&gt;This is in line with the quote from Fielding above.&lt;/p&gt;\n&lt;p&gt;&lt;a href=&quot;https://www.rfc-editor.org/rfc/rfc2616#section-9.3&quot; rel=&quot;nofollow noreferrer&quot;&gt;Section 9.3&lt;/a&gt;, &quot;GET&quot;, describes the semantics of the GET method, and doesn&apos;t mention request bodies. Therefore, a server should ignore any request body it receives on a GET request.&lt;/p&gt;\n    ","\n&lt;blockquote&gt;\n  &lt;p&gt;Which server will ignore it?  fijiaaron Aug 30 &apos;12 at 21:27&lt;/p&gt;\n&lt;/blockquote&gt;\n\n&lt;p&gt;&lt;strong&gt;Google&lt;/strong&gt; for instance is doing worse than ignoring it, it will consider it an &lt;strong&gt;error&lt;/strong&gt;!&lt;/p&gt;\n\n&lt;p&gt;Try it yourself with a simple netcat:&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;$ netcat www.google.com 80\nGET / HTTP/1.1\nHost: www.google.com\nContent-length: 6\n\n1234\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;(the 1234 content is followed by CR-LF, so that is a total of 6 bytes)&lt;/p&gt;\n\n&lt;p&gt;and you will get:&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;HTTP/1.1 400 Bad Request\nServer: GFE/2.0\n(....)\nError 400 (Bad Request)\n400. Thats an error.\nYour client has issued a malformed or illegal request. Thats all we know.\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;You do also get 400 Bad Request from Bing, Apple, etc... which are served by AkamaiGhost.&lt;/p&gt;\n\n&lt;p&gt;So I wouldn&apos;t advise using GET requests with a body entity.&lt;/p&gt;\n    ","\n&lt;p&gt;According to XMLHttpRequest, it&apos;s not valid. From the &lt;a href=&quot;https://xhr.spec.whatwg.org/#the-send()-method&quot; rel=&quot;noreferrer&quot;&gt;standard&lt;/a&gt;:&lt;/p&gt;\n\n&lt;blockquote&gt;\n  &lt;h3&gt;4.5.6 The &lt;code&gt;send()&lt;/code&gt; method&lt;/h3&gt;\n  \n  &lt;blockquote&gt;\n&lt;pre&gt;&lt;code&gt;&lt;i&gt;client&lt;/i&gt; . send([&lt;i&gt;body&lt;/i&gt; = null])&lt;/code&gt;&lt;/pre&gt;\n    \n    &lt;p&gt;Initiates the request. The optional argument provides the request\n    body. The argument is ignored if request method is &lt;code&gt;GET&lt;/code&gt; or &lt;code&gt;HEAD&lt;/code&gt;.&lt;/p&gt;\n    \n    &lt;p&gt;Throws an &lt;code&gt;InvalidStateError&lt;/code&gt; exception if either state is not\n    &lt;em&gt;opened&lt;/em&gt; or the &lt;code&gt;send()&lt;/code&gt; flag is set.&lt;/p&gt;\n  &lt;/blockquote&gt;\n  \n  &lt;p&gt;The &lt;code&gt;send(&lt;i&gt;body&lt;/i&gt;)&lt;/code&gt; method must run these steps:&lt;/p&gt;\n  \n  &lt;ol&gt;\n  &lt;li&gt;If state is not &lt;em&gt;opened&lt;/em&gt;, throw an &lt;code&gt;InvalidStateError&lt;/code&gt; exception.&lt;/li&gt;\n  &lt;li&gt;If the &lt;code&gt;send()&lt;/code&gt; flag is set, throw an &lt;code&gt;InvalidStateError&lt;/code&gt; exception.&lt;/li&gt;\n  &lt;li&gt;If the request method is &lt;code&gt;GET&lt;/code&gt; or &lt;code&gt;HEAD&lt;/code&gt;, set &lt;em&gt;body&lt;/em&gt; to null.&lt;/li&gt;\n  &lt;li&gt;If &lt;em&gt;body&lt;/em&gt; is null, go to the next step.&lt;/li&gt;\n  &lt;/ol&gt;\n&lt;/blockquote&gt;\n\n&lt;p&gt;Although, I don&apos;t think it should because GET request might need big body content.&lt;/p&gt;\n\n&lt;p&gt;So, if you rely on XMLHttpRequest of a browser, it&apos;s likely it won&apos;t work.&lt;/p&gt;\n    ","\n&lt;p&gt;If you really want to send cachable JSON/XML body to web application the only reasonable place to put your data is query string encoded with &lt;a href=&quot;https://www.rfc-editor.org/rfc/rfc4648#section-5&quot; rel=&quot;nofollow noreferrer&quot;&gt;RFC4648: Base 64 Encoding with URL and Filename Safe Alphabet&lt;/a&gt;. Of course you could just urlencode JSON and put is in URL param&apos;s value, but Base64 gives smaller result. Keep in mind that there are URL size restrictions, see &lt;a href=&quot;https://stackoverflow.com/questions/417142/what-is-the-maximum-length-of-a-url&quot;&gt;What is the maximum length of a URL in different browsers?&lt;/a&gt; .&lt;/p&gt;\n&lt;p&gt;You may think that Base64&apos;s padding &lt;code&gt;=&lt;/code&gt; character may be bad for URL&apos;s param value, however it seems not - see this discussion: &lt;a href=&quot;http://mail.python.org/pipermail/python-bugs-list/2007-February/037195.html&quot; rel=&quot;nofollow noreferrer&quot;&gt;http://mail.python.org/pipermail/python-bugs-list/2007-February/037195.html&lt;/a&gt; . However you shouldn&apos;t put encoded data without param name because encoded string with padding will be interpreted as param key with empty value.\nI would use something like &lt;code&gt;?_b64=&amp;lt;encodeddata&amp;gt;&lt;/code&gt;.&lt;/p&gt;\n    ","\n&lt;p&gt;I wouldn&apos;t advise this, it goes against standard practices, and doesn&apos;t offer that much in return. You want to keep the body for content, not options.&lt;/p&gt;\n    ","\n&lt;p&gt;You have a list of options which are far better than using a request body with GET.&lt;/p&gt;\n\n&lt;p&gt;Let&apos; assume you have categories and items for each category. Both to be identified by an id (&quot;catid&quot; / &quot;itemid&quot; for the sake of this example). You want to sort according to another parameter &quot;sortby&quot; in a specific &quot;order&quot;. You want to pass parameters for &quot;sortby&quot; and &quot;order&quot;:&lt;/p&gt;\n\n&lt;p&gt;You can:&lt;/p&gt;\n\n&lt;ol&gt;\n&lt;li&gt;Use query strings, e.g.\n&lt;code&gt;example.com/category/{catid}/item/{itemid}?sortby=itemname&amp;amp;order=asc&lt;/code&gt;&lt;/li&gt;\n&lt;li&gt;Use mod_rewrite (or similar) for paths:\n&lt;code&gt;example.com/category/{catid}/item/{itemid}/{sortby}/{order}&lt;/code&gt;&lt;/li&gt;\n&lt;li&gt;Use individual HTTP headers you pass with the request&lt;/li&gt;\n&lt;li&gt;Use a different method, e.g. POST, to retrieve a resource.&lt;/li&gt;\n&lt;/ol&gt;\n\n&lt;p&gt;All have their downsides, but are far better than using a GET with a body.&lt;/p&gt;\n    ","\n&lt;p&gt;I&apos;m upset that REST as protocol doesn&apos;t support OOP and &lt;code&gt;Get&lt;/code&gt; method is proof. As a solution, you can serialize your a DTO to JSON and then create a query string. On server side you&apos;ll able to deserialize the query string to the DTO.&lt;/p&gt;\n\n&lt;p&gt;Take a look on:&lt;/p&gt;\n\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=&quot;https://github.com/ServiceStack/ServiceStack/wiki/What-is-a-message-based-web-service?&quot; rel=&quot;nofollow&quot;&gt;Message-based design in ServiceStack&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=&quot;http://www.codeproject.com/Articles/712689/Building-RESTful-Message-Based-Web-Services-with-W&quot; rel=&quot;nofollow&quot;&gt;Building RESTful Message Based Web Services with WCF&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n\n&lt;p&gt;Message based approach can help you to solve Get method restriction. You&apos;ll able to send any DTO as with request body&lt;/p&gt;\n\n&lt;p&gt;&lt;a href=&quot;https://github.com/Nelibur/Nelibur&quot; rel=&quot;nofollow&quot;&gt;Nelibur web service framework provides functionality which you can use&lt;/a&gt;&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;var client = new JsonServiceClient(Settings.Default.ServiceAddress);\nvar request = new GetClientRequest\n    {\n        Id = new Guid(&quot;2217239b0e-b35b-4d32-95c7-5db43e2bd573&quot;)\n    };\nvar response = client.Get&amp;lt;GetClientRequest, ClientResponse&amp;gt;(request);\n\nas you can see, the GetClientRequest was encoded to the following query string\n\nhttp://localhost/clients/GetWithResponse?type=GetClientRequest&amp;amp;data=%7B%22Id%22:%2217239b0e-b35b-4d32-95c7-5db43e2bd573%22%7D\n&lt;/code&gt;&lt;/pre&gt;\n    ","\n&lt;p&gt;What about nonconforming base64 encoded headers? &quot;SOMETHINGAPP-PARAMS:sdfSD45fdg45/aS&quot;&lt;/p&gt;\n\n&lt;p&gt;Length restrictions hm. Can&apos;t you make your POST handling distinguish between the meanings? If you want simple parameters like sorting, I don&apos;t see why this would be a problem. I guess it&apos;s certainty you&apos;re worried about.&lt;/p&gt;\n    ","\n&lt;p&gt;IMHO you could just send the &lt;code&gt;JSON&lt;/code&gt; encoded (ie. &lt;code&gt;encodeURIComponent&lt;/code&gt;) in the &lt;code&gt;URL&lt;/code&gt;, this way you do not violate the &lt;code&gt;HTTP&lt;/code&gt; specs and get your &lt;code&gt;JSON&lt;/code&gt; to the server.&lt;/p&gt;\n    ","\n&lt;p&gt;For example, it works with Curl, Apache and PHP.&lt;/p&gt;\n\n&lt;p&gt;PHP file:&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;&amp;lt;?php\necho $_SERVER[&apos;REQUEST_METHOD&apos;] . PHP_EOL;\necho file_get_contents(&apos;php://input&apos;) . PHP_EOL;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Console command:&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;$ curl -X GET -H &quot;Content-Type: application/json&quot; -d &apos;{&quot;the&quot;: &quot;body&quot;}&apos; &apos;http://localhost/test/get.php&apos;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Output:&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;GET\n{&quot;the&quot;: &quot;body&quot;}\n&lt;/code&gt;&lt;/pre&gt;\n    ","\n&lt;p&gt;Even if a popular tool use this, as cited frequently on this page, I think it is still quite a bad idea, being too exotic, despite not forbidden by the spec.&lt;/p&gt;\n\n&lt;p&gt;Many intermediate infrastructures may just reject such requests.&lt;/p&gt;\n\n&lt;p&gt;By example, forget about using some of the available CDN in front of your web site, like this &lt;a href=&quot;https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/RequestAndResponseBehaviorCustomOrigin.html#RequestCustom-get-body&quot; rel=&quot;nofollow noreferrer&quot;&gt;one&lt;/a&gt;:&lt;/p&gt;\n\n&lt;blockquote&gt;\n  &lt;p&gt;If a viewer &lt;code&gt;GET&lt;/code&gt; request includes a body, CloudFront returns an HTTP status code 403 (Forbidden) to the viewer.&lt;/p&gt;\n&lt;/blockquote&gt;\n\n&lt;p&gt;And yes, your client libraries may also not support emitting such requests, as reported in this &lt;a href=&quot;https://stackoverflow.com/questions/978061/http-get-with-request-body/58215864#comment32122408_978094&quot;&gt;comment&lt;/a&gt;.&lt;/p&gt;\n    ","\n&lt;p&gt;An idea on an old question:&lt;/p&gt;\n&lt;p&gt;Add the content on the body, and a hash of the body on the querystring, so caching won&apos;t be a problem and you&apos;ll be able to send tons of data when needed :)&lt;/p&gt;\n    ","\n&lt;p&gt;Create a Requestfactory class&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;import java.net.URI;\n\nimport javax.annotation.PostConstruct;\n\nimport org.apache.http.client.methods.HttpEntityEnclosingRequestBase;\nimport org.apache.http.client.methods.HttpUriRequest;\nimport org.springframework.http.HttpMethod;\nimport org.springframework.http.client.HttpComponentsClientHttpRequestFactory;\nimport org.springframework.stereotype.Component;\nimport org.springframework.web.client.RestTemplate;\n\n@Component\npublic class RequestFactory {\n    private RestTemplate restTemplate = new RestTemplate();\n\n    @PostConstruct\n    public void init() {\n        this.restTemplate.setRequestFactory(new HttpComponentsClientHttpRequestWithBodyFactory());\n    }\n\n    private static final class HttpComponentsClientHttpRequestWithBodyFactory extends HttpComponentsClientHttpRequestFactory {\n        @Override\n        protected HttpUriRequest createHttpUriRequest(HttpMethod httpMethod, URI uri) {\n            if (httpMethod == HttpMethod.GET) {\n                return new HttpGetRequestWithEntity(uri);\n            }\n            return super.createHttpUriRequest(httpMethod, uri);\n        }\n    }\n\n    private static final class HttpGetRequestWithEntity extends HttpEntityEnclosingRequestBase {\n        public HttpGetRequestWithEntity(final URI uri) {\n            super.setURI(uri);\n        }\n\n        @Override\n        public String getMethod() {\n            return HttpMethod.GET.name();\n        }\n    }\n\n    public RestTemplate getRestTemplate() {\n        return restTemplate;\n    }\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;and @Autowired where ever you require and use, Here is one sample code GET request with RequestBody&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt; @RestController\n @RequestMapping(&quot;/v1/API&quot;)\npublic class APIServiceController {\n    \n    @Autowired\n    private RequestFactory requestFactory;\n    \n\n    @RequestMapping(method = RequestMethod.GET, path = &quot;/getData&quot;)\n    public ResponseEntity&amp;lt;APIResponse&amp;gt; getLicenses(@RequestBody APIRequest2 APIRequest){\n        APIResponse response = new APIResponse();\n        HttpHeaders headers = new HttpHeaders();\n        headers.setContentType(MediaType.APPLICATION_JSON);\n        Gson gson = new Gson();\n        try {\n            StringBuilder createPartUrl = new StringBuilder(PART_URL).append(PART_URL2);\n            \n            HttpEntity&amp;lt;String&amp;gt; entity = new HttpEntity&amp;lt;String&amp;gt;(gson.toJson(APIRequest),headers);\n            ResponseEntity&amp;lt;APIResponse&amp;gt; storeViewResponse = requestFactory.getRestTemplate().exchange(createPartUrl.toString(), HttpMethod.GET, entity, APIResponse.class); //.getForObject(createLicenseUrl.toString(), APIResponse.class, entity);\n    \n            if(storeViewResponse.hasBody()) {\n                response = storeViewResponse.getBody();\n            }\n            return new ResponseEntity&amp;lt;APIResponse&amp;gt;(response, HttpStatus.OK);\n        }catch (Exception e) {\n            e.printStackTrace();\n            return new ResponseEntity&amp;lt;APIResponse&amp;gt;(response, HttpStatus.INTERNAL_SERVER_ERROR);\n        }\n        \n    }\n}\n&lt;/code&gt;&lt;/pre&gt;\n    "]},"randomTags":[{"name":"multiline","slug":"multiline"},{"name":"android-asynctask","slug":"android-asynctask"},{"name":"threetenbp","slug":"threetenbp"},{"name":"chromium","slug":"chromium"},{"name":"int","slug":"int"},{"name":"function-pointers","slug":"function-pointers"},{"name":"event-delegation","slug":"event-delegation"},{"name":"sed","slug":"sed"},{"name":"double-quotes","slug":"double-quotes"},{"name":"q","slug":"q"},{"name":"scroll","slug":"scroll"},{"name":"eval","slug":"eval"},{"name":"jsonp","slug":"jsonp"},{"name":"closures","slug":"closures"},{"name":"join","slug":"join"},{"name":"mod-rewrite","slug":"mod-rewrite"},{"name":"same-origin-policy","slug":"same-origin-policy"},{"name":"filtering","slug":"filtering"},{"name":"max","slug":"max"},{"name":"google-cloud-firestore","slug":"google-cloud-firestore"}]},"__N_SSG":true}