{"pageProps":{"data":{"count":1,"rows":[{"id":235,"title":"What are drawbacks or disadvantages of singleton pattern? [closed]","slug":"what-are-drawbacks-or-disadvantages-of-singleton-pattern-closed-1657387360749","postType":"QUESTION","createdAt":"2022-07-09T17:22:40.000Z","updatedAt":"2022-07-09T17:22:40.000Z","tags":[{"id":1565,"name":"design-patterns","slug":"design-patterns","createdAt":"2022-07-09T17:22:40.000Z","updatedAt":"2022-07-09T17:22:40.000Z","Questions_Tags":{"questionId":235,"tagId":1565}}]}]},"slug":"design-patterns","page":1,"answers":{"235":["\n&lt;p&gt;Paraphrased from Brian Button:&lt;/p&gt;\n\n&lt;ol&gt;\n&lt;li&gt;&lt;p&gt;They are generally used as a global instance, why is that so bad? Because you hide the dependencies of your application in your code, instead of exposing them through the interfaces. Making something global to avoid passing it around is a &lt;a href=&quot;https://en.wikipedia.org/wiki/Code_smell&quot; rel=&quot;noreferrer&quot;&gt;code smell&lt;/a&gt;.&lt;/p&gt;&lt;/li&gt;\n&lt;li&gt;&lt;p&gt;They violate the &lt;a href=&quot;https://en.wikipedia.org/wiki/Single_responsibility_principle&quot; rel=&quot;noreferrer&quot;&gt;single responsibility principle&lt;/a&gt;: by virtue of the fact that they control their own creation and lifecycle.&lt;/p&gt;&lt;/li&gt;\n&lt;li&gt;&lt;p&gt;They inherently cause code to be tightly &lt;a href=&quot;https://en.wikipedia.org/wiki/Coupling_%28computer_programming%29&quot; rel=&quot;noreferrer&quot;&gt;coupled&lt;/a&gt;. This makes faking them out under test rather difficult in many cases.&lt;/p&gt;&lt;/li&gt;\n&lt;li&gt;&lt;p&gt;They carry state around for the lifetime of the application. Another hit to testing since you can end up with a situation where tests need to be ordered which is a big no no for unit tests. Why? Because each unit test should be independent from the other.&lt;/p&gt;&lt;/li&gt;\n&lt;/ol&gt;\n    ","\n&lt;p&gt;Singletons solve one (and only one) problem.&lt;/p&gt;\n\n&lt;p&gt;&lt;strong&gt;Resource Contention.&lt;/strong&gt;&lt;/p&gt;\n\n&lt;p&gt;If you have some resource that &lt;/p&gt;\n\n&lt;p&gt;(&lt;strong&gt;1&lt;/strong&gt;) can only have a single instance, and &lt;/p&gt;\n\n&lt;p&gt;(&lt;strong&gt;2&lt;/strong&gt;) you need to manage that single instance, &lt;/p&gt;\n\n&lt;p&gt;you need a &lt;strong&gt;singleton&lt;/strong&gt;.&lt;/p&gt;\n\n&lt;p&gt;There aren&apos;t many examples. A log file is the big one. You don&apos;t want to just abandon a single log file. You want to flush, sync and close it properly. This is an example of a single shared resource that has to be managed.&lt;/p&gt;\n\n&lt;p&gt;It&apos;s rare that you need a singleton. The reason they&apos;re bad is that they feel like a &lt;a href=&quot;https://en.wikipedia.org/wiki/Global_variable&quot; rel=&quot;noreferrer&quot;&gt;global&lt;/a&gt; and they&apos;re a fully paid up member of the GoF &lt;em&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Design_Patterns&quot; rel=&quot;noreferrer&quot;&gt;Design Patterns&lt;/a&gt;&lt;/em&gt; book.&lt;/p&gt;\n\n&lt;p&gt;When you think you need a global, you&apos;re probably making a terrible design mistake.&lt;/p&gt;\n    ","\n&lt;p&gt;Some coding snobs look down on them as just a glorified global. In the same way that many people hate the &lt;em&gt;goto&lt;/em&gt; statement there are others that hate the idea of ever using a &lt;em&gt;global&lt;/em&gt;. I have seen several developers go to extraordinary lengths to avoid a &lt;em&gt;global&lt;/em&gt; because they considered using one as an admission of failure. Strange but true.&lt;/p&gt;\n\n&lt;p&gt;In practice the &lt;em&gt;Singleton&lt;/em&gt; pattern is just a programming technique that is a useful part of your toolkit of concepts. From time to time you might find it is the ideal solution and so use it. But using it just so you can boast about using a &lt;em&gt;design pattern&lt;/em&gt; is just as stupid as refusing to ever use it because it is just a &lt;em&gt;global&lt;/em&gt;.&lt;/p&gt;\n    ","\n&lt;p&gt;Misko Hevery, from Google, has some interesting articles on exactly this topic...&lt;/p&gt;\n&lt;p&gt;&lt;a href=&quot;https://testing.googleblog.com/2008/08/by-miko-hevery-so-you-join-new-project.html&quot; rel=&quot;noreferrer&quot;&gt;Singletons are Pathological Liars&lt;/a&gt; has a unit testing example that illustrates how singletons can make it difficult to figure out dependency chains and start or test an application. It is a fairly extreme example of abuse, but the point that he makes is still valid:&lt;/p&gt;\n&lt;blockquote&gt;\n&lt;p&gt;Singletons are nothing more than global state. Global state makes it so your objects can secretly get hold of things which are not declared in their APIs, and, as a result, Singletons make your APIs into pathological liars.&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;p&gt;&lt;a href=&quot;https://testing.googleblog.com/2008/08/where-have-all-singletons-gone.html&quot; rel=&quot;noreferrer&quot;&gt;Where have all the Singletons Gone&lt;/a&gt; makes the point that dependency injection has made it easy to get instances to constructors that require them, which alleviates the underlying need behind the bad, global Singletons decried in the first article.&lt;/p&gt;\n    ","\n&lt;p&gt;I think the confusion is caused by the fact that people don&apos;t know the real application of the Singleton pattern. I can&apos;t stress this enough. Singleton is &lt;strong&gt;not&lt;/strong&gt; a pattern to wrap globals. Singleton pattern should only be used to guarantee that &lt;strong&gt;one and only one instance of a given class&lt;/strong&gt; exists during run time. &lt;/p&gt;\n\n&lt;p&gt;People think Singleton is evil because they are using it for globals. It is because of this confusion that Singleton is looked down upon. Please, don&apos;t confuse Singletons and globals. If used for the purpose it was intended for, you will gain extreme benefits from the Singleton pattern.&lt;/p&gt;\n    ","\n&lt;p&gt;One rather bad thing about singletons is that you can&apos;t extend them very easily. You basically have to build in some kind of &lt;a href=&quot;https://en.wikipedia.org/wiki/Decorator_pattern&quot; rel=&quot;noreferrer&quot;&gt;decorator pattern&lt;/a&gt; or some such thing if you want to change their behavior. Also, if one day you want to have multiple ways of doing that one thing, it can be rather painful to change, depending on how you lay out your code.&lt;/p&gt;\n\n&lt;p&gt;One thing to note, if you DO use singletons, try to pass them in to whoever needs them rather than have them access it directly... Otherwise if you ever choose to have multiple ways of doing the thing that singleton does, it will be rather difficult to change as each class embeds a dependency if it accesses the singleton directly.&lt;/p&gt;\n\n&lt;p&gt;So basically:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-java s-code-block&quot;&gt;&lt;code class=&quot;hljs language-java&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;MyConstructor&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(Singleton singleton)&lt;/span&gt; {\n    &lt;span class=&quot;hljs-built_in&quot;&gt;this&lt;/span&gt;.singleton = singleton;\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;rather than:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-java s-code-block&quot;&gt;&lt;code class=&quot;hljs language-java&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;MyConstructor&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt; {\n    &lt;span class=&quot;hljs-built_in&quot;&gt;this&lt;/span&gt;.singleton = Singleton.getInstance();\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;I believe this sort of pattern is called &lt;a href=&quot;http://en.wikipedia.org/wiki/Dependency_injection&quot; rel=&quot;noreferrer&quot;&gt;dependency injection&lt;/a&gt; and is generally considered a good thing.&lt;/p&gt;\n\n&lt;p&gt;Like any pattern though... Think about it and consider if its use in the given situation is inappropriate or not... Rules are made to be broken usually, and &lt;a href=&quot;https://en.wikipedia.org/wiki/Software_design_pattern&quot; rel=&quot;noreferrer&quot;&gt;patterns&lt;/a&gt; should not be applied willy nilly without thought.&lt;/p&gt;\n    ","\n&lt;p&gt;The singleton pattern is not a problem in itself. The problem is that the pattern is often used by people developing software with object-oriented tools without having a solid grasp of OO concepts. When singletons are introduced in this context they tend to grow into unmanageable classes that contain helper methods for every little use.&lt;/p&gt;\n\n&lt;p&gt;Singletons are also a problem from a testing perspective. They tend to make isolated unit-tests difficult to write. &lt;strong&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Inversion_of_control&quot; rel=&quot;noreferrer&quot;&gt;Inversion of control&lt;/a&gt;&lt;/strong&gt; (IoC) and &lt;strong&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Dependency_injection&quot; rel=&quot;noreferrer&quot;&gt;dependency injection&lt;/a&gt;&lt;/strong&gt; are patterns meant to overcome this problem in an object-oriented manner that lends itself to unit testing.&lt;/p&gt;\n\n&lt;p&gt;In a &lt;a href=&quot;https://en.wikipedia.org/wiki/Garbage_collection_%28computer_science%29&quot; rel=&quot;noreferrer&quot;&gt;garbage collected&lt;/a&gt; environment singletons can quickly become an issue with regard to memory management.&lt;/p&gt;\n\n&lt;p&gt;There is also the multi-threaded scenario where singletons can become a bottleneck as well as a synchronization issue.&lt;/p&gt;\n    ","\n&lt;p&gt;A singleton gets implemented using a static method. Static methods are avoided by people who do unit testing because they cannot be mocked or stubbed. Most people on this site are big proponents of unit testing. The generally most accepted convention to avoid them is using the &lt;a href=&quot;http://en.wikipedia.org/wiki/Inversion_of_control&quot; rel=&quot;noreferrer&quot;&gt;inversion of control&lt;/a&gt; pattern.&lt;/p&gt;\n    ","\n&lt;p&gt;Singletons are also bad when it comes to &lt;strong&gt;clustering&lt;/strong&gt;. Because then, you do not have &quot;exactly one singleton&quot; in your application anymore.&lt;/p&gt;\n\n&lt;p&gt;Consider the following situation: As a developer, you have to create a web application which accesses a database. To ensure that concurrent database calls do not conflict each other, you create a thread-save &lt;code&gt;SingletonDao&lt;/code&gt;:&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;public class SingletonDao {\n    // songleton&apos;s static variable and getInstance() method etc. omitted\n    public void writeXYZ(...){\n        synchronized(...){\n            // some database writing operations...\n        }\n    }\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;So you are sure that only one singleton in your application exists and all database go through this one and only &lt;code&gt;SingletonDao&lt;/code&gt;. Your production environment now looks like this:\n&lt;img src=&quot;https://i.stack.imgur.com/ySPwz.png&quot; alt=&quot;Single Singleton&quot;&gt;&lt;/p&gt;\n\n&lt;p&gt;Everything is fine so far.&lt;/p&gt;\n\n&lt;p&gt;Now, consider you want to set up multiple instances of your web application in a cluster. Now, you suddenly have something like this:&lt;/p&gt;\n\n&lt;p&gt;&lt;img src=&quot;https://i.stack.imgur.com/Cg1V3.png&quot; alt=&quot;Many singletons&quot;&gt;&lt;/p&gt;\n\n&lt;p&gt;That sounds weird, but &lt;strong&gt;now you have many singletons in your application&lt;/strong&gt;. And that is exactly what a singleton is not supposed to be: Having many objects of it. This is especially bad if you, as shown in this example, want to make synchronized calls to a database.&lt;/p&gt;\n\n&lt;p&gt;Of course this is an example of a bad usage of a singleton. But the message of this example is: You can not rely that there is exactly one instance of a singleton in your application - especially when it comes to clustering.&lt;/p&gt;\n    ","\n&lt;ol&gt;\n&lt;li&gt;It is easily (ab)used as a global variable.&lt;/li&gt;\n&lt;li&gt;Classes that depend on singletons are relatively harder to unit test in isolation.&lt;/li&gt;\n&lt;/ol&gt;\n    ","\n&lt;p&gt;&lt;strong&gt;Monopoly is the devil and singletons with non-readonly/mutable state are the &apos;real&apos; problem...&lt;/strong&gt;&lt;/p&gt;\n\n&lt;p&gt;After reading &lt;a href=&quot;http://misko.hevery.com/2008/08/17/singletons-are-pathological-liars/&quot; rel=&quot;noreferrer&quot;&gt;Singletons are Pathological Liars&lt;/a&gt; as suggested in &lt;a href=&quot;https://stackoverflow.com/a/137996/632951&quot;&gt;jason&apos;s answer&lt;/a&gt; I came across this little tidbit that provides the best presented example of &lt;strong&gt;how&lt;/strong&gt; singletons are often misused.&lt;/p&gt;\n\n&lt;blockquote&gt;\n  &lt;p&gt;Global is bad because:&lt;/p&gt;\n  \n  &lt;ul&gt;\n  &lt;li&gt;a. It causes namespace conflict&lt;/li&gt;\n  &lt;li&gt;b. It exposes the state in a unwarranted fashion&lt;/li&gt;\n  &lt;/ul&gt;\n  \n  &lt;p&gt;When it comes to Singletons&lt;/p&gt;\n  \n  &lt;ul&gt;\n  &lt;li&gt;a. The explicit OO way of calling them, prevents the conflicts, so point a. is not an issue&lt;/li&gt;\n  &lt;li&gt;b. Singletons without state are (like factories) are not a problem. Singletons with state can again fall in two categories, those which are immutable or write once and read many (config/property files). These are not bad. Mutable Singletons, which are kind of reference holders are the ones which you are speaking of.&lt;/li&gt;\n  &lt;/ul&gt;\n&lt;/blockquote&gt;\n\n&lt;p&gt;In the last statement he&apos;s referring to the blog&apos;s concept of &apos;singletons are liars&apos;.&lt;/p&gt;\n\n&lt;p&gt;&lt;strong&gt;How does this apply to Monopoly?&lt;/strong&gt;&lt;/p&gt;\n\n&lt;p&gt;To start a game of monopoly, first:&lt;/p&gt;\n\n&lt;ul&gt;\n&lt;li&gt;we establish the rules first so everybody is on the same page&lt;/li&gt;\n&lt;li&gt;everybody is given an equal start at the beginning of the game&lt;/li&gt;\n&lt;li&gt;only one set of rules is presented to avoid confusion&lt;/li&gt;\n&lt;li&gt;the rules aren&apos;t allowed to change throughout the game&lt;/li&gt;\n&lt;/ul&gt;\n\n&lt;p&gt;Now, for anybody who hasn&apos;t &lt;strong&gt;really&lt;/strong&gt; played monopoly, these standards are ideal at best. A defeat in monopoly is hard to swallow because, monopoly is about money, if you lose you have to painstakingly watch the rest of the players finish the game, and losses are usually swift and crushing. So, the rules usually get twisted at some point to serve the self-interest of some of the players at the expense of the others.&lt;/p&gt;\n\n&lt;p&gt;So you&apos;re playing monopoly with friends Bob, Joe, and Ed. You&apos;re swiftly building your empire and consuming market share at an exponential rate. Your opponents are weakening and you start to smell blood (figuratively). Your buddy Bob put all of his money into gridlocking as many low-value properties as possible but his isn&apos;t receiving a high return on investment the way he expected. Bob, as a stroke of bad luck, lands on your Boardwalk and is excised from the game.&lt;/p&gt;\n\n&lt;p&gt;Now the game goes from friendly dice-rolling to serious business. Bob has been made the example of failure and Joe and Ed don&apos;t want to end up like &apos;that guy&apos;. So, being the leading player you, all of a sudden, become the enemy. Joe and Ed start practicing under-the-table trades, behind-the-back money injections, undervalued house-swapping and generally anything to weaken you as a player until one of them rises to the top. &lt;/p&gt;\n\n&lt;p&gt;Then, instead of one of them winning, the process starts all over. All of a sudden, a finite set of rules becomes a moving target and the game degenerates into the type of social interactions that would make up the foundation of every high-rated reality TV show since Survivor. Why, because the rules are changing and there&apos;s no consensus on how/why/what they&apos;re supposed to represent, and more importantly, there&apos;s no one person making the decisions. Every player in the game, at that point, is making his/her own rules and chaos ensues until two of the players are too tired to keep up the charade and slowly give up.&lt;/p&gt;\n\n&lt;p&gt;So, if a rulebook for a game accurately represented a singleton, the monopoly rulebook would be an example of abuse. &lt;/p&gt;\n\n&lt;p&gt;&lt;strong&gt;How does this apply to programming?&lt;/strong&gt;&lt;/p&gt;\n\n&lt;p&gt;Aside from all of the obvious thread-safety and synchronization issues that mutable singletons present... If you have one set of data, that is capable of being read/manipulated by multiple different sources concurrently and exists during the lifetime of the application execution, it&apos;s probably a good time to step back and ask &quot;am I using the right type of data structure here&quot;.&lt;/p&gt;\n\n&lt;p&gt;Personally, I have seen a programmer abuse a singleton by using it as some sort of twisted cross-thread database store within an application. Having worked on the code directly, I can attest that it was a slow (because of all the thread locks needed to make it thread-safe) and a nightmare to work on (because of the unpredictable/intermittent nature of synchronization bugs), and nearly impossible to test under &apos;production&apos; conditions. Sure, a system could have been developed using polling/signaling to overcome some of the performance issues but that wouldn&apos;t solve the issues with testing and, why bother when a &apos;real&apos; database can already accomplish the same functionality in a much more robust/scalable manner.&lt;/p&gt;\n\n&lt;p&gt;&lt;strong&gt;A Singleton is &lt;em&gt;only&lt;/em&gt; an option if you need what a singleton provides. A write-one read-only instance of an object. That same rule should cascade to the object&apos;s properties/members as well.&lt;/strong&gt;&lt;/p&gt;\n    ","\n&lt;h2&gt;Singleton is not about single instance!&lt;/h2&gt;\n\n&lt;p&gt;Unlike other answers I don&apos;t want to talk about what is wrong with Singletons but to show you how powerful and awesome they are when used right!&lt;/p&gt;\n\n&lt;ul&gt;\n&lt;li&gt;&lt;strong&gt;Problem&lt;/strong&gt;: Singleton can be a challenge in multi-threading environment&lt;br&gt;\n&lt;strong&gt;Solution&lt;/strong&gt;: Use a single threaded bootstrap process to initialize all the   dependencies of your singleton.&lt;/li&gt;\n&lt;li&gt;&lt;strong&gt;Problem&lt;/strong&gt;: It is hard to mock singletons.&lt;br&gt;\n&lt;strong&gt;Solution&lt;/strong&gt;: Use method &lt;a href=&quot;https://github.com/gazman-sdk/android_life_cycle/wiki&quot; rel=&quot;noreferrer&quot;&gt;Factory&lt;/a&gt; pattern for mocking  &lt;/li&gt;\n&lt;/ul&gt;\n\n&lt;pre&gt;&lt;code&gt;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;You can map &lt;code&gt;MyModel&lt;/code&gt; to &lt;code&gt;TestMyModel&lt;/code&gt; class that inherits it, everywhere when &lt;code&gt;MyModel&lt;/code&gt; will be injected you will get &lt;code&gt;TestMyModel&lt;/code&gt; instread.\n - &lt;strong&gt;Problem&lt;/strong&gt;: Singletons can cause memory leaks as they never disposed.&lt;br&gt;\n   &lt;strong&gt;Solution&lt;/strong&gt;: Well, dispose them! Implement a callback in your app to properly dispose a singletons, you should remove any data linked to them and finally: remove them from the Factory. &lt;/p&gt;\n\n&lt;p&gt;As I stated at the title singleton are not about single instance.&lt;/p&gt;\n\n&lt;ul&gt;\n&lt;li&gt;&lt;strong&gt;Singletons improves readability&lt;/strong&gt;: You can look at your class and see what singleton it injected to figure out what is it&apos;s dependencies.&lt;/li&gt;\n&lt;li&gt;&lt;strong&gt;Singletons improves maintenance&lt;/strong&gt;: Once you removed a dependency from a class you just deleted some singleton injection, you don&apos;t need to go and edit a big link of other classes that just moved your dependency around(This is smelly code for me &lt;a href=&quot;https://stackoverflow.com/a/138012/1129332&quot;&gt;@Jim Burger&lt;/a&gt;)&lt;/li&gt;\n&lt;li&gt;&lt;strong&gt;Singletons improves memory and performance&lt;/strong&gt;: When some thing happens in your application, and it takes a long chain of callbacks to deliver, you are wasting memory and performance, by using Singleton you are cutting the middle man, and improve your performance and memory usage(by avoiding unnecessary local variables allocations).&lt;/li&gt;\n&lt;/ul&gt;\n    ","\n&lt;p&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Singleton_pattern&quot; rel=&quot;noreferrer&quot;&gt;See Wikipedia Singleton_pattern&lt;/a&gt;&lt;/p&gt;\n\n&lt;blockquote&gt;\n  &lt;p&gt;It is also considered an anti-pattern by some people, who feel that it is overly used, introducing unnecessary limitations in situations where a sole instance of a class is not actually required.[1][2][3][4]&lt;/p&gt;\n&lt;/blockquote&gt;\n\n&lt;p&gt;References (only relevant references from the article)&lt;/p&gt;\n\n&lt;ol&gt;\n&lt;li&gt;^ Alex Miller. &lt;a href=&quot;http://tech.puredanger.com/2007/07/03/pattern-hate-singleton/&quot; rel=&quot;noreferrer&quot;&gt;Patterns I hate #1: Singleton&lt;/a&gt;, July 2007&lt;/li&gt;\n&lt;li&gt;^ Scott Densmore. &lt;a href=&quot;http://blogs.msdn.com/scottdensmore/archive/2004/05/25/140827.aspx&quot; rel=&quot;noreferrer&quot;&gt;Why singletons are evil&lt;/a&gt;, May 2004&lt;/li&gt;\n&lt;li&gt;^ Steve Yegge. &lt;a href=&quot;http://steve.yegge.googlepages.com/singleton-considered-stupid&quot; rel=&quot;noreferrer&quot;&gt;Singletons considered stupid&lt;/a&gt;, September 2004&lt;/li&gt;\n&lt;li&gt;^ J.B. Rainsberger, IBM. &lt;a href=&quot;http://www-128.ibm.com/developerworks/webservices/library/co-single.html&quot; rel=&quot;noreferrer&quot;&gt;Use your singletons wisely&lt;/a&gt;, July 2001&lt;/li&gt;\n&lt;/ol&gt;\n    ","\n&lt;p&gt;My answer on how Singletons are bad is always, &quot;they are hard to do right&quot;. Many of the foundational components of languages are singletons (classes, functions, namespaces and even operators), as are components in other aspects of computing (localhost, default route, virtual filesystem, etc.), and it is not by accident. While they cause trouble and frustration from time to time, they also can make a lot of things work a LOT better.&lt;/p&gt;\n\n&lt;p&gt;The two biggest screw ups I see are: treating it like a global &amp;amp; failing to define the Singleton closure.&lt;/p&gt;\n\n&lt;p&gt;Everyone talks about Singleton&apos;s as globals, because they basically are. However, much (sadly, not all) of the badness in a global comes not intrinsically from being global, but how you use it. Same goes for Singletons. Actually more so as &quot;single instance&quot; really doesn&apos;t need to mean &quot;globally accessible&quot;. It is more a natural byproduct, and given all the bad that we know comes from it, we shouldn&apos;t be in such a hurry to exploit global accessibility. Once programmers see a Singleton they seem to always access it directly through its instance method. Instead, you should navigate to it just like you would any other object. Most code shouldn&apos;t even be aware it is dealing with a Singleton (loose coupling, right?). If only a small bit of code accesses the object like it is a global, a lot of harm is undone. I recommend enforcing it by restricting access to the instance function.&lt;/p&gt;\n\n&lt;p&gt;The Singleton context is also really important. The defining characteristic of a Singleton is that there is &quot;only one&quot;, but the truth is it is &quot;only one&quot; within some kind of context/namespace. They are usually one of: one per thread, process, IP address or cluster, but can also be one per processor, machine, language namespace/class loader/whatever, subnet, Internet, etc.&lt;/p&gt;\n\n&lt;p&gt;The other, less common, mistake is to ignore the Singleton lifestyle. Just because there is only one doesn&apos;t mean a Singleton is some omnipotent &quot;always was and always will be&quot;, nor is it generally desirable (objects without a begin and end violate all kinds of useful assumptions in code, and should be employed only in the most desperate of circumstances.&lt;/p&gt;\n\n&lt;p&gt;If you avoid those mistakes, Singletons can still be a PITA, bit it is ready to see a lot of the worst problems are significantly mitigated. Imagine a Java Singleton, that is explicitly defined as once per classloader (which means it needs a thread safety policy), with defined creation and destruction methods and a life cycle that dictates when and how they get invoked, and whose &quot;instance&quot; method has package protection so it is generally accessed through other, non-global objects. Still a potential source of trouble, but certainly much less trouble.&lt;/p&gt;\n\n&lt;p&gt;Sadly, rather than teaching good examples of how to do Singletons. We teach bad examples, let programmers run off using them for a while, and then tell them they are a bad design pattern.&lt;/p&gt;\n    ","\n&lt;p&gt;It&apos;s not that singletons themselves are bad but the GoF design pattern is. The only really argument that is valid is that the GoF design pattern doesn&apos;t lend itself in regards to testing, especially if tests are run in parallel.&lt;/p&gt;\n\n&lt;p&gt;Using a single instance of an class is a valid construct as long as you apply the following means in code:&lt;/p&gt;\n\n&lt;ol&gt;\n&lt;li&gt;&lt;p&gt;Make sure the class that will be used as a singleton implements an interface. This allows stubs or mocks to be implemented using the same interface&lt;/p&gt;&lt;/li&gt;\n&lt;li&gt;&lt;p&gt;Make sure that the Singleton is thread-safe.  That&apos;s a given.&lt;/p&gt;&lt;/li&gt;\n&lt;li&gt;&lt;p&gt;The singleton should be simple in nature and not overly complicated.&lt;/p&gt;&lt;/li&gt;\n&lt;li&gt;&lt;p&gt;During the runtime of you application, where singletons need to be passed to a given object, use a class factory that builds that object and have the class factory pass the singleton instance to the class that needs it.&lt;/p&gt;&lt;/li&gt;\n&lt;li&gt;&lt;p&gt;During testing and to ensure deterministic behavior, create the singleton class as separate instance as either the actual class itself or a stub/mock that implements its behavior and pass it as is to the class that requires it. Don&apos;t use the class factor that creates that object under test that needs the singleton during test as it will pass the single global instance of it, which defeats the purpose.&lt;/p&gt;&lt;/li&gt;\n&lt;/ol&gt;\n\n&lt;p&gt;We&apos;ve used Singletons in our solutions with a great deal of success that are testable ensuring deterministic behavior in parallel test run streams.&lt;/p&gt;\n    ","\n&lt;p&gt;&lt;a href=&quot;http://www.vincehuston.org/dp/singleton.html&quot; rel=&quot;noreferrer&quot;&gt;Vince Huston&lt;/a&gt; has these criteria, which seem reasonable to me:&lt;/p&gt;\n\n&lt;blockquote&gt;\n  &lt;p&gt;Singleton should be considered only if all three of the following criteria are satisfied:&lt;/p&gt;\n  \n  &lt;ul&gt;\n  &lt;li&gt;Ownership of the single instance cannot be reasonably assigned&lt;/li&gt;\n  &lt;li&gt;Lazy initialization is desirable&lt;/li&gt;\n  &lt;li&gt;Global access is not otherwise provided for &lt;/li&gt;\n  &lt;/ul&gt;\n  \n  &lt;p&gt;If ownership of the single instance, when and how initialization occurs, and global access are not issues, Singleton is not sufficiently interesting.&lt;/p&gt;\n&lt;/blockquote&gt;\n    ","\n&lt;p&gt;I&apos;d like to address the 4 points in the accepted answer, hopefully someone can explain why I&apos;m wrong.&lt;/p&gt;\n\n&lt;ol&gt;\n&lt;li&gt;&lt;p&gt;Why is hiding dependencies in your code bad? There are already dozens of hidden dependencies (C runtime calls, OS API calls, global function calls), and singleton dependencies are easy to find (search for instance()). &lt;/p&gt;\n\n&lt;p&gt;&quot;Making something global to avoid passing it around is a code smell.&quot; Why isn&apos;t passing something around to avoid making it a singleton a code smell? &lt;/p&gt;\n\n&lt;p&gt;If you&apos;re passing an object through 10 functions in a call stack just to avoid a singleton, is that so great?&lt;/p&gt;&lt;/li&gt;\n&lt;li&gt;&lt;p&gt;Single Responsibility Principle: I think this is a bit vague and depends on your definition of responsibility. A relevant question would be, why does adding this &lt;em&gt;specific&lt;/em&gt; &quot;responsibility&quot; to a class matter?&lt;/p&gt;&lt;/li&gt;\n&lt;li&gt;&lt;p&gt;Why does passing an object to a class make it more tightly coupled than using that object as a singleton from within the class?&lt;/p&gt;&lt;/li&gt;\n&lt;li&gt;&lt;p&gt;Why does it change how long the state lasts? Singletons can be created or destroyed manually, so the control is still there, and you can make the lifetime the same as a non-singleton object&apos;s lifetime would be.&lt;/p&gt;&lt;/li&gt;\n&lt;/ol&gt;\n\n&lt;p&gt;Regarding unit tests:&lt;/p&gt;\n\n&lt;ul&gt;\n&lt;li&gt;not all classes need to be unit\ntested&lt;/li&gt;\n&lt;li&gt;not all classes that need to be unit\ntested need to change the\nimplementation of the singleton&lt;/li&gt;\n&lt;li&gt;if they &lt;em&gt;do&lt;/em&gt; need be unit tested and\ndo need to change the implementation,\nit&apos;s easy to change a class from\nusing a singleton to having the\nsingleton passed to it via dependency\ninjection.&lt;/li&gt;\n&lt;/ul&gt;\n    ","\n&lt;p&gt;Singletons are bad from a purist point of view.&lt;/p&gt;\n\n&lt;p&gt;From a pratical point of view, &lt;strong&gt;a singleton is a trade-off developing time vs complexity&lt;/strong&gt;.&lt;/p&gt;\n\n&lt;p&gt;If you know your application won&apos;t change that much they are pretty OK to go with. Just know that you may need to refactor things up if your requirements change in an unexpected way (which is pretty OK in most cases).&lt;/p&gt;\n\n&lt;p&gt;Singletons sometimes also complicate &lt;a href=&quot;https://en.wikipedia.org/wiki/Unit_testing&quot; rel=&quot;noreferrer&quot;&gt;unit testing&lt;/a&gt;.&lt;/p&gt;\n    ","\n&lt;p&gt;I&apos;m not going to comment on the good/evil argument, but I haven&apos;t used them since &lt;a href=&quot;http://en.wikipedia.org/wiki/Spring_Framework&quot; rel=&quot;nofollow noreferrer&quot;&gt;Spring&lt;/a&gt; came along. Using &lt;a href=&quot;http://en.wikipedia.org/wiki/Dependency_injection&quot; rel=&quot;nofollow noreferrer&quot;&gt;dependency injection&lt;/a&gt; has pretty much removed my requirements for singleton, servicelocators and factories. I find this a much more productive and clean environment, at least for the type of work I do (Java-based web applications).&lt;/p&gt;\n    ","\n&lt;p&gt;There is nothing inherently wrong with the pattern, assuming it is being used for some aspect of your model which is truly single.&lt;/p&gt;\n\n&lt;p&gt;I believe the backlash is due to its overuse which, in turn, is due to the fact that it&apos;s the easiest pattern to understand and implement.&lt;/p&gt;\n    ","\n&lt;p&gt;Singleton is a pattern and can be used or abused just like any other tool.&lt;/p&gt;\n\n&lt;p&gt;The bad part of a singleton is generally the user (or should I say the inappropriate use of a singleton for things it is not designed to do). The biggest offender is using a singleton as a fake global variable.&lt;/p&gt;\n    ","\n&lt;p&gt;When you write code using singletons, say, a logger or a database connection, and afterwards you discover you need more than one log or more than one database, youre in trouble.&lt;/p&gt;\n\n&lt;p&gt;Singletons make it very hard to move from them to regular objects.&lt;/p&gt;\n\n&lt;p&gt;Also, its too easy to write a non-thread-safe singleton.&lt;/p&gt;\n\n&lt;p&gt;Rather than using singletons, you should pass all the needed utility objects from function to function. That can be simplified if you wrap all them into a helper object, like this:&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;void some_class::some_function(parameters, service_provider&amp;amp; srv)\n{\n    srv.get&amp;lt;error_logger&amp;gt;().log(&quot;Hi there!&quot;);\n    this-&amp;gt;another_function(some_other_parameters, srv);\n}\n&lt;/code&gt;&lt;/pre&gt;\n    ","\n&lt;p&gt;Too many people put objects which are not thread safe in a singleton pattern. I&apos;ve seen examples of a DataContext (&lt;a href=&quot;http://en.wikipedia.org/wiki/Language_Integrated_Query#LINQ_to_SQL_.28formerly_called_DLINQ.29&quot; rel=&quot;noreferrer&quot;&gt;LINQ&amp;nbsp;to&amp;nbsp;SQL&lt;/a&gt;) done in a singleton pattern, despite the fact that the DataContext is not thread safe and is purely a unit-of-work object.&lt;/p&gt;\n    ","\n&lt;p&gt;The problems with singletons is the issue of increased scope and therefore &lt;a href=&quot;https://en.wikipedia.org/wiki/Coupling_%28computer_programming%29&quot; rel=&quot;noreferrer&quot;&gt;coupling&lt;/a&gt;. There is no denying that there are some of situations where you do need access to a single instance, and it can be accomplished other ways.&lt;/p&gt;\n\n&lt;p&gt;I now prefer to design around an &lt;a href=&quot;http://en.wikipedia.org/wiki/Inversion_of_control&quot; rel=&quot;noreferrer&quot;&gt;inversion of control&lt;/a&gt; (IoC) container and allow the the lifetimes to be controlled by the container. This gives you the benefit of the classes that depend on the instance to be unaware of the fact that there is a single instance. The lifetime of the singleton can be changed in the future. Once such example I encountered recently was an easy adjustment from single threaded to multi-threaded.&lt;/p&gt;\n\n&lt;p&gt;FWIW, if it a PIA when you try to unit test it then it&apos;s going to PIA when you try to debug, bug fix or enhance it.&lt;/p&gt;\n    ","\n&lt;p&gt;Recent article on this subject by Chris Reath at &lt;a href=&quot;http://www.codingwithoutcomments.com/&quot; rel=&quot;noreferrer&quot;&gt;Coding Without Comments&lt;/a&gt;.&lt;/p&gt;\n\n&lt;p&gt;Note: Coding Without Comments is no longer valid.  However, The article being linked to has been cloned by another user.&lt;/p&gt;\n\n&lt;p&gt;&lt;a href=&quot;http://geekswithblogs.net/AngelEyes/archive/2013/09/08/singleton-i-love-you-but-youre-bringing-me-down-re-uploaded.aspx&quot; rel=&quot;noreferrer&quot;&gt;http://geekswithblogs.net/AngelEyes/archive/2013/09/08/singleton-i-love-you-but-youre-bringing-me-down-re-uploaded.aspx&lt;/a&gt;&lt;/p&gt;\n    ","\n&lt;p&gt;Singletons are NOT bad. It&apos;s only bad when you make something globally unique that isn&apos;t globally unique.&lt;/p&gt;\n\n&lt;p&gt;However, there are &quot;application scope services&quot; (think about a messaging system that makes components interact) - this CALLS for a singleton, a &quot;MessageQueue&quot; - class that has a method &quot;SendMessage(...)&quot;.&lt;/p&gt;\n\n&lt;p&gt;You can then do the following from all over the place:&lt;/p&gt;\n\n&lt;p&gt;MessageQueue.Current.SendMessage(new MailArrivedMessage(...));&lt;/p&gt;\n\n&lt;p&gt;And, of course, do:&lt;/p&gt;\n\n&lt;p&gt;MessageQueue.Current.RegisterReceiver(this);&lt;/p&gt;\n\n&lt;p&gt;in classes that implement IMessageReceiver.&lt;/p&gt;\n    ","\n&lt;p&gt;Here is one more thing about singletons which nobody said yet.&lt;/p&gt;\n\n&lt;p&gt;In most cases &quot;singletonity&quot; is a detail of implementation for some class rather than characteristic of its interface. Inversion of Control Container may hide this characteristic from class users; you just need to mark your class as a singleton (with &lt;code&gt;@Singleton&lt;/code&gt; annotation in Java for example) and that&apos;s it; IoCC will do the rest. You don&apos;t need to provide global access to your singleton instance because the access is already managed by IoCC. Thus there is nothing wrong with IoC Singletons.&lt;/p&gt;\n\n&lt;p&gt;GoF Singletons in opposite to IoC Singletons are supposed to expose &quot;singletonity&quot; in the interface through getInstance() method, and so that they suffer from everything said above.&lt;/p&gt;\n    ","\n&lt;p&gt;Because they are basically object oriented global variables, you can usually design your classes in such a way so that you don&apos;t need them.&lt;/p&gt;\n    ","\n&lt;p&gt;Singletons &lt;em&gt;aren&apos;t&lt;/em&gt; evil, if you use it &lt;em&gt;properly&lt;/em&gt; &amp;amp; &lt;em&gt;minimally&lt;/em&gt;. There are lot of other good design patterns which replaces the needs of singleton at some point (&amp;amp; also gives best results). But some programmers are unaware of those good patterns &amp;amp; uses the singleton for all the cases which makes the singleton evil for them.&lt;/p&gt;\n    ","\n&lt;p&gt;Firstly a class and its collaborators should firstly perform their intended purpose rather than focusing on dependents. Lifecycle management (when instances are created and when they go out of scope) should not be part of the classes responsibility. The accepted best practice for this is to craft or configure a new component to manage dependencies using dependency injection. &lt;/p&gt;\n\n&lt;p&gt;Often software gets more complicated it makes sense to have multiple independent instances of the Singleton class with different state. Committing code to simply grab the singleton is wrong in such cases. Using &lt;code&gt;Singleton.getInstance()&lt;/code&gt; might be ok for small simple systems but it doesn&apos;t work/scale when one might need a different instance of the same class.&lt;/p&gt;\n\n&lt;p&gt;No class should be thought of as a singleton but rather that should be an application of it&apos;s usage or how it is used to configure dependents. For a quick and nasty this does not matter - just luke hard coding say file paths does not matter but for bigger applications such dependencies need to be factored out and managed in more appropriate way using DI.&lt;/p&gt;\n\n&lt;p&gt;The problems that singleton cause in testing is a symptom of their hard coded single usage case/environment. The test suite and the many tests are each individual and separate something that is not compatible with hard coding a singleton.   &lt;/p&gt;\n    "]},"randomTags":[{"name":"python-3.6","slug":"python-3.6"},{"name":"file","slug":"file"},{"name":"shadowing","slug":"shadowing"},{"name":"duplicates","slug":"duplicates"},{"name":"stack","slug":"stack"},{"name":"split","slug":"split"},{"name":"viewmodel","slug":"viewmodel"},{"name":"opacity","slug":"opacity"},{"name":"threetenabp","slug":"threetenabp"},{"name":"android","slug":"android"},{"name":"dependent-name","slug":"dependent-name"},{"name":"list-comprehension","slug":"list-comprehension"},{"name":"google-chrome","slug":"google-chrome"},{"name":"matrix","slug":"matrix"},{"name":"chromium","slug":"chromium"},{"name":"git-commit","slug":"git-commit"},{"name":"pygame","slug":"pygame"},{"name":"q","slug":"q"},{"name":"form-submit","slug":"form-submit"},{"name":"properties","slug":"properties"}]},"__N_SSG":true}