{"pageProps":{"data":{"count":1,"rows":[{"id":129,"title":"What is array to pointer decay?","slug":"what-is-array-to-pointer-decay-1657384709608","postType":"QUESTION","createdAt":"2022-07-09T16:38:29.000Z","updatedAt":"2022-07-09T16:38:29.000Z","tags":[{"id":471,"name":"pointers","slug":"pointers","createdAt":"2022-07-09T16:38:29.000Z","updatedAt":"2022-07-09T16:38:29.000Z","Questions_Tags":{"questionId":129,"tagId":471}}]}]},"slug":"pointers","page":1,"answers":{"129":["\n&lt;p&gt;It&apos;s said that arrays &quot;decay&quot; into pointers.  A C++ array declared as &lt;code&gt;int numbers [5]&lt;/code&gt; cannot be re-pointed, i.e. you can&apos;t say &lt;code&gt;numbers = 0x5a5aff23&lt;/code&gt;. More importantly the term decay signifies loss of type and dimension; &lt;code&gt;numbers&lt;/code&gt; decay into &lt;code&gt;int*&lt;/code&gt; by losing the dimension information (count 5) and the type is not &lt;code&gt;int [5]&lt;/code&gt; any more. Look here for &lt;a href=&quot;https://stackoverflow.com/questions/17752978/exception-to-array-not-decaying-into-a-pointer&quot;&gt;cases where the decay doesn&apos;t happen&lt;/a&gt;.&lt;/p&gt;\n\n&lt;p&gt;If you&apos;re passing an array by value, what you&apos;re really doing is copying a pointer - a pointer to the array&apos;s first element is copied to the parameter (whose type should also be a pointer the array element&apos;s type). This works due to array&apos;s decaying nature; once decayed, &lt;code&gt;sizeof&lt;/code&gt; no longer gives the complete array&apos;s size, because it essentially becomes a pointer.  This is why it&apos;s preferred (among other reasons) to pass by reference or pointer.&lt;/p&gt;\n\n&lt;p&gt;Three ways to pass in an array&lt;sup&gt;1&lt;/sup&gt;:&lt;/p&gt;\n\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-php&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title function_ invoke__&quot;&gt;by_value&lt;/span&gt;(&lt;span class=&quot;hljs-keyword&quot;&gt;const&lt;/span&gt; T* &lt;span class=&quot;hljs-keyword&quot;&gt;array&lt;/span&gt;)   &lt;span class=&quot;hljs-comment&quot;&gt;// const T array[] means the same&lt;/span&gt;\n&lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title function_ invoke__&quot;&gt;by_pointer&lt;/span&gt;(&lt;span class=&quot;hljs-keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;hljs-title function_ invoke__&quot;&gt;T&lt;/span&gt; (*&lt;span class=&quot;hljs-keyword&quot;&gt;array&lt;/span&gt;)[U])\n&lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title function_ invoke__&quot;&gt;by_reference&lt;/span&gt;(&lt;span class=&quot;hljs-keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;hljs-title function_ invoke__&quot;&gt;T&lt;/span&gt; (&amp;amp;&lt;span class=&quot;hljs-keyword&quot;&gt;array&lt;/span&gt;)[U])\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;The last two will give proper &lt;code&gt;sizeof&lt;/code&gt; info, while the first one won&apos;t since the array argument has decayed to be assigned to the parameter.&lt;/p&gt;\n\n&lt;p&gt;&lt;sup&gt;1 The constant U should be known at compile-time.&lt;/sup&gt;&lt;/p&gt;\n    ","\n&lt;p&gt;Arrays are basically the same as pointers in C/C++, but not quite. Once you convert an array:&lt;/p&gt;\n\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-csharp&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;hljs-built_in&quot;&gt;int&lt;/span&gt; a[] = { &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;7&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;11&lt;/span&gt; };\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;into a pointer (which works without casting, and therefore can happen unexpectedly in some cases):&lt;/p&gt;\n\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-csharp&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;hljs-built_in&quot;&gt;int&lt;/span&gt;* p = a;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;you lose the ability of the &lt;code&gt;sizeof&lt;/code&gt; operator to count elements in the array:&lt;/p&gt;\n\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-csharp&quot;&gt;assert( &lt;span class=&quot;hljs-keyword&quot;&gt;sizeof&lt;/span&gt;(p) != &lt;span class=&quot;hljs-keyword&quot;&gt;sizeof&lt;/span&gt;(a) );  &lt;span class=&quot;hljs-comment&quot;&gt;// sizes are not equal&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;This lost ability is referred to as &quot;decay&quot;.&lt;/p&gt;\n\n&lt;p&gt;For more details, check out this &lt;a href=&quot;http://web.archive.org/web/20081208122434/http://www.transcendentaxis.com/dthompson/blog/archives/9&quot; rel=&quot;noreferrer&quot;&gt;article about array decay&lt;/a&gt;.&lt;/p&gt;\n    ","\n&lt;p&gt;Here&apos;s what the standard says (C99 6.3.2.1/3 - Other operands - Lvalues, arrays, and function designators):&lt;/p&gt;\n\n&lt;blockquote&gt;\n  &lt;p&gt;Except when it is the operand of the sizeof operator or the unary &amp;amp; operator, or is a\n  string literal used to initialize an array, an expression that has type array of type is\n  converted to an expression with type pointer to type that points to the initial element of\n  the array object and is not an lvalue.&lt;/p&gt;\n&lt;/blockquote&gt;\n\n&lt;p&gt;This means that pretty much anytime the array name is used in an expression, it is automatically converted to a pointer to the 1st item in the array.&lt;/p&gt;\n\n&lt;p&gt;Note that function names act in a similar way, but function pointers are used far less and in a much more specialized way that it doesn&apos;t cause nearly as much confusion as the automatic conversion of array names to pointers.&lt;/p&gt;\n\n&lt;p&gt;The C++ standard (4.2 Array-to-pointer conversion) loosens the conversion requirement to (emphasis mine):&lt;/p&gt;\n\n&lt;blockquote&gt;\n  &lt;p&gt;An lvalue or rvalue of type array of N T or array of unknown bound of T &lt;strong&gt;can&lt;/strong&gt; be converted to an rvalue\n  of type pointer to T.&lt;/p&gt;\n&lt;/blockquote&gt;\n\n&lt;p&gt;So the conversion doesn&apos;t &lt;em&gt;have&lt;/em&gt; to happen like it pretty much always does in C (this lets functions overload or templates match on the array type).&lt;/p&gt;\n\n&lt;p&gt;This is also why in C you should avoid using array parameters in function prototypes/definitions (in my opinion - I&apos;m not sure if there&apos;s any general agreement).  They cause confusion and are a fiction anyway - use pointer parameters and the confusion might not go away entirely, but at least the parameter declaration isn&apos;t lying.&lt;/p&gt;\n    ","\n&lt;p&gt;&quot;Decay&quot; refers to the implicit conversion of an expression from an array type to a pointer type.  In most contexts, when the compiler sees an array expression it converts the type of the expression from &quot;N-element array of T&quot; to &quot;pointer to T&quot; and sets the value of the expression to the address of the first element of the array.  The exceptions to this rule are when an array is an operand of either the &lt;code&gt;sizeof&lt;/code&gt; or &lt;code&gt;&amp;amp;&lt;/code&gt; operators, or the array is a string literal being used as an initializer in a declaration.&lt;/p&gt;\n&lt;p&gt;Assume the following code:&lt;/p&gt;\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-css&quot;&gt;char &lt;span class=&quot;hljs-selector-tag&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;hljs-selector-attr&quot;&gt;[80]&lt;/span&gt;;\nstrcpy(&lt;span class=&quot;hljs-selector-tag&quot;&gt;a&lt;/span&gt;, &quot;This is &lt;span class=&quot;hljs-selector-tag&quot;&gt;a&lt;/span&gt; test&quot;);\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;The expression &lt;code&gt;a&lt;/code&gt; is of type &quot;80-element array of char&quot; and the expression &quot;This is a test&quot; is of type &quot;15-element array of char&quot; (in C; in C++ string literals are arrays of const char).  However, in the call to &lt;code&gt;strcpy()&lt;/code&gt;, neither expression is an operand of &lt;code&gt;sizeof&lt;/code&gt; or &lt;code&gt;&amp;amp;&lt;/code&gt;, so their types are implicitly converted to &quot;pointer to char&quot;, and their values are set to the address of the first element in each.  What &lt;code&gt;strcpy()&lt;/code&gt; receives are not arrays, but pointers, as seen in its prototype:&lt;/p&gt;\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;char&lt;/span&gt; *&lt;span class=&quot;hljs-title&quot;&gt;strcpy&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-type&quot;&gt;char&lt;/span&gt; *dest, &lt;span class=&quot;hljs-type&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;char&lt;/span&gt; *src)&lt;/span&gt;&lt;/span&gt;;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;This is not the same thing as an array pointer.  For example:&lt;/p&gt;\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-csharp&quot;&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;char&lt;/span&gt; a[&lt;span class=&quot;hljs-number&quot;&gt;80&lt;/span&gt;];\n&lt;span class=&quot;hljs-built_in&quot;&gt;char&lt;/span&gt; *ptr_to_first_element = a;\n&lt;span class=&quot;hljs-built_in&quot;&gt;char&lt;/span&gt; (*ptr_to_array)[&lt;span class=&quot;hljs-number&quot;&gt;80&lt;/span&gt;] = &amp;amp;a;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;Both &lt;code&gt;ptr_to_first_element&lt;/code&gt; and &lt;code&gt;ptr_to_array&lt;/code&gt; have the same &lt;em&gt;value&lt;/em&gt;; the base address of a.  However, they are different types and are treated differently, as shown below:&lt;/p&gt;\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-yaml&quot;&gt;&lt;span class=&quot;hljs-string&quot;&gt;a[i]&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;ptr_to_first_element[i]&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;(*ptr_to_array)[i]&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;*ptr_to_array[i]&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;ptr_to_array[i]&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;Remember that the expression &lt;code&gt;a[i]&lt;/code&gt; is interpreted as &lt;code&gt;*(a+i)&lt;/code&gt; (which only works if the array type is converted to a pointer type), so both &lt;code&gt;a[i]&lt;/code&gt; and &lt;code&gt;ptr_to_first_element[i]&lt;/code&gt; work the same. The expression &lt;code&gt;(*ptr_to_array)[i]&lt;/code&gt; is interpreted as &lt;code&gt;*(*a+i)&lt;/code&gt;.  The expressions &lt;code&gt;*ptr_to_array[i]&lt;/code&gt; and &lt;code&gt;ptr_to_array[i]&lt;/code&gt; may lead to compiler warnings or errors depending on the context; they&apos;ll definitely do the wrong thing if you&apos;re expecting them to evaluate to &lt;code&gt;a[i]&lt;/code&gt;.&lt;/p&gt;\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-csharp&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;sizeof&lt;/span&gt; a == &lt;span class=&quot;hljs-keyword&quot;&gt;sizeof&lt;/span&gt; *ptr_to_array == &lt;span class=&quot;hljs-number&quot;&gt;80&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;Again, when an array is an operand of &lt;code&gt;sizeof&lt;/code&gt;, it&apos;s not converted to a pointer type.&lt;/p&gt;\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-csharp&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;sizeof&lt;/span&gt; *ptr_to_first_element == &lt;span class=&quot;hljs-keyword&quot;&gt;sizeof&lt;/span&gt; (&lt;span class=&quot;hljs-built_in&quot;&gt;char&lt;/span&gt;) == &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;\n&lt;span class=&quot;hljs-keyword&quot;&gt;sizeof&lt;/span&gt; ptr_to_first_element == &lt;span class=&quot;hljs-keyword&quot;&gt;sizeof&lt;/span&gt; (&lt;span class=&quot;hljs-built_in&quot;&gt;char&lt;/span&gt; *) == whatever the pointer size\n                                                  &lt;span class=&quot;hljs-keyword&quot;&gt;is&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;on&lt;/span&gt; your platform\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;&lt;code&gt;ptr_to_first_element&lt;/code&gt; is a simple pointer to char.&lt;/p&gt;\n    ","\n&lt;p&gt;&lt;b&gt;Arrays, in C, have no value.&lt;/b&gt;&lt;/p&gt;\n\n&lt;p&gt;Wherever the value of an object is expected but the object is an array, the address of its first element is used instead, with type &lt;code&gt;pointer to (type of array elements)&lt;/code&gt;.&lt;/p&gt;\n\n&lt;p&gt;In a function, all parameters are passed by value (arrays are no exception). When you pass an array in a function it &quot;decays into a pointer&quot; (sic); when you compare an array to something else, again it &quot;decays into a pointer&quot; (sic); ...&lt;/p&gt;\n\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-csharp&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;foo&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;int&lt;/span&gt; arr[]&lt;/span&gt;)&lt;/span&gt;;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Function foo expects the value of an array. But, in C, arrays have no value! So &lt;code&gt;foo&lt;/code&gt; gets instead the address of the first element of the array.&lt;/p&gt;\n\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-csharp&quot;&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;int&lt;/span&gt; arr[&lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt;];\n&lt;span class=&quot;hljs-built_in&quot;&gt;int&lt;/span&gt; *ip = &amp;amp;(arr[&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;]);\n&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (arr == ip) { &lt;span class=&quot;hljs-comment&quot;&gt;/* something; */&lt;/span&gt; }\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;In the comparison above, &lt;code&gt;arr&lt;/code&gt; has no value, so it becomes a pointer. It becomes a pointer to int. That pointer can be compared with the variable &lt;code&gt;ip&lt;/code&gt;.&lt;/p&gt;\n\n&lt;p&gt;In the array indexing syntax you are used to seeing, again, the arr is &apos;decayed to a pointer&apos;&lt;/p&gt;\n\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-css&quot;&gt;arr&lt;span class=&quot;hljs-selector-attr&quot;&gt;[42]&lt;/span&gt;;\n&lt;span class=&quot;hljs-comment&quot;&gt;/* same as *(arr + 42); */&lt;/span&gt;\n&lt;span class=&quot;hljs-comment&quot;&gt;/* same as *(&amp;amp;(arr[0]) + 42); */&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;The only times an array doesn&apos;t decay into a pointer are when it is the operand of the sizeof operator, or the &amp;amp; operator (the &apos;address of&apos; operator), or as a string literal used to initialize a character array.&lt;/p&gt;\n    ","\n&lt;p&gt;It&apos;s when array rots and is being pointed at ;-)&lt;/p&gt;\n\n&lt;p&gt;Actually, it&apos;s just that if you want to pass an array somewhere, but the pointer is passed instead (because who the hell would pass the whole array for you), people say that poor array decayed to pointer.&lt;/p&gt;\n    ","\n&lt;p&gt;Array decaying means that, when an array is passed as a parameter to a function, it&apos;s treated identically to (&quot;decays to&quot;) a pointer.&lt;/p&gt;\n\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-scss&quot;&gt;void &lt;span class=&quot;hljs-built_in&quot;&gt;do_something&lt;/span&gt;(int *array) {\n  &lt;span class=&quot;hljs-comment&quot;&gt;// We don&apos;t know how big array is here, because it&apos;s decayed to a pointer.&lt;/span&gt;\n  &lt;span class=&quot;hljs-built_in&quot;&gt;printf&lt;/span&gt;(&quot;%i\\n&quot;, sizeof(array));  &lt;span class=&quot;hljs-comment&quot;&gt;// always prints 4 on a 32-bit machine&lt;/span&gt;\n}\n\nint &lt;span class=&quot;hljs-selector-tag&quot;&gt;main&lt;/span&gt; (int argc, char **argv) {\n    int &lt;span class=&quot;hljs-selector-tag&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;hljs-selector-attr&quot;&gt;[10]&lt;/span&gt;;\n    int &lt;span class=&quot;hljs-selector-tag&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;hljs-selector-attr&quot;&gt;[20]&lt;/span&gt;;\n    int *c;\n    &lt;span class=&quot;hljs-built_in&quot;&gt;printf&lt;/span&gt;(&quot;%zu\\n&quot;, sizeof(a)); &lt;span class=&quot;hljs-comment&quot;&gt;//prints 40 on a 32-bit machine&lt;/span&gt;\n    &lt;span class=&quot;hljs-built_in&quot;&gt;printf&lt;/span&gt;(&quot;%zu\\n&quot;, sizeof(b)); &lt;span class=&quot;hljs-comment&quot;&gt;//prints 80 on a 32-bit machine&lt;/span&gt;\n    &lt;span class=&quot;hljs-built_in&quot;&gt;printf&lt;/span&gt;(&quot;%zu\\n&quot;, sizeof(c)); &lt;span class=&quot;hljs-comment&quot;&gt;//prints 4 on a 32-bit machine&lt;/span&gt;\n    &lt;span class=&quot;hljs-built_in&quot;&gt;do_something&lt;/span&gt;(a);\n    &lt;span class=&quot;hljs-built_in&quot;&gt;do_something&lt;/span&gt;(b);\n    &lt;span class=&quot;hljs-built_in&quot;&gt;do_something&lt;/span&gt;(c);\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;There are two complications or exceptions to the above.&lt;/p&gt;\n\n&lt;p&gt;First, when dealing with multidimensional arrays in C and C++, only the first dimension is lost.  This is because arrays are layed out contiguously in memory, so the compiler must know all but the first dimension to be able to calculate offsets into that block of memory.&lt;/p&gt;\n\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-scss&quot;&gt;void &lt;span class=&quot;hljs-built_in&quot;&gt;do_something&lt;/span&gt;(int array[][&lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;])\n{\n    &lt;span class=&quot;hljs-comment&quot;&gt;// We don&apos;t know how big the first dimension is.&lt;/span&gt;\n}\n\nint &lt;span class=&quot;hljs-selector-tag&quot;&gt;main&lt;/span&gt;(int argc, char *argv[]) {\n    int &lt;span class=&quot;hljs-selector-tag&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;hljs-selector-attr&quot;&gt;[5]&lt;/span&gt;&lt;span class=&quot;hljs-selector-attr&quot;&gt;[10]&lt;/span&gt;;\n    int &lt;span class=&quot;hljs-selector-tag&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;hljs-selector-attr&quot;&gt;[20]&lt;/span&gt;&lt;span class=&quot;hljs-selector-attr&quot;&gt;[10]&lt;/span&gt;;\n    &lt;span class=&quot;hljs-built_in&quot;&gt;do_something&lt;/span&gt;(a);\n    &lt;span class=&quot;hljs-built_in&quot;&gt;do_something&lt;/span&gt;(b);\n    return &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;;\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Second, in C++, you can use templates to deduce the size of arrays.  Microsoft uses this for the C++ versions of Secure CRT functions like &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/td1esda9%28VS.80%29.aspx&quot; rel=&quot;nofollow noreferrer&quot;&gt;strcpy_s&lt;/a&gt;, and you can use a similar trick to reliably &lt;a href=&quot;https://stackoverflow.com/questions/469696/what-is-your-most-useful-c-c-snippet/470221#470221&quot;&gt;get the number of elements in an array&lt;/a&gt;.&lt;/p&gt;\n    ","\n&lt;h3&gt;tl;dr: When you use an array you&apos;ve defined, you&apos;ll actually be using a pointer to its first element.&lt;/h3&gt;\n&lt;p&gt;Thus:&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;When you write &lt;code&gt;arr[idx]&lt;/code&gt; you&apos;re really just saying &lt;code&gt;*(arr + idx)&lt;/code&gt;.&lt;/li&gt;\n&lt;li&gt;functions never really take arrays as parameters, only pointers - either directly, when you specify an array parameter, or indirectly, if you pass a reference to an array.&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;Sort-of exceptions to this rule:&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;You can pass fixed-length arrays to functions within a &lt;code&gt;struct&lt;/code&gt;.&lt;/li&gt;\n&lt;li&gt;&lt;code&gt;sizeof()&lt;/code&gt; gives the size taken up by the array, not the size of a pointer.&lt;/li&gt;\n&lt;/ul&gt;\n    ","\n&lt;p&gt;Arrays are automatically passed by pointer in C. &lt;a href=&quot;https://stackoverflow.com/a/671348/7194773&quot;&gt;The rationale behind it can only be speculated&lt;/a&gt;.&lt;/p&gt;\n&lt;p&gt;&lt;code&gt;int a[5]&lt;/code&gt;, &lt;code&gt;int *a&lt;/code&gt; and &lt;code&gt;int (*a)[5]&lt;/code&gt; are all glorified addresses meaning that the compiler treats arithmetic and deference operators on them differently depending on the type, so when they refer to the same address they are not treated the same by the compiler. &lt;code&gt;int a[5]&lt;/code&gt; is different to the other 2 in that the address is implicit and does not manifest on the stack or the executable as part of the array itself, it is only used by the compiler to resolve certain arithmetic operations, like taking its address or pointer arithmetic. &lt;code&gt;int a[5]&lt;/code&gt; is therefore an array as well as an implicit address, but as soon as you talk about the address itself and place it on the stack, the address itself is no longer an array, and can only be a pointer to an array or a decayed array i.e. a pointer to the first member of the array.&lt;/p&gt;\n&lt;p&gt;For instance, on &lt;code&gt;int (*a)[5]&lt;/code&gt;, the first dereference on &lt;code&gt;a&lt;/code&gt; will produce an &lt;code&gt;int *&lt;/code&gt; (so the same address, just a different type, and note not &lt;code&gt;int a[5]&lt;/code&gt;), and pointer arithmetic on &lt;code&gt;a&lt;/code&gt; i.e. &lt;code&gt;a+1&lt;/code&gt; or &lt;code&gt;*(a+1)&lt;/code&gt; will be in terms of the size of an array of 5 ints (which is the data type it points to), and the second dereference will produce the &lt;code&gt;int&lt;/code&gt;. On &lt;code&gt;int a[5]&lt;/code&gt; however, the first dereference will produce the &lt;code&gt;int&lt;/code&gt; and the pointer arithmetic will be in terms of the size of an &lt;code&gt;int&lt;/code&gt;.&lt;/p&gt;\n&lt;p&gt;To a function, you can only pass &lt;code&gt;int *&lt;/code&gt; and &lt;code&gt;int (*)[5]&lt;/code&gt;, and the function casts it to whatever the parameter type is, so within the function you have a choice whether to treat an address that is being passed as a decayed array or a pointer to an array (where the function has to specify the size of the array being passed). If you pass &lt;code&gt;a&lt;/code&gt; to a function and &lt;code&gt;a&lt;/code&gt; is defined &lt;code&gt;int a[5]&lt;/code&gt;, then as &lt;code&gt;a&lt;/code&gt; resolves to an address, you are passing an address, and an address can only be a pointer type. In the function, the parameter it accesses is then an address on the stack or in a register, which can only be a pointer type and not an array type -- this is because it&apos;s an actual address on the stack and is therefore clearly not the array itself.&lt;/p&gt;\n&lt;p&gt;You lose the size of the array because the type of the parameter, being an address, is a pointer and not an array, which does not have an array size, as can be seen when using &lt;code&gt;sizeof&lt;/code&gt;, which works on the type of the value being passed to it. The parameter type &lt;code&gt;int a[5]&lt;/code&gt; instead of &lt;code&gt;int *a&lt;/code&gt; is allowed but is treated as &lt;code&gt;int *&lt;/code&gt; instead of disallowing it outright, though it should be disallowed, because it is misleading, because it makes you think that the size information can be used, but you can only do this by casting it to &lt;code&gt;int (*a)[5]&lt;/code&gt;, and of course, the function has to specify the size of the array because there is no way to pass the size of the array because the size of the array needs to be a compile-time constant.&lt;/p&gt;\n    ","\n&lt;p&gt;I might be so bold to think there are four (4) ways to pass an array as the function argument. Also here is the short but working code for your perusal.&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&amp;lt;string&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&amp;lt;vector&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&amp;lt;cassert&amp;gt;&lt;/span&gt;&lt;/span&gt;\n\n&lt;span class=&quot;hljs-keyword&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;namespace&lt;/span&gt; std;\n\n&lt;span class=&quot;hljs-comment&quot;&gt;// test data&lt;/span&gt;\n&lt;span class=&quot;hljs-comment&quot;&gt;// notice native array init with no copy aka &quot;=&quot;&lt;/span&gt;\n&lt;span class=&quot;hljs-comment&quot;&gt;// not possible in C&lt;/span&gt;\n &lt;span class=&quot;hljs-type&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;char&lt;/span&gt;* specimen[]{ __TIME__, __DATE__, __TIMESTAMP__ };\n\n&lt;span class=&quot;hljs-comment&quot;&gt;// ONE&lt;/span&gt;\n&lt;span class=&quot;hljs-comment&quot;&gt;// simple, dangerous and useless&lt;/span&gt;\n&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;template&lt;/span&gt;&amp;lt;&lt;span class=&quot;hljs-keyword&quot;&gt;typename&lt;/span&gt; T&amp;gt;\n&lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;as_pointer&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-type&quot;&gt;const&lt;/span&gt; T* array)&lt;/span&gt; &lt;/span&gt;{ \n    &lt;span class=&quot;hljs-comment&quot;&gt;// a pointer&lt;/span&gt;\n    &lt;span class=&quot;hljs-built_in&quot;&gt;assert&lt;/span&gt;(array != &lt;span class=&quot;hljs-literal&quot;&gt;nullptr&lt;/span&gt;); \n} ;\n\n&lt;span class=&quot;hljs-comment&quot;&gt;// TWO&lt;/span&gt;\n&lt;span class=&quot;hljs-comment&quot;&gt;// for above const T array[] means the same&lt;/span&gt;\n&lt;span class=&quot;hljs-comment&quot;&gt;// but and also , minimum array size indication might be given too&lt;/span&gt;\n&lt;span class=&quot;hljs-comment&quot;&gt;// this also does not stop the array decay into T *&lt;/span&gt;\n&lt;span class=&quot;hljs-comment&quot;&gt;// thus size information is lost&lt;/span&gt;\n&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;template&lt;/span&gt;&amp;lt;&lt;span class=&quot;hljs-keyword&quot;&gt;typename&lt;/span&gt; T&amp;gt;\n&lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;by_value_no_size&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-type&quot;&gt;const&lt;/span&gt; T array[&lt;span class=&quot;hljs-number&quot;&gt;0xFF&lt;/span&gt;])&lt;/span&gt; &lt;/span&gt;{ \n    &lt;span class=&quot;hljs-comment&quot;&gt;// decayed to a pointer&lt;/span&gt;\n    &lt;span class=&quot;hljs-built_in&quot;&gt;assert&lt;/span&gt;( array != &lt;span class=&quot;hljs-literal&quot;&gt;nullptr&lt;/span&gt; ); \n}\n\n&lt;span class=&quot;hljs-comment&quot;&gt;// THREE&lt;/span&gt;\n&lt;span class=&quot;hljs-comment&quot;&gt;// size information is preserved&lt;/span&gt;\n&lt;span class=&quot;hljs-comment&quot;&gt;// but pointer is asked for&lt;/span&gt;\n&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;template&lt;/span&gt;&amp;lt;&lt;span class=&quot;hljs-keyword&quot;&gt;typename&lt;/span&gt; T, &lt;span class=&quot;hljs-type&quot;&gt;size_t&lt;/span&gt; N&amp;gt;\n&lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;pointer_to_array&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-type&quot;&gt;const&lt;/span&gt; T (*array)[N])&lt;/span&gt;\n&lt;/span&gt;{\n   &lt;span class=&quot;hljs-comment&quot;&gt;// dealing with native pointer &lt;/span&gt;\n    &lt;span class=&quot;hljs-built_in&quot;&gt;assert&lt;/span&gt;( array != &lt;span class=&quot;hljs-literal&quot;&gt;nullptr&lt;/span&gt; ); \n}\n\n&lt;span class=&quot;hljs-comment&quot;&gt;// FOUR&lt;/span&gt;\n&lt;span class=&quot;hljs-comment&quot;&gt;// no C equivalent&lt;/span&gt;\n&lt;span class=&quot;hljs-comment&quot;&gt;// array by reference&lt;/span&gt;\n&lt;span class=&quot;hljs-comment&quot;&gt;// size is preserved&lt;/span&gt;\n&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;template&lt;/span&gt;&amp;lt;&lt;span class=&quot;hljs-keyword&quot;&gt;typename&lt;/span&gt; T, &lt;span class=&quot;hljs-type&quot;&gt;size_t&lt;/span&gt; N&amp;gt;\n&lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;reference_to_array&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-type&quot;&gt;const&lt;/span&gt; T (&amp;amp;array)[N])&lt;/span&gt;\n&lt;/span&gt;{\n    &lt;span class=&quot;hljs-comment&quot;&gt;// array is not a pointer here&lt;/span&gt;\n    &lt;span class=&quot;hljs-comment&quot;&gt;// it is (almost) a container&lt;/span&gt;\n    &lt;span class=&quot;hljs-comment&quot;&gt;// most of the std:: lib algorithms &lt;/span&gt;\n    &lt;span class=&quot;hljs-comment&quot;&gt;// do work on array reference, for example&lt;/span&gt;\n    &lt;span class=&quot;hljs-comment&quot;&gt;// range for requires std::begin() and std::end()&lt;/span&gt;\n    &lt;span class=&quot;hljs-comment&quot;&gt;// on the type passed as range to iterate over&lt;/span&gt;\n    &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;hljs-keyword&quot;&gt;auto&lt;/span&gt; &amp;amp;&amp;amp; elem : array )\n    {\n        cout &amp;lt;&amp;lt; endl &amp;lt;&amp;lt; elem ;\n    }\n}\n\n&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt;\n&lt;/span&gt;{\n     &lt;span class=&quot;hljs-comment&quot;&gt;// ONE&lt;/span&gt;\n     &lt;span class=&quot;hljs-built_in&quot;&gt;as_pointer&lt;/span&gt;(specimen);\n     &lt;span class=&quot;hljs-comment&quot;&gt;// TWO&lt;/span&gt;\n     &lt;span class=&quot;hljs-built_in&quot;&gt;by_value_no_size&lt;/span&gt;(specimen);\n     &lt;span class=&quot;hljs-comment&quot;&gt;// THREE&lt;/span&gt;\n     &lt;span class=&quot;hljs-built_in&quot;&gt;pointer_to_array&lt;/span&gt;(&amp;amp;specimen);\n     &lt;span class=&quot;hljs-comment&quot;&gt;// FOUR&lt;/span&gt;\n     &lt;span class=&quot;hljs-built_in&quot;&gt;reference_to_array&lt;/span&gt;( specimen ) ;\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;I might also think this shows the superiority of C++ vs C. At least in reference (pun intended) of passing an array by reference.&lt;/p&gt;\n\n&lt;p&gt;Of course there are extremely strict projects with no heap allocation, no exceptions and no std:: lib. C++ native array handling is mission critical language feature, one might say.&lt;/p&gt;\n    ","\n&lt;p&gt;Try this code&lt;/p&gt;\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-csharp&quot;&gt;\n&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;f&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;double&lt;/span&gt; a[&lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;]&lt;/span&gt;)&lt;/span&gt; {\n    printf(&lt;span class=&quot;hljs-string&quot;&gt;&quot;in function: %d&quot;&lt;/span&gt;, &lt;span class=&quot;hljs-keyword&quot;&gt;sizeof&lt;/span&gt;(a));\n    printf(&lt;span class=&quot;hljs-string&quot;&gt;&quot;pointer size: %d\\n&quot;&lt;/span&gt;, &lt;span class=&quot;hljs-keyword&quot;&gt;sizeof&lt;/span&gt;(&lt;span class=&quot;hljs-built_in&quot;&gt;double&lt;/span&gt; *));\n}\n\n&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;main&lt;/span&gt;()&lt;/span&gt; {\n    &lt;span class=&quot;hljs-built_in&quot;&gt;double&lt;/span&gt; a[&lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;];\n    printf(&lt;span class=&quot;hljs-string&quot;&gt;&quot;in main: %d&quot;&lt;/span&gt;, &lt;span class=&quot;hljs-keyword&quot;&gt;sizeof&lt;/span&gt;(a));\n    f(a);\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;and you will see that the size of the array inside the function is not equal to the size of the array in main, but it is equal to the size of a pointer.&lt;/p&gt;\n&lt;p&gt;You probably heard that &quot;arrays are pointers&quot;, but, this is not exactly true (the &lt;code&gt;sizeof&lt;/code&gt; inside &lt;code&gt;main&lt;/code&gt; prints the correct size). However, when passed, the array &lt;em&gt;decays&lt;/em&gt; to pointer. That is, regardless of what the syntax shows, you actually pass a pointer, and the function actually receives a pointer.&lt;/p&gt;\n&lt;p&gt;In this case, the definition &lt;code&gt;void f(double a[10]&lt;/code&gt; is implicitly transformed by the compiler to &lt;code&gt;void f(double *a)&lt;/code&gt;. You could have equivalently declared the function argument directly as &lt;code&gt;*a&lt;/code&gt;. You could have even written &lt;code&gt;a[100]&lt;/code&gt; or &lt;code&gt;a[1]&lt;/code&gt;, instead of &lt;code&gt;a[10]&lt;/code&gt;, since it is never actually compiled that way (however, you shouldn&apos;t do it obviously, it would confuse the reader).&lt;/p&gt;\n    "]},"randomTags":[{"name":"python-packaging","slug":"python-packaging"},{"name":"format","slug":"format"},{"name":"jtable","slug":"jtable"},{"name":"pageload","slug":"pageload"},{"name":"for-loop","slug":"for-loop"},{"name":"constructor","slug":"constructor"},{"name":"file","slug":"file"},{"name":"c89","slug":"c89"},{"name":"query-string","slug":"query-string"},{"name":"asp.net-mvc","slug":"asp.net-mvc"},{"name":"xml-parsing","slug":"xml-parsing"},{"name":"winforms","slug":"winforms"},{"name":"user-interface","slug":"user-interface"},{"name":"require","slug":"require"},{"name":"repr","slug":"repr"},{"name":"node.js","slug":"node.js"},{"name":"function","slug":"function"},{"name":"undefined-behavior","slug":"undefined-behavior"},{"name":"dependency-injection","slug":"dependency-injection"},{"name":"haversine","slug":"haversine"}]},"__N_SSG":true}