{"pageProps":{"data":{"count":1,"rows":[{"id":357,"title":"Correctly allocating multi-dimensional arrays","slug":"correctly-allocating-multi-dimensional-arrays-1657387733756","postType":"QUESTION","createdAt":"2022-07-09T17:28:53.000Z","updatedAt":"2022-07-09T17:28:53.000Z","tags":[{"id":1996,"name":"dynamic-arrays","slug":"dynamic-arrays","createdAt":"2022-07-09T17:28:53.000Z","updatedAt":"2022-07-09T17:28:53.000Z","Questions_Tags":{"questionId":357,"tagId":1996}}]}]},"slug":"dynamic-arrays","page":1,"answers":{"357":["\n&lt;p&gt;In order to answer the question, we should first clear up some concepts. What is an array and how can it be used? And what is the code in the question, if not an array?&lt;/p&gt;\n\n&lt;hr&gt;\n\n&lt;p&gt;&lt;strong&gt;What is an array?&lt;/strong&gt;&lt;/p&gt;\n\n&lt;p&gt;The formal definition of an array is found in the C standard, &lt;em&gt;ISO 9899:2011 6.2.5/20 Types&lt;/em&gt;.&lt;/p&gt;\n\n&lt;blockquote&gt;\n  &lt;p&gt;An array type describes a contiguously allocated non-empty set of\n  objects with a particular member object type, called the element type.&lt;/p&gt;\n&lt;/blockquote&gt;\n\n&lt;p&gt;In plain English, an array is a collection of items of the same type allocated contiguously, in adjacent memory cells. &lt;/p&gt;\n\n&lt;p&gt;For example an array of 3 integers &lt;code&gt;int arr[3] = {1,2,3};&lt;/code&gt; would be allocated in memory like this:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;+-------+-------+-------+\n|       |       |       |\n|   &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;   |   &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;   |   &lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;   |\n|       |       |       |\n+-------+-------+-------+\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;So what about the formal definition of a multi-dimensional array? Actually, it is the very same definition as cited above. It applies recursively. &lt;/p&gt;\n\n&lt;p&gt;If we would allocate a 2D array, &lt;code&gt;int arr[2][3] = { {1,2,3}, {1,2,3} };&lt;/code&gt; it would get allocated in memory like this:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;+-------+-------+-------+-------+-------+-------+\n|       |       |       |       |       |       |\n|   &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;   |   &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;   |   &lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;   |   &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;   |   &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;   |   &lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;   |\n|       |       |       |       |       |       |\n+-------+-------+-------+-------+-------+-------+\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;What we have in this example is actually an array of arrays. An array which has 2 items, each of them an array of 3 integers. &lt;/p&gt;\n\n&lt;hr&gt;\n\n&lt;p&gt;&lt;strong&gt;An array is a type like any other&lt;/strong&gt;&lt;/p&gt;\n\n&lt;p&gt;Arrays in C often follow the same type system as regular variables. As shown above, you can have an array of arrays, like you can have an array of any other type. &lt;/p&gt;\n\n&lt;p&gt;You can also apply the same kind of pointer arithmetic on &lt;em&gt;n&lt;/em&gt;-dimensional arrays as on plain one-dimensional arrays. With a regular one-dimensional arrays, applying pointer arithmetic should be trivial:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; arr[&lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;] = {&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;};\n&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt;* ptr = arr; &lt;span class=&quot;hljs-comment&quot;&gt;// integer pointer to the first element.&lt;/span&gt;\n\n&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;hljs-type&quot;&gt;size_t&lt;/span&gt; i=&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;; i&amp;lt;&lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;; i++)\n{\n  &lt;span class=&quot;hljs-built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;%d &quot;&lt;/span&gt;, *ptr); &lt;span class=&quot;hljs-comment&quot;&gt;// print contents.&lt;/span&gt;\n  ptr++; &lt;span class=&quot;hljs-comment&quot;&gt;// set pointer to point at the next element.&lt;/span&gt;\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;This was made possible through &quot;array decay&quot;. When &lt;code&gt;arr&lt;/code&gt; was used inside an expression, it &quot;decayed&quot; into a pointer to the first element.&lt;/p&gt;\n\n&lt;p&gt;Similarly, we can use the very same kind of pointer arithmetic to iterate through an array of arrays, by using an &lt;em&gt;array pointer&lt;/em&gt;:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; arr[&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;][&lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;] = { {&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;}, {&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;} };\n&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; (*ptr)[&lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;] = arr; &lt;span class=&quot;hljs-comment&quot;&gt;// int array pointer to the first element, which is an int[3] array.&lt;/span&gt;\n\n&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;hljs-type&quot;&gt;size_t&lt;/span&gt; i=&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;; i&amp;lt;&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;; i++)\n{\n  &lt;span class=&quot;hljs-built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;%d %d %d\\n&quot;&lt;/span&gt;, (*ptr)[&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;], (*ptr)[&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;], (*ptr)[&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;]); &lt;span class=&quot;hljs-comment&quot;&gt;// print contents&lt;/span&gt;\n  ptr++; &lt;span class=&quot;hljs-comment&quot;&gt;// set pointer to point at the next element&lt;/span&gt;\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Again there was array decay. The variable &lt;code&gt;arr&lt;/code&gt; which was of type &lt;code&gt;int [2][3]&lt;/code&gt; decayed into a pointer to the first element. The first element was an &lt;code&gt;int [3]&lt;/code&gt; and a pointer to such an element is declared as &lt;code&gt;int(*)[3]&lt;/code&gt; - an array pointer.&lt;/p&gt;\n\n&lt;p&gt;Understanding array pointers and array decay is necessary in order to work with multi-dimensional arrays.&lt;/p&gt;\n\n&lt;hr&gt;\n\n&lt;p&gt;There are more cases where arrays behave just like regular variables. The &lt;code&gt;sizeof&lt;/code&gt; operator works just the same for (non-VLA) arrays as for regular variables. Examples for a 32 bit system:&lt;/p&gt;\n\n&lt;p&gt;&lt;code&gt;int x; printf(&quot;%zu&quot;, sizeof(x));&lt;/code&gt; prints &lt;code&gt;4&lt;/code&gt;.&lt;br&gt;\n&lt;code&gt;int arr[3] = {1,2,3}; printf(&quot;%zu&quot;, sizeof(arr));&lt;/code&gt; prints &lt;code&gt;12&lt;/code&gt; (3*4=12)&lt;br&gt;\n&lt;code&gt;int arr[2][3] = { {1,2,3}, {1,2,3} }; printf(&quot;%zu&quot;, sizeof(arr));&lt;/code&gt; prints &lt;code&gt;24&lt;/code&gt; (2*3*4=24)&lt;/p&gt;\n\n&lt;hr&gt;\n\n&lt;p&gt;Like any other type, arrays can be used with library functions and generic APIs. Since arrays fulfil the requirement of being allocated contiguously, we can for example safely copy them with &lt;code&gt;memcpy&lt;/code&gt;:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; arr_a[&lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;] = {&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;};\n&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; arr_b[&lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;];\n&lt;span class=&quot;hljs-built_in&quot;&gt;memcpy&lt;/span&gt;(arr_b, arr_a, &lt;span class=&quot;hljs-keyword&quot;&gt;sizeof&lt;/span&gt;(arr_a));\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Contiguous allocation is also the reason why other similar standard library functions like &lt;code&gt;memset&lt;/code&gt;, &lt;code&gt;strcpy&lt;/code&gt;, &lt;code&gt;bsearch&lt;/code&gt; and &lt;code&gt;qsort&lt;/code&gt; work. They are designed to work on arrays allocated contiguously. So if you have a multi-dimensional array, you can efficiently search it and sort it with &lt;code&gt;bsearch&lt;/code&gt; and &lt;code&gt;qsort&lt;/code&gt;, saving you the fuss of implementing binary search and quick sort yourself and thereby re-inventing the wheel for every project.&lt;/p&gt;\n\n&lt;p&gt;All of the above consistencies between arrays and other types is a very good thing that we want to take advantage of, particularly when doing generic programming.&lt;/p&gt;\n\n&lt;hr&gt;\n\n&lt;p&gt;&lt;strong&gt;What is the pointer-to-pointer thing, if not an array?&lt;/strong&gt;&lt;/p&gt;\n\n&lt;p&gt;Now to get back to the code in the question, which used a different syntax with a pointer-to-pointer. There is nothing mysterious about it. It is a pointer to pointer to type, no more no less. It is not an array. It is not a 2D array. Strictly speaking, it cannot be used to point at an array, nor can it be used to point at a 2D array.&lt;/p&gt;\n\n&lt;p&gt;A pointer-to-pointer can however be used to point at the first element of an array of pointers, instead of pointing at the array as whole. And that is how it is used in the question - as a way to &quot;emulate&quot; an array pointer. In the question, it is used to point at an array of 2 pointers. And then each of the 2 pointers is used to point at an array of 3 integers.&lt;/p&gt;\n\n&lt;p&gt;This is known as a look-up table, which is a kind of abstract data type (ADT), which is something different from the lower level concept of plain arrays. The main difference is how the look-up table is allocated:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;+------------+\n|            |\n| &lt;span class=&quot;hljs-number&quot;&gt;0x12340000&lt;/span&gt; |\n|            |\n+------------+\n      |\n      |\n      v\n+------------+     +-------+-------+-------+\n|            |     |       |       |       |\n| &lt;span class=&quot;hljs-number&quot;&gt;0x22223333&lt;/span&gt; |----&amp;gt;|   &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;   |   &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;   |   &lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;   |\n|            |     |       |       |       |\n+------------+     +-------+-------+-------+\n|            | \n| &lt;span class=&quot;hljs-number&quot;&gt;0xAAAABBBB&lt;/span&gt; |--+\n|            |  | \n+------------+  |  \n                |\n                |  +-------+-------+-------+\n                |  |       |       |       |\n                +-&amp;gt;|   &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;   |   &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;   |   &lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;   |\n                   |       |       |       |\n                   +-------+-------+-------+\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;The 32 bit addresses in this example are made-up. The &lt;code&gt;0x12340000&lt;/code&gt; box represents the pointer-to-pointer. It contains an address &lt;code&gt;0x12340000&lt;/code&gt; to the first item in an array of pointers. Each pointer in that array in turn, contains an address pointing at the first item in an array of integers. &lt;/p&gt;\n\n&lt;p&gt;And here is where the problems start.&lt;/p&gt;\n\n&lt;hr&gt;\n\n&lt;p&gt;&lt;strong&gt;Problems with the look-up table version&lt;/strong&gt;&lt;/p&gt;\n\n&lt;p&gt;The look-up table is scattered all over the heap memory. It is not contiguously allocated memory in adjacent cells, because each call to &lt;code&gt;malloc()&lt;/code&gt; gives a new memory area, not necessarily located adjacently to the others. This in turn gives us lots of problems:&lt;/p&gt;\n\n&lt;ul&gt;\n&lt;li&gt;&lt;p&gt;We can&apos;t use pointer arithmetic as expected. While we can use a form of pointer arithmetic to index and access the items in the look-up table, we can&apos;t do so using array pointers.&lt;/p&gt;&lt;/li&gt;\n&lt;li&gt;&lt;p&gt;We can&apos;t use the sizeof operator. Used on the pointer-to-pointer, it would give us the size of a pointer-to-pointer. Used to the first item pointed at, it would give us the size of a pointer. Neither of them is the size of an array.&lt;/p&gt;&lt;/li&gt;\n&lt;li&gt;&lt;p&gt;We can&apos;t use standard library functions that excepts an array type (&lt;code&gt;memcpy&lt;/code&gt;, &lt;code&gt;memset&lt;/code&gt;, &lt;code&gt;strcpy&lt;/code&gt;, &lt;code&gt;bsearch&lt;/code&gt;, &lt;code&gt;qsort&lt;/code&gt; and so on). All such functions assume to get arrays as input, with data allocated contiguously. Calling them with our look-up table as parameter would result in undefined behavior bugs, such as program crashes.&lt;/p&gt;&lt;/li&gt;\n&lt;li&gt;&lt;p&gt;Repeated calls of &lt;code&gt;malloc&lt;/code&gt; to allocate several segments leads to heap &lt;a href=&quot;https://stackoverflow.com/questions/3770457/what-is-memory-fragmentation&quot;&gt;fragmentation&lt;/a&gt;, which in turn results in poor use of RAM memory.&lt;/p&gt;&lt;/li&gt;\n&lt;li&gt;&lt;p&gt;Since the memory is scattered, the CPU cannot utilize cache memory when iterating through the look-up table. Efficient use of the data cache requires a contiguous chunk of memory which is iterated through from top to bottom. This means that the look-up table, by design, has significantly slower access time than a real multi-dimensional array. &lt;/p&gt;&lt;/li&gt;\n&lt;li&gt;&lt;p&gt;For each call to &lt;code&gt;malloc()&lt;/code&gt;, the library code managing the heap has to calculate where there is free space. Similarly for each call to &lt;code&gt;free()&lt;/code&gt;, there is overhead code which has to be executed. Therefore, as few calls to these functions as possible is often preferable, for the sake of performance.&lt;/p&gt;&lt;/li&gt;\n&lt;/ul&gt;\n\n&lt;hr&gt;\n\n&lt;p&gt;&lt;strong&gt;Are look-up tables all bad?&lt;/strong&gt;&lt;/p&gt;\n\n&lt;p&gt;As we can see, there are a lot of problems with pointer-based look-up tables. But they aren&apos;t all bad, it is a tool like any other. It just has to be used for the right purpose. If you are looking for a multi-dimensional array, which should be used as an array, look-up tables are clearly the wrong tool. But they can be used for other purposes.&lt;/p&gt;\n\n&lt;p&gt;A look-up table is the right choice when you need all dimensions to have completely variable sizes, individually. Such a container can be handy when for example creating a list of C strings. It is then often justified to take the above mentioned execution speed performance loss in order to save memory.&lt;/p&gt;\n\n&lt;p&gt;Also, the look-up table has the advantage that you can re-alloce parts of the table in run-time without the need to re-allocate a whole multi-dimensional array. If this is something that needs to be done frequently, the look-up table might even outperform the multi-dimensional array in terms of execution speed. For example, similar look-up tables can be used when implementing a chained hash table.&lt;/p&gt;\n\n&lt;hr&gt;\n\n&lt;p&gt;&lt;strong&gt;How to properly allocate a multi-dimensional array dynamically then?&lt;/strong&gt;&lt;/p&gt;\n\n&lt;p&gt;The easiest form in modern C is to simply use a variable-length array (VLA). &lt;code&gt;int array[x][y];&lt;/code&gt; where &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; are variables given values in run-time, prior array declaration. However, VLAs have local scope and do not persist throughout the duration of the program - they have automatic storage duration. So while VLAs may be convenient and fast to use for temporary arrays, it is not an universal replacement to the look-up table in the question.&lt;/p&gt;\n\n&lt;p&gt;To truly allocate a multi-dimensional array dynamically, so that it gets &lt;em&gt;allocated storage duration&lt;/em&gt;, we have to use &lt;code&gt;malloc()&lt;/code&gt;/&lt;code&gt;calloc()&lt;/code&gt;/&lt;code&gt;realloc()&lt;/code&gt;. I&apos;ll give   one example below.&lt;/p&gt;\n\n&lt;p&gt;In modern C, you would use array pointers to a VLA. You can use such pointers even when no actual VLA is present in the program. The benefit of using them over a plain &lt;code&gt;type*&lt;/code&gt; or a &lt;code&gt;void*&lt;/code&gt; is increased type-safety. Using a pointer to a VLA also allows you to pass the array dimensions as parameters to the function using the array, making it both variable and type safe at once.&lt;/p&gt;\n\n&lt;p&gt;Unfortunately, in order to use the benefits of having a pointer to VLA, we can&apos;t return that pointer as a function result. So if we need to return a pointer to the array to the caller, it must be passed as a parameter (for the reasons described in &lt;a href=&quot;https://stackoverflow.com/questions/39486797/dynamic-memory-access-only-works-inside-function&quot;&gt;Dynamic memory access only works inside function&lt;/a&gt;). This is fine practice in C, but makes the code a bit hard to read. It would look something like this:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;arr_alloc&lt;/span&gt; &lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-type&quot;&gt;size_t&lt;/span&gt; x, &lt;span class=&quot;hljs-type&quot;&gt;size_t&lt;/span&gt; y, &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt;(**aptr)[x][y])&lt;/span&gt;\n{\n  *aptr = &lt;span class=&quot;hljs-built_in&quot;&gt;malloc&lt;/span&gt;( &lt;span class=&quot;hljs-keyword&quot;&gt;sizeof&lt;/span&gt;(&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt;[x][y]) ); &lt;span class=&quot;hljs-comment&quot;&gt;// allocate a true 2D array&lt;/span&gt;\n  assert(*aptr != &lt;span class=&quot;hljs-literal&quot;&gt;NULL&lt;/span&gt;);\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;While this syntax with &lt;em&gt;a pointer to an array pointer&lt;/em&gt; might look a bit strange and intimidating, it doesn&apos;t get more complex than this even if we add more dimensions:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;arr_alloc&lt;/span&gt; &lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-type&quot;&gt;size_t&lt;/span&gt; x, &lt;span class=&quot;hljs-type&quot;&gt;size_t&lt;/span&gt; y, &lt;span class=&quot;hljs-type&quot;&gt;size_t&lt;/span&gt; z, &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt;(**aptr)[x][y][z])&lt;/span&gt;\n{\n  *aptr = &lt;span class=&quot;hljs-built_in&quot;&gt;malloc&lt;/span&gt;( &lt;span class=&quot;hljs-keyword&quot;&gt;sizeof&lt;/span&gt;(&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt;[x][y][z]) ); &lt;span class=&quot;hljs-comment&quot;&gt;// allocate a true 3D array&lt;/span&gt;\n  assert(*aptr != &lt;span class=&quot;hljs-literal&quot;&gt;NULL&lt;/span&gt;);\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Now compare that code with the code for adding one more dimension to the look-up table version:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;&lt;span class=&quot;hljs-comment&quot;&gt;/* Bad. Don&apos;t write code like this! */&lt;/span&gt;\n&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt;*** &lt;span class=&quot;hljs-title function_&quot;&gt;arr_alloc&lt;/span&gt; &lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-type&quot;&gt;size_t&lt;/span&gt; x, &lt;span class=&quot;hljs-type&quot;&gt;size_t&lt;/span&gt; y, &lt;span class=&quot;hljs-type&quot;&gt;size_t&lt;/span&gt; z)&lt;/span&gt;\n{\n  &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt;*** ppp = &lt;span class=&quot;hljs-built_in&quot;&gt;malloc&lt;/span&gt;(&lt;span class=&quot;hljs-keyword&quot;&gt;sizeof&lt;/span&gt;(*ppp) * x);\n  assert(ppp != &lt;span class=&quot;hljs-literal&quot;&gt;NULL&lt;/span&gt;);\n  &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;hljs-type&quot;&gt;size_t&lt;/span&gt; i=&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;; i&amp;lt;x; i++)\n  {\n    ppp[i] = &lt;span class=&quot;hljs-built_in&quot;&gt;malloc&lt;/span&gt;(&lt;span class=&quot;hljs-keyword&quot;&gt;sizeof&lt;/span&gt;(**ppp) * y);\n    assert(ppp[i] != &lt;span class=&quot;hljs-literal&quot;&gt;NULL&lt;/span&gt;);\n    &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;hljs-type&quot;&gt;size_t&lt;/span&gt; j=&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;; j&amp;lt;y; j++)\n    {\n      ppp[i][j] = &lt;span class=&quot;hljs-built_in&quot;&gt;malloc&lt;/span&gt;(&lt;span class=&quot;hljs-keyword&quot;&gt;sizeof&lt;/span&gt;(***ppp) * z);\n      assert(ppp[i][j] != &lt;span class=&quot;hljs-literal&quot;&gt;NULL&lt;/span&gt;);\n    }\n  }\n\n  &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; ppp;\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Now &lt;em&gt;that&lt;/em&gt; is one unreadble mess of &quot;three-star programming&quot;. And lets not even consider 4 dimensions...&lt;/p&gt;\n\n&lt;hr&gt;\n\n&lt;p&gt;&lt;strong&gt;The full code of a version using true 2D arrays&lt;/strong&gt;&lt;/p&gt;\n\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&amp;lt;stdlib.h&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&amp;lt;assert.h&amp;gt;&lt;/span&gt;&lt;/span&gt;\n\n&lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;arr_alloc&lt;/span&gt; &lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-type&quot;&gt;size_t&lt;/span&gt; x, &lt;span class=&quot;hljs-type&quot;&gt;size_t&lt;/span&gt; y, &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt;(**aptr)[x][y])&lt;/span&gt;\n{\n  *aptr = &lt;span class=&quot;hljs-built_in&quot;&gt;malloc&lt;/span&gt;( &lt;span class=&quot;hljs-keyword&quot;&gt;sizeof&lt;/span&gt;(&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt;[x][y]) ); &lt;span class=&quot;hljs-comment&quot;&gt;// allocate a true 2D array&lt;/span&gt;\n  assert(*aptr != &lt;span class=&quot;hljs-literal&quot;&gt;NULL&lt;/span&gt;);\n}\n\n&lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;arr_fill&lt;/span&gt; &lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-type&quot;&gt;size_t&lt;/span&gt; x, &lt;span class=&quot;hljs-type&quot;&gt;size_t&lt;/span&gt; y, &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-built_in&quot;&gt;array&lt;/span&gt;[x][y])&lt;/span&gt;\n{\n  &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;hljs-type&quot;&gt;size_t&lt;/span&gt; i=&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;; i&amp;lt;x; i++)\n  {\n    &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;hljs-type&quot;&gt;size_t&lt;/span&gt; j=&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;; j&amp;lt;y; j++)\n    {\n      &lt;span class=&quot;hljs-built_in&quot;&gt;array&lt;/span&gt;[i][j] = (&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt;)j + &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;;\n    }\n  }\n}\n\n&lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;arr_print&lt;/span&gt; &lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-type&quot;&gt;size_t&lt;/span&gt; x, &lt;span class=&quot;hljs-type&quot;&gt;size_t&lt;/span&gt; y, &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-built_in&quot;&gt;array&lt;/span&gt;[x][y])&lt;/span&gt;\n{\n  &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;hljs-type&quot;&gt;size_t&lt;/span&gt; i=&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;; i&amp;lt;x; i++)\n  {\n    &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;hljs-type&quot;&gt;size_t&lt;/span&gt; j=&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;; j&amp;lt;y; j++)\n    {\n      &lt;span class=&quot;hljs-built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;%d &quot;&lt;/span&gt;, &lt;span class=&quot;hljs-built_in&quot;&gt;array&lt;/span&gt;[i][j]);\n    }\n    &lt;span class=&quot;hljs-built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;\\n&quot;&lt;/span&gt;);\n  }\n}\n\n&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;main&lt;/span&gt; &lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt;)&lt;/span&gt;\n{\n  &lt;span class=&quot;hljs-type&quot;&gt;size_t&lt;/span&gt; x = &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;;\n  &lt;span class=&quot;hljs-type&quot;&gt;size_t&lt;/span&gt; y = &lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;;\n  &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; (*aptr)[x][y];\n\n  arr_alloc(x, y, &amp;amp;aptr);\n  arr_fill(x, y, *aptr);\n  arr_print(x, y, *aptr);\n  &lt;span class=&quot;hljs-built_in&quot;&gt;free&lt;/span&gt;(aptr); &lt;span class=&quot;hljs-comment&quot;&gt;// free the whole 2D array&lt;/span&gt;\n\n  &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;;\n}\n&lt;/code&gt;&lt;/pre&gt;\n    ","\n&lt;p&gt;&lt;strong&gt;C doesn&apos;t have multidimensional arrays&lt;/strong&gt; (as a &lt;em&gt;primitive&lt;/em&gt; data type). But you could have arrays of arrays (or of other aggregates) and arrays of pointers.&lt;/p&gt;\n\n&lt;p&gt;A possible approach is to &lt;strong&gt;reason with some &lt;a href=&quot;https://en.wikipedia.org/wiki/Abstract_data_type&quot; rel=&quot;nofollow noreferrer&quot;&gt;abstract data type&lt;/a&gt;&lt;/strong&gt; (perhaps using &lt;a href=&quot;https://en.wikipedia.org/wiki/Flexible_array_member&quot; rel=&quot;nofollow noreferrer&quot;&gt;flexible array members&lt;/a&gt;, which is one implementation trick, and you could use other approaches) like in &lt;a href=&quot;https://stackoverflow.com/a/47235897/841108&quot;&gt;this answer&lt;/a&gt;.&lt;/p&gt;\n\n&lt;p&gt;We can&apos;t suggest any abstract data type, because that depends on the text of your homework, which we don&apos;t have. You need to &lt;strong&gt;design your abstract data type&lt;/strong&gt; (on a piece of paper), and later to implement it.&lt;/p&gt;\n\n&lt;p&gt;Once you have listed (on a paper or on a board) all the operations needed on your ADT, implementing them is straightforward.&lt;/p&gt;\n\n&lt;blockquote&gt;\n  &lt;p&gt;This code works just fine! How could it be wrong?&lt;/p&gt;\n&lt;/blockquote&gt;\n\n&lt;p&gt;That sentence is inconsistent (wrong w.r.t. what specifications?) ...&lt;/p&gt;\n\n&lt;p&gt;I recommend to compile with all warnings and debug info (e.g. &lt;a href=&quot;https://gcc.gnu.org/onlinedocs/gcc/Invoking-GCC.html&quot; rel=&quot;nofollow noreferrer&quot;&gt;with&lt;/a&gt; &lt;code&gt;gcc -Wall -Wextra -g&lt;/code&gt; with &lt;a href=&quot;https://gcc.gnu.org/&quot; rel=&quot;nofollow noreferrer&quot;&gt;GCC&lt;/a&gt;), to improve your code till you get no warnings, to use the debugger &lt;code&gt;gdb&lt;/code&gt; (to understand what is happening in your program) and other tools like &lt;a href=&quot;http://valgrind.org/&quot; rel=&quot;nofollow noreferrer&quot;&gt;valgrind&lt;/a&gt;.&lt;/p&gt;\n    "]},"randomTags":[{"name":"groupwise-maximum","slug":"groupwise-maximum"},{"name":"css","slug":"css"},{"name":"javascript","slug":"javascript"},{"name":"database-design","slug":"database-design"},{"name":"facelets","slug":"facelets"},{"name":"constructor","slug":"constructor"},{"name":"dom-events","slug":"dom-events"},{"name":"commandlink","slug":"commandlink"},{"name":"dom-traversal","slug":"dom-traversal"},{"name":"datediff","slug":"datediff"},{"name":"jquery","slug":"jquery"},{"name":"local-storage","slug":"local-storage"},{"name":"getelementsbyclassname","slug":"getelementsbyclassname"},{"name":"observable","slug":"observable"},{"name":"android-recyclerview","slug":"android-recyclerview"},{"name":"servlets","slug":"servlets"},{"name":"recursive-query","slug":"recursive-query"},{"name":"architecture","slug":"architecture"},{"name":"r-faq","slug":"r-faq"},{"name":"angularfire2","slug":"angularfire2"}]},"__N_SSG":true}