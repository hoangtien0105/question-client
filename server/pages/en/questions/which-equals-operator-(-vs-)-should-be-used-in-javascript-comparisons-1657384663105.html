<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><meta name="twitter:card" content="summary_large_image"/><meta name="twitter:site" content="@solutionschecker.com"/><meta name="twitter:creator" content="@solutionschecker.com"/><meta property="og:url" content="https://solutionschecker.com"/><meta property="og:type" content="website"/><meta property="og:image" content="https://solutionschecker.com/solutions-checker-banner.png"/><meta property="og:image:alt" content="Find the solution to any question. We focus on finding the fastest possible solution for users. Main topics like coding, learning. - solutionschecker.com"/><link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png"/><link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png"/><link rel="manifest" href="/site.webmanifest"/><script type="application/ld+json">{"@context":"https://schema.org","@type":"Organization","logo":"/logo.svg","url":"https://solutionschecker.com"}</script><link name="keywords" content="equality-operator,identity-operator,solutions checker, solution checker, how to, solution for, check for solution, resolve question, what is, what solution for, find solution"/><script type="application/ld+json">{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"item":{"@id":"https://solutionschecker.com","name":"Home"}},{"@type":"ListItem","position":2,"item":{"@id":"https://solutionschecker.com/questions","name":"Questions"}},{"@type":"ListItem","position":3,"item":{"@id":"https://solutionschecker.com/questions/which-equals-operator-(-vs-)-should-be-used-in-javascript-comparisons-1657384663105","name":"Questions"}}]}</script><title>Which equals operator (== vs ===) should be used in JavaScript comparisons? | Solution Checker</title><meta name="robots" content="index,follow"/><meta name="description" content="
            
        
            
                    
                        
                    
                
                    
                        This question&#x27;s answers are a community effort. Edit existing answers to improve this post. It is not currently accepting new answers or interactions.
                        
                    
                
            
        


    

I&#x27;m using JSLint to go through JavaScript, and it&#x27;s returning many suggestions to replace == (two equals signs) with === (three equals signs) when doing things like comparing idSele_UNVEHtype.value.length == 0 inside of an if statement.

Is there a performance benefit to replacing == with ===? 

Any performance improvement would be welcomed as many comparison operators exist.

If no type conversion takes place, would there be a performance gain over ==?
    "/><meta property="og:title" content="Which equals operator (== vs ===) should be used in JavaScript comparisons? | Solution Checker"/><meta property="og:description" content="
            
        
            
                    
                        
                    
                
                    
                        This question&#x27;s answers are a community effort. Edit existing answers to improve this post. It is not currently accepting new answers or interactions.
                        
                    
                
            
        


    

I&#x27;m using JSLint to go through JavaScript, and it&#x27;s returning many suggestions to replace == (two equals signs) with === (three equals signs) when doing things like comparing idSele_UNVEHtype.value.length == 0 inside of an if statement.

Is there a performance benefit to replacing == with ===? 

Any performance improvement would be welcomed as many comparison operators exist.

If no type conversion takes place, would there be a performance gain over ==?
    "/><script type="application/ld+json">{"@context":"https://schema.org","@type":"QAPage","mainEntity":{"name":"Which equals operator (== vs ===) should be used in JavaScript comparisons?","text":"\n            \n        \n            \n                    \n                        \n                    \n                \n                    \n                        This question&apos;s answers are a community effort. Edit existing answers to improve this post. It is not currently accepting new answers or interactions.\n                        \n                    \n                \n            \n        \n\n\n    \n\nI&apos;m using JSLint to go through JavaScript, and it&apos;s returning many suggestions to replace == (two equals signs) with === (three equals signs) when doing things like comparing idSele_UNVEHtype.value.length == 0 inside of an if statement.\n\nIs there a performance benefit to replacing == with ===? \n\nAny performance improvement would be welcomed as many comparison operators exist.\n\nIf no type conversion takes place, would there be a performance gain over ==?\n    ","answerCount":30,"upVoteCount":500,"suggestedAnswer":[{"text":"The strict equality operator (===) behaves identically to the abstract equality operator (==) except no type conversion is done, and the types must be the same to be considered equal.\n\nReference: Javascript Tutorial: Comparison Operators\n\nThe == operator will compare for equality after doing any necessary type conversions.  The === operator will not do the conversion, so if two values are not the same type === will simply return false. Both are equally quick.\n\nTo quote Douglas Crockford&apos;s excellent JavaScript: The Good Parts,\n\n\n  JavaScript has two sets of equality operators: === and !==, and their evil twins == and !=.  The good ones work the way you would expect.  If the two operands are of the same type and have the same value, then === produces true and !== produces false.  The evil twins do the right thing when the operands are of the same type, but if they are of different types, they attempt to coerce the values.  the rules by which they do that are complicated and unmemorable.  These are some of the interesting cases:\n\n&apos;&apos; == &apos;0&apos;           // false\n0 == &apos;&apos;             // true\n0 == &apos;0&apos;            // true\n\nfalse == &apos;false&apos;    // false\nfalse == &apos;0&apos;        // true\n\nfalse == undefined  // false\nfalse == null       // false\nnull == undefined   // true\n\n&apos; \\t\\r\\n &apos; == 0     // true\n\n\n\n\n\n\n  The lack of transitivity is alarming.  My advice is to never use the evil twins.  Instead, always use === and !==.  All of the comparisons just shown produce false with the === operator.\n\n\n\n\nUpdate:\n\nA good point was brought up by @Casebash in the comments and in @Phillipe Laybaert&apos;s answer concerning objects.  For objects, == and === act consistently with one another (except in a special case).\n\nvar a = [1,2,3];\nvar b = [1,2,3];\n\nvar c = { x: 1, y: 2 };\nvar d = { x: 1, y: 2 };\n\nvar e = &quot;text&quot;;\nvar f = &quot;te&quot; + &quot;xt&quot;;\n\na == b            // false\na === b           // false\n\nc == d            // false\nc === d           // false\n\ne == f            // true\ne === f           // true\n\n\nThe special case is when you compare a primitive with an object that evaluates to the same primitive, due to its toString or valueOf method. For example, consider the comparison of a string primitive with a string object created using the String constructor.\n\n&quot;abc&quot; == new String(&quot;abc&quot;)    // true\n&quot;abc&quot; === new String(&quot;abc&quot;)   // false\n\n\nHere the == operator is checking the values of the two objects and returning true, but the === is seeing that they&apos;re not the same type and returning false.  Which one is correct?  That really depends on what you&apos;re trying to compare.  My advice is to bypass the question entirely and just don&apos;t use the String constructor to create string objects from string literals.\n\nReference\nhttp://www.ecma-international.org/ecma-262/5.1/#sec-11.9.3\n    ","url":"/questions/[slug]#solution1","@type":"Answer","upvoteCount":0},{"text":"Using the == operator (Equality)\ntrue == 1; //true, because &apos;true&apos; is converted to 1 and then compared\n&quot;2&quot; == 2;  //true, because &quot;2&quot; is converted to 2 and then compared\n\nUsing the === operator (Identity)\ntrue === 1; //false\n&quot;2&quot; === 2;  //false\n\nThis is because the equality operator == does type coercion, meaning that the interpreter implicitly tries to convert the values before comparing.\nOn the other hand, the identity operator === does not do type coercion, and thus does not convert the values when comparing.\n    ","url":"/questions/[slug]#solution2","@type":"Answer","upvoteCount":0},{"text":"Here&apos;s an interesting visualisation of the equality comparison between == and ===.\nSource: https://github.com/dorey/JavaScript-Equality-Table (demo, unified demo)\n\nvar1 === var2\nWhen using === for JavaScript equality testing, everything is as is.\nNothing gets converted before being evaluated.\n\nvar1 == var2\nWhen using == for JavaScript equality testing, some funky conversions take place.\n\nSummary of equality in Javascript\n\n\nConclusion:\nAlways use ===, unless you fully understand the funky conversions that take place with ==.\n    ","url":"/questions/[slug]#solution3","@type":"Answer","upvoteCount":0},{"text":"In the answers here, I didn&apos;t read anything about what equal means. Some will say that === means equal and of the same type, but that&apos;s not really true. It actually means that both operands reference the same object, or in case of value types, have the same value.\nSo, let&apos;s take the following code:\nvar a = [1,2,3];\nvar b = [1,2,3];\nvar c = a;\n\nvar ab_eq = (a === b); // false (even though a and b are the same type)\nvar ac_eq = (a === c); // true\n\nThe same here:\nvar a = { x: 1, y: 2 };\nvar b = { x: 1, y: 2 };\nvar c = a;\n\nvar ab_eq = (a === b); // false (even though a and b are the same type)\nvar ac_eq = (a === c); // true\n\nOr even:\nvar a = { };\nvar b = { };\nvar c = a;\n\nvar ab_eq = (a === b); // false (even though a and b are the same type)\nvar ac_eq = (a === c); // true\n\nThis behavior is not always obvious. There&apos;s more to the story than being equal and being of the same type.\nThe rule is:\nFor value types (numbers):\na === b returns true if a and b have the same value and are of the same type\nFor reference types:\na === b returns true if a and b reference the exact same object\nFor strings:\na === b returns true if a and b are both strings and contain the exact same characters\n\nStrings: the special case...\nStrings are not value types, but in Javascript they behave like value types, so they will be &quot;equal&quot; when the characters in the string are the same and when they are of the same length (as explained in the third rule)\nNow it becomes interesting:\nvar a = &quot;12&quot; + &quot;3&quot;;\nvar b = &quot;123&quot;;\n\nalert(a === b); // returns true, because strings behave like value types\n\nBut how about this?:\nvar a = new String(&quot;123&quot;);\nvar b = &quot;123&quot;;\n\nalert(a === b); // returns false !! (but they are equal and of the same type)\n\nI thought strings behave like value types? Well, it depends who you ask... In this case a and b are not the same type. a is of type Object, while b is of type string. Just remember that creating a string object using the String constructor creates something of type Object that behaves as a string most of the time.\n    ","url":"/questions/[slug]#solution4","@type":"Answer","upvoteCount":0},{"text":"Let me add this counsel:\nIf in doubt, read the specification!\nECMA-262 is the specification for a scripting language of which JavaScript is a dialect. Of course in practice it matters more how the most important browsers behave than an esoteric definition of how something is supposed to be handled. But it is helpful to understand why new String(&quot;a&quot;) !== &quot;a&quot;.\nPlease let me explain how to read the specification to clarify this question. I see that in this very old topic nobody had an answer for the very strange effect. So, if you can read a specification, this will help you in your profession tremendously. It is an acquired skill. So, let&apos;s continue.\nSearching the PDF file for === brings me to page 56 of the specification: 11.9.4. The Strict Equals Operator ( === ), and after wading through the specificationalese I find:\n\n11.9.6 The Strict Equality Comparison Algorithm\nThe comparison x === y, where x and y are values, produces true or false. Such a comparison is performed as follows:\n  1. If Type(x) is different from Type(y), return false.\n  2. If Type(x) is Undefined, return true.\n  3. If Type(x) is Null, return true.\n  4. If Type(x) is not Number, go to step 11.\n  5. If x is NaN, return false.\n  6. If y is NaN, return false.\n  7. If x is the same number value as y, return true.\n  8. If x is +0 and y is 0, return true.\n  9. If x is 0 and y is +0, return true.\n  10. Return false.\n  11. If Type(x) is String, then return true if x and y are exactly the same sequence of characters (same length and same characters in corresponding positions); otherwise, return false.\n  12. If Type(x) is Boolean, return true if x and y are both true or both false; otherwise, return false.\n  13. Return true if x and y refer to the same object or if they refer to objects joined to each other (see 13.1.2). Otherwise, return false.\n\nInteresting is step 11. Yes, strings are treated as value types. But this does not explain why new String(&quot;a&quot;) !== &quot;a&quot;. Do we have a browser not conforming to ECMA-262?\nNot so fast!\nLet&apos;s check the types of the operands. Try it out for yourself by wrapping them in typeof(). I find that new String(&quot;a&quot;) is an object, and step 1 is used: return false if the types are different.\nIf you wonder why new String(&quot;a&quot;) does not return a string, how about some exercise reading a specification? Have fun!\n\nAidiakapi wrote this in a comment below:\n\nFrom the specification\n11.2.2 The new Operator:\nIf Type(constructor) is not Object, throw a TypeError exception.\nWith other words, if String wouldn&apos;t be of type Object it couldn&apos;t be used with the new operator.\n\nnew always returns an Object, even for String constructors, too. And alas! The value semantics for strings (see step 11) is lost.\nAnd this finally means: new String(&quot;a&quot;) !== &quot;a&quot;.\n    ","url":"/questions/[slug]#solution5","@type":"Answer","upvoteCount":0},{"text":"I tested this in Firefox with Firebug using code like this:\n\n\nconsole.time(&quot;testEquality&quot;);\nvar n = 0;\nwhile (true) {\n  n++;\n  if (n == 100000)\n    break;\n}\nconsole.timeEnd(&quot;testEquality&quot;);\n Run code snippetHide resultsExpand snippet\n\n\nand\n\n\nconsole.time(&quot;testTypeEquality&quot;);\nvar n = 0;\nwhile (true) {\n  n++;\n  if (n === 100000)\n    break;\n}\nconsole.timeEnd(&quot;testTypeEquality&quot;);\n Run code snippetHide resultsExpand snippet\n\n\nMy results (tested five times each and averaged):\n==: 115.2\n===: 114.4\n\nSo I&apos;d say that the miniscule difference (this is over 100000 iterations, remember) is negligible. Performance isn&apos;t a reason to do ===. Type safety (well, as safe as you&apos;re going to get in JavaScript), and code quality is.\n    ","url":"/questions/[slug]#solution6","@type":"Answer","upvoteCount":0},{"text":"In PHP and JavaScript, it is a strict equality operator. Which means, it will compare both type and values.\n    ","url":"/questions/[slug]#solution7","@type":"Answer","upvoteCount":0},{"text":"In JavaScript it means of the same value and type.\n\nFor example,\n\n4 == &quot;4&quot; // will return true\n\n\nbut\n\n4 === &quot;4&quot; // will return false \n\n    ","url":"/questions/[slug]#solution8","@type":"Answer","upvoteCount":0},{"text":"Why == is so unpredictable?\n\nWhat do you get when you compare an empty string &quot;&quot; with the number zero 0?\n\ntrue\n\nYep, that&apos;s right according to == an empty string and the number zero are the same time.\n\nAnd it doesn&apos;t end there, here&apos;s another one:\n\n&apos;0&apos; == false // true\n\n\nThings get really weird with arrays.\n\n[1] == true // true\n[] == false // true\n[[]] == false // true\n[0] == false // true\n\n\nThen weirder with strings\n\n[1,2,3] == &apos;1,2,3&apos; // true - REALLY?!\n&apos;\\r\\n\\t&apos; == 0 // true - Come on!\n\n\nIt get&apos;s worse:\n\nWhen is equal not equal?\n\nlet A = &apos;&apos;  // empty string\nlet B = 0   // zero\nlet C = &apos;0&apos; // zero string\n\nA == B // true - ok... \nB == C // true - so far so good...\nA == C // **FALSE** - Plot twist!\n\n\nLet me say that again:\n\n(A == B) &amp;&amp; (B == C) // true\n(A == C) // **FALSE**\n\n\nAnd this is just the crazy stuff you get with primitives.\n\nIt&apos;s a whole new level of crazy when you use == with objects.\n\nAt this point your probably wondering...\n\nWhy does this happen?\n\nWell it&apos;s because unlike &quot;triple equals&quot; (===) which just checks if two values are the same.\n\n== does a whole bunch of other stuff.\n\nIt has special handling for functions, special handling for nulls, undefined, strings, you name it.\n\nIt get&apos;s pretty wacky.\n\nIn fact, if you tried to write a function that does what == does it would look something like this:\n\nfunction isEqual(x, y) { // if `==` were a function\n    if(typeof y === typeof x) return y === x;\n    // treat null and undefined the same\n    var xIsNothing = (y === undefined) || (y === null);\n    var yIsNothing = (x === undefined) || (x === null);\n\n    if(xIsNothing || yIsNothing) return (xIsNothing &amp;&amp; yIsNothing);\n\n    if(typeof y === &quot;function&quot; || typeof x === &quot;function&quot;) {\n        // if either value is a string \n        // convert the function into a string and compare\n        if(typeof x === &quot;string&quot;) {\n            return x === y.toString();\n        } else if(typeof y === &quot;string&quot;) {\n            return x.toString() === y;\n        } \n        return false;\n    }\n\n    if(typeof x === &quot;object&quot;) x = toPrimitive(x);\n    if(typeof y === &quot;object&quot;) y = toPrimitive(y);\n    if(typeof y === typeof x) return y === x;\n\n    // convert x and y into numbers if they are not already use the &quot;+&quot; trick\n    if(typeof x !== &quot;number&quot;) x = +x;\n    if(typeof y !== &quot;number&quot;) y = +y;\n    // actually the real `==` is even more complicated than this, especially in ES6\n    return x === y;\n}\n\nfunction toPrimitive(obj) {\n    var value = obj.valueOf();\n    if(obj !== value) return value;\n    return obj.toString();\n}\n\n\nSo what does this mean?\n\nIt means == is complicated.\n\nBecause it&apos;s complicated it&apos;s hard to know what&apos;s going to happen when you use it.\n\nWhich means you could end up with bugs.\n\nSo the moral of the story is...\n\nMake your life less complicated.\n\nUse === instead of ==.\n\nThe End.\n    ","url":"/questions/[slug]#solution9","@type":"Answer","upvoteCount":0},{"text":"The === operator is called a strict comparison operator, it does differ from the == operator.\n\nLets take 2 vars a and b.\n\nFor &quot;a == b&quot; to evaluate to true a and b need to be the same value.\n\nIn the case of &quot;a === b&quot; a and b must be the same value and also the same type for it to evaluate to true.  \n\nTake the following example\n\nvar a = 1;\nvar b = &quot;1&quot;;\n\nif (a == b) //evaluates to true as a and b are both 1\n{\n    alert(&quot;a == b&quot;);\n}\n\nif (a === b) //evaluates to false as a is not the same type as b\n{\n    alert(&quot;a === b&quot;);\n}\n\n\nIn summary; using the == operator might evaluate to true in situations where you do not want it to so using the === operator would be safer.  \n\nIn the 90% usage scenario it won&apos;t matter which one you use, but it is handy to know the difference when you get some unexpected behaviour one day.\n    ","url":"/questions/[slug]#solution10","@type":"Answer","upvoteCount":0},{"text":"=== checks same sides are equal in type as well as value.\n\nExample:\n&apos;1&apos; === 1 // will return &quot;false&quot; because `string` is not a `number`\n\nCommon example:\n0 == &apos;&apos;  // will be &quot;true&quot;, but it&apos;s very common to want this check to be &quot;false&quot;\n\nAnother common example:\nnull == undefined // returns &quot;true&quot;, but in most cases a distinction is necessary\n\n\nMany times an untyped check would be handy because you do not care if the value is either undefined, null, 0  or &quot;&quot;\n    ","url":"/questions/[slug]#solution11","@type":"Answer","upvoteCount":0},{"text":"Javascript execution flow diagram for strict equality / Comparison &apos;===&apos;\n\n\n\nJavascript execution flow diagram for non strict equality / comparison &apos;==&apos;\n\n\n    ","url":"/questions/[slug]#solution12","@type":"Answer","upvoteCount":0},{"text":"JavaScript === vs == .\n\n0==false   // true\n0===false  // false, because they are of a different type\n1==&quot;1&quot;     // true, auto type coercion\n1===&quot;1&quot;    // false, because they are of a different type\n\n    ","url":"/questions/[slug]#solution13","@type":"Answer","upvoteCount":0},{"text":"It means equality without type coercion\ntype coercion means JavaScript do not automatically convert any other data types to string data types \n\n0==false   // true,although they are different types\n\n0===false  // false,as they are different types\n\n2==&apos;2&apos;    //true,different types,one is string and another is integer but \n            javaScript convert 2 to string by using == operator \n\n2===&apos;2&apos;  //false because by using === operator ,javaScript do not convert \n           integer to string \n\n2===2   //true because both have same value and same types \n\n    ","url":"/questions/[slug]#solution14","@type":"Answer","upvoteCount":0},{"text":"In a typical script there will be no performance difference. More important may be the fact that thousand &quot;===&quot; is 1 KB heavier than thousand &quot;==&quot; :) JavaScript profilers can tell you if there is a performance difference in your case.\n\nBut personally I would do what JSLint suggests. This recommendation is there not because of performance issues, but because type coercion means (&apos;\\t\\r\\n&apos; == 0) is true.\n    ","url":"/questions/[slug]#solution15","@type":"Answer","upvoteCount":0},{"text":"The equal comparison operator == is confusing and should be avoided. \n\nIf you HAVE TO live with it, then remember the following 3 things: \n\n\nIt is not transitive: (a == b) and (b == c) does not lead to (a == c)\nIt&apos;s mutually exclusive to its negation: (a == b) and (a != b) always hold opposite Boolean values, with all a and b.\nIn case of doubt, learn by heart the following truth table:\n\n\nEQUAL OPERATOR TRUTH TABLE IN JAVASCRIPT\n\n\nEach row in the table is a set of 3 mutually &quot;equal&quot; values, meaning that any 2 values among them are equal using the equal == sign*\n\n\n** STRANGE: note that any two values on the first column are not equal in that sense.**\n\n&apos;&apos;       == 0 == false   // Any two values among these 3 ones are equal with the == operator\n&apos;0&apos;      == 0 == false   // Also a set of 3 equal values, note that only 0 and false are repeated\n&apos;\\t&apos;     == 0 == false   // -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --\n&apos;\\r&apos;     == 0 == false   // -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --\n&apos;\\n&apos;     == 0 == false   // -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --\n&apos;\\t\\r\\n&apos; == 0 == false   // -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --\n\nnull == undefined  // These two &quot;default&quot; values are not-equal to any of the listed values above\nNaN                // NaN is not equal to any thing, even to itself.\n\n    ","url":"/questions/[slug]#solution16","@type":"Answer","upvoteCount":0},{"text":"There is unlikely to be any performance difference between the two operations in your usage. There is no type-conversion to be done because both parameters are already the same type. Both operations will have a type comparison followed by a value comparison.\n    ","url":"/questions/[slug]#solution17","@type":"Answer","upvoteCount":0},{"text":"Yes! It does matter.\n\n=== operator in javascript checks value as well as type where as == operator just checks the value (does type conversion if required).\n\n\n\nYou can easily test it. Paste following code in an HTML file and open it in browser\n\n&lt;script&gt;\n\nfunction onPageLoad()\n{\n    var x = &quot;5&quot;;\n    var y = 5;\n    alert(x === 5);\n};\n\n&lt;/script&gt;\n\n&lt;/head&gt;\n\n&lt;body onload=&apos;onPageLoad();&apos;&gt;\n\n\nYou will get &apos;false&apos; in alert. Now modify the onPageLoad() method to alert(x == 5); you will get true.\n    ","url":"/questions/[slug]#solution18","@type":"Answer","upvoteCount":0},{"text":"Simply\n== means comparison between operands with type coercion\nand\n=== means comparison between operands without type coercion.\nType coercion in JavaScript means automatically converting data types to other data types.\nFor example:\n123 == &quot;123&quot;  // Returns true, because JS coerces string &quot;123&quot; to number 123\n              // and then goes on to compare `123 == 123`.\n\n123 === &quot;123&quot; // Returns false, because JS does not coerce values of different types here.\n\n    ","url":"/questions/[slug]#solution19","@type":"Answer","upvoteCount":0},{"text":"As a rule of thumb, I would generally use === instead of == (and !== instead of !=).\nReasons are explained in in the answers above and also Douglas Crockford is pretty clear about it (JavaScript: The Good Parts).\nHowever there is one single exception:\n== null is an efficient way to check for &apos;is null or undefined&apos;:\nif( value == null ){\n    // value is either null or undefined\n}\n\nFor example jQuery 1.9.1 uses this pattern 43 times, and  the JSHint syntax checker even provides the eqnull relaxing option for this reason.\nFrom the jQuery style guide:\n\nStrict equality checks (===) should be used in favor of ==. The only\nexception is when checking for undefined and null by way of null.\n\n// Check for both undefined and null values, for some important reason. \nundefOrNull == null;\n\nEDIT 2021-03:\nNowadays most browsers\nsupport the Nullish coalescing operator (??)\nand the Logical nullish assignment (??=), which allows a more concise way to\nassign a default value if a variable is null or undefined, for example:\nif (a.speed == null) {\n  // Set default if null or undefined\n  a.speed = 42;\n}\n\ncan be written as any of these forms\na.speed ??= 42;\na.speed ?? a.speed = 42;\na.speed = a.speed ?? 42;\n\n    ","url":"/questions/[slug]#solution20","@type":"Answer","upvoteCount":0},{"text":"It&apos;s a strict check test.\n\nIt&apos;s a good thing especially if you&apos;re checking between 0 and false and null. \n\nFor example, if you have:\n\n$a = 0;\n\n\nThen:\n\n$a==0; \n$a==NULL;\n$a==false;\n\n\nAll returns true and you may not want this. Let&apos;s suppose you have a function that can return the 0th index of an array or false on failure. If you check with &quot;==&quot; false, you can get a confusing result.\n\nSo with the same thing as above, but a strict test:\n\n$a = 0;\n\n$a===0; // returns true\n$a===NULL; // returns false\n$a===false; // returns false\n\n    ","url":"/questions/[slug]#solution21","@type":"Answer","upvoteCount":0},{"text":"=== operator  checks the values as well as the types of the variables for equality.\n\n== operator just checks the value of the variables for equality.\n    ","url":"/questions/[slug]#solution22","@type":"Answer","upvoteCount":0},{"text":"JSLint sometimes gives you unrealistic reasons to modify stuff. === has exactly the same performance as == if the types are already the same. \n\nIt is faster only when the types are not the same, in which case it does not try to convert types but directly returns a false.\n\nSo, IMHO, JSLint maybe used to write new code, but useless over-optimizing should be avoided at all costs. \n\nMeaning, there is no reason to change == to === in a check like if (a == &apos;test&apos;) when you know it for a fact that a can only be a String. \n\nModifying a lot of code that way wastes developers&apos; and reviewers&apos; time and achieves nothing.\n    ","url":"/questions/[slug]#solution23","@type":"Answer","upvoteCount":0},{"text":"A simple example is \n\n2 == &apos;2&apos;  -&gt; true, values are SAME because of type conversion.\n\n2 === &apos;2&apos;  -&gt; false, values are NOT SAME because of no type conversion.\n\n    ","url":"/questions/[slug]#solution24","@type":"Answer","upvoteCount":0},{"text":"The top 2 answers both mentioned == means equality and === means identity. Unfortunately, this statement is incorrect. \n\nIf both operands of == are objects, then they are compared to see if they are the same object. If both operands point to the same object, then the equal operator returns true. Otherwise,\nthe two are not equal. \n\nvar a = [1, 2, 3];  \nvar b = [1, 2, 3];  \nconsole.log(a == b)  // false  \nconsole.log(a === b) // false  \n\n\nIn the code above, both == and === get false because a and b are not the same objects.\n\nThat&apos;s to say: if both operands of == are objects, == behaves same as ===, which also means identity. The essential difference of this two operators is about type conversion. == has conversion before it checks equality, but === does not.\n    ","url":"/questions/[slug]#solution25","@type":"Answer","upvoteCount":0},{"text":"The problem is that you might easily get into trouble since JavaScript have a lot of implicit conversions meaning...\n\nvar x = 0;\nvar isTrue = x == null;\nvar isFalse = x === null;\n\n\nWhich pretty soon becomes a problem. The best sample of why implicit conversion is &quot;evil&quot; can be taken from this code in MFC / C++ which actually will compile due to an implicit conversion from CString to HANDLE which is a pointer typedef type...\n\nCString x;\ndelete x;\n\n\nWhich obviously during runtime does very undefined things...\n\nGoogle for implicit conversions in C++ and STL to get some of the arguments against it...\n    ","url":"/questions/[slug]#solution26","@type":"Answer","upvoteCount":0},{"text":"From the core javascript reference\n\n\n  === Returns true if the operands are strictly equal (see above)\n  with no type conversion.\n\n    ","url":"/questions/[slug]#solution27","@type":"Answer","upvoteCount":0},{"text":"Equality comparison: \n\nOperator ==\n\nReturns true, when both operands are equal. The operands are converted to the same type before being compared.\n\n&gt;&gt;&gt; 1 == 1\ntrue\n&gt;&gt;&gt; 1 == 2\nfalse\n&gt;&gt;&gt; 1 == &apos;1&apos;\ntrue\n\n\nEquality and type comparison: \n\nOperator ===\n\nReturns true if both operands are equal and of the same type. It&apos;s generally \nbetter and safer if you compare this way, because there&apos;s no behind-the-scenes type conversions.\n\n&gt;&gt;&gt; 1 === &apos;1&apos;\nfalse\n&gt;&gt;&gt; 1 === 1\ntrue\n\n    ","url":"/questions/[slug]#solution28","@type":"Answer","upvoteCount":0},{"text":"Here is a handy comparison table that shows the conversions that happen and the differences between == and ===.\n\nAs the conclusion states:\n\n\n  &quot;Use three equals unless you fully understand the conversions that take\n  place for two-equals.&quot;\n\n\nhttp://dorey.github.io/JavaScript-Equality-Table/\n    ","url":"/questions/[slug]#solution29","@type":"Answer","upvoteCount":0},{"text":"null and undefined are nothingness, that is,\n\nvar a;\nvar b = null;\n\n\nHere a and b do not have values. Whereas, 0, false and &apos;&apos; are all values. One thing common beween all these are that they are all falsy values, which means they all satisfy falsy conditions.\n\nSo, the 0, false and &apos;&apos; together form a sub-group. And on other hand, null &amp; undefined form the second sub-group. Check the comparisons in the below image. null and undefined would equal. The other three would equal to each other. But, they all are treated as falsy conditions in JavaScript.\n\n\n\nThis is same as any object (like {}, arrays, etc.), non-empty string &amp; Boolean true are all truthy conditions. But, they are all not equal.\n    ","url":"/questions/[slug]#solution30","@type":"Answer","upvoteCount":0}],"@type":"Question"}}</script><meta name="next-head-count" content="22"/><link rel="preload" href="/_next/static/css/c116652e2d6f4ad0.css" as="style"/><link rel="stylesheet" href="/_next/static/css/c116652e2d6f4ad0.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-0d1b80a048d4787e.js"></script><script src="/_next/static/chunks/webpack-42cdea76c8170223.js" defer=""></script><script src="/_next/static/chunks/framework-4556c45dd113b893.js" defer=""></script><script src="/_next/static/chunks/main-ccfab947c79712f4.js" defer=""></script><script src="/_next/static/chunks/pages/_app-260362324a06d105.js" defer=""></script><script src="/_next/static/chunks/294-106ef8570fa99deb.js" defer=""></script><script src="/_next/static/chunks/490-7f0418bb4354ac73.js" defer=""></script><script src="/_next/static/chunks/pages/questions/%5Bslug%5D-50e201fdaa1e0fd1.js" defer=""></script><script src="/_next/static/5tS3Jli5j89_wXapXajXn/_buildManifest.js" defer=""></script><script src="/_next/static/5tS3Jli5j89_wXapXajXn/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="wrapper"><header><nav class="bg-white border-gray-200 px-4 lg:px-6 py-2.5 dark:bg-gray-800"><div class="flex flex-wrap justify-between items-center mx-auto max-w-screen-xl"><a class="flex items-center" href="/"><img src="/logo-second.png" class="mr-3 h-6 sm:h-9" alt="Solution Checker Logo"/><h1 class="self-center text-xl font-semibold whitespace-nowrap dark:text-white">Solution Checker</h1></a><div class="flex items-center lg:order-2"><button data-collapse-toggle="mobile-menu-2" type="button" class="inline-flex items-center p-2 ml-1 text-sm text-gray-500 rounded-lg lg:hidden hover:bg-gray-100 focus:outline-none focus:ring-2 focus:ring-gray-200 dark:text-gray-400 dark:hover:bg-gray-700 dark:focus:ring-gray-600" aria-controls="mobile-menu-2" aria-expanded="false"><span class="sr-only">Open main menu</span><svg class="w-6 h-6" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M3 5a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM3 10a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM3 15a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1z" clip-rule="evenodd"></path></svg><svg class="hidden w-6 h-6" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z" clip-rule="evenodd"></path></svg></button></div><div class="hidden justify-between items-center w-full lg:flex lg:w-auto lg:order-1" id="mobile-menu-2"><ul class="flex flex-col mt-4 font-medium lg:flex-row lg:space-x-8 lg:mt-0"><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" aria-current="page" href="/">Home</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/questions?tab=news">Questions</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/post?tab=news">Post</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/questions/which-equals-operator-(-vs-)-should-be-used-in-javascript-comparisons-1657384663105#">Coding</a></li></ul></div></div></nav></header><div class="main-content"><div class="question my-5"><div class="flex question-header items-center m-auto justify-center"><div class="rounded-xl w-full border p-5 shadow-md bg-white"><div class="flex w-full items-center justify-between border-b pb-3"><div class="flex items-center space-x-3"><div class="text-lg font-bold text-slate-700"><a href="/questions/which-equals-operator-(-vs-)-should-be-used-in-javascript-comparisons-1657384663105"><h1>Which equals operator (== vs ===) should be used in JavaScript comparisons?</h1></a></div></div><div class="flex flex-wrap h-auto justify-end items-center space-x-8"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold" href="/questions/tag/equality-operator">equality-operator</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold" href="/questions/tag/identity-operator">identity-operator</a></div></div><div class="question-content mt-5">
                    <div>
            <aside class="s-notice s-notice__info post-notice js-post-notice mb16" role="status">
        <div class="d-flex fd-column fw-nowrap">
            <div class="d-flex fw-nowrap">
                    <div class="flex--item mr8">
                        <svg aria-hidden="true" class="svg-icon iconLock" width="18" height="18" viewBox="0 0 18 18"><path d="M16 9a2 2 0 0 0-2-2V6A5 5 0 0 0 4 6v1a2 2 0 0 0-2 2v6c0 1.1.9 2 2 2h10a2 2 0 0 0 2-2V9Zm-7 5a2 2 0 1 1 0-4 2 2 0 0 1 0 4Zm3.1-7H5.9V6a3.1 3.1 0 0 1 6.2 0v1Z"></path></svg>
                    </div>
                <div class="flex--item wmn0 fl1 lh-lg">
                    <div class="flex--item fl1 lh-lg">
                        <b>This question's answers are a <a href="/help/privileges/edit-community-wiki">community effort</a></b>. Edit existing answers to improve this post. It is not currently accepting new answers or interactions.
                        
                    </div>
                </div>
            </div>
        </div>
</aside>

    </div>

<p>I'm using <a href="http://en.wikipedia.org/wiki/JSLint" rel="noreferrer">JSLint</a> to go through JavaScript, and it's returning many suggestions to replace <code>==</code> (two equals signs) with <code>===</code> (three equals signs) when doing things like comparing <code>idSele_UNVEHtype.value.length == 0</code> inside of an <code>if</code> statement.</p>

<p>Is there a performance benefit to replacing <code>==</code> with <code>===</code>? </p>

<p>Any performance improvement would be welcomed as many comparison operators exist.</p>

<p>If no type conversion takes place, would there be a performance gain over <code>==</code>?</p>
    </div></div></div><div class="solution-section"><nav class="flex pagination-solution flex-col justify-end"><h1 class="text-lg font-semibold mb-5">Navigate to solutions: </h1><ul class="inline-flex -space-x-px overflow-auto"><li class="pagination-solution-item"><span data-id="#solution1" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">1</span></li><li class="pagination-solution-item"><span data-id="#solution2" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">2</span></li><li class="pagination-solution-item"><span data-id="#solution3" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">3</span></li><li class="pagination-solution-item"><span data-id="#solution4" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">4</span></li><li class="pagination-solution-item"><span data-id="#solution5" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">5</span></li><li class="pagination-solution-item"><span data-id="#solution6" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">6</span></li><li class="pagination-solution-item"><span data-id="#solution7" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">7</span></li><li class="pagination-solution-item"><span data-id="#solution8" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">8</span></li><li class="pagination-solution-item"><span data-id="#solution9" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">9</span></li><li class="pagination-solution-item"><span data-id="#solution10" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">10</span></li><li class="pagination-solution-item"><span data-id="#solution11" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">11</span></li><li class="pagination-solution-item"><span data-id="#solution12" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">12</span></li><li class="pagination-solution-item"><span data-id="#solution13" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">13</span></li><li class="pagination-solution-item"><span data-id="#solution14" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">14</span></li><li class="pagination-solution-item"><span data-id="#solution15" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">15</span></li><li class="pagination-solution-item"><span data-id="#solution16" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">16</span></li><li class="pagination-solution-item"><span data-id="#solution17" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">17</span></li><li class="pagination-solution-item"><span data-id="#solution18" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">18</span></li><li class="pagination-solution-item"><span data-id="#solution19" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">19</span></li><li class="pagination-solution-item"><span data-id="#solution20" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">20</span></li><li class="pagination-solution-item"><span data-id="#solution21" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">21</span></li><li class="pagination-solution-item"><span data-id="#solution22" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">22</span></li><li class="pagination-solution-item"><span data-id="#solution23" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">23</span></li><li class="pagination-solution-item"><span data-id="#solution24" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">24</span></li><li class="pagination-solution-item"><span data-id="#solution25" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">25</span></li><li class="pagination-solution-item"><span data-id="#solution26" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">26</span></li><li class="pagination-solution-item"><span data-id="#solution27" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">27</span></li><li class="pagination-solution-item"><span data-id="#solution28" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">28</span></li><li class="pagination-solution-item"><span data-id="#solution29" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">29</span></li><li class="pagination-solution-item"><span data-id="#solution30" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">30</span></li></ul></nav><div id="solution1" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 1</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/equality-operator">equality-operator</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/identity-operator">identity-operator</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>The strict equality operator (<code>===</code>) behaves identically to the abstract equality operator (<code>==</code>) except no type conversion is done, and the types must be the same to be considered equal.</p>

<p>Reference: <a href="http://www.c-point.com/javascript_tutorial/jsgrpComparison.htm" rel="noreferrer">Javascript Tutorial: Comparison Operators</a></p>

<p>The <code>==</code> operator will compare for equality <em>after doing any necessary type conversions</em>.  The <code>===</code> operator will <strong>not</strong> do the conversion, so if two values are not the same type <code>===</code> will simply return <code>false</code>. Both are equally quick.</p>

<p>To quote Douglas Crockford's excellent <a href="https://rads.stackoverflow.com/amzn/click/com/0596517742" rel="noreferrer">JavaScript: The Good Parts</a>,</p>

<blockquote>
  <p>JavaScript has two sets of equality operators: <code>===</code> and <code>!==</code>, and their evil twins <code>==</code> and <code>!=</code>.  The good ones work the way you would expect.  If the two operands are of the same type and have the same value, then <code>===</code> produces <code>true</code> and <code>!==</code> produces <code>false</code>.  The evil twins do the right thing when the operands are of the same type, but if they are of different types, they attempt to coerce the values.  the rules by which they do that are complicated and unmemorable.  These are some of the interesting cases:</p>

<pre class="lang-js s-code-block"><code class="hljs language-javascript"><span class="hljs-string">''</span> == <span class="hljs-string">'0'</span>           <span class="hljs-comment">// false</span>
<span class="hljs-number">0</span> == <span class="hljs-string">''</span>             <span class="hljs-comment">// true</span>
<span class="hljs-number">0</span> == <span class="hljs-string">'0'</span>            <span class="hljs-comment">// true</span>

<span class="hljs-literal">false</span> == <span class="hljs-string">'false'</span>    <span class="hljs-comment">// false</span>
<span class="hljs-literal">false</span> == <span class="hljs-string">'0'</span>        <span class="hljs-comment">// true</span>

<span class="hljs-literal">false</span> == <span class="hljs-literal">undefined</span>  <span class="hljs-comment">// false</span>
<span class="hljs-literal">false</span> == <span class="hljs-literal">null</span>       <span class="hljs-comment">// false</span>
<span class="hljs-literal">null</span> == <span class="hljs-literal">undefined</span>   <span class="hljs-comment">// true</span>

<span class="hljs-string">' \t\r\n '</span> == <span class="hljs-number">0</span>     <span class="hljs-comment">// true</span>
</code></pre>
</blockquote>

<p><a href="https://i.stack.imgur.com/yISob.png" rel="noreferrer"><img src="https://i.stack.imgur.com/yISob.png" alt="Equality Comparison Table "></a></p>

<blockquote>
  <p>The lack of transitivity is alarming.  My advice is to never use the evil twins.  Instead, always use <code>===</code> and <code>!==</code>.  All of the comparisons just shown produce <code>false</code> with the <code>===</code> operator.</p>
</blockquote>

<hr>

<h3>Update:</h3>

<p>A good point was brought up by <a href="https://stackoverflow.com/users/165495/casebash">@Casebash</a> in the comments and in <a href="https://stackoverflow.com/users/113570/philippe-leybaert">@Phillipe Laybaert's</a> <a href="https://stackoverflow.com/a/957602/1288">answer</a> concerning objects.  For objects, <code>==</code> and <code>===</code> act consistently with one another (except in a special case).</p>

<pre class="lang-js s-code-block"><code class="hljs language-javascript"><span class="hljs-keyword">var</span> a = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>];
<span class="hljs-keyword">var</span> b = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>];

<span class="hljs-keyword">var</span> c = { <span class="hljs-attr">x</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">y</span>: <span class="hljs-number">2</span> };
<span class="hljs-keyword">var</span> d = { <span class="hljs-attr">x</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">y</span>: <span class="hljs-number">2</span> };

<span class="hljs-keyword">var</span> e = <span class="hljs-string">"text"</span>;
<span class="hljs-keyword">var</span> f = <span class="hljs-string">"te"</span> + <span class="hljs-string">"xt"</span>;

a == b            <span class="hljs-comment">// false</span>
a === b           <span class="hljs-comment">// false</span>

c == d            <span class="hljs-comment">// false</span>
c === d           <span class="hljs-comment">// false</span>

e == f            <span class="hljs-comment">// true</span>
e === f           <span class="hljs-comment">// true</span>
</code></pre>

<p>The special case is when you compare a primitive with an object that evaluates to the same primitive, due to its <code>toString</code> or <code>valueOf</code> method. For example, consider the comparison of a string primitive with a string object created using the <code>String</code> constructor.</p>

<pre class="lang-js s-code-block"><code class="hljs language-javascript"><span class="hljs-string">"abc"</span> == <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">"abc"</span>)    <span class="hljs-comment">// true</span>
<span class="hljs-string">"abc"</span> === <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">"abc"</span>)   <span class="hljs-comment">// false</span>
</code></pre>

<p>Here the <code>==</code> operator is checking the values of the two objects and returning <code>true</code>, but the <code>===</code> is seeing that they're not the same type and returning <code>false</code>.  Which one is correct?  That really depends on what you're trying to compare.  My advice is to bypass the question entirely and just don't use the <code>String</code> constructor to create string objects from string literals.</p>

<p><strong>Reference</strong><br>
<a href="http://www.ecma-international.org/ecma-262/5.1/#sec-11.9.3" rel="noreferrer">http://www.ecma-international.org/ecma-262/5.1/#sec-11.9.3</a></p>
    </div></div></div></div><div id="solution2" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 2</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/equality-operator">equality-operator</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/identity-operator">identity-operator</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Using the <code>==</code> operator (<em>Equality</em>)</p>
<pre class="lang-js s-code-block"><code class="hljs language-javascript"><span class="hljs-literal">true</span> == <span class="hljs-number">1</span>; <span class="hljs-comment">//true, because 'true' is converted to 1 and then compared</span>
<span class="hljs-string">"2"</span> == <span class="hljs-number">2</span>;  <span class="hljs-comment">//true, because "2" is converted to 2 and then compared</span>
</code></pre>
<p>Using the <code>===</code> operator (<em>Identity</em>)</p>
<pre class="lang-js s-code-block"><code class="hljs language-javascript"><span class="hljs-literal">true</span> === <span class="hljs-number">1</span>; <span class="hljs-comment">//false</span>
<span class="hljs-string">"2"</span> === <span class="hljs-number">2</span>;  <span class="hljs-comment">//false</span>
</code></pre>
<p>This is because the <strong>equality operator <code>==</code> does type coercion</strong>, meaning that the interpreter implicitly tries to convert the values before comparing.</p>
<p>On the other hand, the <strong>identity operator <code>===</code> does not do type coercion</strong>, and thus does not convert the values when comparing.</p>
    </div></div></div></div><div id="solution3" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 3</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/equality-operator">equality-operator</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/identity-operator">identity-operator</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Here's an interesting visualisation of the equality comparison between <code>==</code> and <code>===</code>.</p>
<p><strong>Source: <a href="https://github.com/dorey/JavaScript-Equality-Table" rel="noreferrer">https://github.com/dorey/JavaScript-Equality-Table</a></strong> (<a href="https://dorey.github.io/JavaScript-Equality-Table/" rel="noreferrer">demo</a>, <a href="https://dorey.github.io/JavaScript-Equality-Table/unified/" rel="noreferrer">unified demo</a>)</p>
<hr>
<h2><code>var1 === var2</code></h2>
<p>When using <code>===</code> for JavaScript equality testing, everything is as is.<br>
Nothing gets converted before being evaluated.</p>
<p><img src="https://i.stack.imgur.com/62vxI.png" alt="Equality evaluation of === in JS"></p>
<h2><code>var1 == var2</code></h2>
<p>When using <code>==</code> for JavaScript equality testing, some <em><strong>funky conversions</strong></em> take place.</p>
<p><img src="https://i.stack.imgur.com/35MpY.png" alt="Equality evaluation of == in JS"></p>
<h3>Summary of equality in Javascript</h3>
<p><img src="https://i.stack.imgur.com/FX7z1.png" alt="Equality in Javascript"></p>
<hr>
<h3>Conclusion:</h3>
<p><strong>Always use <code>===</code></strong>, unless you fully understand the <a href="https://dorey.github.io/JavaScript-Equality-Table/#two-equals" rel="noreferrer">funky conversions</a> that take place with <code>==</code>.</p>
    </div></div></div></div><div id="solution4" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 4</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/equality-operator">equality-operator</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/identity-operator">identity-operator</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>In the answers here, I didn't read anything about what <strong>equal</strong> means. Some will say that <code>===</code> means <strong>equal and of the same type</strong>, but that's not really true. It actually means that <strong>both operands reference the same object</strong>, or in case of <strong>value types, have the same value</strong>.</p>
<p>So, let's take the following code:</p>
<pre class="lang-js s-code-block"><code class="hljs language-javascript"><span class="hljs-keyword">var</span> a = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>];
<span class="hljs-keyword">var</span> b = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>];
<span class="hljs-keyword">var</span> c = a;

<span class="hljs-keyword">var</span> ab_eq = (a === b); <span class="hljs-comment">// false (even though a and b are the same type)</span>
<span class="hljs-keyword">var</span> ac_eq = (a === c); <span class="hljs-comment">// true</span>
</code></pre>
<p>The same here:</p>
<pre class="lang-js s-code-block"><code class="hljs language-javascript"><span class="hljs-keyword">var</span> a = { <span class="hljs-attr">x</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">y</span>: <span class="hljs-number">2</span> };
<span class="hljs-keyword">var</span> b = { <span class="hljs-attr">x</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">y</span>: <span class="hljs-number">2</span> };
<span class="hljs-keyword">var</span> c = a;

<span class="hljs-keyword">var</span> ab_eq = (a === b); <span class="hljs-comment">// false (even though a and b are the same type)</span>
<span class="hljs-keyword">var</span> ac_eq = (a === c); <span class="hljs-comment">// true</span>
</code></pre>
<p>Or even:</p>
<pre class="lang-js s-code-block"><code class="hljs language-javascript"><span class="hljs-keyword">var</span> a = { };
<span class="hljs-keyword">var</span> b = { };
<span class="hljs-keyword">var</span> c = a;

<span class="hljs-keyword">var</span> ab_eq = (a === b); <span class="hljs-comment">// false (even though a and b are the same type)</span>
<span class="hljs-keyword">var</span> ac_eq = (a === c); <span class="hljs-comment">// true</span>
</code></pre>
<p>This behavior is not always obvious. There's more to the story than being equal and being of the same type.</p>
<p>The rule is:</p>
<p><em><strong>For value types (numbers):</strong></em><br>
<code>a === b</code> returns true if <code>a</code> and <code>b</code> have the same value and are of the same type</p>
<p><em><strong>For reference types:</strong></em><br>
<code>a === b</code> returns true if <code>a</code> and <code>b</code> reference the exact same object</p>
<p><em><strong>For strings:</strong></em><br>
<code>a === b</code> returns true if <code>a</code> and <code>b</code> are both strings and contain the exact same characters</p>
<hr>
<h2>Strings: the special case...</h2>
<p>Strings are not value types, but in Javascript they behave like value types, so they will be "equal" when the characters in the string are the same and when they are of the same length (as explained in the third rule)</p>
<p>Now it becomes interesting:</p>
<pre class="lang-js s-code-block"><code class="hljs language-javascript"><span class="hljs-keyword">var</span> a = <span class="hljs-string">"12"</span> + <span class="hljs-string">"3"</span>;
<span class="hljs-keyword">var</span> b = <span class="hljs-string">"123"</span>;

<span class="hljs-title function_">alert</span>(a === b); <span class="hljs-comment">// returns true, because strings behave like value types</span>
</code></pre>
<p>But how about this?:</p>
<pre class="lang-js s-code-block"><code class="hljs language-javascript"><span class="hljs-keyword">var</span> a = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">"123"</span>);
<span class="hljs-keyword">var</span> b = <span class="hljs-string">"123"</span>;

<span class="hljs-title function_">alert</span>(a === b); <span class="hljs-comment">// returns false !! (but they are equal and of the same type)</span>
</code></pre>
<p>I thought strings behave like value types? Well, it depends who you ask... In this case a and b are not the same type. <code>a</code> is of type <code>Object</code>, while <code>b</code> is of type <code>string</code>. Just remember that creating a string object using the <code>String</code> constructor creates something of type <code>Object</code> that behaves as a string <em>most of the time</em>.</p>
    </div></div></div></div><div id="solution5" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 5</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/equality-operator">equality-operator</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/identity-operator">identity-operator</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Let me add this counsel:</p>
<p><em><strong>If in doubt, read the <a href="http://www.ecma-international.org/publications/standards/Ecma-262.htm" rel="noreferrer">specification</a>!</strong></em></p>
<p>ECMA-262 is the specification for a scripting language of which JavaScript is a dialect. Of course in practice it matters more how the most important browsers behave than an esoteric definition of how something is supposed to be handled. But it is helpful to understand why <strong>new String("a") !== "a"</strong>.</p>
<p>Please let me explain how to read the specification to clarify this question. I see that in this very old topic nobody had an answer for the very strange effect. So, if you can read a specification, this will help you in your profession tremendously. It is an acquired skill. So, let's continue.</p>
<p>Searching the PDF file for === brings me to page 56 of the specification: <strong>11.9.4. The Strict Equals Operator ( === )</strong>, and after wading through the specificationalese I find:</p>
<blockquote>
<p><strong>11.9.6 The Strict Equality Comparison Algorithm</strong><br>
The comparison x === y, where x and y are values, produces <strong>true</strong> or <strong>false</strong>. Such a comparison is performed as follows:<br>
&nbsp;&nbsp;1. If Type(x) is different from Type(y), return <strong>false</strong>.<br>
&nbsp;&nbsp;2. If Type(x) is Undefined, return <strong>true</strong>.<br>
&nbsp;&nbsp;3. If Type(x) is Null, return <strong>true</strong>.<br>
&nbsp;&nbsp;4. If Type(x) is not Number, go to step 11.<br>
&nbsp;&nbsp;5. If x is <strong>NaN</strong>, return <strong>false</strong>.<br>
&nbsp;&nbsp;6. If y is <strong>NaN</strong>, return <strong>false</strong>.<br>
&nbsp;&nbsp;7. If x is the same number value as y, return <strong>true</strong>.<br>
&nbsp;&nbsp;8. If x is +0 and y is 0, return <strong>true</strong>.<br>
&nbsp;&nbsp;9. If x is 0 and y is +0, return <strong>true</strong>.<br>
&nbsp;&nbsp;10. Return <strong>false</strong>.<br>
&nbsp;&nbsp;11. If Type(x) is String, then return <strong>true</strong> if x and y are exactly the same sequence of characters (same length and same characters in corresponding positions); otherwise, return <strong>false</strong>.<br>
&nbsp;&nbsp;12. If Type(x) is Boolean, return <strong>true</strong> if x and y are both <strong>true</strong> or both <strong>false</strong>; otherwise, return <strong>false</strong>.<br>
&nbsp;&nbsp;13. Return <strong>true</strong> if x and y refer to the same object or if they refer to objects joined to each other (see 13.1.2). Otherwise, return <strong>false</strong>.</p>
</blockquote>
<p>Interesting is step 11. Yes, strings are treated as value types. But this does not explain why <strong>new String("a") !== "a"</strong>. Do we have a browser not conforming to ECMA-262?</p>
<p>Not so fast!</p>
<p>Let's check the types of the operands. Try it out for yourself by wrapping them in <strong>typeof()</strong>. I find that <strong>new String("a")</strong> is an object, and step 1 is used: return <strong>false</strong> if the types are different.</p>
<p>If you wonder why <strong>new String("a")</strong> does not return a string, how about some exercise reading a specification? Have fun!</p>
<hr>
<p>Aidiakapi wrote this in a comment below:</p>
<blockquote>
<p>From the specification</p>
<p><strong>11.2.2 The new Operator</strong>:</p>
<p>If Type(constructor) is not Object, throw a TypeError exception.</p>
<p>With other words, if String wouldn't be of type Object it couldn't be used with the new operator.</p>
</blockquote>
<p><strong>new</strong> always returns an Object, even for <strong>String</strong> constructors, too. And alas! The value semantics for strings (see step 11) is lost.</p>
<p>And this finally means: <strong>new String("a") !== "a"</strong>.</p>
    </div></div></div></div><div id="solution6" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 6</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/equality-operator">equality-operator</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/identity-operator">identity-operator</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>I tested this in Firefox with <a href="http://en.wikipedia.org/wiki/Firebug_%28software%29" rel="noreferrer">Firebug</a> using code like this:</p>
<p></p><div class="snippet" data-lang="js" data-hide="false" data-console="true" data-babel="false">
<div class="snippet-code">
<pre class="snippet-code-js lang-js s-code-block"><code class="hljs language-javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">time</span>(<span class="hljs-string">"testEquality"</span>);
<span class="hljs-keyword">var</span> n = <span class="hljs-number">0</span>;
<span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) {
  n++;
  <span class="hljs-keyword">if</span> (n == <span class="hljs-number">100000</span>)
    <span class="hljs-keyword">break</span>;
}
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">timeEnd</span>(<span class="hljs-string">"testEquality"</span>);</code></pre>
<div class="snippet-result"><div class="snippet-ctas"><button type="button" class="s-btn s-btn__primary"><span class="icon-play-white _hover"></span><span> Run code snippet</span></button><input class="copySnippet s-btn s-btn__filled" type="button" value="Copy snippet to answer" style="display: none;"><button type="button" class="s-btn hideResults" style="display: none;">Hide results</button><div class="popout-code"><a class="snippet-expand-link">Expand snippet</a></div></div><div class="snippet-result-code" style="display: none;"><iframe name="sif1" sandbox="allow-forms allow-modals allow-scripts" class="snippet-box-edit snippet-box-result" frameborder="0"></iframe></div></div></div>
</div>
<p></p>
<p>and</p>
<p></p><div class="snippet" data-lang="js" data-hide="false" data-console="true" data-babel="false">
<div class="snippet-code">
<pre class="snippet-code-js lang-js s-code-block"><code class="hljs language-javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">time</span>(<span class="hljs-string">"testTypeEquality"</span>);
<span class="hljs-keyword">var</span> n = <span class="hljs-number">0</span>;
<span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) {
  n++;
  <span class="hljs-keyword">if</span> (n === <span class="hljs-number">100000</span>)
    <span class="hljs-keyword">break</span>;
}
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">timeEnd</span>(<span class="hljs-string">"testTypeEquality"</span>);</code></pre>
<div class="snippet-result"><div class="snippet-ctas"><button type="button" class="s-btn s-btn__primary"><span class="icon-play-white _hover"></span><span> Run code snippet</span></button><input class="copySnippet s-btn s-btn__filled" type="button" value="Copy snippet to answer" style="display: none;"><button type="button" class="s-btn hideResults" style="display: none;">Hide results</button><div class="popout-code"><a class="snippet-expand-link">Expand snippet</a></div></div><div class="snippet-result-code" style="display: none;"><iframe name="sif2" sandbox="allow-forms allow-modals allow-scripts" class="snippet-box-edit snippet-box-result" frameborder="0"></iframe></div></div></div>
</div>
<p></p>
<p>My results (tested five times each and averaged):</p>
<pre class="lang-js s-code-block"><code class="hljs language-javascript">==: <span class="hljs-number">115.2</span>
===: <span class="hljs-number">114.4</span>
</code></pre>
<p>So I'd say that the miniscule difference (this is over 100000 iterations, remember) is negligible. Performance <em><strong>isn't</strong></em> a reason to do <code>===</code>. Type safety (well, as safe as you're going to get in JavaScript), and code quality is.</p>
    </div></div></div></div><div id="solution7" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 7</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/equality-operator">equality-operator</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/identity-operator">identity-operator</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>In PHP and JavaScript, it is a strict equality operator. Which means, it will compare both type and values.</p>
    </div></div></div></div><div id="solution8" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 8</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/equality-operator">equality-operator</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/identity-operator">identity-operator</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>In JavaScript it means of the same value and type.</p>

<p>For example,</p>

<pre class="lang-js s-code-block"><code class="hljs language-javascript"><span class="hljs-number">4</span> == <span class="hljs-string">"4"</span> <span class="hljs-comment">// will return true</span>
</code></pre>

<p>but</p>

<pre class="lang-js s-code-block"><code class="hljs language-javascript"><span class="hljs-number">4</span> === <span class="hljs-string">"4"</span> <span class="hljs-comment">// will return false </span>
</code></pre>
    </div></div></div></div><div id="solution9" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 9</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/equality-operator">equality-operator</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/identity-operator">identity-operator</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p><strong>Why <code>==</code> is so unpredictable?</strong></p>

<p>What do you get when you compare an empty string <code>""</code> with the number zero <code>0</code>?</p>

<p><code>true</code></p>

<p>Yep, that's right according to <code>==</code> an empty string and the number zero are the same time.</p>

<p>And it doesn't end there, here's another one:</p>

<pre class="lang-js s-code-block"><code class="hljs language-javascript"><span class="hljs-string">'0'</span> == <span class="hljs-literal">false</span> <span class="hljs-comment">// true</span>
</code></pre>

<p><strong>Things get really weird with arrays.</strong></p>

<pre class="lang-js s-code-block"><code class="hljs language-javascript">[<span class="hljs-number">1</span>] == <span class="hljs-literal">true</span> <span class="hljs-comment">// true</span>
[] == <span class="hljs-literal">false</span> <span class="hljs-comment">// true</span>
[[]] == <span class="hljs-literal">false</span> <span class="hljs-comment">// true</span>
[<span class="hljs-number">0</span>] == <span class="hljs-literal">false</span> <span class="hljs-comment">// true</span>
</code></pre>

<p><strong>Then weirder with strings</strong></p>

<pre class="lang-js s-code-block"><code class="hljs language-javascript">[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>] == <span class="hljs-string">'1,2,3'</span> <span class="hljs-comment">// true - REALLY?!</span>
<span class="hljs-string">'\r\n\t'</span> == <span class="hljs-number">0</span> <span class="hljs-comment">// true - Come on!</span>
</code></pre>

<p>It get's worse:</p>

<p><strong>When is equal not equal?</strong></p>

<pre class="lang-js s-code-block"><code class="hljs language-javascript"><span class="hljs-keyword">let</span> A = <span class="hljs-string">''</span>  <span class="hljs-comment">// empty string</span>
<span class="hljs-keyword">let</span> B = <span class="hljs-number">0</span>   <span class="hljs-comment">// zero</span>
<span class="hljs-keyword">let</span> C = <span class="hljs-string">'0'</span> <span class="hljs-comment">// zero string</span>

A == B <span class="hljs-comment">// true - ok... </span>
B == C <span class="hljs-comment">// true - so far so good...</span>
A == C <span class="hljs-comment">// **FALSE** - Plot twist!</span>
</code></pre>

<p>Let me say that again:</p>

<pre class="lang-js s-code-block"><code class="hljs language-javascript">(A == B) &amp;&amp; (B == C) <span class="hljs-comment">// true</span>
(A == C) <span class="hljs-comment">// **FALSE**</span>
</code></pre>

<p>And this is just the crazy stuff you get with primitives.</p>

<p>It's a whole new level of crazy when you use <code>==</code> with objects.</p>

<p>At this point your probably wondering...</p>

<p><strong>Why does this happen?</strong></p>

<p>Well it's because unlike "triple equals" (<code>===</code>) which just checks if two values are the same.</p>

<p><code>==</code> does a <strong><em>whole bunch of other stuff</em></strong>.</p>

<p>It has special handling for functions, special handling for nulls, undefined, strings, you name it.</p>

<p>It get's pretty wacky.</p>

<p>In fact, if you tried to write a function that does what <code>==</code> does it would look something like this:</p>

<pre class="lang-js s-code-block"><code class="hljs language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">isEqual</span>(<span class="hljs-params">x, y</span>) { <span class="hljs-comment">// if `==` were a function</span>
    <span class="hljs-keyword">if</span>(<span class="hljs-keyword">typeof</span> y === <span class="hljs-keyword">typeof</span> x) <span class="hljs-keyword">return</span> y === x;
    <span class="hljs-comment">// treat null and undefined the same</span>
    <span class="hljs-keyword">var</span> xIsNothing = (y === <span class="hljs-literal">undefined</span>) || (y === <span class="hljs-literal">null</span>);
    <span class="hljs-keyword">var</span> yIsNothing = (x === <span class="hljs-literal">undefined</span>) || (x === <span class="hljs-literal">null</span>);

    <span class="hljs-keyword">if</span>(xIsNothing || yIsNothing) <span class="hljs-keyword">return</span> (xIsNothing &amp;&amp; yIsNothing);

    <span class="hljs-keyword">if</span>(<span class="hljs-keyword">typeof</span> y === <span class="hljs-string">"function"</span> || <span class="hljs-keyword">typeof</span> x === <span class="hljs-string">"function"</span>) {
        <span class="hljs-comment">// if either value is a string </span>
        <span class="hljs-comment">// convert the function into a string and compare</span>
        <span class="hljs-keyword">if</span>(<span class="hljs-keyword">typeof</span> x === <span class="hljs-string">"string"</span>) {
            <span class="hljs-keyword">return</span> x === y.<span class="hljs-title function_">toString</span>();
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(<span class="hljs-keyword">typeof</span> y === <span class="hljs-string">"string"</span>) {
            <span class="hljs-keyword">return</span> x.<span class="hljs-title function_">toString</span>() === y;
        } 
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    }

    <span class="hljs-keyword">if</span>(<span class="hljs-keyword">typeof</span> x === <span class="hljs-string">"object"</span>) x = <span class="hljs-title function_">toPrimitive</span>(x);
    <span class="hljs-keyword">if</span>(<span class="hljs-keyword">typeof</span> y === <span class="hljs-string">"object"</span>) y = <span class="hljs-title function_">toPrimitive</span>(y);
    <span class="hljs-keyword">if</span>(<span class="hljs-keyword">typeof</span> y === <span class="hljs-keyword">typeof</span> x) <span class="hljs-keyword">return</span> y === x;

    <span class="hljs-comment">// convert x and y into numbers if they are not already use the "+" trick</span>
    <span class="hljs-keyword">if</span>(<span class="hljs-keyword">typeof</span> x !== <span class="hljs-string">"number"</span>) x = +x;
    <span class="hljs-keyword">if</span>(<span class="hljs-keyword">typeof</span> y !== <span class="hljs-string">"number"</span>) y = +y;
    <span class="hljs-comment">// actually the real `==` is even more complicated than this, especially in ES6</span>
    <span class="hljs-keyword">return</span> x === y;
}

<span class="hljs-keyword">function</span> <span class="hljs-title function_">toPrimitive</span>(<span class="hljs-params">obj</span>) {
    <span class="hljs-keyword">var</span> value = obj.<span class="hljs-title function_">valueOf</span>();
    <span class="hljs-keyword">if</span>(obj !== value) <span class="hljs-keyword">return</span> value;
    <span class="hljs-keyword">return</span> obj.<span class="hljs-title function_">toString</span>();
}
</code></pre>

<p><strong>So what does this mean?</strong></p>

<p>It means <code>==</code> is complicated.</p>

<p>Because it's complicated it's hard to know what's going to happen when you use it.</p>

<p>Which means you could end up with bugs.</p>

<p><strong>So the moral of the story is...</strong></p>

<p>Make your life less complicated.</p>

<p>Use <code>===</code> instead of <code>==</code>.</p>

<p>The End.</p>
    </div></div></div></div><div id="solution10" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 10</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/equality-operator">equality-operator</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/identity-operator">identity-operator</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>The <strong>===</strong> operator is called a strict comparison operator, it <strong>does</strong> differ from the <strong>==</strong> operator.</p>

<p>Lets take 2 vars a and b.</p>

<p>For <strong>"a == b"</strong> to evaluate to true a and b need to be the <strong>same value</strong>.</p>

<p>In the case of <strong>"a === b"</strong> a and b must be the <strong>same value</strong> and also the <strong>same type</strong> for it to evaluate to true.  </p>

<p>Take the following example</p>

<pre class="lang-js s-code-block"><code class="hljs language-javascript"><span class="hljs-keyword">var</span> a = <span class="hljs-number">1</span>;
<span class="hljs-keyword">var</span> b = <span class="hljs-string">"1"</span>;

<span class="hljs-keyword">if</span> (a == b) <span class="hljs-comment">//evaluates to true as a and b are both 1</span>
{
    <span class="hljs-title function_">alert</span>(<span class="hljs-string">"a == b"</span>);
}

<span class="hljs-keyword">if</span> (a === b) <span class="hljs-comment">//evaluates to false as a is not the same type as b</span>
{
    <span class="hljs-title function_">alert</span>(<span class="hljs-string">"a === b"</span>);
}
</code></pre>

<p><strong>In summary</strong>; using the <strong>==</strong> operator might evaluate to true in situations where you do not want it to so using the <strong>===</strong> operator would be safer.  </p>

<p>In the 90% usage scenario it won't matter which one you use, but it is handy to know the difference when you get some unexpected behaviour one day.</p>
    </div></div></div></div><div id="solution11" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 11</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/equality-operator">equality-operator</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/identity-operator">identity-operator</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<h1><code>===</code> checks same sides are equal in <em>type</em> as well as <em>value</em>.</h1>
<hr>
<h2>Example:</h2>
<pre class="lang-js s-code-block"><code class="hljs language-javascript"><span class="hljs-string">'1'</span> === <span class="hljs-number">1</span> <span class="hljs-comment">// will return "false" because `string` is not a `number`</span>
</code></pre>
<h2>Common example:</h2>
<pre class="lang-js s-code-block"><code class="hljs language-javascript"><span class="hljs-number">0</span> == <span class="hljs-string">''</span>  <span class="hljs-comment">// will be "true", but it's very common to want this check to be "false"</span>
</code></pre>
<h2>Another common example:</h2>
<pre class="lang-js s-code-block"><code class="hljs language-javascript"><span class="hljs-literal">null</span> == <span class="hljs-literal">undefined</span> <span class="hljs-comment">// returns "true", but in most cases a distinction is necessary</span>
</code></pre>
<hr>
<p>Many times an <em>untyped</em> check would be handy because you do not care if the value is either <code>undefined</code>, <code>null</code>, <code>0</code>  or <code>""</code></p>
    </div></div></div></div><div id="solution12" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 12</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/equality-operator">equality-operator</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/identity-operator">identity-operator</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Javascript execution flow diagram for strict equality / Comparison '==='</p>

<p><a href="https://i.stack.imgur.com/A27Be.png"><img src="https://i.stack.imgur.com/A27Be.png" alt="Javascript strict equality"></a></p>

<p>Javascript execution flow diagram for non strict equality / comparison '=='</p>

<p><a href="https://i.stack.imgur.com/Ccyb8.png"><img src="https://i.stack.imgur.com/Ccyb8.png" alt="Javascript non equality"></a></p>
    </div></div></div></div><div id="solution13" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 13</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/equality-operator">equality-operator</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/identity-operator">identity-operator</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>JavaScript <code>===</code> <strong>vs</strong> <code>==</code> .</p>

<pre class="lang-js s-code-block"><code class="hljs language-javascript"><span class="hljs-number">0</span>==<span class="hljs-literal">false</span>   <span class="hljs-comment">// true</span>
<span class="hljs-number">0</span>===<span class="hljs-literal">false</span>  <span class="hljs-comment">// false, because they are of a different type</span>
<span class="hljs-number">1</span>==<span class="hljs-string">"1"</span>     <span class="hljs-comment">// true, auto type coercion</span>
<span class="hljs-number">1</span>===<span class="hljs-string">"1"</span>    <span class="hljs-comment">// false, because they are of a different type</span>
</code></pre>
    </div></div></div></div><div id="solution14" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 14</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/equality-operator">equality-operator</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/identity-operator">identity-operator</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>It means <strong>equality without type coercion</strong>
type coercion means JavaScript do not automatically convert any other data types to string data types </p>

<pre class="lang-js s-code-block"><code class="hljs language-javascript"><span class="hljs-number">0</span>==<span class="hljs-literal">false</span>   <span class="hljs-comment">// true,although they are different types</span>

<span class="hljs-number">0</span>===<span class="hljs-literal">false</span>  <span class="hljs-comment">// false,as they are different types</span>

<span class="hljs-number">2</span>==<span class="hljs-string">'2'</span>    <span class="hljs-comment">//true,different types,one is string and another is integer but </span>
            javaScript convert <span class="hljs-number">2</span> to string by using == operator 

<span class="hljs-number">2</span>===<span class="hljs-string">'2'</span>  <span class="hljs-comment">//false because by using === operator ,javaScript do not convert </span>
           integer to string 

<span class="hljs-number">2</span>===<span class="hljs-number">2</span>   <span class="hljs-comment">//true because both have same value and same types </span>
</code></pre>
    </div></div></div></div><div id="solution15" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 15</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/equality-operator">equality-operator</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/identity-operator">identity-operator</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>In a typical script there will be no performance difference. More important may be the fact that thousand "===" is 1&nbsp;KB heavier than thousand "==" :) <a href="https://stackoverflow.com/questions/tagged/javascript+performance">JavaScript profilers</a> can tell you if there is a performance difference in your case.</p>

<p>But personally I would do what JSLint suggests. This recommendation is there not because of performance issues, but because type coercion means <code>('\t\r\n' == 0)</code> is true.</p>
    </div></div></div></div><div id="solution16" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 16</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/equality-operator">equality-operator</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/identity-operator">identity-operator</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p><em><strong>The equal comparison operator == is confusing and should be avoided.</strong></em> </p>

<p>If you <strong>HAVE TO</strong> live with it, then remember the following 3 things: </p>

<ol>
<li><strong>It is not transitive: <em>(a == b)</em> and <em>(b == c)</em> does not lead to <em>(a == c)</em></strong></li>
<li><strong>It's mutually exclusive to its negation: <em>(a == b)</em> and <em>(a != b)</em> always hold opposite Boolean values, with all a and b.</strong></li>
<li><strong>In case of doubt, learn by heart the following truth table:</strong></li>
</ol>

<p>EQUAL OPERATOR TRUTH TABLE IN JAVASCRIPT</p>

<ul>
<li>Each row in the table is a set of 3 mutually "equal" values, meaning that any 2 values among them are equal using the equal == sign*</li>
</ul>

<p>** STRANGE: note that any two values on the first column are not equal in that sense.**</p>

<pre class="lang-js s-code-block"><code class="hljs language-javascript"><span class="hljs-string">''</span>       == <span class="hljs-number">0</span> == <span class="hljs-literal">false</span>   <span class="hljs-comment">// Any two values among these 3 ones are equal with the == operator</span>
<span class="hljs-string">'0'</span>      == <span class="hljs-number">0</span> == <span class="hljs-literal">false</span>   <span class="hljs-comment">// Also a set of 3 equal values, note that only 0 and false are repeated</span>
<span class="hljs-string">'\t'</span>     == <span class="hljs-number">0</span> == <span class="hljs-literal">false</span>   <span class="hljs-comment">// -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --</span>
<span class="hljs-string">'\r'</span>     == <span class="hljs-number">0</span> == <span class="hljs-literal">false</span>   <span class="hljs-comment">// -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --</span>
<span class="hljs-string">'\n'</span>     == <span class="hljs-number">0</span> == <span class="hljs-literal">false</span>   <span class="hljs-comment">// -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --</span>
<span class="hljs-string">'\t\r\n'</span> == <span class="hljs-number">0</span> == <span class="hljs-literal">false</span>   <span class="hljs-comment">// -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --</span>

<span class="hljs-literal">null</span> == <span class="hljs-literal">undefined</span>  <span class="hljs-comment">// These two "default" values are not-equal to any of the listed values above</span>
<span class="hljs-title class_">NaN</span>                <span class="hljs-comment">// NaN is not equal to any thing, even to itself.</span>
</code></pre>
    </div></div></div></div><div id="solution17" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 17</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/equality-operator">equality-operator</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/identity-operator">identity-operator</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>There is unlikely to be any performance difference between the two operations in your usage. There is no type-conversion to be done because both parameters are already the same type. Both operations will have a type comparison followed by a value comparison.</p>
    </div></div></div></div><div id="solution18" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 18</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/equality-operator">equality-operator</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/identity-operator">identity-operator</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p><strong>Yes!</strong> It does matter.</p>

<p><code>===</code> operator in javascript <strong>checks value as well as type</strong> where as <code>==</code> operator just checks <strong>the value (does type conversion if required)</strong>.</p>

<p><img src="https://i.stack.imgur.com/5ttlR.png" alt="enter image description here"></p>

<p>You can easily test it. Paste following code in an HTML file and open it in browser</p>

<pre class="lang-js s-code-block"><code class="hljs language-javascript">&lt;script&gt;

<span class="hljs-keyword">function</span> <span class="hljs-title function_">onPageLoad</span>(<span class="hljs-params"></span>)
{
    <span class="hljs-keyword">var</span> x = <span class="hljs-string">"5"</span>;
    <span class="hljs-keyword">var</span> y = <span class="hljs-number">5</span>;
    <span class="hljs-title function_">alert</span>(x === <span class="hljs-number">5</span>);
};

&lt;/script&gt;

&lt;/head&gt;

<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">body</span> <span class="hljs-attr">onload</span>=<span class="hljs-string">'onPageLoad();'</span>&gt;</span>
</span></code></pre>

<p>You will get '<strong>false</strong>' in alert. Now modify the <code>onPageLoad()</code> method to <code>alert(x == 5);</code> you will get <strong>true</strong>.</p>
    </div></div></div></div><div id="solution19" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 19</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/equality-operator">equality-operator</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/identity-operator">identity-operator</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Simply</p>
<p><code>==</code> means <strong>comparison</strong> between operands <strong>with</strong> type coercion</p>
<p>and</p>
<p><code>===</code> means <strong>comparison</strong> between operands <strong>without</strong> type coercion.</p>
<p>Type coercion in JavaScript means automatically converting data types to other data types.</p>
<p>For example:</p>
<pre class="lang-js s-code-block"><code class="hljs language-javascript"><span class="hljs-number">123</span> == <span class="hljs-string">"123"</span>  <span class="hljs-comment">// Returns true, because JS coerces string "123" to number 123</span>
              <span class="hljs-comment">// and then goes on to compare `123 == 123`.</span>

<span class="hljs-number">123</span> === <span class="hljs-string">"123"</span> <span class="hljs-comment">// Returns false, because JS does not coerce values of different types here.</span>
</code></pre>
    </div></div></div></div><div id="solution20" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 20</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/equality-operator">equality-operator</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/identity-operator">identity-operator</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>As a rule of thumb, I would generally use <code>===</code> instead of <code>==</code> (and <code>!==</code> instead of <code>!=</code>).</p>
<p>Reasons are explained in in the answers above and also Douglas Crockford is pretty clear about it (<a href="https://rads.stackoverflow.com/amzn/click/com/0596517742" rel="noreferrer">JavaScript: The Good Parts</a>).</p>
<p>However there is <strong>one single exception</strong>:
<code>== null</code> is an efficient way to check for 'is null or undefined':</p>
<pre class="lang-js s-code-block"><code class="hljs language-javascript"><span class="hljs-keyword">if</span>( value == <span class="hljs-literal">null</span> ){
    <span class="hljs-comment">// value is either null or undefined</span>
}
</code></pre>
<p>For example jQuery 1.9.1 uses this pattern 43 times, and  the <a href="http://www.jshint.com/docs/#options" rel="noreferrer">JSHint syntax checker</a> even provides the <code>eqnull</code> relaxing option for this reason.</p>
<p>From the <a href="http://contribute.jquery.org/style-guide/js/" rel="noreferrer">jQuery style guide</a>:</p>
<blockquote>
<p>Strict equality checks (===) should be used in favor of ==. The only
exception is when checking for undefined and null by way of null.</p>
</blockquote>
<pre class="lang-js s-code-block"><code class="hljs language-javascript"><span class="hljs-comment">// Check for both undefined and null values, for some important reason. </span>
undefOrNull == <span class="hljs-literal">null</span>;
</code></pre>
<p>EDIT 2021-03:</p>
<p>Nowadays <a href="https://caniuse.com/mdn-javascript_operators_logical_nullish_assignment" rel="noreferrer">most browsers</a>
support the <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Nullish_coalescing_operator" rel="noreferrer">Nullish coalescing operator (<code>??</code>)</a>
and the <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Logical_nullish_assignment" rel="noreferrer">Logical nullish assignment <code>(??=)</code></a>, which allows a more concise way to
assign a default value if a variable is null or undefined, for example:</p>
<pre class="lang-js s-code-block"><code class="hljs language-javascript"><span class="hljs-keyword">if</span> (a.<span class="hljs-property">speed</span> == <span class="hljs-literal">null</span>) {
  <span class="hljs-comment">// Set default if null or undefined</span>
  a.<span class="hljs-property">speed</span> = <span class="hljs-number">42</span>;
}
</code></pre>
<p>can be written as any of these forms</p>
<pre class="lang-js s-code-block"><code class="hljs language-javascript">a.<span class="hljs-property">speed</span> ??= <span class="hljs-number">42</span>;
a.<span class="hljs-property">speed</span> ?? a.<span class="hljs-property">speed</span> = <span class="hljs-number">42</span>;
a.<span class="hljs-property">speed</span> = a.<span class="hljs-property">speed</span> ?? <span class="hljs-number">42</span>;
</code></pre>
    </div></div></div></div><div id="solution21" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 21</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/equality-operator">equality-operator</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/identity-operator">identity-operator</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>It's a strict check test.</p>

<p>It's a good thing especially if you're checking between 0 and false and null. </p>

<p>For example, if you have:</p>

<pre class="lang-js s-code-block"><code class="hljs language-javascript">$a = <span class="hljs-number">0</span>;
</code></pre>

<p>Then:</p>

<pre class="lang-js s-code-block"><code class="hljs language-javascript">$a==<span class="hljs-number">0</span>; 
$a==<span class="hljs-variable constant_">NULL</span>;
$a==<span class="hljs-literal">false</span>;
</code></pre>

<p>All returns true and you may not want this. Let's suppose you have a function that can return the 0th index of an array or false on failure. If you check with "==" false, you can get a confusing result.</p>

<p>So with the same thing as above, but a strict test:</p>

<pre class="lang-js s-code-block"><code class="hljs language-javascript">$a = <span class="hljs-number">0</span>;

$a===<span class="hljs-number">0</span>; <span class="hljs-comment">// returns true</span>
$a===<span class="hljs-variable constant_">NULL</span>; <span class="hljs-comment">// returns false</span>
$a===<span class="hljs-literal">false</span>; <span class="hljs-comment">// returns false</span>
</code></pre>
    </div></div></div></div><div id="solution22" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 22</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/equality-operator">equality-operator</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/identity-operator">identity-operator</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p><code>===</code> operator  checks the values as well as the types of the variables for equality.</p>

<p><code>==</code> operator just checks the value of the variables for equality.</p>
    </div></div></div></div><div id="solution23" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 23</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/equality-operator">equality-operator</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/identity-operator">identity-operator</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>JSLint sometimes gives you unrealistic reasons to modify stuff. <code>===</code> has exactly the same performance as <code>==</code> if the types are already the same. </p>

<p>It is faster only when the types are not the same, in which case it does not try to convert types but directly returns a false.</p>

<p>So, <em>IMHO,</em> JSLint maybe used to write new code, but useless over-optimizing should be avoided at all costs. </p>

<p>Meaning, there is no reason to change <code>==</code> to <code>===</code> in a check like <code>if (a == 'test')</code> when you know it for a fact that a can only be a String. </p>

<p>Modifying a lot of code that way wastes developers' and reviewers' time and achieves nothing.</p>
    </div></div></div></div><div id="solution24" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 24</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/equality-operator">equality-operator</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/identity-operator">identity-operator</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>A simple example is </p>

<pre class="lang-js s-code-block"><code class="hljs language-javascript"><span class="hljs-number">2</span> == <span class="hljs-string">'2'</span>  -&gt; <span class="hljs-literal">true</span>, values are <span class="hljs-variable constant_">SAME</span> because <span class="hljs-keyword">of</span> type conversion.

<span class="hljs-number">2</span> === <span class="hljs-string">'2'</span>  -&gt; <span class="hljs-literal">false</span>, values are <span class="hljs-variable constant_">NOT</span> <span class="hljs-variable constant_">SAME</span> because <span class="hljs-keyword">of</span> no type conversion.
</code></pre>
    </div></div></div></div><div id="solution25" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 25</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/equality-operator">equality-operator</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/identity-operator">identity-operator</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>The top 2 answers both mentioned == means equality and === means identity. Unfortunately, this statement is incorrect. </p>

<p>If both operands of == are objects, then they are compared to see if they are the same object. If both operands point to the same object, then the equal operator returns true. Otherwise,
the two are not equal. </p>

<pre class="lang-js s-code-block"><code class="hljs language-javascript"><span class="hljs-keyword">var</span> a = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];  
<span class="hljs-keyword">var</span> b = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];  
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a == b)  <span class="hljs-comment">// false  </span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a === b) <span class="hljs-comment">// false  </span>
</code></pre>

<p>In the code above, both == and === get false because a and b are not the same objects.</p>

<p>That's to say: if both operands of == are objects, == behaves same as ===, which also means identity. The essential difference of this two operators is about type conversion. == has conversion before it checks equality, but === does not.</p>
    </div></div></div></div><div id="solution26" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 26</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/equality-operator">equality-operator</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/identity-operator">identity-operator</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>The problem is that you might easily get into trouble since JavaScript have a lot of implicit conversions meaning...</p>

<pre class="lang-js s-code-block"><code class="hljs language-javascript"><span class="hljs-keyword">var</span> x = <span class="hljs-number">0</span>;
<span class="hljs-keyword">var</span> isTrue = x == <span class="hljs-literal">null</span>;
<span class="hljs-keyword">var</span> isFalse = x === <span class="hljs-literal">null</span>;
</code></pre>

<p>Which pretty soon becomes a problem. The best sample of why implicit conversion is "evil" can be taken from this code in <a href="http://en.wikipedia.org/wiki/Microsoft_Foundation_Class_Library" rel="noreferrer">MFC</a> / C++ which actually will compile due to an implicit conversion from CString to HANDLE which is a pointer typedef type...</p>

<pre class="lang-js s-code-block"><code class="hljs language-javascript"><span class="hljs-title class_">CString</span> x;
<span class="hljs-keyword">delete</span> x;
</code></pre>

<p>Which obviously during runtime does <em>very</em> undefined things...</p>

<p>Google for implicit conversions in C++ and <a href="http://en.wikipedia.org/wiki/Standard_Template_Library" rel="noreferrer">STL</a> to get some of the arguments against it...</p>
    </div></div></div></div><div id="solution27" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 27</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/equality-operator">equality-operator</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/identity-operator">identity-operator</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>From the <a href="https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Operators/Comparison_Operators" rel="noreferrer">core javascript reference</a></p>

<blockquote>
  <p><code>===</code> Returns <code>true</code> if the operands are strictly equal (see above)
  with no type conversion.</p>
</blockquote>
    </div></div></div></div><div id="solution28" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 28</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/equality-operator">equality-operator</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/identity-operator">identity-operator</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p><b>Equality comparison: </b></p>

<p>Operator <code>==</code></p>

<p>Returns true, when both operands are equal. The operands are converted to the same type before being compared.</p>

<pre class="lang-js s-code-block"><code class="hljs language-javascript">&gt;&gt;&gt; <span class="hljs-number">1</span> == <span class="hljs-number">1</span>
<span class="hljs-literal">true</span>
&gt;&gt;&gt; <span class="hljs-number">1</span> == <span class="hljs-number">2</span>
<span class="hljs-literal">false</span>
&gt;&gt;&gt; <span class="hljs-number">1</span> == <span class="hljs-string">'1'</span>
<span class="hljs-literal">true</span>
</code></pre>

<p><b>Equality and type comparison: </b></p>

<p>Operator <code>===</code></p>

<p>Returns true if both operands are equal and of the same type. It's generally 
better and safer if you compare this way, because there's no behind-the-scenes type conversions.</p>

<pre class="lang-js s-code-block"><code class="hljs language-javascript">&gt;&gt;&gt; <span class="hljs-number">1</span> === <span class="hljs-string">'1'</span>
<span class="hljs-literal">false</span>
&gt;&gt;&gt; <span class="hljs-number">1</span> === <span class="hljs-number">1</span>
<span class="hljs-literal">true</span>
</code></pre>
    </div></div></div></div><div id="solution29" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 29</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/equality-operator">equality-operator</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/identity-operator">identity-operator</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Here is a handy comparison table that shows the conversions that happen and the differences between <code>==</code> and <code>===</code>.</p>

<p>As the conclusion states:</p>

<blockquote>
  <p>"Use three equals unless you fully understand the conversions that take
  place for two-equals."</p>
</blockquote>

<p><a href="http://dorey.github.io/JavaScript-Equality-Table/" rel="noreferrer">http://dorey.github.io/JavaScript-Equality-Table/</a></p>
    </div></div></div></div><div id="solution30" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 30</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/equality-operator">equality-operator</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/identity-operator">identity-operator</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>null and undefined are nothingness, that is,</p>

<pre class="lang-js s-code-block"><code class="hljs language-javascript"><span class="hljs-keyword">var</span> a;
<span class="hljs-keyword">var</span> b = <span class="hljs-literal">null</span>;
</code></pre>

<p>Here <code>a</code> and <code>b</code> do not have values. Whereas, 0, false and '' are all values. One thing common beween all these are that they are all falsy values, which means they all <strong>satisfy</strong> falsy conditions.</p>

<p>So, the 0, false and '' together form a sub-group. And on other hand, null &amp; undefined form the second sub-group. Check the comparisons in the below image. null and undefined would equal. The other three would equal to each other. But, they all are treated as falsy conditions in JavaScript.</p>

<p><img src="https://i.stack.imgur.com/11I0i.jpg" alt="Enter image description here"></p>

<p>This is same as any object (like {}, arrays, etc.), non-empty string &amp; Boolean true are all truthy conditions. But, they are all not equal.</p>
    </div></div></div></div></div></div><div class="widget"><a href="/questions/can-a-local-variable&#x27;s-memory-be-accessed-outside-its-scope-1657384460386">Can a local variable&#x27;s memory be accessed outside its scope?</a><a href="/questions/how-do-i-return-the-response-from-an-asynchronous-call-1657384208012">How do I return the response from an asynchronous call?</a><a href="/questions/http-get-with-request-body-1657387379038">HTTP GET with request body</a><a href="/questions/random-number-generator-only-generating-one-random-number-1657385468315">Random number generator only generating one random number</a><a href="/questions/deserialize-json-into-c-dynamic-object-1657388568720">Deserialize JSON into C# dynamic object?</a><a href="/questions/how-to-avoid-having-class-data-shared-among-instances-1657387687732">How to avoid having class data shared among instances?</a><a href="/questions/how-can-i-validate-an-email-address-in-javascript-1657385475959">How can I validate an email address in JavaScript?</a><a href="/questions/are-&#x27;arrow-functions&#x27;-and-&#x27;functions&#x27;-equivalent-interchangeable-1657384527873">Are &#x27;Arrow Functions&#x27; and &#x27;Functions&#x27; equivalent / interchangeable?</a><a href="/questions/what-are-drawbacks-or-disadvantages-of-singleton-pattern-closed-1657387360749">What are drawbacks or disadvantages of singleton pattern? [closed]</a><a href="/questions/how-do-i-compare-strings-in-java-1657384243187">How do I compare strings in Java?</a><a href="/questions/firebase-query-if-child-of-child-contains-a-value-1657387841291">Firebase query if child of child contains a value</a><a href="/questions/how-to-lazy-load-images-in-listview-in-android-1657387332835">How to lazy load images in ListView in Android</a><a href="/questions/what-is-the-copy-and-swap-idiom-1657384840329">What is the copy-and-swap idiom?</a><a href="/questions/select-first-row-in-each-group-by-group-1657384809388">Select first row in each GROUP BY group?</a><a href="/questions/how-to-remove-%22noise%22-from-gccclang-assembly-output-1657387612391">How to remove &quot;noise&quot; from GCC/clang assembly output?</a><a href="/questions/what-is-the-canonical-way-to-check-for-errors-using-the-cuda-runtime-api-1657387302698">What is the canonical way to check for errors using the CUDA runtime API?</a><a href="/questions/calling-a-function-of-a-module-by-using-its-name-(a-string)-1657388565656">Calling a function of a module by using its name (a string)</a><a href="/questions/most-efficient-method-to-groupby-on-an-array-of-objects-1657387580538">Most efficient method to groupby on an array of objects</a><a href="/questions/how-do-javascript-closures-work-1657384418555">How do JavaScript closures work?</a><a href="/questions/how-to-use-sharedpreferences-in-android-to-store-fetch-and-edit-values-closed-1657387683057">How to use SharedPreferences in Android to store, fetch and edit values [closed]</a></div></div><span class="cursor-pointer text-lg p-2" style="position:fixed;bottom:20px;left:20px;background:#000;z-index:2000;color:white">Go go top</span></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"data":{"answer":["\n\u0026lt;p\u0026gt;The strict equality operator (\u0026lt;code\u0026gt;===\u0026lt;/code\u0026gt;) behaves identically to the abstract equality operator (\u0026lt;code\u0026gt;==\u0026lt;/code\u0026gt;) except no type conversion is done, and the types must be the same to be considered equal.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Reference: \u0026lt;a href=\u0026quot;http://www.c-point.com/javascript_tutorial/jsgrpComparison.htm\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;Javascript Tutorial: Comparison Operators\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;The \u0026lt;code\u0026gt;==\u0026lt;/code\u0026gt; operator will compare for equality \u0026lt;em\u0026gt;after doing any necessary type conversions\u0026lt;/em\u0026gt;.  The \u0026lt;code\u0026gt;===\u0026lt;/code\u0026gt; operator will \u0026lt;strong\u0026gt;not\u0026lt;/strong\u0026gt; do the conversion, so if two values are not the same type \u0026lt;code\u0026gt;===\u0026lt;/code\u0026gt; will simply return \u0026lt;code\u0026gt;false\u0026lt;/code\u0026gt;. Both are equally quick.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;To quote Douglas Crockford\u0026apos;s excellent \u0026lt;a href=\u0026quot;https://rads.stackoverflow.com/amzn/click/com/0596517742\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;JavaScript: The Good Parts\u0026lt;/a\u0026gt;,\u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;JavaScript has two sets of equality operators: \u0026lt;code\u0026gt;===\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;!==\u0026lt;/code\u0026gt;, and their evil twins \u0026lt;code\u0026gt;==\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;!=\u0026lt;/code\u0026gt;.  The good ones work the way you would expect.  If the two operands are of the same type and have the same value, then \u0026lt;code\u0026gt;===\u0026lt;/code\u0026gt; produces \u0026lt;code\u0026gt;true\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;!==\u0026lt;/code\u0026gt; produces \u0026lt;code\u0026gt;false\u0026lt;/code\u0026gt;.  The evil twins do the right thing when the operands are of the same type, but if they are of different types, they attempt to coerce the values.  the rules by which they do that are complicated and unmemorable.  These are some of the interesting cases:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;\u0026apos;\u0026lt;/span\u0026gt; == \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;0\u0026apos;\u0026lt;/span\u0026gt;           \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// false\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt; == \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;\u0026apos;\u0026lt;/span\u0026gt;             \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// true\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt; == \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;0\u0026apos;\u0026lt;/span\u0026gt;            \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// true\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;false\u0026lt;/span\u0026gt; == \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;false\u0026apos;\u0026lt;/span\u0026gt;    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// false\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;false\u0026lt;/span\u0026gt; == \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;0\u0026apos;\u0026lt;/span\u0026gt;        \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// true\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;false\u0026lt;/span\u0026gt; == \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;undefined\u0026lt;/span\u0026gt;  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// false\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;false\u0026lt;/span\u0026gt; == \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;null\u0026lt;/span\u0026gt;       \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// false\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;null\u0026lt;/span\u0026gt; == \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;undefined\u0026lt;/span\u0026gt;   \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// true\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos; \\t\\r\\n \u0026apos;\u0026lt;/span\u0026gt; == \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;     \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// true\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;a href=\u0026quot;https://i.stack.imgur.com/yISob.png\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;\u0026lt;img src=\u0026quot;https://i.stack.imgur.com/yISob.png\u0026quot; alt=\u0026quot;Equality Comparison Table \u0026quot;\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;The lack of transitivity is alarming.  My advice is to never use the evil twins.  Instead, always use \u0026lt;code\u0026gt;===\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;!==\u0026lt;/code\u0026gt;.  All of the comparisons just shown produce \u0026lt;code\u0026gt;false\u0026lt;/code\u0026gt; with the \u0026lt;code\u0026gt;===\u0026lt;/code\u0026gt; operator.\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;hr\u0026gt;\n\n\u0026lt;h3\u0026gt;Update:\u0026lt;/h3\u0026gt;\n\n\u0026lt;p\u0026gt;A good point was brought up by \u0026lt;a href=\u0026quot;https://stackoverflow.com/users/165495/casebash\u0026quot;\u0026gt;@Casebash\u0026lt;/a\u0026gt; in the comments and in \u0026lt;a href=\u0026quot;https://stackoverflow.com/users/113570/philippe-leybaert\u0026quot;\u0026gt;@Phillipe Laybaert\u0026apos;s\u0026lt;/a\u0026gt; \u0026lt;a href=\u0026quot;https://stackoverflow.com/a/957602/1288\u0026quot;\u0026gt;answer\u0026lt;/a\u0026gt; concerning objects.  For objects, \u0026lt;code\u0026gt;==\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;===\u0026lt;/code\u0026gt; act consistently with one another (except in a special case).\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; a = [\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;,\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;,\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3\u0026lt;/span\u0026gt;];\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; b = [\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;,\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;,\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3\u0026lt;/span\u0026gt;];\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; c = { \u0026lt;span class=\u0026quot;hljs-attr\u0026quot;\u0026gt;x\u0026lt;/span\u0026gt;: \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-attr\u0026quot;\u0026gt;y\u0026lt;/span\u0026gt;: \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt; };\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; d = { \u0026lt;span class=\u0026quot;hljs-attr\u0026quot;\u0026gt;x\u0026lt;/span\u0026gt;: \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-attr\u0026quot;\u0026gt;y\u0026lt;/span\u0026gt;: \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt; };\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; e = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;text\u0026quot;\u0026lt;/span\u0026gt;;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; f = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;te\u0026quot;\u0026lt;/span\u0026gt; + \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;xt\u0026quot;\u0026lt;/span\u0026gt;;\n\na == b            \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// false\u0026lt;/span\u0026gt;\na === b           \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// false\u0026lt;/span\u0026gt;\n\nc == d            \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// false\u0026lt;/span\u0026gt;\nc === d           \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// false\u0026lt;/span\u0026gt;\n\ne == f            \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// true\u0026lt;/span\u0026gt;\ne === f           \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// true\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;The special case is when you compare a primitive with an object that evaluates to the same primitive, due to its \u0026lt;code\u0026gt;toString\u0026lt;/code\u0026gt; or \u0026lt;code\u0026gt;valueOf\u0026lt;/code\u0026gt; method. For example, consider the comparison of a string primitive with a string object created using the \u0026lt;code\u0026gt;String\u0026lt;/code\u0026gt; constructor.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;abc\u0026quot;\u0026lt;/span\u0026gt; == \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;String\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;abc\u0026quot;\u0026lt;/span\u0026gt;)    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// true\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;abc\u0026quot;\u0026lt;/span\u0026gt; === \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;String\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;abc\u0026quot;\u0026lt;/span\u0026gt;)   \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// false\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Here the \u0026lt;code\u0026gt;==\u0026lt;/code\u0026gt; operator is checking the values of the two objects and returning \u0026lt;code\u0026gt;true\u0026lt;/code\u0026gt;, but the \u0026lt;code\u0026gt;===\u0026lt;/code\u0026gt; is seeing that they\u0026apos;re not the same type and returning \u0026lt;code\u0026gt;false\u0026lt;/code\u0026gt;.  Which one is correct?  That really depends on what you\u0026apos;re trying to compare.  My advice is to bypass the question entirely and just don\u0026apos;t use the \u0026lt;code\u0026gt;String\u0026lt;/code\u0026gt; constructor to create string objects from string literals.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Reference\u0026lt;/strong\u0026gt;\u0026lt;br\u0026gt;\n\u0026lt;a href=\u0026quot;http://www.ecma-international.org/ecma-262/5.1/#sec-11.9.3\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;http://www.ecma-international.org/ecma-262/5.1/#sec-11.9.3\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Using the \u0026lt;code\u0026gt;==\u0026lt;/code\u0026gt; operator (\u0026lt;em\u0026gt;Equality\u0026lt;/em\u0026gt;)\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;true\u0026lt;/span\u0026gt; == \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//true, because \u0026apos;true\u0026apos; is converted to 1 and then compared\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;2\u0026quot;\u0026lt;/span\u0026gt; == \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;;  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//true, because \u0026quot;2\u0026quot; is converted to 2 and then compared\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;Using the \u0026lt;code\u0026gt;===\u0026lt;/code\u0026gt; operator (\u0026lt;em\u0026gt;Identity\u0026lt;/em\u0026gt;)\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;true\u0026lt;/span\u0026gt; === \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//false\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;2\u0026quot;\u0026lt;/span\u0026gt; === \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;;  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//false\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;This is because the \u0026lt;strong\u0026gt;equality operator \u0026lt;code\u0026gt;==\u0026lt;/code\u0026gt; does type coercion\u0026lt;/strong\u0026gt;, meaning that the interpreter implicitly tries to convert the values before comparing.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;On the other hand, the \u0026lt;strong\u0026gt;identity operator \u0026lt;code\u0026gt;===\u0026lt;/code\u0026gt; does not do type coercion\u0026lt;/strong\u0026gt;, and thus does not convert the values when comparing.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Here\u0026apos;s an interesting visualisation of the equality comparison between \u0026lt;code\u0026gt;==\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;===\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Source: \u0026lt;a href=\u0026quot;https://github.com/dorey/JavaScript-Equality-Table\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;https://github.com/dorey/JavaScript-Equality-Table\u0026lt;/a\u0026gt;\u0026lt;/strong\u0026gt; (\u0026lt;a href=\u0026quot;https://dorey.github.io/JavaScript-Equality-Table/\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;demo\u0026lt;/a\u0026gt;, \u0026lt;a href=\u0026quot;https://dorey.github.io/JavaScript-Equality-Table/unified/\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;unified demo\u0026lt;/a\u0026gt;)\u0026lt;/p\u0026gt;\n\u0026lt;hr\u0026gt;\n\u0026lt;h2\u0026gt;\u0026lt;code\u0026gt;var1 === var2\u0026lt;/code\u0026gt;\u0026lt;/h2\u0026gt;\n\u0026lt;p\u0026gt;When using \u0026lt;code\u0026gt;===\u0026lt;/code\u0026gt; for JavaScript equality testing, everything is as is.\u0026lt;br\u0026gt;\nNothing gets converted before being evaluated.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;img src=\u0026quot;https://i.stack.imgur.com/62vxI.png\u0026quot; alt=\u0026quot;Equality evaluation of === in JS\u0026quot;\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;h2\u0026gt;\u0026lt;code\u0026gt;var1 == var2\u0026lt;/code\u0026gt;\u0026lt;/h2\u0026gt;\n\u0026lt;p\u0026gt;When using \u0026lt;code\u0026gt;==\u0026lt;/code\u0026gt; for JavaScript equality testing, some \u0026lt;em\u0026gt;\u0026lt;strong\u0026gt;funky conversions\u0026lt;/strong\u0026gt;\u0026lt;/em\u0026gt; take place.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;img src=\u0026quot;https://i.stack.imgur.com/35MpY.png\u0026quot; alt=\u0026quot;Equality evaluation of == in JS\u0026quot;\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;h3\u0026gt;Summary of equality in Javascript\u0026lt;/h3\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;img src=\u0026quot;https://i.stack.imgur.com/FX7z1.png\u0026quot; alt=\u0026quot;Equality in Javascript\u0026quot;\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;hr\u0026gt;\n\u0026lt;h3\u0026gt;Conclusion:\u0026lt;/h3\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Always use \u0026lt;code\u0026gt;===\u0026lt;/code\u0026gt;\u0026lt;/strong\u0026gt;, unless you fully understand the \u0026lt;a href=\u0026quot;https://dorey.github.io/JavaScript-Equality-Table/#two-equals\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;funky conversions\u0026lt;/a\u0026gt; that take place with \u0026lt;code\u0026gt;==\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;In the answers here, I didn\u0026apos;t read anything about what \u0026lt;strong\u0026gt;equal\u0026lt;/strong\u0026gt; means. Some will say that \u0026lt;code\u0026gt;===\u0026lt;/code\u0026gt; means \u0026lt;strong\u0026gt;equal and of the same type\u0026lt;/strong\u0026gt;, but that\u0026apos;s not really true. It actually means that \u0026lt;strong\u0026gt;both operands reference the same object\u0026lt;/strong\u0026gt;, or in case of \u0026lt;strong\u0026gt;value types, have the same value\u0026lt;/strong\u0026gt;.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;So, let\u0026apos;s take the following code:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; a = [\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;,\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;,\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3\u0026lt;/span\u0026gt;];\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; b = [\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;,\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;,\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3\u0026lt;/span\u0026gt;];\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; c = a;\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; ab_eq = (a === b); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// false (even though a and b are the same type)\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; ac_eq = (a === c); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// true\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;The same here:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; a = { \u0026lt;span class=\u0026quot;hljs-attr\u0026quot;\u0026gt;x\u0026lt;/span\u0026gt;: \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-attr\u0026quot;\u0026gt;y\u0026lt;/span\u0026gt;: \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt; };\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; b = { \u0026lt;span class=\u0026quot;hljs-attr\u0026quot;\u0026gt;x\u0026lt;/span\u0026gt;: \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-attr\u0026quot;\u0026gt;y\u0026lt;/span\u0026gt;: \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt; };\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; c = a;\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; ab_eq = (a === b); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// false (even though a and b are the same type)\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; ac_eq = (a === c); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// true\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;Or even:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; a = { };\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; b = { };\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; c = a;\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; ab_eq = (a === b); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// false (even though a and b are the same type)\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; ac_eq = (a === c); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// true\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;This behavior is not always obvious. There\u0026apos;s more to the story than being equal and being of the same type.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;The rule is:\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;em\u0026gt;\u0026lt;strong\u0026gt;For value types (numbers):\u0026lt;/strong\u0026gt;\u0026lt;/em\u0026gt;\u0026lt;br\u0026gt;\n\u0026lt;code\u0026gt;a === b\u0026lt;/code\u0026gt; returns true if \u0026lt;code\u0026gt;a\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;b\u0026lt;/code\u0026gt; have the same value and are of the same type\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;em\u0026gt;\u0026lt;strong\u0026gt;For reference types:\u0026lt;/strong\u0026gt;\u0026lt;/em\u0026gt;\u0026lt;br\u0026gt;\n\u0026lt;code\u0026gt;a === b\u0026lt;/code\u0026gt; returns true if \u0026lt;code\u0026gt;a\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;b\u0026lt;/code\u0026gt; reference the exact same object\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;em\u0026gt;\u0026lt;strong\u0026gt;For strings:\u0026lt;/strong\u0026gt;\u0026lt;/em\u0026gt;\u0026lt;br\u0026gt;\n\u0026lt;code\u0026gt;a === b\u0026lt;/code\u0026gt; returns true if \u0026lt;code\u0026gt;a\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;b\u0026lt;/code\u0026gt; are both strings and contain the exact same characters\u0026lt;/p\u0026gt;\n\u0026lt;hr\u0026gt;\n\u0026lt;h2\u0026gt;Strings: the special case...\u0026lt;/h2\u0026gt;\n\u0026lt;p\u0026gt;Strings are not value types, but in Javascript they behave like value types, so they will be \u0026quot;equal\u0026quot; when the characters in the string are the same and when they are of the same length (as explained in the third rule)\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Now it becomes interesting:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; a = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;12\u0026quot;\u0026lt;/span\u0026gt; + \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;3\u0026quot;\u0026lt;/span\u0026gt;;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; b = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;123\u0026quot;\u0026lt;/span\u0026gt;;\n\n\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;alert\u0026lt;/span\u0026gt;(a === b); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// returns true, because strings behave like value types\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;But how about this?:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; a = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;String\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;123\u0026quot;\u0026lt;/span\u0026gt;);\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; b = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;123\u0026quot;\u0026lt;/span\u0026gt;;\n\n\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;alert\u0026lt;/span\u0026gt;(a === b); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// returns false !! (but they are equal and of the same type)\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;I thought strings behave like value types? Well, it depends who you ask... In this case a and b are not the same type. \u0026lt;code\u0026gt;a\u0026lt;/code\u0026gt; is of type \u0026lt;code\u0026gt;Object\u0026lt;/code\u0026gt;, while \u0026lt;code\u0026gt;b\u0026lt;/code\u0026gt; is of type \u0026lt;code\u0026gt;string\u0026lt;/code\u0026gt;. Just remember that creating a string object using the \u0026lt;code\u0026gt;String\u0026lt;/code\u0026gt; constructor creates something of type \u0026lt;code\u0026gt;Object\u0026lt;/code\u0026gt; that behaves as a string \u0026lt;em\u0026gt;most of the time\u0026lt;/em\u0026gt;.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Let me add this counsel:\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;em\u0026gt;\u0026lt;strong\u0026gt;If in doubt, read the \u0026lt;a href=\u0026quot;http://www.ecma-international.org/publications/standards/Ecma-262.htm\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;specification\u0026lt;/a\u0026gt;!\u0026lt;/strong\u0026gt;\u0026lt;/em\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;ECMA-262 is the specification for a scripting language of which JavaScript is a dialect. Of course in practice it matters more how the most important browsers behave than an esoteric definition of how something is supposed to be handled. But it is helpful to understand why \u0026lt;strong\u0026gt;new String(\u0026quot;a\u0026quot;) !== \u0026quot;a\u0026quot;\u0026lt;/strong\u0026gt;.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Please let me explain how to read the specification to clarify this question. I see that in this very old topic nobody had an answer for the very strange effect. So, if you can read a specification, this will help you in your profession tremendously. It is an acquired skill. So, let\u0026apos;s continue.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Searching the PDF file for === brings me to page 56 of the specification: \u0026lt;strong\u0026gt;11.9.4. The Strict Equals Operator ( === )\u0026lt;/strong\u0026gt;, and after wading through the specificationalese I find:\u0026lt;/p\u0026gt;\n\u0026lt;blockquote\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;11.9.6 The Strict Equality Comparison Algorithm\u0026lt;/strong\u0026gt;\u0026lt;br\u0026gt;\nThe comparison x === y, where x and y are values, produces \u0026lt;strong\u0026gt;true\u0026lt;/strong\u0026gt; or \u0026lt;strong\u0026gt;false\u0026lt;/strong\u0026gt;. Such a comparison is performed as follows:\u0026lt;br\u0026gt;\n\u0026amp;nbsp;\u0026amp;nbsp;1. If Type(x) is different from Type(y), return \u0026lt;strong\u0026gt;false\u0026lt;/strong\u0026gt;.\u0026lt;br\u0026gt;\n\u0026amp;nbsp;\u0026amp;nbsp;2. If Type(x) is Undefined, return \u0026lt;strong\u0026gt;true\u0026lt;/strong\u0026gt;.\u0026lt;br\u0026gt;\n\u0026amp;nbsp;\u0026amp;nbsp;3. If Type(x) is Null, return \u0026lt;strong\u0026gt;true\u0026lt;/strong\u0026gt;.\u0026lt;br\u0026gt;\n\u0026amp;nbsp;\u0026amp;nbsp;4. If Type(x) is not Number, go to step 11.\u0026lt;br\u0026gt;\n\u0026amp;nbsp;\u0026amp;nbsp;5. If x is \u0026lt;strong\u0026gt;NaN\u0026lt;/strong\u0026gt;, return \u0026lt;strong\u0026gt;false\u0026lt;/strong\u0026gt;.\u0026lt;br\u0026gt;\n\u0026amp;nbsp;\u0026amp;nbsp;6. If y is \u0026lt;strong\u0026gt;NaN\u0026lt;/strong\u0026gt;, return \u0026lt;strong\u0026gt;false\u0026lt;/strong\u0026gt;.\u0026lt;br\u0026gt;\n\u0026amp;nbsp;\u0026amp;nbsp;7. If x is the same number value as y, return \u0026lt;strong\u0026gt;true\u0026lt;/strong\u0026gt;.\u0026lt;br\u0026gt;\n\u0026amp;nbsp;\u0026amp;nbsp;8. If x is +0 and y is 0, return \u0026lt;strong\u0026gt;true\u0026lt;/strong\u0026gt;.\u0026lt;br\u0026gt;\n\u0026amp;nbsp;\u0026amp;nbsp;9. If x is 0 and y is +0, return \u0026lt;strong\u0026gt;true\u0026lt;/strong\u0026gt;.\u0026lt;br\u0026gt;\n\u0026amp;nbsp;\u0026amp;nbsp;10. Return \u0026lt;strong\u0026gt;false\u0026lt;/strong\u0026gt;.\u0026lt;br\u0026gt;\n\u0026amp;nbsp;\u0026amp;nbsp;11. If Type(x) is String, then return \u0026lt;strong\u0026gt;true\u0026lt;/strong\u0026gt; if x and y are exactly the same sequence of characters (same length and same characters in corresponding positions); otherwise, return \u0026lt;strong\u0026gt;false\u0026lt;/strong\u0026gt;.\u0026lt;br\u0026gt;\n\u0026amp;nbsp;\u0026amp;nbsp;12. If Type(x) is Boolean, return \u0026lt;strong\u0026gt;true\u0026lt;/strong\u0026gt; if x and y are both \u0026lt;strong\u0026gt;true\u0026lt;/strong\u0026gt; or both \u0026lt;strong\u0026gt;false\u0026lt;/strong\u0026gt;; otherwise, return \u0026lt;strong\u0026gt;false\u0026lt;/strong\u0026gt;.\u0026lt;br\u0026gt;\n\u0026amp;nbsp;\u0026amp;nbsp;13. Return \u0026lt;strong\u0026gt;true\u0026lt;/strong\u0026gt; if x and y refer to the same object or if they refer to objects joined to each other (see 13.1.2). Otherwise, return \u0026lt;strong\u0026gt;false\u0026lt;/strong\u0026gt;.\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\u0026lt;p\u0026gt;Interesting is step 11. Yes, strings are treated as value types. But this does not explain why \u0026lt;strong\u0026gt;new String(\u0026quot;a\u0026quot;) !== \u0026quot;a\u0026quot;\u0026lt;/strong\u0026gt;. Do we have a browser not conforming to ECMA-262?\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Not so fast!\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Let\u0026apos;s check the types of the operands. Try it out for yourself by wrapping them in \u0026lt;strong\u0026gt;typeof()\u0026lt;/strong\u0026gt;. I find that \u0026lt;strong\u0026gt;new String(\u0026quot;a\u0026quot;)\u0026lt;/strong\u0026gt; is an object, and step 1 is used: return \u0026lt;strong\u0026gt;false\u0026lt;/strong\u0026gt; if the types are different.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;If you wonder why \u0026lt;strong\u0026gt;new String(\u0026quot;a\u0026quot;)\u0026lt;/strong\u0026gt; does not return a string, how about some exercise reading a specification? Have fun!\u0026lt;/p\u0026gt;\n\u0026lt;hr\u0026gt;\n\u0026lt;p\u0026gt;Aidiakapi wrote this in a comment below:\u0026lt;/p\u0026gt;\n\u0026lt;blockquote\u0026gt;\n\u0026lt;p\u0026gt;From the specification\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;11.2.2 The new Operator\u0026lt;/strong\u0026gt;:\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;If Type(constructor) is not Object, throw a TypeError exception.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;With other words, if String wouldn\u0026apos;t be of type Object it couldn\u0026apos;t be used with the new operator.\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;new\u0026lt;/strong\u0026gt; always returns an Object, even for \u0026lt;strong\u0026gt;String\u0026lt;/strong\u0026gt; constructors, too. And alas! The value semantics for strings (see step 11) is lost.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;And this finally means: \u0026lt;strong\u0026gt;new String(\u0026quot;a\u0026quot;) !== \u0026quot;a\u0026quot;\u0026lt;/strong\u0026gt;.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;I tested this in Firefox with \u0026lt;a href=\u0026quot;http://en.wikipedia.org/wiki/Firebug_%28software%29\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;Firebug\u0026lt;/a\u0026gt; using code like this:\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;/p\u0026gt;\u0026lt;div class=\u0026quot;snippet\u0026quot; data-lang=\u0026quot;js\u0026quot; data-hide=\u0026quot;false\u0026quot; data-console=\u0026quot;true\u0026quot; data-babel=\u0026quot;false\u0026quot;\u0026gt;\n\u0026lt;div class=\u0026quot;snippet-code\u0026quot;\u0026gt;\n\u0026lt;pre class=\u0026quot;snippet-code-js lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;console\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;time\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;testEquality\u0026quot;\u0026lt;/span\u0026gt;);\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; n = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;while\u0026lt;/span\u0026gt; (\u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;true\u0026lt;/span\u0026gt;) {\n  n++;\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (n == \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;100000\u0026lt;/span\u0026gt;)\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;break\u0026lt;/span\u0026gt;;\n}\n\u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;console\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;timeEnd\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;testEquality\u0026quot;\u0026lt;/span\u0026gt;);\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;div class=\u0026quot;snippet-result\u0026quot;\u0026gt;\u0026lt;div class=\u0026quot;snippet-ctas\u0026quot;\u0026gt;\u0026lt;button type=\u0026quot;button\u0026quot; class=\u0026quot;s-btn s-btn__primary\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;icon-play-white _hover\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;\u0026lt;span\u0026gt; Run code snippet\u0026lt;/span\u0026gt;\u0026lt;/button\u0026gt;\u0026lt;input class=\u0026quot;copySnippet s-btn s-btn__filled\u0026quot; type=\u0026quot;button\u0026quot; value=\u0026quot;Copy snippet to answer\u0026quot; style=\u0026quot;display: none;\u0026quot;\u0026gt;\u0026lt;button type=\u0026quot;button\u0026quot; class=\u0026quot;s-btn hideResults\u0026quot; style=\u0026quot;display: none;\u0026quot;\u0026gt;Hide results\u0026lt;/button\u0026gt;\u0026lt;div class=\u0026quot;popout-code\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;snippet-expand-link\u0026quot;\u0026gt;Expand snippet\u0026lt;/a\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;div class=\u0026quot;snippet-result-code\u0026quot; style=\u0026quot;display: none;\u0026quot;\u0026gt;\u0026lt;iframe name=\u0026quot;sif1\u0026quot; sandbox=\u0026quot;allow-forms allow-modals allow-scripts\u0026quot; class=\u0026quot;snippet-box-edit snippet-box-result\u0026quot; frameborder=\u0026quot;0\u0026quot;\u0026gt;\u0026lt;/iframe\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;/div\u0026gt;\n\u0026lt;/div\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;and\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;/p\u0026gt;\u0026lt;div class=\u0026quot;snippet\u0026quot; data-lang=\u0026quot;js\u0026quot; data-hide=\u0026quot;false\u0026quot; data-console=\u0026quot;true\u0026quot; data-babel=\u0026quot;false\u0026quot;\u0026gt;\n\u0026lt;div class=\u0026quot;snippet-code\u0026quot;\u0026gt;\n\u0026lt;pre class=\u0026quot;snippet-code-js lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;console\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;time\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;testTypeEquality\u0026quot;\u0026lt;/span\u0026gt;);\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; n = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;while\u0026lt;/span\u0026gt; (\u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;true\u0026lt;/span\u0026gt;) {\n  n++;\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (n === \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;100000\u0026lt;/span\u0026gt;)\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;break\u0026lt;/span\u0026gt;;\n}\n\u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;console\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;timeEnd\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;testTypeEquality\u0026quot;\u0026lt;/span\u0026gt;);\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;div class=\u0026quot;snippet-result\u0026quot;\u0026gt;\u0026lt;div class=\u0026quot;snippet-ctas\u0026quot;\u0026gt;\u0026lt;button type=\u0026quot;button\u0026quot; class=\u0026quot;s-btn s-btn__primary\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;icon-play-white _hover\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;\u0026lt;span\u0026gt; Run code snippet\u0026lt;/span\u0026gt;\u0026lt;/button\u0026gt;\u0026lt;input class=\u0026quot;copySnippet s-btn s-btn__filled\u0026quot; type=\u0026quot;button\u0026quot; value=\u0026quot;Copy snippet to answer\u0026quot; style=\u0026quot;display: none;\u0026quot;\u0026gt;\u0026lt;button type=\u0026quot;button\u0026quot; class=\u0026quot;s-btn hideResults\u0026quot; style=\u0026quot;display: none;\u0026quot;\u0026gt;Hide results\u0026lt;/button\u0026gt;\u0026lt;div class=\u0026quot;popout-code\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;snippet-expand-link\u0026quot;\u0026gt;Expand snippet\u0026lt;/a\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;div class=\u0026quot;snippet-result-code\u0026quot; style=\u0026quot;display: none;\u0026quot;\u0026gt;\u0026lt;iframe name=\u0026quot;sif2\u0026quot; sandbox=\u0026quot;allow-forms allow-modals allow-scripts\u0026quot; class=\u0026quot;snippet-box-edit snippet-box-result\u0026quot; frameborder=\u0026quot;0\u0026quot;\u0026gt;\u0026lt;/iframe\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;/div\u0026gt;\n\u0026lt;/div\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;My results (tested five times each and averaged):\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;==: \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;115.2\u0026lt;/span\u0026gt;\n===: \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;114.4\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;So I\u0026apos;d say that the miniscule difference (this is over 100000 iterations, remember) is negligible. Performance \u0026lt;em\u0026gt;\u0026lt;strong\u0026gt;isn\u0026apos;t\u0026lt;/strong\u0026gt;\u0026lt;/em\u0026gt; a reason to do \u0026lt;code\u0026gt;===\u0026lt;/code\u0026gt;. Type safety (well, as safe as you\u0026apos;re going to get in JavaScript), and code quality is.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;In PHP and JavaScript, it is a strict equality operator. Which means, it will compare both type and values.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;In JavaScript it means of the same value and type.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;For example,\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;4\u0026lt;/span\u0026gt; == \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;4\u0026quot;\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// will return true\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;but\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;4\u0026lt;/span\u0026gt; === \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;4\u0026quot;\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// will return false \u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Why \u0026lt;code\u0026gt;==\u0026lt;/code\u0026gt; is so unpredictable?\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;What do you get when you compare an empty string \u0026lt;code\u0026gt;\u0026quot;\u0026quot;\u0026lt;/code\u0026gt; with the number zero \u0026lt;code\u0026gt;0\u0026lt;/code\u0026gt;?\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;code\u0026gt;true\u0026lt;/code\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Yep, that\u0026apos;s right according to \u0026lt;code\u0026gt;==\u0026lt;/code\u0026gt; an empty string and the number zero are the same time.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;And it doesn\u0026apos;t end there, here\u0026apos;s another one:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;0\u0026apos;\u0026lt;/span\u0026gt; == \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;false\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// true\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Things get really weird with arrays.\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;] == \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;true\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// true\u0026lt;/span\u0026gt;\n[] == \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;false\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// true\u0026lt;/span\u0026gt;\n[[]] == \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;false\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// true\u0026lt;/span\u0026gt;\n[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;] == \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;false\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// true\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Then weirder with strings\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;,\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;,\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3\u0026lt;/span\u0026gt;] == \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;1,2,3\u0026apos;\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// true - REALLY?!\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;\\r\\n\\t\u0026apos;\u0026lt;/span\u0026gt; == \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// true - Come on!\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;It get\u0026apos;s worse:\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;When is equal not equal?\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;let\u0026lt;/span\u0026gt; A = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;\u0026apos;\u0026lt;/span\u0026gt;  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// empty string\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;let\u0026lt;/span\u0026gt; B = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;   \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// zero\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;let\u0026lt;/span\u0026gt; C = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;0\u0026apos;\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// zero string\u0026lt;/span\u0026gt;\n\nA == B \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// true - ok... \u0026lt;/span\u0026gt;\nB == C \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// true - so far so good...\u0026lt;/span\u0026gt;\nA == C \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// **FALSE** - Plot twist!\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Let me say that again:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;(A == B) \u0026amp;amp;\u0026amp;amp; (B == C) \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// true\u0026lt;/span\u0026gt;\n(A == C) \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// **FALSE**\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;And this is just the crazy stuff you get with primitives.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;It\u0026apos;s a whole new level of crazy when you use \u0026lt;code\u0026gt;==\u0026lt;/code\u0026gt; with objects.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;At this point your probably wondering...\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Why does this happen?\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Well it\u0026apos;s because unlike \u0026quot;triple equals\u0026quot; (\u0026lt;code\u0026gt;===\u0026lt;/code\u0026gt;) which just checks if two values are the same.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;code\u0026gt;==\u0026lt;/code\u0026gt; does a \u0026lt;strong\u0026gt;\u0026lt;em\u0026gt;whole bunch of other stuff\u0026lt;/em\u0026gt;\u0026lt;/strong\u0026gt;.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;It has special handling for functions, special handling for nulls, undefined, strings, you name it.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;It get\u0026apos;s pretty wacky.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;In fact, if you tried to write a function that does what \u0026lt;code\u0026gt;==\u0026lt;/code\u0026gt; does it would look something like this:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;isEqual\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;x, y\u0026lt;/span\u0026gt;) { \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// if `==` were a function\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typeof\u0026lt;/span\u0026gt; y === \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typeof\u0026lt;/span\u0026gt; x) \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; y === x;\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// treat null and undefined the same\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; xIsNothing = (y === \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;undefined\u0026lt;/span\u0026gt;) || (y === \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;null\u0026lt;/span\u0026gt;);\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; yIsNothing = (x === \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;undefined\u0026lt;/span\u0026gt;) || (x === \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;null\u0026lt;/span\u0026gt;);\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt;(xIsNothing || yIsNothing) \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; (xIsNothing \u0026amp;amp;\u0026amp;amp; yIsNothing);\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typeof\u0026lt;/span\u0026gt; y === \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;function\u0026quot;\u0026lt;/span\u0026gt; || \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typeof\u0026lt;/span\u0026gt; x === \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;function\u0026quot;\u0026lt;/span\u0026gt;) {\n        \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// if either value is a string \u0026lt;/span\u0026gt;\n        \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// convert the function into a string and compare\u0026lt;/span\u0026gt;\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typeof\u0026lt;/span\u0026gt; x === \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;string\u0026quot;\u0026lt;/span\u0026gt;) {\n            \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; x === y.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;toString\u0026lt;/span\u0026gt;();\n        } \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;else\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typeof\u0026lt;/span\u0026gt; y === \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;string\u0026quot;\u0026lt;/span\u0026gt;) {\n            \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; x.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;toString\u0026lt;/span\u0026gt;() === y;\n        } \n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;false\u0026lt;/span\u0026gt;;\n    }\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typeof\u0026lt;/span\u0026gt; x === \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;object\u0026quot;\u0026lt;/span\u0026gt;) x = \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;toPrimitive\u0026lt;/span\u0026gt;(x);\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typeof\u0026lt;/span\u0026gt; y === \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;object\u0026quot;\u0026lt;/span\u0026gt;) y = \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;toPrimitive\u0026lt;/span\u0026gt;(y);\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typeof\u0026lt;/span\u0026gt; y === \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typeof\u0026lt;/span\u0026gt; x) \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; y === x;\n\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// convert x and y into numbers if they are not already use the \u0026quot;+\u0026quot; trick\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typeof\u0026lt;/span\u0026gt; x !== \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;number\u0026quot;\u0026lt;/span\u0026gt;) x = +x;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typeof\u0026lt;/span\u0026gt; y !== \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;number\u0026quot;\u0026lt;/span\u0026gt;) y = +y;\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// actually the real `==` is even more complicated than this, especially in ES6\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; x === y;\n}\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;toPrimitive\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;obj\u0026lt;/span\u0026gt;) {\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; value = obj.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;valueOf\u0026lt;/span\u0026gt;();\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt;(obj !== value) \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; value;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; obj.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;toString\u0026lt;/span\u0026gt;();\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;So what does this mean?\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;It means \u0026lt;code\u0026gt;==\u0026lt;/code\u0026gt; is complicated.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Because it\u0026apos;s complicated it\u0026apos;s hard to know what\u0026apos;s going to happen when you use it.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Which means you could end up with bugs.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;So the moral of the story is...\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Make your life less complicated.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Use \u0026lt;code\u0026gt;===\u0026lt;/code\u0026gt; instead of \u0026lt;code\u0026gt;==\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;The End.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;The \u0026lt;strong\u0026gt;===\u0026lt;/strong\u0026gt; operator is called a strict comparison operator, it \u0026lt;strong\u0026gt;does\u0026lt;/strong\u0026gt; differ from the \u0026lt;strong\u0026gt;==\u0026lt;/strong\u0026gt; operator.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Lets take 2 vars a and b.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;For \u0026lt;strong\u0026gt;\u0026quot;a == b\u0026quot;\u0026lt;/strong\u0026gt; to evaluate to true a and b need to be the \u0026lt;strong\u0026gt;same value\u0026lt;/strong\u0026gt;.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;In the case of \u0026lt;strong\u0026gt;\u0026quot;a === b\u0026quot;\u0026lt;/strong\u0026gt; a and b must be the \u0026lt;strong\u0026gt;same value\u0026lt;/strong\u0026gt; and also the \u0026lt;strong\u0026gt;same type\u0026lt;/strong\u0026gt; for it to evaluate to true.  \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Take the following example\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; a = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; b = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;1\u0026quot;\u0026lt;/span\u0026gt;;\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (a == b) \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//evaluates to true as a and b are both 1\u0026lt;/span\u0026gt;\n{\n    \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;alert\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;a == b\u0026quot;\u0026lt;/span\u0026gt;);\n}\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (a === b) \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//evaluates to false as a is not the same type as b\u0026lt;/span\u0026gt;\n{\n    \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;alert\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;a === b\u0026quot;\u0026lt;/span\u0026gt;);\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;In summary\u0026lt;/strong\u0026gt;; using the \u0026lt;strong\u0026gt;==\u0026lt;/strong\u0026gt; operator might evaluate to true in situations where you do not want it to so using the \u0026lt;strong\u0026gt;===\u0026lt;/strong\u0026gt; operator would be safer.  \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;In the 90% usage scenario it won\u0026apos;t matter which one you use, but it is handy to know the difference when you get some unexpected behaviour one day.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;h1\u0026gt;\u0026lt;code\u0026gt;===\u0026lt;/code\u0026gt; checks same sides are equal in \u0026lt;em\u0026gt;type\u0026lt;/em\u0026gt; as well as \u0026lt;em\u0026gt;value\u0026lt;/em\u0026gt;.\u0026lt;/h1\u0026gt;\n\u0026lt;hr\u0026gt;\n\u0026lt;h2\u0026gt;Example:\u0026lt;/h2\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;1\u0026apos;\u0026lt;/span\u0026gt; === \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// will return \u0026quot;false\u0026quot; because `string` is not a `number`\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;h2\u0026gt;Common example:\u0026lt;/h2\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt; == \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;\u0026apos;\u0026lt;/span\u0026gt;  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// will be \u0026quot;true\u0026quot;, but it\u0026apos;s very common to want this check to be \u0026quot;false\u0026quot;\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;h2\u0026gt;Another common example:\u0026lt;/h2\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;null\u0026lt;/span\u0026gt; == \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;undefined\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// returns \u0026quot;true\u0026quot;, but in most cases a distinction is necessary\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;hr\u0026gt;\n\u0026lt;p\u0026gt;Many times an \u0026lt;em\u0026gt;untyped\u0026lt;/em\u0026gt; check would be handy because you do not care if the value is either \u0026lt;code\u0026gt;undefined\u0026lt;/code\u0026gt;, \u0026lt;code\u0026gt;null\u0026lt;/code\u0026gt;, \u0026lt;code\u0026gt;0\u0026lt;/code\u0026gt;  or \u0026lt;code\u0026gt;\u0026quot;\u0026quot;\u0026lt;/code\u0026gt;\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Javascript execution flow diagram for strict equality / Comparison \u0026apos;===\u0026apos;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;a href=\u0026quot;https://i.stack.imgur.com/A27Be.png\u0026quot;\u0026gt;\u0026lt;img src=\u0026quot;https://i.stack.imgur.com/A27Be.png\u0026quot; alt=\u0026quot;Javascript strict equality\u0026quot;\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Javascript execution flow diagram for non strict equality / comparison \u0026apos;==\u0026apos;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;a href=\u0026quot;https://i.stack.imgur.com/Ccyb8.png\u0026quot;\u0026gt;\u0026lt;img src=\u0026quot;https://i.stack.imgur.com/Ccyb8.png\u0026quot; alt=\u0026quot;Javascript non equality\u0026quot;\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;JavaScript \u0026lt;code\u0026gt;===\u0026lt;/code\u0026gt; \u0026lt;strong\u0026gt;vs\u0026lt;/strong\u0026gt; \u0026lt;code\u0026gt;==\u0026lt;/code\u0026gt; .\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;==\u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;false\u0026lt;/span\u0026gt;   \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// true\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;===\u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;false\u0026lt;/span\u0026gt;  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// false, because they are of a different type\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;==\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;1\u0026quot;\u0026lt;/span\u0026gt;     \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// true, auto type coercion\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;===\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;1\u0026quot;\u0026lt;/span\u0026gt;    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// false, because they are of a different type\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;It means \u0026lt;strong\u0026gt;equality without type coercion\u0026lt;/strong\u0026gt;\ntype coercion means JavaScript do not automatically convert any other data types to string data types \u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;==\u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;false\u0026lt;/span\u0026gt;   \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// true,although they are different types\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;===\u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;false\u0026lt;/span\u0026gt;  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// false,as they are different types\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;==\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;2\u0026apos;\u0026lt;/span\u0026gt;    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//true,different types,one is string and another is integer but \u0026lt;/span\u0026gt;\n            javaScript convert \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt; to string by using == operator \n\n\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;===\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;2\u0026apos;\u0026lt;/span\u0026gt;  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//false because by using === operator ,javaScript do not convert \u0026lt;/span\u0026gt;\n           integer to string \n\n\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;===\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;   \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//true because both have same value and same types \u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;In a typical script there will be no performance difference. More important may be the fact that thousand \u0026quot;===\u0026quot; is 1\u0026amp;nbsp;KB heavier than thousand \u0026quot;==\u0026quot; :) \u0026lt;a href=\u0026quot;https://stackoverflow.com/questions/tagged/javascript+performance\u0026quot;\u0026gt;JavaScript profilers\u0026lt;/a\u0026gt; can tell you if there is a performance difference in your case.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;But personally I would do what JSLint suggests. This recommendation is there not because of performance issues, but because type coercion means \u0026lt;code\u0026gt;(\u0026apos;\\t\\r\\n\u0026apos; == 0)\u0026lt;/code\u0026gt; is true.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;\u0026lt;em\u0026gt;\u0026lt;strong\u0026gt;The equal comparison operator == is confusing and should be avoided.\u0026lt;/strong\u0026gt;\u0026lt;/em\u0026gt; \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;If you \u0026lt;strong\u0026gt;HAVE TO\u0026lt;/strong\u0026gt; live with it, then remember the following 3 things: \u0026lt;/p\u0026gt;\n\n\u0026lt;ol\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;strong\u0026gt;It is not transitive: \u0026lt;em\u0026gt;(a == b)\u0026lt;/em\u0026gt; and \u0026lt;em\u0026gt;(b == c)\u0026lt;/em\u0026gt; does not lead to \u0026lt;em\u0026gt;(a == c)\u0026lt;/em\u0026gt;\u0026lt;/strong\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;strong\u0026gt;It\u0026apos;s mutually exclusive to its negation: \u0026lt;em\u0026gt;(a == b)\u0026lt;/em\u0026gt; and \u0026lt;em\u0026gt;(a != b)\u0026lt;/em\u0026gt; always hold opposite Boolean values, with all a and b.\u0026lt;/strong\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;strong\u0026gt;In case of doubt, learn by heart the following truth table:\u0026lt;/strong\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;/ol\u0026gt;\n\n\u0026lt;p\u0026gt;EQUAL OPERATOR TRUTH TABLE IN JAVASCRIPT\u0026lt;/p\u0026gt;\n\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;Each row in the table is a set of 3 mutually \u0026quot;equal\u0026quot; values, meaning that any 2 values among them are equal using the equal == sign*\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\n\u0026lt;p\u0026gt;** STRANGE: note that any two values on the first column are not equal in that sense.**\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;\u0026apos;\u0026lt;/span\u0026gt;       == \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt; == \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;false\u0026lt;/span\u0026gt;   \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Any two values among these 3 ones are equal with the == operator\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;0\u0026apos;\u0026lt;/span\u0026gt;      == \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt; == \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;false\u0026lt;/span\u0026gt;   \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Also a set of 3 equal values, note that only 0 and false are repeated\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;\\t\u0026apos;\u0026lt;/span\u0026gt;     == \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt; == \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;false\u0026lt;/span\u0026gt;   \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;\\r\u0026apos;\u0026lt;/span\u0026gt;     == \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt; == \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;false\u0026lt;/span\u0026gt;   \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;\\n\u0026apos;\u0026lt;/span\u0026gt;     == \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt; == \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;false\u0026lt;/span\u0026gt;   \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;\\t\\r\\n\u0026apos;\u0026lt;/span\u0026gt; == \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt; == \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;false\u0026lt;/span\u0026gt;   \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;null\u0026lt;/span\u0026gt; == \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;undefined\u0026lt;/span\u0026gt;  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// These two \u0026quot;default\u0026quot; values are not-equal to any of the listed values above\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;NaN\u0026lt;/span\u0026gt;                \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// NaN is not equal to any thing, even to itself.\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;There is unlikely to be any performance difference between the two operations in your usage. There is no type-conversion to be done because both parameters are already the same type. Both operations will have a type comparison followed by a value comparison.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Yes!\u0026lt;/strong\u0026gt; It does matter.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;code\u0026gt;===\u0026lt;/code\u0026gt; operator in javascript \u0026lt;strong\u0026gt;checks value as well as type\u0026lt;/strong\u0026gt; where as \u0026lt;code\u0026gt;==\u0026lt;/code\u0026gt; operator just checks \u0026lt;strong\u0026gt;the value (does type conversion if required)\u0026lt;/strong\u0026gt;.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;img src=\u0026quot;https://i.stack.imgur.com/5ttlR.png\u0026quot; alt=\u0026quot;enter image description here\u0026quot;\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;You can easily test it. Paste following code in an HTML file and open it in browser\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026amp;lt;script\u0026amp;gt;\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;onPageLoad\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;)\n{\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; x = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;5\u0026quot;\u0026lt;/span\u0026gt;;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; y = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;5\u0026lt;/span\u0026gt;;\n    \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;alert\u0026lt;/span\u0026gt;(x === \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;5\u0026lt;/span\u0026gt;);\n};\n\n\u0026amp;lt;/script\u0026amp;gt;\n\n\u0026amp;lt;/head\u0026amp;gt;\n\n\u0026lt;span class=\u0026quot;language-xml\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-tag\u0026quot;\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;body\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-attr\u0026quot;\u0026gt;onload\u0026lt;/span\u0026gt;=\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;onPageLoad();\u0026apos;\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026lt;/span\u0026gt;\n\u0026lt;/span\u0026gt;\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;You will get \u0026apos;\u0026lt;strong\u0026gt;false\u0026lt;/strong\u0026gt;\u0026apos; in alert. Now modify the \u0026lt;code\u0026gt;onPageLoad()\u0026lt;/code\u0026gt; method to \u0026lt;code\u0026gt;alert(x == 5);\u0026lt;/code\u0026gt; you will get \u0026lt;strong\u0026gt;true\u0026lt;/strong\u0026gt;.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Simply\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;code\u0026gt;==\u0026lt;/code\u0026gt; means \u0026lt;strong\u0026gt;comparison\u0026lt;/strong\u0026gt; between operands \u0026lt;strong\u0026gt;with\u0026lt;/strong\u0026gt; type coercion\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;and\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;code\u0026gt;===\u0026lt;/code\u0026gt; means \u0026lt;strong\u0026gt;comparison\u0026lt;/strong\u0026gt; between operands \u0026lt;strong\u0026gt;without\u0026lt;/strong\u0026gt; type coercion.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Type coercion in JavaScript means automatically converting data types to other data types.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;For example:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;123\u0026lt;/span\u0026gt; == \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;123\u0026quot;\u0026lt;/span\u0026gt;  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Returns true, because JS coerces string \u0026quot;123\u0026quot; to number 123\u0026lt;/span\u0026gt;\n              \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// and then goes on to compare `123 == 123`.\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;123\u0026lt;/span\u0026gt; === \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;123\u0026quot;\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Returns false, because JS does not coerce values of different types here.\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;As a rule of thumb, I would generally use \u0026lt;code\u0026gt;===\u0026lt;/code\u0026gt; instead of \u0026lt;code\u0026gt;==\u0026lt;/code\u0026gt; (and \u0026lt;code\u0026gt;!==\u0026lt;/code\u0026gt; instead of \u0026lt;code\u0026gt;!=\u0026lt;/code\u0026gt;).\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Reasons are explained in in the answers above and also Douglas Crockford is pretty clear about it (\u0026lt;a href=\u0026quot;https://rads.stackoverflow.com/amzn/click/com/0596517742\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;JavaScript: The Good Parts\u0026lt;/a\u0026gt;).\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;However there is \u0026lt;strong\u0026gt;one single exception\u0026lt;/strong\u0026gt;:\n\u0026lt;code\u0026gt;== null\u0026lt;/code\u0026gt; is an efficient way to check for \u0026apos;is null or undefined\u0026apos;:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt;( value == \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;null\u0026lt;/span\u0026gt; ){\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// value is either null or undefined\u0026lt;/span\u0026gt;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;For example jQuery 1.9.1 uses this pattern 43 times, and  the \u0026lt;a href=\u0026quot;http://www.jshint.com/docs/#options\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;JSHint syntax checker\u0026lt;/a\u0026gt; even provides the \u0026lt;code\u0026gt;eqnull\u0026lt;/code\u0026gt; relaxing option for this reason.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;From the \u0026lt;a href=\u0026quot;http://contribute.jquery.org/style-guide/js/\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;jQuery style guide\u0026lt;/a\u0026gt;:\u0026lt;/p\u0026gt;\n\u0026lt;blockquote\u0026gt;\n\u0026lt;p\u0026gt;Strict equality checks (===) should be used in favor of ==. The only\nexception is when checking for undefined and null by way of null.\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Check for both undefined and null values, for some important reason. \u0026lt;/span\u0026gt;\nundefOrNull == \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;null\u0026lt;/span\u0026gt;;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;EDIT 2021-03:\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Nowadays \u0026lt;a href=\u0026quot;https://caniuse.com/mdn-javascript_operators_logical_nullish_assignment\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;most browsers\u0026lt;/a\u0026gt;\nsupport the \u0026lt;a href=\u0026quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Nullish_coalescing_operator\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;Nullish coalescing operator (\u0026lt;code\u0026gt;??\u0026lt;/code\u0026gt;)\u0026lt;/a\u0026gt;\nand the \u0026lt;a href=\u0026quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Logical_nullish_assignment\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;Logical nullish assignment \u0026lt;code\u0026gt;(??=)\u0026lt;/code\u0026gt;\u0026lt;/a\u0026gt;, which allows a more concise way to\nassign a default value if a variable is null or undefined, for example:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (a.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;speed\u0026lt;/span\u0026gt; == \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;null\u0026lt;/span\u0026gt;) {\n  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Set default if null or undefined\u0026lt;/span\u0026gt;\n  a.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;speed\u0026lt;/span\u0026gt; = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;42\u0026lt;/span\u0026gt;;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;can be written as any of these forms\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;a.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;speed\u0026lt;/span\u0026gt; ??= \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;42\u0026lt;/span\u0026gt;;\na.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;speed\u0026lt;/span\u0026gt; ?? a.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;speed\u0026lt;/span\u0026gt; = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;42\u0026lt;/span\u0026gt;;\na.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;speed\u0026lt;/span\u0026gt; = a.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;speed\u0026lt;/span\u0026gt; ?? \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;42\u0026lt;/span\u0026gt;;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;It\u0026apos;s a strict check test.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;It\u0026apos;s a good thing especially if you\u0026apos;re checking between 0 and false and null. \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;For example, if you have:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;$a = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Then:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;$a==\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;; \n$a==\u0026lt;span class=\u0026quot;hljs-variable constant_\u0026quot;\u0026gt;NULL\u0026lt;/span\u0026gt;;\n$a==\u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;false\u0026lt;/span\u0026gt;;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;All returns true and you may not want this. Let\u0026apos;s suppose you have a function that can return the 0th index of an array or false on failure. If you check with \u0026quot;==\u0026quot; false, you can get a confusing result.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;So with the same thing as above, but a strict test:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;$a = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;;\n\n$a===\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// returns true\u0026lt;/span\u0026gt;\n$a===\u0026lt;span class=\u0026quot;hljs-variable constant_\u0026quot;\u0026gt;NULL\u0026lt;/span\u0026gt;; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// returns false\u0026lt;/span\u0026gt;\n$a===\u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;false\u0026lt;/span\u0026gt;; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// returns false\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;\u0026lt;code\u0026gt;===\u0026lt;/code\u0026gt; operator  checks the values as well as the types of the variables for equality.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;code\u0026gt;==\u0026lt;/code\u0026gt; operator just checks the value of the variables for equality.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;JSLint sometimes gives you unrealistic reasons to modify stuff. \u0026lt;code\u0026gt;===\u0026lt;/code\u0026gt; has exactly the same performance as \u0026lt;code\u0026gt;==\u0026lt;/code\u0026gt; if the types are already the same. \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;It is faster only when the types are not the same, in which case it does not try to convert types but directly returns a false.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;So, \u0026lt;em\u0026gt;IMHO,\u0026lt;/em\u0026gt; JSLint maybe used to write new code, but useless over-optimizing should be avoided at all costs. \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Meaning, there is no reason to change \u0026lt;code\u0026gt;==\u0026lt;/code\u0026gt; to \u0026lt;code\u0026gt;===\u0026lt;/code\u0026gt; in a check like \u0026lt;code\u0026gt;if (a == \u0026apos;test\u0026apos;)\u0026lt;/code\u0026gt; when you know it for a fact that a can only be a String. \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Modifying a lot of code that way wastes developers\u0026apos; and reviewers\u0026apos; time and achieves nothing.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;A simple example is \u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt; == \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;2\u0026apos;\u0026lt;/span\u0026gt;  -\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;true\u0026lt;/span\u0026gt;, values are \u0026lt;span class=\u0026quot;hljs-variable constant_\u0026quot;\u0026gt;SAME\u0026lt;/span\u0026gt; because \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;of\u0026lt;/span\u0026gt; type conversion.\n\n\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt; === \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;2\u0026apos;\u0026lt;/span\u0026gt;  -\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;false\u0026lt;/span\u0026gt;, values are \u0026lt;span class=\u0026quot;hljs-variable constant_\u0026quot;\u0026gt;NOT\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-variable constant_\u0026quot;\u0026gt;SAME\u0026lt;/span\u0026gt; because \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;of\u0026lt;/span\u0026gt; no type conversion.\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;The top 2 answers both mentioned == means equality and === means identity. Unfortunately, this statement is incorrect. \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;If both operands of == are objects, then they are compared to see if they are the same object. If both operands point to the same object, then the equal operator returns true. Otherwise,\nthe two are not equal. \u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; a = [\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3\u0026lt;/span\u0026gt;];  \n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; b = [\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3\u0026lt;/span\u0026gt;];  \n\u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;console\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;log\u0026lt;/span\u0026gt;(a == b)  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// false  \u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;console\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;log\u0026lt;/span\u0026gt;(a === b) \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// false  \u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;In the code above, both == and === get false because a and b are not the same objects.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;That\u0026apos;s to say: if both operands of == are objects, == behaves same as ===, which also means identity. The essential difference of this two operators is about type conversion. == has conversion before it checks equality, but === does not.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;The problem is that you might easily get into trouble since JavaScript have a lot of implicit conversions meaning...\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; x = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; isTrue = x == \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;null\u0026lt;/span\u0026gt;;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; isFalse = x === \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;null\u0026lt;/span\u0026gt;;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Which pretty soon becomes a problem. The best sample of why implicit conversion is \u0026quot;evil\u0026quot; can be taken from this code in \u0026lt;a href=\u0026quot;http://en.wikipedia.org/wiki/Microsoft_Foundation_Class_Library\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;MFC\u0026lt;/a\u0026gt; / C++ which actually will compile due to an implicit conversion from CString to HANDLE which is a pointer typedef type...\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;CString\u0026lt;/span\u0026gt; x;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;delete\u0026lt;/span\u0026gt; x;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Which obviously during runtime does \u0026lt;em\u0026gt;very\u0026lt;/em\u0026gt; undefined things...\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Google for implicit conversions in C++ and \u0026lt;a href=\u0026quot;http://en.wikipedia.org/wiki/Standard_Template_Library\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;STL\u0026lt;/a\u0026gt; to get some of the arguments against it...\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;From the \u0026lt;a href=\u0026quot;https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Operators/Comparison_Operators\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;core javascript reference\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;\u0026lt;code\u0026gt;===\u0026lt;/code\u0026gt; Returns \u0026lt;code\u0026gt;true\u0026lt;/code\u0026gt; if the operands are strictly equal (see above)\n  with no type conversion.\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n    ","\n\u0026lt;p\u0026gt;\u0026lt;b\u0026gt;Equality comparison: \u0026lt;/b\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Operator \u0026lt;code\u0026gt;==\u0026lt;/code\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Returns true, when both operands are equal. The operands are converted to the same type before being compared.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt; == \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;true\u0026lt;/span\u0026gt;\n\u0026amp;gt;\u0026amp;gt;\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt; == \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;false\u0026lt;/span\u0026gt;\n\u0026amp;gt;\u0026amp;gt;\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt; == \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;1\u0026apos;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;true\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;b\u0026gt;Equality and type comparison: \u0026lt;/b\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Operator \u0026lt;code\u0026gt;===\u0026lt;/code\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Returns true if both operands are equal and of the same type. It\u0026apos;s generally \nbetter and safer if you compare this way, because there\u0026apos;s no behind-the-scenes type conversions.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt; === \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;1\u0026apos;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;false\u0026lt;/span\u0026gt;\n\u0026amp;gt;\u0026amp;gt;\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt; === \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;true\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Here is a handy comparison table that shows the conversions that happen and the differences between \u0026lt;code\u0026gt;==\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;===\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;As the conclusion states:\u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;\u0026quot;Use three equals unless you fully understand the conversions that take\n  place for two-equals.\u0026quot;\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;a href=\u0026quot;http://dorey.github.io/JavaScript-Equality-Table/\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;http://dorey.github.io/JavaScript-Equality-Table/\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;null and undefined are nothingness, that is,\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; a;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; b = \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;null\u0026lt;/span\u0026gt;;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Here \u0026lt;code\u0026gt;a\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;b\u0026lt;/code\u0026gt; do not have values. Whereas, 0, false and \u0026apos;\u0026apos; are all values. One thing common beween all these are that they are all falsy values, which means they all \u0026lt;strong\u0026gt;satisfy\u0026lt;/strong\u0026gt; falsy conditions.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;So, the 0, false and \u0026apos;\u0026apos; together form a sub-group. And on other hand, null \u0026amp;amp; undefined form the second sub-group. Check the comparisons in the below image. null and undefined would equal. The other three would equal to each other. But, they all are treated as falsy conditions in JavaScript.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;img src=\u0026quot;https://i.stack.imgur.com/11I0i.jpg\u0026quot; alt=\u0026quot;Enter image description here\u0026quot;\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;This is same as any object (like {}, arrays, etc.), non-empty string \u0026amp;amp; Boolean true are all truthy conditions. But, they are all not equal.\u0026lt;/p\u0026gt;\n    "],"id":116,"title":"Which equals operator (== vs ===) should be used in JavaScript comparisons?","content":"\n                    \u0026lt;div\u0026gt;\n            \u0026lt;aside class=\u0026quot;s-notice s-notice__info post-notice js-post-notice mb16\u0026quot; role=\u0026quot;status\u0026quot;\u0026gt;\n        \u0026lt;div class=\u0026quot;d-flex fd-column fw-nowrap\u0026quot;\u0026gt;\n            \u0026lt;div class=\u0026quot;d-flex fw-nowrap\u0026quot;\u0026gt;\n                    \u0026lt;div class=\u0026quot;flex--item mr8\u0026quot;\u0026gt;\n                        \u0026lt;svg aria-hidden=\u0026quot;true\u0026quot; class=\u0026quot;svg-icon iconLock\u0026quot; width=\u0026quot;18\u0026quot; height=\u0026quot;18\u0026quot; viewBox=\u0026quot;0 0 18 18\u0026quot;\u0026gt;\u0026lt;path d=\u0026quot;M16 9a2 2 0 0 0-2-2V6A5 5 0 0 0 4 6v1a2 2 0 0 0-2 2v6c0 1.1.9 2 2 2h10a2 2 0 0 0 2-2V9Zm-7 5a2 2 0 1 1 0-4 2 2 0 0 1 0 4Zm3.1-7H5.9V6a3.1 3.1 0 0 1 6.2 0v1Z\u0026quot;\u0026gt;\u0026lt;/path\u0026gt;\u0026lt;/svg\u0026gt;\n                    \u0026lt;/div\u0026gt;\n                \u0026lt;div class=\u0026quot;flex--item wmn0 fl1 lh-lg\u0026quot;\u0026gt;\n                    \u0026lt;div class=\u0026quot;flex--item fl1 lh-lg\u0026quot;\u0026gt;\n                        \u0026lt;b\u0026gt;This question\u0026apos;s answers are a \u0026lt;a href=\u0026quot;/help/privileges/edit-community-wiki\u0026quot;\u0026gt;community effort\u0026lt;/a\u0026gt;\u0026lt;/b\u0026gt;. Edit existing answers to improve this post. It is not currently accepting new answers or interactions.\n                        \n                    \u0026lt;/div\u0026gt;\n                \u0026lt;/div\u0026gt;\n            \u0026lt;/div\u0026gt;\n        \u0026lt;/div\u0026gt;\n\u0026lt;/aside\u0026gt;\n\n    \u0026lt;/div\u0026gt;\n\n\u0026lt;p\u0026gt;I\u0026apos;m using \u0026lt;a href=\u0026quot;http://en.wikipedia.org/wiki/JSLint\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;JSLint\u0026lt;/a\u0026gt; to go through JavaScript, and it\u0026apos;s returning many suggestions to replace \u0026lt;code\u0026gt;==\u0026lt;/code\u0026gt; (two equals signs) with \u0026lt;code\u0026gt;===\u0026lt;/code\u0026gt; (three equals signs) when doing things like comparing \u0026lt;code\u0026gt;idSele_UNVEHtype.value.length == 0\u0026lt;/code\u0026gt; inside of an \u0026lt;code\u0026gt;if\u0026lt;/code\u0026gt; statement.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Is there a performance benefit to replacing \u0026lt;code\u0026gt;==\u0026lt;/code\u0026gt; with \u0026lt;code\u0026gt;===\u0026lt;/code\u0026gt;? \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Any performance improvement would be welcomed as many comparison operators exist.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;If no type conversion takes place, would there be a performance gain over \u0026lt;code\u0026gt;==\u0026lt;/code\u0026gt;?\u0026lt;/p\u0026gt;\n    ","slug":"which-equals-operator-(-vs-)-should-be-used-in-javascript-comparisons-1657384663105","postType":"QUESTION","createdAt":"2022-07-09T16:37:43.000Z","updatedAt":"2022-07-09T16:37:43.000Z","tags":[{"id":426,"name":"equality-operator","slug":"equality-operator","createdAt":"2022-07-09T16:37:43.000Z","updatedAt":"2022-07-09T16:37:43.000Z","Questions_Tags":{"questionId":116,"tagId":426}},{"id":427,"name":"identity-operator","slug":"identity-operator","createdAt":"2022-07-09T16:37:43.000Z","updatedAt":"2022-07-09T16:37:43.000Z","Questions_Tags":{"questionId":116,"tagId":427}}],"relatedQuestions":[{"title":"Which equals operator (== vs ===) should be used in JavaScript comparisons?","slug":"which-equals-operator-(-vs-)-should-be-used-in-javascript-comparisons-1657384663105","tags":[{"name":"equality-operator","Questions_Tags":{"questionId":116,"tagId":426}},{"name":"identity-operator","Questions_Tags":{"questionId":116,"tagId":427}}]}]},"randomQuestions":[{"title":"Can a local variable's memory be accessed outside its scope?","slug":"can-a-local-variable's-memory-be-accessed-outside-its-scope-1657384460386"},{"title":"How do I return the response from an asynchronous call?","slug":"how-do-i-return-the-response-from-an-asynchronous-call-1657384208012"},{"title":"HTTP GET with request body","slug":"http-get-with-request-body-1657387379038"},{"title":"Random number generator only generating one random number","slug":"random-number-generator-only-generating-one-random-number-1657385468315"},{"title":"Deserialize JSON into C# dynamic object?","slug":"deserialize-json-into-c-dynamic-object-1657388568720"},{"title":"How to avoid having class data shared among instances?","slug":"how-to-avoid-having-class-data-shared-among-instances-1657387687732"},{"title":"How can I validate an email address in JavaScript?","slug":"how-can-i-validate-an-email-address-in-javascript-1657385475959"},{"title":"Are 'Arrow Functions' and 'Functions' equivalent / interchangeable?","slug":"are-'arrow-functions'-and-'functions'-equivalent-interchangeable-1657384527873"},{"title":"What are drawbacks or disadvantages of singleton pattern? [closed]","slug":"what-are-drawbacks-or-disadvantages-of-singleton-pattern-closed-1657387360749"},{"title":"How do I compare strings in Java?","slug":"how-do-i-compare-strings-in-java-1657384243187"},{"title":"Firebase query if child of child contains a value","slug":"firebase-query-if-child-of-child-contains-a-value-1657387841291"},{"title":"How to lazy load images in ListView in Android","slug":"how-to-lazy-load-images-in-listview-in-android-1657387332835"},{"title":"What is the copy-and-swap idiom?","slug":"what-is-the-copy-and-swap-idiom-1657384840329"},{"title":"Select first row in each GROUP BY group?","slug":"select-first-row-in-each-group-by-group-1657384809388"},{"title":"How to remove \"noise\" from GCC/clang assembly output?","slug":"how-to-remove-\"noise\"-from-gccclang-assembly-output-1657387612391"},{"title":"What is the canonical way to check for errors using the CUDA runtime API?","slug":"what-is-the-canonical-way-to-check-for-errors-using-the-cuda-runtime-api-1657387302698"},{"title":"Calling a function of a module by using its name (a string)","slug":"calling-a-function-of-a-module-by-using-its-name-(a-string)-1657388565656"},{"title":"Most efficient method to groupby on an array of objects","slug":"most-efficient-method-to-groupby-on-an-array-of-objects-1657387580538"},{"title":"How do JavaScript closures work?","slug":"how-do-javascript-closures-work-1657384418555"},{"title":"How to use SharedPreferences in Android to store, fetch and edit values [closed]","slug":"how-to-use-sharedpreferences-in-android-to-store-fetch-and-edit-values-closed-1657387683057"}]},"__N_SSG":true},"page":"/questions/[slug]","query":{"slug":"which-equals-operator-(-vs-)-should-be-used-in-javascript-comparisons-1657384663105"},"buildId":"5tS3Jli5j89_wXapXajXn","isFallback":false,"gsp":true,"locale":"en","locales":["en"],"defaultLocale":"en","scriptLoader":[]}</script></body></html>