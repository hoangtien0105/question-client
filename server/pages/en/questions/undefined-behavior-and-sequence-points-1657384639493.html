<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><meta name="twitter:card" content="summary_large_image"/><meta name="twitter:site" content="@solutionschecker.com"/><meta name="twitter:creator" content="@solutionschecker.com"/><meta property="og:url" content="https://solutionschecker.com"/><meta property="og:type" content="website"/><meta property="og:image" content="https://solutionschecker.com/solutions-checker-banner.png"/><meta property="og:image:alt" content="Find solution for coding, HTML, CSS, JAVASCRIPT, MYSQL, PHP, PYTHON,... quickly. - solutionschecker.com"/><script type="application/ld+json">{"@context":"https://schema.org","@type":"Organization","logo":"/logo.svg","url":"https://solutionschecker.com"}</script><title>Undefined behavior and sequence points | Solutions Checker</title><meta name="robots" content="index,follow"/><meta name="description" content="What are &quot;sequence points&quot;?
What is the relation between undefined behaviour and sequence points?
I often use funny and convoluted expressions like a[++i] = i;, to make myself feel better. Why should I stop using them?
If you&#x27;ve read this, be sure to visit the follow-up question Undefined behavior and sequence points reloaded.

(Note: This is meant to be an entry to Stack Overflow&#x27;s C++ FAQ. If you want to critique the idea of providing an FAQ in this form, then the posting on meta that started all this would be the place to do that. Answers to that question are monitored in the C++ chatroom, where the FAQ idea started out in the first place, so your answer is very likely to get read by those who came up with the idea.)

    "/><meta property="og:title" content="Undefined behavior and sequence points | Solutions Checker"/><meta property="og:description" content="What are &quot;sequence points&quot;?
What is the relation between undefined behaviour and sequence points?
I often use funny and convoluted expressions like a[++i] = i;, to make myself feel better. Why should I stop using them?
If you&#x27;ve read this, be sure to visit the follow-up question Undefined behavior and sequence points reloaded.

(Note: This is meant to be an entry to Stack Overflow&#x27;s C++ FAQ. If you want to critique the idea of providing an FAQ in this form, then the posting on meta that started all this would be the place to do that. Answers to that question are monitored in the C++ chatroom, where the FAQ idea started out in the first place, so your answer is very likely to get read by those who came up with the idea.)

    "/><script type="application/ld+json">{"@context":"https://schema.org","@type":"QAPage","mainEntity":{"name":"Undefined behavior and sequence points","text":"What are &quot;sequence points&quot;?\nWhat is the relation between undefined behaviour and sequence points?\nI often use funny and convoluted expressions like a[++i] = i;, to make myself feel better. Why should I stop using them?\nIf you&apos;ve read this, be sure to visit the follow-up question Undefined behavior and sequence points reloaded.\n\n(Note: This is meant to be an entry to Stack Overflow&apos;s C++ FAQ. If you want to critique the idea of providing an FAQ in this form, then the posting on meta that started all this would be the place to do that. Answers to that question are monitored in the C++ chatroom, where the FAQ idea started out in the first place, so your answer is very likely to get read by those who came up with the idea.)\n\n    ","answerCount":5,"upVoteCount":500,"suggestedAnswer":[{"text":"C++98 and C++03\nThis answer is for the older versions of the C++ standard.  The C++11 and C++14 versions of the standard do not formally contain &apos;sequence points&apos;; operations are &apos;sequenced before&apos; or &apos;unsequenced&apos; or &apos;indeterminately sequenced&apos; instead.  The net effect is essentially the same, but the terminology is different.\n\nDisclaimer : Okay. This answer is a bit long. So have patience while reading it. If you already know these things, reading them again won&apos;t make you crazy.\nPre-requisites : An elementary knowledge of C++ Standard\n\nWhat are Sequence Points?\nThe Standard says\n\nAt  certain specified points in the execution sequence called sequence points, all side effects of previous evaluations\nshall be complete and no side effects of subsequent evaluations shall have taken place. (§1.9/7)\n\nSide effects? What are side effects?\nEvaluation  of  an  expression produces something and if in addition there is a change in the state of the execution environment it is said that the expression (its evaluation) has some side effect(s).\nFor example:\nint x = y++; //where y is also an int\n\nIn addition to the initialization operation the value of y gets changed due to the side effect of ++ operator.\nSo far so good. Moving on to sequence points. An alternation definition of seq-points given by the comp.lang.c author Steve Summit:\n\nSequence point is a point in time at which the dust has settled and all side effects which have been seen so far are guaranteed to be complete.\n\n\nWhat are the common sequence points listed in the C++ Standard?\nThose are:\n\nat the end of the evaluation of full expression (§1.9/16) (A full-expression is an expression that is not a subexpression of another expression.)1\nExample :\nint a = 5; // ; is a sequence point here\n\n\nin the evaluation of each of the following expressions after the evaluation of the first expression (§1.9/18) 2\n\na &amp;&amp; b (§5.14)\na || b (§5.15)\na ? b : c (§5.16)\na , b (§5.18) (here a , b is a comma operator; in func(a,a++) , is not a comma operator, it&apos;s merely a separator between the arguments a and a++. Thus the behaviour is undefined in that case (if a is considered to be a primitive type)) \n\n\nat a function call (whether or not the function is inline), after the evaluation of all function arguments (if any) which\ntakes place before execution of any expressions or statements in the function body (§1.9/17).\n\n\n1 : Note : the evaluation of a full-expression can include the evaluation of subexpressions that are not lexically\npart of the full-expression.  For example, subexpressions involved in evaluating default argument expressions (8.3.6) are considered to be created in the expression that calls the function, not the expression that defines the default argument\n2 : The operators indicated are the built-in operators, as described in clause 5.  When one of these operators is overloaded (clause 13) in a valid context, thus designating a user-defined operator function, the expression designates a function invocation and the operands form an argument list, without an implied sequence point between them.\n\nWhat is Undefined Behaviour?\nThe Standard defines Undefined Behaviour in Section §1.3.12 as\n\nbehavior, such as might arise upon use of an erroneous program construct or erroneous data, for which this International Standard imposes no  requirements 3.\n\n\nUndefined  behavior  may  also  be  expected  when  this\nInternational Standard omits the description of any explicit definition of behavior.\n\n 3 : permissible undefined behavior ranges from ignoring the situation completely with unpredictable results, to behaving during translation or program execution in a documented manner characteristic of the environment (with or with-\nout the issuance of a diagnostic message), to terminating a translation or execution (with the issuance of a diagnostic message).\nIn short, undefined behaviour means anything can happen from daemons flying out of your nose to  your girlfriend getting pregnant.\n\nWhat is the relation between Undefined Behaviour and Sequence Points?\nBefore I get into that you must know the difference(s) between Undefined Behaviour, Unspecified Behaviour and Implementation Defined Behaviour.\nYou must also know that the order of evaluation of operands of individual operators and subexpressions of individual expressions, and the order in which side effects take place, is unspecified.\nFor example:\nint x = 5, y = 6;\n\nint z = x++ + y++; //it is unspecified whether x++ or y++ will be evaluated first.\n\nAnother example here.\n\nNow the Standard in §5/4 says\n\n\n\nBetween the previous and next sequence point a scalar object shall have its stored value modified at most once by the evaluation of an expression.\n\n\n\nWhat does it mean?\nInformally it means that between two sequence points a variable must not be modified more than once.\nIn an expression statement, the next sequence point is usually at the terminating semicolon, and the previous sequence point is at the end of the previous statement. An expression may also contain intermediate sequence points.\nFrom the above sentence the following expressions invoke Undefined Behaviour:\ni++ * ++i;   // UB, i is modified more than once btw two SPs\ni = ++i;     // UB, same as above\n++i = 2;     // UB, same as above\ni = ++i + 1; // UB, same as above\n++++++i;     // UB, parsed as (++(++(++i)))\n\ni = (i, ++i, ++i); // UB, there&apos;s no SP between `++i` (right most) and assignment to `i` (`i` is modified more than once btw two SPs)\n\nBut the following expressions are fine:\ni = (i, ++i, 1) + 1; // well defined (AFAIK)\ni = (++i, i++, i);   // well defined \nint j = i;\nj = (++i, i++, j*i); // well defined\n\n\n\n\n\nFurthermore, the prior value shall be accessed only to determine the value to be stored.\n\n\n\nWhat does it mean? It means if an object is written to within a full expression, any and all accesses to it within the same expression must be directly involved in the computation of the value to be written.\nFor example in i = i + 1 all the access of i (in L.H.S and in R.H.S) are directly involved in computation of the value to be written. So it is fine.\nThis rule effectively constrains legal expressions to those in which the accesses demonstrably precede the modification.\nExample 1:\nstd::printf(&quot;%d %d&quot;, i,++i); // invokes Undefined Behaviour because of Rule no 2\n\nExample 2:\na[i] = i++ // or a[++i] = i or a[i++] = ++i etc\n\nis disallowed because one of the accesses of i (the one in a[i]) has nothing to do with the value which ends up being stored in i (which happens over in i++), and so there&apos;s no good way to define--either for our understanding or the compiler&apos;s--whether the access should take place before or after the incremented value is stored. So the behaviour is undefined.\nExample 3 :\nint x = i + i++ ;// Similar to above\n\n\nFollow up answer for C++11 here.\n    ","url":"/questions/[slug]#solution1","@type":"Answer","upvoteCount":0},{"text":"This is a follow up to my previous answer and contains C++11 related material..\n\n\n\nPre-requisites : An elementary knowledge of Relations (Mathematics).\n\n\n\nIs it true that there are no Sequence Points in C++11?\n\nYes! This is very true. \n\nSequence Points have been replaced by Sequenced Before and Sequenced After (and Unsequenced and Indeterminately Sequenced) relations in C++11.\n\n\n\nWhat exactly is this &apos;Sequenced before&apos; thing?\n\nSequenced Before(§1.9/13) is a relation which is: \n\n\nAsymmetric \nTransitive\n\n\nbetween evaluations executed by a single thread and induces a strict partial order1\n\nFormally it means given any two evaluations(See below) A and B, if A is sequenced before B, then the execution of A shall precede the execution of B. If A is not sequenced before B and B is not sequenced before A, then A and B are unsequenced 2.\n\nEvaluations A and B are indeterminately sequenced when either A is sequenced before B or B is sequenced before A, but it is unspecified which3.\n\n[NOTES]\n\n  1 :  A strict partial order is a binary relation &quot;&lt;&quot; over a set P which is asymmetric, and transitive, i.e., for all a, b, and c in P, we have that:   \n  ........(i). if a &lt; b then ¬ (b &lt; a) (asymmetry);\n  ........(ii). if a &lt; b and b &lt; c then a &lt; c (transitivity).\n  2 : The execution of unsequenced evaluations can overlap.\n  3 : Indeterminately sequenced evaluations cannot overlap, but either could be executed first.\n\n\n\n\n What is the meaning of the word &apos;evaluation&apos; in context of C++11? \n\nIn C++11, evaluation of an expression (or a sub-expression) in general includes: \n\n\nvalue computations (including determining the identity of an object for glvalue evaluation and fetching a value previously assigned to an object for prvalue evaluation) and\ninitiation of side effects.\n\n\nNow  (§1.9/14) says:\n\n\n  Every value computation and side effect associated with a full-expression is sequenced before every value computation and side effect associated with the next full-expression to be evaluated.\n\n\n\nTrivial example: \n\nint x;\n x = 10;\n ++x;\n\nValue computation and side effect associated with ++x is sequenced after the value computation and side effect of x = 10; \n\n\n\n\nSo there must be some relation between Undefined Behaviour and the above-mentioned things, right? \n\nYes! Right.\n\nIn (§1.9/15) it has been mentioned that \n\n\n  Except where noted, evaluations of operands of individual operators and of subexpressions of individual expressions are unsequenced4.\n\n\nFor example :\n\nint main()\n{\n     int num = 19 ;\n     num = (num &lt;&lt; 3) + (num &gt;&gt; 3);\n} \n\n\n\nEvaluation of operands of + operator are unsequenced relative to each other.\nEvaluation of operands of &lt;&lt; and &gt;&gt; operators are unsequenced relative to each other.\n\n\n 4: In an expression that is evaluated more than once during the execution\nof a program, unsequenced and indeterminately sequenced evaluations of its subexpressions need not be performed consistently in different evaluations. \n\n\n  (§1.9/15)\n  The value computations of the operands of an\n  operator are sequenced before the value computation of the result of the operator.\n\n\nThat means in x + y the value computation of x and y are sequenced before the value computation of (x + y).\n\nMore importantly\n\n\n  (§1.9/15) If a side effect on a scalar object is unsequenced relative to either\n  \n  (a) another side effect on the same scalar object \n  \n  or \n  \n  (b) a value computation using the value of the same scalar object.\n  \n  the behaviour is undefined.\n\n\nExamples:\n\nint i = 5, v[10] = { };\nvoid  f(int,  int);\n\n\n\ni = i++ * ++i;  // Undefined Behaviour\ni = ++i + i++;  // Undefined Behaviour \ni = ++i + ++i;  // Undefined Behaviour\ni = v[i++];     // Undefined Behaviour\ni = v[++i]:     // Well-defined Behavior\ni = i++ + 1;    // Undefined Behaviour\ni = ++i + 1;    // Well-defined Behaviour\n++++i;          // Well-defined Behaviour\nf(i = -1, i = -1); // Undefined Behaviour (see below)\n\n\n\n  When calling a function (whether or not the function is inline), every value computation and side effect associated with any argument expression, or with the postfix expression designating the called function, is sequenced before execution of every expression or statement in the body of the called function. [Note: Value computations and side effects associated with different argument expressions are unsequenced.   end note]\n\n\nExpressions (5), (7) and (8) do not invoke undefined behaviour. Check out the following answers for a more detailed explanation.\n\n\nMultiple preincrement operations on a variable in C++0x\nUnsequenced Value Computations\n\n\n\n\nFinal Note : \n\nIf you find any flaw in the post please leave a comment. Power-users (With rep &gt;20000) please do not hesitate to edit the post for correcting typos and other mistakes.\n    ","url":"/questions/[slug]#solution2","@type":"Answer","upvoteCount":0},{"text":"C++17 (N4659) includes a proposal Refining Expression Evaluation Order for Idiomatic C++\nwhich defines a stricter order of expression evaluation.\n\nIn particular, the following sentence\n\n\n  8.18 Assignment and compound assignment operators:....\n  \n  In all cases, the assignment is sequenced after the value\n  computation of the right and left operands, and before the value computation of the assignment expression.\n  The right operand is sequenced before the left operand.\n\n\ntogether with the following clarification\n\n\n  An expression X is said to be sequenced before an expression Y if every\n  value computation and every side effect associated with the expression X is sequenced before every value\n  computation and every side effect associated with the expression Y.\n\n\nmake several cases of previously undefined behavior valid, including the one in question:\n\na[++i] = i;\n\n\nHowever several other similar cases still lead to undefined behavior.\n\nIn N4140:\n\ni = i++ + 1; // the behavior is undefined\n\n\nBut in N4659\n\ni = i++ + 1; // the value of i is incremented\ni = i++ + i; // the behavior is undefined\n\n\nOf course, using a C++17 compliant compiler does not necessarily mean that one should start writing such expressions.\n    ","url":"/questions/[slug]#solution3","@type":"Answer","upvoteCount":0},{"text":"I am guessing there is a fundamental reason for the change, it isn&apos;t merely cosmetic to make the old interpretation clearer: that reason is concurrency. Unspecified order of elaboration is merely selection of one of several possible serial orderings, this is quite different to before and after orderings, because if there is no specified ordering, concurrent evaluation is possible: not so with the old rules. For example in:\n\nf (a,b)\n\n\npreviously either a then b, or, b then a. Now, a and b can be evaluated with instructions interleaved or even on different cores. \n    ","url":"/questions/[slug]#solution4","@type":"Answer","upvoteCount":0},{"text":"In C99(ISO/IEC 9899:TC3) which seems absent from this discussion thus far the following steteents are made regarding order of evaluaiton.\n\n\n  [...]the order of evaluation of subexpressions and the order in which\n  side effects take place are both unspecified. (Section 6.5 pp 67)\n  \n  The order of evaluation of the operands is unspecified. If an attempt\n  is made to modify the result of an assignment operator or to access it\n  after the next sequence point, the behavior[sic] is undefined.(Section\n  6.5.16 pp 91)\n\n    ","url":"/questions/[slug]#solution5","@type":"Answer","upvoteCount":0}],"@type":"Question"}}</script><meta name="next-head-count" content="16"/><link rel="preload" href="/_next/static/css/08bcc42a26fe5c92.css" as="style"/><link rel="stylesheet" href="/_next/static/css/08bcc42a26fe5c92.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-0d1b80a048d4787e.js"></script><script src="/_next/static/chunks/webpack-42cdea76c8170223.js" defer=""></script><script src="/_next/static/chunks/framework-4556c45dd113b893.js" defer=""></script><script src="/_next/static/chunks/main-ccfab947c79712f4.js" defer=""></script><script src="/_next/static/chunks/pages/_app-08d1a634dea6705e.js" defer=""></script><script src="/_next/static/chunks/29107295-fbcfe2172188e46f.js" defer=""></script><script src="/_next/static/chunks/150-b06815e21c943e0d.js" defer=""></script><script src="/_next/static/chunks/490-7f0418bb4354ac73.js" defer=""></script><script src="/_next/static/chunks/108-87de33c23337ff53.js" defer=""></script><script src="/_next/static/chunks/pages/questions/%5Bslug%5D-79a1437acf654019.js" defer=""></script><script src="/_next/static/TQ2eYlCSdocSK-hq6gkM0/_buildManifest.js" defer=""></script><script src="/_next/static/TQ2eYlCSdocSK-hq6gkM0/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="wrapper"><header><nav class="bg-white border-gray-200 px-4 lg:px-6 py-2.5 dark:bg-gray-800"><div class="flex flex-wrap justify-between items-center mx-auto max-w-screen-xl"><a class="flex items-center" href="/"><img src="/logo-second.png" class="mr-3 h-6 sm:h-9" alt="Solution Checker Logo"/><h4 class="self-center text-xl font-semibold whitespace-nowrap dark:text-white">Solution Checker</h4></a><div class="flex items-center lg:order-2"><button data-collapse-toggle="mobile-menu-2" type="button" class="inline-flex items-center p-2 ml-1 text-sm text-gray-500 rounded-lg lg:hidden hover:bg-gray-100 focus:outline-none focus:ring-2 focus:ring-gray-200 dark:text-gray-400 dark:hover:bg-gray-700 dark:focus:ring-gray-600" aria-controls="mobile-menu-2" aria-expanded="false"><span class="sr-only">Open main menu</span><svg class="w-6 h-6" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M3 5a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM3 10a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM3 15a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1z" clip-rule="evenodd"></path></svg><svg class="hidden w-6 h-6" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z" clip-rule="evenodd"></path></svg></button></div><div class="hidden justify-between items-center w-full lg:flex lg:w-auto lg:order-1" id="mobile-menu-2"><ul class="flex flex-col mt-4 font-medium lg:flex-row lg:space-x-8 lg:mt-0"><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" aria-current="page" href="/">Home</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/questions?tab=news">Questions</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/post?tab=news">Post</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/questions/undefined-behavior-and-sequence-points-1657384639493#">Coding</a></li></ul></div></div></nav></header><div class="main-content"><div class="question my-5"><div class="flex question-header items-center m-auto justify-center"><div class="rounded-xl w-full border p-5 shadow-md bg-white"><div class="flex w-full items-center justify-between border-b pb-3"><div class="flex items-center space-x-3"><div class="text-lg font-bold text-slate-700"><a href="/questions/undefined-behavior-and-sequence-points-1657384639493"><h1>Undefined behavior and sequence points</h1></a></div></div><div class="flex flex-wrap h-auto justify-end items-center space-x-8"></div></div><div class="question-content mt-5">
                
<p>What are "sequence points"?</p>
<p>What is the relation between undefined behaviour and sequence points?</p>
<p>I often use funny and convoluted expressions like <code>a[++i] = i;</code>, to make myself feel better. Why should I stop using them?</p>
<p>If you've read this, be sure to visit the follow-up question <em><a href="https://stackoverflow.com/questions/4638364">Undefined behavior and sequence points reloaded</a></em>.</p>
<sub>
<i>(Note: This is meant to be an entry to <a href="https://stackoverflow.com/questions/tagged/c++-faq">Stack Overflow's C++ FAQ</a>. If you want to critique the idea of providing an FAQ in this form, then <a href="https://meta.stackexchange.com/questions/68647/setting-up-a-faq-for-the-c-tag">the posting on meta that started all this</a> would be the place to do that. Answers to that question are monitored in the <a href="https://chat.stackoverflow.com/rooms/10/c-lounge">C++ chatroom</a>, where the FAQ idea started out in the first place, so your answer is very likely to get read by those who came up with the idea.)</i>
</sub>
    </div></div></div><div class="solution-section"><nav class="flex pagination-solution flex-col justify-end"><ul class="inline-flex -space-x-px overflow-auto"><li class="pagination-solution-item"><span data-id="#solution1" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">1</span></li><li class="pagination-solution-item"><span data-id="#solution2" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">2</span></li><li class="pagination-solution-item"><span data-id="#solution3" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">3</span></li><li class="pagination-solution-item"><span data-id="#solution4" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">4</span></li><li class="pagination-solution-item"><span data-id="#solution5" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">5</span></li></ul></nav><div id="solution1" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 1</h4><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<h3>C++98 and C++03</h3>
<p>This answer is for the older versions of the C++ standard.  The C++11 and C++14 versions of the standard do not formally contain 'sequence points'; operations are 'sequenced before' or 'unsequenced' or 'indeterminately sequenced' instead.  The net effect is essentially the same, but the terminology is different.</p>
<hr>
<p><strong>Disclaimer</strong> : Okay. This answer is a bit long. So have patience while reading it. If you already know these things, reading them again won't make you crazy.</p>
<p><strong>Pre-requisites</strong> : An elementary knowledge of <a href="http://www.open-std.org/jtc1/sc22/wg21/" rel="nofollow noreferrer">C++ Standard</a></p>
<hr>
<h2>What are Sequence Points?</h2>
<p>The Standard says</p>
<blockquote>
<p>At  certain specified points in the execution sequence called <strong>sequence points</strong>, all <em>side effects</em> of previous evaluations
shall be complete and no <em>side effects</em> of subsequent evaluations shall have taken place. (§1.9/7)</p>
</blockquote>
<h2>Side effects? What are side effects?</h2>
<p>Evaluation  of  an  expression produces something and if in addition there is a change in the state of the execution environment it is said that the expression (its evaluation) has some side effect(s).</p>
<p>For example:</p>
<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-type">int</span> x = y++; <span class="hljs-comment">//where y is also an int</span>
</code></pre>
<p>In addition to the initialization operation the value of <code>y</code> gets changed due to the side effect of <code>++</code> operator.</p>
<p>So far so good. Moving on to sequence points. An alternation definition of seq-points given by the comp.lang.c author <code>Steve Summit</code>:</p>
<blockquote>
<p>Sequence point is a point in time at which the dust has settled and all side effects which have been seen so far are guaranteed to be complete.</p>
</blockquote>
<hr>
<h2>What are the common sequence points listed in the C++ Standard?</h2>
<p>Those are:</p>
<ul>
<li><p>at the end of the evaluation of full expression (<code>§1.9/16</code>) (A full-expression is an expression that is not a subexpression of another expression.)<sup>1</sup></p>
<p>Example :</p>
<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-type">int</span> a = <span class="hljs-number">5</span>; <span class="hljs-comment">// ; is a sequence point here</span>
</code></pre>
</li>
<li><p>in the evaluation of each of the following expressions after the evaluation of the first expression (<code>§1.9/18</code>) <sup>2</sup></p>
<ul>
<li><code>a &amp;&amp; b (§5.14)</code></li>
<li><code>a || b (§5.15)</code></li>
<li><code>a ? b : c (§5.16)</code></li>
<li><code>a , b (§5.18)</code> (here a , b is a comma operator; in <code>func(a,a++)</code> <code>,</code> is not a comma operator, it's merely a separator between the arguments <code>a</code> and <code>a++</code>. Thus the behaviour is undefined in that case (if <code>a</code> is considered to be a primitive type)) <br></li>
</ul>
</li>
<li><p>at a function call (whether or not the function is inline), after the evaluation of all function arguments (if any) which
takes place before execution of any expressions or statements in the function body (<code>§1.9/17</code>).</p>
</li>
</ul>
<p><sub>1 : Note : the evaluation of a full-expression can include the evaluation of subexpressions that are not lexically
part of the full-expression.  For example, subexpressions involved in evaluating default argument expressions (8.3.6) are considered to be created in the expression that calls the function, not the expression that defines the default argument</sub></p>
<p><sub>2 : The operators indicated are the built-in operators, as described in clause 5.  When one of these operators is overloaded (clause 13) in a valid context, thus designating a user-defined operator function, the expression designates a function invocation and the operands form an argument list, without an implied sequence point between them.</sub></p>
<hr>
<h2>What is Undefined Behaviour?</h2>
<p>The Standard defines Undefined Behaviour in Section <code>§1.3.12</code> as</p>
<blockquote>
<p>behavior, such as might arise upon use of an erroneous program construct or erroneous data, for which this International Standard imposes <strong>no  requirements <sup>3</sup></strong>.</p>
</blockquote>
<blockquote>
<p>Undefined  behavior  may  also  be  expected  when  this
International Standard omits the description of any explicit definition of behavior.</p>
</blockquote>
<p><sub> 3 : permissible undefined behavior ranges from ignoring the situation completely with unpredictable results, to behaving during translation or program execution in a documented manner characteristic of the environment (with or with-
out the issuance of a diagnostic message), to terminating a translation or execution (with the issuance of a diagnostic message).</sub></p>
<p>In short, undefined behaviour means <strong>anything</strong> can happen from daemons flying out of your nose to  your girlfriend getting pregnant.</p>
<hr>
<h2>What is the relation between Undefined Behaviour and Sequence Points?</h2>
<p>Before I get into that you must know the difference(s) between <a href="https://stackoverflow.com/questions/2397984/undefined-unspecified-and-implementation-defined-behavior">Undefined Behaviour, Unspecified Behaviour and Implementation Defined Behaviour</a>.</p>
<p>You must also know that <code>the order of evaluation of operands of individual operators and subexpressions of individual expressions, and the order in which side effects take place, is unspecified</code>.</p>
<p>For example:</p>
<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-type">int</span> x = <span class="hljs-number">5</span>, y = <span class="hljs-number">6</span>;

<span class="hljs-type">int</span> z = x++ + y++; <span class="hljs-comment">//it is unspecified whether x++ or y++ will be evaluated first.</span>
</code></pre>
<p>Another example <a href="https://stackoverflow.com/questions/3457967/what-belongs-in-an-educational-tool-to-demonstrate-the-unwarranted-assumptions-pe/3458842#3458842">here</a>.</p>
<hr>
<p>Now the Standard in <code>§5/4</code> says</p>
<ul>
<li>
<ol>
<li><strong>Between the previous and next sequence point a scalar object shall have its stored value modified at most once by the evaluation of an expression.</strong></li>
</ol>
</li>
</ul>
<p>What does it mean?</p>
<p>Informally it means that between two sequence points a variable must not be modified more than once.
In an expression statement, the <code>next sequence point</code> is usually at the terminating semicolon, and the <code>previous sequence point</code> is at the end of the previous statement. An expression may also contain intermediate <code>sequence points</code>.</p>
<p>From the above sentence the following expressions invoke Undefined Behaviour:</p>
<pre class="lang-cpp s-code-block"><code class="hljs language-cpp">i++ * ++i;   <span class="hljs-comment">// UB, i is modified more than once btw two SPs</span>
i = ++i;     <span class="hljs-comment">// UB, same as above</span>
++i = <span class="hljs-number">2</span>;     <span class="hljs-comment">// UB, same as above</span>
i = ++i + <span class="hljs-number">1</span>; <span class="hljs-comment">// UB, same as above</span>
++++++i;     <span class="hljs-comment">// UB, parsed as (++(++(++i)))</span>

i = (i, ++i, ++i); <span class="hljs-comment">// UB, there's no SP between `++i` (right most) and assignment to `i` (`i` is modified more than once btw two SPs)</span>
</code></pre>
<p>But the following expressions are fine:</p>
<pre class="lang-cpp s-code-block"><code class="hljs language-cpp">i = (i, ++i, <span class="hljs-number">1</span>) + <span class="hljs-number">1</span>; <span class="hljs-comment">// well defined (AFAIK)</span>
i = (++i, i++, i);   <span class="hljs-comment">// well defined </span>
<span class="hljs-type">int</span> j = i;
j = (++i, i++, j*i); <span class="hljs-comment">// well defined</span>
</code></pre>
<hr>
<ul>
<li>
<ol start="2">
<li><strong>Furthermore, the prior value shall be accessed only to determine the value to be stored.</strong></li>
</ol>
</li>
</ul>
<p>What does it mean? It means if an object is written to within a full expression, any and all accesses to it within the same expression <strong>must be directly involved in the computation of the value to be written</strong>.</p>
<p>For example in <code>i = i + 1</code> all the access of <code>i</code> (in L.H.S and in R.H.S) are <strong>directly involved in computation</strong> of the value to be written. So it is fine.</p>
<p>This rule effectively constrains legal expressions to those in which the accesses demonstrably precede the modification.</p>
<p>Example 1:</p>
<pre class="lang-cpp s-code-block"><code class="hljs language-cpp">std::<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d %d"</span>, i,++i); <span class="hljs-comment">// invokes Undefined Behaviour because of Rule no 2</span>
</code></pre>
<p>Example 2:</p>
<pre class="lang-cpp s-code-block"><code class="hljs language-cpp">a[i] = i++ <span class="hljs-comment">// or a[++i] = i or a[i++] = ++i etc</span>
</code></pre>
<p>is disallowed because one of the accesses of <code>i</code> (the one in <code>a[i]</code>) has nothing to do with the value which ends up being stored in i (which happens over in <code>i++</code>), and so there's no good way to define--either for our understanding or the compiler's--whether the access should take place before or after the incremented value is stored. So the behaviour is undefined.</p>
<p>Example 3 :</p>
<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-type">int</span> x = i + i++ ;<span class="hljs-comment">// Similar to above</span>
</code></pre>
<hr>
<p><strong>Follow up answer for C++11 <a href="https://stackoverflow.com/questions/4176328/faq-undefined-behavior-and-sequence-points/4183735#4183735">here</a>.</strong></p>
    </div></div></div></div><div id="solution2" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 2</h4><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p><strong>This is a follow up to my <a href="https://stackoverflow.com/questions/4176328/faq-undefined-behavior-and-sequence-points/4176333#4176333">previous answer</a> and contains C++11 related material.</strong>.</p>

<hr>

<p><strong>Pre-requisites</strong> : An elementary knowledge of Relations (Mathematics).</p>

<hr>

<h2>Is it true that there are no Sequence Points in C++11?</h2>

<p><strong>Yes!</strong> This is very true. </p>

<p><strong>Sequence Points</strong> have been replaced by <strong>Sequenced Before</strong> and <strong>Sequenced After</strong> (and <strong>Unsequenced</strong> and <strong>Indeterminately Sequenced</strong>) <a href="http://en.wikipedia.org/wiki/Relation_(mathematics)" rel="noreferrer">relations</a> in C++11.</p>

<hr>

<h2>What exactly is this 'Sequenced before' thing?</h2>

<p><strong>Sequenced Before</strong><sup>(§1.9/13)</sup> is a relation which is: </p>

<ul>
<li><a href="http://en.wikipedia.org/wiki/Asymmetric_relation" rel="noreferrer"><strong>Asymmetric</strong></a> </li>
<li><a href="http://en.wikipedia.org/wiki/Transitive_relation" rel="noreferrer"><strong>Transitive</strong></a></li>
</ul>

<p>between evaluations executed by a single <a href="http://en.wikipedia.org/wiki/Thread_(computer_science)" rel="noreferrer">thread</a> and induces a <strong>strict partial order</strong><sup>1</sup><br></p>

<p>Formally it means given any two evaluations<sup>(See below)</sup> <code>A</code> and <code>B</code>, if <code>A</code> is <strong>sequenced before</strong> <code>B</code>, then the execution of <code>A</code> <em>shall precede</em> the execution of <code>B</code>. If <code>A</code> is not sequenced before <code>B</code> and <code>B</code> is not sequenced before <code>A</code>, then <code>A</code> and <code>B</code> are <strong>unsequenced</strong> <sup>2</sup>.</p>

<p>Evaluations <code>A</code> and <code>B</code> are <strong>indeterminately sequenced</strong> when either <code>A</code> is sequenced before <code>B</code> or <code>B</code> is sequenced before <code>A</code>, but it is unspecified which<sup>3</sup>.</p>

<p><sub>[NOTES]</sub>
<sub><br>
  1 :  A strict partial order is a <a href="http://en.wikipedia.org/wiki/Binary_relation" rel="noreferrer"><strong>binary relation</strong></a> <code>"&lt;"</code> over a set <code>P</code> which is <a href="http://en.wikipedia.org/wiki/Asymmetric_relation" rel="noreferrer"><code>asymmetric</code></a>, and <a href="http://en.wikipedia.org/wiki/Transitive_relation" rel="noreferrer"><code>transitive</code></a>, i.e., for all <code>a</code>, <code>b</code>, and <code>c</code> in <code>P</code>, we have that:<br>  </sub> 
<sub>  ........(i). if a &lt; b then ¬ (b &lt; a) (<code>asymmetry</code>);<br>
  ........(ii). if a &lt; b and b &lt; c then a &lt; c (<code>transitivity</code>).<br>
  2 : The execution of <strong>unsequenced evaluations</strong> can <em>overlap</em>.<br>
  3 : <strong>Indeterminately sequenced evaluations</strong> cannot <em>overlap</em>, but either could be executed first.
</sub></p>

<hr>

<h2> What is the meaning of the word 'evaluation' in context of C++11? </h2>

<p>In C++11, evaluation of an expression (or a sub-expression) in general includes: </p>

<ul>
<li><p><strong>value computations</strong> (including determining the identity of an object for <a href="https://stackoverflow.com/questions/3601602/what-are-rvalues-lvalues-xvalues-glvalues-and-prvalues">glvalue evaluation</a> and fetching a value previously assigned to an object for <a href="https://stackoverflow.com/questions/3601602/what-are-rvalues-lvalues-xvalues-glvalues-and-prvalues">prvalue evaluation</a>) and</p></li>
<li><p>initiation of <strong>side effects</strong>.</p></li>
</ul>

<p>Now  (§1.9/14) says:</p>

<blockquote>
  <p>Every value computation and side effect associated with a full-expression is <strong>sequenced before</strong> every value computation and side effect associated with the <strong>next full-expression to be evaluated</strong>.</p>
</blockquote>

<ul>
<li><p>Trivial example: </p>

<p><code>int x;</code>
 <code>x = 10;</code>
 <code>++x;</code></p>

<p>Value computation and side effect associated with <code>++x</code> is sequenced after the value computation and side effect of <code>x = 10;</code> </p></li>
</ul>

<hr>

<h2>So there must be some relation between Undefined Behaviour and the above-mentioned things, right? </h2>

<p><strong>Yes!</strong> Right.</p>

<p>In (§1.9/15) it has been mentioned that </p>

<blockquote>
  <p>Except where noted, evaluations of operands of individual operators and of subexpressions of individual expressions are <strong>unsequenced</strong><sup>4</sup>.</p>
</blockquote>

<p>For example :</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
     <span class="hljs-type">int</span> num = <span class="hljs-number">19</span> ;
     num = (num &lt;&lt; <span class="hljs-number">3</span>) + (num &gt;&gt; <span class="hljs-number">3</span>);
} 
</code></pre>

<ol>
<li>Evaluation of operands of <code>+</code> operator are unsequenced relative to each other.</li>
<li>Evaluation of operands of <code>&lt;&lt;</code> and <code>&gt;&gt;</code> operators are unsequenced relative to each other.</li>
</ol>

<p><sub> 4: In an expression that is evaluated more than once during the execution
of a program, <strong>unsequenced</strong> and <strong>indeterminately sequenced</strong> evaluations of its subexpressions need not be performed consistently in different evaluations. </sub></p>

<blockquote>
  <p>(§1.9/15)
  The value computations of the operands of an
  operator are sequenced before the value computation of the result of the operator.</p>
</blockquote>

<p>That means in <code>x + y</code> the value computation of <code>x</code> and <code>y</code> are sequenced before the value computation of <code>(x + y)</code>.</p>

<p>More importantly</p>

<blockquote>
  <p>(§1.9/15) If a side effect on a scalar object is unsequenced relative to either</p>
  
  <p>(a) <strong>another side effect on the same scalar object</strong> </p>
  
  <p>or </p>
  
  <p>(b) <strong>a value computation using the value of the same scalar object.</strong></p>
  
  <p>the behaviour is <strong>undefined</strong>.</p>
</blockquote>

<p>Examples:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-type">int</span> i = <span class="hljs-number">5</span>, v[<span class="hljs-number">10</span>] = { };
<span class="hljs-function"><span class="hljs-type">void</span>  <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-type">int</span>,  <span class="hljs-type">int</span>)</span></span>;
</code></pre>

<ol>
<li><code>i = i++ * ++i;  // Undefined Behaviour</code></li>
<li><code>i = ++i + i++;  // Undefined Behaviour</code> </li>
<li><code>i = ++i + ++i;  // Undefined Behaviour</code></li>
<li><code>i = v[i++];     // Undefined Behaviour</code></li>
<li><code>i = v[++i]:     // Well-defined Behavior</code></li>
<li><code>i = i++ + 1;    // Undefined Behaviour</code></li>
<li><code>i = ++i + 1;    // Well-defined Behaviour</code></li>
<li><code>++++i;          // Well-defined Behaviour</code></li>
<li><code>f(i = -1, i = -1); // Undefined Behaviour (see below)</code></li>
</ol>

<blockquote>
  <p>When calling a function (whether or not the function is inline), every value computation and side effect associated with any argument expression, or with the postfix expression designating the called function, is sequenced before execution of every expression or statement in the body of the called function. [<em>Note:</em> <strong>Value computations and side effects associated with different argument expressions are unsequenced</strong>.   <em>end note</em>]</p>
</blockquote>

<p>Expressions <code>(5)</code>, <code>(7)</code> and <code>(8)</code> do not invoke undefined behaviour. Check out the following answers for a more detailed explanation.</p>

<ul>
<li><a href="https://stackoverflow.com/questions/3690141/multiple-preincrement-operations-on-a-variable-in-cc/3691469#3691469">Multiple preincrement operations on a variable in C++0x</a></li>
<li><a href="https://stackoverflow.com/questions/3852768/unsequenced-value-computations-a-k-a-sequence-points/3852774#3852774">Unsequenced Value Computations</a></li>
</ul>

<hr>

<p><strong>Final Note</strong> : </p>

<p>If you find any flaw in the post please leave a comment. Power-users (With rep &gt;20000) please do not hesitate to edit the post for correcting typos and other mistakes.</p>
    </div></div></div></div><div id="solution3" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 3</h4><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p><strong>C++17</strong> (<code>N4659</code>) includes a proposal <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0145r3.pdf" rel="noreferrer">Refining Expression Evaluation Order for Idiomatic C++</a>
which defines a stricter order of expression evaluation.</p>

<p>In particular, the <strong><em>following sentence</em></strong></p>

<blockquote>
  <p><strong>8.18 Assignment and compound assignment operators</strong>:<br>....</p>
  
  <p>In all cases, the assignment is sequenced after the value
  computation of the right and left operands, and before the value computation of the assignment expression.
  <strong><em>The right operand is sequenced before the left operand.</em></strong></p>
</blockquote>

<p>together with the following clarification</p>

<blockquote>
  <p>An expression <em>X</em> is said to be sequenced before an expression <em>Y</em> if every
  value computation and every side effect associated with the expression <em>X</em> is sequenced before every value
  computation and every side effect associated with the expression <em>Y</em>.</p>
</blockquote>

<p>make several cases of previously undefined behavior valid, including the one in question:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp">a[++i] = i;
</code></pre>

<p>However several other similar cases still lead to undefined behavior.</p>

<p>In <code>N4140</code>:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp">i = i++ + <span class="hljs-number">1</span>; <span class="hljs-comment">// the behavior is undefined</span>
</code></pre>

<p>But in <code>N4659</code></p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp">i = i++ + <span class="hljs-number">1</span>; <span class="hljs-comment">// the value of i is incremented</span>
i = i++ + i; <span class="hljs-comment">// the behavior is undefined</span>
</code></pre>

<p>Of course, using a C++17 compliant compiler does not necessarily mean that one should start writing such expressions.</p>
    </div></div></div></div><div id="solution4" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 4</h4><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>I am guessing there is a fundamental reason for the change, it isn't merely cosmetic to make the old interpretation clearer: that reason is concurrency. Unspecified order of elaboration is merely selection of one of several possible serial orderings, this is quite different to before and after orderings, because if there is no specified ordering, concurrent evaluation is possible: not so with the old rules. For example in:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-built_in">f</span> (a,b)
</code></pre>

<p>previously either a then b, or, b then a. Now, a and b can be evaluated with instructions interleaved or even on different cores. </p>
    </div></div></div></div><div id="solution5" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 5</h4><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>In <code>C99(ISO/IEC 9899:TC3)</code> which seems absent from this discussion thus far the following steteents are made regarding order of evaluaiton.</p>

<blockquote>
  <p>[...]the order of evaluation of subexpressions and the order in which
  side effects take place are both unspecified. (Section 6.5 pp 67)</p>
  
  <p>The order of evaluation of the operands is unspecified. If an attempt
  is made to modify the result of an assignment operator or to access it
  after the next sequence point, the behavior[sic] is undefined.(Section
  6.5.16 pp 91)</p>
</blockquote>
    </div></div></div></div></div></div><div class="widget"><a href="/questions/how-can-i-deserialize-json-with-c-1657388102941">How can I deserialize JSON with C#?</a><a href="/questions/why-are-floating-point-numbers-inaccurate-1657387346111">Why are floating point numbers inaccurate?</a><a href="/questions/scanf()-leaves-the-newline-character-in-the-buffer-1657384699202">scanf() leaves the newline character in the buffer</a><a href="/questions/what-are-metaclasses-in-python-1657387811608">What are metaclasses in Python?</a><a href="/questions/google-maps-js-api-v3-simple-multiple-marker-example-1657388073335">Google Maps JS API v3 - Simple Multiple Marker Example</a><a href="/questions/make-container-shrink-to-fit-child-elements-as-they-wrap-1657388134549">Make container shrink-to-fit child elements as they wrap</a><a href="/questions/read-file-line-by-line-using-ifstream-in-c++-1657388236966">Read file line by line using ifstream in C++</a><a href="/questions/why-not-use-tables-for-layout-in-html-closed-1657387752327">Why not use tables for layout in HTML? [closed]</a><a href="/questions/dynamically-access-object-property-using-variable-1657384439324">Dynamically access object property using variable</a><a href="/questions/how-do-i-detect-collision-in-pygame-1657387496338">How do I detect collision in pygame?</a><a href="/questions/why-does-a-regexp-with-global-flag-give-wrong-results-1657387788550">Why does a RegExp with global flag give wrong results?</a><a href="/questions/difference-between-sh-and-bash-1657388197713">Difference between sh and Bash</a><a href="/questions/what-is-the-rule-of-three-1657384390295">What is The Rule of Three?</a><a href="/questions/is-storing-a-delimited-list-in-a-database-column-really-that-bad-1657384474773">Is storing a delimited list in a database column really that bad?</a><a href="/questions/center-one-and-rightleft-align-other-flexbox-element-1657387899083">Center one and right/left align other flexbox element</a><a href="/questions/official-locator-strategies-for-the-webdriver-1657384353174">Official locator strategies for the webdriver</a><a href="/questions/what-does-it-mean-to-%22program-to-an-interface%22-1657384671665">What does it mean to &quot;program to an interface&quot;?</a><a href="/questions/what-are-valid-values-for-the-id-attribute-in-html-1657384874780">What are valid values for the id attribute in HTML?</a><a href="/questions/convert-rows-to-columns-using-&#x27;pivot&#x27;-in-sql-server-1657388372528">Convert Rows to columns using &#x27;Pivot&#x27; in SQL Server</a><a href="/questions/are-dictionaries-ordered-in-python-3.6+-1657387834234">Are dictionaries ordered in Python 3.6+?</a></div></div><span class="cursor-pointer text-lg p-2" style="position:fixed;bottom:20px;left:20px;background:#000;z-index:2000;color:white">Go go top</span></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"data":{"answer":["\n\u0026lt;h3\u0026gt;C++98 and C++03\u0026lt;/h3\u0026gt;\n\u0026lt;p\u0026gt;This answer is for the older versions of the C++ standard.  The C++11 and C++14 versions of the standard do not formally contain \u0026apos;sequence points\u0026apos;; operations are \u0026apos;sequenced before\u0026apos; or \u0026apos;unsequenced\u0026apos; or \u0026apos;indeterminately sequenced\u0026apos; instead.  The net effect is essentially the same, but the terminology is different.\u0026lt;/p\u0026gt;\n\u0026lt;hr\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Disclaimer\u0026lt;/strong\u0026gt; : Okay. This answer is a bit long. So have patience while reading it. If you already know these things, reading them again won\u0026apos;t make you crazy.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Pre-requisites\u0026lt;/strong\u0026gt; : An elementary knowledge of \u0026lt;a href=\u0026quot;http://www.open-std.org/jtc1/sc22/wg21/\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;C++ Standard\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;hr\u0026gt;\n\u0026lt;h2\u0026gt;What are Sequence Points?\u0026lt;/h2\u0026gt;\n\u0026lt;p\u0026gt;The Standard says\u0026lt;/p\u0026gt;\n\u0026lt;blockquote\u0026gt;\n\u0026lt;p\u0026gt;At  certain specified points in the execution sequence called \u0026lt;strong\u0026gt;sequence points\u0026lt;/strong\u0026gt;, all \u0026lt;em\u0026gt;side effects\u0026lt;/em\u0026gt; of previous evaluations\nshall be complete and no \u0026lt;em\u0026gt;side effects\u0026lt;/em\u0026gt; of subsequent evaluations shall have taken place. (§1.9/7)\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\u0026lt;h2\u0026gt;Side effects? What are side effects?\u0026lt;/h2\u0026gt;\n\u0026lt;p\u0026gt;Evaluation  of  an  expression produces something and if in addition there is a change in the state of the execution environment it is said that the expression (its evaluation) has some side effect(s).\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;For example:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; x = y++; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//where y is also an int\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;In addition to the initialization operation the value of \u0026lt;code\u0026gt;y\u0026lt;/code\u0026gt; gets changed due to the side effect of \u0026lt;code\u0026gt;++\u0026lt;/code\u0026gt; operator.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;So far so good. Moving on to sequence points. An alternation definition of seq-points given by the comp.lang.c author \u0026lt;code\u0026gt;Steve Summit\u0026lt;/code\u0026gt;:\u0026lt;/p\u0026gt;\n\u0026lt;blockquote\u0026gt;\n\u0026lt;p\u0026gt;Sequence point is a point in time at which the dust has settled and all side effects which have been seen so far are guaranteed to be complete.\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\u0026lt;hr\u0026gt;\n\u0026lt;h2\u0026gt;What are the common sequence points listed in the C++ Standard?\u0026lt;/h2\u0026gt;\n\u0026lt;p\u0026gt;Those are:\u0026lt;/p\u0026gt;\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;at the end of the evaluation of full expression (\u0026lt;code\u0026gt;§1.9/16\u0026lt;/code\u0026gt;) (A full-expression is an expression that is not a subexpression of another expression.)\u0026lt;sup\u0026gt;1\u0026lt;/sup\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Example :\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; a = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;5\u0026lt;/span\u0026gt;; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// ; is a sequence point here\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;in the evaluation of each of the following expressions after the evaluation of the first expression (\u0026lt;code\u0026gt;§1.9/18\u0026lt;/code\u0026gt;) \u0026lt;sup\u0026gt;2\u0026lt;/sup\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;code\u0026gt;a \u0026amp;amp;\u0026amp;amp; b (§5.14)\u0026lt;/code\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;code\u0026gt;a || b (§5.15)\u0026lt;/code\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;code\u0026gt;a ? b : c (§5.16)\u0026lt;/code\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;code\u0026gt;a , b (§5.18)\u0026lt;/code\u0026gt; (here a , b is a comma operator; in \u0026lt;code\u0026gt;func(a,a++)\u0026lt;/code\u0026gt; \u0026lt;code\u0026gt;,\u0026lt;/code\u0026gt; is not a comma operator, it\u0026apos;s merely a separator between the arguments \u0026lt;code\u0026gt;a\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;a++\u0026lt;/code\u0026gt;. Thus the behaviour is undefined in that case (if \u0026lt;code\u0026gt;a\u0026lt;/code\u0026gt; is considered to be a primitive type)) \u0026lt;br\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;at a function call (whether or not the function is inline), after the evaluation of all function arguments (if any) which\ntakes place before execution of any expressions or statements in the function body (\u0026lt;code\u0026gt;§1.9/17\u0026lt;/code\u0026gt;).\u0026lt;/p\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;sub\u0026gt;1 : Note : the evaluation of a full-expression can include the evaluation of subexpressions that are not lexically\npart of the full-expression.  For example, subexpressions involved in evaluating default argument expressions (8.3.6) are considered to be created in the expression that calls the function, not the expression that defines the default argument\u0026lt;/sub\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;sub\u0026gt;2 : The operators indicated are the built-in operators, as described in clause 5.  When one of these operators is overloaded (clause 13) in a valid context, thus designating a user-defined operator function, the expression designates a function invocation and the operands form an argument list, without an implied sequence point between them.\u0026lt;/sub\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;hr\u0026gt;\n\u0026lt;h2\u0026gt;What is Undefined Behaviour?\u0026lt;/h2\u0026gt;\n\u0026lt;p\u0026gt;The Standard defines Undefined Behaviour in Section \u0026lt;code\u0026gt;§1.3.12\u0026lt;/code\u0026gt; as\u0026lt;/p\u0026gt;\n\u0026lt;blockquote\u0026gt;\n\u0026lt;p\u0026gt;behavior, such as might arise upon use of an erroneous program construct or erroneous data, for which this International Standard imposes \u0026lt;strong\u0026gt;no  requirements \u0026lt;sup\u0026gt;3\u0026lt;/sup\u0026gt;\u0026lt;/strong\u0026gt;.\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\u0026lt;blockquote\u0026gt;\n\u0026lt;p\u0026gt;Undefined  behavior  may  also  be  expected  when  this\nInternational Standard omits the description of any explicit definition of behavior.\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;sub\u0026gt; 3 : permissible undefined behavior ranges from ignoring the situation completely with unpredictable results, to behaving during translation or program execution in a documented manner characteristic of the environment (with or with-\nout the issuance of a diagnostic message), to terminating a translation or execution (with the issuance of a diagnostic message).\u0026lt;/sub\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;In short, undefined behaviour means \u0026lt;strong\u0026gt;anything\u0026lt;/strong\u0026gt; can happen from daemons flying out of your nose to  your girlfriend getting pregnant.\u0026lt;/p\u0026gt;\n\u0026lt;hr\u0026gt;\n\u0026lt;h2\u0026gt;What is the relation between Undefined Behaviour and Sequence Points?\u0026lt;/h2\u0026gt;\n\u0026lt;p\u0026gt;Before I get into that you must know the difference(s) between \u0026lt;a href=\u0026quot;https://stackoverflow.com/questions/2397984/undefined-unspecified-and-implementation-defined-behavior\u0026quot;\u0026gt;Undefined Behaviour, Unspecified Behaviour and Implementation Defined Behaviour\u0026lt;/a\u0026gt;.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;You must also know that \u0026lt;code\u0026gt;the order of evaluation of operands of individual operators and subexpressions of individual expressions, and the order in which side effects take place, is unspecified\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;For example:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; x = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;5\u0026lt;/span\u0026gt;, y = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;6\u0026lt;/span\u0026gt;;\n\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; z = x++ + y++; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//it is unspecified whether x++ or y++ will be evaluated first.\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;Another example \u0026lt;a href=\u0026quot;https://stackoverflow.com/questions/3457967/what-belongs-in-an-educational-tool-to-demonstrate-the-unwarranted-assumptions-pe/3458842#3458842\u0026quot;\u0026gt;here\u0026lt;/a\u0026gt;.\u0026lt;/p\u0026gt;\n\u0026lt;hr\u0026gt;\n\u0026lt;p\u0026gt;Now the Standard in \u0026lt;code\u0026gt;§5/4\u0026lt;/code\u0026gt; says\u0026lt;/p\u0026gt;\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;\n\u0026lt;ol\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;strong\u0026gt;Between the previous and next sequence point a scalar object shall have its stored value modified at most once by the evaluation of an expression.\u0026lt;/strong\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;/ol\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;p\u0026gt;What does it mean?\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Informally it means that between two sequence points a variable must not be modified more than once.\nIn an expression statement, the \u0026lt;code\u0026gt;next sequence point\u0026lt;/code\u0026gt; is usually at the terminating semicolon, and the \u0026lt;code\u0026gt;previous sequence point\u0026lt;/code\u0026gt; is at the end of the previous statement. An expression may also contain intermediate \u0026lt;code\u0026gt;sequence points\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;From the above sentence the following expressions invoke Undefined Behaviour:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;i++ * ++i;   \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// UB, i is modified more than once btw two SPs\u0026lt;/span\u0026gt;\ni = ++i;     \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// UB, same as above\u0026lt;/span\u0026gt;\n++i = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;;     \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// UB, same as above\u0026lt;/span\u0026gt;\ni = ++i + \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// UB, same as above\u0026lt;/span\u0026gt;\n++++++i;     \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// UB, parsed as (++(++(++i)))\u0026lt;/span\u0026gt;\n\ni = (i, ++i, ++i); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// UB, there\u0026apos;s no SP between `++i` (right most) and assignment to `i` (`i` is modified more than once btw two SPs)\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;But the following expressions are fine:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;i = (i, ++i, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;) + \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// well defined (AFAIK)\u0026lt;/span\u0026gt;\ni = (++i, i++, i);   \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// well defined \u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; j = i;\nj = (++i, i++, j*i); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// well defined\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;hr\u0026gt;\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;\n\u0026lt;ol start=\u0026quot;2\u0026quot;\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;strong\u0026gt;Furthermore, the prior value shall be accessed only to determine the value to be stored.\u0026lt;/strong\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;/ol\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;p\u0026gt;What does it mean? It means if an object is written to within a full expression, any and all accesses to it within the same expression \u0026lt;strong\u0026gt;must be directly involved in the computation of the value to be written\u0026lt;/strong\u0026gt;.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;For example in \u0026lt;code\u0026gt;i = i + 1\u0026lt;/code\u0026gt; all the access of \u0026lt;code\u0026gt;i\u0026lt;/code\u0026gt; (in L.H.S and in R.H.S) are \u0026lt;strong\u0026gt;directly involved in computation\u0026lt;/strong\u0026gt; of the value to be written. So it is fine.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;This rule effectively constrains legal expressions to those in which the accesses demonstrably precede the modification.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Example 1:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;std::\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;printf\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;%d %d\u0026quot;\u0026lt;/span\u0026gt;, i,++i); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// invokes Undefined Behaviour because of Rule no 2\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;Example 2:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;a[i] = i++ \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// or a[++i] = i or a[i++] = ++i etc\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;is disallowed because one of the accesses of \u0026lt;code\u0026gt;i\u0026lt;/code\u0026gt; (the one in \u0026lt;code\u0026gt;a[i]\u0026lt;/code\u0026gt;) has nothing to do with the value which ends up being stored in i (which happens over in \u0026lt;code\u0026gt;i++\u0026lt;/code\u0026gt;), and so there\u0026apos;s no good way to define--either for our understanding or the compiler\u0026apos;s--whether the access should take place before or after the incremented value is stored. So the behaviour is undefined.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Example 3 :\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; x = i + i++ ;\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Similar to above\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;hr\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Follow up answer for C++11 \u0026lt;a href=\u0026quot;https://stackoverflow.com/questions/4176328/faq-undefined-behavior-and-sequence-points/4183735#4183735\u0026quot;\u0026gt;here\u0026lt;/a\u0026gt;.\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;This is a follow up to my \u0026lt;a href=\u0026quot;https://stackoverflow.com/questions/4176328/faq-undefined-behavior-and-sequence-points/4176333#4176333\u0026quot;\u0026gt;previous answer\u0026lt;/a\u0026gt; and contains C++11 related material.\u0026lt;/strong\u0026gt;.\u0026lt;/p\u0026gt;\n\n\u0026lt;hr\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Pre-requisites\u0026lt;/strong\u0026gt; : An elementary knowledge of Relations (Mathematics).\u0026lt;/p\u0026gt;\n\n\u0026lt;hr\u0026gt;\n\n\u0026lt;h2\u0026gt;Is it true that there are no Sequence Points in C++11?\u0026lt;/h2\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Yes!\u0026lt;/strong\u0026gt; This is very true. \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Sequence Points\u0026lt;/strong\u0026gt; have been replaced by \u0026lt;strong\u0026gt;Sequenced Before\u0026lt;/strong\u0026gt; and \u0026lt;strong\u0026gt;Sequenced After\u0026lt;/strong\u0026gt; (and \u0026lt;strong\u0026gt;Unsequenced\u0026lt;/strong\u0026gt; and \u0026lt;strong\u0026gt;Indeterminately Sequenced\u0026lt;/strong\u0026gt;) \u0026lt;a href=\u0026quot;http://en.wikipedia.org/wiki/Relation_(mathematics)\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;relations\u0026lt;/a\u0026gt; in C++11.\u0026lt;/p\u0026gt;\n\n\u0026lt;hr\u0026gt;\n\n\u0026lt;h2\u0026gt;What exactly is this \u0026apos;Sequenced before\u0026apos; thing?\u0026lt;/h2\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Sequenced Before\u0026lt;/strong\u0026gt;\u0026lt;sup\u0026gt;(§1.9/13)\u0026lt;/sup\u0026gt; is a relation which is: \u0026lt;/p\u0026gt;\n\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;a href=\u0026quot;http://en.wikipedia.org/wiki/Asymmetric_relation\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;\u0026lt;strong\u0026gt;Asymmetric\u0026lt;/strong\u0026gt;\u0026lt;/a\u0026gt; \u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;a href=\u0026quot;http://en.wikipedia.org/wiki/Transitive_relation\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;\u0026lt;strong\u0026gt;Transitive\u0026lt;/strong\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\n\u0026lt;p\u0026gt;between evaluations executed by a single \u0026lt;a href=\u0026quot;http://en.wikipedia.org/wiki/Thread_(computer_science)\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;thread\u0026lt;/a\u0026gt; and induces a \u0026lt;strong\u0026gt;strict partial order\u0026lt;/strong\u0026gt;\u0026lt;sup\u0026gt;1\u0026lt;/sup\u0026gt;\u0026lt;br\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Formally it means given any two evaluations\u0026lt;sup\u0026gt;(See below)\u0026lt;/sup\u0026gt; \u0026lt;code\u0026gt;A\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;B\u0026lt;/code\u0026gt;, if \u0026lt;code\u0026gt;A\u0026lt;/code\u0026gt; is \u0026lt;strong\u0026gt;sequenced before\u0026lt;/strong\u0026gt; \u0026lt;code\u0026gt;B\u0026lt;/code\u0026gt;, then the execution of \u0026lt;code\u0026gt;A\u0026lt;/code\u0026gt; \u0026lt;em\u0026gt;shall precede\u0026lt;/em\u0026gt; the execution of \u0026lt;code\u0026gt;B\u0026lt;/code\u0026gt;. If \u0026lt;code\u0026gt;A\u0026lt;/code\u0026gt; is not sequenced before \u0026lt;code\u0026gt;B\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;B\u0026lt;/code\u0026gt; is not sequenced before \u0026lt;code\u0026gt;A\u0026lt;/code\u0026gt;, then \u0026lt;code\u0026gt;A\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;B\u0026lt;/code\u0026gt; are \u0026lt;strong\u0026gt;unsequenced\u0026lt;/strong\u0026gt; \u0026lt;sup\u0026gt;2\u0026lt;/sup\u0026gt;.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Evaluations \u0026lt;code\u0026gt;A\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;B\u0026lt;/code\u0026gt; are \u0026lt;strong\u0026gt;indeterminately sequenced\u0026lt;/strong\u0026gt; when either \u0026lt;code\u0026gt;A\u0026lt;/code\u0026gt; is sequenced before \u0026lt;code\u0026gt;B\u0026lt;/code\u0026gt; or \u0026lt;code\u0026gt;B\u0026lt;/code\u0026gt; is sequenced before \u0026lt;code\u0026gt;A\u0026lt;/code\u0026gt;, but it is unspecified which\u0026lt;sup\u0026gt;3\u0026lt;/sup\u0026gt;.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;sub\u0026gt;[NOTES]\u0026lt;/sub\u0026gt;\n\u0026lt;sub\u0026gt;\u0026lt;br\u0026gt;\n  1 :  A strict partial order is a \u0026lt;a href=\u0026quot;http://en.wikipedia.org/wiki/Binary_relation\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;\u0026lt;strong\u0026gt;binary relation\u0026lt;/strong\u0026gt;\u0026lt;/a\u0026gt; \u0026lt;code\u0026gt;\u0026quot;\u0026amp;lt;\u0026quot;\u0026lt;/code\u0026gt; over a set \u0026lt;code\u0026gt;P\u0026lt;/code\u0026gt; which is \u0026lt;a href=\u0026quot;http://en.wikipedia.org/wiki/Asymmetric_relation\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;\u0026lt;code\u0026gt;asymmetric\u0026lt;/code\u0026gt;\u0026lt;/a\u0026gt;, and \u0026lt;a href=\u0026quot;http://en.wikipedia.org/wiki/Transitive_relation\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;\u0026lt;code\u0026gt;transitive\u0026lt;/code\u0026gt;\u0026lt;/a\u0026gt;, i.e., for all \u0026lt;code\u0026gt;a\u0026lt;/code\u0026gt;, \u0026lt;code\u0026gt;b\u0026lt;/code\u0026gt;, and \u0026lt;code\u0026gt;c\u0026lt;/code\u0026gt; in \u0026lt;code\u0026gt;P\u0026lt;/code\u0026gt;, we have that:\u0026lt;br\u0026gt;  \u0026lt;/sub\u0026gt; \n\u0026lt;sub\u0026gt;  ........(i). if a \u0026amp;lt; b then ¬ (b \u0026amp;lt; a) (\u0026lt;code\u0026gt;asymmetry\u0026lt;/code\u0026gt;);\u0026lt;br\u0026gt;\n  ........(ii). if a \u0026amp;lt; b and b \u0026amp;lt; c then a \u0026amp;lt; c (\u0026lt;code\u0026gt;transitivity\u0026lt;/code\u0026gt;).\u0026lt;br\u0026gt;\n  2 : The execution of \u0026lt;strong\u0026gt;unsequenced evaluations\u0026lt;/strong\u0026gt; can \u0026lt;em\u0026gt;overlap\u0026lt;/em\u0026gt;.\u0026lt;br\u0026gt;\n  3 : \u0026lt;strong\u0026gt;Indeterminately sequenced evaluations\u0026lt;/strong\u0026gt; cannot \u0026lt;em\u0026gt;overlap\u0026lt;/em\u0026gt;, but either could be executed first.\n\u0026lt;/sub\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;hr\u0026gt;\n\n\u0026lt;h2\u0026gt; What is the meaning of the word \u0026apos;evaluation\u0026apos; in context of C++11? \u0026lt;/h2\u0026gt;\n\n\u0026lt;p\u0026gt;In C++11, evaluation of an expression (or a sub-expression) in general includes: \u0026lt;/p\u0026gt;\n\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;value computations\u0026lt;/strong\u0026gt; (including determining the identity of an object for \u0026lt;a href=\u0026quot;https://stackoverflow.com/questions/3601602/what-are-rvalues-lvalues-xvalues-glvalues-and-prvalues\u0026quot;\u0026gt;glvalue evaluation\u0026lt;/a\u0026gt; and fetching a value previously assigned to an object for \u0026lt;a href=\u0026quot;https://stackoverflow.com/questions/3601602/what-are-rvalues-lvalues-xvalues-glvalues-and-prvalues\u0026quot;\u0026gt;prvalue evaluation\u0026lt;/a\u0026gt;) and\u0026lt;/p\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;initiation of \u0026lt;strong\u0026gt;side effects\u0026lt;/strong\u0026gt;.\u0026lt;/p\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\n\u0026lt;p\u0026gt;Now  (§1.9/14) says:\u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;Every value computation and side effect associated with a full-expression is \u0026lt;strong\u0026gt;sequenced before\u0026lt;/strong\u0026gt; every value computation and side effect associated with the \u0026lt;strong\u0026gt;next full-expression to be evaluated\u0026lt;/strong\u0026gt;.\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;Trivial example: \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;code\u0026gt;int x;\u0026lt;/code\u0026gt;\n \u0026lt;code\u0026gt;x = 10;\u0026lt;/code\u0026gt;\n \u0026lt;code\u0026gt;++x;\u0026lt;/code\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Value computation and side effect associated with \u0026lt;code\u0026gt;++x\u0026lt;/code\u0026gt; is sequenced after the value computation and side effect of \u0026lt;code\u0026gt;x = 10;\u0026lt;/code\u0026gt; \u0026lt;/p\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\n\u0026lt;hr\u0026gt;\n\n\u0026lt;h2\u0026gt;So there must be some relation between Undefined Behaviour and the above-mentioned things, right? \u0026lt;/h2\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Yes!\u0026lt;/strong\u0026gt; Right.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;In (§1.9/15) it has been mentioned that \u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;Except where noted, evaluations of operands of individual operators and of subexpressions of individual expressions are \u0026lt;strong\u0026gt;unsequenced\u0026lt;/strong\u0026gt;\u0026lt;sup\u0026gt;4\u0026lt;/sup\u0026gt;.\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;p\u0026gt;For example :\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;main\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt;\n\u0026lt;/span\u0026gt;{\n     \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; num = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;19\u0026lt;/span\u0026gt; ;\n     num = (num \u0026amp;lt;\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3\u0026lt;/span\u0026gt;) + (num \u0026amp;gt;\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3\u0026lt;/span\u0026gt;);\n} \n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;ol\u0026gt;\n\u0026lt;li\u0026gt;Evaluation of operands of \u0026lt;code\u0026gt;+\u0026lt;/code\u0026gt; operator are unsequenced relative to each other.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Evaluation of operands of \u0026lt;code\u0026gt;\u0026amp;lt;\u0026amp;lt;\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026lt;/code\u0026gt; operators are unsequenced relative to each other.\u0026lt;/li\u0026gt;\n\u0026lt;/ol\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;sub\u0026gt; 4: In an expression that is evaluated more than once during the execution\nof a program, \u0026lt;strong\u0026gt;unsequenced\u0026lt;/strong\u0026gt; and \u0026lt;strong\u0026gt;indeterminately sequenced\u0026lt;/strong\u0026gt; evaluations of its subexpressions need not be performed consistently in different evaluations. \u0026lt;/sub\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;(§1.9/15)\n  The value computations of the operands of an\n  operator are sequenced before the value computation of the result of the operator.\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;p\u0026gt;That means in \u0026lt;code\u0026gt;x + y\u0026lt;/code\u0026gt; the value computation of \u0026lt;code\u0026gt;x\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;y\u0026lt;/code\u0026gt; are sequenced before the value computation of \u0026lt;code\u0026gt;(x + y)\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;More importantly\u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;(§1.9/15) If a side effect on a scalar object is unsequenced relative to either\u0026lt;/p\u0026gt;\n  \n  \u0026lt;p\u0026gt;(a) \u0026lt;strong\u0026gt;another side effect on the same scalar object\u0026lt;/strong\u0026gt; \u0026lt;/p\u0026gt;\n  \n  \u0026lt;p\u0026gt;or \u0026lt;/p\u0026gt;\n  \n  \u0026lt;p\u0026gt;(b) \u0026lt;strong\u0026gt;a value computation using the value of the same scalar object.\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n  \n  \u0026lt;p\u0026gt;the behaviour is \u0026lt;strong\u0026gt;undefined\u0026lt;/strong\u0026gt;.\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;p\u0026gt;Examples:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; i = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;5\u0026lt;/span\u0026gt;, v[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;10\u0026lt;/span\u0026gt;] = { };\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt;  \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;f\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;,  \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;)\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;ol\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;code\u0026gt;i = i++ * ++i;  // Undefined Behaviour\u0026lt;/code\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;code\u0026gt;i = ++i + i++;  // Undefined Behaviour\u0026lt;/code\u0026gt; \u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;code\u0026gt;i = ++i + ++i;  // Undefined Behaviour\u0026lt;/code\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;code\u0026gt;i = v[i++];     // Undefined Behaviour\u0026lt;/code\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;code\u0026gt;i = v[++i]:     // Well-defined Behavior\u0026lt;/code\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;code\u0026gt;i = i++ + 1;    // Undefined Behaviour\u0026lt;/code\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;code\u0026gt;i = ++i + 1;    // Well-defined Behaviour\u0026lt;/code\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;code\u0026gt;++++i;          // Well-defined Behaviour\u0026lt;/code\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;code\u0026gt;f(i = -1, i = -1); // Undefined Behaviour (see below)\u0026lt;/code\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;/ol\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;When calling a function (whether or not the function is inline), every value computation and side effect associated with any argument expression, or with the postfix expression designating the called function, is sequenced before execution of every expression or statement in the body of the called function. [\u0026lt;em\u0026gt;Note:\u0026lt;/em\u0026gt; \u0026lt;strong\u0026gt;Value computations and side effects associated with different argument expressions are unsequenced\u0026lt;/strong\u0026gt;.   \u0026lt;em\u0026gt;end note\u0026lt;/em\u0026gt;]\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;p\u0026gt;Expressions \u0026lt;code\u0026gt;(5)\u0026lt;/code\u0026gt;, \u0026lt;code\u0026gt;(7)\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;(8)\u0026lt;/code\u0026gt; do not invoke undefined behaviour. Check out the following answers for a more detailed explanation.\u0026lt;/p\u0026gt;\n\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;a href=\u0026quot;https://stackoverflow.com/questions/3690141/multiple-preincrement-operations-on-a-variable-in-cc/3691469#3691469\u0026quot;\u0026gt;Multiple preincrement operations on a variable in C++0x\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;a href=\u0026quot;https://stackoverflow.com/questions/3852768/unsequenced-value-computations-a-k-a-sequence-points/3852774#3852774\u0026quot;\u0026gt;Unsequenced Value Computations\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\n\u0026lt;hr\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Final Note\u0026lt;/strong\u0026gt; : \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;If you find any flaw in the post please leave a comment. Power-users (With rep \u0026amp;gt;20000) please do not hesitate to edit the post for correcting typos and other mistakes.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;C++17\u0026lt;/strong\u0026gt; (\u0026lt;code\u0026gt;N4659\u0026lt;/code\u0026gt;) includes a proposal \u0026lt;a href=\u0026quot;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0145r3.pdf\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;Refining Expression Evaluation Order for Idiomatic C++\u0026lt;/a\u0026gt;\nwhich defines a stricter order of expression evaluation.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;In particular, the \u0026lt;strong\u0026gt;\u0026lt;em\u0026gt;following sentence\u0026lt;/em\u0026gt;\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;8.18 Assignment and compound assignment operators\u0026lt;/strong\u0026gt;:\u0026lt;br\u0026gt;....\u0026lt;/p\u0026gt;\n  \n  \u0026lt;p\u0026gt;In all cases, the assignment is sequenced after the value\n  computation of the right and left operands, and before the value computation of the assignment expression.\n  \u0026lt;strong\u0026gt;\u0026lt;em\u0026gt;The right operand is sequenced before the left operand.\u0026lt;/em\u0026gt;\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;p\u0026gt;together with the following clarification\u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;An expression \u0026lt;em\u0026gt;X\u0026lt;/em\u0026gt; is said to be sequenced before an expression \u0026lt;em\u0026gt;Y\u0026lt;/em\u0026gt; if every\n  value computation and every side effect associated with the expression \u0026lt;em\u0026gt;X\u0026lt;/em\u0026gt; is sequenced before every value\n  computation and every side effect associated with the expression \u0026lt;em\u0026gt;Y\u0026lt;/em\u0026gt;.\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;p\u0026gt;make several cases of previously undefined behavior valid, including the one in question:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;a[++i] = i;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;However several other similar cases still lead to undefined behavior.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;In \u0026lt;code\u0026gt;N4140\u0026lt;/code\u0026gt;:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;i = i++ + \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// the behavior is undefined\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;But in \u0026lt;code\u0026gt;N4659\u0026lt;/code\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;i = i++ + \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// the value of i is incremented\u0026lt;/span\u0026gt;\ni = i++ + i; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// the behavior is undefined\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Of course, using a C++17 compliant compiler does not necessarily mean that one should start writing such expressions.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;I am guessing there is a fundamental reason for the change, it isn\u0026apos;t merely cosmetic to make the old interpretation clearer: that reason is concurrency. Unspecified order of elaboration is merely selection of one of several possible serial orderings, this is quite different to before and after orderings, because if there is no specified ordering, concurrent evaluation is possible: not so with the old rules. For example in:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;f\u0026lt;/span\u0026gt; (a,b)\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;previously either a then b, or, b then a. Now, a and b can be evaluated with instructions interleaved or even on different cores. \u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;In \u0026lt;code\u0026gt;C99(ISO/IEC 9899:TC3)\u0026lt;/code\u0026gt; which seems absent from this discussion thus far the following steteents are made regarding order of evaluaiton.\u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;[...]the order of evaluation of subexpressions and the order in which\n  side effects take place are both unspecified. (Section 6.5 pp 67)\u0026lt;/p\u0026gt;\n  \n  \u0026lt;p\u0026gt;The order of evaluation of the operands is unspecified. If an attempt\n  is made to modify the result of an assignment operator or to access it\n  after the next sequence point, the behavior[sic] is undefined.(Section\n  6.5.16 pp 91)\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n    "],"id":109,"title":"Undefined behavior and sequence points","content":"\n                \n\u0026lt;p\u0026gt;What are \u0026quot;sequence points\u0026quot;?\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;What is the relation between undefined behaviour and sequence points?\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;I often use funny and convoluted expressions like \u0026lt;code\u0026gt;a[++i] = i;\u0026lt;/code\u0026gt;, to make myself feel better. Why should I stop using them?\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;If you\u0026apos;ve read this, be sure to visit the follow-up question \u0026lt;em\u0026gt;\u0026lt;a href=\u0026quot;https://stackoverflow.com/questions/4638364\u0026quot;\u0026gt;Undefined behavior and sequence points reloaded\u0026lt;/a\u0026gt;\u0026lt;/em\u0026gt;.\u0026lt;/p\u0026gt;\n\u0026lt;sub\u0026gt;\n\u0026lt;i\u0026gt;(Note: This is meant to be an entry to \u0026lt;a href=\u0026quot;https://stackoverflow.com/questions/tagged/c++-faq\u0026quot;\u0026gt;Stack Overflow\u0026apos;s C++ FAQ\u0026lt;/a\u0026gt;. If you want to critique the idea of providing an FAQ in this form, then \u0026lt;a href=\u0026quot;https://meta.stackexchange.com/questions/68647/setting-up-a-faq-for-the-c-tag\u0026quot;\u0026gt;the posting on meta that started all this\u0026lt;/a\u0026gt; would be the place to do that. Answers to that question are monitored in the \u0026lt;a href=\u0026quot;https://chat.stackoverflow.com/rooms/10/c-lounge\u0026quot;\u0026gt;C++ chatroom\u0026lt;/a\u0026gt;, where the FAQ idea started out in the first place, so your answer is very likely to get read by those who came up with the idea.)\u0026lt;/i\u0026gt;\n\u0026lt;/sub\u0026gt;\n    ","slug":"undefined-behavior-and-sequence-points-1657384639493","postType":"QUESTION","createdAt":"2022-07-09T16:37:19.000Z","updatedAt":"2022-07-09T16:37:19.000Z","tags":[],"relatedQuestions":[]},"randomQuestions":[{"title":"How can I deserialize JSON with C#?","slug":"how-can-i-deserialize-json-with-c-1657388102941"},{"title":"Why are floating point numbers inaccurate?","slug":"why-are-floating-point-numbers-inaccurate-1657387346111"},{"title":"scanf() leaves the newline character in the buffer","slug":"scanf()-leaves-the-newline-character-in-the-buffer-1657384699202"},{"title":"What are metaclasses in Python?","slug":"what-are-metaclasses-in-python-1657387811608"},{"title":"Google Maps JS API v3 - Simple Multiple Marker Example","slug":"google-maps-js-api-v3-simple-multiple-marker-example-1657388073335"},{"title":"Make container shrink-to-fit child elements as they wrap","slug":"make-container-shrink-to-fit-child-elements-as-they-wrap-1657388134549"},{"title":"Read file line by line using ifstream in C++","slug":"read-file-line-by-line-using-ifstream-in-c++-1657388236966"},{"title":"Why not use tables for layout in HTML? [closed]","slug":"why-not-use-tables-for-layout-in-html-closed-1657387752327"},{"title":"Dynamically access object property using variable","slug":"dynamically-access-object-property-using-variable-1657384439324"},{"title":"How do I detect collision in pygame?","slug":"how-do-i-detect-collision-in-pygame-1657387496338"},{"title":"Why does a RegExp with global flag give wrong results?","slug":"why-does-a-regexp-with-global-flag-give-wrong-results-1657387788550"},{"title":"Difference between sh and Bash","slug":"difference-between-sh-and-bash-1657388197713"},{"title":"What is The Rule of Three?","slug":"what-is-the-rule-of-three-1657384390295"},{"title":"Is storing a delimited list in a database column really that bad?","slug":"is-storing-a-delimited-list-in-a-database-column-really-that-bad-1657384474773"},{"title":"Center one and right/left align other flexbox element","slug":"center-one-and-rightleft-align-other-flexbox-element-1657387899083"},{"title":"Official locator strategies for the webdriver","slug":"official-locator-strategies-for-the-webdriver-1657384353174"},{"title":"What does it mean to \"program to an interface\"?","slug":"what-does-it-mean-to-\"program-to-an-interface\"-1657384671665"},{"title":"What are valid values for the id attribute in HTML?","slug":"what-are-valid-values-for-the-id-attribute-in-html-1657384874780"},{"title":"Convert Rows to columns using 'Pivot' in SQL Server","slug":"convert-rows-to-columns-using-'pivot'-in-sql-server-1657388372528"},{"title":"Are dictionaries ordered in Python 3.6+?","slug":"are-dictionaries-ordered-in-python-3.6+-1657387834234"}]},"__N_SSG":true},"page":"/questions/[slug]","query":{"slug":"undefined-behavior-and-sequence-points-1657384639493"},"buildId":"TQ2eYlCSdocSK-hq6gkM0","isFallback":false,"gsp":true,"locale":"en","locales":["en"],"defaultLocale":"en","scriptLoader":[]}</script></body></html>