<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><meta name="twitter:card" content="summary_large_image"/><meta name="twitter:site" content="@solutionschecker.com"/><meta name="twitter:creator" content="@solutionschecker.com"/><meta property="og:url" content="https://solutionschecker.com"/><meta property="og:type" content="website"/><meta property="og:image" content="https://solutionschecker.com/solutions-checker-banner.png"/><meta property="og:image:alt" content="Find solution for coding, HTML, CSS, JAVASCRIPT, MYSQL, PHP, PYTHON,... quickly. - solutionschecker.com"/><script type="application/ld+json">{"@context":"https://schema.org","@type":"Organization","logo":"/logo.svg","url":"https://solutionschecker.com"}</script><title>Why is 24.0000 not equal to 24.0000 in MATLAB? | Solutions Checker</title><meta name="robots" content="index,follow"/><meta name="description" content="I am writing a program where I need to delete duplicate points stored in a matrix. The problem is that when it comes to check whether those points are in the matrix, MATLAB can&#x27;t recognize them in the matrix although they exist.

In the following code, intersections function gets the intersection points:

[points(:,1), points(:,2)] = intersections(...
    obj.modifiedVGVertices(1,:), obj.modifiedVGVertices(2,:), ...
    [vertex1(1) vertex2(1)], [vertex1(2) vertex2(2)]);


The result:

&gt;&gt; points
points =
   12.0000   15.0000
   33.0000   24.0000
   33.0000   24.0000

&gt;&gt; vertex1
vertex1 =
    12
    15

&gt;&gt; vertex2    
vertex2 =
    33
    24


Two points (vertex1 and vertex2) should be eliminated from the result. It should be done by the below commands:

points = points((points(:,1) ~= vertex1(1)) | (points(:,2) ~= vertex1(2)), :);
points = points((points(:,1) ~= vertex2(1)) | (points(:,2) ~= vertex2(2)), :);


After doing that, we have this unexpected outcome:

&gt;&gt; points
points =
   33.0000   24.0000


The outcome should be an empty matrix. As you can see, the first (or second?) pair of [33.0000 24.0000] has been eliminated, but not the second one.

Then I checked these two expressions:

&gt;&gt; points(1) ~= vertex2(1)
ans =
     0
&gt;&gt; points(2) ~= vertex2(2)
ans =
     1   % &lt;-- It means 24.0000 is not equal to 24.0000?


What is the problem?



More surprisingly, I made a new script that has only these commands:

points = [12.0000   15.0000
          33.0000   24.0000
          33.0000   24.0000];

vertex1 = [12 ;  15];
vertex2 = [33 ;  24];

points = points((points(:,1) ~= vertex1(1)) | (points(:,2) ~= vertex1(2)), :);
points = points((points(:,1) ~= vertex2(1)) | (points(:,2) ~= vertex2(2)), :);


The result as expected:

&gt;&gt; points
points =  
   Empty matrix: 0-by-2

    "/><meta property="og:title" content="Why is 24.0000 not equal to 24.0000 in MATLAB? | Solutions Checker"/><meta property="og:description" content="I am writing a program where I need to delete duplicate points stored in a matrix. The problem is that when it comes to check whether those points are in the matrix, MATLAB can&#x27;t recognize them in the matrix although they exist.

In the following code, intersections function gets the intersection points:

[points(:,1), points(:,2)] = intersections(...
    obj.modifiedVGVertices(1,:), obj.modifiedVGVertices(2,:), ...
    [vertex1(1) vertex2(1)], [vertex1(2) vertex2(2)]);


The result:

&gt;&gt; points
points =
   12.0000   15.0000
   33.0000   24.0000
   33.0000   24.0000

&gt;&gt; vertex1
vertex1 =
    12
    15

&gt;&gt; vertex2    
vertex2 =
    33
    24


Two points (vertex1 and vertex2) should be eliminated from the result. It should be done by the below commands:

points = points((points(:,1) ~= vertex1(1)) | (points(:,2) ~= vertex1(2)), :);
points = points((points(:,1) ~= vertex2(1)) | (points(:,2) ~= vertex2(2)), :);


After doing that, we have this unexpected outcome:

&gt;&gt; points
points =
   33.0000   24.0000


The outcome should be an empty matrix. As you can see, the first (or second?) pair of [33.0000 24.0000] has been eliminated, but not the second one.

Then I checked these two expressions:

&gt;&gt; points(1) ~= vertex2(1)
ans =
     0
&gt;&gt; points(2) ~= vertex2(2)
ans =
     1   % &lt;-- It means 24.0000 is not equal to 24.0000?


What is the problem?



More surprisingly, I made a new script that has only these commands:

points = [12.0000   15.0000
          33.0000   24.0000
          33.0000   24.0000];

vertex1 = [12 ;  15];
vertex2 = [33 ;  24];

points = points((points(:,1) ~= vertex1(1)) | (points(:,2) ~= vertex1(2)), :);
points = points((points(:,1) ~= vertex2(1)) | (points(:,2) ~= vertex2(2)), :);


The result as expected:

&gt;&gt; points
points =  
   Empty matrix: 0-by-2

    "/><script type="application/ld+json">{"@context":"https://schema.org","@type":"QAPage","mainEntity":{"name":"Why is 24.0000 not equal to 24.0000 in MATLAB?","text":"I am writing a program where I need to delete duplicate points stored in a matrix. The problem is that when it comes to check whether those points are in the matrix, MATLAB can&apos;t recognize them in the matrix although they exist.\n\nIn the following code, intersections function gets the intersection points:\n\n[points(:,1), points(:,2)] = intersections(...\n    obj.modifiedVGVertices(1,:), obj.modifiedVGVertices(2,:), ...\n    [vertex1(1) vertex2(1)], [vertex1(2) vertex2(2)]);\n\n\nThe result:\n\n&gt;&gt; points\npoints =\n   12.0000   15.0000\n   33.0000   24.0000\n   33.0000   24.0000\n\n&gt;&gt; vertex1\nvertex1 =\n    12\n    15\n\n&gt;&gt; vertex2    \nvertex2 =\n    33\n    24\n\n\nTwo points (vertex1 and vertex2) should be eliminated from the result. It should be done by the below commands:\n\npoints = points((points(:,1) ~= vertex1(1)) | (points(:,2) ~= vertex1(2)), :);\npoints = points((points(:,1) ~= vertex2(1)) | (points(:,2) ~= vertex2(2)), :);\n\n\nAfter doing that, we have this unexpected outcome:\n\n&gt;&gt; points\npoints =\n   33.0000   24.0000\n\n\nThe outcome should be an empty matrix. As you can see, the first (or second?) pair of [33.0000 24.0000] has been eliminated, but not the second one.\n\nThen I checked these two expressions:\n\n&gt;&gt; points(1) ~= vertex2(1)\nans =\n     0\n&gt;&gt; points(2) ~= vertex2(2)\nans =\n     1   % &lt;-- It means 24.0000 is not equal to 24.0000?\n\n\nWhat is the problem?\n\n\n\nMore surprisingly, I made a new script that has only these commands:\n\npoints = [12.0000   15.0000\n          33.0000   24.0000\n          33.0000   24.0000];\n\nvertex1 = [12 ;  15];\nvertex2 = [33 ;  24];\n\npoints = points((points(:,1) ~= vertex1(1)) | (points(:,2) ~= vertex1(2)), :);\npoints = points((points(:,1) ~= vertex2(1)) | (points(:,2) ~= vertex2(2)), :);\n\n\nThe result as expected:\n\n&gt;&gt; points\npoints =  \n   Empty matrix: 0-by-2\n\n    ","answerCount":6,"upVoteCount":500,"suggestedAnswer":[{"text":"The problem you&apos;re having relates to how floating-point numbers are represented on a computer. A more detailed discussion of floating-point representations appears towards the end of my answer (The &quot;Floating-point representation&quot; section). The TL;DR version: because computers have finite amounts of memory, numbers can only be represented with finite precision. Thus, the accuracy of floating-point numbers is limited to a certain number of decimal places (about 16 significant digits for double-precision values, the default used in MATLAB).\n\nActual vs. displayed precision\n\nNow to address the specific example in the question... while 24.0000 and 24.0000 are displayed in the same manner, it turns out that they actually differ by very small decimal amounts in this case. You don&apos;t see it because MATLAB only displays 4 significant digits by default, keeping the overall display neat and tidy. If you want to see the full precision, you should either issue the format long command or view a hexadecimal representation of the number:\n\n&gt;&gt; pi\nans =\n    3.1416\n&gt;&gt; format long\n&gt;&gt; pi\nans =\n   3.141592653589793\n&gt;&gt; num2hex(pi)\nans =\n400921fb54442d18\n\n\nInitialized values vs. computed values\n\nSince there are only a finite number of values that can be represented for a floating-point number, it&apos;s possible for a computation to result in a value that falls between two of these representations. In such a case, the result has to be rounded off to one of them. This introduces a small machine-precision error. This also means that initializing a value directly or by some computation can give slightly different results. For example, the value 0.1 doesn&apos;t have an exact floating-point representation (i.e. it gets slightly rounded off), and so you end up with counter-intuitive results like this due to the way round-off errors accumulate:\n\n&gt;&gt; a=sum([0.1 0.1 0.1 0.1 0.1 0.1 0.1 0.1 0.1 0.1]);  % Sum 10 0.1s\n&gt;&gt; b=1;                                               % Initialize to 1\n&gt;&gt; a == b\nans =\n  logical\n   0                % They are unequal!\n&gt;&gt; num2hex(a)       % Let&apos;s check their hex representation to confirm\nans =\n3fefffffffffffff\n&gt;&gt; num2hex(b)\nans =\n3ff0000000000000\n\n\nHow to correctly handle floating-point comparisons\n\nSince floating-point values can differ by very small amounts, any comparisons should be done by checking that the values are within some range (i.e. tolerance) of one another, as opposed to exactly equal to each other. For example:\n\na = 24;\nb = 24.000001;\ntolerance = 0.001;\nif abs(a-b) &lt; tolerance, disp(&apos;Equal!&apos;); end\n\n\nwill display &quot;Equal!&quot;.\n\nYou could then change your code to something like:\n\npoints = points((abs(points(:,1)-vertex1(1)) &gt; tolerance) | ...\n                (abs(points(:,2)-vertex1(2)) &gt; tolerance),:)\n\n\n\n\nFloating-point representation\n\nA good overview of floating-point numbers (and specifically the IEEE 754 standard for floating-point arithmetic) is What Every Computer Scientist Should Know About Floating-Point Arithmetic by David Goldberg.\n\nA binary floating-point number is actually represented by three integers: a sign bit s, a significand (or coefficient/fraction) b, and an exponent e. For double-precision floating-point format, each number is represented by 64 bits laid out in memory as follows:\n\n\n\nThe real value can then be found with the following formula:\n\n\n\nThis format allows for number representations in the range 10^-308 to 10^308. For MATLAB you can get these limits from realmin and realmax:\n\n&gt;&gt; realmin\nans =\n    2.225073858507201e-308\n&gt;&gt; realmax\nans =\n    1.797693134862316e+308\n\n\nSince there are a finite number of bits used to represent a floating-point number, there are only so many finite numbers that can be represented within the above given range. Computations will often result in a value that doesn&apos;t exactly match one of these finite representations, so the values must be rounded off. These machine-precision errors make themselves evident in different ways, as discussed in the above examples.\n\nIn order to better understand these round-off errors it&apos;s useful to look at the relative floating-point accuracy provided by the function eps, which quantifies the distance from a given number to the next largest floating-point representation:\n\n&gt;&gt; eps(1)\nans =\n     2.220446049250313e-16\n&gt;&gt; eps(1000)\nans =\n     1.136868377216160e-13\n\n\nNotice that the precision is relative to the size of a given number being represented; larger numbers will have larger distances between floating-point representations, and will thus have fewer digits of precision following the decimal point. This can be an important consideration with some calculations. Consider the following example:\n\n&gt;&gt; format long              % Display full precision\n&gt;&gt; x = rand(1, 10);         % Get 10 random values between 0 and 1\n&gt;&gt; a = mean(x)              % Take the mean\na =\n   0.587307428244141\n&gt;&gt; b = mean(x+10000)-10000  % Take the mean at a different scale, then shift back\nb =\n   0.587307428244458\n\n\nNote that when we shift the values of x from the range [0 1] to the range [10000 10001], compute a mean, then subtract the mean offset for comparison, we get a value that differs for the last 3 significant digits. This illustrates how an offset or scaling of data can change the accuracy of calculations performed on it, which is something that has to be accounted for with certain problems.\n    ","url":"/questions/[slug]#solution1","@type":"Answer","upvoteCount":0},{"text":"Look at this article: The Perils of Floating Point. Though its examples are in FORTRAN it has sense for virtually any modern programming language, including MATLAB. Your problem (and solution for it) is described in &quot;Safe Comparisons&quot; section.\n    ","url":"/questions/[slug]#solution2","@type":"Answer","upvoteCount":0},{"text":"type\n\nformat long g\n\n\nThis command will show the FULL value of the number. It&apos;s likely to be something like 24.00000021321 != 24.00000123124\n    ","url":"/questions/[slug]#solution3","@type":"Answer","upvoteCount":0},{"text":"Try writing \n\n\n  0.1 + 0.1 + 0.1 == 0.3. \n\n\nWarning: You might be surprised about the result!\n    ","url":"/questions/[slug]#solution4","@type":"Answer","upvoteCount":0},{"text":"Maybe the two numbers are really 24.0 and 24.000000001 but you&apos;re not seeing all the decimal places.\n    ","url":"/questions/[slug]#solution5","@type":"Answer","upvoteCount":0},{"text":"Check out the Matlab EPS function.\n\nMatlab uses floating point math up to 16 digits of precision (only 5 are displayed).\n    ","url":"/questions/[slug]#solution6","@type":"Answer","upvoteCount":0}],"@type":"Question"}}</script><meta name="next-head-count" content="16"/><link rel="preload" href="/_next/static/css/08bcc42a26fe5c92.css" as="style"/><link rel="stylesheet" href="/_next/static/css/08bcc42a26fe5c92.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-0d1b80a048d4787e.js"></script><script src="/_next/static/chunks/webpack-42cdea76c8170223.js" defer=""></script><script src="/_next/static/chunks/framework-4556c45dd113b893.js" defer=""></script><script src="/_next/static/chunks/main-ccfab947c79712f4.js" defer=""></script><script src="/_next/static/chunks/pages/_app-08d1a634dea6705e.js" defer=""></script><script src="/_next/static/chunks/29107295-fbcfe2172188e46f.js" defer=""></script><script src="/_next/static/chunks/150-b06815e21c943e0d.js" defer=""></script><script src="/_next/static/chunks/490-7f0418bb4354ac73.js" defer=""></script><script src="/_next/static/chunks/108-87de33c23337ff53.js" defer=""></script><script src="/_next/static/chunks/pages/questions/%5Bslug%5D-79a1437acf654019.js" defer=""></script><script src="/_next/static/6ctJfCympFH_chh5mjicD/_buildManifest.js" defer=""></script><script src="/_next/static/6ctJfCympFH_chh5mjicD/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="wrapper"><header><nav class="bg-white border-gray-200 px-4 lg:px-6 py-2.5 dark:bg-gray-800"><div class="flex flex-wrap justify-between items-center mx-auto max-w-screen-xl"><a class="flex items-center" href="/"><img src="/logo-second.png" class="mr-3 h-6 sm:h-9" alt="Solution Checker Logo"/><h4 class="self-center text-xl font-semibold whitespace-nowrap dark:text-white">Solution Checker</h4></a><div class="flex items-center lg:order-2"><button data-collapse-toggle="mobile-menu-2" type="button" class="inline-flex items-center p-2 ml-1 text-sm text-gray-500 rounded-lg lg:hidden hover:bg-gray-100 focus:outline-none focus:ring-2 focus:ring-gray-200 dark:text-gray-400 dark:hover:bg-gray-700 dark:focus:ring-gray-600" aria-controls="mobile-menu-2" aria-expanded="false"><span class="sr-only">Open main menu</span><svg class="w-6 h-6" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M3 5a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM3 10a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM3 15a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1z" clip-rule="evenodd"></path></svg><svg class="hidden w-6 h-6" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z" clip-rule="evenodd"></path></svg></button></div><div class="hidden justify-between items-center w-full lg:flex lg:w-auto lg:order-1" id="mobile-menu-2"><ul class="flex flex-col mt-4 font-medium lg:flex-row lg:space-x-8 lg:mt-0"><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" aria-current="page" href="/">Home</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/questions?tab=news">Questions</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/post?tab=news">Post</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/questions/why-is-24.0000-not-equal-to-24.0000-in-matlab-1657388376753#">Coding</a></li></ul></div></div></nav></header><div class="main-content"><div class="question my-5"><div class="flex question-header items-center m-auto justify-center"><div class="rounded-xl w-full border p-5 shadow-md bg-white"><div class="flex w-full items-center justify-between border-b pb-3"><div class="flex items-center space-x-3"><div class="text-lg font-bold text-slate-700"><a href="/questions/why-is-24.0000-not-equal-to-24.0000-in-matlab-1657388376753"><h1>Why is 24.0000 not equal to 24.0000 in MATLAB?</h1></a></div></div><div class="flex flex-wrap h-auto justify-end items-center space-x-8"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold" href="/questions/tag/matlab">matlab</a></div></div><div class="question-content mt-5">
                
<p>I am writing a program where I need to delete duplicate points stored in a matrix. The problem is that when it comes to check whether those points are in the matrix, MATLAB can't recognize them in the matrix although they exist.</p>

<p>In the following code, <code>intersections</code> function gets the intersection points:</p>

<pre class="lang-matlab s-code-block"><code class="hljs language-matlab">[points(:,<span class="hljs-number">1</span>), points(:,<span class="hljs-number">2</span>)] = intersections(...
    obj.modifiedVGVertices(<span class="hljs-number">1</span>,:), obj.modifiedVGVertices(<span class="hljs-number">2</span>,:), ...
    [vertex1(<span class="hljs-number">1</span>) vertex2(<span class="hljs-number">1</span>)], [vertex1(<span class="hljs-number">2</span>) vertex2(<span class="hljs-number">2</span>)]);
</code></pre>

<p>The result:</p>

<pre class="lang-matlab s-code-block"><code class="hljs language-matlab">&gt;&gt; points
points =
   <span class="hljs-number">12.0000</span>   <span class="hljs-number">15.0000</span>
   <span class="hljs-number">33.0000</span>   <span class="hljs-number">24.0000</span>
   <span class="hljs-number">33.0000</span>   <span class="hljs-number">24.0000</span>

&gt;&gt; vertex1
vertex1 =
    <span class="hljs-number">12</span>
    <span class="hljs-number">15</span>

&gt;&gt; vertex2    
vertex2 =
    <span class="hljs-number">33</span>
    <span class="hljs-number">24</span>
</code></pre>

<p>Two points (<code>vertex1</code> and <code>vertex2</code>) should be eliminated from the result. It should be done by the below commands:</p>

<pre class="lang-matlab s-code-block"><code class="hljs language-matlab">points = points((points(:,<span class="hljs-number">1</span>) ~= vertex1(<span class="hljs-number">1</span>)) | (points(:,<span class="hljs-number">2</span>) ~= vertex1(<span class="hljs-number">2</span>)), :);
points = points((points(:,<span class="hljs-number">1</span>) ~= vertex2(<span class="hljs-number">1</span>)) | (points(:,<span class="hljs-number">2</span>) ~= vertex2(<span class="hljs-number">2</span>)), :);
</code></pre>

<p>After doing that, we have this unexpected outcome:</p>

<pre class="lang-matlab s-code-block"><code class="hljs language-matlab">&gt;&gt; points
points =
   <span class="hljs-number">33.0000</span>   <span class="hljs-number">24.0000</span>
</code></pre>

<p>The outcome should be an empty matrix. As you can see, the first (or second?) pair of <code>[33.0000 24.0000]</code> has been eliminated, but not the second one.</p>

<p>Then I checked these two expressions:</p>

<pre class="lang-matlab s-code-block"><code class="hljs language-matlab">&gt;&gt; points(<span class="hljs-number">1</span>) ~= vertex2(<span class="hljs-number">1</span>)
<span class="hljs-built_in">ans</span> =
     <span class="hljs-number">0</span>
&gt;&gt; points(<span class="hljs-number">2</span>) ~= vertex2(<span class="hljs-number">2</span>)
<span class="hljs-built_in">ans</span> =
     <span class="hljs-number">1</span>   <span class="hljs-comment">% &lt;-- It means 24.0000 is not equal to 24.0000?</span>
</code></pre>

<p>What is the problem?</p>

<hr>

<p>More surprisingly, I made a new script that has only these commands:</p>

<pre class="lang-matlab s-code-block"><code class="hljs language-matlab">points = [<span class="hljs-number">12.0000</span>   <span class="hljs-number">15.0000</span>
          <span class="hljs-number">33.0000</span>   <span class="hljs-number">24.0000</span>
          <span class="hljs-number">33.0000</span>   <span class="hljs-number">24.0000</span>];

vertex1 = [<span class="hljs-number">12</span> ;  <span class="hljs-number">15</span>];
vertex2 = [<span class="hljs-number">33</span> ;  <span class="hljs-number">24</span>];

points = points((points(:,<span class="hljs-number">1</span>) ~= vertex1(<span class="hljs-number">1</span>)) | (points(:,<span class="hljs-number">2</span>) ~= vertex1(<span class="hljs-number">2</span>)), :);
points = points((points(:,<span class="hljs-number">1</span>) ~= vertex2(<span class="hljs-number">1</span>)) | (points(:,<span class="hljs-number">2</span>) ~= vertex2(<span class="hljs-number">2</span>)), :);
</code></pre>

<p>The result as expected:</p>

<pre class="lang-matlab s-code-block"><code class="hljs language-matlab">&gt;&gt; points
points =  
   Empty matrix: <span class="hljs-number">0</span>-by<span class="hljs-number">-2</span>
</code></pre>
    </div></div></div><div class="solution-section"><nav class="flex pagination-solution flex-col justify-end"><ul class="inline-flex -space-x-px overflow-auto"><li class="pagination-solution-item"><span data-id="#solution1" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">1</span></li><li class="pagination-solution-item"><span data-id="#solution2" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">2</span></li><li class="pagination-solution-item"><span data-id="#solution3" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">3</span></li><li class="pagination-solution-item"><span data-id="#solution4" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">4</span></li><li class="pagination-solution-item"><span data-id="#solution5" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">5</span></li><li class="pagination-solution-item"><span data-id="#solution6" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">6</span></li></ul></nav><div id="solution1" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 1</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/matlab">matlab</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>The problem you're having relates to how <a href="https://www.mathworks.com/help/matlab/matlab_prog/floating-point-numbers.html" rel="noreferrer">floating-point numbers</a> are represented on a computer. A more detailed discussion of floating-point representations appears towards the end of my answer (The "Floating-point representation" section). The <strong>TL;DR</strong> version: because computers have finite amounts of memory, numbers can only be represented with finite precision. Thus, the accuracy of floating-point numbers is limited to a certain number of decimal places (about 16 significant digits for <a href="https://en.wikipedia.org/wiki/Double-precision_floating-point_format" rel="noreferrer">double-precision values</a>, the default used in MATLAB).</p>

<h2>Actual vs. displayed precision</h2>

<p>Now to address the specific example in the question... <strong>while <code>24.0000</code> and <code>24.0000</code> are <em>displayed</em> in the same manner, it turns out that they actually differ by very small decimal amounts in this case. You don't see it because MATLAB <a href="https://www.mathworks.com/help/matlab/ref/format.html" rel="noreferrer">only displays 4 significant digits by default</a>, keeping the overall display neat and tidy.</strong> If you want to see the full precision, you should either issue the <code>format long</code> command or view a <a href="https://www.mathworks.com/help/matlab/ref/num2hex.html" rel="noreferrer">hexadecimal representation</a> of the number:</p>

<pre class="lang-matlab s-code-block"><code class="hljs language-matlab">&gt;&gt; <span class="hljs-built_in">pi</span>
<span class="hljs-built_in">ans</span> =
    <span class="hljs-number">3.1416</span>
&gt;&gt; format long
&gt;&gt; <span class="hljs-built_in">pi</span>
<span class="hljs-built_in">ans</span> =
   <span class="hljs-number">3.141592653589793</span>
&gt;&gt; num2hex(<span class="hljs-built_in">pi</span>)
<span class="hljs-built_in">ans</span> =
<span class="hljs-number">400921</span>fb54442d18
</code></pre>

<h2>Initialized values vs. computed values</h2>

<p>Since there are only a finite number of values that can be represented for a floating-point number, it's possible for a computation to result in a value that falls between two of these representations. In such a case, the result has to be rounded off to one of them. This introduces a small <a href="https://en.wikipedia.org/wiki/Machine_epsilon" rel="noreferrer">machine-precision error</a>. This also means that initializing a value directly or by some computation can give slightly different results. For example, the value <code>0.1</code> doesn't have an <em>exact</em> floating-point representation (i.e. it gets slightly rounded off), and so you end up with counter-intuitive results like this due to the way round-off errors accumulate:</p>

<pre class="lang-matlab s-code-block"><code class="hljs language-matlab">&gt;&gt; a=sum([<span class="hljs-number">0.1</span> <span class="hljs-number">0.1</span> <span class="hljs-number">0.1</span> <span class="hljs-number">0.1</span> <span class="hljs-number">0.1</span> <span class="hljs-number">0.1</span> <span class="hljs-number">0.1</span> <span class="hljs-number">0.1</span> <span class="hljs-number">0.1</span> <span class="hljs-number">0.1</span>]);  <span class="hljs-comment">% Sum 10 0.1s</span>
&gt;&gt; b=<span class="hljs-number">1</span>;                                               <span class="hljs-comment">% Initialize to 1</span>
&gt;&gt; a == b
<span class="hljs-built_in">ans</span> =
  logical
   <span class="hljs-number">0</span>                <span class="hljs-comment">% They are unequal!</span>
&gt;&gt; num2hex(a)       <span class="hljs-comment">% Let's check their hex representation to confirm</span>
<span class="hljs-built_in">ans</span> =
<span class="hljs-number">3</span>fefffffffffffff
&gt;&gt; num2hex(b)
<span class="hljs-built_in">ans</span> =
<span class="hljs-number">3</span>ff0000000000000
</code></pre>

<h2>How to correctly handle floating-point comparisons</h2>

<p>Since floating-point values can differ by very small amounts, any comparisons should be done by checking that the values are within some range (i.e. tolerance) of one another, as opposed to exactly equal to each other. For example:</p>

<pre class="lang-matlab s-code-block"><code class="hljs language-matlab">a = <span class="hljs-number">24</span>;
b = <span class="hljs-number">24.000001</span>;
tolerance = <span class="hljs-number">0.001</span>;
<span class="hljs-keyword">if</span> <span class="hljs-built_in">abs</span>(a-b) &lt; tolerance, <span class="hljs-built_in">disp</span>(<span class="hljs-string">'Equal!'</span>); <span class="hljs-keyword">end</span>
</code></pre>

<p>will display "Equal!".</p>

<p>You could then change your code to something like:</p>

<pre class="lang-matlab s-code-block"><code class="hljs language-matlab">points = points((<span class="hljs-built_in">abs</span>(points(:,<span class="hljs-number">1</span>)-vertex1(<span class="hljs-number">1</span>)) &gt; tolerance) | ...
                (<span class="hljs-built_in">abs</span>(points(:,<span class="hljs-number">2</span>)-vertex1(<span class="hljs-number">2</span>)) &gt; tolerance),:)
</code></pre>

<hr>

<h1>Floating-point representation</h1>

<p>A good overview of floating-point numbers (and specifically the <a href="https://en.wikipedia.org/wiki/IEEE_floating_point" rel="noreferrer">IEEE 754 standard for floating-point arithmetic</a>) is <a href="http://docs.oracle.com/cd/E19957-01/806-3568/ncg_goldberg.html" rel="noreferrer"><em>What Every Computer Scientist Should Know About Floating-Point Arithmetic</em></a> by David Goldberg.</p>

<p>A binary floating-point number is actually represented by three integers: a sign bit <code>s</code>, a significand (or coefficient/fraction) <code>b</code>, and an exponent <code>e</code>. <a href="https://en.wikipedia.org/wiki/Double-precision_floating-point_format" rel="noreferrer">For double-precision floating-point format</a>, each number is represented by 64 bits laid out in memory as follows:</p>

<p><a href="https://i.stack.imgur.com/KTTPX.png" rel="noreferrer"><img src="https://i.stack.imgur.com/KTTPX.png" alt="enter image description here"></a></p>

<p>The real value can then be found with the following formula:</p>

<p><a href="https://i.stack.imgur.com/nV0ly.png" rel="noreferrer"><img src="https://i.stack.imgur.com/nV0ly.png" alt="enter image description here"></a></p>

<p>This format allows for number representations in the range 10^-308 to 10^308. For MATLAB you can get these limits from <a href="https://www.mathworks.com/help/matlab/ref/realmin.html" rel="noreferrer"><code>realmin</code></a> and <a href="https://www.mathworks.com/help/matlab/ref/realmax.html" rel="noreferrer"><code>realmax</code></a>:</p>

<pre class="lang-matlab s-code-block"><code class="hljs language-matlab">&gt;&gt; <span class="hljs-built_in">realmin</span>
<span class="hljs-built_in">ans</span> =
    <span class="hljs-number">2.225073858507201e-308</span>
&gt;&gt; <span class="hljs-built_in">realmax</span>
<span class="hljs-built_in">ans</span> =
    <span class="hljs-number">1.797693134862316e+308</span>
</code></pre>

<p>Since there are a finite number of bits used to represent a floating-point number, there are only so many finite numbers that can be represented within the above given range. Computations will often result in a value that doesn't exactly match one of these finite representations, so the values must be rounded off. These <a href="https://en.wikipedia.org/wiki/Machine_epsilon" rel="noreferrer">machine-precision errors</a> make themselves evident in different ways, as discussed in the above examples.</p>

<p>In order to better understand these round-off errors it's useful to look at the relative floating-point accuracy provided by the function <a href="https://www.mathworks.com/help/matlab/ref/eps.html" rel="noreferrer"><code>eps</code></a>, which quantifies the distance from a given number to the next largest floating-point representation:</p>

<pre class="lang-matlab s-code-block"><code class="hljs language-matlab">&gt;&gt; <span class="hljs-built_in">eps</span>(<span class="hljs-number">1</span>)
<span class="hljs-built_in">ans</span> =
     <span class="hljs-number">2.220446049250313e-16</span>
&gt;&gt; <span class="hljs-built_in">eps</span>(<span class="hljs-number">1000</span>)
<span class="hljs-built_in">ans</span> =
     <span class="hljs-number">1.136868377216160e-13</span>
</code></pre>

<p>Notice that the precision is <em>relative</em> to the size of a given number being represented; larger numbers will have larger distances between floating-point representations, and will thus have fewer digits of precision following the decimal point. This can be an important consideration with some calculations. Consider the following example:</p>

<pre class="lang-matlab s-code-block"><code class="hljs language-matlab">&gt;&gt; format long              <span class="hljs-comment">% Display full precision</span>
&gt;&gt; x = <span class="hljs-built_in">rand</span>(<span class="hljs-number">1</span>, <span class="hljs-number">10</span>);         <span class="hljs-comment">% Get 10 random values between 0 and 1</span>
&gt;&gt; a = <span class="hljs-built_in">mean</span>(x)              <span class="hljs-comment">% Take the mean</span>
a =
   <span class="hljs-number">0.587307428244141</span>
&gt;&gt; b = <span class="hljs-built_in">mean</span>(x+<span class="hljs-number">10000</span>)<span class="hljs-number">-10000</span>  <span class="hljs-comment">% Take the mean at a different scale, then shift back</span>
b =
   <span class="hljs-number">0.587307428244458</span>
</code></pre>

<p>Note that when we shift the values of <code>x</code> from the range <code>[0 1]</code> to the range <code>[10000 10001]</code>, compute a mean, then subtract the mean offset for comparison, we get a value that differs for the last 3 significant digits. This illustrates how an offset or scaling of data can change the accuracy of calculations performed on it, which is something that has to be accounted for with certain problems.</p>
    </div></div></div></div><div id="solution2" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 2</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/matlab">matlab</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Look at this article: <a href="http://www.lahey.com/float.htm" rel="noreferrer">The Perils of Floating Point</a>. Though its examples are in FORTRAN it has sense for virtually any modern programming language, including MATLAB. Your problem (and solution for it) is described in "Safe Comparisons" section.</p>
    </div></div></div></div><div id="solution3" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 3</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/matlab">matlab</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>type</p>

<pre class="lang-matlab s-code-block"><code class="hljs language-matlab">format long g
</code></pre>

<p>This command will show the FULL value of the number. It's likely to be something like 24.00000021321 != 24.00000123124</p>
    </div></div></div></div><div id="solution4" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 4</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/matlab">matlab</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Try writing </p>

<blockquote>
  <p>0.1 + 0.1 + 0.1 == 0.3. </p>
</blockquote>

<p>Warning: You might be surprised about the result!</p>
    </div></div></div></div><div id="solution5" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 5</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/matlab">matlab</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Maybe the two numbers are really 24.0 and 24.000000001 but you're not seeing all the decimal places.</p>
    </div></div></div></div><div id="solution6" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 6</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/matlab">matlab</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Check out the <a href="https://www.mathworks.com/help/matlab/ref/eps.html" rel="nofollow noreferrer">Matlab EPS function</a>.</p>

<p>Matlab uses floating point math up to 16 digits of precision (only 5 are displayed).</p>
    </div></div></div></div></div></div><div class="widget"><a href="/questions/add-a-property-to-a-javascript-object-using-a-variable-as-the-name-1657388425650">Add a property to a JavaScript object using a variable as the name?</a><a href="/questions/what-does-the-comma-operator-do-1657388258021">What does the comma operator , do?</a><a href="/questions/how-can-i-read-and-parse-csv-files-in-c++-1657387869219">How can I read and parse CSV files in C++?</a><a href="/questions/switch-between-two-frames-in-tkinter-1657388528781">Switch between two frames in tkinter?</a><a href="/questions/how-do-i-make-a-redirect-in-php-1657387381903">How do I make a redirect in PHP?</a><a href="/questions/why-do-i-get-a-segmentation-fault-when-writing-to-a-%22char-*s%22-initialized-with-a-string-literal-but-not-%22char-s%22-1657385511046">Why do I get a segmentation fault when writing to a &quot;char *s&quot; initialized with a string literal, but not &quot;char s[]&quot;?</a><a href="/questions/what-is-the-scope-of-variables-in-javascript-1657384464291">What is the scope of variables in JavaScript?</a><a href="/questions/preview-an-image-before-it-is-uploaded-1657388048128">Preview an image before it is uploaded</a><a href="/questions/how-to-make-function-decorators-and-chain-them-together-1657388180803">How to make function decorators and chain them together?</a><a href="/questions/%22is%22-operator-behaves-unexpectedly-with-integers-1657387563823">&quot;is&quot; operator behaves unexpectedly with integers</a><a href="/questions/the-definitive-guide-to-form-based-website-authentication-closed-1657388456475">The definitive guide to form-based website authentication [closed]</a><a href="/questions/example-images-for-code-and-mark-up-qandas-closed-1657387690222">Example images for code and mark-up Q&amp;As [closed]</a><a href="/questions/the-definitive-c++-book-guide-and-list-1657384247395">The Definitive C++ Book Guide and List</a><a href="/questions/how-do-i-set-clear-and-toggle-a-single-bit-1657388227052">How do I set, clear, and toggle a single bit?</a><a href="/questions/does-javascript-guarantee-object-property-order-1657384822587">Does JavaScript guarantee object property order?</a><a href="/questions/reshaping-data.frame-from-wide-to-long-format-1657384678522">Reshaping data.frame from wide to long format</a><a href="/questions/why-is-%22using-namespace-std%22-considered-bad-practice-1657384296377">Why is &quot;using namespace std;&quot; considered bad practice?</a><a href="/questions/how-do-i-detect-collision-in-pygame-1657387496338">How do I detect collision in pygame?</a><a href="/questions/generating-random-whole-numbers-in-javascript-in-a-specific-range-1657388112728">Generating random whole numbers in JavaScript in a specific range</a><a href="/questions/how-to-remove-%22noise%22-from-gccclang-assembly-output-1657387612391">How to remove &quot;noise&quot; from GCC/clang assembly output?</a></div></div><span class="cursor-pointer text-lg p-2" style="position:fixed;bottom:20px;left:20px;background:#000;z-index:2000;color:white">Go go top</span></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"data":{"answer":["\n\u0026lt;p\u0026gt;The problem you\u0026apos;re having relates to how \u0026lt;a href=\u0026quot;https://www.mathworks.com/help/matlab/matlab_prog/floating-point-numbers.html\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;floating-point numbers\u0026lt;/a\u0026gt; are represented on a computer. A more detailed discussion of floating-point representations appears towards the end of my answer (The \u0026quot;Floating-point representation\u0026quot; section). The \u0026lt;strong\u0026gt;TL;DR\u0026lt;/strong\u0026gt; version: because computers have finite amounts of memory, numbers can only be represented with finite precision. Thus, the accuracy of floating-point numbers is limited to a certain number of decimal places (about 16 significant digits for \u0026lt;a href=\u0026quot;https://en.wikipedia.org/wiki/Double-precision_floating-point_format\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;double-precision values\u0026lt;/a\u0026gt;, the default used in MATLAB).\u0026lt;/p\u0026gt;\n\n\u0026lt;h2\u0026gt;Actual vs. displayed precision\u0026lt;/h2\u0026gt;\n\n\u0026lt;p\u0026gt;Now to address the specific example in the question... \u0026lt;strong\u0026gt;while \u0026lt;code\u0026gt;24.0000\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;24.0000\u0026lt;/code\u0026gt; are \u0026lt;em\u0026gt;displayed\u0026lt;/em\u0026gt; in the same manner, it turns out that they actually differ by very small decimal amounts in this case. You don\u0026apos;t see it because MATLAB \u0026lt;a href=\u0026quot;https://www.mathworks.com/help/matlab/ref/format.html\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;only displays 4 significant digits by default\u0026lt;/a\u0026gt;, keeping the overall display neat and tidy.\u0026lt;/strong\u0026gt; If you want to see the full precision, you should either issue the \u0026lt;code\u0026gt;format long\u0026lt;/code\u0026gt; command or view a \u0026lt;a href=\u0026quot;https://www.mathworks.com/help/matlab/ref/num2hex.html\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;hexadecimal representation\u0026lt;/a\u0026gt; of the number:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-matlab s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-matlab\u0026quot;\u0026gt;\u0026amp;gt;\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;pi\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;ans\u0026lt;/span\u0026gt; =\n    \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3.1416\u0026lt;/span\u0026gt;\n\u0026amp;gt;\u0026amp;gt; format long\n\u0026amp;gt;\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;pi\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;ans\u0026lt;/span\u0026gt; =\n   \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3.141592653589793\u0026lt;/span\u0026gt;\n\u0026amp;gt;\u0026amp;gt; num2hex(\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;pi\u0026lt;/span\u0026gt;)\n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;ans\u0026lt;/span\u0026gt; =\n\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;400921\u0026lt;/span\u0026gt;fb54442d18\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;h2\u0026gt;Initialized values vs. computed values\u0026lt;/h2\u0026gt;\n\n\u0026lt;p\u0026gt;Since there are only a finite number of values that can be represented for a floating-point number, it\u0026apos;s possible for a computation to result in a value that falls between two of these representations. In such a case, the result has to be rounded off to one of them. This introduces a small \u0026lt;a href=\u0026quot;https://en.wikipedia.org/wiki/Machine_epsilon\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;machine-precision error\u0026lt;/a\u0026gt;. This also means that initializing a value directly or by some computation can give slightly different results. For example, the value \u0026lt;code\u0026gt;0.1\u0026lt;/code\u0026gt; doesn\u0026apos;t have an \u0026lt;em\u0026gt;exact\u0026lt;/em\u0026gt; floating-point representation (i.e. it gets slightly rounded off), and so you end up with counter-intuitive results like this due to the way round-off errors accumulate:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-matlab s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-matlab\u0026quot;\u0026gt;\u0026amp;gt;\u0026amp;gt; a=sum([\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0.1\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0.1\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0.1\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0.1\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0.1\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0.1\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0.1\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0.1\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0.1\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0.1\u0026lt;/span\u0026gt;]);  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;% Sum 10 0.1s\u0026lt;/span\u0026gt;\n\u0026amp;gt;\u0026amp;gt; b=\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;;                                               \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;% Initialize to 1\u0026lt;/span\u0026gt;\n\u0026amp;gt;\u0026amp;gt; a == b\n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;ans\u0026lt;/span\u0026gt; =\n  logical\n   \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;                \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;% They are unequal!\u0026lt;/span\u0026gt;\n\u0026amp;gt;\u0026amp;gt; num2hex(a)       \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;% Let\u0026apos;s check their hex representation to confirm\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;ans\u0026lt;/span\u0026gt; =\n\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3\u0026lt;/span\u0026gt;fefffffffffffff\n\u0026amp;gt;\u0026amp;gt; num2hex(b)\n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;ans\u0026lt;/span\u0026gt; =\n\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3\u0026lt;/span\u0026gt;ff0000000000000\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;h2\u0026gt;How to correctly handle floating-point comparisons\u0026lt;/h2\u0026gt;\n\n\u0026lt;p\u0026gt;Since floating-point values can differ by very small amounts, any comparisons should be done by checking that the values are within some range (i.e. tolerance) of one another, as opposed to exactly equal to each other. For example:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-matlab s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-matlab\u0026quot;\u0026gt;a = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;24\u0026lt;/span\u0026gt;;\nb = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;24.000001\u0026lt;/span\u0026gt;;\ntolerance = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0.001\u0026lt;/span\u0026gt;;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;abs\u0026lt;/span\u0026gt;(a-b) \u0026amp;lt; tolerance, \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;disp\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;Equal!\u0026apos;\u0026lt;/span\u0026gt;); \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;end\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;will display \u0026quot;Equal!\u0026quot;.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;You could then change your code to something like:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-matlab s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-matlab\u0026quot;\u0026gt;points = points((\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;abs\u0026lt;/span\u0026gt;(points(:,\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;)-vertex1(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;)) \u0026amp;gt; tolerance) | ...\n                (\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;abs\u0026lt;/span\u0026gt;(points(:,\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;)-vertex1(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;)) \u0026amp;gt; tolerance),:)\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;hr\u0026gt;\n\n\u0026lt;h1\u0026gt;Floating-point representation\u0026lt;/h1\u0026gt;\n\n\u0026lt;p\u0026gt;A good overview of floating-point numbers (and specifically the \u0026lt;a href=\u0026quot;https://en.wikipedia.org/wiki/IEEE_floating_point\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;IEEE 754 standard for floating-point arithmetic\u0026lt;/a\u0026gt;) is \u0026lt;a href=\u0026quot;http://docs.oracle.com/cd/E19957-01/806-3568/ncg_goldberg.html\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;\u0026lt;em\u0026gt;What Every Computer Scientist Should Know About Floating-Point Arithmetic\u0026lt;/em\u0026gt;\u0026lt;/a\u0026gt; by David Goldberg.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;A binary floating-point number is actually represented by three integers: a sign bit \u0026lt;code\u0026gt;s\u0026lt;/code\u0026gt;, a significand (or coefficient/fraction) \u0026lt;code\u0026gt;b\u0026lt;/code\u0026gt;, and an exponent \u0026lt;code\u0026gt;e\u0026lt;/code\u0026gt;. \u0026lt;a href=\u0026quot;https://en.wikipedia.org/wiki/Double-precision_floating-point_format\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;For double-precision floating-point format\u0026lt;/a\u0026gt;, each number is represented by 64 bits laid out in memory as follows:\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;a href=\u0026quot;https://i.stack.imgur.com/KTTPX.png\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;\u0026lt;img src=\u0026quot;https://i.stack.imgur.com/KTTPX.png\u0026quot; alt=\u0026quot;enter image description here\u0026quot;\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;The real value can then be found with the following formula:\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;a href=\u0026quot;https://i.stack.imgur.com/nV0ly.png\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;\u0026lt;img src=\u0026quot;https://i.stack.imgur.com/nV0ly.png\u0026quot; alt=\u0026quot;enter image description here\u0026quot;\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;This format allows for number representations in the range 10^-308 to 10^308. For MATLAB you can get these limits from \u0026lt;a href=\u0026quot;https://www.mathworks.com/help/matlab/ref/realmin.html\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;\u0026lt;code\u0026gt;realmin\u0026lt;/code\u0026gt;\u0026lt;/a\u0026gt; and \u0026lt;a href=\u0026quot;https://www.mathworks.com/help/matlab/ref/realmax.html\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;\u0026lt;code\u0026gt;realmax\u0026lt;/code\u0026gt;\u0026lt;/a\u0026gt;:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-matlab s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-matlab\u0026quot;\u0026gt;\u0026amp;gt;\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;realmin\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;ans\u0026lt;/span\u0026gt; =\n    \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2.225073858507201e-308\u0026lt;/span\u0026gt;\n\u0026amp;gt;\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;realmax\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;ans\u0026lt;/span\u0026gt; =\n    \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1.797693134862316e+308\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Since there are a finite number of bits used to represent a floating-point number, there are only so many finite numbers that can be represented within the above given range. Computations will often result in a value that doesn\u0026apos;t exactly match one of these finite representations, so the values must be rounded off. These \u0026lt;a href=\u0026quot;https://en.wikipedia.org/wiki/Machine_epsilon\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;machine-precision errors\u0026lt;/a\u0026gt; make themselves evident in different ways, as discussed in the above examples.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;In order to better understand these round-off errors it\u0026apos;s useful to look at the relative floating-point accuracy provided by the function \u0026lt;a href=\u0026quot;https://www.mathworks.com/help/matlab/ref/eps.html\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;\u0026lt;code\u0026gt;eps\u0026lt;/code\u0026gt;\u0026lt;/a\u0026gt;, which quantifies the distance from a given number to the next largest floating-point representation:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-matlab s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-matlab\u0026quot;\u0026gt;\u0026amp;gt;\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;eps\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;)\n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;ans\u0026lt;/span\u0026gt; =\n     \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2.220446049250313e-16\u0026lt;/span\u0026gt;\n\u0026amp;gt;\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;eps\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1000\u0026lt;/span\u0026gt;)\n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;ans\u0026lt;/span\u0026gt; =\n     \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1.136868377216160e-13\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Notice that the precision is \u0026lt;em\u0026gt;relative\u0026lt;/em\u0026gt; to the size of a given number being represented; larger numbers will have larger distances between floating-point representations, and will thus have fewer digits of precision following the decimal point. This can be an important consideration with some calculations. Consider the following example:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-matlab s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-matlab\u0026quot;\u0026gt;\u0026amp;gt;\u0026amp;gt; format long              \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;% Display full precision\u0026lt;/span\u0026gt;\n\u0026amp;gt;\u0026amp;gt; x = \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;rand\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;10\u0026lt;/span\u0026gt;);         \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;% Get 10 random values between 0 and 1\u0026lt;/span\u0026gt;\n\u0026amp;gt;\u0026amp;gt; a = \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;mean\u0026lt;/span\u0026gt;(x)              \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;% Take the mean\u0026lt;/span\u0026gt;\na =\n   \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0.587307428244141\u0026lt;/span\u0026gt;\n\u0026amp;gt;\u0026amp;gt; b = \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;mean\u0026lt;/span\u0026gt;(x+\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;10000\u0026lt;/span\u0026gt;)\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;-10000\u0026lt;/span\u0026gt;  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;% Take the mean at a different scale, then shift back\u0026lt;/span\u0026gt;\nb =\n   \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0.587307428244458\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Note that when we shift the values of \u0026lt;code\u0026gt;x\u0026lt;/code\u0026gt; from the range \u0026lt;code\u0026gt;[0 1]\u0026lt;/code\u0026gt; to the range \u0026lt;code\u0026gt;[10000 10001]\u0026lt;/code\u0026gt;, compute a mean, then subtract the mean offset for comparison, we get a value that differs for the last 3 significant digits. This illustrates how an offset or scaling of data can change the accuracy of calculations performed on it, which is something that has to be accounted for with certain problems.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Look at this article: \u0026lt;a href=\u0026quot;http://www.lahey.com/float.htm\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;The Perils of Floating Point\u0026lt;/a\u0026gt;. Though its examples are in FORTRAN it has sense for virtually any modern programming language, including MATLAB. Your problem (and solution for it) is described in \u0026quot;Safe Comparisons\u0026quot; section.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;type\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-matlab s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-matlab\u0026quot;\u0026gt;format long g\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;This command will show the FULL value of the number. It\u0026apos;s likely to be something like 24.00000021321 != 24.00000123124\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Try writing \u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;0.1 + 0.1 + 0.1 == 0.3. \u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;p\u0026gt;Warning: You might be surprised about the result!\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Maybe the two numbers are really 24.0 and 24.000000001 but you\u0026apos;re not seeing all the decimal places.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Check out the \u0026lt;a href=\u0026quot;https://www.mathworks.com/help/matlab/ref/eps.html\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;Matlab EPS function\u0026lt;/a\u0026gt;.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Matlab uses floating point math up to 16 digits of precision (only 5 are displayed).\u0026lt;/p\u0026gt;\n    "],"id":545,"title":"Why is 24.0000 not equal to 24.0000 in MATLAB?","content":"\n                \n\u0026lt;p\u0026gt;I am writing a program where I need to delete duplicate points stored in a matrix. The problem is that when it comes to check whether those points are in the matrix, MATLAB can\u0026apos;t recognize them in the matrix although they exist.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;In the following code, \u0026lt;code\u0026gt;intersections\u0026lt;/code\u0026gt; function gets the intersection points:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-matlab s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-matlab\u0026quot;\u0026gt;[points(:,\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;), points(:,\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;)] = intersections(...\n    obj.modifiedVGVertices(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;,:), obj.modifiedVGVertices(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;,:), ...\n    [vertex1(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;) vertex2(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;)], [vertex1(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;) vertex2(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;)]);\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;The result:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-matlab s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-matlab\u0026quot;\u0026gt;\u0026amp;gt;\u0026amp;gt; points\npoints =\n   \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;12.0000\u0026lt;/span\u0026gt;   \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;15.0000\u0026lt;/span\u0026gt;\n   \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;33.0000\u0026lt;/span\u0026gt;   \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;24.0000\u0026lt;/span\u0026gt;\n   \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;33.0000\u0026lt;/span\u0026gt;   \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;24.0000\u0026lt;/span\u0026gt;\n\n\u0026amp;gt;\u0026amp;gt; vertex1\nvertex1 =\n    \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;12\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;15\u0026lt;/span\u0026gt;\n\n\u0026amp;gt;\u0026amp;gt; vertex2    \nvertex2 =\n    \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;33\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;24\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Two points (\u0026lt;code\u0026gt;vertex1\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;vertex2\u0026lt;/code\u0026gt;) should be eliminated from the result. It should be done by the below commands:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-matlab s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-matlab\u0026quot;\u0026gt;points = points((points(:,\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;) ~= vertex1(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;)) | (points(:,\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;) ~= vertex1(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;)), :);\npoints = points((points(:,\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;) ~= vertex2(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;)) | (points(:,\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;) ~= vertex2(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;)), :);\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;After doing that, we have this unexpected outcome:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-matlab s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-matlab\u0026quot;\u0026gt;\u0026amp;gt;\u0026amp;gt; points\npoints =\n   \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;33.0000\u0026lt;/span\u0026gt;   \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;24.0000\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;The outcome should be an empty matrix. As you can see, the first (or second?) pair of \u0026lt;code\u0026gt;[33.0000 24.0000]\u0026lt;/code\u0026gt; has been eliminated, but not the second one.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Then I checked these two expressions:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-matlab s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-matlab\u0026quot;\u0026gt;\u0026amp;gt;\u0026amp;gt; points(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;) ~= vertex2(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;)\n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;ans\u0026lt;/span\u0026gt; =\n     \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;\n\u0026amp;gt;\u0026amp;gt; points(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;) ~= vertex2(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;)\n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;ans\u0026lt;/span\u0026gt; =\n     \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;   \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;% \u0026amp;lt;-- It means 24.0000 is not equal to 24.0000?\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;What is the problem?\u0026lt;/p\u0026gt;\n\n\u0026lt;hr\u0026gt;\n\n\u0026lt;p\u0026gt;More surprisingly, I made a new script that has only these commands:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-matlab s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-matlab\u0026quot;\u0026gt;points = [\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;12.0000\u0026lt;/span\u0026gt;   \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;15.0000\u0026lt;/span\u0026gt;\n          \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;33.0000\u0026lt;/span\u0026gt;   \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;24.0000\u0026lt;/span\u0026gt;\n          \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;33.0000\u0026lt;/span\u0026gt;   \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;24.0000\u0026lt;/span\u0026gt;];\n\nvertex1 = [\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;12\u0026lt;/span\u0026gt; ;  \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;15\u0026lt;/span\u0026gt;];\nvertex2 = [\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;33\u0026lt;/span\u0026gt; ;  \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;24\u0026lt;/span\u0026gt;];\n\npoints = points((points(:,\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;) ~= vertex1(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;)) | (points(:,\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;) ~= vertex1(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;)), :);\npoints = points((points(:,\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;) ~= vertex2(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;)) | (points(:,\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;) ~= vertex2(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;)), :);\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;The result as expected:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-matlab s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-matlab\u0026quot;\u0026gt;\u0026amp;gt;\u0026amp;gt; points\npoints =  \n   Empty matrix: \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;-by\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;-2\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","slug":"why-is-24.0000-not-equal-to-24.0000-in-matlab-1657388376753","postType":"QUESTION","createdAt":"2022-07-09T17:39:36.000Z","updatedAt":"2022-07-09T17:39:36.000Z","tags":[{"id":2657,"name":"matlab","slug":"matlab","createdAt":"2022-07-09T17:39:36.000Z","updatedAt":"2022-07-09T17:39:36.000Z","Questions_Tags":{"questionId":545,"tagId":2657}}],"relatedQuestions":[{"title":"Why is 24.0000 not equal to 24.0000 in MATLAB?","slug":"why-is-24.0000-not-equal-to-24.0000-in-matlab-1657388376753","tags":[{"name":"matlab","Questions_Tags":{"questionId":545,"tagId":2657}}]}]},"randomQuestions":[{"title":"Add a property to a JavaScript object using a variable as the name?","slug":"add-a-property-to-a-javascript-object-using-a-variable-as-the-name-1657388425650"},{"title":"What does the comma operator , do?","slug":"what-does-the-comma-operator-do-1657388258021"},{"title":"How can I read and parse CSV files in C++?","slug":"how-can-i-read-and-parse-csv-files-in-c++-1657387869219"},{"title":"Switch between two frames in tkinter?","slug":"switch-between-two-frames-in-tkinter-1657388528781"},{"title":"How do I make a redirect in PHP?","slug":"how-do-i-make-a-redirect-in-php-1657387381903"},{"title":"Why do I get a segmentation fault when writing to a \"char *s\" initialized with a string literal, but not \"char s[]\"?","slug":"why-do-i-get-a-segmentation-fault-when-writing-to-a-\"char-*s\"-initialized-with-a-string-literal-but-not-\"char-s\"-1657385511046"},{"title":"What is the scope of variables in JavaScript?","slug":"what-is-the-scope-of-variables-in-javascript-1657384464291"},{"title":"Preview an image before it is uploaded","slug":"preview-an-image-before-it-is-uploaded-1657388048128"},{"title":"How to make function decorators and chain them together?","slug":"how-to-make-function-decorators-and-chain-them-together-1657388180803"},{"title":"\"is\" operator behaves unexpectedly with integers","slug":"\"is\"-operator-behaves-unexpectedly-with-integers-1657387563823"},{"title":"The definitive guide to form-based website authentication [closed]","slug":"the-definitive-guide-to-form-based-website-authentication-closed-1657388456475"},{"title":"Example images for code and mark-up Q\u0026As [closed]","slug":"example-images-for-code-and-mark-up-qandas-closed-1657387690222"},{"title":"The Definitive C++ Book Guide and List","slug":"the-definitive-c++-book-guide-and-list-1657384247395"},{"title":"How do I set, clear, and toggle a single bit?","slug":"how-do-i-set-clear-and-toggle-a-single-bit-1657388227052"},{"title":"Does JavaScript guarantee object property order?","slug":"does-javascript-guarantee-object-property-order-1657384822587"},{"title":"Reshaping data.frame from wide to long format","slug":"reshaping-data.frame-from-wide-to-long-format-1657384678522"},{"title":"Why is \"using namespace std;\" considered bad practice?","slug":"why-is-\"using-namespace-std\"-considered-bad-practice-1657384296377"},{"title":"How do I detect collision in pygame?","slug":"how-do-i-detect-collision-in-pygame-1657387496338"},{"title":"Generating random whole numbers in JavaScript in a specific range","slug":"generating-random-whole-numbers-in-javascript-in-a-specific-range-1657388112728"},{"title":"How to remove \"noise\" from GCC/clang assembly output?","slug":"how-to-remove-\"noise\"-from-gccclang-assembly-output-1657387612391"}]},"__N_SSG":true},"page":"/questions/[slug]","query":{"slug":"why-is-24.0000-not-equal-to-24.0000-in-matlab-1657388376753"},"buildId":"6ctJfCympFH_chh5mjicD","isFallback":false,"gsp":true,"locale":"en","locales":["en"],"defaultLocale":"en","scriptLoader":[]}</script></body></html>