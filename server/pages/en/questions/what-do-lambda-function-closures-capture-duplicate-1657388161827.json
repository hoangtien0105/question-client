{"pageProps":{"data":{"answer":["\n&lt;p&gt;you may force the capture of a variable using an argument with a default value:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; i &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; [&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;]:\n&lt;span class=&quot;hljs-meta&quot;&gt;... &lt;/span&gt;   adders[i]=&lt;span class=&quot;hljs-keyword&quot;&gt;lambda&lt;/span&gt; a,i=i: i+a  &lt;span class=&quot;hljs-comment&quot;&gt;# note the dummy parameter with a default value&lt;/span&gt;\n...\n&lt;span class=&quot;hljs-meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;print&lt;/span&gt;( adders[&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;](&lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;) )\n&lt;span class=&quot;hljs-number&quot;&gt;4&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;the idea is to declare a parameter (cleverly named &lt;code&gt;i&lt;/code&gt;) and give it a default value of the variable you want to capture (the value of  &lt;code&gt;i&lt;/code&gt;)&lt;/p&gt;\n    ","\n&lt;p&gt;Your second question has been answered, but as for your first:&lt;/p&gt;\n&lt;blockquote&gt;\n&lt;p&gt;what does the closure capture exactly?&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;p&gt;Scoping in Python is &lt;strike&gt;dynamic and&lt;/strike&gt; lexical. A closure will always remember the name and scope of the variable, not the object it&apos;s pointing to. Since all the functions in your example are created in the same scope and use the same variable name, they always refer to the same variable.&lt;/p&gt;\n&lt;p&gt;Regarding your other question of how to overcome this, there are two ways that come to mind:&lt;/p&gt;\n&lt;ol&gt;\n&lt;li&gt;&lt;p&gt;The most concise, but not strictly equivalent way is the &lt;a href=&quot;https://stackoverflow.com/a/2295372/181765&quot;&gt;one recommended by Adrien Plisson&lt;/a&gt;. Create a lambda with an extra argument, and set the extra argument&apos;s default value to the object you want preserved.&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;p&gt;A little more verbose but less hacky would be to create a new scope each time you create the lambda:&lt;/p&gt;\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt; &amp;gt;&amp;gt;&amp;gt; adders = [&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;]\n &amp;gt;&amp;gt;&amp;gt; &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; i &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; [&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;]:\n ...     adders[i] = (&lt;span class=&quot;hljs-keyword&quot;&gt;lambda&lt;/span&gt; b: &lt;span class=&quot;hljs-keyword&quot;&gt;lambda&lt;/span&gt; a: b + a)(i)\n ...     \n &amp;gt;&amp;gt;&amp;gt; adders[&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;](&lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;)\n &lt;span class=&quot;hljs-number&quot;&gt;4&lt;/span&gt;\n &amp;gt;&amp;gt;&amp;gt; adders[&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;](&lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;)\n &lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;/li&gt;\n&lt;/ol&gt;\n&lt;p&gt;The scope here is created using a new function (a lambda, for brevity), which binds its argument, and passing the value you want to bind as the argument. In real code, though, you most likely will have an ordinary function instead of the lambda to create the new scope:&lt;/p&gt;\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;createAdder&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;x&lt;/span&gt;):\n    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;lambda&lt;/span&gt; y: y + x\nadders = [createAdder(i) &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; i &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;hljs-built_in&quot;&gt;range&lt;/span&gt;(&lt;span class=&quot;hljs-number&quot;&gt;4&lt;/span&gt;)]\n&lt;/code&gt;&lt;/pre&gt;\n    ","\n&lt;p&gt;For completeness another answer to your second question: You could use &lt;a href=&quot;http://docs.python.org/library/functools.html#functools.partial&quot; rel=&quot;nofollow noreferrer&quot;&gt;partial&lt;/a&gt; in the &lt;a href=&quot;http://docs.python.org/library/functools.html&quot; rel=&quot;nofollow noreferrer&quot;&gt;functools&lt;/a&gt; module.&lt;/p&gt;\n&lt;p&gt;With importing add from operator as Chris Lutz proposed the example becomes:&lt;/p&gt;\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;from&lt;/span&gt; functools &lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; partial\n&lt;span class=&quot;hljs-keyword&quot;&gt;from&lt;/span&gt; operator &lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; add   &lt;span class=&quot;hljs-comment&quot;&gt;# add(a, b) -- Same as a + b.&lt;/span&gt;\n\nadders = [&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;]\n&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; i &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; [&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;]:\n    &lt;span class=&quot;hljs-comment&quot;&gt;# store callable object with first argument given as (current) i&lt;/span&gt;\n    adders[i] = partial(add, i) \n\n&lt;span class=&quot;hljs-built_in&quot;&gt;print&lt;/span&gt; adders[&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;](&lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;)\n&lt;/code&gt;&lt;/pre&gt;\n    ","\n&lt;p&gt;Consider the following code:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;x = &lt;span class=&quot;hljs-string&quot;&gt;&quot;foo&quot;&lt;/span&gt;\n\n&lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;print_x&lt;/span&gt;():\n    &lt;span class=&quot;hljs-built_in&quot;&gt;print&lt;/span&gt; x\n\nx = &lt;span class=&quot;hljs-string&quot;&gt;&quot;bar&quot;&lt;/span&gt;\n\nprint_x() &lt;span class=&quot;hljs-comment&quot;&gt;# Outputs &quot;bar&quot;&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;I think most people won&apos;t find this confusing at all. It is the expected behaviour.&lt;/p&gt;\n\n&lt;p&gt;So, why do people think it would be different when it is done in a loop? I know I did that mistake myself, but I don&apos;t know why. It is the loop? Or perhaps the lambda?&lt;/p&gt;\n\n&lt;p&gt;After all, the loop is just a shorter version of:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;adders= [&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;]\ni = &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;\nadders[i] = &lt;span class=&quot;hljs-keyword&quot;&gt;lambda&lt;/span&gt; a: i+a\ni = &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;\nadders[i] = &lt;span class=&quot;hljs-keyword&quot;&gt;lambda&lt;/span&gt; a: i+a\ni = &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;\nadders[i] = &lt;span class=&quot;hljs-keyword&quot;&gt;lambda&lt;/span&gt; a: i+a\ni = &lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;\nadders[i] = &lt;span class=&quot;hljs-keyword&quot;&gt;lambda&lt;/span&gt; a: i+a\n&lt;/code&gt;&lt;/pre&gt;\n    ","\n&lt;p&gt;Here&apos;s a new example that highlights the data structure and contents of a closure, to help clarify when the enclosing context is &quot;saved.&quot;&lt;/p&gt;\n\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;make_funcs&lt;/span&gt;():\n    i = &lt;span class=&quot;hljs-number&quot;&gt;42&lt;/span&gt;\n    my_str = &lt;span class=&quot;hljs-string&quot;&gt;&quot;hi&quot;&lt;/span&gt;\n\n    f_one = &lt;span class=&quot;hljs-keyword&quot;&gt;lambda&lt;/span&gt;: i\n\n    i += &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;\n    f_two = &lt;span class=&quot;hljs-keyword&quot;&gt;lambda&lt;/span&gt;: i+&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;\n\n    f_three = &lt;span class=&quot;hljs-keyword&quot;&gt;lambda&lt;/span&gt;: my_str\n    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; f_one, f_two, f_three\n\nf_1, f_2, f_3 = make_funcs()\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;What is in a closure?&lt;/p&gt;\n\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;print&lt;/span&gt; f_1.func_closure, f_1.func_closure[&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;].cell_contents\n(&amp;lt;cell at &lt;span class=&quot;hljs-number&quot;&gt;0x106a99a28&lt;/span&gt;: &lt;span class=&quot;hljs-built_in&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-built_in&quot;&gt;object&lt;/span&gt; at &lt;span class=&quot;hljs-number&quot;&gt;0x7fbb20c11170&lt;/span&gt;&amp;gt;,) &lt;span class=&quot;hljs-number&quot;&gt;43&lt;/span&gt; \n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Notably, my_str is not in f1&apos;s closure.&lt;/p&gt;\n\n&lt;p&gt;What&apos;s in f2&apos;s closure?&lt;/p&gt;\n\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;print&lt;/span&gt; f_2.func_closure, f_2.func_closure[&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;].cell_contents\n(&amp;lt;cell at &lt;span class=&quot;hljs-number&quot;&gt;0x106a99a28&lt;/span&gt;: &lt;span class=&quot;hljs-built_in&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-built_in&quot;&gt;object&lt;/span&gt; at &lt;span class=&quot;hljs-number&quot;&gt;0x7fbb20c11170&lt;/span&gt;&amp;gt;,) &lt;span class=&quot;hljs-number&quot;&gt;43&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Notice (from the memory addresses) that both closures contain the same objects. So, you can &lt;em&gt;start&lt;/em&gt; to think of the lambda function as having a reference to the scope. However, my_str is not in the closure for f_1 or f_2, and i is not in the closure for f_3 (not shown), which suggests the closure objects themselves are distinct objects.&lt;/p&gt;\n\n&lt;p&gt;Are the closure objects themselves the same object?&lt;/p&gt;\n\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;print&lt;/span&gt; f_1.func_closure &lt;span class=&quot;hljs-keyword&quot;&gt;is&lt;/span&gt; f_2.func_closure\n&lt;span class=&quot;hljs-literal&quot;&gt;False&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n    ","\n&lt;p&gt;In answer to your second question, the most elegant way to do this would be to use a function that takes two parameters instead of an array:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;add = &lt;span class=&quot;hljs-keyword&quot;&gt;lambda&lt;/span&gt; a, b: a + b\nadd(&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;)\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;However, using lambda here is a bit silly. Python gives us the &lt;code&gt;operator&lt;/code&gt; module, which provides a functional interface to the basic operators. The lambda above has unnecessary overhead just to call the addition operator:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;from&lt;/span&gt; operator &lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; add\nadd(&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;)\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;I understand that you&apos;re playing around, trying to explore the language, but I can&apos;t imagine a situation I would use an array of functions where Python&apos;s scoping weirdness would get in the way.&lt;/p&gt;\n\n&lt;p&gt;If you wanted, you could write a small class that uses your array-indexing syntax:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;Adders&lt;/span&gt;(&lt;span class=&quot;hljs-title class_ inherited__&quot;&gt;object&lt;/span&gt;):\n    &lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;__getitem__&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;self, item&lt;/span&gt;):\n        &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;lambda&lt;/span&gt; a: a + item\n\nadders = Adders()\nadders[&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;](&lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;)\n&lt;/code&gt;&lt;/pre&gt;\n    ","\n&lt;p&gt;One way to sort out the scope of &lt;code&gt;i&lt;/code&gt; is to generate the lambda in another scope (a closure function), handing over the necessary parameters for it to make the lambda:&lt;/p&gt;\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;get_funky&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;i&lt;/span&gt;):\n    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;lambda&lt;/span&gt; a: i+a\n\nadders=[&lt;span class=&quot;hljs-literal&quot;&gt;None&lt;/span&gt;, &lt;span class=&quot;hljs-literal&quot;&gt;None&lt;/span&gt;, &lt;span class=&quot;hljs-literal&quot;&gt;None&lt;/span&gt;, &lt;span class=&quot;hljs-literal&quot;&gt;None&lt;/span&gt;]\n\n&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; i &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; [&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;]:\n   adders[i]=get_funky(i)\n\n&lt;span class=&quot;hljs-built_in&quot;&gt;print&lt;/span&gt;(*(ar(&lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt;) &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; ar &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; adders))\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;giving &lt;code&gt;5 6 7 8&lt;/code&gt; of course.&lt;/p&gt;\n    "],"id":489,"title":"What do lambda function closures capture? [duplicate]","content":"\n                    &lt;div&gt;\n            &lt;aside class=&quot;s-notice s-notice__info post-notice js-post-notice mb16&quot; role=&quot;status&quot;&gt;\n        &lt;div class=&quot;d-flex fd-column fw-nowrap&quot;&gt;\n            &lt;div class=&quot;d-flex fw-nowrap&quot;&gt;\n                &lt;div class=&quot;flex--item wmn0 fl1 lh-lg&quot;&gt;\n                    &lt;div class=&quot;flex--item fl1 lh-lg&quot;&gt;\n                        &lt;b&gt;This question already has answers here&lt;/b&gt;:\n                        \n                    &lt;/div&gt;\n                &lt;/div&gt;\n            &lt;/div&gt;\n                    &lt;div class=&quot;flex--item mb0 mt4&quot;&gt;\n                        &lt;a href=&quot;/questions/3431676/creating-functions-in-a-loop&quot; dir=&quot;ltr&quot;&gt;Creating functions in a loop&lt;/a&gt;\n                            &lt;span class=&quot;question-originals-answer-count&quot;&gt;\n                                (5 answers)\n                            &lt;/span&gt;\n                    &lt;/div&gt;\n                &lt;div class=&quot;flex--item mb0 mt8&quot;&gt;Closed &lt;span title=&quot;2022-07-03 04:31:24Z&quot; class=&quot;relativetime&quot;&gt;6 days ago&lt;/span&gt;.&lt;/div&gt;\n        &lt;/div&gt;\n&lt;/aside&gt;\n\n    &lt;/div&gt;\n\n&lt;p&gt;Recently I started playing around with Python and I came around something peculiar in the way closures work. Consider the following code:&lt;/p&gt;\n&lt;pre class=&quot;lang-py s-code-block&quot;&gt;&lt;code class=&quot;hljs language-python&quot;&gt;adders=[&lt;span class=&quot;hljs-literal&quot;&gt;None&lt;/span&gt;, &lt;span class=&quot;hljs-literal&quot;&gt;None&lt;/span&gt;, &lt;span class=&quot;hljs-literal&quot;&gt;None&lt;/span&gt;, &lt;span class=&quot;hljs-literal&quot;&gt;None&lt;/span&gt;]\n\n&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; i &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; [&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;]:\n   adders[i]=&lt;span class=&quot;hljs-keyword&quot;&gt;lambda&lt;/span&gt; a: i+a\n\n&lt;span class=&quot;hljs-built_in&quot;&gt;print&lt;/span&gt; adders[&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;](&lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;)\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;It builds a simple array of functions that take a single input and return that input added by a number. The functions are constructed in &lt;code&gt;for&lt;/code&gt; loop where the iterator &lt;code&gt;i&lt;/code&gt; runs from &lt;code&gt;0&lt;/code&gt; to &lt;code&gt;3&lt;/code&gt;. For each of these numbers a &lt;code&gt;lambda&lt;/code&gt; function is created which captures &lt;code&gt;i&lt;/code&gt; and adds it to the function&apos;s input. The last line calls the second &lt;code&gt;lambda&lt;/code&gt; function with &lt;code&gt;3&lt;/code&gt; as a parameter. To my surprise the output was &lt;code&gt;6&lt;/code&gt;.&lt;/p&gt;\n&lt;p&gt;I expected a &lt;code&gt;4&lt;/code&gt;. My reasoning was: in Python everything is an object and thus every variable is essential a pointer to it. When creating the &lt;code&gt;lambda&lt;/code&gt; closures for &lt;code&gt;i&lt;/code&gt;, I expected it to store a pointer to the integer object currently pointed to by &lt;code&gt;i&lt;/code&gt;. That means that when &lt;code&gt;i&lt;/code&gt; assigned a new integer object it shouldn&apos;t effect the previously created closures. Sadly, inspecting the &lt;code&gt;adders&lt;/code&gt; array within a debugger shows that it does. All &lt;code&gt;lambda&lt;/code&gt; functions refer to the last value of &lt;code&gt;i&lt;/code&gt;, &lt;code&gt;3&lt;/code&gt;, which results in &lt;code&gt;adders[1](3)&lt;/code&gt; returning &lt;code&gt;6&lt;/code&gt;.&lt;/p&gt;\n&lt;p&gt;Which make me wonder about the following:&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;What do the closures capture exactly?&lt;/li&gt;\n&lt;li&gt;What is the most elegant way to convince the &lt;code&gt;lambda&lt;/code&gt; functions to capture the current value of &lt;code&gt;i&lt;/code&gt; in a way that will not be affected when &lt;code&gt;i&lt;/code&gt; changes its value?&lt;/li&gt;\n&lt;/ul&gt;\n    ","slug":"what-do-lambda-function-closures-capture-duplicate-1657388161827","postType":"QUESTION","createdAt":"2022-07-09T17:36:01.000Z","updatedAt":"2022-07-09T17:36:01.000Z","tags":[],"relatedQuestions":[]},"randomQuestions":[{"title":"JavaScript closure inside loops â€“ simple practical example","slug":"javascript-closure-inside-loops-simple-practical-example-1657384278449"},{"title":"Can I mix MySQL APIs in PHP?","slug":"can-i-mix-mysql-apis-in-php-1657384597444"},{"title":"Convert form data to JavaScript object with jQuery","slug":"convert-form-data-to-javascript-object-with-jquery-1657388036834"},{"title":"Removing duplicates in lists","slug":"removing-duplicates-in-lists-1657388207448"},{"title":"Are dictionaries ordered in Python 3.6+?","slug":"are-dictionaries-ordered-in-python-3.6+-1657387834234"},{"title":"Make a div fill the height of the remaining screen space","slug":"make-a-div-fill-the-height-of-the-remaining-screen-space-1657387482387"},{"title":"Why are these numbers not equal?","slug":"why-are-these-numbers-not-equal-1657384729559"},{"title":"How to fix java.lang.UnsupportedClassVersionError: Unsupported major.minor version","slug":"how-to-fix-java.lang.unsupportedclassversionerror:-unsupported-major.minor-version-1657384863422"},{"title":"How to create RecyclerView with multiple view types","slug":"how-to-create-recyclerview-with-multiple-view-types-1657388121512"},{"title":"Returning data from async call in Swift function","slug":"returning-data-from-async-call-in-swift-function-1657387469218"},{"title":"How can I change an element's class with JavaScript?","slug":"how-can-i-change-an-element's-class-with-javascript-1657387694695"},{"title":"What is the best regular expression to check if a string is a valid URL?","slug":"what-is-the-best-regular-expression-to-check-if-a-string-is-a-valid-url-1657387618306"},{"title":"How to avoid having class data shared among instances?","slug":"how-to-avoid-having-class-data-shared-among-instances-1657387687732"},{"title":"How to make a div 100% height of the browser window","slug":"how-to-make-a-div-100percent-height-of-the-browser-window-1657388265955"},{"title":"How to join (merge) data frames (inner, outer, left, right)","slug":"how-to-join-(merge)-data-frames-(inner-outer-left-right)-1657384406445"},{"title":"Submit same Partial View called multiple times data to controller?","slug":"submit-same-partial-view-called-multiple-times-data-to-controller-1657387887213"},{"title":"What special characters must be escaped in regular expressions?","slug":"what-special-characters-must-be-escaped-in-regular-expressions-1657387465381"},{"title":"var functionName = function() {} vs function functionName() {}","slug":"var-functionname-function()-vs-function-functionname()-1657384724077"},{"title":"Short description of the scoping rules?","slug":"short-description-of-the-scoping-rules-1657384853121"},{"title":"How to check whether a string contains a substring in JavaScript?","slug":"how-to-check-whether-a-string-contains-a-substring-in-javascript-1657388080698"}]},"__N_SSG":true}