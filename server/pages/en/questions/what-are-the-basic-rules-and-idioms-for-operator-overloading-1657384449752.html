<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><meta name="twitter:card" content="summary_large_image"/><meta name="twitter:site" content="@solutionschecker.com"/><meta name="twitter:creator" content="@solutionschecker.com"/><meta property="og:url" content="https://solutionschecker.com"/><meta property="og:type" content="website"/><meta property="og:image" content="https://solutionschecker.com/solutions-checker-banner.png"/><meta property="og:image:alt" content="Find solution for coding, HTML, CSS, JAVASCRIPT, MYSQL, PHP, PYTHON,... quickly. - solutionschecker.com"/><script type="application/ld+json">{"@context":"https://schema.org","@type":"Organization","logo":"/logo.svg","url":"https://solutionschecker.com"}</script><title>What are the basic rules and idioms for operator overloading? | Solutions Checker</title><meta name="robots" content="index,follow"/><meta name="description" content="Note: The answers were given in a specific order, but since many users sort answers according to votes, rather than the time they were given, here&#x27;s an index of the answers in the order in which they make the most sense:

The General Syntax of operator overloading in C++
The Three Basic Rules of Operator Overloading in C++
The Decision between Member and Non-member
Common operators to overload

Assignment Operator
Input and Output Operators
Function call operator
Comparison operators
Arithmetic Operators
Array Subscripting
Operators for Pointer-like Types


Conversion Operators
Overloading new and delete

(Note: This is meant to be an entry to Stack Overflow&#x27;s C++ FAQ. If you want to critique the idea of providing an FAQ in this form, then the posting on meta that started all this would be the place to do that. Answers to that question are monitored in the C++ chatroom, where the FAQ idea started in the first place, so your answer is very likely to get read by those who came up with the idea.)

    "/><meta property="og:title" content="What are the basic rules and idioms for operator overloading? | Solutions Checker"/><meta property="og:description" content="Note: The answers were given in a specific order, but since many users sort answers according to votes, rather than the time they were given, here&#x27;s an index of the answers in the order in which they make the most sense:

The General Syntax of operator overloading in C++
The Three Basic Rules of Operator Overloading in C++
The Decision between Member and Non-member
Common operators to overload

Assignment Operator
Input and Output Operators
Function call operator
Comparison operators
Arithmetic Operators
Array Subscripting
Operators for Pointer-like Types


Conversion Operators
Overloading new and delete

(Note: This is meant to be an entry to Stack Overflow&#x27;s C++ FAQ. If you want to critique the idea of providing an FAQ in this form, then the posting on meta that started all this would be the place to do that. Answers to that question are monitored in the C++ chatroom, where the FAQ idea started in the first place, so your answer is very likely to get read by those who came up with the idea.)

    "/><script type="application/ld+json">{"@context":"https://schema.org","@type":"QAPage","mainEntity":{"name":"What are the basic rules and idioms for operator overloading?","text":"Note: The answers were given in a specific order, but since many users sort answers according to votes, rather than the time they were given, here&apos;s an index of the answers in the order in which they make the most sense:\n\nThe General Syntax of operator overloading in C++\nThe Three Basic Rules of Operator Overloading in C++\nThe Decision between Member and Non-member\nCommon operators to overload\n\nAssignment Operator\nInput and Output Operators\nFunction call operator\nComparison operators\nArithmetic Operators\nArray Subscripting\nOperators for Pointer-like Types\n\n\nConversion Operators\nOverloading new and delete\n\n(Note: This is meant to be an entry to Stack Overflow&apos;s C++ FAQ. If you want to critique the idea of providing an FAQ in this form, then the posting on meta that started all this would be the place to do that. Answers to that question are monitored in the C++ chatroom, where the FAQ idea started in the first place, so your answer is very likely to get read by those who came up with the idea.)\n\n    ","answerCount":8,"upVoteCount":500,"suggestedAnswer":[{"text":"Common operators to overload\n\nMost of the work in overloading operators is boiler-plate code. That is little wonder, since operators are merely syntactic sugar, their actual work could be done by (and often is forwarded to) plain functions. But it is important that you get this boiler-plate code right. If you fail, either your operators code wont compile or your users code wont compile or your users code will behave surprisingly.\n\nAssignment Operator\n\nThere&apos;s a lot to be said about assignment. However, most of it has already been said in GMan&apos;s famous Copy-And-Swap FAQ, so I&apos;ll skip most of it here, only listing the perfect assignment operator for reference:\n\nX&amp; X::operator=(X rhs)\n{\n  swap(rhs);\n  return *this;\n}\n\n\nBitshift Operators (used for Stream I/O)\n\nThe bitshift operators &lt;&lt; and &gt;&gt;, although still used in hardware interfacing for the bit-manipulation functions they inherit from C, have become more prevalent as overloaded stream input and output operators in most applications.  For guidance overloading as bit-manipulation operators, see the section below on Binary Arithmetic Operators.  For implementing your own custom format and parsing logic when your object is used with iostreams, continue.\n\nThe stream operators, among the most commonly overloaded operators, are binary infix operators for which the syntax specifies no restriction on whether they should be members or non-members.\nSince they change their left argument (they alter the streams state), they should, according to the rules of thumb, be implemented as members of their left operands type. However, their left operands are streams from the standard library, and while most of the stream output and input operators defined by the standard library are indeed defined as members of the stream classes, when you implement output and input operations for your own types, you cannot change the standard librarys stream types. Thats why you need to implement these operators for your own types as non-member functions.\nThe canonical forms of the two are these:\n\nstd::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const T&amp; obj)\n{\n  // write obj to stream\n\n  return os;\n}\n\nstd::istream&amp; operator&gt;&gt;(std::istream&amp; is, T&amp; obj)\n{\n  // read obj from stream\n\n  if( /* no valid object of T found in stream */ )\n    is.setstate(std::ios::failbit);\n\n  return is;\n}\n\n\nWhen implementing operator&gt;&gt;, manually setting the streams state is only necessary when the reading itself succeeded, but the result is not what would be expected.\n\nFunction call operator\n\nThe function call operator, used to create function objects, also known as functors, must be defined as a member function, so it always has the implicit this argument of member functions. Other than this, it can be overloaded to take any number of additional arguments, including zero.\n\nHere&apos;s an example of the syntax:\n\nclass foo {\npublic:\n    // Overloaded call operator\n    int operator()(const std::string&amp; y) {\n        // ...\n    }\n};\n\n\nUsage:\n\nfoo f;\nint a = f(&quot;hello&quot;);\n\n\nThroughout the C++ standard library, function objects are always copied. Your own function objects should therefore be cheap to copy. If a function object absolutely needs to use data which is expensive to copy, it is better to store that data elsewhere and have the function object refer to it.\n\nComparison operators\n\nThe binary infix comparison operators should, according to the rules of thumb, be implemented as non-member functions1. The unary prefix negation ! should (according to the same rules) be implemented as a member function. (but it is usually not a good idea to overload it.)\n\nThe standard librarys algorithms (e.g. std::sort()) and types (e.g. std::map) will always only expect operator&lt; to be present. However, the users of your type will expect all the other operators to be present, too, so if you define operator&lt;, be sure to follow the third fundamental rule of operator overloading and also define all the other boolean comparison operators. The canonical way to implement them is this:\n\ninline bool operator==(const X&amp; lhs, const X&amp; rhs){ /* do actual comparison */ }\ninline bool operator!=(const X&amp; lhs, const X&amp; rhs){return !operator==(lhs,rhs);}\ninline bool operator&lt; (const X&amp; lhs, const X&amp; rhs){ /* do actual comparison */ }\ninline bool operator&gt; (const X&amp; lhs, const X&amp; rhs){return  operator&lt; (rhs,lhs);}\ninline bool operator&lt;=(const X&amp; lhs, const X&amp; rhs){return !operator&gt; (lhs,rhs);}\ninline bool operator&gt;=(const X&amp; lhs, const X&amp; rhs){return !operator&lt; (lhs,rhs);}\n\n\nThe important thing to note here is that only two of these operators actually do anything, the others are just forwarding their arguments to either of these two to do the actual work.\n\nThe syntax for overloading the remaining binary boolean operators (||, &amp;&amp;) follows the rules of the comparison operators. However, it is very unlikely that you would find a reasonable use case for these2.\n\n1 As with all rules of thumb, sometimes there might be reasons to break this one, too. If so, do not forget that the left-hand operand of the binary comparison operators, which for member functions will be *this, needs to be const, too. So a comparison operator implemented as a member function would have to have this signature:\n\nbool operator&lt;(const X&amp; rhs) const { /* do actual comparison with *this */ }\n\n\n(Note the const at the end.)\n\n2 It should be noted that the built-in version of || and &amp;&amp; use shortcut semantics. While the user defined ones (because they are syntactic sugar for method calls) do not use shortcut semantics. User will expect these operators to have shortcut semantics, and their code may depend on it, Therefore it is highly advised NEVER to define them.\n\nArithmetic Operators\n\nUnary arithmetic operators\n\nThe unary increment and decrement operators come in both prefix and postfix flavor. To tell one from the other, the postfix variants take an additional dummy int argument. If you overload increment or decrement, be sure to always implement both prefix and postfix versions.\nHere is the canonical implementation of increment, decrement follows the same rules:\n\nclass X {\n  X&amp; operator++()\n  {\n    // do actual increment\n    return *this;\n  }\n  X operator++(int)\n  {\n    X tmp(*this);\n    operator++();\n    return tmp;\n  }\n};\n\n\nNote that the postfix variant is implemented in terms of prefix. Also note that postfix does an extra copy.2\n\nOverloading unary minus and plus is not very common and probably best avoided. If needed, they should probably be overloaded as member functions. \n\n2 Also note that the postfix variant does more work and is therefore less efficient to use than the prefix variant. This is a good reason to generally prefer prefix increment over postfix increment. While compilers can usually optimize away the additional work of postfix increment for built-in types, they might not be able to do the same for user-defined types (which could be something as innocently looking as a list iterator). Once you got used to do i++, it becomes very hard to remember to do ++i instead when i is not of a built-in type (plus you&apos;d have to change code when changing a type), so it is better to make a habit of always using prefix increment, unless postfix is explicitly needed.\n\nBinary arithmetic operators\n\nFor the binary arithmetic operators, do not forget to obey the third basic rule operator overloading: If you provide +, also provide +=, if you provide -, do not omit -=, etc. Andrew Koenig is said to have been the first to observe that the compound assignment operators can be used as a base for their non-compound counterparts. That is, operator + is implemented in terms of +=, - is implemented in terms of -= etc.\n\nAccording to our rules of thumb, + and its companions should be non-members, while their compound assignment counterparts (+= etc.), changing their left argument, should be a member. Here is the exemplary code for += and +; the other binary arithmetic operators should be implemented in the same way:\n\nclass X {\n  X&amp; operator+=(const X&amp; rhs)\n  {\n    // actual addition of rhs to *this\n    return *this;\n  }\n};\ninline X operator+(X lhs, const X&amp; rhs)\n{\n  lhs += rhs;\n  return lhs;\n}\n\n\noperator+= returns its result per reference, while operator+ returns a copy of its result. Of course, returning a reference is usually more efficient than returning a copy, but in the case of operator+, there is no way around the copying. When you write a + b, you expect the result to be a new value, which is why operator+ has to return a new value.3\nAlso note that operator+ takes its left operand by copy rather than by const reference. The reason for this is the same as the reason giving for operator= taking its argument per copy.\n\nThe bit manipulation operators ~ &amp; | ^ &lt;&lt; &gt;&gt; should be implemented in the same way as the arithmetic operators. However, (except for overloading &lt;&lt; and &gt;&gt; for output and input) there are very few reasonable use cases for overloading these.\n\n3 Again, the lesson to be taken from this is that a += b is, in general, more efficient than a + b and should be preferred if possible.\n\nArray Subscripting\n\nThe array subscript operator is a binary operator which must be implemented as a class member. It is used for container-like types that allow access to their data elements by a key.\nThe canonical form of providing these is this:\n\nclass X {\n        value_type&amp; operator[](index_type idx);\n  const value_type&amp; operator[](index_type idx) const;\n  // ...\n};\n\n\nUnless you do not want users of your class to be able to change data elements returned by operator[] (in which case you can omit the non-const variant), you should always provide both variants of the operator.\n\nIf value_type is known to refer to a built-in type, the const variant of the operator should better return a copy instead of a const reference:\n\nclass X {\n  value_type&amp; operator[](index_type idx);\n  value_type  operator[](index_type idx) const;\n  // ...\n};\n\n\nOperators for Pointer-like Types\n\nFor defining your own iterators or smart pointers, you have to overload the unary prefix dereference operator * and the binary infix pointer member access operator -&gt;:\n\nclass my_ptr {\n        value_type&amp; operator*();\n  const value_type&amp; operator*() const;\n        value_type* operator-&gt;();\n  const value_type* operator-&gt;() const;\n};\n\n\nNote that these, too, will almost always need both a const and a non-const version.\nFor the -&gt; operator, if value_type is of class (or struct or union) type, another operator-&gt;() is called recursively, until an operator-&gt;() returns a value of non-class type.\n\nThe unary address-of operator should never be overloaded.\n\nFor operator-&gt;*() see this question. It&apos;s rarely used and thus rarely ever overloaded. In fact, even iterators do not overload it.\n\n\n\nContinue to Conversion Operators\n    ","url":"/questions/[slug]#solution1","@type":"Answer","upvoteCount":0},{"text":"The Three Basic Rules of Operator Overloading in C++\nWhen it comes to operator overloading in C++, there are three basic rules you should follow. As with all such rules, there are indeed exceptions. Sometimes people have deviated from them and the outcome was not bad code, but such positive deviations are few and far between. At the very least, 99 out of 100 such deviations I have seen were unjustified. However, it might just as well have been 999 out of 1000. So youd better stick to the following rules.\n\nWhenever the meaning of an operator is not obviously clear and undisputed, it should not be overloaded. Instead, provide a function with a well-chosen name.\nBasically, the first and foremost rule for overloading operators, at its very heart, says: Dont do it. That might seem strange, because there is a lot to be known about operator overloading and so a lot of articles, book chapters, and other texts deal with all this. But despite this seemingly obvious evidence, there are only a surprisingly few cases where operator overloading is appropriate. The reason is that actually it is hard to understand the semantics behind the application of an operator unless the use of the operator in the application domain is well known and undisputed. Contrary to popular belief, this is hardly ever the case.\n\nAlways stick to the operators well-known semantics.\nC++ poses no limitations on the semantics of overloaded operators. Your compiler will happily accept code that implements the binary + operator to subtract from its right operand. However, the users of such an operator would never suspect the expression a + b to subtract a from b. Of course, this supposes that the semantics of the operator in the application domain is undisputed.\n\nAlways provide all out of a set of related operations.\nOperators are related to each other and to other operations. If your type supports a + b, users will expect to be able to call a += b, too. If it supports prefix increment ++a, they will expect a++ to work as well. If they can check whether a &lt; b, they will most certainly expect to also to be able to check whether a &gt; b. If they can copy-construct your type, they expect assignment to work as well.\n\n\n\nContinue to The Decision between Member and Non-member.\n    ","url":"/questions/[slug]#solution2","@type":"Answer","upvoteCount":0},{"text":"The Decision between Member and Non-member\nThe binary operators = (assignment), [] (array subscription), -&gt; (member access), as well as the n-ary () (function call) operator, must always be implemented as member functions, because the syntax of the language requires them to.\nOther operators can be implemented either as members or as non-members. Some of them, however, usually have to be implemented as non-member functions, because their left operand cannot be modified by you. The most prominent of these are the input and output operators &lt;&lt; and &gt;&gt;, whose left operands are stream classes from the standard library which you cannot change.\nFor all operators where you have to choose to either implement them as a member function or a non-member function, use the following rules of thumb to decide:\n\nIf it is a unary operator, implement it as a member function.\nIf a binary operator treats both operands equally (it leaves them unchanged), implement this operator as a non-member function.\nIf a binary operator does not treat both of its operands equally (usually it will change its left operand), it might be useful to make it a member function of its left operands type, if it has to access the operand&apos;s private parts.\n\nOf course, as with all rules of thumb, there are exceptions. If you have a type\nenum Month {Jan, Feb, ..., Nov, Dec}\n\nand you want to overload the increment and decrement operators for it, you cannot do this as a member functions, since in C++, enum types cannot have member functions. So you have to overload it as a free function. And operator&lt;() for a class template nested within a class template is much easier to write and read when done as a member function inline in the class definition. But these are indeed rare exceptions.\n(However, if you make an exception, do not forget the issue of const-ness for the operand that, for member functions, becomes the implicit this argument. If the operator as a non-member function would take its left-most argument as a const reference, the same operator as a member function needs to have a const at the end to make *this a const reference.)\n\nContinue to Common operators to overload.\n    ","url":"/questions/[slug]#solution3","@type":"Answer","upvoteCount":0},{"text":"The General Syntax of operator overloading in C++\nYou cannot change the meaning of operators for built-in types in C++, operators can only be overloaded for user-defined types1. That is, at least one of the operands has to be of a user-defined type. As with other overloaded functions, operators can be overloaded for a certain set of parameters only once.\nNot all operators can be overloaded in C++. Among the operators that cannot be overloaded are: . :: sizeof typeid .* and the only ternary operator in C++, ?:\nAmong the operators that can be overloaded in C++ are these:\n\narithmetic operators: + - * / % and += -= *= /= %= (all binary infix); + - (unary prefix); ++ -- (unary prefix and postfix)\nbit manipulation: &amp; | ^ &lt;&lt; &gt;&gt; and &amp;= |= ^= &lt;&lt;= &gt;&gt;= (all binary infix); ~ (unary prefix)\nboolean algebra: == != &lt; &gt; &lt;= &gt;= || &amp;&amp; (all binary infix); ! (unary prefix)\nmemory management: new new[] delete delete[]\nimplicit conversion operators\nmiscellany: = [] -&gt; -&gt;* ,  (all binary infix); * &amp; (all unary prefix) () (function call, n-ary infix)\n\nHowever, the fact that you can overload all of these does not mean you should do so. See the basic rules of operator overloading.\nIn C++, operators are overloaded in the form of functions with special names. As with other functions, overloaded operators can generally be implemented either as a member function of their left operand&apos;s type or as non-member functions. Whether you are free to choose or bound to use either one depends on several criteria.2 A unary operator @3, applied to an object x, is invoked either as operator@(x) or as x.operator@(). A binary infix operator @, applied to the objects x and y, is called either as operator@(x,y) or as x.operator@(y).4\nOperators that are implemented as non-member functions are sometimes friend of their operands type.\n1 The term user-defined might be slightly misleading. C++ makes the distinction between built-in types and user-defined types. To the former belong for example int, char, and double; to the latter belong all struct, class, union, and enum types, including those from the standard library, even though they are not, as such, defined by users.\n2 This is covered in a later part of this FAQ.\n3 The @ is not a valid operator in C++ which is why I use it as a placeholder.\n4 The only ternary operator in C++ cannot be overloaded and the only n-ary operator must always be implemented as a member function.\n\nContinue to The Three Basic Rules of Operator Overloading in C++.\n    ","url":"/questions/[slug]#solution4","@type":"Answer","upvoteCount":0},{"text":"Conversion Operators (also known as User Defined Conversions)\n\nIn C++ you can create conversion operators, operators that allow the compiler to convert between your types and other defined types.  There are two types of conversion operators, implicit and explicit ones.\n\nImplicit Conversion Operators (C++98/C++03 and C++11)\n\nAn implicit conversion operator allows the compiler to implicitly convert (like the conversion between int and long) the value of a user-defined type to some other type.\n\nThe following is a simple class with an implicit conversion operator:\n\nclass my_string {\npublic:\n  operator const char*() const {return data_;} // This is the conversion operator\nprivate:\n  const char* data_;\n};\n\n\nImplicit conversion operators, like one-argument constructors, are user-defined conversions. Compilers will grant one user-defined conversion when trying to match a call to an overloaded function.\n\nvoid f(const char*);\n\nmy_string str;\nf(str); // same as f( str.operator const char*() )\n\n\nAt first this seems very helpful, but the problem with this is that the implicit conversion even kicks in when it isnt expected to. In the following code, void f(const char*) will be called because my_string() is not an lvalue, so the first does not match:\n\nvoid f(my_string&amp;);\nvoid f(const char*);\n\nf(my_string());\n\n\nBeginners easily get this wrong and even experienced C++ programmers are sometimes surprised because the compiler picks an overload they didnt suspect.  These problems can be mitigated by explicit conversion operators.\n\nExplicit Conversion Operators (C++11)\n\nUnlike implicit conversion operators, explicit conversion operators will never kick in when you don&apos;t expect them to.  The following is a simple class with an explicit conversion operator:\n\nclass my_string {\npublic:\n  explicit operator const char*() const {return data_;}\nprivate:\n  const char* data_;\n};\n\n\nNotice the explicit.  Now when you try to execute the unexpected code from the implicit conversion operators, you get a compiler error:\n\nprog.cpp: In function int main():\nprog.cpp:15:18: error: no matching function for call to f(my_string)\nprog.cpp:15:18: note: candidates are:\nprog.cpp:11:10: note: void f(my_string&amp;)\nprog.cpp:11:10: note:   no known conversion for argument 1 from my_string to my_string&amp;\nprog.cpp:12:10: note: void f(const char*)\nprog.cpp:12:10: note:   no known conversion for argument 1 from my_string to const char*\n\n\nTo invoke the explicit cast operator, you have to use static_cast, a C-style cast, or a constructor style cast ( i.e. T(value) ).  \n\nHowever, there is one exception to this:  The compiler is allowed to implicitly convert to bool.  In addition, the compiler is not allowed to do another implicit conversion after it converts to bool (a compiler is allowed to do 2 implicit conversions at a time, but only 1 user-defined conversion at max).  \n\nBecause the compiler will not cast &quot;past&quot; bool, explicit conversion operators now remove the need for the Safe Bool idiom.   For example, smart pointers before C++11 used the Safe Bool idiom to prevent conversions to integral types.  In C++11, the smart pointers use an explicit operator instead because the compiler is not allowed to implicitly convert to an integral type after it explicitly converted a type to bool.\n\nContinue to Overloading new and delete.\n    ","url":"/questions/[slug]#solution5","@type":"Answer","upvoteCount":0},{"text":"Overloading new and delete operators\nNote: This only deals with the syntax of overloading new and delete, not with the implementation of such overloaded operators. I think that the semantics of overloading new and delete deserve their own FAQ, within the topic of operator overloading I can never do it justice.\nBasics\nIn C++, when you write a new expression like new T(arg) two things happen when this expression is evaluated: First operator new is invoked to obtain raw memory, and then the appropriate constructor of T is invoked to turn this raw memory into a valid object. Likewise, when you delete an object, first its destructor is called, and then the memory is returned to operator delete.\nC++ allows you to tune both of these operations: memory management and the construction/destruction of the object at the allocated memory. The latter is done by writing constructors and destructors for a class. Fine-tuning memory management is done by writing your own operator new and operator delete.\nThe first of the basic rules of operator overloading  dont do it  applies especially to overloading new and delete. Almost the only reasons to overload these operators are performance problems and memory constraints, and in many cases, other actions, like changes to the algorithms used, will provide a much higher cost/gain ratio than attempting to tweak memory management.\nThe C++ standard library comes with a set of predefined new and delete operators. The most important ones are these:\nvoid* operator new(std::size_t) throw(std::bad_alloc); \nvoid  operator delete(void*) throw(); \nvoid* operator new[](std::size_t) throw(std::bad_alloc); \nvoid  operator delete[](void*) throw(); \n\nThe first two allocate/deallocate memory for an object, the latter two for an array of objects. If you provide your own versions of these, they will not overload, but replace the ones from the standard library.\nIf you overload operator new, you should always also overload the matching operator delete, even if you never intend to call it. The reason is that, if a constructor throws during the evaluation of a new expression, the run-time system will return the memory to the operator delete matching the operator new that was called to allocate the memory to create the object in. If you do not provide a matching operator delete, the default one is called, which is almost always wrong.\nIf you overload new and delete, you should consider overloading the array variants, too.\nPlacement new\nC++ allows new and delete operators to take additional arguments.\nSo-called placement new allows you to create an object at a certain address which is passed to:\nclass X { /* ... */ };\nchar buffer[ sizeof(X) ];\nvoid f()\n{ \n  X* p = new(buffer) X(/*...*/);\n  // ... \n  p-&gt;~X(); // call destructor \n} \n\nThe standard library comes with the appropriate overloads of the new and delete operators for this:\nvoid* operator new(std::size_t,void* p) throw(std::bad_alloc); \nvoid  operator delete(void* p,void*) throw(); \nvoid* operator new[](std::size_t,void* p) throw(std::bad_alloc); \nvoid  operator delete[](void* p,void*) throw(); \n\nNote that, in the example code for placement new given above, operator delete is never called, unless the constructor of X throws an exception.\nYou can also overload new and delete with other arguments. As with the additional argument for placement new, these arguments are also listed within parentheses after the keyword new. Merely for historical reasons, such variants are often also called placement new, even if their arguments are not for placing an object at a specific address.\nClass-specific new and delete\nMost commonly you will want to fine-tune memory management because measurement has shown that instances of a specific class, or of a group of related classes, are created and destroyed often and that the default memory management of the run-time system, tuned for general performance, deals inefficiently in this specific case. To improve this, you can overload new and delete for a specific class:\nclass my_class { \n  public: \n    // ... \n    void* operator new(std::size_t);\n    void  operator delete(void*);\n    void* operator new[](std::size_t);\n    void  operator delete[](void*);\n    // ...  \n}; \n\nOverloaded thus, new and delete behave like static member functions. For objects of my_class, the std::size_t argument will always be sizeof(my_class). However, these operators are also called for dynamically allocated objects of derived classes, in which case it might be greater than that.\nGlobal new and delete\nTo overload the global new and delete, simply replace the pre-defined operators of the standard library with our own. However, this rarely ever needs to be done.\n    ","url":"/questions/[slug]#solution6","@type":"Answer","upvoteCount":0},{"text":"Why can&apos;t operator&lt;&lt; function for streaming objects to std::cout or to a file be a member function?\n\nLet&apos;s say you have:\n\nstruct Foo\n{\n   int a;\n   double b;\n\n   std::ostream&amp; operator&lt;&lt;(std::ostream&amp; out) const\n   {\n      return out &lt;&lt; a &lt;&lt; &quot; &quot; &lt;&lt; b;\n   }\n};\n\n\nGiven that, you cannot use:\n\nFoo f = {10, 20.0};\nstd::cout &lt;&lt; f;\n\n\nSince operator&lt;&lt; is overloaded as a member function of Foo, the LHS of the operator must be a Foo object. Which means, you will be required to use:\n\nFoo f = {10, 20.0};\nf &lt;&lt; std::cout\n\n\nwhich is very non-intuitive.\n\nIf you define it as a non-member function,\n\nstruct Foo\n{\n   int a;\n   double b;\n};\n\nstd::ostream&amp; operator&lt;&lt;(std::ostream&amp; out, Foo const&amp; f)\n{\n   return out &lt;&lt; f.a &lt;&lt; &quot; &quot; &lt;&lt; f.b;\n}\n\n\nYou will be able to use:\n\nFoo f = {10, 20.0};\nstd::cout &lt;&lt; f;\n\n\nwhich is very intuitive.\n    ","url":"/questions/[slug]#solution7","@type":"Answer","upvoteCount":0},{"text":"Making it short and simple, I&apos;ll be referring to some points, which I had come over the past week as I was learning Python and C++, oops and other things, so it goes as follows:\n\nThe Arity of the operator can not be modified further than to what it is!\n\nOverloaded operators can only have one default argument which the function call operator rest it cannot.\n\nOnly built in operator can be overloaded, rest can&apos;t!\n\n\nFor more info, you can refer to the following link, which redirects you to the documentation provided by GeekforGeeks.\nhttps://www.geeksforgeeks.org/g-fact-39/\n    ","url":"/questions/[slug]#solution8","@type":"Answer","upvoteCount":0}],"@type":"Question"}}</script><meta name="next-head-count" content="16"/><link rel="preload" href="/_next/static/css/08bcc42a26fe5c92.css" as="style"/><link rel="stylesheet" href="/_next/static/css/08bcc42a26fe5c92.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-0d1b80a048d4787e.js"></script><script src="/_next/static/chunks/webpack-42cdea76c8170223.js" defer=""></script><script src="/_next/static/chunks/framework-4556c45dd113b893.js" defer=""></script><script src="/_next/static/chunks/main-ccfab947c79712f4.js" defer=""></script><script src="/_next/static/chunks/pages/_app-08d1a634dea6705e.js" defer=""></script><script src="/_next/static/chunks/29107295-fbcfe2172188e46f.js" defer=""></script><script src="/_next/static/chunks/150-b06815e21c943e0d.js" defer=""></script><script src="/_next/static/chunks/490-7f0418bb4354ac73.js" defer=""></script><script src="/_next/static/chunks/108-87de33c23337ff53.js" defer=""></script><script src="/_next/static/chunks/pages/questions/%5Bslug%5D-79a1437acf654019.js" defer=""></script><script src="/_next/static/6ctJfCympFH_chh5mjicD/_buildManifest.js" defer=""></script><script src="/_next/static/6ctJfCympFH_chh5mjicD/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="wrapper"><header><nav class="bg-white border-gray-200 px-4 lg:px-6 py-2.5 dark:bg-gray-800"><div class="flex flex-wrap justify-between items-center mx-auto max-w-screen-xl"><a class="flex items-center" href="/"><img src="/logo-second.png" class="mr-3 h-6 sm:h-9" alt="Solution Checker Logo"/><h4 class="self-center text-xl font-semibold whitespace-nowrap dark:text-white">Solution Checker</h4></a><div class="flex items-center lg:order-2"><button data-collapse-toggle="mobile-menu-2" type="button" class="inline-flex items-center p-2 ml-1 text-sm text-gray-500 rounded-lg lg:hidden hover:bg-gray-100 focus:outline-none focus:ring-2 focus:ring-gray-200 dark:text-gray-400 dark:hover:bg-gray-700 dark:focus:ring-gray-600" aria-controls="mobile-menu-2" aria-expanded="false"><span class="sr-only">Open main menu</span><svg class="w-6 h-6" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M3 5a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM3 10a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM3 15a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1z" clip-rule="evenodd"></path></svg><svg class="hidden w-6 h-6" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z" clip-rule="evenodd"></path></svg></button></div><div class="hidden justify-between items-center w-full lg:flex lg:w-auto lg:order-1" id="mobile-menu-2"><ul class="flex flex-col mt-4 font-medium lg:flex-row lg:space-x-8 lg:mt-0"><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" aria-current="page" href="/">Home</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/questions?tab=news">Questions</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/post?tab=news">Post</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/questions/what-are-the-basic-rules-and-idioms-for-operator-overloading-1657384449752#">Coding</a></li></ul></div></div></nav></header><div class="main-content"><div class="question my-5"><div class="flex question-header items-center m-auto justify-center"><div class="rounded-xl w-full border p-5 shadow-md bg-white"><div class="flex w-full items-center justify-between border-b pb-3"><div class="flex items-center space-x-3"><div class="text-lg font-bold text-slate-700"><a href="/questions/what-are-the-basic-rules-and-idioms-for-operator-overloading-1657384449752"><h1>What are the basic rules and idioms for operator overloading?</h1></a></div></div><div class="flex flex-wrap h-auto justify-end items-center space-x-8"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold" href="/questions/tag/operators">operators</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold" href="/questions/tag/operator-overloading">operator-overloading</a></div></div><div class="question-content mt-5">
                
<p>Note: The answers were given in <em>a specific order</em>, but since many users sort answers according to votes, rather than the time they were given, here's an <em><strong>index of the answers</strong></em> in the order in which they make the most sense:</p>
<ul>
<li><a href="https://stackoverflow.com/questions/4421706/operator-overloading-in-c/4421715#4421715">The General Syntax of operator overloading in C++</a></li>
<li><a href="https://stackoverflow.com/questions/4421706/operator-overloading-in-c/4421708#4421708">The Three Basic Rules of Operator Overloading in C++</a></li>
<li><a href="https://stackoverflow.com/questions/4421706/operator-overloading-in-c/4421729#4421729">The Decision between Member and Non-member</a></li>
<li><a href="https://stackoverflow.com/questions/4421706/operator-overloading-in-c/4421719#4421719">Common operators to overload</a>
<ul>
<li>Assignment Operator</li>
<li>Input and Output Operators</li>
<li>Function call operator</li>
<li>Comparison operators</li>
<li>Arithmetic Operators</li>
<li>Array Subscripting</li>
<li>Operators for Pointer-like Types</li>
</ul>
</li>
<li><a href="https://stackoverflow.com/questions/4421706/operator-overloading/16615725#16615725">Conversion Operators</a></li>
<li><a href="https://stackoverflow.com/questions/4421706/operator-overloading-in-c/4421791#4421791">Overloading new and delete</a></li>
</ul>
<p><sub><em>(Note: This is meant to be an entry to <a href="https://stackoverflow.com/questions/tagged/c++-faq">Stack Overflow's C++ FAQ</a>. If you want to critique the idea of providing an FAQ in this form, then <a href="https://meta.stackexchange.com/questions/68647/setting-up-a-faq-for-the-c-tag">the posting on meta that started all this</a> would be the place to do that. Answers to that question are monitored in the <a href="https://chat.stackoverflow.com/rooms/10/c-lounge">C++ chatroom</a>, where the FAQ idea started in the first place, so your answer is very likely to get read by those who came up with the idea.)</em>
</sub></p>
    </div></div></div><div class="solution-section"><nav class="flex pagination-solution flex-col justify-end"><ul class="inline-flex -space-x-px overflow-auto"><li class="pagination-solution-item"><span data-id="#solution1" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">1</span></li><li class="pagination-solution-item"><span data-id="#solution2" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">2</span></li><li class="pagination-solution-item"><span data-id="#solution3" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">3</span></li><li class="pagination-solution-item"><span data-id="#solution4" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">4</span></li><li class="pagination-solution-item"><span data-id="#solution5" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">5</span></li><li class="pagination-solution-item"><span data-id="#solution6" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">6</span></li><li class="pagination-solution-item"><span data-id="#solution7" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">7</span></li><li class="pagination-solution-item"><span data-id="#solution8" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">8</span></li></ul></nav><div id="solution1" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 1</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/operators">operators</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/operator-overloading">operator-overloading</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<h1>Common operators to overload</h1>

<p>Most of the work in overloading operators is boiler-plate code. That is little wonder, since operators are merely syntactic sugar, their actual work could be done by (and often is forwarded to) plain functions. But it is important that you get this boiler-plate code right. If you fail, either your operators code wont compile or your users code wont compile or your users code will behave surprisingly.</p>

<h2>Assignment Operator</h2>

<p>There's a lot to be said about assignment. However, most of it has already been said in <a href="https://stackoverflow.com/questions/3279543/what-is-the-copy-and-swap-idiom">GMan's famous Copy-And-Swap FAQ</a>, so I'll skip most of it here, only listing the perfect assignment operator for reference:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp">X&amp; X::<span class="hljs-keyword">operator</span>=(X rhs)
{
  <span class="hljs-built_in">swap</span>(rhs);
  <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;
}
</code></pre>

<h2>Bitshift Operators (used for Stream I/O)</h2>

<p>The bitshift operators <code>&lt;&lt;</code> and <code>&gt;&gt;</code>, although still used in hardware interfacing for the bit-manipulation functions they inherit from C, have become more prevalent as overloaded stream input and output operators in most applications.  For guidance overloading as bit-manipulation operators, see the section below on Binary Arithmetic Operators.  For implementing your own custom format and parsing logic when your object is used with iostreams, continue.</p>

<p>The stream operators, among the most commonly overloaded operators, are binary infix operators for which the syntax specifies no restriction on whether they should be members or non-members.
Since they change their left argument (they alter the streams state), they should, according to the rules of thumb, be implemented as members of their left operands type. However, their left operands are streams from the standard library, and while most of the stream output and input operators defined by the standard library are indeed defined as members of the stream classes, when you implement output and input operations for your own types, you cannot change the standard librarys stream types. Thats why you need to implement these operators for your own types as non-member functions.
The canonical forms of the two are these:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp">std::ostream&amp; <span class="hljs-keyword">operator</span>&lt;&lt;(std::ostream&amp; os, <span class="hljs-type">const</span> T&amp; obj)
{
  <span class="hljs-comment">// write obj to stream</span>

  <span class="hljs-keyword">return</span> os;
}

std::istream&amp; <span class="hljs-keyword">operator</span>&gt;&gt;(std::istream&amp; is, T&amp; obj)
{
  <span class="hljs-comment">// read obj from stream</span>

  <span class="hljs-keyword">if</span>( <span class="hljs-comment">/* no valid object of T found in stream */</span> )
    is.<span class="hljs-built_in">setstate</span>(std::ios::failbit);

  <span class="hljs-keyword">return</span> is;
}
</code></pre>

<p>When implementing <code>operator&gt;&gt;</code>, manually setting the streams state is only necessary when the reading itself succeeded, but the result is not what would be expected.</p>

<h2>Function call operator</h2>

<p>The function call operator, used to create function objects, also known as functors, must be defined as a <strong><em>member</em></strong> function, so it always has the implicit <code>this</code> argument of member functions. Other than this, it can be overloaded to take any number of additional arguments, including zero.</p>

<p>Here's an example of the syntax:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">foo</span> {
<span class="hljs-keyword">public</span>:
    <span class="hljs-comment">// Overloaded call operator</span>
    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; y)</span> </span>{
        <span class="hljs-comment">// ...</span>
    }
};
</code></pre>

<p>Usage:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp">foo f;
<span class="hljs-type">int</span> a = <span class="hljs-built_in">f</span>(<span class="hljs-string">"hello"</span>);
</code></pre>

<p>Throughout the C++ standard library, function objects are always copied. Your own function objects should therefore be cheap to copy. If a function object absolutely needs to use data which is expensive to copy, it is better to store that data elsewhere and have the function object refer to it.</p>

<h2>Comparison operators</h2>

<p>The binary infix comparison operators should, according to the rules of thumb, be implemented as non-member functions<sup>1</sup>. The unary prefix negation <code>!</code> should (according to the same rules) be implemented as a member function. (but it is usually not a good idea to overload it.)</p>

<p>The standard librarys algorithms (e.g. <code>std::sort()</code>) and types (e.g. <code>std::map</code>) will always only expect <code>operator&lt;</code> to be present. However, the <em>users of your type will expect all the other operators to be present</em>, too, so if you define <code>operator&lt;</code>, be sure to follow the third fundamental rule of operator overloading and also define all the other boolean comparison operators. The canonical way to implement them is this:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-keyword">inline</span> <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>==(<span class="hljs-type">const</span> X&amp; lhs, <span class="hljs-type">const</span> X&amp; rhs){ <span class="hljs-comment">/* do actual comparison */</span> }
<span class="hljs-keyword">inline</span> <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>!=(<span class="hljs-type">const</span> X&amp; lhs, <span class="hljs-type">const</span> X&amp; rhs){<span class="hljs-keyword">return</span> !<span class="hljs-keyword">operator</span>==(lhs,rhs);}
<span class="hljs-keyword">inline</span> <span class="hljs-type">bool</span> <span class="hljs-built_in">operator</span>&lt; (<span class="hljs-type">const</span> X&amp; lhs, <span class="hljs-type">const</span> X&amp; rhs){ <span class="hljs-comment">/* do actual comparison */</span> }
<span class="hljs-keyword">inline</span> <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&gt; (<span class="hljs-type">const</span> X&amp; lhs, <span class="hljs-type">const</span> X&amp; rhs){<span class="hljs-keyword">return</span>  <span class="hljs-keyword">operator</span>&lt; (rhs,lhs);}
<span class="hljs-keyword">inline</span> <span class="hljs-type">bool</span> <span class="hljs-built_in">operator</span>&lt;=(<span class="hljs-type">const</span> X&amp; lhs, <span class="hljs-type">const</span> X&amp; rhs){<span class="hljs-keyword">return</span> !<span class="hljs-keyword">operator</span>&gt; (lhs,rhs);}
<span class="hljs-keyword">inline</span> <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&gt;=(<span class="hljs-type">const</span> X&amp; lhs, <span class="hljs-type">const</span> X&amp; rhs){<span class="hljs-keyword">return</span> !<span class="hljs-keyword">operator</span>&lt; (lhs,rhs);}
</code></pre>

<p>The important thing to note here is that only two of these operators actually do anything, the others are just forwarding their arguments to either of these two to do the actual work.</p>

<p>The syntax for overloading the remaining binary boolean operators (<code>||</code>, <code>&amp;&amp;</code>) follows the rules of the comparison operators. However, it is <em>very</em> unlikely that you would find a reasonable use case for these<sup>2</sup>.</p>

<p><sup>1</sup> <sub>As with all rules of thumb, sometimes there might be reasons to break this one, too. If so, do not forget that the left-hand operand of the binary comparison operators, which for member functions will be <code>*this</code>, needs to be <code>const</code>, too. So a comparison operator implemented as a member function would have to have this signature:</sub></p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&lt;(<span class="hljs-type">const</span> X&amp; rhs) <span class="hljs-type">const</span> { <span class="hljs-comment">/* do actual comparison with *this */</span> }
</code></pre>

<p><sub>(Note the <code>const</code> at the end.)</sub></p>

<p><sup>2</sup> <sub>It should be noted that the built-in version of <code>||</code> and <code>&amp;&amp;</code> use shortcut semantics. While the user defined ones (because they are syntactic sugar for method calls) do not use shortcut semantics. User will expect these operators to have shortcut semantics, and their code may depend on it, Therefore it is highly advised NEVER to define them.</sub></p>

<h2>Arithmetic Operators</h2>

<h3>Unary arithmetic operators</h3>

<p>The unary increment and decrement operators come in both prefix and postfix flavor. To tell one from the other, the postfix variants take an additional dummy int argument. If you overload increment or decrement, be sure to always implement both prefix and postfix versions.
Here is the canonical implementation of increment, decrement follows the same rules:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">X</span> {
  X&amp; <span class="hljs-keyword">operator</span>++()
  {
    <span class="hljs-comment">// do actual increment</span>
    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;
  }
  X <span class="hljs-keyword">operator</span>++(<span class="hljs-type">int</span>)
  {
    <span class="hljs-function">X <span class="hljs-title">tmp</span><span class="hljs-params">(*<span class="hljs-keyword">this</span>)</span></span>;
    <span class="hljs-keyword">operator</span>++();
    <span class="hljs-keyword">return</span> tmp;
  }
};
</code></pre>

<p>Note that the postfix variant is implemented in terms of prefix. Also note that postfix does an extra copy.<sup>2</sup></p>

<p>Overloading unary minus and plus is not very common and probably best avoided. If needed, they should probably be overloaded as member functions. </p>

<p><sup>2</sup> <sub>Also note that the postfix variant does more work and is therefore less efficient to use than the prefix variant. This is a good reason to generally prefer prefix increment over postfix increment. While compilers can usually optimize away the additional work of postfix increment for built-in types, they might not be able to do the same for user-defined types (which could be something as innocently looking as a list iterator). Once you got used to do <code>i++</code>, it becomes very hard to remember to do <code>++i</code> instead when <code>i</code> is not of a built-in type (plus you'd have to change code when changing a type), so it is better to make a habit of always using prefix increment, unless postfix is explicitly needed.</sub></p>

<h3>Binary arithmetic operators</h3>

<p>For the binary arithmetic operators, do not forget to obey the third basic rule operator overloading: If you provide <code>+</code>, also provide <code>+=</code>, if you provide <code>-</code>, do not omit <code>-=</code>, etc. Andrew Koenig is said to have been the first to observe that the compound assignment operators can be used as a base for their non-compound counterparts. That is, operator <code>+</code> is implemented in terms of <code>+=</code>, <code>-</code> is implemented in terms of <code>-=</code> etc.</p>

<p>According to our rules of thumb, <code>+</code> and its companions should be non-members, while their compound assignment counterparts (<code>+=</code> etc.), changing their left argument, should be a member. Here is the exemplary code for <code>+=</code> and <code>+</code>; the other binary arithmetic operators should be implemented in the same way:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">X</span> {
  X&amp; <span class="hljs-keyword">operator</span>+=(<span class="hljs-type">const</span> X&amp; rhs)
  {
    <span class="hljs-comment">// actual addition of rhs to *this</span>
    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;
  }
};
<span class="hljs-keyword">inline</span> X <span class="hljs-keyword">operator</span>+(X lhs, <span class="hljs-type">const</span> X&amp; rhs)
{
  lhs += rhs;
  <span class="hljs-keyword">return</span> lhs;
}
</code></pre>

<p><code>operator+=</code> returns its result per reference, while <code>operator+</code> returns a copy of its result. Of course, returning a reference is usually more efficient than returning a copy, but in the case of <code>operator+</code>, there is no way around the copying. When you write <code>a + b</code>, you expect the result to be a new value, which is why <code>operator+</code> has to return a new value.<sup>3</sup>
Also note that <code>operator+</code> takes its left operand <strong><em>by copy</em></strong> rather than by const reference. The reason for this is the same as the reason giving for <code>operator=</code> taking its argument per copy.</p>

<p>The bit manipulation operators <code>~</code> <code>&amp;</code> <code>|</code> <code>^</code> <code>&lt;&lt;</code> <code>&gt;&gt;</code> should be implemented in the same way as the arithmetic operators. However, (except for overloading <code>&lt;&lt;</code> and <code>&gt;&gt;</code> for output and input) there are very few reasonable use cases for overloading these.</p>

<p><sup>3</sup> <sub>Again, the lesson to be taken from this is that <code>a += b</code> is, in general, more efficient than <code>a + b</code> and should be preferred if possible.</sub></p>

<h2>Array Subscripting</h2>

<p>The array subscript operator is a binary operator which must be implemented as a class member. It is used for container-like types that allow access to their data elements by a key.
The canonical form of providing these is this:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">X</span> {
        value_type&amp; <span class="hljs-keyword">operator</span>[](index_type idx);
  <span class="hljs-type">const</span> value_type&amp; <span class="hljs-keyword">operator</span>[](index_type idx) <span class="hljs-type">const</span>;
  <span class="hljs-comment">// ...</span>
};
</code></pre>

<p>Unless you do not want users of your class to be able to change data elements returned by <code>operator[]</code> (in which case you can omit the non-const variant), you should always provide both variants of the operator.</p>

<p>If value_type is known to refer to a built-in type, the const variant of the operator should better return a copy instead of a const reference:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">X</span> {
  value_type&amp; <span class="hljs-keyword">operator</span>[](index_type idx);
  value_type  <span class="hljs-keyword">operator</span>[](index_type idx) <span class="hljs-type">const</span>;
  <span class="hljs-comment">// ...</span>
};
</code></pre>

<h2>Operators for Pointer-like Types</h2>

<p>For defining your own iterators or smart pointers, you have to overload the unary prefix dereference operator <code>*</code> and the binary infix pointer member access operator <code>-&gt;</code>:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">my_ptr</span> {
        value_type&amp; <span class="hljs-keyword">operator</span>*();
  <span class="hljs-type">const</span> value_type&amp; <span class="hljs-keyword">operator</span>*() <span class="hljs-type">const</span>;
        value_type* <span class="hljs-keyword">operator</span>-&gt;();
  <span class="hljs-type">const</span> value_type* <span class="hljs-keyword">operator</span>-&gt;() <span class="hljs-type">const</span>;
};
</code></pre>

<p>Note that these, too, will almost always need both a const and a non-const version.
For the <code>-&gt;</code> operator, if <code>value_type</code> is of <code>class</code> (or <code>struct</code> or <code>union</code>) type, another <code>operator-&gt;()</code> is called recursively, until an <code>operator-&gt;()</code> returns a value of non-class type.</p>

<p>The unary address-of operator should never be overloaded.</p>

<p>For <code>operator-&gt;*()</code> see <a href="https://stackoverflow.com/q/8777845/140719">this question</a>. It's rarely used and thus rarely ever overloaded. In fact, even iterators do not overload it.</p>

<hr>

<p>Continue to <a href="https://stackoverflow.com/questions/4421706/operator-overloading/16615725#16615725">Conversion Operators</a></p>
    </div></div></div></div><div id="solution2" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 2</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/operators">operators</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/operator-overloading">operator-overloading</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<h1>The Three Basic Rules of Operator Overloading in C++</h1>
<p>When it comes to operator overloading in C++, there are <em><strong>three basic rules you should follow</strong></em>. As with all such rules, there are indeed exceptions. Sometimes people have deviated from them and the outcome was not bad code, but such positive deviations are few and far between. At the very least, 99 out of 100 such deviations I have seen were unjustified. However, it might just as well have been 999 out of 1000. So youd better stick to the following rules.</p>
<ol>
<li><p><em><strong>Whenever the meaning of an operator is not obviously clear and undisputed, it should not be overloaded.</strong></em> <em>Instead, provide a function with a well-chosen name.</em><br>
Basically, the first and foremost rule for overloading operators, at its very heart, says: <em>Dont do it</em>. That might seem strange, because there is a lot to be known about operator overloading and so a lot of articles, book chapters, and other texts deal with all this. But despite this seemingly obvious evidence, <em>there are only a surprisingly few cases where operator overloading is appropriate</em>. The reason is that actually it is hard to understand the semantics behind the application of an operator unless the use of the operator in the application domain is well known and undisputed. Contrary to popular belief, this is hardly ever the case.</p>
</li>
<li><p><em><strong>Always stick to the operators well-known semantics.</strong></em><br>
C++ poses no limitations on the semantics of overloaded operators. Your compiler will happily accept code that implements the binary <code>+</code> operator to subtract from its right operand. However, the users of such an operator would never suspect the expression <code>a + b</code> to subtract <code>a</code> from <code>b</code>. Of course, this supposes that the semantics of the operator in the application domain is undisputed.</p>
</li>
<li><p><em><strong>Always provide all out of a set of related operations.</strong></em><br>
<em>Operators are related to each other</em> and to other operations. If your type supports <code>a + b</code>, users will expect to be able to call <code>a += b</code>, too. If it supports prefix increment <code>++a</code>, they will expect <code>a++</code> to work as well. If they can check whether <code>a &lt; b</code>, they will most certainly expect to also to be able to check whether <code>a &gt; b</code>. If they can copy-construct your type, they expect assignment to work as well.</p>
</li>
</ol>
<hr>
<p>Continue to <a href="https://stackoverflow.com/questions/4421706/operator-overloading-in-c/4421729#4421729">The Decision between Member and Non-member</a>.</p>
    </div></div></div></div><div id="solution3" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 3</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/operators">operators</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/operator-overloading">operator-overloading</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<h2>The Decision between Member and Non-member</h2>
<p>The binary operators <code>=</code> (assignment), <code>[]</code> (array subscription), <code>-&gt;</code> (member access), as well as the n-ary <code>()</code> (function call) operator, must always be implemented as <em><strong>member functions</strong></em>, because the syntax of the language requires them to.</p>
<p>Other operators can be implemented either as members or as non-members. Some of them, however, usually have to be implemented as non-member functions, because their left operand cannot be modified by you. The most prominent of these are the input and output operators <code>&lt;&lt;</code> and <code>&gt;&gt;</code>, whose left operands are stream classes from the standard library which you cannot change.</p>
<p>For all operators where you have to choose to either implement them as a member function or a non-member function, <em><strong>use the following rules of thumb</strong></em> to decide:</p>
<ol>
<li>If it is a <em><strong>unary operator</strong></em>, implement it as a <em><strong>member</strong></em> function.</li>
<li>If a binary operator treats <em><strong>both operands equally</strong></em> (it leaves them unchanged), implement this operator as a <em><strong>non-member</strong></em> function.</li>
<li>If a binary operator does <em><strong>not</strong></em> treat both of its operands <em><strong>equally</strong></em> (usually it will change its left operand), it might be useful to make it a <em><strong>member</strong></em> function of its left operands type, if it has to access the operand's private parts.</li>
</ol>
<p>Of course, as with all rules of thumb, there are exceptions. If you have a type</p>
<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Month</span> {Jan, Feb, ..., Nov, Dec}
</code></pre>
<p>and you want to overload the increment and decrement operators for it, you cannot do this as a member functions, since in C++, enum types cannot have member functions. So you have to overload it as a free function. And <code>operator&lt;()</code> for a class template nested within a class template is much easier to write and read when done as a member function inline in the class definition. But these are indeed rare exceptions.</p>
<p>(However, <em>if</em> you make an exception, do not forget the issue of <code>const</code>-ness for the operand that, for member functions, becomes the implicit <code>this</code> argument. If the operator as a non-member function would take its left-most argument as a <code>const</code> reference, the same operator as a member function needs to have a <code>const</code> at the end to make <code>*this</code> a <code>const</code> reference.)</p>
<hr>
<p>Continue to <a href="https://stackoverflow.com/questions/4421706/operator-overloading-in-c/4421719#4421719">Common operators to overload</a>.</p>
    </div></div></div></div><div id="solution4" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 4</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/operators">operators</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/operator-overloading">operator-overloading</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<h1>The General Syntax of operator overloading in C++</h1>
<p>You cannot change the meaning of operators for built-in types in C++, operators can only be overloaded for user-defined types<sup>1</sup>. That is, at least one of the operands has to be of a user-defined type. As with other overloaded functions, operators can be overloaded for a certain set of parameters only once.</p>
<p>Not all operators can be overloaded in C++. Among the operators that cannot be overloaded are: <code>.</code> <code>::</code> <code>sizeof</code> <code>typeid</code> <code>.*</code> and the only ternary operator in C++, <code>?:</code></p>
<p>Among the operators that can be overloaded in C++ are these:</p>
<ul>
<li>arithmetic operators: <code>+</code> <code>-</code> <code>*</code> <code>/</code> <code>%</code> and <code>+=</code> <code>-=</code> <code>*=</code> <code>/=</code> <code>%=</code> (all binary infix); <code>+</code> <code>-</code> (unary prefix); <code>++</code> <code>--</code> (unary prefix and postfix)</li>
<li>bit manipulation: <code>&amp;</code> <code>|</code> <code>^</code> <code>&lt;&lt;</code> <code>&gt;&gt;</code> and <code>&amp;=</code> <code>|=</code> <code>^=</code> <code>&lt;&lt;=</code> <code>&gt;&gt;=</code> (all binary infix); <code>~</code> (unary prefix)</li>
<li>boolean algebra: <code>==</code> <code>!=</code> <code>&lt;</code> <code>&gt;</code> <code>&lt;=</code> <code>&gt;=</code> <code>||</code> <code>&amp;&amp;</code> (all binary infix); <code>!</code> (unary prefix)</li>
<li>memory management: <code>new</code> <code>new[]</code> <code>delete</code> <code>delete[]</code></li>
<li>implicit conversion operators</li>
<li>miscellany: <code>=</code> <code>[]</code> <code>-&gt;</code> <code>-&gt;*</code> <code>,</code>  (all binary infix); <code>*</code> <code>&amp;</code> (all unary prefix) <code>()</code> (function call, n-ary infix)</li>
</ul>
<p>However, the fact that you <em>can</em> overload all of these does not mean you <em>should</em> do so. See the basic rules of operator overloading.</p>
<p>In C++, operators are overloaded in the form of <em><strong>functions with special names</strong></em>. As with other functions, overloaded operators can generally be implemented either as a <em><strong>member function of their left operand's type</strong></em> or as <em><strong>non-member functions</strong></em>. Whether you are free to choose or bound to use either one depends on several criteria.<sup>2</sup> A unary operator <code>@</code><sup>3</sup>, applied to an object x, is invoked either as <code>operator@(x)</code> or as <code>x.operator@()</code>. A binary infix operator <code>@</code>, applied to the objects <code>x</code> and <code>y</code>, is called either as <code>operator@(x,y)</code> or as <code>x.operator@(y)</code>.<sup>4</sup></p>
<p>Operators that are implemented as non-member functions are sometimes friend of their operands type.</p>
<p><sup>1</sup> <sub>The term user-defined might be slightly misleading. C++ makes the distinction between built-in types and user-defined types. To the former belong for example int, char, and double; to the latter belong all struct, class, union, and enum types, including those from the standard library, even though they are not, as such, defined by users.</sub></p>
<p><sup>2</sup> <sub>This is covered in <a href="https://stackoverflow.com/questions/4421706/operator-overloading/4421729#4421729">a later part</a> of this FAQ.</sub></p>
<p><sup>3</sup> <sub>The <code>@</code> is not a valid operator in C++ which is why I use it as a placeholder.</sub></p>
<p><sup>4</sup> <sub>The only ternary operator in C++ cannot be overloaded and the only n-ary operator must always be implemented as a member function.</sub></p>
<hr>
<p>Continue to <a href="https://stackoverflow.com/questions/4421706/operator-overloading-in-c/4421708#4421708">The Three Basic Rules of Operator Overloading in C++</a>.</p>
    </div></div></div></div><div id="solution5" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 5</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/operators">operators</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/operator-overloading">operator-overloading</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<h1>Conversion Operators (also known as User Defined Conversions)</h1>

<p>In C++ you can create conversion operators, operators that allow the compiler to convert between your types and other defined types.  There are two types of conversion operators, implicit and explicit ones.</p>

<h2>Implicit Conversion Operators (C++98/C++03 and C++11)</h2>

<p>An implicit conversion operator allows the compiler to implicitly convert (like the conversion between <code>int</code> and <code>long</code>) the value of a user-defined type to some other type.</p>

<p>The following is a simple class with an implicit conversion operator:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">my_string</span> {
<span class="hljs-keyword">public</span>:
  <span class="hljs-keyword">operator</span> <span class="hljs-type">const</span> <span class="hljs-type">char</span>*() <span class="hljs-type">const</span> {<span class="hljs-keyword">return</span> data_;} <span class="hljs-comment">// This is the conversion operator</span>
<span class="hljs-keyword">private</span>:
  <span class="hljs-type">const</span> <span class="hljs-type">char</span>* data_;
};
</code></pre>

<p>Implicit conversion operators, like one-argument constructors, are user-defined conversions. Compilers will grant one user-defined conversion when trying to match a call to an overloaded function.</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>*)</span></span>;

my_string str;
<span class="hljs-built_in">f</span>(str); <span class="hljs-comment">// same as f( str.operator const char*() )</span>
</code></pre>

<p>At first this seems very helpful, but the problem with this is that the implicit conversion even kicks in when it isnt expected to. In the following code, <code>void f(const char*)</code> will be called because <code>my_string()</code> is not an <a href="https://stackoverflow.com/questions/3601602/what-are-rvalues-lvalues-xvalues-glvalues-and-prvalues">lvalue</a>, so the first does not match:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(my_string&amp;)</span></span>;
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>*)</span></span>;

<span class="hljs-built_in">f</span>(<span class="hljs-built_in">my_string</span>());
</code></pre>

<p>Beginners easily get this wrong and even experienced C++ programmers are sometimes surprised because the compiler picks an overload they didnt suspect.  These problems can be mitigated by explicit conversion operators.</p>

<h2>Explicit Conversion Operators (C++11)</h2>

<p>Unlike implicit conversion operators, explicit conversion operators will never kick in when you don't expect them to.  The following is a simple class with an explicit conversion operator:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">my_string</span> {
<span class="hljs-keyword">public</span>:
  <span class="hljs-keyword">explicit</span> <span class="hljs-keyword">operator</span> <span class="hljs-type">const</span> <span class="hljs-type">char</span>*() <span class="hljs-type">const</span> {<span class="hljs-keyword">return</span> data_;}
<span class="hljs-keyword">private</span>:
  <span class="hljs-type">const</span> <span class="hljs-type">char</span>* data_;
};
</code></pre>

<p>Notice the <code>explicit</code>.  Now when you try to execute the unexpected code from the implicit conversion operators, you get a compiler error:</p>

<pre>prog.cpp: In function int main():
prog.cpp:15:18: error: no matching function for call to f(my_string)
prog.cpp:15:18: note: candidates are:
prog.cpp:11:10: note: void f(my_string&amp;)
prog.cpp:11:10: note:   no known conversion for argument 1 from my_string to my_string&amp;
prog.cpp:12:10: note: void f(const char*)
prog.cpp:12:10: note:   no known conversion for argument 1 from my_string to const char*
</pre>

<p>To invoke the explicit cast operator, you have to use <code>static_cast</code>, a C-style cast, or a constructor style cast ( i.e. <code>T(value)</code> ).  </p>

<p>However, there is one exception to this:  The compiler is allowed to implicitly convert to <code>bool</code>.  In addition, the compiler is not allowed to do another implicit conversion after it converts to <code>bool</code> (a compiler is allowed to do 2 implicit conversions at a time, but only 1 user-defined conversion at max).  </p>

<p>Because the compiler will not cast "past" <code>bool</code>, explicit conversion operators now remove the need for the <a href="http://en.wikibooks.org/wiki/More_C%2B%2B_Idioms/Safe_bool" rel="noreferrer">Safe Bool idiom</a>.   For example, smart pointers before C++11 used the Safe Bool idiom to prevent conversions to integral types.  In C++11, the smart pointers use an explicit operator instead because the compiler is not allowed to implicitly convert to an integral type after it explicitly converted a type to bool.</p>

<p>Continue to <a href="https://stackoverflow.com/questions/4421706/operator-overloading-in-c/4421791#4421791">Overloading <code>new</code> and <code>delete</code></a>.</p>
    </div></div></div></div><div id="solution6" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 6</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/operators">operators</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/operator-overloading">operator-overloading</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<h1>Overloading <code>new</code> and <code>delete</code> operators</h1>
<p><sup><em><strong>Note:</strong></em> This only deals with the <em><strong>syntax</strong></em> of overloading <code>new</code> and <code>delete</code>, not with the <em><strong>implementation</strong></em> of such overloaded operators. I think that the semantics of overloading <em><strong><a href="https://stackoverflow.com/questions/7149461/"><code>new</code> and <code>delete</code> deserve their own FAQ</a></strong></em>, within the topic of operator overloading I can never do it justice.</sup></p>
<h2>Basics</h2>
<p>In C++, when you write a <em><strong>new expression</strong></em> like <code>new T(arg)</code> two things happen when this expression is evaluated: First <em><strong><code>operator new</code></strong></em> is invoked to obtain raw memory, and then the appropriate constructor of <code>T</code> is invoked to turn this raw memory into a valid object. Likewise, when you delete an object, first its destructor is called, and then the memory is returned to <code>operator delete</code>.<br>
C++ allows you to tune both of these operations: memory management and the construction/destruction of the object at the allocated memory. The latter is done by writing constructors and destructors for a class. Fine-tuning memory management is done by writing your own <code>operator new</code> and <code>operator delete</code>.</p>
<p>The first of the basic rules of operator overloading  <em>dont do it</em>  applies especially to overloading <code>new</code> and <code>delete</code>. Almost the only reasons to overload these operators are <em><strong>performance problems</strong></em> and <em><strong>memory constraints</strong></em>, and in many cases, other actions, like <em>changes to the algorithms</em> used, will provide a much <em><strong>higher cost/gain ratio</strong></em> than attempting to tweak memory management.</p>
<p>The C++ standard library comes with a set of predefined <code>new</code> and <code>delete</code> operators. The most important ones are these:</p>
<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-function"><span class="hljs-type">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(std::<span class="hljs-type">size_t</span>)</span> <span class="hljs-title">throw</span><span class="hljs-params">(std::bad_alloc)</span></span>; 
<span class="hljs-function"><span class="hljs-type">void</span>  <span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(<span class="hljs-type">void</span>*)</span> <span class="hljs-title">throw</span><span class="hljs-params">()</span></span>; 
<span class="hljs-type">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-keyword">new</span>[](std::<span class="hljs-type">size_t</span>) <span class="hljs-built_in">throw</span>(std::bad_alloc); 
<span class="hljs-type">void</span>  <span class="hljs-keyword">operator</span> <span class="hljs-keyword">delete</span>[](<span class="hljs-type">void</span>*) <span class="hljs-keyword">throw</span>(); 
</code></pre>
<p>The first two allocate/deallocate memory for an object, the latter two for an array of objects. If you provide your own versions of these, they will <em><strong>not overload, but replace</strong></em> the ones from the standard library.<br>
If you overload <code>operator new</code>, you should always also overload the matching <code>operator delete</code>, even if you never intend to call it. The reason is that, if a constructor throws during the evaluation of a new expression, the run-time system will return the memory to the <code>operator delete</code> matching the <code>operator new</code> that was called to allocate the memory to create the object in. If you do not provide a matching <code>operator delete</code>, the default one is called, which is almost always wrong.<br>
If you overload <code>new</code> and <code>delete</code>, you should consider overloading the array variants, too.</p>
<h2>Placement <code>new</code></h2>
<p>C++ allows new and delete operators to take additional arguments.<br>
So-called placement new allows you to create an object at a certain address which is passed to:</p>
<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">X</span> { <span class="hljs-comment">/* ... */</span> };
<span class="hljs-type">char</span> buffer[ <span class="hljs-built_in">sizeof</span>(X) ];
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span>
</span>{ 
  X* p = <span class="hljs-built_in">new</span>(buffer) <span class="hljs-built_in">X</span>(<span class="hljs-comment">/*...*/</span>);
  <span class="hljs-comment">// ... </span>
  p-&gt;~<span class="hljs-built_in">X</span>(); <span class="hljs-comment">// call destructor </span>
} 
</code></pre>
<p>The standard library comes with the appropriate overloads of the new and delete operators for this:</p>
<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-function"><span class="hljs-type">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(std::<span class="hljs-type">size_t</span>,<span class="hljs-type">void</span>* p)</span> <span class="hljs-title">throw</span><span class="hljs-params">(std::bad_alloc)</span></span>; 
<span class="hljs-function"><span class="hljs-type">void</span>  <span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(<span class="hljs-type">void</span>* p,<span class="hljs-type">void</span>*)</span> <span class="hljs-title">throw</span><span class="hljs-params">()</span></span>; 
<span class="hljs-type">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-keyword">new</span>[](std::<span class="hljs-type">size_t</span>,<span class="hljs-type">void</span>* p) <span class="hljs-built_in">throw</span>(std::bad_alloc); 
<span class="hljs-type">void</span>  <span class="hljs-keyword">operator</span> <span class="hljs-keyword">delete</span>[](<span class="hljs-type">void</span>* p,<span class="hljs-type">void</span>*) <span class="hljs-keyword">throw</span>(); 
</code></pre>
<p>Note that, in the example code for placement new given above, <code>operator delete</code> is never called, unless the constructor of X throws an exception.</p>
<p>You can also overload <code>new</code> and <code>delete</code> with other arguments. As with the additional argument for placement new, these arguments are also listed within parentheses after the keyword <code>new</code>. Merely for historical reasons, such variants are often also called placement new, even if their arguments are not for placing an object at a specific address.</p>
<h2>Class-specific new and delete</h2>
<p>Most commonly you will want to fine-tune memory management because measurement has shown that instances of a specific class, or of a group of related classes, are created and destroyed often and that the default memory management of the run-time system, tuned for general performance, deals inefficiently in this specific case. To improve this, you can overload new and delete for a specific class:</p>
<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">my_class</span> { 
  <span class="hljs-keyword">public</span>: 
    <span class="hljs-comment">// ... </span>
    <span class="hljs-function"><span class="hljs-type">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(std::<span class="hljs-type">size_t</span>)</span></span>;
    <span class="hljs-function"><span class="hljs-type">void</span>  <span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(<span class="hljs-type">void</span>*)</span></span>;
    <span class="hljs-type">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-keyword">new</span>[](std::<span class="hljs-type">size_t</span>);
    <span class="hljs-type">void</span>  <span class="hljs-keyword">operator</span> <span class="hljs-keyword">delete</span>[](<span class="hljs-type">void</span>*);
    <span class="hljs-comment">// ...  </span>
}; 
</code></pre>
<p>Overloaded thus, new and delete behave like static member functions. For objects of <code>my_class</code>, the <code>std::size_t</code> argument will always be <code>sizeof(my_class)</code>. However, these operators are also called for dynamically allocated objects of <em><strong>derived classes</strong></em>, in which case it might be greater than that.</p>
<h2>Global new and delete</h2>
<p>To overload the global new and delete, simply replace the pre-defined operators of the standard library with our own. However, this rarely ever needs to be done.</p>
    </div></div></div></div><div id="solution7" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 7</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/operators">operators</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/operator-overloading">operator-overloading</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p><a href="https://stackoverflow.com/questions/34953523/overloading-the-insertion-operator-questions-theoretical">Why can't <code>operator&lt;&lt;</code> function for streaming objects to <code>std::cout</code> or to a file be a member function?</a></p>

<p>Let's say you have:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Foo</span>
{
   <span class="hljs-type">int</span> a;
   <span class="hljs-type">double</span> b;

   std::ostream&amp; <span class="hljs-keyword">operator</span>&lt;&lt;(std::ostream&amp; out) <span class="hljs-type">const</span>
   {
      <span class="hljs-keyword">return</span> out &lt;&lt; a &lt;&lt; <span class="hljs-string">" "</span> &lt;&lt; b;
   }
};
</code></pre>

<p>Given that, you cannot use:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp">Foo f = {<span class="hljs-number">10</span>, <span class="hljs-number">20.0</span>};
std::cout &lt;&lt; f;
</code></pre>

<p>Since <code>operator&lt;&lt;</code> is overloaded as a member function of <code>Foo</code>, the LHS of the operator must be a <code>Foo</code> object. Which means, you will be required to use:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp">Foo f = {<span class="hljs-number">10</span>, <span class="hljs-number">20.0</span>};
f &lt;&lt; std::cout
</code></pre>

<p>which is very non-intuitive.</p>

<p>If you define it as a non-member function,</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Foo</span>
{
   <span class="hljs-type">int</span> a;
   <span class="hljs-type">double</span> b;
};

std::ostream&amp; <span class="hljs-keyword">operator</span>&lt;&lt;(std::ostream&amp; out, Foo <span class="hljs-type">const</span>&amp; f)
{
   <span class="hljs-keyword">return</span> out &lt;&lt; f.a &lt;&lt; <span class="hljs-string">" "</span> &lt;&lt; f.b;
}
</code></pre>

<p>You will be able to use:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp">Foo f = {<span class="hljs-number">10</span>, <span class="hljs-number">20.0</span>};
std::cout &lt;&lt; f;
</code></pre>

<p>which is very intuitive.</p>
    </div></div></div></div><div id="solution8" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 8</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/operators">operators</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/operator-overloading">operator-overloading</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Making it short and simple, I'll be referring to some points, which I had come over the past week as I was learning Python and C++, oops and other things, so it goes as follows:</p>
<ol>
<li><p>The Arity of the operator can not be modified further than to what it is!</p>
</li>
<li><p>Overloaded operators can only have one default argument which the function call operator rest it cannot.</p>
</li>
<li><p>Only built in operator can be overloaded, rest can't!</p>
</li>
</ol>
<p>For more info, you can refer to the following link, which redirects you to the documentation provided by GeekforGeeks.</p>
<p><a href="https://www.geeksforgeeks.org/g-fact-39/" rel="nofollow noreferrer">https://www.geeksforgeeks.org/g-fact-39/</a></p>
    </div></div></div></div></div></div><div class="widget"><a href="/questions/reference:-mod_rewrite-url-rewriting-and-%22pretty-links%22-explained-1657384905504">Reference: mod_rewrite, URL rewriting and &quot;pretty links&quot; explained</a><a href="/questions/what-is-the-difference-between-%22inner-join%22-and-%22outer-join%22-1657387501982">What is the difference between &quot;INNER JOIN&quot; and &quot;OUTER JOIN&quot;?</a><a href="/questions/is-there-a-%22previous-sibling%22-selector-1657384771067">Is there a &quot;previous sibling&quot; selector?</a><a href="/questions/how-do-i-use-arrays-in-c++-1657387456118">How do I use arrays in C++?</a><a href="/questions/what-is-viewmodel-in-mvc-1657387451244">What is ViewModel in MVC?</a><a href="/questions/useless-use-of-cat-1657388390794">Useless use of cat?</a><a href="/questions/how-to-get-all-possible-combinations-of-a-list&#x27;s-elements-1657388271070">How to get all possible combinations of a list’s elements?</a><a href="/questions/why-don&#x27;t-flex-items-shrink-past-content-size-1657384687282">Why don&#x27;t flex items shrink past content size?</a><a href="/questions/do-dom-tree-elements-with-ids-become-global-properties-1657387475110">Do DOM tree elements with IDs become global properties?</a><a href="/questions/what-is-the-rule-of-three-1657384390295">What is The Rule of Three?</a><a href="/questions/with-arrays-why-is-it-the-case-that-a5-5a-1657387956216">With arrays, why is it the case that a[5] == 5[a]?</a><a href="/questions/commandbuttoncommandlinkajax-actionlistener-method-not-invoked-or-input-value-not-setupdated-1657384667519">commandButton/commandLink/ajax action/listener method not invoked or input value not set/updated</a><a href="/questions/what-is-the-difference-between-a-definition-and-a-declaration-1657387851618">What is the difference between a definition and a declaration?</a><a href="/questions/how-can-i-access-the-contents-of-an-iframe-with-javascriptjquery-1657388369923">How can I access the contents of an iframe with JavaScript/jQuery?</a><a href="/questions/is-there-a-unique-android-device-id-1657388089268">Is there a unique Android device ID?</a><a href="/questions/how-to-find-the-&#x27;sizeof&#x27;-(a-pointer-pointing-to-an-array)-1657387354284">How to find the &#x27;sizeof&#x27; (a pointer pointing to an array)?</a><a href="/questions/strange-result-when-removing-item-from-a-list-while-iterating-over-it-duplicate-1657387735759">Strange result when removing item from a list while iterating over it [duplicate]</a><a href="/questions/what-should-main()-return-in-c-and-c++-1657384745630">What should main() return in C and C++?</a><a href="/questions/why-does-%22a-x-or-y-or-z%22-always-evaluate-to-true-1657384855216">Why does &quot;a == x or y or z&quot; always evaluate to True?</a><a href="/questions/how-to-store-objects-in-html5-localstorage-1657387568907">How to store objects in HTML5 localStorage</a></div></div><span class="cursor-pointer text-lg p-2" style="position:fixed;bottom:20px;left:20px;background:#000;z-index:2000;color:white">Go go top</span></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"data":{"answer":["\n\u0026lt;h1\u0026gt;Common operators to overload\u0026lt;/h1\u0026gt;\n\n\u0026lt;p\u0026gt;Most of the work in overloading operators is boiler-plate code. That is little wonder, since operators are merely syntactic sugar, their actual work could be done by (and often is forwarded to) plain functions. But it is important that you get this boiler-plate code right. If you fail, either your operators code wont compile or your users code wont compile or your users code will behave surprisingly.\u0026lt;/p\u0026gt;\n\n\u0026lt;h2\u0026gt;Assignment Operator\u0026lt;/h2\u0026gt;\n\n\u0026lt;p\u0026gt;There\u0026apos;s a lot to be said about assignment. However, most of it has already been said in \u0026lt;a href=\u0026quot;https://stackoverflow.com/questions/3279543/what-is-the-copy-and-swap-idiom\u0026quot;\u0026gt;GMan\u0026apos;s famous Copy-And-Swap FAQ\u0026lt;/a\u0026gt;, so I\u0026apos;ll skip most of it here, only listing the perfect assignment operator for reference:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;X\u0026amp;amp; X::\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;operator\u0026lt;/span\u0026gt;=(X rhs)\n{\n  \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;swap\u0026lt;/span\u0026gt;(rhs);\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; *\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;this\u0026lt;/span\u0026gt;;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;h2\u0026gt;Bitshift Operators (used for Stream I/O)\u0026lt;/h2\u0026gt;\n\n\u0026lt;p\u0026gt;The bitshift operators \u0026lt;code\u0026gt;\u0026amp;lt;\u0026amp;lt;\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026lt;/code\u0026gt;, although still used in hardware interfacing for the bit-manipulation functions they inherit from C, have become more prevalent as overloaded stream input and output operators in most applications.  For guidance overloading as bit-manipulation operators, see the section below on Binary Arithmetic Operators.  For implementing your own custom format and parsing logic when your object is used with iostreams, continue.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;The stream operators, among the most commonly overloaded operators, are binary infix operators for which the syntax specifies no restriction on whether they should be members or non-members.\nSince they change their left argument (they alter the streams state), they should, according to the rules of thumb, be implemented as members of their left operands type. However, their left operands are streams from the standard library, and while most of the stream output and input operators defined by the standard library are indeed defined as members of the stream classes, when you implement output and input operations for your own types, you cannot change the standard librarys stream types. Thats why you need to implement these operators for your own types as non-member functions.\nThe canonical forms of the two are these:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;std::ostream\u0026amp;amp; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;operator\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026amp;lt;(std::ostream\u0026amp;amp; os, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; T\u0026amp;amp; obj)\n{\n  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// write obj to stream\u0026lt;/span\u0026gt;\n\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; os;\n}\n\nstd::istream\u0026amp;amp; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;operator\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026amp;gt;(std::istream\u0026amp;amp; is, T\u0026amp;amp; obj)\n{\n  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// read obj from stream\u0026lt;/span\u0026gt;\n\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt;( \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;/* no valid object of T found in stream */\u0026lt;/span\u0026gt; )\n    is.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;setstate\u0026lt;/span\u0026gt;(std::ios::failbit);\n\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; is;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;When implementing \u0026lt;code\u0026gt;operator\u0026amp;gt;\u0026amp;gt;\u0026lt;/code\u0026gt;, manually setting the streams state is only necessary when the reading itself succeeded, but the result is not what would be expected.\u0026lt;/p\u0026gt;\n\n\u0026lt;h2\u0026gt;Function call operator\u0026lt;/h2\u0026gt;\n\n\u0026lt;p\u0026gt;The function call operator, used to create function objects, also known as functors, must be defined as a \u0026lt;strong\u0026gt;\u0026lt;em\u0026gt;member\u0026lt;/em\u0026gt;\u0026lt;/strong\u0026gt; function, so it always has the implicit \u0026lt;code\u0026gt;this\u0026lt;/code\u0026gt; argument of member functions. Other than this, it can be overloaded to take any number of additional arguments, including zero.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Here\u0026apos;s an example of the syntax:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;foo\u0026lt;/span\u0026gt; {\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt;:\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Overloaded call operator\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;operator\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; std::string\u0026amp;amp; y)\u0026lt;/span\u0026gt; \u0026lt;/span\u0026gt;{\n        \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// ...\u0026lt;/span\u0026gt;\n    }\n};\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Usage:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;foo f;\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; a = \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;f\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;hello\u0026quot;\u0026lt;/span\u0026gt;);\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Throughout the C++ standard library, function objects are always copied. Your own function objects should therefore be cheap to copy. If a function object absolutely needs to use data which is expensive to copy, it is better to store that data elsewhere and have the function object refer to it.\u0026lt;/p\u0026gt;\n\n\u0026lt;h2\u0026gt;Comparison operators\u0026lt;/h2\u0026gt;\n\n\u0026lt;p\u0026gt;The binary infix comparison operators should, according to the rules of thumb, be implemented as non-member functions\u0026lt;sup\u0026gt;1\u0026lt;/sup\u0026gt;. The unary prefix negation \u0026lt;code\u0026gt;!\u0026lt;/code\u0026gt; should (according to the same rules) be implemented as a member function. (but it is usually not a good idea to overload it.)\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;The standard librarys algorithms (e.g. \u0026lt;code\u0026gt;std::sort()\u0026lt;/code\u0026gt;) and types (e.g. \u0026lt;code\u0026gt;std::map\u0026lt;/code\u0026gt;) will always only expect \u0026lt;code\u0026gt;operator\u0026amp;lt;\u0026lt;/code\u0026gt; to be present. However, the \u0026lt;em\u0026gt;users of your type will expect all the other operators to be present\u0026lt;/em\u0026gt;, too, so if you define \u0026lt;code\u0026gt;operator\u0026amp;lt;\u0026lt;/code\u0026gt;, be sure to follow the third fundamental rule of operator overloading and also define all the other boolean comparison operators. The canonical way to implement them is this:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;inline\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;bool\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;operator\u0026lt;/span\u0026gt;==(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; X\u0026amp;amp; lhs, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; X\u0026amp;amp; rhs){ \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;/* do actual comparison */\u0026lt;/span\u0026gt; }\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;inline\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;bool\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;operator\u0026lt;/span\u0026gt;!=(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; X\u0026amp;amp; lhs, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; X\u0026amp;amp; rhs){\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; !\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;operator\u0026lt;/span\u0026gt;==(lhs,rhs);}\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;inline\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;bool\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;operator\u0026lt;/span\u0026gt;\u0026amp;lt; (\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; X\u0026amp;amp; lhs, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; X\u0026amp;amp; rhs){ \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;/* do actual comparison */\u0026lt;/span\u0026gt; }\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;inline\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;bool\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;operator\u0026lt;/span\u0026gt;\u0026amp;gt; (\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; X\u0026amp;amp; lhs, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; X\u0026amp;amp; rhs){\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt;  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;operator\u0026lt;/span\u0026gt;\u0026amp;lt; (rhs,lhs);}\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;inline\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;bool\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;operator\u0026lt;/span\u0026gt;\u0026amp;lt;=(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; X\u0026amp;amp; lhs, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; X\u0026amp;amp; rhs){\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; !\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;operator\u0026lt;/span\u0026gt;\u0026amp;gt; (lhs,rhs);}\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;inline\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;bool\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;operator\u0026lt;/span\u0026gt;\u0026amp;gt;=(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; X\u0026amp;amp; lhs, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; X\u0026amp;amp; rhs){\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; !\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;operator\u0026lt;/span\u0026gt;\u0026amp;lt; (lhs,rhs);}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;The important thing to note here is that only two of these operators actually do anything, the others are just forwarding their arguments to either of these two to do the actual work.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;The syntax for overloading the remaining binary boolean operators (\u0026lt;code\u0026gt;||\u0026lt;/code\u0026gt;, \u0026lt;code\u0026gt;\u0026amp;amp;\u0026amp;amp;\u0026lt;/code\u0026gt;) follows the rules of the comparison operators. However, it is \u0026lt;em\u0026gt;very\u0026lt;/em\u0026gt; unlikely that you would find a reasonable use case for these\u0026lt;sup\u0026gt;2\u0026lt;/sup\u0026gt;.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;sup\u0026gt;1\u0026lt;/sup\u0026gt; \u0026lt;sub\u0026gt;As with all rules of thumb, sometimes there might be reasons to break this one, too. If so, do not forget that the left-hand operand of the binary comparison operators, which for member functions will be \u0026lt;code\u0026gt;*this\u0026lt;/code\u0026gt;, needs to be \u0026lt;code\u0026gt;const\u0026lt;/code\u0026gt;, too. So a comparison operator implemented as a member function would have to have this signature:\u0026lt;/sub\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;bool\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;operator\u0026lt;/span\u0026gt;\u0026amp;lt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; X\u0026amp;amp; rhs) \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; { \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;/* do actual comparison with *this */\u0026lt;/span\u0026gt; }\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;sub\u0026gt;(Note the \u0026lt;code\u0026gt;const\u0026lt;/code\u0026gt; at the end.)\u0026lt;/sub\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;sup\u0026gt;2\u0026lt;/sup\u0026gt; \u0026lt;sub\u0026gt;It should be noted that the built-in version of \u0026lt;code\u0026gt;||\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;\u0026amp;amp;\u0026amp;amp;\u0026lt;/code\u0026gt; use shortcut semantics. While the user defined ones (because they are syntactic sugar for method calls) do not use shortcut semantics. User will expect these operators to have shortcut semantics, and their code may depend on it, Therefore it is highly advised NEVER to define them.\u0026lt;/sub\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;h2\u0026gt;Arithmetic Operators\u0026lt;/h2\u0026gt;\n\n\u0026lt;h3\u0026gt;Unary arithmetic operators\u0026lt;/h3\u0026gt;\n\n\u0026lt;p\u0026gt;The unary increment and decrement operators come in both prefix and postfix flavor. To tell one from the other, the postfix variants take an additional dummy int argument. If you overload increment or decrement, be sure to always implement both prefix and postfix versions.\nHere is the canonical implementation of increment, decrement follows the same rules:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;X\u0026lt;/span\u0026gt; {\n  X\u0026amp;amp; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;operator\u0026lt;/span\u0026gt;++()\n  {\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// do actual increment\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; *\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;this\u0026lt;/span\u0026gt;;\n  }\n  X \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;operator\u0026lt;/span\u0026gt;++(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;)\n  {\n    \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;X \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;tmp\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(*\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;this\u0026lt;/span\u0026gt;)\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;operator\u0026lt;/span\u0026gt;++();\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; tmp;\n  }\n};\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Note that the postfix variant is implemented in terms of prefix. Also note that postfix does an extra copy.\u0026lt;sup\u0026gt;2\u0026lt;/sup\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Overloading unary minus and plus is not very common and probably best avoided. If needed, they should probably be overloaded as member functions. \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;sup\u0026gt;2\u0026lt;/sup\u0026gt; \u0026lt;sub\u0026gt;Also note that the postfix variant does more work and is therefore less efficient to use than the prefix variant. This is a good reason to generally prefer prefix increment over postfix increment. While compilers can usually optimize away the additional work of postfix increment for built-in types, they might not be able to do the same for user-defined types (which could be something as innocently looking as a list iterator). Once you got used to do \u0026lt;code\u0026gt;i++\u0026lt;/code\u0026gt;, it becomes very hard to remember to do \u0026lt;code\u0026gt;++i\u0026lt;/code\u0026gt; instead when \u0026lt;code\u0026gt;i\u0026lt;/code\u0026gt; is not of a built-in type (plus you\u0026apos;d have to change code when changing a type), so it is better to make a habit of always using prefix increment, unless postfix is explicitly needed.\u0026lt;/sub\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;h3\u0026gt;Binary arithmetic operators\u0026lt;/h3\u0026gt;\n\n\u0026lt;p\u0026gt;For the binary arithmetic operators, do not forget to obey the third basic rule operator overloading: If you provide \u0026lt;code\u0026gt;+\u0026lt;/code\u0026gt;, also provide \u0026lt;code\u0026gt;+=\u0026lt;/code\u0026gt;, if you provide \u0026lt;code\u0026gt;-\u0026lt;/code\u0026gt;, do not omit \u0026lt;code\u0026gt;-=\u0026lt;/code\u0026gt;, etc. Andrew Koenig is said to have been the first to observe that the compound assignment operators can be used as a base for their non-compound counterparts. That is, operator \u0026lt;code\u0026gt;+\u0026lt;/code\u0026gt; is implemented in terms of \u0026lt;code\u0026gt;+=\u0026lt;/code\u0026gt;, \u0026lt;code\u0026gt;-\u0026lt;/code\u0026gt; is implemented in terms of \u0026lt;code\u0026gt;-=\u0026lt;/code\u0026gt; etc.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;According to our rules of thumb, \u0026lt;code\u0026gt;+\u0026lt;/code\u0026gt; and its companions should be non-members, while their compound assignment counterparts (\u0026lt;code\u0026gt;+=\u0026lt;/code\u0026gt; etc.), changing their left argument, should be a member. Here is the exemplary code for \u0026lt;code\u0026gt;+=\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;+\u0026lt;/code\u0026gt;; the other binary arithmetic operators should be implemented in the same way:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;X\u0026lt;/span\u0026gt; {\n  X\u0026amp;amp; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;operator\u0026lt;/span\u0026gt;+=(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; X\u0026amp;amp; rhs)\n  {\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// actual addition of rhs to *this\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; *\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;this\u0026lt;/span\u0026gt;;\n  }\n};\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;inline\u0026lt;/span\u0026gt; X \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;operator\u0026lt;/span\u0026gt;+(X lhs, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; X\u0026amp;amp; rhs)\n{\n  lhs += rhs;\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; lhs;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;code\u0026gt;operator+=\u0026lt;/code\u0026gt; returns its result per reference, while \u0026lt;code\u0026gt;operator+\u0026lt;/code\u0026gt; returns a copy of its result. Of course, returning a reference is usually more efficient than returning a copy, but in the case of \u0026lt;code\u0026gt;operator+\u0026lt;/code\u0026gt;, there is no way around the copying. When you write \u0026lt;code\u0026gt;a + b\u0026lt;/code\u0026gt;, you expect the result to be a new value, which is why \u0026lt;code\u0026gt;operator+\u0026lt;/code\u0026gt; has to return a new value.\u0026lt;sup\u0026gt;3\u0026lt;/sup\u0026gt;\nAlso note that \u0026lt;code\u0026gt;operator+\u0026lt;/code\u0026gt; takes its left operand \u0026lt;strong\u0026gt;\u0026lt;em\u0026gt;by copy\u0026lt;/em\u0026gt;\u0026lt;/strong\u0026gt; rather than by const reference. The reason for this is the same as the reason giving for \u0026lt;code\u0026gt;operator=\u0026lt;/code\u0026gt; taking its argument per copy.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;The bit manipulation operators \u0026lt;code\u0026gt;~\u0026lt;/code\u0026gt; \u0026lt;code\u0026gt;\u0026amp;amp;\u0026lt;/code\u0026gt; \u0026lt;code\u0026gt;|\u0026lt;/code\u0026gt; \u0026lt;code\u0026gt;^\u0026lt;/code\u0026gt; \u0026lt;code\u0026gt;\u0026amp;lt;\u0026amp;lt;\u0026lt;/code\u0026gt; \u0026lt;code\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026lt;/code\u0026gt; should be implemented in the same way as the arithmetic operators. However, (except for overloading \u0026lt;code\u0026gt;\u0026amp;lt;\u0026amp;lt;\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026lt;/code\u0026gt; for output and input) there are very few reasonable use cases for overloading these.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;sup\u0026gt;3\u0026lt;/sup\u0026gt; \u0026lt;sub\u0026gt;Again, the lesson to be taken from this is that \u0026lt;code\u0026gt;a += b\u0026lt;/code\u0026gt; is, in general, more efficient than \u0026lt;code\u0026gt;a + b\u0026lt;/code\u0026gt; and should be preferred if possible.\u0026lt;/sub\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;h2\u0026gt;Array Subscripting\u0026lt;/h2\u0026gt;\n\n\u0026lt;p\u0026gt;The array subscript operator is a binary operator which must be implemented as a class member. It is used for container-like types that allow access to their data elements by a key.\nThe canonical form of providing these is this:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;X\u0026lt;/span\u0026gt; {\n        value_type\u0026amp;amp; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;operator\u0026lt;/span\u0026gt;[](index_type idx);\n  \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; value_type\u0026amp;amp; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;operator\u0026lt;/span\u0026gt;[](index_type idx) \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt;;\n  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// ...\u0026lt;/span\u0026gt;\n};\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Unless you do not want users of your class to be able to change data elements returned by \u0026lt;code\u0026gt;operator[]\u0026lt;/code\u0026gt; (in which case you can omit the non-const variant), you should always provide both variants of the operator.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;If value_type is known to refer to a built-in type, the const variant of the operator should better return a copy instead of a const reference:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;X\u0026lt;/span\u0026gt; {\n  value_type\u0026amp;amp; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;operator\u0026lt;/span\u0026gt;[](index_type idx);\n  value_type  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;operator\u0026lt;/span\u0026gt;[](index_type idx) \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt;;\n  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// ...\u0026lt;/span\u0026gt;\n};\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;h2\u0026gt;Operators for Pointer-like Types\u0026lt;/h2\u0026gt;\n\n\u0026lt;p\u0026gt;For defining your own iterators or smart pointers, you have to overload the unary prefix dereference operator \u0026lt;code\u0026gt;*\u0026lt;/code\u0026gt; and the binary infix pointer member access operator \u0026lt;code\u0026gt;-\u0026amp;gt;\u0026lt;/code\u0026gt;:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;my_ptr\u0026lt;/span\u0026gt; {\n        value_type\u0026amp;amp; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;operator\u0026lt;/span\u0026gt;*();\n  \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; value_type\u0026amp;amp; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;operator\u0026lt;/span\u0026gt;*() \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt;;\n        value_type* \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;operator\u0026lt;/span\u0026gt;-\u0026amp;gt;();\n  \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; value_type* \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;operator\u0026lt;/span\u0026gt;-\u0026amp;gt;() \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt;;\n};\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Note that these, too, will almost always need both a const and a non-const version.\nFor the \u0026lt;code\u0026gt;-\u0026amp;gt;\u0026lt;/code\u0026gt; operator, if \u0026lt;code\u0026gt;value_type\u0026lt;/code\u0026gt; is of \u0026lt;code\u0026gt;class\u0026lt;/code\u0026gt; (or \u0026lt;code\u0026gt;struct\u0026lt;/code\u0026gt; or \u0026lt;code\u0026gt;union\u0026lt;/code\u0026gt;) type, another \u0026lt;code\u0026gt;operator-\u0026amp;gt;()\u0026lt;/code\u0026gt; is called recursively, until an \u0026lt;code\u0026gt;operator-\u0026amp;gt;()\u0026lt;/code\u0026gt; returns a value of non-class type.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;The unary address-of operator should never be overloaded.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;For \u0026lt;code\u0026gt;operator-\u0026amp;gt;*()\u0026lt;/code\u0026gt; see \u0026lt;a href=\u0026quot;https://stackoverflow.com/q/8777845/140719\u0026quot;\u0026gt;this question\u0026lt;/a\u0026gt;. It\u0026apos;s rarely used and thus rarely ever overloaded. In fact, even iterators do not overload it.\u0026lt;/p\u0026gt;\n\n\u0026lt;hr\u0026gt;\n\n\u0026lt;p\u0026gt;Continue to \u0026lt;a href=\u0026quot;https://stackoverflow.com/questions/4421706/operator-overloading/16615725#16615725\u0026quot;\u0026gt;Conversion Operators\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;h1\u0026gt;The Three Basic Rules of Operator Overloading in C++\u0026lt;/h1\u0026gt;\n\u0026lt;p\u0026gt;When it comes to operator overloading in C++, there are \u0026lt;em\u0026gt;\u0026lt;strong\u0026gt;three basic rules you should follow\u0026lt;/strong\u0026gt;\u0026lt;/em\u0026gt;. As with all such rules, there are indeed exceptions. Sometimes people have deviated from them and the outcome was not bad code, but such positive deviations are few and far between. At the very least, 99 out of 100 such deviations I have seen were unjustified. However, it might just as well have been 999 out of 1000. So youd better stick to the following rules.\u0026lt;/p\u0026gt;\n\u0026lt;ol\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;\u0026lt;em\u0026gt;\u0026lt;strong\u0026gt;Whenever the meaning of an operator is not obviously clear and undisputed, it should not be overloaded.\u0026lt;/strong\u0026gt;\u0026lt;/em\u0026gt; \u0026lt;em\u0026gt;Instead, provide a function with a well-chosen name.\u0026lt;/em\u0026gt;\u0026lt;br\u0026gt;\nBasically, the first and foremost rule for overloading operators, at its very heart, says: \u0026lt;em\u0026gt;Dont do it\u0026lt;/em\u0026gt;. That might seem strange, because there is a lot to be known about operator overloading and so a lot of articles, book chapters, and other texts deal with all this. But despite this seemingly obvious evidence, \u0026lt;em\u0026gt;there are only a surprisingly few cases where operator overloading is appropriate\u0026lt;/em\u0026gt;. The reason is that actually it is hard to understand the semantics behind the application of an operator unless the use of the operator in the application domain is well known and undisputed. Contrary to popular belief, this is hardly ever the case.\u0026lt;/p\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;\u0026lt;em\u0026gt;\u0026lt;strong\u0026gt;Always stick to the operators well-known semantics.\u0026lt;/strong\u0026gt;\u0026lt;/em\u0026gt;\u0026lt;br\u0026gt;\nC++ poses no limitations on the semantics of overloaded operators. Your compiler will happily accept code that implements the binary \u0026lt;code\u0026gt;+\u0026lt;/code\u0026gt; operator to subtract from its right operand. However, the users of such an operator would never suspect the expression \u0026lt;code\u0026gt;a + b\u0026lt;/code\u0026gt; to subtract \u0026lt;code\u0026gt;a\u0026lt;/code\u0026gt; from \u0026lt;code\u0026gt;b\u0026lt;/code\u0026gt;. Of course, this supposes that the semantics of the operator in the application domain is undisputed.\u0026lt;/p\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;\u0026lt;em\u0026gt;\u0026lt;strong\u0026gt;Always provide all out of a set of related operations.\u0026lt;/strong\u0026gt;\u0026lt;/em\u0026gt;\u0026lt;br\u0026gt;\n\u0026lt;em\u0026gt;Operators are related to each other\u0026lt;/em\u0026gt; and to other operations. If your type supports \u0026lt;code\u0026gt;a + b\u0026lt;/code\u0026gt;, users will expect to be able to call \u0026lt;code\u0026gt;a += b\u0026lt;/code\u0026gt;, too. If it supports prefix increment \u0026lt;code\u0026gt;++a\u0026lt;/code\u0026gt;, they will expect \u0026lt;code\u0026gt;a++\u0026lt;/code\u0026gt; to work as well. If they can check whether \u0026lt;code\u0026gt;a \u0026amp;lt; b\u0026lt;/code\u0026gt;, they will most certainly expect to also to be able to check whether \u0026lt;code\u0026gt;a \u0026amp;gt; b\u0026lt;/code\u0026gt;. If they can copy-construct your type, they expect assignment to work as well.\u0026lt;/p\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;/ol\u0026gt;\n\u0026lt;hr\u0026gt;\n\u0026lt;p\u0026gt;Continue to \u0026lt;a href=\u0026quot;https://stackoverflow.com/questions/4421706/operator-overloading-in-c/4421729#4421729\u0026quot;\u0026gt;The Decision between Member and Non-member\u0026lt;/a\u0026gt;.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;h2\u0026gt;The Decision between Member and Non-member\u0026lt;/h2\u0026gt;\n\u0026lt;p\u0026gt;The binary operators \u0026lt;code\u0026gt;=\u0026lt;/code\u0026gt; (assignment), \u0026lt;code\u0026gt;[]\u0026lt;/code\u0026gt; (array subscription), \u0026lt;code\u0026gt;-\u0026amp;gt;\u0026lt;/code\u0026gt; (member access), as well as the n-ary \u0026lt;code\u0026gt;()\u0026lt;/code\u0026gt; (function call) operator, must always be implemented as \u0026lt;em\u0026gt;\u0026lt;strong\u0026gt;member functions\u0026lt;/strong\u0026gt;\u0026lt;/em\u0026gt;, because the syntax of the language requires them to.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Other operators can be implemented either as members or as non-members. Some of them, however, usually have to be implemented as non-member functions, because their left operand cannot be modified by you. The most prominent of these are the input and output operators \u0026lt;code\u0026gt;\u0026amp;lt;\u0026amp;lt;\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026lt;/code\u0026gt;, whose left operands are stream classes from the standard library which you cannot change.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;For all operators where you have to choose to either implement them as a member function or a non-member function, \u0026lt;em\u0026gt;\u0026lt;strong\u0026gt;use the following rules of thumb\u0026lt;/strong\u0026gt;\u0026lt;/em\u0026gt; to decide:\u0026lt;/p\u0026gt;\n\u0026lt;ol\u0026gt;\n\u0026lt;li\u0026gt;If it is a \u0026lt;em\u0026gt;\u0026lt;strong\u0026gt;unary operator\u0026lt;/strong\u0026gt;\u0026lt;/em\u0026gt;, implement it as a \u0026lt;em\u0026gt;\u0026lt;strong\u0026gt;member\u0026lt;/strong\u0026gt;\u0026lt;/em\u0026gt; function.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;If a binary operator treats \u0026lt;em\u0026gt;\u0026lt;strong\u0026gt;both operands equally\u0026lt;/strong\u0026gt;\u0026lt;/em\u0026gt; (it leaves them unchanged), implement this operator as a \u0026lt;em\u0026gt;\u0026lt;strong\u0026gt;non-member\u0026lt;/strong\u0026gt;\u0026lt;/em\u0026gt; function.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;If a binary operator does \u0026lt;em\u0026gt;\u0026lt;strong\u0026gt;not\u0026lt;/strong\u0026gt;\u0026lt;/em\u0026gt; treat both of its operands \u0026lt;em\u0026gt;\u0026lt;strong\u0026gt;equally\u0026lt;/strong\u0026gt;\u0026lt;/em\u0026gt; (usually it will change its left operand), it might be useful to make it a \u0026lt;em\u0026gt;\u0026lt;strong\u0026gt;member\u0026lt;/strong\u0026gt;\u0026lt;/em\u0026gt; function of its left operands type, if it has to access the operand\u0026apos;s private parts.\u0026lt;/li\u0026gt;\n\u0026lt;/ol\u0026gt;\n\u0026lt;p\u0026gt;Of course, as with all rules of thumb, there are exceptions. If you have a type\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;enum\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Month\u0026lt;/span\u0026gt; {Jan, Feb, ..., Nov, Dec}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;and you want to overload the increment and decrement operators for it, you cannot do this as a member functions, since in C++, enum types cannot have member functions. So you have to overload it as a free function. And \u0026lt;code\u0026gt;operator\u0026amp;lt;()\u0026lt;/code\u0026gt; for a class template nested within a class template is much easier to write and read when done as a member function inline in the class definition. But these are indeed rare exceptions.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;(However, \u0026lt;em\u0026gt;if\u0026lt;/em\u0026gt; you make an exception, do not forget the issue of \u0026lt;code\u0026gt;const\u0026lt;/code\u0026gt;-ness for the operand that, for member functions, becomes the implicit \u0026lt;code\u0026gt;this\u0026lt;/code\u0026gt; argument. If the operator as a non-member function would take its left-most argument as a \u0026lt;code\u0026gt;const\u0026lt;/code\u0026gt; reference, the same operator as a member function needs to have a \u0026lt;code\u0026gt;const\u0026lt;/code\u0026gt; at the end to make \u0026lt;code\u0026gt;*this\u0026lt;/code\u0026gt; a \u0026lt;code\u0026gt;const\u0026lt;/code\u0026gt; reference.)\u0026lt;/p\u0026gt;\n\u0026lt;hr\u0026gt;\n\u0026lt;p\u0026gt;Continue to \u0026lt;a href=\u0026quot;https://stackoverflow.com/questions/4421706/operator-overloading-in-c/4421719#4421719\u0026quot;\u0026gt;Common operators to overload\u0026lt;/a\u0026gt;.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;h1\u0026gt;The General Syntax of operator overloading in C++\u0026lt;/h1\u0026gt;\n\u0026lt;p\u0026gt;You cannot change the meaning of operators for built-in types in C++, operators can only be overloaded for user-defined types\u0026lt;sup\u0026gt;1\u0026lt;/sup\u0026gt;. That is, at least one of the operands has to be of a user-defined type. As with other overloaded functions, operators can be overloaded for a certain set of parameters only once.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Not all operators can be overloaded in C++. Among the operators that cannot be overloaded are: \u0026lt;code\u0026gt;.\u0026lt;/code\u0026gt; \u0026lt;code\u0026gt;::\u0026lt;/code\u0026gt; \u0026lt;code\u0026gt;sizeof\u0026lt;/code\u0026gt; \u0026lt;code\u0026gt;typeid\u0026lt;/code\u0026gt; \u0026lt;code\u0026gt;.*\u0026lt;/code\u0026gt; and the only ternary operator in C++, \u0026lt;code\u0026gt;?:\u0026lt;/code\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Among the operators that can be overloaded in C++ are these:\u0026lt;/p\u0026gt;\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;arithmetic operators: \u0026lt;code\u0026gt;+\u0026lt;/code\u0026gt; \u0026lt;code\u0026gt;-\u0026lt;/code\u0026gt; \u0026lt;code\u0026gt;*\u0026lt;/code\u0026gt; \u0026lt;code\u0026gt;/\u0026lt;/code\u0026gt; \u0026lt;code\u0026gt;%\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;+=\u0026lt;/code\u0026gt; \u0026lt;code\u0026gt;-=\u0026lt;/code\u0026gt; \u0026lt;code\u0026gt;*=\u0026lt;/code\u0026gt; \u0026lt;code\u0026gt;/=\u0026lt;/code\u0026gt; \u0026lt;code\u0026gt;%=\u0026lt;/code\u0026gt; (all binary infix); \u0026lt;code\u0026gt;+\u0026lt;/code\u0026gt; \u0026lt;code\u0026gt;-\u0026lt;/code\u0026gt; (unary prefix); \u0026lt;code\u0026gt;++\u0026lt;/code\u0026gt; \u0026lt;code\u0026gt;--\u0026lt;/code\u0026gt; (unary prefix and postfix)\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;bit manipulation: \u0026lt;code\u0026gt;\u0026amp;amp;\u0026lt;/code\u0026gt; \u0026lt;code\u0026gt;|\u0026lt;/code\u0026gt; \u0026lt;code\u0026gt;^\u0026lt;/code\u0026gt; \u0026lt;code\u0026gt;\u0026amp;lt;\u0026amp;lt;\u0026lt;/code\u0026gt; \u0026lt;code\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;\u0026amp;amp;=\u0026lt;/code\u0026gt; \u0026lt;code\u0026gt;|=\u0026lt;/code\u0026gt; \u0026lt;code\u0026gt;^=\u0026lt;/code\u0026gt; \u0026lt;code\u0026gt;\u0026amp;lt;\u0026amp;lt;=\u0026lt;/code\u0026gt; \u0026lt;code\u0026gt;\u0026amp;gt;\u0026amp;gt;=\u0026lt;/code\u0026gt; (all binary infix); \u0026lt;code\u0026gt;~\u0026lt;/code\u0026gt; (unary prefix)\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;boolean algebra: \u0026lt;code\u0026gt;==\u0026lt;/code\u0026gt; \u0026lt;code\u0026gt;!=\u0026lt;/code\u0026gt; \u0026lt;code\u0026gt;\u0026amp;lt;\u0026lt;/code\u0026gt; \u0026lt;code\u0026gt;\u0026amp;gt;\u0026lt;/code\u0026gt; \u0026lt;code\u0026gt;\u0026amp;lt;=\u0026lt;/code\u0026gt; \u0026lt;code\u0026gt;\u0026amp;gt;=\u0026lt;/code\u0026gt; \u0026lt;code\u0026gt;||\u0026lt;/code\u0026gt; \u0026lt;code\u0026gt;\u0026amp;amp;\u0026amp;amp;\u0026lt;/code\u0026gt; (all binary infix); \u0026lt;code\u0026gt;!\u0026lt;/code\u0026gt; (unary prefix)\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;memory management: \u0026lt;code\u0026gt;new\u0026lt;/code\u0026gt; \u0026lt;code\u0026gt;new[]\u0026lt;/code\u0026gt; \u0026lt;code\u0026gt;delete\u0026lt;/code\u0026gt; \u0026lt;code\u0026gt;delete[]\u0026lt;/code\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;implicit conversion operators\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;miscellany: \u0026lt;code\u0026gt;=\u0026lt;/code\u0026gt; \u0026lt;code\u0026gt;[]\u0026lt;/code\u0026gt; \u0026lt;code\u0026gt;-\u0026amp;gt;\u0026lt;/code\u0026gt; \u0026lt;code\u0026gt;-\u0026amp;gt;*\u0026lt;/code\u0026gt; \u0026lt;code\u0026gt;,\u0026lt;/code\u0026gt;  (all binary infix); \u0026lt;code\u0026gt;*\u0026lt;/code\u0026gt; \u0026lt;code\u0026gt;\u0026amp;amp;\u0026lt;/code\u0026gt; (all unary prefix) \u0026lt;code\u0026gt;()\u0026lt;/code\u0026gt; (function call, n-ary infix)\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;p\u0026gt;However, the fact that you \u0026lt;em\u0026gt;can\u0026lt;/em\u0026gt; overload all of these does not mean you \u0026lt;em\u0026gt;should\u0026lt;/em\u0026gt; do so. See the basic rules of operator overloading.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;In C++, operators are overloaded in the form of \u0026lt;em\u0026gt;\u0026lt;strong\u0026gt;functions with special names\u0026lt;/strong\u0026gt;\u0026lt;/em\u0026gt;. As with other functions, overloaded operators can generally be implemented either as a \u0026lt;em\u0026gt;\u0026lt;strong\u0026gt;member function of their left operand\u0026apos;s type\u0026lt;/strong\u0026gt;\u0026lt;/em\u0026gt; or as \u0026lt;em\u0026gt;\u0026lt;strong\u0026gt;non-member functions\u0026lt;/strong\u0026gt;\u0026lt;/em\u0026gt;. Whether you are free to choose or bound to use either one depends on several criteria.\u0026lt;sup\u0026gt;2\u0026lt;/sup\u0026gt; A unary operator \u0026lt;code\u0026gt;@\u0026lt;/code\u0026gt;\u0026lt;sup\u0026gt;3\u0026lt;/sup\u0026gt;, applied to an object x, is invoked either as \u0026lt;code\u0026gt;operator@(x)\u0026lt;/code\u0026gt; or as \u0026lt;code\u0026gt;x.operator@()\u0026lt;/code\u0026gt;. A binary infix operator \u0026lt;code\u0026gt;@\u0026lt;/code\u0026gt;, applied to the objects \u0026lt;code\u0026gt;x\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;y\u0026lt;/code\u0026gt;, is called either as \u0026lt;code\u0026gt;operator@(x,y)\u0026lt;/code\u0026gt; or as \u0026lt;code\u0026gt;x.operator@(y)\u0026lt;/code\u0026gt;.\u0026lt;sup\u0026gt;4\u0026lt;/sup\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Operators that are implemented as non-member functions are sometimes friend of their operands type.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;sup\u0026gt;1\u0026lt;/sup\u0026gt; \u0026lt;sub\u0026gt;The term user-defined might be slightly misleading. C++ makes the distinction between built-in types and user-defined types. To the former belong for example int, char, and double; to the latter belong all struct, class, union, and enum types, including those from the standard library, even though they are not, as such, defined by users.\u0026lt;/sub\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;sup\u0026gt;2\u0026lt;/sup\u0026gt; \u0026lt;sub\u0026gt;This is covered in \u0026lt;a href=\u0026quot;https://stackoverflow.com/questions/4421706/operator-overloading/4421729#4421729\u0026quot;\u0026gt;a later part\u0026lt;/a\u0026gt; of this FAQ.\u0026lt;/sub\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;sup\u0026gt;3\u0026lt;/sup\u0026gt; \u0026lt;sub\u0026gt;The \u0026lt;code\u0026gt;@\u0026lt;/code\u0026gt; is not a valid operator in C++ which is why I use it as a placeholder.\u0026lt;/sub\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;sup\u0026gt;4\u0026lt;/sup\u0026gt; \u0026lt;sub\u0026gt;The only ternary operator in C++ cannot be overloaded and the only n-ary operator must always be implemented as a member function.\u0026lt;/sub\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;hr\u0026gt;\n\u0026lt;p\u0026gt;Continue to \u0026lt;a href=\u0026quot;https://stackoverflow.com/questions/4421706/operator-overloading-in-c/4421708#4421708\u0026quot;\u0026gt;The Three Basic Rules of Operator Overloading in C++\u0026lt;/a\u0026gt;.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;h1\u0026gt;Conversion Operators (also known as User Defined Conversions)\u0026lt;/h1\u0026gt;\n\n\u0026lt;p\u0026gt;In C++ you can create conversion operators, operators that allow the compiler to convert between your types and other defined types.  There are two types of conversion operators, implicit and explicit ones.\u0026lt;/p\u0026gt;\n\n\u0026lt;h2\u0026gt;Implicit Conversion Operators (C++98/C++03 and C++11)\u0026lt;/h2\u0026gt;\n\n\u0026lt;p\u0026gt;An implicit conversion operator allows the compiler to implicitly convert (like the conversion between \u0026lt;code\u0026gt;int\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;long\u0026lt;/code\u0026gt;) the value of a user-defined type to some other type.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;The following is a simple class with an implicit conversion operator:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;my_string\u0026lt;/span\u0026gt; {\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt;:\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;operator\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt;*() \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; {\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; data_;} \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// This is the conversion operator\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;private\u0026lt;/span\u0026gt;:\n  \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt;* data_;\n};\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Implicit conversion operators, like one-argument constructors, are user-defined conversions. Compilers will grant one user-defined conversion when trying to match a call to an overloaded function.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;f\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt;*)\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;;\n\nmy_string str;\n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;f\u0026lt;/span\u0026gt;(str); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// same as f( str.operator const char*() )\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;At first this seems very helpful, but the problem with this is that the implicit conversion even kicks in when it isnt expected to. In the following code, \u0026lt;code\u0026gt;void f(const char*)\u0026lt;/code\u0026gt; will be called because \u0026lt;code\u0026gt;my_string()\u0026lt;/code\u0026gt; is not an \u0026lt;a href=\u0026quot;https://stackoverflow.com/questions/3601602/what-are-rvalues-lvalues-xvalues-glvalues-and-prvalues\u0026quot;\u0026gt;lvalue\u0026lt;/a\u0026gt;, so the first does not match:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;f\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(my_string\u0026amp;amp;)\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;;\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;f\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt;*)\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;;\n\n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;f\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;my_string\u0026lt;/span\u0026gt;());\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Beginners easily get this wrong and even experienced C++ programmers are sometimes surprised because the compiler picks an overload they didnt suspect.  These problems can be mitigated by explicit conversion operators.\u0026lt;/p\u0026gt;\n\n\u0026lt;h2\u0026gt;Explicit Conversion Operators (C++11)\u0026lt;/h2\u0026gt;\n\n\u0026lt;p\u0026gt;Unlike implicit conversion operators, explicit conversion operators will never kick in when you don\u0026apos;t expect them to.  The following is a simple class with an explicit conversion operator:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;my_string\u0026lt;/span\u0026gt; {\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt;:\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;explicit\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;operator\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt;*() \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; {\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; data_;}\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;private\u0026lt;/span\u0026gt;:\n  \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt;* data_;\n};\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Notice the \u0026lt;code\u0026gt;explicit\u0026lt;/code\u0026gt;.  Now when you try to execute the unexpected code from the implicit conversion operators, you get a compiler error:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre\u0026gt;prog.cpp: In function int main():\nprog.cpp:15:18: error: no matching function for call to f(my_string)\nprog.cpp:15:18: note: candidates are:\nprog.cpp:11:10: note: void f(my_string\u0026amp;amp;)\nprog.cpp:11:10: note:   no known conversion for argument 1 from my_string to my_string\u0026amp;amp;\nprog.cpp:12:10: note: void f(const char*)\nprog.cpp:12:10: note:   no known conversion for argument 1 from my_string to const char*\n\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;To invoke the explicit cast operator, you have to use \u0026lt;code\u0026gt;static_cast\u0026lt;/code\u0026gt;, a C-style cast, or a constructor style cast ( i.e. \u0026lt;code\u0026gt;T(value)\u0026lt;/code\u0026gt; ).  \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;However, there is one exception to this:  The compiler is allowed to implicitly convert to \u0026lt;code\u0026gt;bool\u0026lt;/code\u0026gt;.  In addition, the compiler is not allowed to do another implicit conversion after it converts to \u0026lt;code\u0026gt;bool\u0026lt;/code\u0026gt; (a compiler is allowed to do 2 implicit conversions at a time, but only 1 user-defined conversion at max).  \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Because the compiler will not cast \u0026quot;past\u0026quot; \u0026lt;code\u0026gt;bool\u0026lt;/code\u0026gt;, explicit conversion operators now remove the need for the \u0026lt;a href=\u0026quot;http://en.wikibooks.org/wiki/More_C%2B%2B_Idioms/Safe_bool\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;Safe Bool idiom\u0026lt;/a\u0026gt;.   For example, smart pointers before C++11 used the Safe Bool idiom to prevent conversions to integral types.  In C++11, the smart pointers use an explicit operator instead because the compiler is not allowed to implicitly convert to an integral type after it explicitly converted a type to bool.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Continue to \u0026lt;a href=\u0026quot;https://stackoverflow.com/questions/4421706/operator-overloading-in-c/4421791#4421791\u0026quot;\u0026gt;Overloading \u0026lt;code\u0026gt;new\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;delete\u0026lt;/code\u0026gt;\u0026lt;/a\u0026gt;.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;h1\u0026gt;Overloading \u0026lt;code\u0026gt;new\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;delete\u0026lt;/code\u0026gt; operators\u0026lt;/h1\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;sup\u0026gt;\u0026lt;em\u0026gt;\u0026lt;strong\u0026gt;Note:\u0026lt;/strong\u0026gt;\u0026lt;/em\u0026gt; This only deals with the \u0026lt;em\u0026gt;\u0026lt;strong\u0026gt;syntax\u0026lt;/strong\u0026gt;\u0026lt;/em\u0026gt; of overloading \u0026lt;code\u0026gt;new\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;delete\u0026lt;/code\u0026gt;, not with the \u0026lt;em\u0026gt;\u0026lt;strong\u0026gt;implementation\u0026lt;/strong\u0026gt;\u0026lt;/em\u0026gt; of such overloaded operators. I think that the semantics of overloading \u0026lt;em\u0026gt;\u0026lt;strong\u0026gt;\u0026lt;a href=\u0026quot;https://stackoverflow.com/questions/7149461/\u0026quot;\u0026gt;\u0026lt;code\u0026gt;new\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;delete\u0026lt;/code\u0026gt; deserve their own FAQ\u0026lt;/a\u0026gt;\u0026lt;/strong\u0026gt;\u0026lt;/em\u0026gt;, within the topic of operator overloading I can never do it justice.\u0026lt;/sup\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;h2\u0026gt;Basics\u0026lt;/h2\u0026gt;\n\u0026lt;p\u0026gt;In C++, when you write a \u0026lt;em\u0026gt;\u0026lt;strong\u0026gt;new expression\u0026lt;/strong\u0026gt;\u0026lt;/em\u0026gt; like \u0026lt;code\u0026gt;new T(arg)\u0026lt;/code\u0026gt; two things happen when this expression is evaluated: First \u0026lt;em\u0026gt;\u0026lt;strong\u0026gt;\u0026lt;code\u0026gt;operator new\u0026lt;/code\u0026gt;\u0026lt;/strong\u0026gt;\u0026lt;/em\u0026gt; is invoked to obtain raw memory, and then the appropriate constructor of \u0026lt;code\u0026gt;T\u0026lt;/code\u0026gt; is invoked to turn this raw memory into a valid object. Likewise, when you delete an object, first its destructor is called, and then the memory is returned to \u0026lt;code\u0026gt;operator delete\u0026lt;/code\u0026gt;.\u0026lt;br\u0026gt;\nC++ allows you to tune both of these operations: memory management and the construction/destruction of the object at the allocated memory. The latter is done by writing constructors and destructors for a class. Fine-tuning memory management is done by writing your own \u0026lt;code\u0026gt;operator new\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;operator delete\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;The first of the basic rules of operator overloading  \u0026lt;em\u0026gt;dont do it\u0026lt;/em\u0026gt;  applies especially to overloading \u0026lt;code\u0026gt;new\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;delete\u0026lt;/code\u0026gt;. Almost the only reasons to overload these operators are \u0026lt;em\u0026gt;\u0026lt;strong\u0026gt;performance problems\u0026lt;/strong\u0026gt;\u0026lt;/em\u0026gt; and \u0026lt;em\u0026gt;\u0026lt;strong\u0026gt;memory constraints\u0026lt;/strong\u0026gt;\u0026lt;/em\u0026gt;, and in many cases, other actions, like \u0026lt;em\u0026gt;changes to the algorithms\u0026lt;/em\u0026gt; used, will provide a much \u0026lt;em\u0026gt;\u0026lt;strong\u0026gt;higher cost/gain ratio\u0026lt;/strong\u0026gt;\u0026lt;/em\u0026gt; than attempting to tweak memory management.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;The C++ standard library comes with a set of predefined \u0026lt;code\u0026gt;new\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;delete\u0026lt;/code\u0026gt; operators. The most important ones are these:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt;* \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;operator\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(std::\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;size_t\u0026lt;/span\u0026gt;)\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;throw\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(std::bad_alloc)\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;; \n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt;  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;operator\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;delete\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt;*)\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;throw\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;; \n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt;* \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;operator\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt;[](std::\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;size_t\u0026lt;/span\u0026gt;) \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;throw\u0026lt;/span\u0026gt;(std::bad_alloc); \n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt;  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;operator\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;delete\u0026lt;/span\u0026gt;[](\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt;*) \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;throw\u0026lt;/span\u0026gt;(); \n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;The first two allocate/deallocate memory for an object, the latter two for an array of objects. If you provide your own versions of these, they will \u0026lt;em\u0026gt;\u0026lt;strong\u0026gt;not overload, but replace\u0026lt;/strong\u0026gt;\u0026lt;/em\u0026gt; the ones from the standard library.\u0026lt;br\u0026gt;\nIf you overload \u0026lt;code\u0026gt;operator new\u0026lt;/code\u0026gt;, you should always also overload the matching \u0026lt;code\u0026gt;operator delete\u0026lt;/code\u0026gt;, even if you never intend to call it. The reason is that, if a constructor throws during the evaluation of a new expression, the run-time system will return the memory to the \u0026lt;code\u0026gt;operator delete\u0026lt;/code\u0026gt; matching the \u0026lt;code\u0026gt;operator new\u0026lt;/code\u0026gt; that was called to allocate the memory to create the object in. If you do not provide a matching \u0026lt;code\u0026gt;operator delete\u0026lt;/code\u0026gt;, the default one is called, which is almost always wrong.\u0026lt;br\u0026gt;\nIf you overload \u0026lt;code\u0026gt;new\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;delete\u0026lt;/code\u0026gt;, you should consider overloading the array variants, too.\u0026lt;/p\u0026gt;\n\u0026lt;h2\u0026gt;Placement \u0026lt;code\u0026gt;new\u0026lt;/code\u0026gt;\u0026lt;/h2\u0026gt;\n\u0026lt;p\u0026gt;C++ allows new and delete operators to take additional arguments.\u0026lt;br\u0026gt;\nSo-called placement new allows you to create an object at a certain address which is passed to:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;X\u0026lt;/span\u0026gt; { \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;/* ... */\u0026lt;/span\u0026gt; };\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; buffer[ \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;sizeof\u0026lt;/span\u0026gt;(X) ];\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;f\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt;\n\u0026lt;/span\u0026gt;{ \n  X* p = \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt;(buffer) \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;X\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;/*...*/\u0026lt;/span\u0026gt;);\n  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// ... \u0026lt;/span\u0026gt;\n  p-\u0026amp;gt;~\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;X\u0026lt;/span\u0026gt;(); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// call destructor \u0026lt;/span\u0026gt;\n} \n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;The standard library comes with the appropriate overloads of the new and delete operators for this:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt;* \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;operator\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(std::\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;size_t\u0026lt;/span\u0026gt;,\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt;* p)\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;throw\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(std::bad_alloc)\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;; \n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt;  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;operator\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;delete\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt;* p,\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt;*)\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;throw\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;; \n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt;* \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;operator\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt;[](std::\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;size_t\u0026lt;/span\u0026gt;,\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt;* p) \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;throw\u0026lt;/span\u0026gt;(std::bad_alloc); \n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt;  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;operator\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;delete\u0026lt;/span\u0026gt;[](\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt;* p,\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt;*) \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;throw\u0026lt;/span\u0026gt;(); \n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;Note that, in the example code for placement new given above, \u0026lt;code\u0026gt;operator delete\u0026lt;/code\u0026gt; is never called, unless the constructor of X throws an exception.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;You can also overload \u0026lt;code\u0026gt;new\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;delete\u0026lt;/code\u0026gt; with other arguments. As with the additional argument for placement new, these arguments are also listed within parentheses after the keyword \u0026lt;code\u0026gt;new\u0026lt;/code\u0026gt;. Merely for historical reasons, such variants are often also called placement new, even if their arguments are not for placing an object at a specific address.\u0026lt;/p\u0026gt;\n\u0026lt;h2\u0026gt;Class-specific new and delete\u0026lt;/h2\u0026gt;\n\u0026lt;p\u0026gt;Most commonly you will want to fine-tune memory management because measurement has shown that instances of a specific class, or of a group of related classes, are created and destroyed often and that the default memory management of the run-time system, tuned for general performance, deals inefficiently in this specific case. To improve this, you can overload new and delete for a specific class:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;my_class\u0026lt;/span\u0026gt; { \n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt;: \n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// ... \u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt;* \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;operator\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(std::\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;size_t\u0026lt;/span\u0026gt;)\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;;\n    \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt;  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;operator\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;delete\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt;*)\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;;\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt;* \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;operator\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt;[](std::\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;size_t\u0026lt;/span\u0026gt;);\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt;  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;operator\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;delete\u0026lt;/span\u0026gt;[](\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt;*);\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// ...  \u0026lt;/span\u0026gt;\n}; \n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;Overloaded thus, new and delete behave like static member functions. For objects of \u0026lt;code\u0026gt;my_class\u0026lt;/code\u0026gt;, the \u0026lt;code\u0026gt;std::size_t\u0026lt;/code\u0026gt; argument will always be \u0026lt;code\u0026gt;sizeof(my_class)\u0026lt;/code\u0026gt;. However, these operators are also called for dynamically allocated objects of \u0026lt;em\u0026gt;\u0026lt;strong\u0026gt;derived classes\u0026lt;/strong\u0026gt;\u0026lt;/em\u0026gt;, in which case it might be greater than that.\u0026lt;/p\u0026gt;\n\u0026lt;h2\u0026gt;Global new and delete\u0026lt;/h2\u0026gt;\n\u0026lt;p\u0026gt;To overload the global new and delete, simply replace the pre-defined operators of the standard library with our own. However, this rarely ever needs to be done.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;\u0026lt;a href=\u0026quot;https://stackoverflow.com/questions/34953523/overloading-the-insertion-operator-questions-theoretical\u0026quot;\u0026gt;Why can\u0026apos;t \u0026lt;code\u0026gt;operator\u0026amp;lt;\u0026amp;lt;\u0026lt;/code\u0026gt; function for streaming objects to \u0026lt;code\u0026gt;std::cout\u0026lt;/code\u0026gt; or to a file be a member function?\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Let\u0026apos;s say you have:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Foo\u0026lt;/span\u0026gt;\n{\n   \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; a;\n   \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;double\u0026lt;/span\u0026gt; b;\n\n   std::ostream\u0026amp;amp; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;operator\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026amp;lt;(std::ostream\u0026amp;amp; out) \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt;\n   {\n      \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; out \u0026amp;lt;\u0026amp;lt; a \u0026amp;lt;\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot; \u0026quot;\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026amp;lt; b;\n   }\n};\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Given that, you cannot use:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;Foo f = {\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;10\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;20.0\u0026lt;/span\u0026gt;};\nstd::cout \u0026amp;lt;\u0026amp;lt; f;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Since \u0026lt;code\u0026gt;operator\u0026amp;lt;\u0026amp;lt;\u0026lt;/code\u0026gt; is overloaded as a member function of \u0026lt;code\u0026gt;Foo\u0026lt;/code\u0026gt;, the LHS of the operator must be a \u0026lt;code\u0026gt;Foo\u0026lt;/code\u0026gt; object. Which means, you will be required to use:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;Foo f = {\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;10\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;20.0\u0026lt;/span\u0026gt;};\nf \u0026amp;lt;\u0026amp;lt; std::cout\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;which is very non-intuitive.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;If you define it as a non-member function,\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Foo\u0026lt;/span\u0026gt;\n{\n   \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; a;\n   \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;double\u0026lt;/span\u0026gt; b;\n};\n\nstd::ostream\u0026amp;amp; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;operator\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026amp;lt;(std::ostream\u0026amp;amp; out, Foo \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt;\u0026amp;amp; f)\n{\n   \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; out \u0026amp;lt;\u0026amp;lt; f.a \u0026amp;lt;\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot; \u0026quot;\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026amp;lt; f.b;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;You will be able to use:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;Foo f = {\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;10\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;20.0\u0026lt;/span\u0026gt;};\nstd::cout \u0026amp;lt;\u0026amp;lt; f;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;which is very intuitive.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Making it short and simple, I\u0026apos;ll be referring to some points, which I had come over the past week as I was learning Python and C++, oops and other things, so it goes as follows:\u0026lt;/p\u0026gt;\n\u0026lt;ol\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;The Arity of the operator can not be modified further than to what it is!\u0026lt;/p\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;Overloaded operators can only have one default argument which the function call operator rest it cannot.\u0026lt;/p\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;Only built in operator can be overloaded, rest can\u0026apos;t!\u0026lt;/p\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;/ol\u0026gt;\n\u0026lt;p\u0026gt;For more info, you can refer to the following link, which redirects you to the documentation provided by GeekforGeeks.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;a href=\u0026quot;https://www.geeksforgeeks.org/g-fact-39/\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;https://www.geeksforgeeks.org/g-fact-39/\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n    "],"id":61,"title":"What are the basic rules and idioms for operator overloading?","content":"\n                \n\u0026lt;p\u0026gt;Note: The answers were given in \u0026lt;em\u0026gt;a specific order\u0026lt;/em\u0026gt;, but since many users sort answers according to votes, rather than the time they were given, here\u0026apos;s an \u0026lt;em\u0026gt;\u0026lt;strong\u0026gt;index of the answers\u0026lt;/strong\u0026gt;\u0026lt;/em\u0026gt; in the order in which they make the most sense:\u0026lt;/p\u0026gt;\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;a href=\u0026quot;https://stackoverflow.com/questions/4421706/operator-overloading-in-c/4421715#4421715\u0026quot;\u0026gt;The General Syntax of operator overloading in C++\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;a href=\u0026quot;https://stackoverflow.com/questions/4421706/operator-overloading-in-c/4421708#4421708\u0026quot;\u0026gt;The Three Basic Rules of Operator Overloading in C++\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;a href=\u0026quot;https://stackoverflow.com/questions/4421706/operator-overloading-in-c/4421729#4421729\u0026quot;\u0026gt;The Decision between Member and Non-member\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;a href=\u0026quot;https://stackoverflow.com/questions/4421706/operator-overloading-in-c/4421719#4421719\u0026quot;\u0026gt;Common operators to overload\u0026lt;/a\u0026gt;\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;Assignment Operator\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Input and Output Operators\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Function call operator\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Comparison operators\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Arithmetic Operators\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Array Subscripting\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Operators for Pointer-like Types\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;a href=\u0026quot;https://stackoverflow.com/questions/4421706/operator-overloading/16615725#16615725\u0026quot;\u0026gt;Conversion Operators\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;a href=\u0026quot;https://stackoverflow.com/questions/4421706/operator-overloading-in-c/4421791#4421791\u0026quot;\u0026gt;Overloading new and delete\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;sub\u0026gt;\u0026lt;em\u0026gt;(Note: This is meant to be an entry to \u0026lt;a href=\u0026quot;https://stackoverflow.com/questions/tagged/c++-faq\u0026quot;\u0026gt;Stack Overflow\u0026apos;s C++ FAQ\u0026lt;/a\u0026gt;. If you want to critique the idea of providing an FAQ in this form, then \u0026lt;a href=\u0026quot;https://meta.stackexchange.com/questions/68647/setting-up-a-faq-for-the-c-tag\u0026quot;\u0026gt;the posting on meta that started all this\u0026lt;/a\u0026gt; would be the place to do that. Answers to that question are monitored in the \u0026lt;a href=\u0026quot;https://chat.stackoverflow.com/rooms/10/c-lounge\u0026quot;\u0026gt;C++ chatroom\u0026lt;/a\u0026gt;, where the FAQ idea started in the first place, so your answer is very likely to get read by those who came up with the idea.)\u0026lt;/em\u0026gt;\n\u0026lt;/sub\u0026gt;\u0026lt;/p\u0026gt;\n    ","slug":"what-are-the-basic-rules-and-idioms-for-operator-overloading-1657384449752","postType":"QUESTION","createdAt":"2022-07-09T16:34:09.000Z","updatedAt":"2022-07-09T16:34:09.000Z","tags":[{"id":221,"name":"operators","slug":"operators","createdAt":"2022-07-09T16:34:09.000Z","updatedAt":"2022-07-09T16:34:09.000Z","Questions_Tags":{"questionId":61,"tagId":221}},{"id":222,"name":"operator-overloading","slug":"operator-overloading","createdAt":"2022-07-09T16:34:09.000Z","updatedAt":"2022-07-09T16:34:09.000Z","Questions_Tags":{"questionId":61,"tagId":222}}],"relatedQuestions":[{"title":"What are the basic rules and idioms for operator overloading?","slug":"what-are-the-basic-rules-and-idioms-for-operator-overloading-1657384449752","tags":[{"name":"operators","Questions_Tags":{"questionId":61,"tagId":221}},{"name":"operator-overloading","Questions_Tags":{"questionId":61,"tagId":222}}]}]},"randomQuestions":[{"title":"Reference: mod_rewrite, URL rewriting and \"pretty links\" explained","slug":"reference:-mod_rewrite-url-rewriting-and-\"pretty-links\"-explained-1657384905504"},{"title":"What is the difference between \"INNER JOIN\" and \"OUTER JOIN\"?","slug":"what-is-the-difference-between-\"inner-join\"-and-\"outer-join\"-1657387501982"},{"title":"Is there a \"previous sibling\" selector?","slug":"is-there-a-\"previous-sibling\"-selector-1657384771067"},{"title":"How do I use arrays in C++?","slug":"how-do-i-use-arrays-in-c++-1657387456118"},{"title":"What is ViewModel in MVC?","slug":"what-is-viewmodel-in-mvc-1657387451244"},{"title":"Useless use of cat?","slug":"useless-use-of-cat-1657388390794"},{"title":"How to get all possible combinations of a list’s elements?","slug":"how-to-get-all-possible-combinations-of-a-list's-elements-1657388271070"},{"title":"Why don't flex items shrink past content size?","slug":"why-don't-flex-items-shrink-past-content-size-1657384687282"},{"title":"Do DOM tree elements with IDs become global properties?","slug":"do-dom-tree-elements-with-ids-become-global-properties-1657387475110"},{"title":"What is The Rule of Three?","slug":"what-is-the-rule-of-three-1657384390295"},{"title":"With arrays, why is it the case that a[5] == 5[a]?","slug":"with-arrays-why-is-it-the-case-that-a5-5a-1657387956216"},{"title":"commandButton/commandLink/ajax action/listener method not invoked or input value not set/updated","slug":"commandbuttoncommandlinkajax-actionlistener-method-not-invoked-or-input-value-not-setupdated-1657384667519"},{"title":"What is the difference between a definition and a declaration?","slug":"what-is-the-difference-between-a-definition-and-a-declaration-1657387851618"},{"title":"How can I access the contents of an iframe with JavaScript/jQuery?","slug":"how-can-i-access-the-contents-of-an-iframe-with-javascriptjquery-1657388369923"},{"title":"Is there a unique Android device ID?","slug":"is-there-a-unique-android-device-id-1657388089268"},{"title":"How to find the 'sizeof' (a pointer pointing to an array)?","slug":"how-to-find-the-'sizeof'-(a-pointer-pointing-to-an-array)-1657387354284"},{"title":"Strange result when removing item from a list while iterating over it [duplicate]","slug":"strange-result-when-removing-item-from-a-list-while-iterating-over-it-duplicate-1657387735759"},{"title":"What should main() return in C and C++?","slug":"what-should-main()-return-in-c-and-c++-1657384745630"},{"title":"Why does \"a == x or y or z\" always evaluate to True?","slug":"why-does-\"a-x-or-y-or-z\"-always-evaluate-to-true-1657384855216"},{"title":"How to store objects in HTML5 localStorage","slug":"how-to-store-objects-in-html5-localstorage-1657387568907"}]},"__N_SSG":true},"page":"/questions/[slug]","query":{"slug":"what-are-the-basic-rules-and-idioms-for-operator-overloading-1657384449752"},"buildId":"6ctJfCympFH_chh5mjicD","isFallback":false,"gsp":true,"locale":"en","locales":["en"],"defaultLocale":"en","scriptLoader":[]}</script></body></html>