<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><meta name="twitter:card" content="summary_large_image"/><meta name="twitter:site" content="@solutionschecker.com"/><meta name="twitter:creator" content="@solutionschecker.com"/><meta property="og:url" content="https://solutionschecker.com"/><meta property="og:type" content="website"/><meta property="og:image" content="https://solutionschecker.com/solutions-checker-banner.png"/><meta property="og:image:alt" content="Find the solution to any question. We focus on finding the fastest possible solution for users. Main topics like coding, learning. - solutionschecker.com"/><link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png"/><link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png"/><link rel="manifest" href="/site.webmanifest"/><script type="application/ld+json">{"@context":"https://schema.org","@type":"Organization","logo":"/logo.svg","url":"https://solutionschecker.com"}</script><link name="keywords" content="solutions checker, solution checker, how to, solution for, check for solution, resolve question, what is, what solution for, find solution"/><script type="application/ld+json">{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"item":{"@id":"https://solutionschecker.com","name":"Home"}},{"@type":"ListItem","position":2,"item":{"@id":"https://solutionschecker.com/questions","name":"Questions"}},{"@type":"ListItem","position":3,"item":{"@id":"https://solutionschecker.com/questions/my-attempt-at-value-initialization-is-interpreted-as-a-function-declaration-and-why-doesn&apos;t-a-a(())-solve-it-1657388474057","name":"Questions"}}]}</script><title>My attempt at value initialization is interpreted as a function declaration, and why doesn&#x27;t A a(()); solve it? | Solution Checker</title><meta name="robots" content="index,follow"/><meta name="description" content="Among the many things Stack Overflow has taught me is what is known as the &quot;most vexing parse&quot;, which is classically demonstrated with a line such as

A a(B()); //declares a function


While this, for most, intuitively appears to be the declaration of an object a of type A, taking a temporary B object as a constructor parameter, it&#x27;s actually a declaration of a function a returning an A, taking a pointer to a function which returns B and itself takes no parameters. Similarly the line

A a(); //declares a function


also falls under the same category, since instead of an object, it declares a function. Now, in the first case, the usual workaround for this issue is to add an extra set of brackets/parenthesis around the B(), as the compiler will then interpret it as the declaration of an object

A a((B())); //declares an object


However, in the second case, doing the same leads to a compile error

A a(()); //compile error


My question is, why? Yes I&#x27;m very well aware that the correct &#x27;workaround&#x27; is to change it to A a;, but I&#x27;m curious to know what it is that the extra () does for the compiler in the first example which then doesn&#x27;t work when reapplying it in the second example. Is the A a((B())); workaround a specific exception written into the standard?
    "/><meta property="og:title" content="My attempt at value initialization is interpreted as a function declaration, and why doesn&#x27;t A a(()); solve it? | Solution Checker"/><meta property="og:description" content="Among the many things Stack Overflow has taught me is what is known as the &quot;most vexing parse&quot;, which is classically demonstrated with a line such as

A a(B()); //declares a function


While this, for most, intuitively appears to be the declaration of an object a of type A, taking a temporary B object as a constructor parameter, it&#x27;s actually a declaration of a function a returning an A, taking a pointer to a function which returns B and itself takes no parameters. Similarly the line

A a(); //declares a function


also falls under the same category, since instead of an object, it declares a function. Now, in the first case, the usual workaround for this issue is to add an extra set of brackets/parenthesis around the B(), as the compiler will then interpret it as the declaration of an object

A a((B())); //declares an object


However, in the second case, doing the same leads to a compile error

A a(()); //compile error


My question is, why? Yes I&#x27;m very well aware that the correct &#x27;workaround&#x27; is to change it to A a;, but I&#x27;m curious to know what it is that the extra () does for the compiler in the first example which then doesn&#x27;t work when reapplying it in the second example. Is the A a((B())); workaround a specific exception written into the standard?
    "/><script type="application/ld+json">{"@context":"https://schema.org","@type":"QAPage","mainEntity":{"name":"My attempt at value initialization is interpreted as a function declaration, and why doesn&apos;t A a(()); solve it?","text":"Among the many things Stack Overflow has taught me is what is known as the &quot;most vexing parse&quot;, which is classically demonstrated with a line such as\n\nA a(B()); //declares a function\n\n\nWhile this, for most, intuitively appears to be the declaration of an object a of type A, taking a temporary B object as a constructor parameter, it&apos;s actually a declaration of a function a returning an A, taking a pointer to a function which returns B and itself takes no parameters. Similarly the line\n\nA a(); //declares a function\n\n\nalso falls under the same category, since instead of an object, it declares a function. Now, in the first case, the usual workaround for this issue is to add an extra set of brackets/parenthesis around the B(), as the compiler will then interpret it as the declaration of an object\n\nA a((B())); //declares an object\n\n\nHowever, in the second case, doing the same leads to a compile error\n\nA a(()); //compile error\n\n\nMy question is, why? Yes I&apos;m very well aware that the correct &apos;workaround&apos; is to change it to A a;, but I&apos;m curious to know what it is that the extra () does for the compiler in the first example which then doesn&apos;t work when reapplying it in the second example. Is the A a((B())); workaround a specific exception written into the standard?\n    ","answerCount":5,"upVoteCount":500,"suggestedAnswer":[{"text":"There is no enlightened answer, it&apos;s just because it&apos;s not defined as valid syntax by the C++ language...  So it is so, by definition of the language.\n\nIf you do have an expression within then it is valid.  For example:\n\n ((0));//compiles\n\n\nEven simpler put: because (x) is a valid C++ expression, while () is not. \n\nTo learn more about how languages are defined, and how compilers work, you should learn about Formal language theory or more specifically Context Free Grammars (CFG) and related material like finite state machines.  If you are interested in that though the wikipedia pages won&apos;t be enough, you&apos;ll have to get a book.\n    ","url":"https://solutionschecker.com/questions/my-attempt-at-value-initialization-is-interpreted-as-a-function-declaration-and-why-doesn&apos;t-a-a(())-solve-it-1657388474057#solution1","@type":"Answer","upvoteCount":0},{"text":"The final solution to this issue is to move to the C+11 uniform initialization syntax if you can.\n\nA a{};\n\n\nhttp://www.stroustrup.com/C++11FAQ.html#uniform-init\n    ","url":"https://solutionschecker.com/questions/my-attempt-at-value-initialization-is-interpreted-as-a-function-declaration-and-why-doesn&apos;t-a-a(())-solve-it-1657388474057#solution2","@type":"Answer","upvoteCount":0},{"text":"C function declarators\n\nFirst of all, there is C. In C, A a() is function declaration. For example, putchar has the following declaration. Normally, such declarations are stored in header files, however nothing stops you from writing them manually, if you know how the declaration of function looks like. The argument names are optional in declarations, so I omitted it in this example.\n\nint putchar(int);\n\n\nThis allows you to write the code like this.\n\nint puts(const char *);\nint main() {\n    puts(&quot;Hello, world!&quot;);\n}\n\n\nC also allows you to define functions that take functions as arguments, with nice readable syntax that looks like a function call (well, it&apos;s readable, as long you won&apos;t return a pointer to function).\n\n#include &lt;stdio.h&gt;\n\nint eighty_four() {\n    return 84;\n}\n\nint output_result(int callback()) {\n    printf(&quot;Returned: %d\\n&quot;, callback());\n    return 0;\n}\n\nint main() {\n    return output_result(eighty_four);\n}\n\n\nAs I mentioned, C allows omitting argument names in header files, therefore the output_result would look like this in header file.\n\nint output_result(int());\n\n\nOne argument in constructor\n\nDon&apos;t you recognize that one? Well, let me remind you.\n\nA a(B());\n\n\nYep, it&apos;s exactly the same function declaration. A is int, a is output_result, and B is int.\n\nYou can easily notice a conflict of C with new features of C++. To be exact, constructors being class name and parenthesis, and alternate declaration syntax with () instead of =. By design, C++ tries to be compatible with C code, and therefore it has to deal with this case - even if practically nobody cares. Therefore, old C features have priority over new C++ features. The grammar of declarations tries to match the name as function, before reverting to the new syntax with () if it fails.\n\nIf one of those features wouldn&apos;t exist, or had a different syntax (like {} in C++11), this issue would never have happened for syntax with one argument.\n\nNow you may ask why A a((B())) works. Well, let&apos;s declare output_result with useless parentheses.\n\nint output_result((int()));\n\n\nIt won&apos;t work. The grammar requires the variable to not be in parentheses.\n\n&lt;stdin&gt;:1:19: error: expected declaration specifiers or ... before ( token\n\n\nHowever, C++ expects standard expression here. In C++, you can write the following code.\n\nint value = int();\n\n\nAnd the following code.\n\nint value = ((((int()))));\n\n\nC++ expects expression inside inside parentheses to be... well... expression, as opposed to the type C expects. Parentheses don&apos;t mean anything here. However, by inserting useless parentheses, the C function declaration is not matched, and the new syntax can be matched properly (which simply expects an expression, such as 2 + 2).\n\nMore arguments in constructor\n\nSurely one argument is nice, but what about two? It&apos;s not that constructors may have just one argument. One of built-in classes which takes two arguments is std::string\n\nstd::string hundred_dots(100, &apos;.&apos;);\n\n\nThis is all well and fine (technically, it would have most vexing parse if it would be written as std::string wat(int(), char()), but let&apos;s be honest - who would write that? But let&apos;s assume this code has a vexing problem. You would assume that you have to put everything in parentheses.\n\nstd::string hundred_dots((100, &apos;.&apos;));\n\n\nNot quite so.\n\n&lt;stdin&gt;:2:36: error: invalid conversion from char to const char* [-fpermissive]\nIn file included from /usr/include/c++/4.8/string:53:0,\n                 from &lt;stdin&gt;:1:\n/usr/include/c++/4.8/bits/basic_string.tcc:212:5: error:   initializing argument 1 of std::basic_string&lt;_CharT, _Traits, _Alloc&gt;::basic_string(const _CharT*, const _Alloc&amp;) [with _CharT = char; _Traits = std::char_traits&lt;char&gt;; _Alloc = std::allocator&lt;char&gt;] [-fpermissive]\n     basic_string&lt;_CharT, _Traits, _Alloc&gt;::\n     ^\n\n\nI&apos;m not sure why g++ tries to convert char to const char *. Either way, the constructor was called with just one value of type char. There is no overload which has one argument of type char, therefore the compiler is confused. You may ask - why the argument is of type char?\n\n(100, &apos;.&apos;)\n\n\nYes, , here is a comma operator. The comma operator takes two arguments, and gives the right-side argument. It isn&apos;t really useful, but it&apos;s something to be known for my explanation.\n\nInstead, to solve the most vexing parse, the following code is needed.\n\nstd::string hundred_dots((100), (&apos;.&apos;));\n\n\nThe arguments are in parentheses, not the entire expression. In fact, just one of expressions needs to be in parentheses, as it&apos;s enough to break from the C grammar slightly to use the C++ feature. Things brings us to the point of zero arguments.\n\nZero arguments in constructor\n\nYou may have noticed the eighty_four function in my explanation.\n\nint eighty_four();\n\n\nYes, this is also affected by the most vexing parse. It&apos;s a valid definition, and one you most likely have seen if you created header files (and you should). Adding parentheses doesn&apos;t fix it.\n\nint eighty_four(());\n\n\nWhy is that so? Well, () is not an expression. In C++, you have to put an expression between parentheses. You cannot write auto value = () in C++, because () doesn&apos;t mean anything (and even if did, like empty tuple (see Python), it would be one argument, not zero). Practically that means you cannot use shorthand syntax without using C++11&apos;s {} syntax, as there are no expressions to put in parenthesis, and C grammar for function declarations will always apply.\n    ","url":"https://solutionschecker.com/questions/my-attempt-at-value-initialization-is-interpreted-as-a-function-declaration-and-why-doesn&apos;t-a-a(())-solve-it-1657388474057#solution3","@type":"Answer","upvoteCount":0},{"text":"You could instead\n\nA a(());\n\n\nuse\n\nA a=A();\n\n    ","url":"https://solutionschecker.com/questions/my-attempt-at-value-initialization-is-interpreted-as-a-function-declaration-and-why-doesn&apos;t-a-a(())-solve-it-1657388474057#solution4","@type":"Answer","upvoteCount":0},{"text":"The innermost parens in your example would be an expression, and in C++ the grammar defines an expression to be an assignment-expression or another expression followed by a comma and another assignment-expression (Appendix A.4 - Grammar summary/Expressions).\n\nThe grammar further defines an assignment-expression as one of several other types of expression, none of which can be nothing (or only whitespace).\n\nSo the reason you can&apos;t have A a(()) is simply because the grammar doesn&apos;t allow it.  However, I can&apos;t answer why the people who created C++ didn&apos;t allow this particular use of empty parens as some sort of special-case - I&apos;d guess that they&apos;d rather not put in such a special case if there was a reasonable alternative.\n    ","url":"https://solutionschecker.com/questions/my-attempt-at-value-initialization-is-interpreted-as-a-function-declaration-and-why-doesn&apos;t-a-a(())-solve-it-1657388474057#solution5","@type":"Answer","upvoteCount":0}],"@type":"Question"}}</script><meta name="next-head-count" content="22"/><script id="google-analytics" data-nscript="beforeInteractive">(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
})(window,document,'script','dataLayer','GTM-NXVLL8B');</script><link rel="preload" href="/_next/static/css/c116652e2d6f4ad0.css" as="style"/><link rel="stylesheet" href="/_next/static/css/c116652e2d6f4ad0.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-0d1b80a048d4787e.js"></script><script src="/_next/static/chunks/webpack-42cdea76c8170223.js" defer=""></script><script src="/_next/static/chunks/framework-4556c45dd113b893.js" defer=""></script><script src="/_next/static/chunks/main-ccfab947c79712f4.js" defer=""></script><script src="/_next/static/chunks/pages/_app-862498b6ec7885c3.js" defer=""></script><script src="/_next/static/chunks/294-106ef8570fa99deb.js" defer=""></script><script src="/_next/static/chunks/490-7f0418bb4354ac73.js" defer=""></script><script src="/_next/static/chunks/pages/questions/%5Bslug%5D-47289857226115f9.js" defer=""></script><script src="/_next/static/xZs8haGjOP63QuDE0kxeX/_buildManifest.js" defer=""></script><script src="/_next/static/xZs8haGjOP63QuDE0kxeX/_ssgManifest.js" defer=""></script></head><body><noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-NXVLL8B"
        height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript><div id="__next"><div class="wrapper"><header><nav class="bg-white border-gray-200 px-4 lg:px-6 py-2.5 dark:bg-gray-800"><div class="flex flex-wrap justify-between items-center mx-auto max-w-screen-xl"><a class="flex items-center" href="/"><img src="/logo-second.png" class="mr-3 h-6 sm:h-9" alt="Solution Checker Logo"/><h1 class="self-center text-xl font-semibold whitespace-nowrap dark:text-white">Solution Checker</h1></a><div class="flex items-center lg:order-2"><button data-collapse-toggle="mobile-menu-2" type="button" class="inline-flex items-center p-2 ml-1 text-sm text-gray-500 rounded-lg lg:hidden hover:bg-gray-100 focus:outline-none focus:ring-2 focus:ring-gray-200 dark:text-gray-400 dark:hover:bg-gray-700 dark:focus:ring-gray-600" aria-controls="mobile-menu-2" aria-expanded="false"><span class="sr-only">Open main menu</span><svg class="w-6 h-6" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M3 5a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM3 10a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM3 15a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1z" clip-rule="evenodd"></path></svg><svg class="hidden w-6 h-6" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z" clip-rule="evenodd"></path></svg></button></div><div class="hidden justify-between items-center w-full lg:flex lg:w-auto lg:order-1" id="mobile-menu-2"><ul class="flex flex-col mt-4 font-medium lg:flex-row lg:space-x-8 lg:mt-0"><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" aria-current="page" href="/">Home</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/questions?tab=news">Questions</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/post?tab=news">Post</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/questions/my-attempt-at-value-initialization-is-interpreted-as-a-function-declaration-and-why-doesn&#x27;t-a-a(())-solve-it-1657388474057#">Coding</a></li></ul></div></div></nav></header><div class="main-content"><div class="question my-5"><div class="flex question-header items-center m-auto justify-center"><div class="rounded-xl w-full border p-5 shadow-md bg-white"><div class="flex w-full items-center justify-between border-b pb-3"><div class="flex items-center space-x-3"><div class="text-lg font-bold text-slate-700"><a href="/questions/my-attempt-at-value-initialization-is-interpreted-as-a-function-declaration-and-why-doesn&#x27;t-a-a(())-solve-it-1657388474057"><h1>My attempt at value initialization is interpreted as a function declaration, and why doesn&#x27;t A a(()); solve it?</h1></a></div></div><div class="flex flex-wrap h-auto justify-end items-center space-x-8"></div></div><div class="question-content mt-5">
                
<p>Among the many things Stack Overflow has taught me is what is known as the "most vexing parse", which is classically demonstrated with a line such as</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-function">A <span class="hljs-title">a</span><span class="hljs-params">(B())</span></span>; <span class="hljs-comment">//declares a function</span>
</code></pre>

<p>While this, for most, intuitively appears to be the declaration of an object <code>a</code> of type <code>A</code>, taking a temporary <code>B</code> object as a constructor parameter, it's actually a declaration of a function <code>a</code> returning an <code>A</code>, taking a pointer to a function which returns <code>B</code> and itself takes no parameters. Similarly the line</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-function">A <span class="hljs-title">a</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">//declares a function</span>
</code></pre>

<p>also falls under the same category, since instead of an object, it declares a function. Now, in the first case, the usual workaround for this issue is to add an extra set of brackets/parenthesis around the <code>B()</code>, as the compiler will then interpret it as the declaration of an object</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-function">A <span class="hljs-title">a</span><span class="hljs-params">((B()))</span></span>; <span class="hljs-comment">//declares an object</span>
</code></pre>

<p>However, in the second case, doing the same leads to a compile error</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-function">A <span class="hljs-title">a</span><span class="hljs-params">(())</span></span>; <span class="hljs-comment">//compile error</span>
</code></pre>

<p>My question is, why? Yes I'm very well aware that the correct 'workaround' is to change it to <code>A a;</code>, but I'm curious to know what it is that the extra <code>()</code> does for the compiler in the first example which then doesn't work when reapplying it in the second example. Is the <code>A a((B()));</code> workaround a specific exception written into the standard?</p>
    </div></div></div><div class="solution-section"><nav class="flex pagination-solution flex-col justify-end"><h1 class="text-lg font-semibold mb-5">Navigate to solutions: </h1><ul class="inline-flex -space-x-px overflow-auto"><li class="pagination-solution-item"><span data-id="#solution1" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">1</span></li><li class="pagination-solution-item"><span data-id="#solution2" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">2</span></li><li class="pagination-solution-item"><span data-id="#solution3" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">3</span></li><li class="pagination-solution-item"><span data-id="#solution4" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">4</span></li><li class="pagination-solution-item"><span data-id="#solution5" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">5</span></li></ul></nav><div id="solution1" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 1</h1><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>There is no enlightened answer, it's just because it's not defined as valid syntax by the C++ language...  So it is so, by definition of the language.</p>

<p>If you do have an expression within then it is valid.  For example:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"> ((<span class="hljs-number">0</span>));<span class="hljs-comment">//compiles</span>
</code></pre>

<p>Even simpler put: because <code>(x)</code> is a valid C++ expression, while <code>()</code> is not. </p>

<p>To learn more about how languages are defined, and how compilers work, you should learn about <a href="http://en.wikipedia.org/wiki/Formal_language_theory" rel="noreferrer">Formal language theory</a> or more specifically <a href="http://en.wikipedia.org/wiki/Context-free_grammar" rel="noreferrer">Context Free Grammars (CFG)</a> and related material like finite state machines.  If you are interested in that though the wikipedia pages won't be enough, you'll have to get a book.</p>
    </div></div></div></div><div id="solution2" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 2</h1><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>The final solution to this issue is to move to the C+11 uniform initialization syntax if you can.</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp">A a{};
</code></pre>

<p><a href="http://www.stroustrup.com/C++11FAQ.html#uniform-init">http://www.stroustrup.com/C++11FAQ.html#uniform-init</a></p>
    </div></div></div></div><div id="solution3" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 3</h1><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<h1>C function declarators</h1>

<p>First of all, there is C. In C, <code>A a()</code> is function declaration. For example, <code>putchar</code> has the following declaration. Normally, such declarations are stored in header files, however nothing stops you from writing them manually, if you know how the declaration of function looks like. The argument names are optional in declarations, so I omitted it in this example.</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">putchar</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span></span>;
</code></pre>

<p>This allows you to write the code like this.</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">puts</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *)</span></span>;
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-built_in">puts</span>(<span class="hljs-string">"Hello, world!"</span>);
}
</code></pre>

<p>C also allows you to define functions that take functions as arguments, with nice readable syntax that looks like a function call (well, it's readable, as long you won't return a pointer to function).</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span>

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">eighty_four</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-number">84</span>;
}

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">output_result</span><span class="hljs-params">(<span class="hljs-type">int</span> callback())</span> </span>{
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Returned: %d\n"</span>, <span class="hljs-built_in">callback</span>());
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">output_result</span>(eighty_four);
}
</code></pre>

<p>As I mentioned, C allows omitting argument names in header files, therefore the <code>output_result</code> would look like this in header file.</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">output_result</span><span class="hljs-params">(<span class="hljs-type">int</span>())</span></span>;
</code></pre>

<h1>One argument in constructor</h1>

<p>Don't you recognize that one? Well, let me remind you.</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-function">A <span class="hljs-title">a</span><span class="hljs-params">(B())</span></span>;
</code></pre>

<p>Yep, it's exactly the same function declaration. <code>A</code> is <code>int</code>, <code>a</code> is <code>output_result</code>, and <code>B</code> is <code>int</code>.</p>

<p>You can easily notice a conflict of C with new features of C++. To be exact, constructors being class name and parenthesis, and alternate declaration syntax with <code>()</code> instead of <code>=</code>. By design, C++ tries to be compatible with C code, and therefore it has to deal with this case - even if practically nobody cares. Therefore, old C features have priority over new C++ features. The grammar of declarations tries to match the name as function, before reverting to the new syntax with <code>()</code> if it fails.</p>

<p>If one of those features wouldn't exist, or had a different syntax (like <code>{}</code> in C++11), this issue would never have happened for syntax with one argument.</p>

<p>Now you may ask why <code>A a((B()))</code> works. Well, let's declare <code>output_result</code> with useless parentheses.</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">output_result</span><span class="hljs-params">((<span class="hljs-type">int</span>()))</span></span>;
</code></pre>

<p>It won't work. The grammar requires the variable to not be in parentheses.</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp">&lt;stdin&gt;:<span class="hljs-number">1</span>:<span class="hljs-number">19</span>: error: expected declaration specifiers <span class="hljs-keyword">or</span> ... before ( token
</code></pre>

<p>However, C++ expects standard expression here. In C++, you can write the following code.</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-type">int</span> value = <span class="hljs-built_in">int</span>();
</code></pre>

<p>And the following code.</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-type">int</span> value = ((((<span class="hljs-built_in">int</span>()))));
</code></pre>

<p>C++ expects expression inside inside parentheses to be... well... expression, as opposed to the type C expects. Parentheses don't mean anything here. However, by inserting useless parentheses, the C function declaration is not matched, and the new syntax can be matched properly (which simply expects an expression, such as <code>2 + 2</code>).</p>

<h1>More arguments in constructor</h1>

<p>Surely one argument is nice, but what about two? It's not that constructors may have just one argument. One of built-in classes which takes two arguments is <code>std::string</code></p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-function">std::string <span class="hljs-title">hundred_dots</span><span class="hljs-params">(<span class="hljs-number">100</span>, <span class="hljs-string">'.'</span>)</span></span>;
</code></pre>

<p>This is all well and fine (technically, it would have most vexing parse if it would be written as <code>std::string wat(int(), char())</code>, but let's be honest - who would write that? But let's assume this code has a vexing problem. You would assume that you have to put everything in parentheses.</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-function">std::string <span class="hljs-title">hundred_dots</span><span class="hljs-params">((<span class="hljs-number">100</span>, <span class="hljs-string">'.'</span>))</span></span>;
</code></pre>

<p>Not quite so.</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp">&lt;stdin&gt;:<span class="hljs-number">2</span>:<span class="hljs-number">36</span>: error: invalid conversion from <span class="hljs-type">char</span> to <span class="hljs-type">const</span> <span class="hljs-type">char</span>* [-fpermissive]
In file included from /usr/include/c++/<span class="hljs-number">4.8</span>/string:<span class="hljs-number">53</span>:<span class="hljs-number">0</span>,
                 from &lt;stdin&gt;:<span class="hljs-number">1</span>:
/usr/include/c++/<span class="hljs-number">4.8</span>/bits/basic_string.tcc:<span class="hljs-number">212</span>:<span class="hljs-number">5</span>: error:   initializing argument <span class="hljs-number">1</span> of std::basic_string&lt;_CharT, _Traits, _Alloc&gt;::<span class="hljs-built_in">basic_string</span>(<span class="hljs-type">const</span> _CharT*, <span class="hljs-type">const</span> _Alloc&amp;) [with _CharT = <span class="hljs-type">char</span>; _Traits = std::char_traits&lt;<span class="hljs-type">char</span>&gt;; _Alloc = std::allocator&lt;<span class="hljs-type">char</span>&gt;] [-fpermissive]
     basic_string&lt;_CharT, _Traits, _Alloc&gt;::
     ^
</code></pre>

<p>I'm not sure why g++ tries to convert <code>char</code> to <code>const char *</code>. Either way, the constructor was called with just one value of type <code>char</code>. There is no overload which has one argument of type <code>char</code>, therefore the compiler is confused. You may ask - why the argument is of type char?</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp">(<span class="hljs-number">100</span>, <span class="hljs-string">'.'</span>)
</code></pre>

<p>Yes, <code>,</code> here is a comma operator. The comma operator takes two arguments, and gives the right-side argument. It isn't really useful, but it's something to be known for my explanation.</p>

<p>Instead, to solve the most vexing parse, the following code is needed.</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-function">std::string <span class="hljs-title">hundred_dots</span><span class="hljs-params">((<span class="hljs-number">100</span>), (<span class="hljs-string">'.'</span>))</span></span>;
</code></pre>

<p>The arguments are in parentheses, not the entire expression. In fact, just one of expressions needs to be in parentheses, as it's enough to break from the C grammar slightly to use the C++ feature. Things brings us to the point of zero arguments.</p>

<h1>Zero arguments in constructor</h1>

<p>You may have noticed the <code>eighty_four</code> function in my explanation.</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">eighty_four</span><span class="hljs-params">()</span></span>;
</code></pre>

<p>Yes, this is also affected by the most vexing parse. It's a valid definition, and one you most likely have seen if you created header files (and you should). Adding parentheses doesn't fix it.</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">eighty_four</span><span class="hljs-params">(())</span></span>;
</code></pre>

<p>Why is that so? Well, <code>()</code> is not an expression. In C++, you have to put an expression between parentheses. You cannot write <code>auto value = ()</code> in C++, because <code>()</code> doesn't mean anything (and even if did, like empty tuple (see Python), it would be one argument, not zero). Practically that means you cannot use shorthand syntax without using C++11's <code>{}</code> syntax, as there are no expressions to put in parenthesis, and C grammar for function declarations will always apply.</p>
    </div></div></div></div><div id="solution4" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 4</h1><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>You could instead</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-function">A <span class="hljs-title">a</span><span class="hljs-params">(())</span></span>;
</code></pre>

<p>use</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp">A a=<span class="hljs-built_in">A</span>();
</code></pre>
    </div></div></div></div><div id="solution5" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 5</h1><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>The innermost parens in your example would be an expression, and in C++ the grammar defines an <code>expression</code> to be an <code>assignment-expression</code> or another <code>expression</code> followed by a comma and another <code>assignment-expression</code> (Appendix A.4 - Grammar summary/Expressions).</p>

<p>The grammar further defines an <code>assignment-expression</code> as one of several other types of expression, none of which can be nothing (or only whitespace).</p>

<p>So the reason you can't have <code>A a(())</code> is simply because the grammar doesn't allow it.  However, I can't answer why the people who created C++ didn't allow this particular use of empty parens as some sort of special-case - I'd guess that they'd rather not put in such a special case if there was a reasonable alternative.</p>
    </div></div></div></div></div></div><div class="widget"><a href="/questions/selecting-and-manipulating-css-pseudo-elements-such-as-::before-and-::after-using-javascript-(or-jquery)-1657387406132">Selecting and manipulating CSS pseudo-elements such as ::before and ::after using javascript (or jQuery)</a><a href="/questions/sending-email-in-android-using-javamail-api-without-using-the-defaultbuilt-in-app-1657387883400">Sending Email in Android using JavaMail API without using the default/built-in app</a><a href="/questions/do-i-cast-the-result-of-malloc-1657384271583">Do I cast the result of malloc?</a><a href="/questions/how-do-i-merge-two-dictionaries-in-a-single-expression-1657387593160">How do I merge two dictionaries in a single expression?</a><a href="/questions/javascript-infamous-loop-issue-duplicate-1657387498530">Javascript infamous Loop issue? [duplicate]</a><a href="/questions/how-to-lazy-load-images-in-listview-in-android-1657387332835">How to lazy load images in ListView in Android</a><a href="/questions/how-do-you-parse-and-process-htmlxml-in-php-1657384351267">How do you parse and process HTML/XML in PHP?</a><a href="/questions/why-are-global-variables-evil-closed-1657388260006">Why are global variables evil? [closed]</a><a href="/questions/is-storing-a-delimited-list-in-a-database-column-really-that-bad-1657384474773">Is storing a delimited list in a database column really that bad?</a><a href="/questions/how-do-i-add-a-delay-in-a-javascript-loop-1657388544679">How do I add a delay in a JavaScript loop?</a><a href="/questions/%22is%22-operator-behaves-unexpectedly-with-integers-1657387563823">&quot;is&quot; operator behaves unexpectedly with integers</a><a href="/questions/asking-the-user-for-input-until-they-give-a-valid-response-1657384376162">Asking the user for input until they give a valid response</a><a href="/questions/web-scraping-javascript-page-with-python-1657388240875">Web-scraping JavaScript page with Python</a><a href="/questions/why-is-%22while(-!feof(file)-)%22-always-wrong-1657384367349">Why is “while( !feof(file) )” always wrong?</a><a href="/questions/%22thinking-in-angularjs%22-if-i-have-a-jquery-background-closed-1657384761159">&quot;Thinking in AngularJS&quot; if I have a jQuery background? [closed]</a><a href="/questions/what-is-a-smart-pointer-and-when-should-i-use-one-1657387905461">What is a smart pointer and when should I use one?</a><a href="/questions/how-to-access-the-correct-this-inside-a-callback-1657384283261">How to access the correct `this` inside a callback</a><a href="/questions/the-3-different-equals-1657385490242">The 3 different equals</a><a href="/questions/what-is-__init__.py-for-1657388415243">What is __init__.py for?</a><a href="/questions/why-jsf-calls-getters-multiple-times-1657388244489">Why JSF calls getters multiple times</a></div></div><span class="cursor-pointer text-lg p-2" style="position:fixed;bottom:20px;left:20px;background:#000;z-index:2000;color:white">Go go top</span></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"data":{"answer":["\n\u0026lt;p\u0026gt;There is no enlightened answer, it\u0026apos;s just because it\u0026apos;s not defined as valid syntax by the C++ language...  So it is so, by definition of the language.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;If you do have an expression within then it is valid.  For example:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt; ((\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;));\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//compiles\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Even simpler put: because \u0026lt;code\u0026gt;(x)\u0026lt;/code\u0026gt; is a valid C++ expression, while \u0026lt;code\u0026gt;()\u0026lt;/code\u0026gt; is not. \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;To learn more about how languages are defined, and how compilers work, you should learn about \u0026lt;a href=\u0026quot;http://en.wikipedia.org/wiki/Formal_language_theory\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;Formal language theory\u0026lt;/a\u0026gt; or more specifically \u0026lt;a href=\u0026quot;http://en.wikipedia.org/wiki/Context-free_grammar\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;Context Free Grammars (CFG)\u0026lt;/a\u0026gt; and related material like finite state machines.  If you are interested in that though the wikipedia pages won\u0026apos;t be enough, you\u0026apos;ll have to get a book.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;The final solution to this issue is to move to the C+11 uniform initialization syntax if you can.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;A a{};\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;a href=\u0026quot;http://www.stroustrup.com/C++11FAQ.html#uniform-init\u0026quot;\u0026gt;http://www.stroustrup.com/C++11FAQ.html#uniform-init\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;h1\u0026gt;C function declarators\u0026lt;/h1\u0026gt;\n\n\u0026lt;p\u0026gt;First of all, there is C. In C, \u0026lt;code\u0026gt;A a()\u0026lt;/code\u0026gt; is function declaration. For example, \u0026lt;code\u0026gt;putchar\u0026lt;/code\u0026gt; has the following declaration. Normally, such declarations are stored in header files, however nothing stops you from writing them manually, if you know how the declaration of function looks like. The argument names are optional in declarations, so I omitted it in this example.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;putchar\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;)\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;This allows you to write the code like this.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;puts\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; *)\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;;\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;main\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt; \u0026lt;/span\u0026gt;{\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;puts\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Hello, world!\u0026quot;\u0026lt;/span\u0026gt;);\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;C also allows you to define functions that take functions as arguments, with nice readable syntax that looks like a function call (well, it\u0026apos;s readable, as long you won\u0026apos;t return a pointer to function).\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;stdio.h\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;eighty_four\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt; \u0026lt;/span\u0026gt;{\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;84\u0026lt;/span\u0026gt;;\n}\n\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;output_result\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; callback())\u0026lt;/span\u0026gt; \u0026lt;/span\u0026gt;{\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;printf\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Returned: %d\\n\u0026quot;\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;callback\u0026lt;/span\u0026gt;());\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;;\n}\n\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;main\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt; \u0026lt;/span\u0026gt;{\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;output_result\u0026lt;/span\u0026gt;(eighty_four);\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;As I mentioned, C allows omitting argument names in header files, therefore the \u0026lt;code\u0026gt;output_result\u0026lt;/code\u0026gt; would look like this in header file.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;output_result\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;())\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;h1\u0026gt;One argument in constructor\u0026lt;/h1\u0026gt;\n\n\u0026lt;p\u0026gt;Don\u0026apos;t you recognize that one? Well, let me remind you.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;A \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;a\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(B())\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Yep, it\u0026apos;s exactly the same function declaration. \u0026lt;code\u0026gt;A\u0026lt;/code\u0026gt; is \u0026lt;code\u0026gt;int\u0026lt;/code\u0026gt;, \u0026lt;code\u0026gt;a\u0026lt;/code\u0026gt; is \u0026lt;code\u0026gt;output_result\u0026lt;/code\u0026gt;, and \u0026lt;code\u0026gt;B\u0026lt;/code\u0026gt; is \u0026lt;code\u0026gt;int\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;You can easily notice a conflict of C with new features of C++. To be exact, constructors being class name and parenthesis, and alternate declaration syntax with \u0026lt;code\u0026gt;()\u0026lt;/code\u0026gt; instead of \u0026lt;code\u0026gt;=\u0026lt;/code\u0026gt;. By design, C++ tries to be compatible with C code, and therefore it has to deal with this case - even if practically nobody cares. Therefore, old C features have priority over new C++ features. The grammar of declarations tries to match the name as function, before reverting to the new syntax with \u0026lt;code\u0026gt;()\u0026lt;/code\u0026gt; if it fails.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;If one of those features wouldn\u0026apos;t exist, or had a different syntax (like \u0026lt;code\u0026gt;{}\u0026lt;/code\u0026gt; in C++11), this issue would never have happened for syntax with one argument.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Now you may ask why \u0026lt;code\u0026gt;A a((B()))\u0026lt;/code\u0026gt; works. Well, let\u0026apos;s declare \u0026lt;code\u0026gt;output_result\u0026lt;/code\u0026gt; with useless parentheses.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;output_result\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;((\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;()))\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;It won\u0026apos;t work. The grammar requires the variable to not be in parentheses.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026amp;lt;stdin\u0026amp;gt;:\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;:\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;19\u0026lt;/span\u0026gt;: error: expected declaration specifiers \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;or\u0026lt;/span\u0026gt; ... before ( token\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;However, C++ expects standard expression here. In C++, you can write the following code.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; value = \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;();\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;And the following code.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; value = ((((\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;()))));\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;C++ expects expression inside inside parentheses to be... well... expression, as opposed to the type C expects. Parentheses don\u0026apos;t mean anything here. However, by inserting useless parentheses, the C function declaration is not matched, and the new syntax can be matched properly (which simply expects an expression, such as \u0026lt;code\u0026gt;2 + 2\u0026lt;/code\u0026gt;).\u0026lt;/p\u0026gt;\n\n\u0026lt;h1\u0026gt;More arguments in constructor\u0026lt;/h1\u0026gt;\n\n\u0026lt;p\u0026gt;Surely one argument is nice, but what about two? It\u0026apos;s not that constructors may have just one argument. One of built-in classes which takes two arguments is \u0026lt;code\u0026gt;std::string\u0026lt;/code\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;std::string \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;hundred_dots\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;100\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;.\u0026apos;\u0026lt;/span\u0026gt;)\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;This is all well and fine (technically, it would have most vexing parse if it would be written as \u0026lt;code\u0026gt;std::string wat(int(), char())\u0026lt;/code\u0026gt;, but let\u0026apos;s be honest - who would write that? But let\u0026apos;s assume this code has a vexing problem. You would assume that you have to put everything in parentheses.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;std::string \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;hundred_dots\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;((\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;100\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;.\u0026apos;\u0026lt;/span\u0026gt;))\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Not quite so.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026amp;lt;stdin\u0026amp;gt;:\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;:\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;36\u0026lt;/span\u0026gt;: error: invalid conversion from \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; to \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt;* [-fpermissive]\nIn file included from /usr/include/c++/\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;4.8\u0026lt;/span\u0026gt;/string:\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;53\u0026lt;/span\u0026gt;:\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;,\n                 from \u0026amp;lt;stdin\u0026amp;gt;:\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;:\n/usr/include/c++/\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;4.8\u0026lt;/span\u0026gt;/bits/basic_string.tcc:\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;212\u0026lt;/span\u0026gt;:\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;5\u0026lt;/span\u0026gt;: error:   initializing argument \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt; of std::basic_string\u0026amp;lt;_CharT, _Traits, _Alloc\u0026amp;gt;::\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;basic_string\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; _CharT*, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; _Alloc\u0026amp;amp;) [with _CharT = \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt;; _Traits = std::char_traits\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt;\u0026amp;gt;; _Alloc = std::allocator\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt;\u0026amp;gt;] [-fpermissive]\n     basic_string\u0026amp;lt;_CharT, _Traits, _Alloc\u0026amp;gt;::\n     ^\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;I\u0026apos;m not sure why g++ tries to convert \u0026lt;code\u0026gt;char\u0026lt;/code\u0026gt; to \u0026lt;code\u0026gt;const char *\u0026lt;/code\u0026gt;. Either way, the constructor was called with just one value of type \u0026lt;code\u0026gt;char\u0026lt;/code\u0026gt;. There is no overload which has one argument of type \u0026lt;code\u0026gt;char\u0026lt;/code\u0026gt;, therefore the compiler is confused. You may ask - why the argument is of type char?\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;100\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;.\u0026apos;\u0026lt;/span\u0026gt;)\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Yes, \u0026lt;code\u0026gt;,\u0026lt;/code\u0026gt; here is a comma operator. The comma operator takes two arguments, and gives the right-side argument. It isn\u0026apos;t really useful, but it\u0026apos;s something to be known for my explanation.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Instead, to solve the most vexing parse, the following code is needed.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;std::string \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;hundred_dots\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;((\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;100\u0026lt;/span\u0026gt;), (\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;.\u0026apos;\u0026lt;/span\u0026gt;))\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;The arguments are in parentheses, not the entire expression. In fact, just one of expressions needs to be in parentheses, as it\u0026apos;s enough to break from the C grammar slightly to use the C++ feature. Things brings us to the point of zero arguments.\u0026lt;/p\u0026gt;\n\n\u0026lt;h1\u0026gt;Zero arguments in constructor\u0026lt;/h1\u0026gt;\n\n\u0026lt;p\u0026gt;You may have noticed the \u0026lt;code\u0026gt;eighty_four\u0026lt;/code\u0026gt; function in my explanation.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;eighty_four\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Yes, this is also affected by the most vexing parse. It\u0026apos;s a valid definition, and one you most likely have seen if you created header files (and you should). Adding parentheses doesn\u0026apos;t fix it.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;eighty_four\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(())\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Why is that so? Well, \u0026lt;code\u0026gt;()\u0026lt;/code\u0026gt; is not an expression. In C++, you have to put an expression between parentheses. You cannot write \u0026lt;code\u0026gt;auto value = ()\u0026lt;/code\u0026gt; in C++, because \u0026lt;code\u0026gt;()\u0026lt;/code\u0026gt; doesn\u0026apos;t mean anything (and even if did, like empty tuple (see Python), it would be one argument, not zero). Practically that means you cannot use shorthand syntax without using C++11\u0026apos;s \u0026lt;code\u0026gt;{}\u0026lt;/code\u0026gt; syntax, as there are no expressions to put in parenthesis, and C grammar for function declarations will always apply.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;You could instead\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;A \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;a\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(())\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;use\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;A a=\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;A\u0026lt;/span\u0026gt;();\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;The innermost parens in your example would be an expression, and in C++ the grammar defines an \u0026lt;code\u0026gt;expression\u0026lt;/code\u0026gt; to be an \u0026lt;code\u0026gt;assignment-expression\u0026lt;/code\u0026gt; or another \u0026lt;code\u0026gt;expression\u0026lt;/code\u0026gt; followed by a comma and another \u0026lt;code\u0026gt;assignment-expression\u0026lt;/code\u0026gt; (Appendix A.4 - Grammar summary/Expressions).\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;The grammar further defines an \u0026lt;code\u0026gt;assignment-expression\u0026lt;/code\u0026gt; as one of several other types of expression, none of which can be nothing (or only whitespace).\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;So the reason you can\u0026apos;t have \u0026lt;code\u0026gt;A a(())\u0026lt;/code\u0026gt; is simply because the grammar doesn\u0026apos;t allow it.  However, I can\u0026apos;t answer why the people who created C++ didn\u0026apos;t allow this particular use of empty parens as some sort of special-case - I\u0026apos;d guess that they\u0026apos;d rather not put in such a special case if there was a reasonable alternative.\u0026lt;/p\u0026gt;\n    "],"id":579,"title":"My attempt at value initialization is interpreted as a function declaration, and why doesn't A a(()); solve it?","content":"\n                \n\u0026lt;p\u0026gt;Among the many things Stack Overflow has taught me is what is known as the \u0026quot;most vexing parse\u0026quot;, which is classically demonstrated with a line such as\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;A \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;a\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(B())\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//declares a function\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;While this, for most, intuitively appears to be the declaration of an object \u0026lt;code\u0026gt;a\u0026lt;/code\u0026gt; of type \u0026lt;code\u0026gt;A\u0026lt;/code\u0026gt;, taking a temporary \u0026lt;code\u0026gt;B\u0026lt;/code\u0026gt; object as a constructor parameter, it\u0026apos;s actually a declaration of a function \u0026lt;code\u0026gt;a\u0026lt;/code\u0026gt; returning an \u0026lt;code\u0026gt;A\u0026lt;/code\u0026gt;, taking a pointer to a function which returns \u0026lt;code\u0026gt;B\u0026lt;/code\u0026gt; and itself takes no parameters. Similarly the line\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;A \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;a\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//declares a function\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;also falls under the same category, since instead of an object, it declares a function. Now, in the first case, the usual workaround for this issue is to add an extra set of brackets/parenthesis around the \u0026lt;code\u0026gt;B()\u0026lt;/code\u0026gt;, as the compiler will then interpret it as the declaration of an object\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;A \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;a\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;((B()))\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//declares an object\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;However, in the second case, doing the same leads to a compile error\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;A \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;a\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(())\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//compile error\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;My question is, why? Yes I\u0026apos;m very well aware that the correct \u0026apos;workaround\u0026apos; is to change it to \u0026lt;code\u0026gt;A a;\u0026lt;/code\u0026gt;, but I\u0026apos;m curious to know what it is that the extra \u0026lt;code\u0026gt;()\u0026lt;/code\u0026gt; does for the compiler in the first example which then doesn\u0026apos;t work when reapplying it in the second example. Is the \u0026lt;code\u0026gt;A a((B()));\u0026lt;/code\u0026gt; workaround a specific exception written into the standard?\u0026lt;/p\u0026gt;\n    ","slug":"my-attempt-at-value-initialization-is-interpreted-as-a-function-declaration-and-why-doesn't-a-a(())-solve-it-1657388474057","postType":"QUESTION","createdAt":"2022-07-09T17:41:14.000Z","updatedAt":"2022-07-09T17:41:14.000Z","tags":[],"relatedQuestions":[]},"randomQuestions":[{"title":"Selecting and manipulating CSS pseudo-elements such as ::before and ::after using javascript (or jQuery)","slug":"selecting-and-manipulating-css-pseudo-elements-such-as-::before-and-::after-using-javascript-(or-jquery)-1657387406132"},{"title":"Sending Email in Android using JavaMail API without using the default/built-in app","slug":"sending-email-in-android-using-javamail-api-without-using-the-defaultbuilt-in-app-1657387883400"},{"title":"Do I cast the result of malloc?","slug":"do-i-cast-the-result-of-malloc-1657384271583"},{"title":"How do I merge two dictionaries in a single expression?","slug":"how-do-i-merge-two-dictionaries-in-a-single-expression-1657387593160"},{"title":"Javascript infamous Loop issue? [duplicate]","slug":"javascript-infamous-loop-issue-duplicate-1657387498530"},{"title":"How to lazy load images in ListView in Android","slug":"how-to-lazy-load-images-in-listview-in-android-1657387332835"},{"title":"How do you parse and process HTML/XML in PHP?","slug":"how-do-you-parse-and-process-htmlxml-in-php-1657384351267"},{"title":"Why are global variables evil? [closed]","slug":"why-are-global-variables-evil-closed-1657388260006"},{"title":"Is storing a delimited list in a database column really that bad?","slug":"is-storing-a-delimited-list-in-a-database-column-really-that-bad-1657384474773"},{"title":"How do I add a delay in a JavaScript loop?","slug":"how-do-i-add-a-delay-in-a-javascript-loop-1657388544679"},{"title":"\"is\" operator behaves unexpectedly with integers","slug":"\"is\"-operator-behaves-unexpectedly-with-integers-1657387563823"},{"title":"Asking the user for input until they give a valid response","slug":"asking-the-user-for-input-until-they-give-a-valid-response-1657384376162"},{"title":"Web-scraping JavaScript page with Python","slug":"web-scraping-javascript-page-with-python-1657388240875"},{"title":"Why is “while( !feof(file) )” always wrong?","slug":"why-is-\"while(-!feof(file)-)\"-always-wrong-1657384367349"},{"title":"\"Thinking in AngularJS\" if I have a jQuery background? [closed]","slug":"\"thinking-in-angularjs\"-if-i-have-a-jquery-background-closed-1657384761159"},{"title":"What is a smart pointer and when should I use one?","slug":"what-is-a-smart-pointer-and-when-should-i-use-one-1657387905461"},{"title":"How to access the correct `this` inside a callback","slug":"how-to-access-the-correct-this-inside-a-callback-1657384283261"},{"title":"The 3 different equals","slug":"the-3-different-equals-1657385490242"},{"title":"What is __init__.py for?","slug":"what-is-__init__.py-for-1657388415243"},{"title":"Why JSF calls getters multiple times","slug":"why-jsf-calls-getters-multiple-times-1657388244489"}]},"__N_SSG":true},"page":"/questions/[slug]","query":{"slug":"my-attempt-at-value-initialization-is-interpreted-as-a-function-declaration-and-why-doesn't-a-a(())-solve-it-1657388474057"},"buildId":"xZs8haGjOP63QuDE0kxeX","isFallback":false,"gsp":true,"locale":"en","locales":["en"],"defaultLocale":"en","scriptLoader":[]}</script></body></html>