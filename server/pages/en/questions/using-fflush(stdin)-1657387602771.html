<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><meta name="twitter:card" content="summary_large_image"/><meta name="twitter:site" content="@solutionschecker.com"/><meta name="twitter:creator" content="@solutionschecker.com"/><meta property="og:url" content="https://solutionschecker.com"/><meta property="og:type" content="website"/><meta property="og:image" content="https://solutionschecker.com/solutions-checker-banner.png"/><meta property="og:image:alt" content="Find the solution to any question. We focus on finding the fastest possible solution for users. Main topics like coding, learning. - solutionschecker.com"/><link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png"/><link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png"/><link rel="manifest" href="/site.webmanifest"/><script type="application/ld+json">{"@context":"https://schema.org","@type":"Organization","logo":"/logo.svg","url":"https://solutionschecker.com"}</script><link name="keywords" content="stdin,fflush,solutions checker, solution checker, how to, solution for, check for solution, resolve question, what is, what solution for, find solution"/><script type="application/ld+json">{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"item":{"@id":"https://solutionschecker.com","name":"Home"}},{"@type":"ListItem","position":2,"item":{"@id":"https://solutionschecker.com/questions","name":"Questions"}},{"@type":"ListItem","position":3,"item":{"@id":"https://solutionschecker.com/questions/using-fflush(stdin)-1657387602771","name":"Questions"}}]}</script><title>Using fflush(stdin) | Solution Checker</title><meta name="robots" content="index,follow"/><meta name="description" content="So a quick Google search for fflush(stdin) for clearing the input buffer reveals numerous websites warning against using it. And yet that&#x27;s exactly how my CS professor taught the class to do it.

How bad is using fflush(stdin)? Should I really abstain from using it, even though my professor is using it and it seems to work flawlessly?
    "/><meta property="og:title" content="Using fflush(stdin) | Solution Checker"/><meta property="og:description" content="So a quick Google search for fflush(stdin) for clearing the input buffer reveals numerous websites warning against using it. And yet that&#x27;s exactly how my CS professor taught the class to do it.

How bad is using fflush(stdin)? Should I really abstain from using it, even though my professor is using it and it seems to work flawlessly?
    "/><script type="application/ld+json">{"@context":"https://schema.org","@type":"QAPage","mainEntity":{"name":"Using fflush(stdin)","text":"So a quick Google search for fflush(stdin) for clearing the input buffer reveals numerous websites warning against using it. And yet that&apos;s exactly how my CS professor taught the class to do it.\n\nHow bad is using fflush(stdin)? Should I really abstain from using it, even though my professor is using it and it seems to work flawlessly?\n    ","answerCount":7,"upVoteCount":500,"suggestedAnswer":[{"text":"Simple: this is undefined behavior, since fflush is meant to be called on an output stream. This is an excerpt from the C standard:\n\nint fflush(FILE *ostream);\nostream points to an output stream or\nan update stream in which the most\nrecent operation was not input, the\nfflush function causes any unwritten\ndata for that stream to be delivered\nto the host environment to be written\nto the file; otherwise, the behavior\nis undefined.\n\nSo it&apos;s not a question of &quot;how bad&quot; this is. fflush(stdin) is simply not portable, so you should not use it if you want your code to be portable between compilers.\n    ","url":"https://solutionschecker.com/questions/using-fflush(stdin)-1657387602771#solution1","@type":"Answer","upvoteCount":0},{"text":"Converting comments into an answer.\nTL;DR  Portable code doesn&apos;t use fflush(stdin)\nThe rest of this answer explains why portable code does not use fflush(stdin).  It is tempting to add &quot;reliable code doesn&apos;t use fflush(stdin)&quot;, which is also generally true.\nStandard C and POSIX leave fflush(stdin) as undefined behaviour\nThe POSIX, C and C++ standards for fflush() explicitly state that the behaviour is undefined (because stdin is an input stream), but none of them prevent a system from defining it.\nISO/IEC 9899:2011  the C11 Standard  says:\n\n§7.21.5.2 The fflush function\n¶2 If stream points to an output stream or an update stream in which the most recent operation was not input, the fflush function causes any unwritten data for that stream to be delivered to the host environment to be written to the file; otherwise, the behavior is undefined.\n\nPOSIX mostly defers to the C standard but it does mark this text as a C extension.\n\n[CX]  For a stream open for reading, if the file is not already at EOF, and the file is one capable of seeking, the file offset of the underlying open file description shall be set to the file position of the stream, and any characters pushed back onto the stream by ungetc() or ungetwc() that have not subsequently been read from the stream shall be discarded (without further changing the file offset). \n\nNote that terminals are not capable of seeking; neither are pipes or sockets.\nMicrosoft defines the behaviour of fflush(stdin)\nIn 2015, Microsoft and the Visual Studio runtime used to define the behaviour of fflush() on an input stream like this (but the link leads to different text in 2021):\n\nIf the stream is open for input, fflush clears the contents of the buffer.\n\nM.M notes:\n\nCygwin is an example of a fairly common platform on which fflush(stdin) does not clear the input.\n\nThis is why this answer version of my comment notes &apos;Microsoft and the Visual Studio runtime&apos;  if you use a non-Microsoft C runtime library, the behaviour you see depends on that library.\nWeather Vane pointed out to me in a comment to another question that, at some time before June 2021, Microsoft changed its description of fflush() compared with what was originally specified when this answer was written in 2015.  It now says:\n\nIf the stream was opened in read mode, or if the stream has no buffer, the call to fflush has no effect, and any buffer is retained. A call to fflush negates the effect of any prior call to ungetc for the stream.\n\nCaveat Lector: it is probably best not to rely on fflush(stdin) on any platform.\nLinux documentation and practice seem to contradict each other\nSurprisingly, Linux nominally documents the behaviour of fflush(stdin) too, and even defines it the same way (miracle of miracles).  This quote is from 2015.\n\nFor input streams, fflush() discards any buffered data that has been fetched from the underlying file, but has not been consumed by the application.\n\nIn 2021, the quote changes to:\n\nFor input streams, fflush() discards any buffered data that has been fetched from the underlying file, but has not been consumed by the application. The open status of the stream is unaffected.\n\nAnd another source for fflush(3) on Linux agrees (give or take paragraph breaks):\n\nFor input streams associated with seekable files (e.g., disk files, but not pipes or terminals), fflush() discards any buffered data that has been fetched from the underlying file, but has not been consumed by the application.\n\nNeither of these explicitly addresses the points made by the POSIX specification about ungetc().\nIn 2021, zwol commented that the Linux documentation has been improved.\nIt seems to me that there is still room for improvement.\nIn 2015, I was a bit puzzled and surprised at the Linux documentation saying that fflush(stdin) will work.\nDespite that suggestion, it most usually does not work on Linux.  I just checked the documentation on Ubuntu 14.04 LTS; it says what is quoted above, but empirically, it does not work  at least when the input stream is a non-seekable device such as a terminal.\ndemo-fflush.c\n#include &lt;stdio.h&gt;\n\nint main(void)\n{\n    int c;\n    if ((c = getchar()) != EOF)\n    {\n        printf(&quot;Got %c; enter some new data\\n&quot;, c);\n        fflush(stdin);\n    }\n    if ((c = getchar()) != EOF)\n        printf(&quot;Got %c\\n&quot;, c);\n\n    return 0;\n}\n\nExample output\n$ ./demo-fflush\nAlliteration\nGot A; enter some new data\nGot l\n$\n\nThis output was obtained on both Ubuntu 14.04 LTS and Mac OS X 10.11.2.  To my understanding, it contradicts what the Linux manual says.  If the fflush(stdin) operation worked, I would have to type a new line of text to get information for the second getchar() to read.\nGiven what the POSIX standard says, maybe a better demonstration is needed, and the Linux documentation should be clarified.\ndemo-fflush2.c\n#include &lt;stdio.h&gt;\n\nint main(void)\n{\n    int c;\n    if ((c = getchar()) != EOF)\n    {\n        printf(&quot;Got %c\\n&quot;, c);\n        ungetc(&apos;B&apos;, stdin);\n        ungetc(&apos;Z&apos;, stdin);\n        if ((c = getchar()) == EOF)\n        {\n            fprintf(stderr, &quot;Huh?!\\n&quot;);\n            return 1;\n        }\n        printf(&quot;Got %c after ungetc()\\n&quot;, c);\n        fflush(stdin);\n    }\n    if ((c = getchar()) != EOF)\n        printf(&quot;Got %c\\n&quot;, c);\n\n    return 0;\n}\n\nExample output\nNote that /etc/passwd is a seekable file.  On Ubuntu, the first line looks like:\nroot:x:0:0:root:/root:/bin/bash\n\nOn Mac OS X, the first 4 lines look like:\n##\n# User Database\n# \n# Note that this file is consulted directly only when the system is running\n\nIn other words, there is commentary at the top of the Mac OS X /etc/passwd file.  The non-comment lines conform to the normal layout, so the root entry is:\nroot:*:0:0:System Administrator:/var/root:/bin/sh\n\nUbuntu 14.04 LTS:\n$ ./demo-fflush2 &lt; /etc/passwd\nGot r\nGot Z after ungetc()\nGot o\n$ ./demo-fflush2\nAllotrope\nGot A\nGot Z after ungetc()\nGot B\n$\n\nMac OS X 10.11.2:\n$ ./demo-fflush2 &lt; /etc/passwd\nGot #\nGot Z after ungetc()\nGot B\n$\n\nThe Mac OS X behaviour ignores (or at least seems to ignore) the fflush(stdin) (thus not following POSIX on this issue).  The Linux behaviour corresponds to the documented POSIX behaviour, but the POSIX specification is far more careful in what it says  it specifies a file capable of seeking, but terminals, of course, do not support seeking.  It is also much less useful than the Microsoft specification.\nSummary\nMicrosoft documents the behaviour of fflush(stdin), but that behaviour has changed between 2015 and 2021.  Apparently, it works as documented on the Windows platform, using the native Windows compiler and C runtime support libraries.\nDespite documentation to the contrary, it does not work on Linux when the standard input is a terminal, but it seems to follow the POSIX specification which is far more carefully worded.  According to the C standard, the behaviour of fflush(stdin) is undefined.  POSIX adds the qualifier &apos;unless the input file is seekable&apos;, which a terminal is not.  The behaviour is not the same as Microsoft&apos;s.\nConsequently, portable code does not use fflush(stdin).  Code that is tied to Microsoft&apos;s platform may use it and it may work as expected, but beware of the portability issues.\nPOSIX way to discard unread terminal input from a file descriptor\nThe POSIX standard way to discard unread information from a terminal file descriptor (as opposed to a file stream like stdin) is illustrated at How can I flush unread data from a tty input queue on a Unix system.  However, that is operating below the standard I/O library level.\n    ","url":"https://solutionschecker.com/questions/using-fflush(stdin)-1657387602771#solution2","@type":"Answer","upvoteCount":0},{"text":"According to the standard, fflush can only be used with output buffers, and obviously stdin isn&apos;t one. However, some standard C libraries provide the use of fflush(stdin) as an extension. In that case you can use it, but it will affect portability, so you will no longer be able to use any standards-compliant standard C library on earth and expect the same results.\n    ","url":"https://solutionschecker.com/questions/using-fflush(stdin)-1657387602771#solution3","@type":"Answer","upvoteCount":0},{"text":"I believe that you should never call fflush(stdin), and for the simple reason that you should never even find it necessary to try to flush input in the first place.  Realistically, there is only one reason you might think you had to flush input, and that is: to get past some bad input that scanf is stuck on.\nFor example, you might have a program that is sitting in a loop reading integers using scanf(&quot;%d&quot;, &amp;n).  Soon enough you&apos;ll discover that the first time the user types a non-digit character like &apos;x&apos;, the program goes into an infinite loop.\nWhen faced with this situation, I believe you basically have three choices:\n\nFlush the input somehow (if not by using fflush(stdin), then by calling getchar in a loop to read characters until \\n, as is often recommended).\nTell the user not to type non-digit characters when digits are expected.\nUse something other than scanf to read input.\n\nNow, if you&apos;re a beginner, scanf seems like the easiest way to read input, and so choice #3 looks scary and difficult.  But #2 seems like a real cop-out, because everyone knows that user-unfriendly computer programs are a problem, so it&apos;d be nice to do better.  So all too many beginning programmers get painted into a corner, feeling that they have no choice but to do #1.  They more or less have to do input using scanf, meaning that it will get stuck on bad input, meaning that they have to figure out a way to flush the bad input, meaning that they&apos;re sorely tempted to use fflush(stdin).\nI would like to encourage all beginning C programmers out there to make a different set of tradeoffs:\n\nDuring the earliest stages of your C programming career, before you&apos;re comfortable using anything other than scanf, just don&apos;t worry about bad input.  Really.  Go ahead and use cop-out #2 above.  Think about it like this: You&apos;re a beginner, there are lots of things you don&apos;t know how to do yet, and one of the things you don&apos;t know how to do yet is: deal gracefully with unexpected input.\n\nAs soon as you can, learn how to do input using functions other than scanf.  At that point, you can start dealing gracefully with bad input, and you&apos;ll have many more, much better techniques available to you, that won&apos;t require trying to &quot;flush the bad input&quot; at all.\n\n\nOr, in other words, beginners who are still stuck using scanf should feel free to use cop-out #2, and when they&apos;re ready they should graduate from there to technique #3, and nobody should be using technique #1 to try to flush input at all -- and certainly not with fflush(stdin).\n    ","url":"https://solutionschecker.com/questions/using-fflush(stdin)-1657387602771#solution4","@type":"Answer","upvoteCount":0},{"text":"Using fflush(stdin) to flush input is kind of like dowsing for water using a stick shaped like the letter &quot;S&quot;.\nAnd helping people to flush input in some &quot;better&quot; way is kind of like rushing up to an S-stick dowser and saying &quot;No, no, you&apos;re doing it wrong,\nyou need to use a Y-shaped stick!&quot;.\nIn other words, the real problem isn&apos;t that fflush(stdin) doesn&apos;t work.  Calling fflush(stdin) is a symptom of an underlying problem.  Why are you having to &quot;flush&quot; input at all?  That&apos;s your problem.\nAnd, usually, that underlying problem is that you&apos;re using scanf, in one of its many unhelpful modes that unexpectedly leaves newlines or other &quot;unwanted&quot; text on the input.  The best long-term solution, therefore, is to learn how to do input using better techniques than scanf, so that you don&apos;t have to deal with its unhandled input and other idiosyncrasies at all.\n    ","url":"https://solutionschecker.com/questions/using-fflush(stdin)-1657387602771#solution5","@type":"Answer","upvoteCount":0},{"text":"None of the existing answers point out a key aspect of the issue.\nIf you find yourself wanting to &quot;clear the input buffer&quot;, you&apos;re probably writing a command-line interactive program, and it would be more accurate to say that what you want is to discard characters from the current line of input that you haven&apos;t already read.\nThis is not what fflush(stdin) does.  The C libraries that support using fflush on an input stream, document it as either doing nothing, or as discarding buffered data that has been read from the underlying file but not passed to the application.  That can easily be either more or less input than the rest of the current line.  It probably does work by accident in a lot of cases, because the terminal driver (in its default mode) supplies input to a command-line interactive program one line at a time.  However, the moment you try to feed input to your program from an actual file on disk (perhaps for automated testing), the kernel and C library will switch over to buffering data in large &quot;blocks&quot; (often 4 to 8 kB) with no relationship to line boundaries, and you&apos;ll be wondering why your program is processing the first line of the file and then skipping several dozen lines and picking up in the middle of some apparently random line below.  Or, if you decide to test your program on a very long line typed by hand, then the terminal driver won&apos;t be able to give the program the whole line at once and fflush(stdin) won&apos;t skip all of it.\nSo what should you do instead?  The approach that I prefer is, if you&apos;re processing input one line at a time, then read an entire line all at once.  The C library has functions specifically for this: fgets (in C90, so fully portable, but does still make you process very long lines in chunks) and getline (POSIX-specific, but will manage a malloced buffer for you so you can process long lines all at once no matter how long they get).  There&apos;s usually a direct translation from code that processes &quot;the current line&quot; directly from stdin to code that processes a string containing &quot;the current line&quot;.\n    ","url":"https://solutionschecker.com/questions/using-fflush(stdin)-1657387602771#solution6","@type":"Answer","upvoteCount":0},{"text":"Quote from POSIX:\n\nFor  a  stream  open  for  reading, if the file is not already at EOF, and the file is one\ncapable of seeking, the file offset of the underlying open file description shall  be  set\nto  the   file  position  of  the stream, and any characters pushed back onto the stream by\nungetc() or ungetwc() that have not subsequently been read from the stream shall  be  dis-\ncarded (without further changing the file offset).\n\nNote that terminal is not capable of seeking.\n    ","url":"https://solutionschecker.com/questions/using-fflush(stdin)-1657387602771#solution7","@type":"Answer","upvoteCount":0}],"@type":"Question"}}</script><meta name="next-head-count" content="22"/><script id="google-analytics" data-nscript="beforeInteractive">(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
})(window,document,'script','dataLayer','GTM-NXVLL8B');</script><link rel="preload" href="/_next/static/css/c116652e2d6f4ad0.css" as="style"/><link rel="stylesheet" href="/_next/static/css/c116652e2d6f4ad0.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-0d1b80a048d4787e.js"></script><script src="/_next/static/chunks/webpack-42cdea76c8170223.js" defer=""></script><script src="/_next/static/chunks/framework-4556c45dd113b893.js" defer=""></script><script src="/_next/static/chunks/main-ccfab947c79712f4.js" defer=""></script><script src="/_next/static/chunks/pages/_app-862498b6ec7885c3.js" defer=""></script><script src="/_next/static/chunks/294-106ef8570fa99deb.js" defer=""></script><script src="/_next/static/chunks/490-7f0418bb4354ac73.js" defer=""></script><script src="/_next/static/chunks/pages/questions/%5Bslug%5D-47289857226115f9.js" defer=""></script><script src="/_next/static/xZs8haGjOP63QuDE0kxeX/_buildManifest.js" defer=""></script><script src="/_next/static/xZs8haGjOP63QuDE0kxeX/_ssgManifest.js" defer=""></script></head><body><noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-NXVLL8B"
        height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript><div id="__next"><div class="wrapper"><header><nav class="bg-white border-gray-200 px-4 lg:px-6 py-2.5 dark:bg-gray-800"><div class="flex flex-wrap justify-between items-center mx-auto max-w-screen-xl"><a class="flex items-center" href="/"><img src="/logo-second.png" class="mr-3 h-6 sm:h-9" alt="Solution Checker Logo"/><h1 class="self-center text-xl font-semibold whitespace-nowrap dark:text-white">Solution Checker</h1></a><div class="flex items-center lg:order-2"><button data-collapse-toggle="mobile-menu-2" type="button" class="inline-flex items-center p-2 ml-1 text-sm text-gray-500 rounded-lg lg:hidden hover:bg-gray-100 focus:outline-none focus:ring-2 focus:ring-gray-200 dark:text-gray-400 dark:hover:bg-gray-700 dark:focus:ring-gray-600" aria-controls="mobile-menu-2" aria-expanded="false"><span class="sr-only">Open main menu</span><svg class="w-6 h-6" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M3 5a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM3 10a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM3 15a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1z" clip-rule="evenodd"></path></svg><svg class="hidden w-6 h-6" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z" clip-rule="evenodd"></path></svg></button></div><div class="hidden justify-between items-center w-full lg:flex lg:w-auto lg:order-1" id="mobile-menu-2"><ul class="flex flex-col mt-4 font-medium lg:flex-row lg:space-x-8 lg:mt-0"><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" aria-current="page" href="/">Home</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/questions?tab=news">Questions</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/post?tab=news">Post</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/questions/using-fflush(stdin)-1657387602771#">Coding</a></li></ul></div></div></nav></header><div class="main-content"><div class="question my-5"><div class="flex question-header items-center m-auto justify-center"><div class="rounded-xl w-full border p-5 shadow-md bg-white"><div class="flex w-full items-center justify-between border-b pb-3"><div class="flex items-center space-x-3"><div class="text-lg font-bold text-slate-700"><a href="/questions/using-fflush(stdin)-1657387602771"><h1>Using fflush(stdin)</h1></a></div></div><div class="flex flex-wrap h-auto justify-end items-center space-x-8"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold" href="/questions/tag/stdin">stdin</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold" href="/questions/tag/fflush">fflush</a></div></div><div class="question-content mt-5">
                
<p>So a quick Google search for <code>fflush(stdin)</code> for clearing the input buffer reveals numerous websites warning against using it. And yet that's exactly how my CS professor taught the class to do it.</p>

<p>How bad is using <code>fflush(stdin)</code>? Should I really abstain from using it, even though my professor is using it and it seems to work flawlessly?</p>
    </div></div></div><div class="solution-section"><nav class="flex pagination-solution flex-col justify-end"><h1 class="text-lg font-semibold mb-5">Navigate to solutions: </h1><ul class="inline-flex -space-x-px overflow-auto"><li class="pagination-solution-item"><span data-id="#solution1" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">1</span></li><li class="pagination-solution-item"><span data-id="#solution2" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">2</span></li><li class="pagination-solution-item"><span data-id="#solution3" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">3</span></li><li class="pagination-solution-item"><span data-id="#solution4" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">4</span></li><li class="pagination-solution-item"><span data-id="#solution5" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">5</span></li><li class="pagination-solution-item"><span data-id="#solution6" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">6</span></li><li class="pagination-solution-item"><span data-id="#solution7" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">7</span></li></ul></nav><div id="solution1" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 1</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/stdin">stdin</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/fflush">fflush</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Simple: this is undefined behavior, since <code>fflush</code> is meant to be called on an output stream. This is an excerpt from the C standard:</p>
<blockquote>
<p>int fflush(FILE *ostream);</p>
<p>ostream points to an output stream or
an update stream in which the most
recent operation was not input, the
fflush function causes any unwritten
data for that stream to be delivered
to the host environment to be written
to the file; otherwise, the behavior
is undefined.</p>
</blockquote>
<p>So it's not a question of "how bad" this is. <code>fflush(stdin)</code> is simply not portable, so you should not use it if you want your code to be portable between compilers.</p>
    </div></div></div></div><div id="solution2" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 2</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/stdin">stdin</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/fflush">fflush</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p><sup><em>Converting comments into an answer.</em></sup></p>
<h1>TL;DR  <em><strong>Portable code doesn't use <code>fflush(stdin)</code></strong></em></h1>
<p>The rest of this answer explains why portable code does not use <code>fflush(stdin)</code>.  It is tempting to add "reliable code doesn't use <code>fflush(stdin)</code>", which is also generally true.</p>
<h2>Standard C and POSIX leave <code>fflush(stdin)</code> as undefined behaviour</h2>
<p>The <a href="http://pubs.opengroup.org/onlinepubs/9699919799/functions/fflush.html" rel="noreferrer">POSIX</a>, C and C++ standards for <code>fflush()</code> explicitly state that the behaviour is undefined (because <code>stdin</code> is an input stream), but none of them prevent a system from defining it.</p>
<p>ISO/IEC 9899:2011 &nbsp;the C11 Standard  says:</p>
<blockquote>
<h3><a href="http://port70.net/%7Ensz/c/c11/n1570.html#7.21.5.2" rel="noreferrer">§7.21.5.2 The fflush function</a></h3>
<p>¶2 If <code>stream</code> points to an output stream or an update stream in which the most recent operation was not input, the <code>fflush</code> function causes any unwritten data for that stream to be delivered to the host environment to be written to the file; otherwise, the behavior is undefined.</p>
</blockquote>
<p>POSIX mostly defers to the C standard but it does mark this text as a C extension.</p>
<blockquote>
<p>[CX]  For a stream open for reading, if the file is not already at EOF, and the file is one capable of seeking, the file offset of the underlying open file description shall be set to the file position of the stream, and any characters pushed back onto the stream by <code>ungetc()</code> or <code>ungetwc()</code> that have not subsequently been read from the stream shall be discarded (without further changing the file offset). </p>
</blockquote>
<p>Note that terminals are not capable of seeking; neither are pipes or sockets.</p>
<h2>Microsoft defines the behaviour of <code>fflush(stdin)</code></h2>
<p>In 2015, <a href="http://msdn.microsoft.com/en-us/library/9yky46tz.aspx" rel="noreferrer">Microsoft</a> and the Visual Studio runtime used to define the behaviour of <code>fflush()</code> on an input stream like this (but the link leads to different text in 2021):</p>
<blockquote>
<p>If the stream is open for input, <code>fflush</code> clears the contents of the buffer.</p>
</blockquote>
<p><a href="https://stackoverflow.com/users/1505939/m-m">M.M</a> <a href="https://stackoverflow.com/questions/2979209/using-fflushstdin#comment40866432_2979209">notes</a>:</p>
<blockquote>
<p>Cygwin is an example of a fairly common platform on which <code>fflush(stdin)</code> does not clear the input.</p>
</blockquote>
<p>This is why this answer version of my <a href="https://stackoverflow.com/questions/2979209/using-fflushstdin#comment31066899_2979209">comment</a> notes 'Microsoft and the Visual Studio runtime'  if you use a non-Microsoft C runtime library, the behaviour you see depends on that library.</p>
<p><a href="https://stackoverflow.com/users/4142924/weather-vane">Weather Vane</a> pointed out to me in a comment to another question that, at some time before June 2021, Microsoft changed its description of <a href="https://docs.microsoft.com/en-us/cpp/c-runtime-library/reference/fflush?view=msvc-160" rel="noreferrer"><code>fflush()</code></a> compared with what was originally specified when this answer was written in 2015.  It now says:</p>
<blockquote>
<p>If the stream was opened in read mode, or if the stream has no buffer, the call to <code>fflush</code> has no effect, and any buffer is retained. A call to <code>fflush</code> negates the effect of any prior call to <code>ungetc</code> for the stream.</p>
</blockquote>
<p><a href="https://en.wiktionary.org/wiki/caveat_lector" rel="noreferrer"><em>Caveat Lector:</em></a> it is probably best not to rely on <code>fflush(stdin)</code> on any platform.</p>
<h2>Linux documentation and practice seem to contradict each other</h2>
<p>Surprisingly, <a href="http://linux.die.net/man/3/fflush" rel="noreferrer">Linux</a> nominally documents the behaviour of <code>fflush(stdin)</code> too, and even defines it the same way (miracle of miracles).  This quote is from 2015.</p>
<blockquote>
<p>For input streams, <code>fflush()</code> discards any buffered data that has been fetched from the underlying file, but has not been consumed by the application.</p>
</blockquote>
<p>In 2021, the quote changes to:</p>
<blockquote>
<p>For input streams, <code>fflush()</code> discards any buffered data that has been fetched from the underlying file, but has not been consumed by the application. The open status of the stream is unaffected.</p>
</blockquote>
<p>And another source for <a href="http://man7.org/linux/man-pages/man3/fflush.3.html" rel="noreferrer"><code>fflush(3)</code></a> on Linux agrees (give or take paragraph breaks):</p>
<blockquote>
<p>For input streams associated with seekable files (e.g., disk files, but not pipes or terminals), <code>fflush()</code> discards any buffered data that has been fetched from the underlying file, but has not been consumed by the application.</p>
</blockquote>
<p>Neither of these explicitly addresses the points made by the POSIX specification about <code>ungetc()</code>.</p>
<p>In 2021, <a href="https://stackoverflow.com/users/388520/zwol">zwol</a> <a href="https://stackoverflow.com/questions/2979209/using-fflushstdin/34247021?noredirect=1#comment120026978_34247021">commented</a> that the Linux documentation has been improved.
It seems to me that there is still room for improvement.</p>
<p>In 2015, I was a bit puzzled and surprised at the Linux documentation saying that <code>fflush(stdin)</code> will work.
Despite that suggestion, it most usually does not work on Linux.  I just checked the documentation on Ubuntu 14.04 LTS; it says what is quoted above, but empirically, it does not work &nbsp;at least when the input stream is a non-seekable device such as a terminal.</p>
<h3><code>demo-fflush.c</code></h3>
<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span>

<span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>
{
    <span class="hljs-type">int</span> c;
    <span class="hljs-keyword">if</span> ((c = getchar()) != EOF)
    {
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Got %c; enter some new data\n"</span>, c);
        fflush(<span class="hljs-built_in">stdin</span>);
    }
    <span class="hljs-keyword">if</span> ((c = getchar()) != EOF)
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Got %c\n"</span>, c);

    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>
<h3>Example output</h3>
<pre class="lang-c s-code-block"><code class="hljs language-c">$ ./demo-fflush
Alliteration
Got A; enter some new data
Got l
$
</code></pre>
<p>This output was obtained on both Ubuntu 14.04 LTS and Mac OS X 10.11.2.  To my understanding, it contradicts what the Linux manual says.  If the <code>fflush(stdin)</code> operation worked, I would have to type a new line of text to get information for the second <code>getchar()</code> to read.</p>
<p>Given what the POSIX standard says, maybe a better demonstration is needed, and the Linux documentation should be clarified.</p>
<h3><code>demo-fflush2.c</code></h3>
<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span>

<span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>
{
    <span class="hljs-type">int</span> c;
    <span class="hljs-keyword">if</span> ((c = getchar()) != EOF)
    {
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Got %c\n"</span>, c);
        ungetc(<span class="hljs-string">'B'</span>, <span class="hljs-built_in">stdin</span>);
        ungetc(<span class="hljs-string">'Z'</span>, <span class="hljs-built_in">stdin</span>);
        <span class="hljs-keyword">if</span> ((c = getchar()) == EOF)
        {
            <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"Huh?!\n"</span>);
            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
        }
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Got %c after ungetc()\n"</span>, c);
        fflush(<span class="hljs-built_in">stdin</span>);
    }
    <span class="hljs-keyword">if</span> ((c = getchar()) != EOF)
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Got %c\n"</span>, c);

    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>
<h3>Example output</h3>
<p>Note that <code>/etc/passwd</code> is a seekable file.  On Ubuntu, the first line looks like:</p>
<pre class="lang-c s-code-block"><code class="hljs language-c">root:x:<span class="hljs-number">0</span>:<span class="hljs-number">0</span>:root:/root:/bin/bash
</code></pre>
<p>On Mac OS X, the first 4 lines look like:</p>
<pre class="lang-c s-code-block"><code class="hljs language-c">##
# User Database
# 
# Note that this file is consulted directly only when the system is running
</code></pre>
<p>In other words, there is commentary at the top of the Mac OS X <code>/etc/passwd</code> file.  The non-comment lines conform to the normal layout, so the <code>root</code> entry is:</p>
<pre class="lang-c s-code-block"><code class="hljs language-c">root:*:<span class="hljs-number">0</span>:<span class="hljs-number">0</span>:System Administrator:/var/root:/bin/sh
</code></pre>
<p>Ubuntu 14.04 LTS:</p>
<pre class="lang-c s-code-block"><code class="hljs language-c">$ ./demo-fflush2 &lt; /etc/passwd
Got r
Got Z after <span class="hljs-title function_">ungetc</span><span class="hljs-params">()</span>
Got o
$ ./demo-fflush2
Allotrope
Got A
Got Z after <span class="hljs-title function_">ungetc</span><span class="hljs-params">()</span>
Got B
$
</code></pre>
<p>Mac OS X 10.11.2:</p>
<pre class="lang-c s-code-block"><code class="hljs language-c">$ ./demo-fflush2 &lt; /etc/passwd
Got #
Got Z after <span class="hljs-title function_">ungetc</span><span class="hljs-params">()</span>
Got B
$
</code></pre>
<p>The Mac OS X behaviour ignores (or at least seems to ignore) the <code>fflush(stdin)</code> (thus not following POSIX on this issue).  The Linux behaviour corresponds to the documented POSIX behaviour, but the POSIX specification is far more careful in what it says  it specifies a file capable of seeking, but terminals, of course, do not support seeking.  It is also much less useful than the Microsoft specification.</p>
<h2>Summary</h2>
<p>Microsoft documents the behaviour of <code>fflush(stdin)</code>, but that behaviour has changed between 2015 and 2021.  Apparently, it works as documented on the Windows platform, using the native Windows compiler and C runtime support libraries.</p>
<p>Despite documentation to the contrary, it does not work on Linux when the standard input is a terminal, but it seems to follow the POSIX specification which is far more carefully worded.  According to the C standard, the behaviour of <code>fflush(stdin)</code> is undefined.  POSIX adds the qualifier 'unless the input file is seekable', which a terminal is not.  The behaviour is not the same as Microsoft's.</p>
<p>Consequently, <em><strong>portable code does not use <code>fflush(stdin)</code></strong></em>.  Code that is tied to Microsoft's platform may use it and it may work as expected, but beware of the portability issues.</p>
<h3>POSIX way to discard unread terminal input from a file descriptor</h3>
<p>The POSIX standard way to discard unread information from a terminal file descriptor (as opposed to a file stream like <code>stdin</code>) is illustrated at <a href="https://stackoverflow.com/questions/10938882/how-can-i-flush-unread-data-from-a-tty-input-queue-on-a-unix-system">How can I flush unread data from a tty input queue on a Unix system</a>.  However, that is operating below the standard I/O library level.</p>
    </div></div></div></div><div id="solution3" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 3</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/stdin">stdin</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/fflush">fflush</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>According to the standard, <code>fflush</code> can only be used with output buffers, and obviously <code>stdin</code> isn't one. However, <a href="http://msdn.microsoft.com/en-us/library/9yky46tz.aspx" rel="nofollow noreferrer">some</a> standard C libraries provide the use of <code>fflush(stdin)</code> as an extension. In that case you can use it, but it will affect portability, so you will no longer be able to use any standards-compliant standard C library on earth and expect the same results.</p>
    </div></div></div></div><div id="solution4" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 4</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/stdin">stdin</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/fflush">fflush</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>I believe that you should never call <code>fflush(stdin)</code>, and for the simple reason that you should never even find it necessary to try to flush input in the first place.  Realistically, there is only one reason you might think you had to flush input, and that is: to get past some bad input that <code>scanf</code> is stuck on.</p>
<p>For example, you might have a program that is sitting in a loop reading integers using <code>scanf("%d", &amp;n)</code>.  Soon enough you'll discover that the first time the user types a non-digit character like <code>'x'</code>, <a href="https://stackoverflow.com/questions/1716013/why-is-scanf-causing-infinite-loop-in-this-code">the program goes into an infinite loop</a>.</p>
<p>When faced with this situation, I believe you basically have three choices:</p>
<ol>
<li>Flush the input somehow (if not by using <code>fflush(stdin)</code>, then by calling <code>getchar</code> in a loop to read characters until <code>\n</code>, as is often recommended).</li>
<li>Tell the user not to type non-digit characters when digits are expected.</li>
<li><a href="https://stackoverflow.com/questions/58403537/what-can-i-use-to-parse-input-instead-of-scanf">Use something other than <code>scanf</code> to read input</a>.</li>
</ol>
<p>Now, if you're a beginner, <code>scanf</code> <em>seems</em> like the easiest way to read input, and so choice #3 looks scary and difficult.  But #2 seems like a real cop-out, because everyone knows that user-unfriendly computer programs are a problem, so it'd be nice to do better.  So all too many beginning programmers get painted into a corner, feeling that they have no choice but to do #1.  They more or less have to do input using <code>scanf</code>, meaning that it will get stuck on bad input, meaning that they have to figure out a way to flush the bad input, meaning that they're sorely tempted to use <code>fflush(stdin)</code>.</p>
<p>I would like to encourage all beginning C programmers out there to make a different set of tradeoffs:</p>
<ol>
<li><p>During the earliest stages of your C programming career, before you're comfortable using anything other than <code>scanf</code>, just <em>don't worry about bad input</em>.  Really.  Go ahead and use cop-out #2 above.  Think about it like this: You're a beginner, there are lots of things you don't know how to do yet, and one of the things you don't know how to do yet is: deal gracefully with unexpected input.</p>
</li>
<li><p>As soon as you can, <a href="https://stackoverflow.com/questions/58403537/what-can-i-use-to-parse-input-instead-of-scanf">learn how to do input using functions other than <code>scanf</code></a>.  At that point, you can start dealing gracefully with bad input, and you'll have many more, much better techniques available to you, that won't require trying to "flush the bad input" at all.</p>
</li>
</ol>
<p>Or, in other words, beginners who are still stuck using <code>scanf</code> should feel free to use cop-out #2, and when they're ready they should graduate from there to technique #3, and nobody should be using technique #1 to try to flush input at all -- and certainly not with <code>fflush(stdin)</code>.</p>
    </div></div></div></div><div id="solution5" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 5</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/stdin">stdin</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/fflush">fflush</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Using <code>fflush(stdin)</code> to flush input is kind of like <a href="https://en.wikipedia.org/wiki/Dowsing" rel="nofollow noreferrer">dowsing for water</a> using a stick shaped like the letter "S".</p>
<p>And helping people to flush input in some "better" way is kind of like rushing up to an S-stick dowser and saying "No, no, you're doing it wrong,
you need to use a Y-shaped stick!".</p>
<p>In other words, the real problem isn't that <code>fflush(stdin)</code> doesn't work.  Calling <code>fflush(stdin)</code> is a symptom of an underlying problem.  Why are you having to "flush" input at all?  <em>That's</em> your problem.</p>
<p>And, usually, that underlying problem is that you're using <code>scanf</code>, in one of its many unhelpful modes that unexpectedly leaves newlines or other "unwanted" text on the input.  The best long-term solution, therefore, is to <a href="https://stackoverflow.com/questions/58403537/what-can-i-use-for-input-conversion-instead-of-scanf">learn how to do input using better techniques than <code>scanf</code></a>, so that you don't have to deal with its unhandled input and other idiosyncrasies at all.</p>
    </div></div></div></div><div id="solution6" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 6</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/stdin">stdin</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/fflush">fflush</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>None of the existing answers point out a key aspect of the issue.</p>
<p>If you find yourself <em>wanting</em> to "clear the input buffer", you're probably writing a command-line interactive program, and it would be more accurate to say that what you want is to <em>discard characters from the current <strong>line</strong> of input that you haven't already read.</em></p>
<p><strong>This is not what <code>fflush(stdin)</code> does.</strong>  The C libraries that support using <code>fflush</code> on an input stream, document it as either doing <em>nothing,</em> or as discarding <em>buffered data that has been read from the underlying file but not passed to the application</em>.  That can easily be either <em>more</em> or <em>less</em> input than the rest of the current line.  It probably does work by accident in a lot of cases, because the terminal driver (in its default mode) supplies input to a command-line interactive program one line at a time.  However, the moment you try to feed input to your program from an actual file on disk (perhaps for automated testing), the kernel and C library will switch over to buffering data in large "blocks" (often 4 to 8 kB) with no relationship to line boundaries, and you'll be wondering why your program is processing the first line of the file and then skipping several dozen lines and picking up in the <em>middle</em> of some apparently random line below.  Or, if you decide to test your program on a very <em>long</em> line typed by hand, then the terminal driver won't be able to give the program the whole line at once and <code>fflush(stdin)</code> won't skip all of it.</p>
<p>So what should you do instead?  The approach that I prefer is, if you're processing input one line at a time, then <em>read an entire line all at once</em>.  The C library has functions specifically for this: <code>fgets</code> (in C90, so fully portable, but does still make you process very long lines in chunks) and <code>getline</code> (POSIX-specific, but will manage a <code>malloc</code>ed buffer for you so you can process long lines all at once no matter how long they get).  There's usually a direct translation from code that processes "the current line" directly from stdin to code that processes a string containing "the current line".</p>
    </div></div></div></div><div id="solution7" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 7</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/stdin">stdin</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/fflush">fflush</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Quote from <a href="https://www.unix.com/man-page/posix/3P/fflush/" rel="nofollow noreferrer" title="POSIX">POSIX</a>:</p>
<blockquote>
<p>For  a  stream  open  for  reading, if the file is not already at EOF, and the file is one
capable of seeking, the file offset of the underlying open file description shall  be  set
to  the   file  position  of  the stream, and any characters pushed back onto the stream by
ungetc() or ungetwc() that have not subsequently been read from the stream shall  be  dis-
carded (without further changing the file offset).</p>
</blockquote>
<p>Note that terminal is not capable of seeking.</p>
    </div></div></div></div></div></div><div class="widget"><a href="/questions/how-do-i-access-previous-promise-results-in-a-.then()-chain-1657387705386">How do I access previous promise results in a .then() chain?</a><a href="/questions/what&#x27;s-the-difference-between-inner-join-left-join-right-join-and-full-join-duplicate-1657388082887">What&#x27;s the difference between INNER JOIN, LEFT JOIN, RIGHT JOIN and FULL JOIN? [duplicate]</a><a href="/questions/is-storing-a-delimited-list-in-a-database-column-really-that-bad-1657384474773">Is storing a delimited list in a database column really that bad?</a><a href="/questions/how-do-you-get-the-footer-to-stay-at-the-bottom-of-a-web-page-1657387817544">How do you get the footer to stay at the bottom of a Web page?</a><a href="/questions/how-do-you-access-the-matched-groups-in-a-javascript-regular-expression-1657388233817">How do you access the matched groups in a JavaScript regular expression?</a><a href="/questions/what-is-the-meaning-of-single-and-double-underscore-before-an-object-name-1657387926929">What is the meaning of single and double underscore before an object name?</a><a href="/questions/how-to-create-a-mysql-hierarchical-recursive-query-1657387662163">How to create a MySQL hierarchical recursive query?</a><a href="/questions/importing-installed-package-from-script-raises-%22attributeerror:-module-has-no-attribute%22-or-%22importerror:-cannot-import-name%22-1657387790607">Importing installed package from script raises &quot;AttributeError: module has no attribute&quot; or &quot;ImportError: cannot import name&quot;</a><a href="/questions/what-is-this-weird-colon-member-(%22-:-%22)-syntax-in-the-constructor-1657387264047">What is this weird colon-member (&quot; : &quot;) syntax in the constructor?</a><a href="/questions/what-does-the-comma-operator-do-1657388258021">What does the comma operator , do?</a><a href="/questions/what-is-the-strict-aliasing-rule-1657384742852">What is the strict aliasing rule?</a><a href="/questions/how-do-i-match-any-character-across-multiple-lines-in-a-regular-expression-1657387839720">How do I match any character across multiple lines in a regular expression?</a><a href="/questions/how-can-i-make-an-ajax-call-without-jquery-1657388448955">How can I make an AJAX call without jQuery?</a><a href="/questions/why-is-using-&#x27;eval&#x27;-a-bad-practice-1657387348760">Why is using &#x27;eval&#x27; a bad practice?</a><a href="/questions/how-can-i-validate-an-email-address-in-javascript-1657385475959">How can I validate an email address in JavaScript?</a><a href="/questions/what-are-good-ways-to-prevent-sql-injection-duplicate-1657388431570">What are good ways to prevent SQL injection? [duplicate]</a><a href="/questions/what-does-a-space-mean-in-a-css-selector-i.e.-what-is-the-difference-between-.classa.classb-and-.classa-.classb-1657387912095">What does a space mean in a CSS selector? i.e. What is the difference between .classA.classB and .classA .classB?</a><a href="/questions/how-can-i-transition-height:-0-to-height:-auto-using-css-1657388022100">How can I transition height: 0; to height: auto; using CSS?</a><a href="/questions/why-does-my-function-that-calls-an-api-or-launches-a-coroutine-return-an-empty-or-null-value-1657388483820">Why does my function that calls an API or launches a coroutine return an empty or null value?</a><a href="/questions/how-to-removedelete-a-large-file-from-commit-history-in-the-git-repository-1657387589093">How to remove/delete a large file from commit history in the Git repository?</a></div></div><span class="cursor-pointer text-lg p-2" style="position:fixed;bottom:20px;left:20px;background:#000;z-index:2000;color:white">Go go top</span></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"data":{"answer":["\n\u0026lt;p\u0026gt;Simple: this is undefined behavior, since \u0026lt;code\u0026gt;fflush\u0026lt;/code\u0026gt; is meant to be called on an output stream. This is an excerpt from the C standard:\u0026lt;/p\u0026gt;\n\u0026lt;blockquote\u0026gt;\n\u0026lt;p\u0026gt;int fflush(FILE *ostream);\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;ostream points to an output stream or\nan update stream in which the most\nrecent operation was not input, the\nfflush function causes any unwritten\ndata for that stream to be delivered\nto the host environment to be written\nto the file; otherwise, the behavior\nis undefined.\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\u0026lt;p\u0026gt;So it\u0026apos;s not a question of \u0026quot;how bad\u0026quot; this is. \u0026lt;code\u0026gt;fflush(stdin)\u0026lt;/code\u0026gt; is simply not portable, so you should not use it if you want your code to be portable between compilers.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;\u0026lt;sup\u0026gt;\u0026lt;em\u0026gt;Converting comments into an answer.\u0026lt;/em\u0026gt;\u0026lt;/sup\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;h1\u0026gt;TL;DR  \u0026lt;em\u0026gt;\u0026lt;strong\u0026gt;Portable code doesn\u0026apos;t use \u0026lt;code\u0026gt;fflush(stdin)\u0026lt;/code\u0026gt;\u0026lt;/strong\u0026gt;\u0026lt;/em\u0026gt;\u0026lt;/h1\u0026gt;\n\u0026lt;p\u0026gt;The rest of this answer explains why portable code does not use \u0026lt;code\u0026gt;fflush(stdin)\u0026lt;/code\u0026gt;.  It is tempting to add \u0026quot;reliable code doesn\u0026apos;t use \u0026lt;code\u0026gt;fflush(stdin)\u0026lt;/code\u0026gt;\u0026quot;, which is also generally true.\u0026lt;/p\u0026gt;\n\u0026lt;h2\u0026gt;Standard C and POSIX leave \u0026lt;code\u0026gt;fflush(stdin)\u0026lt;/code\u0026gt; as undefined behaviour\u0026lt;/h2\u0026gt;\n\u0026lt;p\u0026gt;The \u0026lt;a href=\u0026quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/fflush.html\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;POSIX\u0026lt;/a\u0026gt;, C and C++ standards for \u0026lt;code\u0026gt;fflush()\u0026lt;/code\u0026gt; explicitly state that the behaviour is undefined (because \u0026lt;code\u0026gt;stdin\u0026lt;/code\u0026gt; is an input stream), but none of them prevent a system from defining it.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;ISO/IEC 9899:2011 \u0026amp;nbsp;the C11 Standard  says:\u0026lt;/p\u0026gt;\n\u0026lt;blockquote\u0026gt;\n\u0026lt;h3\u0026gt;\u0026lt;a href=\u0026quot;http://port70.net/%7Ensz/c/c11/n1570.html#7.21.5.2\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;§7.21.5.2 The fflush function\u0026lt;/a\u0026gt;\u0026lt;/h3\u0026gt;\n\u0026lt;p\u0026gt;¶2 If \u0026lt;code\u0026gt;stream\u0026lt;/code\u0026gt; points to an output stream or an update stream in which the most recent operation was not input, the \u0026lt;code\u0026gt;fflush\u0026lt;/code\u0026gt; function causes any unwritten data for that stream to be delivered to the host environment to be written to the file; otherwise, the behavior is undefined.\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\u0026lt;p\u0026gt;POSIX mostly defers to the C standard but it does mark this text as a C extension.\u0026lt;/p\u0026gt;\n\u0026lt;blockquote\u0026gt;\n\u0026lt;p\u0026gt;[CX]  For a stream open for reading, if the file is not already at EOF, and the file is one capable of seeking, the file offset of the underlying open file description shall be set to the file position of the stream, and any characters pushed back onto the stream by \u0026lt;code\u0026gt;ungetc()\u0026lt;/code\u0026gt; or \u0026lt;code\u0026gt;ungetwc()\u0026lt;/code\u0026gt; that have not subsequently been read from the stream shall be discarded (without further changing the file offset). \u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\u0026lt;p\u0026gt;Note that terminals are not capable of seeking; neither are pipes or sockets.\u0026lt;/p\u0026gt;\n\u0026lt;h2\u0026gt;Microsoft defines the behaviour of \u0026lt;code\u0026gt;fflush(stdin)\u0026lt;/code\u0026gt;\u0026lt;/h2\u0026gt;\n\u0026lt;p\u0026gt;In 2015, \u0026lt;a href=\u0026quot;http://msdn.microsoft.com/en-us/library/9yky46tz.aspx\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;Microsoft\u0026lt;/a\u0026gt; and the Visual Studio runtime used to define the behaviour of \u0026lt;code\u0026gt;fflush()\u0026lt;/code\u0026gt; on an input stream like this (but the link leads to different text in 2021):\u0026lt;/p\u0026gt;\n\u0026lt;blockquote\u0026gt;\n\u0026lt;p\u0026gt;If the stream is open for input, \u0026lt;code\u0026gt;fflush\u0026lt;/code\u0026gt; clears the contents of the buffer.\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;a href=\u0026quot;https://stackoverflow.com/users/1505939/m-m\u0026quot;\u0026gt;M.M\u0026lt;/a\u0026gt; \u0026lt;a href=\u0026quot;https://stackoverflow.com/questions/2979209/using-fflushstdin#comment40866432_2979209\u0026quot;\u0026gt;notes\u0026lt;/a\u0026gt;:\u0026lt;/p\u0026gt;\n\u0026lt;blockquote\u0026gt;\n\u0026lt;p\u0026gt;Cygwin is an example of a fairly common platform on which \u0026lt;code\u0026gt;fflush(stdin)\u0026lt;/code\u0026gt; does not clear the input.\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\u0026lt;p\u0026gt;This is why this answer version of my \u0026lt;a href=\u0026quot;https://stackoverflow.com/questions/2979209/using-fflushstdin#comment31066899_2979209\u0026quot;\u0026gt;comment\u0026lt;/a\u0026gt; notes \u0026apos;Microsoft and the Visual Studio runtime\u0026apos;  if you use a non-Microsoft C runtime library, the behaviour you see depends on that library.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;a href=\u0026quot;https://stackoverflow.com/users/4142924/weather-vane\u0026quot;\u0026gt;Weather Vane\u0026lt;/a\u0026gt; pointed out to me in a comment to another question that, at some time before June 2021, Microsoft changed its description of \u0026lt;a href=\u0026quot;https://docs.microsoft.com/en-us/cpp/c-runtime-library/reference/fflush?view=msvc-160\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;\u0026lt;code\u0026gt;fflush()\u0026lt;/code\u0026gt;\u0026lt;/a\u0026gt; compared with what was originally specified when this answer was written in 2015.  It now says:\u0026lt;/p\u0026gt;\n\u0026lt;blockquote\u0026gt;\n\u0026lt;p\u0026gt;If the stream was opened in read mode, or if the stream has no buffer, the call to \u0026lt;code\u0026gt;fflush\u0026lt;/code\u0026gt; has no effect, and any buffer is retained. A call to \u0026lt;code\u0026gt;fflush\u0026lt;/code\u0026gt; negates the effect of any prior call to \u0026lt;code\u0026gt;ungetc\u0026lt;/code\u0026gt; for the stream.\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;a href=\u0026quot;https://en.wiktionary.org/wiki/caveat_lector\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;\u0026lt;em\u0026gt;Caveat Lector:\u0026lt;/em\u0026gt;\u0026lt;/a\u0026gt; it is probably best not to rely on \u0026lt;code\u0026gt;fflush(stdin)\u0026lt;/code\u0026gt; on any platform.\u0026lt;/p\u0026gt;\n\u0026lt;h2\u0026gt;Linux documentation and practice seem to contradict each other\u0026lt;/h2\u0026gt;\n\u0026lt;p\u0026gt;Surprisingly, \u0026lt;a href=\u0026quot;http://linux.die.net/man/3/fflush\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;Linux\u0026lt;/a\u0026gt; nominally documents the behaviour of \u0026lt;code\u0026gt;fflush(stdin)\u0026lt;/code\u0026gt; too, and even defines it the same way (miracle of miracles).  This quote is from 2015.\u0026lt;/p\u0026gt;\n\u0026lt;blockquote\u0026gt;\n\u0026lt;p\u0026gt;For input streams, \u0026lt;code\u0026gt;fflush()\u0026lt;/code\u0026gt; discards any buffered data that has been fetched from the underlying file, but has not been consumed by the application.\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\u0026lt;p\u0026gt;In 2021, the quote changes to:\u0026lt;/p\u0026gt;\n\u0026lt;blockquote\u0026gt;\n\u0026lt;p\u0026gt;For input streams, \u0026lt;code\u0026gt;fflush()\u0026lt;/code\u0026gt; discards any buffered data that has been fetched from the underlying file, but has not been consumed by the application. The open status of the stream is unaffected.\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\u0026lt;p\u0026gt;And another source for \u0026lt;a href=\u0026quot;http://man7.org/linux/man-pages/man3/fflush.3.html\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;\u0026lt;code\u0026gt;fflush(3)\u0026lt;/code\u0026gt;\u0026lt;/a\u0026gt; on Linux agrees (give or take paragraph breaks):\u0026lt;/p\u0026gt;\n\u0026lt;blockquote\u0026gt;\n\u0026lt;p\u0026gt;For input streams associated with seekable files (e.g., disk files, but not pipes or terminals), \u0026lt;code\u0026gt;fflush()\u0026lt;/code\u0026gt; discards any buffered data that has been fetched from the underlying file, but has not been consumed by the application.\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\u0026lt;p\u0026gt;Neither of these explicitly addresses the points made by the POSIX specification about \u0026lt;code\u0026gt;ungetc()\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;In 2021, \u0026lt;a href=\u0026quot;https://stackoverflow.com/users/388520/zwol\u0026quot;\u0026gt;zwol\u0026lt;/a\u0026gt; \u0026lt;a href=\u0026quot;https://stackoverflow.com/questions/2979209/using-fflushstdin/34247021?noredirect=1#comment120026978_34247021\u0026quot;\u0026gt;commented\u0026lt;/a\u0026gt; that the Linux documentation has been improved.\nIt seems to me that there is still room for improvement.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;In 2015, I was a bit puzzled and surprised at the Linux documentation saying that \u0026lt;code\u0026gt;fflush(stdin)\u0026lt;/code\u0026gt; will work.\nDespite that suggestion, it most usually does not work on Linux.  I just checked the documentation on Ubuntu 14.04 LTS; it says what is quoted above, but empirically, it does not work \u0026amp;nbsp;at least when the input stream is a non-seekable device such as a terminal.\u0026lt;/p\u0026gt;\n\u0026lt;h3\u0026gt;\u0026lt;code\u0026gt;demo-fflush.c\u0026lt;/code\u0026gt;\u0026lt;/h3\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;stdio.h\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;main\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt;)\u0026lt;/span\u0026gt;\n{\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; c;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; ((c = getchar()) != EOF)\n    {\n        \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;printf\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Got %c; enter some new data\\n\u0026quot;\u0026lt;/span\u0026gt;, c);\n        fflush(\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;stdin\u0026lt;/span\u0026gt;);\n    }\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; ((c = getchar()) != EOF)\n        \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;printf\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Got %c\\n\u0026quot;\u0026lt;/span\u0026gt;, c);\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;h3\u0026gt;Example output\u0026lt;/h3\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;$ ./demo-fflush\nAlliteration\nGot A; enter some new data\nGot l\n$\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;This output was obtained on both Ubuntu 14.04 LTS and Mac OS X 10.11.2.  To my understanding, it contradicts what the Linux manual says.  If the \u0026lt;code\u0026gt;fflush(stdin)\u0026lt;/code\u0026gt; operation worked, I would have to type a new line of text to get information for the second \u0026lt;code\u0026gt;getchar()\u0026lt;/code\u0026gt; to read.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Given what the POSIX standard says, maybe a better demonstration is needed, and the Linux documentation should be clarified.\u0026lt;/p\u0026gt;\n\u0026lt;h3\u0026gt;\u0026lt;code\u0026gt;demo-fflush2.c\u0026lt;/code\u0026gt;\u0026lt;/h3\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;stdio.h\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;main\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt;)\u0026lt;/span\u0026gt;\n{\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; c;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; ((c = getchar()) != EOF)\n    {\n        \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;printf\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Got %c\\n\u0026quot;\u0026lt;/span\u0026gt;, c);\n        ungetc(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;B\u0026apos;\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;stdin\u0026lt;/span\u0026gt;);\n        ungetc(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;Z\u0026apos;\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;stdin\u0026lt;/span\u0026gt;);\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; ((c = getchar()) == EOF)\n        {\n            \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;fprintf\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;stderr\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Huh?!\\n\u0026quot;\u0026lt;/span\u0026gt;);\n            \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;;\n        }\n        \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;printf\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Got %c after ungetc()\\n\u0026quot;\u0026lt;/span\u0026gt;, c);\n        fflush(\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;stdin\u0026lt;/span\u0026gt;);\n    }\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; ((c = getchar()) != EOF)\n        \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;printf\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Got %c\\n\u0026quot;\u0026lt;/span\u0026gt;, c);\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;h3\u0026gt;Example output\u0026lt;/h3\u0026gt;\n\u0026lt;p\u0026gt;Note that \u0026lt;code\u0026gt;/etc/passwd\u0026lt;/code\u0026gt; is a seekable file.  On Ubuntu, the first line looks like:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;root:x:\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;:\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;:root:/root:/bin/bash\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;On Mac OS X, the first 4 lines look like:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;##\n# User Database\n# \n# Note that this file is consulted directly only when the system is running\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;In other words, there is commentary at the top of the Mac OS X \u0026lt;code\u0026gt;/etc/passwd\u0026lt;/code\u0026gt; file.  The non-comment lines conform to the normal layout, so the \u0026lt;code\u0026gt;root\u0026lt;/code\u0026gt; entry is:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;root:*:\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;:\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;:System Administrator:/var/root:/bin/sh\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;Ubuntu 14.04 LTS:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;$ ./demo-fflush2 \u0026amp;lt; /etc/passwd\nGot r\nGot Z after \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;ungetc\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt;\nGot o\n$ ./demo-fflush2\nAllotrope\nGot A\nGot Z after \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;ungetc\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt;\nGot B\n$\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;Mac OS X 10.11.2:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;$ ./demo-fflush2 \u0026amp;lt; /etc/passwd\nGot #\nGot Z after \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;ungetc\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt;\nGot B\n$\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;The Mac OS X behaviour ignores (or at least seems to ignore) the \u0026lt;code\u0026gt;fflush(stdin)\u0026lt;/code\u0026gt; (thus not following POSIX on this issue).  The Linux behaviour corresponds to the documented POSIX behaviour, but the POSIX specification is far more careful in what it says  it specifies a file capable of seeking, but terminals, of course, do not support seeking.  It is also much less useful than the Microsoft specification.\u0026lt;/p\u0026gt;\n\u0026lt;h2\u0026gt;Summary\u0026lt;/h2\u0026gt;\n\u0026lt;p\u0026gt;Microsoft documents the behaviour of \u0026lt;code\u0026gt;fflush(stdin)\u0026lt;/code\u0026gt;, but that behaviour has changed between 2015 and 2021.  Apparently, it works as documented on the Windows platform, using the native Windows compiler and C runtime support libraries.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Despite documentation to the contrary, it does not work on Linux when the standard input is a terminal, but it seems to follow the POSIX specification which is far more carefully worded.  According to the C standard, the behaviour of \u0026lt;code\u0026gt;fflush(stdin)\u0026lt;/code\u0026gt; is undefined.  POSIX adds the qualifier \u0026apos;unless the input file is seekable\u0026apos;, which a terminal is not.  The behaviour is not the same as Microsoft\u0026apos;s.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Consequently, \u0026lt;em\u0026gt;\u0026lt;strong\u0026gt;portable code does not use \u0026lt;code\u0026gt;fflush(stdin)\u0026lt;/code\u0026gt;\u0026lt;/strong\u0026gt;\u0026lt;/em\u0026gt;.  Code that is tied to Microsoft\u0026apos;s platform may use it and it may work as expected, but beware of the portability issues.\u0026lt;/p\u0026gt;\n\u0026lt;h3\u0026gt;POSIX way to discard unread terminal input from a file descriptor\u0026lt;/h3\u0026gt;\n\u0026lt;p\u0026gt;The POSIX standard way to discard unread information from a terminal file descriptor (as opposed to a file stream like \u0026lt;code\u0026gt;stdin\u0026lt;/code\u0026gt;) is illustrated at \u0026lt;a href=\u0026quot;https://stackoverflow.com/questions/10938882/how-can-i-flush-unread-data-from-a-tty-input-queue-on-a-unix-system\u0026quot;\u0026gt;How can I flush unread data from a tty input queue on a Unix system\u0026lt;/a\u0026gt;.  However, that is operating below the standard I/O library level.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;According to the standard, \u0026lt;code\u0026gt;fflush\u0026lt;/code\u0026gt; can only be used with output buffers, and obviously \u0026lt;code\u0026gt;stdin\u0026lt;/code\u0026gt; isn\u0026apos;t one. However, \u0026lt;a href=\u0026quot;http://msdn.microsoft.com/en-us/library/9yky46tz.aspx\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;some\u0026lt;/a\u0026gt; standard C libraries provide the use of \u0026lt;code\u0026gt;fflush(stdin)\u0026lt;/code\u0026gt; as an extension. In that case you can use it, but it will affect portability, so you will no longer be able to use any standards-compliant standard C library on earth and expect the same results.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;I believe that you should never call \u0026lt;code\u0026gt;fflush(stdin)\u0026lt;/code\u0026gt;, and for the simple reason that you should never even find it necessary to try to flush input in the first place.  Realistically, there is only one reason you might think you had to flush input, and that is: to get past some bad input that \u0026lt;code\u0026gt;scanf\u0026lt;/code\u0026gt; is stuck on.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;For example, you might have a program that is sitting in a loop reading integers using \u0026lt;code\u0026gt;scanf(\u0026quot;%d\u0026quot;, \u0026amp;amp;n)\u0026lt;/code\u0026gt;.  Soon enough you\u0026apos;ll discover that the first time the user types a non-digit character like \u0026lt;code\u0026gt;\u0026apos;x\u0026apos;\u0026lt;/code\u0026gt;, \u0026lt;a href=\u0026quot;https://stackoverflow.com/questions/1716013/why-is-scanf-causing-infinite-loop-in-this-code\u0026quot;\u0026gt;the program goes into an infinite loop\u0026lt;/a\u0026gt;.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;When faced with this situation, I believe you basically have three choices:\u0026lt;/p\u0026gt;\n\u0026lt;ol\u0026gt;\n\u0026lt;li\u0026gt;Flush the input somehow (if not by using \u0026lt;code\u0026gt;fflush(stdin)\u0026lt;/code\u0026gt;, then by calling \u0026lt;code\u0026gt;getchar\u0026lt;/code\u0026gt; in a loop to read characters until \u0026lt;code\u0026gt;\\n\u0026lt;/code\u0026gt;, as is often recommended).\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Tell the user not to type non-digit characters when digits are expected.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;a href=\u0026quot;https://stackoverflow.com/questions/58403537/what-can-i-use-to-parse-input-instead-of-scanf\u0026quot;\u0026gt;Use something other than \u0026lt;code\u0026gt;scanf\u0026lt;/code\u0026gt; to read input\u0026lt;/a\u0026gt;.\u0026lt;/li\u0026gt;\n\u0026lt;/ol\u0026gt;\n\u0026lt;p\u0026gt;Now, if you\u0026apos;re a beginner, \u0026lt;code\u0026gt;scanf\u0026lt;/code\u0026gt; \u0026lt;em\u0026gt;seems\u0026lt;/em\u0026gt; like the easiest way to read input, and so choice #3 looks scary and difficult.  But #2 seems like a real cop-out, because everyone knows that user-unfriendly computer programs are a problem, so it\u0026apos;d be nice to do better.  So all too many beginning programmers get painted into a corner, feeling that they have no choice but to do #1.  They more or less have to do input using \u0026lt;code\u0026gt;scanf\u0026lt;/code\u0026gt;, meaning that it will get stuck on bad input, meaning that they have to figure out a way to flush the bad input, meaning that they\u0026apos;re sorely tempted to use \u0026lt;code\u0026gt;fflush(stdin)\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;I would like to encourage all beginning C programmers out there to make a different set of tradeoffs:\u0026lt;/p\u0026gt;\n\u0026lt;ol\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;During the earliest stages of your C programming career, before you\u0026apos;re comfortable using anything other than \u0026lt;code\u0026gt;scanf\u0026lt;/code\u0026gt;, just \u0026lt;em\u0026gt;don\u0026apos;t worry about bad input\u0026lt;/em\u0026gt;.  Really.  Go ahead and use cop-out #2 above.  Think about it like this: You\u0026apos;re a beginner, there are lots of things you don\u0026apos;t know how to do yet, and one of the things you don\u0026apos;t know how to do yet is: deal gracefully with unexpected input.\u0026lt;/p\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;As soon as you can, \u0026lt;a href=\u0026quot;https://stackoverflow.com/questions/58403537/what-can-i-use-to-parse-input-instead-of-scanf\u0026quot;\u0026gt;learn how to do input using functions other than \u0026lt;code\u0026gt;scanf\u0026lt;/code\u0026gt;\u0026lt;/a\u0026gt;.  At that point, you can start dealing gracefully with bad input, and you\u0026apos;ll have many more, much better techniques available to you, that won\u0026apos;t require trying to \u0026quot;flush the bad input\u0026quot; at all.\u0026lt;/p\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;/ol\u0026gt;\n\u0026lt;p\u0026gt;Or, in other words, beginners who are still stuck using \u0026lt;code\u0026gt;scanf\u0026lt;/code\u0026gt; should feel free to use cop-out #2, and when they\u0026apos;re ready they should graduate from there to technique #3, and nobody should be using technique #1 to try to flush input at all -- and certainly not with \u0026lt;code\u0026gt;fflush(stdin)\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Using \u0026lt;code\u0026gt;fflush(stdin)\u0026lt;/code\u0026gt; to flush input is kind of like \u0026lt;a href=\u0026quot;https://en.wikipedia.org/wiki/Dowsing\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;dowsing for water\u0026lt;/a\u0026gt; using a stick shaped like the letter \u0026quot;S\u0026quot;.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;And helping people to flush input in some \u0026quot;better\u0026quot; way is kind of like rushing up to an S-stick dowser and saying \u0026quot;No, no, you\u0026apos;re doing it wrong,\nyou need to use a Y-shaped stick!\u0026quot;.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;In other words, the real problem isn\u0026apos;t that \u0026lt;code\u0026gt;fflush(stdin)\u0026lt;/code\u0026gt; doesn\u0026apos;t work.  Calling \u0026lt;code\u0026gt;fflush(stdin)\u0026lt;/code\u0026gt; is a symptom of an underlying problem.  Why are you having to \u0026quot;flush\u0026quot; input at all?  \u0026lt;em\u0026gt;That\u0026apos;s\u0026lt;/em\u0026gt; your problem.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;And, usually, that underlying problem is that you\u0026apos;re using \u0026lt;code\u0026gt;scanf\u0026lt;/code\u0026gt;, in one of its many unhelpful modes that unexpectedly leaves newlines or other \u0026quot;unwanted\u0026quot; text on the input.  The best long-term solution, therefore, is to \u0026lt;a href=\u0026quot;https://stackoverflow.com/questions/58403537/what-can-i-use-for-input-conversion-instead-of-scanf\u0026quot;\u0026gt;learn how to do input using better techniques than \u0026lt;code\u0026gt;scanf\u0026lt;/code\u0026gt;\u0026lt;/a\u0026gt;, so that you don\u0026apos;t have to deal with its unhandled input and other idiosyncrasies at all.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;None of the existing answers point out a key aspect of the issue.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;If you find yourself \u0026lt;em\u0026gt;wanting\u0026lt;/em\u0026gt; to \u0026quot;clear the input buffer\u0026quot;, you\u0026apos;re probably writing a command-line interactive program, and it would be more accurate to say that what you want is to \u0026lt;em\u0026gt;discard characters from the current \u0026lt;strong\u0026gt;line\u0026lt;/strong\u0026gt; of input that you haven\u0026apos;t already read.\u0026lt;/em\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;This is not what \u0026lt;code\u0026gt;fflush(stdin)\u0026lt;/code\u0026gt; does.\u0026lt;/strong\u0026gt;  The C libraries that support using \u0026lt;code\u0026gt;fflush\u0026lt;/code\u0026gt; on an input stream, document it as either doing \u0026lt;em\u0026gt;nothing,\u0026lt;/em\u0026gt; or as discarding \u0026lt;em\u0026gt;buffered data that has been read from the underlying file but not passed to the application\u0026lt;/em\u0026gt;.  That can easily be either \u0026lt;em\u0026gt;more\u0026lt;/em\u0026gt; or \u0026lt;em\u0026gt;less\u0026lt;/em\u0026gt; input than the rest of the current line.  It probably does work by accident in a lot of cases, because the terminal driver (in its default mode) supplies input to a command-line interactive program one line at a time.  However, the moment you try to feed input to your program from an actual file on disk (perhaps for automated testing), the kernel and C library will switch over to buffering data in large \u0026quot;blocks\u0026quot; (often 4 to 8 kB) with no relationship to line boundaries, and you\u0026apos;ll be wondering why your program is processing the first line of the file and then skipping several dozen lines and picking up in the \u0026lt;em\u0026gt;middle\u0026lt;/em\u0026gt; of some apparently random line below.  Or, if you decide to test your program on a very \u0026lt;em\u0026gt;long\u0026lt;/em\u0026gt; line typed by hand, then the terminal driver won\u0026apos;t be able to give the program the whole line at once and \u0026lt;code\u0026gt;fflush(stdin)\u0026lt;/code\u0026gt; won\u0026apos;t skip all of it.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;So what should you do instead?  The approach that I prefer is, if you\u0026apos;re processing input one line at a time, then \u0026lt;em\u0026gt;read an entire line all at once\u0026lt;/em\u0026gt;.  The C library has functions specifically for this: \u0026lt;code\u0026gt;fgets\u0026lt;/code\u0026gt; (in C90, so fully portable, but does still make you process very long lines in chunks) and \u0026lt;code\u0026gt;getline\u0026lt;/code\u0026gt; (POSIX-specific, but will manage a \u0026lt;code\u0026gt;malloc\u0026lt;/code\u0026gt;ed buffer for you so you can process long lines all at once no matter how long they get).  There\u0026apos;s usually a direct translation from code that processes \u0026quot;the current line\u0026quot; directly from stdin to code that processes a string containing \u0026quot;the current line\u0026quot;.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Quote from \u0026lt;a href=\u0026quot;https://www.unix.com/man-page/posix/3P/fflush/\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot; title=\u0026quot;POSIX\u0026quot;\u0026gt;POSIX\u0026lt;/a\u0026gt;:\u0026lt;/p\u0026gt;\n\u0026lt;blockquote\u0026gt;\n\u0026lt;p\u0026gt;For  a  stream  open  for  reading, if the file is not already at EOF, and the file is one\ncapable of seeking, the file offset of the underlying open file description shall  be  set\nto  the   file  position  of  the stream, and any characters pushed back onto the stream by\nungetc() or ungetwc() that have not subsequently been read from the stream shall  be  dis-\ncarded (without further changing the file offset).\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\u0026lt;p\u0026gt;Note that terminal is not capable of seeking.\u0026lt;/p\u0026gt;\n    "],"id":314,"title":"Using fflush(stdin)","content":"\n                \n\u0026lt;p\u0026gt;So a quick Google search for \u0026lt;code\u0026gt;fflush(stdin)\u0026lt;/code\u0026gt; for clearing the input buffer reveals numerous websites warning against using it. And yet that\u0026apos;s exactly how my CS professor taught the class to do it.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;How bad is using \u0026lt;code\u0026gt;fflush(stdin)\u0026lt;/code\u0026gt;? Should I really abstain from using it, even though my professor is using it and it seems to work flawlessly?\u0026lt;/p\u0026gt;\n    ","slug":"using-fflush(stdin)-1657387602771","postType":"QUESTION","createdAt":"2022-07-09T17:26:42.000Z","updatedAt":"2022-07-09T17:26:42.000Z","tags":[{"id":1849,"name":"stdin","slug":"stdin","createdAt":"2022-07-09T17:26:42.000Z","updatedAt":"2022-07-09T17:26:42.000Z","Questions_Tags":{"questionId":314,"tagId":1849}},{"id":1850,"name":"fflush","slug":"fflush","createdAt":"2022-07-09T17:26:42.000Z","updatedAt":"2022-07-09T17:26:42.000Z","Questions_Tags":{"questionId":314,"tagId":1850}}],"relatedQuestions":[{"title":"Using fflush(stdin)","slug":"using-fflush(stdin)-1657387602771","tags":[{"name":"stdin","Questions_Tags":{"questionId":314,"tagId":1849}},{"name":"fflush","Questions_Tags":{"questionId":314,"tagId":1850}}]}]},"randomQuestions":[{"title":"How do I access previous promise results in a .then() chain?","slug":"how-do-i-access-previous-promise-results-in-a-.then()-chain-1657387705386"},{"title":"What's the difference between INNER JOIN, LEFT JOIN, RIGHT JOIN and FULL JOIN? [duplicate]","slug":"what's-the-difference-between-inner-join-left-join-right-join-and-full-join-duplicate-1657388082887"},{"title":"Is storing a delimited list in a database column really that bad?","slug":"is-storing-a-delimited-list-in-a-database-column-really-that-bad-1657384474773"},{"title":"How do you get the footer to stay at the bottom of a Web page?","slug":"how-do-you-get-the-footer-to-stay-at-the-bottom-of-a-web-page-1657387817544"},{"title":"How do you access the matched groups in a JavaScript regular expression?","slug":"how-do-you-access-the-matched-groups-in-a-javascript-regular-expression-1657388233817"},{"title":"What is the meaning of single and double underscore before an object name?","slug":"what-is-the-meaning-of-single-and-double-underscore-before-an-object-name-1657387926929"},{"title":"How to create a MySQL hierarchical recursive query?","slug":"how-to-create-a-mysql-hierarchical-recursive-query-1657387662163"},{"title":"Importing installed package from script raises \"AttributeError: module has no attribute\" or \"ImportError: cannot import name\"","slug":"importing-installed-package-from-script-raises-\"attributeerror:-module-has-no-attribute\"-or-\"importerror:-cannot-import-name\"-1657387790607"},{"title":"What is this weird colon-member (\" : \") syntax in the constructor?","slug":"what-is-this-weird-colon-member-(\"-:-\")-syntax-in-the-constructor-1657387264047"},{"title":"What does the comma operator , do?","slug":"what-does-the-comma-operator-do-1657388258021"},{"title":"What is the strict aliasing rule?","slug":"what-is-the-strict-aliasing-rule-1657384742852"},{"title":"How do I match any character across multiple lines in a regular expression?","slug":"how-do-i-match-any-character-across-multiple-lines-in-a-regular-expression-1657387839720"},{"title":"How can I make an AJAX call without jQuery?","slug":"how-can-i-make-an-ajax-call-without-jquery-1657388448955"},{"title":"Why is using 'eval' a bad practice?","slug":"why-is-using-'eval'-a-bad-practice-1657387348760"},{"title":"How can I validate an email address in JavaScript?","slug":"how-can-i-validate-an-email-address-in-javascript-1657385475959"},{"title":"What are good ways to prevent SQL injection? [duplicate]","slug":"what-are-good-ways-to-prevent-sql-injection-duplicate-1657388431570"},{"title":"What does a space mean in a CSS selector? i.e. What is the difference between .classA.classB and .classA .classB?","slug":"what-does-a-space-mean-in-a-css-selector-i.e.-what-is-the-difference-between-.classa.classb-and-.classa-.classb-1657387912095"},{"title":"How can I transition height: 0; to height: auto; using CSS?","slug":"how-can-i-transition-height:-0-to-height:-auto-using-css-1657388022100"},{"title":"Why does my function that calls an API or launches a coroutine return an empty or null value?","slug":"why-does-my-function-that-calls-an-api-or-launches-a-coroutine-return-an-empty-or-null-value-1657388483820"},{"title":"How to remove/delete a large file from commit history in the Git repository?","slug":"how-to-removedelete-a-large-file-from-commit-history-in-the-git-repository-1657387589093"}]},"__N_SSG":true},"page":"/questions/[slug]","query":{"slug":"using-fflush(stdin)-1657387602771"},"buildId":"xZs8haGjOP63QuDE0kxeX","isFallback":false,"gsp":true,"locale":"en","locales":["en"],"defaultLocale":"en","scriptLoader":[]}</script></body></html>