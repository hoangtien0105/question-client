<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><meta name="twitter:card" content="summary_large_image"/><meta name="twitter:site" content="@solutionschecker.com"/><meta name="twitter:creator" content="@solutionschecker.com"/><meta property="og:url" content="https://solutionschecker.com"/><meta property="og:type" content="website"/><meta property="og:image" content="https://solutionschecker.com/solutions-checker-banner.png"/><meta property="og:image:alt" content="Find solution for coding, HTML, CSS, JAVASCRIPT, MYSQL, PHP, PYTHON,... quickly. - solutionschecker.com"/><script type="application/ld+json">{"@context":"https://schema.org","@type":"Organization","logo":"/logo.svg","url":"https://solutionschecker.com"}</script><script type="application/ld+json">{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"item":{"@id":"https://solutionschecker.com","name":"Home"}},{"@type":"ListItem","position":2,"item":{"@id":"https://solutionschecker.com/questions","name":"Questions"}},{"@type":"ListItem","position":3,"item":{"@id":"https://solutionschecker.com/questions/use-of-&apos;prototype&apos;-vs.-&apos;this&apos;-in-javascript-1657388117307","name":"Questions"}}]}</script><title>Use of &#x27;prototype&#x27; vs. &#x27;this&#x27; in JavaScript? | Solutions Checker</title><meta name="robots" content="index,follow"/><meta name="description" content="What&#x27;s the difference between

var A = function () {
    this.x = function () {
        //do something
    };
};


and

var A = function () { };
A.prototype.x = function () {
    //do something
};

    "/><meta property="og:title" content="Use of &#x27;prototype&#x27; vs. &#x27;this&#x27; in JavaScript? | Solutions Checker"/><meta property="og:description" content="What&#x27;s the difference between

var A = function () {
    this.x = function () {
        //do something
    };
};


and

var A = function () { };
A.prototype.x = function () {
    //do something
};

    "/><script type="application/ld+json">{"@context":"https://schema.org","@type":"QAPage","mainEntity":{"name":"Use of &apos;prototype&apos; vs. &apos;this&apos; in JavaScript?","text":"What&apos;s the difference between\n\nvar A = function () {\n    this.x = function () {\n        //do something\n    };\n};\n\n\nand\n\nvar A = function () { };\nA.prototype.x = function () {\n    //do something\n};\n\n    ","answerCount":15,"upVoteCount":500,"suggestedAnswer":[{"text":"The examples have very different outcomes.\n\nBefore looking at the differences, the following should be noted:\n\n\nA constructor&apos;s prototype provides a way to share methods and values among instances via the instance&apos;s private [[Prototype]] property.\nA function&apos;s this is set by how the function is called or by the use of bind (not discussed here). Where a function is called on an object (e.g. myObj.method()) then this within the method references the object. Where this is not set by the call or by the use of bind, it defaults to the global object (window in a browser) or in strict mode, remains undefined.\nJavaScript is an object-oriented language, i.e. most values are objects, including functions. (Strings, numbers, and booleans are not objects.)\n\n\nSo here are the snippets in question:\n\nvar A = function () {\n    this.x = function () {\n        //do something\n    };\n};\n\n\nIn this case, variable A is assigned a value that is a reference to a function.  When that function is called using A(), the function&apos;s this isn&apos;t set by the call so it defaults to the global object and the expression this.x is effective window.x. The result is that a reference to the function expression on the right-hand side is assigned to window.x.\n\nIn the case of:\n\nvar A = function () { };\nA.prototype.x = function () {\n    //do something\n};\n\n\nsomething very different occurs.  In the first line, variable A is assigned a reference to a function.  In JavaScript, all functions objects have a prototype property by default so there is no separate code to create an A.prototype object.\n\nIn the second line, A.prototype.x is assigned a reference to a function. This will create an x property if it doesn&apos;t exist, or assign a new value if it does. So the difference with the first example in which object&apos;s x property is involved in the expression.\n\nAnother example is below.  It&apos;s similar to the first one (and maybe what you meant to ask about):\n\nvar A = new function () {\n    this.x = function () {\n        //do something\n    };\n};\n\n\nIn this example, the new operator has been added before the function expression so that the function is called as a constructor. When called with new, the function&apos;s this is set to reference a new Object whose private [[Prototype]] property is set to reference the constructor&apos;s public prototype. So in the assignment statement, the x property will be created on this new object. When called as a constructor, a function returns its this object by default, so there is no need for a separate return this; statement.\n\nTo check that A has an x property:\n\nconsole.log(A.x) // function () {\n                 //   //do something\n                 // };\n\n\nThis is an uncommon use of new since the only way to reference the constructor is via A.constructor. It would be much more common to do:\n\nvar A = function () {\n    this.x = function () {\n        //do something\n    };\n};\nvar a = new A();\n\n\nAnother way of achieving a similar result is to use an immediately invoked function expression:\n\nvar A = (function () {\n    this.x = function () {\n        //do something\n    };\n}());\n\n\nIn this case, A assigned the return value of calling the function on the right-hand side. Here again, since this is not set in the call, it will reference the global object and this.x is effective window.x. Since the function doesn&apos;t return anything, A will have a value of undefined.\n\nThese differences between the two approaches also manifest if you&apos;re serializing and de-serializing your Javascript objects to/from JSON. Methods defined on an object&apos;s prototype are not serialized when you serialize the object, which can be convenient when for example you want to serialize just the data portions of an object, but not it&apos;s methods:\n\nvar A = function () { \n    this.objectsOwnProperties = &quot;are serialized&quot;;\n};\nA.prototype.prototypeProperties = &quot;are NOT serialized&quot;;\nvar instance = new A();\nconsole.log(instance.prototypeProperties); // &quot;are NOT serialized&quot;\nconsole.log(JSON.stringify(instance)); \n// {&quot;objectsOwnProperties&quot;:&quot;are serialized&quot;} \n\n\nRelated questions:\n\n\nWhat does it mean that JavaScript is a prototypal language?\nWhat is the scope of a function in JavaScript?\nHow does the &quot;this&quot; keyword work?\n\n\nSidenote: There may not be any significant memory savings between the two approaches, however using the prototype to share methods and properties will likely use less memory than each instance having its own copy.\n\nJavaScript isn&apos;t a low-level language.  It may not be very valuable to think of prototyping or other inheritance patterns as a way to explicitly change the way memory is allocated.\n    ","url":"/questions/[slug]#solution1","@type":"Answer","upvoteCount":0},{"text":"As others have said the first version, using &quot;this&quot; results in every instance of the class A having its own independent copy of function method &quot;x&quot;.  Whereas using &quot;prototype&quot; will mean that each instance of class A will use the same copy of method &quot;x&quot;.\n\nHere is some code to show this subtle difference:\n\n// x is a method assigned to the object using &quot;this&quot;\nvar A = function () {\n    this.x = function () { alert(&apos;A&apos;); };\n};\nA.prototype.updateX = function( value ) {\n    this.x = function() { alert( value ); }\n};\n\nvar a1 = new A();\nvar a2 = new A();\na1.x();  // Displays &apos;A&apos;\na2.x();  // Also displays &apos;A&apos;\na1.updateX(&apos;Z&apos;);\na1.x();  // Displays &apos;Z&apos;\na2.x();  // Still displays &apos;A&apos;\n\n// Here x is a method assigned to the object using &quot;prototype&quot;\nvar B = function () { };\nB.prototype.x = function () { alert(&apos;B&apos;); };\n\nB.prototype.updateX = function( value ) {\n    B.prototype.x = function() { alert( value ); }\n}\n\nvar b1 = new B();\nvar b2 = new B();\nb1.x();  // Displays &apos;B&apos;\nb2.x();  // Also displays &apos;B&apos;\nb1.updateX(&apos;Y&apos;);\nb1.x();  // Displays &apos;Y&apos;\nb2.x();  // Also displays &apos;Y&apos; because by using prototype we have changed it for all instances\n\n\nAs others have mentioned, there are various reasons to choose one method or the other.  My sample is just meant to clearly demonstrate the difference.\n    ","url":"/questions/[slug]#solution2","@type":"Answer","upvoteCount":0},{"text":"Take these 2 examples:\n\nvar A = function() { this.hey = function() { alert(&apos;from A&apos;) } };\n\n\nvs.\n\nvar A = function() {}\nA.prototype.hey = function() { alert(&apos;from prototype&apos;) };\n\n\nMost people here (especially the top-rated answers) tried to explain how they are different without explaining WHY. I think this is wrong and if you understand the fundamentals first, the difference will become obvious. Let&apos;s try to explain the fundamentals first...\n\na) A function is an object in JavaScript. EVERY object in JavaScript gets an internal property (meaning, you can&apos;t access it like other properties, except maybe in browsers like Chrome), often referred to as __proto__ (you can actually type anyObject.__proto__ in Chrome to see what it references. This is just that, a property, nothing more. A property in JavaScript = a variable inside an object, nothing more. What do variables do? They point to things.\n\nSo what does this __proto__ property points to? Well, usually another object (we&apos;ll explain why later). The only way to force JavaScript for the __proto__ property to NOT point to another object is to use var newObj = Object.create(null). Even if you do this, the __proto__ property STILL exists as a property of the object,  just it doesn&apos;t point to another object, it points to null.\n\nHere&apos;s where most people get confused:\n\nWhen you create a new function in JavaScript (which is an object as well, remember?), the moment it is defined, JavaScript automatically creates a new property on that function called prototype. Try it:\n\nvar A = [];\nA.prototype // undefined\nA = function() {}\nA.prototype // {} // got created when function() {} was defined\n\n\nA.prototype is TOTALLY DIFFERENT from the __proto__ property. In our example, &apos;A&apos; now has TWO properties called &apos;prototype&apos; and __proto__ . This is a big confusion for people. prototype and __proto__ properties are in no way related, they&apos;re separate things pointing to separate values.\n\nYou may wonder: Why does JavaScript has __proto__ property created on every single object? Well, one word: delegation. When you call a property on an object and the object doesn&apos;t have it, then JavaScript looks for the object referenced by __proto__ to see if it maybe has it. If it doesn&apos;t have it, then it looks at that object&apos;s __proto__ property and so on...until the chain ends. Thus the name prototype chain. Of course, if __proto__ doesn&apos;t point to an object and instead points to null, well tough luck, JavaScript realizes that and will return you undefined for the property.\n\nYou may also wonder, why does JavaScript creates a property called prototype for a function when you define the function? Because it tries to fool you, yes fool you that it works like class-based languages. \n\nLet&apos;s go on with our example and create an &quot;object&quot; out of A:\n\nvar a1 = new A();\n\n\nThere&apos;s something happening in the background when this thing happened. a1 is an ordinary variable which was assigned a new, empty object.\n\nThe fact that you used the operator new before a function invocation A() did something ADDITIONAL in the background. The new keyword created a new object which now references a1 and that object is empty. Here&apos;s what happening additionally:\n\nWe said that on each function definition there&apos;s a new property created called prototype (which you can access it, unlike with the __proto__ property) created? Well, that property is being used now.\n\nSo we&apos;re now at the point where we have a freshly baked empty a1 object. We said that all objects in JavaScript have an internal __proto__ property which points to something (a1 also has it), whether it&apos;s null or another object. What the new operator does is that it sets that __proto__ property to point to the function&apos;s prototype property. Read that again. It&apos;s basically this:\n\na1.__proto__ = A.prototype;\n\n\nWe said that A.prototype is nothing more than an empty object (unless we change it to something else before defining a1). So now basically a1.__proto__ points to the same thing A.prototype points to, which is that empty object. They both point to the same object which was created when this line happened:\n\nA = function() {} // JS: cool. let&apos;s also create A.prototype pointing to empty {}\n\n\nNow, there&apos;s another thing happening when var a1 = new A() statement is processed. Basically A() is executed and if A is something like this:\n\nvar A = function() { this.hey = function() { alert(&apos;from A&apos;) } };\n\n\nAll that stuff inside function() { } is going to execute. When you reach the this.hey.. line, this is changed to a1 and you get this:\n\na1.hey = function() { alert(&apos;from A&apos;) }\n\n\nI won&apos;t cover why this changes to a1 but this is a great answer to learn more.\n\nSo to summarize, when you do var a1 = new A() there are 3 things happening in the background:\n\n\nA totally new empty object is created and assigned to a1. a1 = {}\na1.__proto__ property is assigned to point at the same thing as A.prototype points to (another empty object {} )\nThe function A() is being executed with this set to the new, empty object created in step 1 (read the answer I referenced above as to why this changes to a1)\n\n\nNow, let&apos;s try to create another object:\n\nvar a2 = new A();\n\n\nSteps 1,2,3 will repeat. Do you notice something? The key word is repeat. Step 1: a2 will be a new empty object, step 2: its __proto__ property will point to the same thing A.prototype points to and most importantly, step 3: function A() is AGAIN executed, which means that a2 will get hey property containing a function. a1 and a2 have two SEPARATE properties named hey which point to 2 SEPARATE functions! We now have duplicate functions in same two different objects doing the same thing, oops...You can imagine the memory implications of this if we have 1000 objects created with new A, after all functions declarations take more memory than something like the number 2. So how do we prevent this?\n\nRemember why the __proto__ property exists on every object? So that if you retrieve the yoMan property on a1 (which doesn&apos;t exist), its __proto__ property will be consulted, which if it&apos;s an object (and is most cases it is), it will check if it contains yoMan, and if it doesn&apos;t, it will consult that object&apos;s __proto__ etc. If it does, it will take that property value and display it to you.\n\nSo someone decided to use this fact + the fact that when you create a1, its __proto__ property points to the same (empty) object A.prototype points to and do this:\n\nvar A = function() {}\nA.prototype.hey = function() { alert(&apos;from prototype&apos;) };\n\n\nCool! Now, when you create a1, it again goes through all of the 3 steps above, and in step 3, it doesn&apos;t do anything, since function A() has nothing to execute. And if we do:\n\na1.hey\n\n\nIt will see that a1 does not contain hey and it will check its __proto__ property object to see if it has it, which is the case.\n\nWith this approach we eliminate the part from step 3 where functions are duplicated on each new object creation. Instead of a1 and a2 having a separate hey property, now NONE of them has it. Which, I guess, you figured out yourself by now. That&apos;s the nice thing...if you understand __proto__ and Function.prototype, questions like these will be pretty obvious.\n\nNOTE: Some people tend to not call the internal Prototype property as __proto__, I&apos;ve used this name through the post to distinguish it clearly to the Functional.prototype property as two different things.\n    ","url":"/questions/[slug]#solution3","@type":"Answer","upvoteCount":0},{"text":"In most cases they are essentially the same, but the second version saves memory because there is only one instance of the function instead of a separate function for each object.\n\nA reason to use the first form is to access &quot;private members&quot;. For example:\n\nvar A = function () {\n    var private_var = ...;\n\n    this.x = function () {\n        return private_var;\n    };\n\n    this.setX = function (new_x) {\n        private_var = new_x;\n    };\n};\n\n\nBecause of javascript&apos;s scoping rules, private_var is available to the function assigned to this.x, but not outside the object.\n    ","url":"/questions/[slug]#solution4","@type":"Answer","upvoteCount":0},{"text":"The first example changes the interface for that object only. The second example changes the interface for all object of that class.\n    ","url":"/questions/[slug]#solution5","@type":"Answer","upvoteCount":0},{"text":"The ultimate problem with using this instead of prototype is that when overriding a method, the constructor of the base class will still refer to the overridden method. Consider this:\n\nBaseClass = function() {\n    var text = null;\n\n    this.setText = function(value) {\n        text = value + &quot; BaseClass!&quot;;\n    };\n\n    this.getText = function() {\n        return text;\n    };\n\n    this.setText(&quot;Hello&quot;); // This always calls BaseClass.setText()\n};\n\nSubClass = function() {\n    // setText is not overridden yet,\n    // so the constructor calls the superclass&apos; method\n    BaseClass.call(this);\n\n    // Keeping a reference to the superclass&apos; method\n    var super_setText = this.setText;\n    // Overriding\n    this.setText = function(value) {\n        super_setText.call(this, &quot;SubClass says: &quot; + value);\n    };\n};\nSubClass.prototype = new BaseClass();\n\nvar subClass = new SubClass();\nconsole.log(subClass.getText()); // Hello BaseClass!\n\nsubClass.setText(&quot;Hello&quot;); // setText is already overridden\nconsole.log(subClass.getText()); // SubClass says: Hello BaseClass!\n\n\nversus:\n\nBaseClass = function() {\n    this.setText(&quot;Hello&quot;); // This calls the overridden method\n};\n\nBaseClass.prototype.setText = function(value) {\n    this.text = value + &quot; BaseClass!&quot;;\n};\n\nBaseClass.prototype.getText = function() {\n    return this.text;\n};\n\nSubClass = function() {\n    // setText is already overridden, so this works as expected\n    BaseClass.call(this);\n};\nSubClass.prototype = new BaseClass();\n\nSubClass.prototype.setText = function(value) {\n    BaseClass.prototype.setText.call(this, &quot;SubClass says: &quot; + value);\n};\n\nvar subClass = new SubClass();\nconsole.log(subClass.getText()); // SubClass says: Hello BaseClass!\n\n\nIf you think this is not a problem, then it depends on whether you can live without private variables, and whether you are experienced enough to know a leak when you see one. Also, having to put the constructor logic after the method definitions is inconvenient.\n\nvar A = function (param1) {\n    var privateVar = null; // Private variable\n\n    // Calling this.setPrivateVar(param1) here would be an error\n\n    this.setPrivateVar = function (value) {\n        privateVar = value;\n        console.log(&quot;setPrivateVar value set to: &quot; + value);\n\n        // param1 is still here, possible memory leak\n        console.log(&quot;setPrivateVar has param1: &quot; + param1);\n    };\n\n    // The constructor logic starts here possibly after\n    // many lines of code that define methods\n\n    this.setPrivateVar(param1); // This is valid\n};\n\nvar a = new A(0);\n// setPrivateVar value set to: 0\n// setPrivateVar has param1: 0\n\na.setPrivateVar(1);\n//setPrivateVar value set to: 1\n//setPrivateVar has param1: 0\n\n\nversus:\n\nvar A = function (param1) {\n    this.setPublicVar(param1); // This is valid\n};\nA.prototype.setPublicVar = function (value) {\n    this.publicVar = value; // No private variable\n};\n\nvar a = new A(0);\na.setPublicVar(1);\nconsole.log(a.publicVar); // 1\n\n    ","url":"/questions/[slug]#solution6","@type":"Answer","upvoteCount":0},{"text":"Every object is linked to a prototype object. When trying to access a property that does not exist, JavaScript will look in the object&apos;s prototype object for that property and return it if it exists.\n\nThe prototype property of a function constructor refers to the prototype object of all instances created with that function when using new.\n\n\n\nIn your first example, you are adding a property x to each instance created with the A function.\n\nvar A = function () {\n    this.x = function () {\n        //do something\n    };\n};\n\nvar a = new A();    // constructor function gets executed\n                    // newly created object gets an &apos;x&apos; property\n                    // which is a function\na.x();              // and can be called like this\n\n\nIn the second example you are adding a property to the prototype object that all the instances created with A point to.\n\nvar A = function () { };\nA.prototype.x = function () {\n    //do something\n};\n\nvar a = new A();    // constructor function gets executed\n                    // which does nothing in this example\n\na.x();              // you are trying to access the &apos;x&apos; property of an instance of &apos;A&apos;\n                    // which does not exist\n                    // so JavaScript looks for that property in the prototype object\n                    // that was defined using the &apos;prototype&apos; property of the constructor\n\n\n\n\nIn conclusion, in the first example a copy of the function is assigned to each instance. In the second example a single copy of the function is shared by all instances.\n    ","url":"/questions/[slug]#solution7","@type":"Answer","upvoteCount":0},{"text":"What&apos;s the difference? =&gt; A lot.\n\nI think, the this version is used to enable encapsulation, i.e. data hiding.\nIt helps to manipulate private variables.\n\nLet us look at the following example:   \n\nvar AdultPerson = function() {\n\n  var age;\n\n  this.setAge = function(val) {\n    // some housekeeping\n    age = val &gt;= 18 &amp;&amp; val;\n  };\n\n  this.getAge = function() {\n    return age;\n  };\n\n  this.isValid = function() {\n    return !!age;\n  };\n};\n\n\nNow, the prototype structure can be applied as following:\n\nDifferent adults have different ages, but all of the adults get the same rights.\nSo, we add it using prototype, rather than this.\n\nAdultPerson.prototype.getRights = function() {\n  // Should be valid\n  return this.isValid() &amp;&amp; [&apos;Booze&apos;, &apos;Drive&apos;];\n};\n\n\nLets look at the implementation now.\n\nvar p1 = new AdultPerson;\np1.setAge(12); // ( age = false )\nconsole.log(p1.getRights()); // false ( Kid alert! )\np1.setAge(19); // ( age = 19 )\nconsole.log(p1.getRights()); // [&apos;Booze&apos;, &apos;Drive&apos;] ( Welcome AdultPerson )\n\nvar p2 = new AdultPerson;\np2.setAge(45);    \nconsole.log(p2.getRights()); // The same getRights() method, *** not a new copy of it ***\n\n\nHope this helps.\n    ","url":"/questions/[slug]#solution8","@type":"Answer","upvoteCount":0},{"text":"I know this has been answered to death but I&apos;d like to show an actual example of speed differences.\nFunction directly on object:\n\n\nfunction ExampleFn() {\n    this.print = function() {\n        console.log(&quot;Calling print! &quot;);\n    }\n}\n\nvar objects = [];\nconsole.time(&apos;x&apos;);\nfor (let i = 0; i &lt; 2000000; i++) {\n    objects.push(new ExampleFn());\n}\nconsole.timeEnd(&apos;x&apos;);\n\n//x: 1151.960693359375ms\n Run code snippetHide resultsExpand snippet\n\n\nFunction on prototype:\n\n\nfunction ExampleFn() {\n}\nExampleFn.prototype.print = function() {\n    console.log(&quot;Calling print!&quot;);\n}\n\nvar objects = [];\nconsole.time(&apos;y&apos;);\nfor (let i = 0; i &lt; 2000000; i++) {\n    objects.push(new ExampleFn());\n}\nconsole.timeEnd(&apos;y&apos;);\n\n//x: 617.866943359375ms\n Run code snippetHide resultsExpand snippet\n\n\nHere we&apos;re creating 2,000,000 new objects with a print method in Chrome. We&apos;re storing every object in an array. Putting print on the prototype takes about 1/2 as long.\n    ","url":"/questions/[slug]#solution9","@type":"Answer","upvoteCount":0},{"text":"Prototype is the template of the class; which applies to all future instances of it. Whereas this is the particular instance of the object.\n    ","url":"/questions/[slug]#solution10","@type":"Answer","upvoteCount":0},{"text":"Let me give you a more comprehensive answer that I learned during a JavaScript training course.\n\nMost answers mentioned the difference already, i.e. when prototyping the function is shared with all (future) instances. Whereas declaring the function in the class will create a copy for each instance.\n\nIn general there is no right or wrong, it&apos;s more a matter of taste or a design decision depending on your requirements. The prototype however is the technique that is used to develop in an object oriented manner, as I hope you&apos;ll see at the end of this answer.\n\nYou showed two patterns in your question. I will try to explain two more and try to explain the differences if relevant. Feel free to edit/extend.\nIn all examples it is about a car object that has a location and can move.\n\nObject Decorator pattern\n\nNot sure if this pattern is still relevant nowadays, but it exists. And it is good to know about it.\nYou simply pass an object and a property to the decorator function. The decorator returns the object with property and method.\n\nvar carlike = function(obj, loc) {\n    obj.loc = loc;\n    obj.move = function() {\n        obj.loc++;\n    };\n    return obj;\n};\n\nvar amy = carlike({}, 1);\namy.move();\nvar ben = carlike({}, 9);\nben.move();\n\n\nFunctional Classes\n\nA function in JavaScript is a specialised object. In addition to being invoked, a function can store properties like any other object.\n\nIn this case Car is a function (also think object) that can be invoked as you are used to do. It has a property methods (which is an object with a move function). When Car is invoked the extend function is called, which does some magic, and extends the Car function (think object) with the methods defined within methods.\n\nThis example, though different, comes closest to the first example in the question.\n\nvar Car = function(loc) {\n    var obj = {loc: loc};\n    extend(obj, Car.methods);\n    return obj;\n};\n\nCar.methods = {\n    move : function() {\n        this.loc++;\n    }\n};\n\nvar amy = Car(1);\namy.move();\nvar ben = Car(9);\nben.move();\n\n\nPrototypal Classes\n\nThe first two patterns allow a discussion of using techniques to define  shared methods or using methods that are defined inline in the body of the constructor. In both cases every instance has its own move function.\n\nThe prototypal pattern does not lend itself well to the same examination, because function sharing via a prototype delegation is the very goal for the prototypal pattern. As others pointed out, it is expected to have a better memory footprint.\n\nHowever there is one point interesting to know:\nEvery prototype object has has a convenience property constructor, which points back to the function (think object) it came attached to.\n\nConcerning the last three lines:\n\nIn this example Car links to the prototype object, which links via constructor to Car itself, i.e. Car.prototype.constructor is Car itself. This allows you to figure out which constructor function built a certain object.\n\namy.constructor&apos;s lookup fails and thus is delegated to Car.prototype, which does have the constructor property. And so amy.constructor is Car.\n\nFurthermore, amy is an instanceof Car. The instanceof operator works by seeing if the right operand&apos;s prototype object (Car) can be found anywhere in the left operand&apos;s prototype (amy) chain.\n\nvar Car = function(loc) {\n    var obj = Object.create(Car.prototype);\n    obj.loc = loc;\n    return obj;\n};\n\nCar.prototype.move = function() {\n        this.loc++;\n};\n\nvar amy = Car(1);\namy.move();\nvar ben = Car(9);\nben.move();\n\nconsole.log(Car.prototype.constructor);\nconsole.log(amy.constructor);\nconsole.log(amy instanceof Car);\n\n\nSome developers can be confused in the beginning. See below example:\n\nvar Dog = function() {\n  return {legs: 4, bark: alert};\n};\n\nvar fido = Dog();\nconsole.log(fido instanceof Dog);\n\n\nThe instanceof operator returns false, because Dog&apos;s prototype cannot be found anywhere in fido&apos;s prototype chain. fido is a simple object that is created with an object literal, i.e. it just delegates to Object.prototype.\n\nPseudoclassical patterns\n\nThis is really just another form of the prototypal pattern in simplified form and more familiar to do those who program in Java for example, since it uses the new constructor.\n\nIt does the same as in the prototypal pattern really, it is just syntactic sugar overtop of the prototypal pattern.\n\nHowever, the primary difference is that there are optimizations implemented in JavaScript engines that only apply when using the pseudoclassical pattern. Think of the pseudoclassical pattern a probably faster version of the prototypal pattern; the object relations in both examples are the same.\n\nvar Car = function(loc) {\n    this.loc = loc;\n};\n\nCar.prototype.move = function() {\n        this.loc++;\n};\n\nvar amy = new Car(1);\namy.move();\nvar ben = new Car(9);\nben.move();\n\n\n\n\nFinally, it should not be too difficult to realize how object oriented programming can be done. There are two sections. \n\nOne section that defines common properties/methods in the prototype (chain).\n\nAnd another section where you put the definitions that distinguish the objects from each other (loc variable in the examples).\n\nThis is what allows us to apply concepts like superclass or subclass in JavaScript.\n\nFeel free to add or edit. Once more complete I could make this a community wiki maybe.\n    ","url":"/questions/[slug]#solution11","@type":"Answer","upvoteCount":0},{"text":"I believe that @Matthew Crumley is right.  They are functionally, if not structurally, equivalent.  If you use Firebug to look at the objects that are created using new, you can see that they are the same.  However, my preference would be the following.  I&apos;m guessing that it just seems more like what I&apos;m used to in C#/Java.  That is, define the class, define the fields, constructor, and methods.\n\nvar A = function() {};\nA.prototype = {\n    _instance_var: 0,\n\n    initialize: function(v) { this._instance_var = v; },\n\n    x: function() {  alert(this._instance_var); }\n};\n\n\nEDIT Didn&apos;t mean to imply that the scope of the variable was private, I was just trying to illustrate how I define my classes in javascript.  Variable name has been changed to reflect this.\n    ","url":"/questions/[slug]#solution12","@type":"Answer","upvoteCount":0},{"text":"As discussed in other answers, it&apos;s really a performance consideration because the function in the prototype is shared with all of the instantiations - rather than the function being created for each instantiation.\n\nI put together a jsperf to show this. There is a dramatic difference in the time it takes to instantiate the class, although it is really only relevant if you are making many instances.\n\nhttp://jsperf.com/functions-in-constructor-vs-prototype\n    ","url":"/questions/[slug]#solution13","@type":"Answer","upvoteCount":0},{"text":"Think about statically typed language, things on prototype are static and things on this are instance related.\n    ","url":"/questions/[slug]#solution14","@type":"Answer","upvoteCount":0},{"text":"When you use prototype, the function will only be loaded only once into memory (independently on the amount of objects you create) and you can override the function whenever you want.\n    ","url":"/questions/[slug]#solution15","@type":"Answer","upvoteCount":0}],"@type":"Question"}}</script><meta name="next-head-count" content="17"/><link rel="preload" href="/_next/static/css/08bcc42a26fe5c92.css" as="style"/><link rel="stylesheet" href="/_next/static/css/08bcc42a26fe5c92.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-0d1b80a048d4787e.js"></script><script src="/_next/static/chunks/webpack-42cdea76c8170223.js" defer=""></script><script src="/_next/static/chunks/framework-4556c45dd113b893.js" defer=""></script><script src="/_next/static/chunks/main-ccfab947c79712f4.js" defer=""></script><script src="/_next/static/chunks/pages/_app-7e79b78ef884195a.js" defer=""></script><script src="/_next/static/chunks/294-106ef8570fa99deb.js" defer=""></script><script src="/_next/static/chunks/490-7f0418bb4354ac73.js" defer=""></script><script src="/_next/static/chunks/pages/questions/%5Bslug%5D-c1a73f3e758d48b9.js" defer=""></script><script src="/_next/static/XDXakEY6gSPdgAODPxtjg/_buildManifest.js" defer=""></script><script src="/_next/static/XDXakEY6gSPdgAODPxtjg/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="wrapper"><header><nav class="bg-white border-gray-200 px-4 lg:px-6 py-2.5 dark:bg-gray-800"><div class="flex flex-wrap justify-between items-center mx-auto max-w-screen-xl"><a class="flex items-center" href="/"><img src="/logo-second.png" class="mr-3 h-6 sm:h-9" alt="Solution Checker Logo"/><h4 class="self-center text-xl font-semibold whitespace-nowrap dark:text-white">Solution Checker</h4></a><div class="flex items-center lg:order-2"><button data-collapse-toggle="mobile-menu-2" type="button" class="inline-flex items-center p-2 ml-1 text-sm text-gray-500 rounded-lg lg:hidden hover:bg-gray-100 focus:outline-none focus:ring-2 focus:ring-gray-200 dark:text-gray-400 dark:hover:bg-gray-700 dark:focus:ring-gray-600" aria-controls="mobile-menu-2" aria-expanded="false"><span class="sr-only">Open main menu</span><svg class="w-6 h-6" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M3 5a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM3 10a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM3 15a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1z" clip-rule="evenodd"></path></svg><svg class="hidden w-6 h-6" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z" clip-rule="evenodd"></path></svg></button></div><div class="hidden justify-between items-center w-full lg:flex lg:w-auto lg:order-1" id="mobile-menu-2"><ul class="flex flex-col mt-4 font-medium lg:flex-row lg:space-x-8 lg:mt-0"><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" aria-current="page" href="/">Home</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/questions?tab=news">Questions</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/post?tab=news">Post</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/questions/use-of-&#x27;prototype&#x27;-vs.-&#x27;this&#x27;-in-javascript-1657388117307#">Coding</a></li></ul></div></div></nav></header><div class="main-content"><div class="question my-5"><div class="flex question-header items-center m-auto justify-center"><div class="rounded-xl w-full border p-5 shadow-md bg-white"><div class="flex w-full items-center justify-between border-b pb-3"><div class="flex items-center space-x-3"><div class="text-lg font-bold text-slate-700"><a href="/questions/use-of-&#x27;prototype&#x27;-vs.-&#x27;this&#x27;-in-javascript-1657388117307"><h1>Use of &#x27;prototype&#x27; vs. &#x27;this&#x27; in JavaScript?</h1></a></div></div><div class="flex flex-wrap h-auto justify-end items-center space-x-8"></div></div><div class="question-content mt-5">
                
<p>What's the difference between</p>

<pre class="lang-js s-code-block"><code class="hljs language-javascript"><span class="hljs-keyword">var</span> A = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">x</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
        <span class="hljs-comment">//do something</span>
    };
};
</code></pre>

<p>and</p>

<pre class="lang-js s-code-block"><code class="hljs language-javascript"><span class="hljs-keyword">var</span> A = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) { };
A.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">x</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
    <span class="hljs-comment">//do something</span>
};
</code></pre>
    </div></div></div><div class="solution-section"><nav class="flex pagination-solution flex-col justify-end"><ul class="inline-flex -space-x-px overflow-auto"><li class="pagination-solution-item"><span data-id="#solution1" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">1</span></li><li class="pagination-solution-item"><span data-id="#solution2" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">2</span></li><li class="pagination-solution-item"><span data-id="#solution3" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">3</span></li><li class="pagination-solution-item"><span data-id="#solution4" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">4</span></li><li class="pagination-solution-item"><span data-id="#solution5" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">5</span></li><li class="pagination-solution-item"><span data-id="#solution6" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">6</span></li><li class="pagination-solution-item"><span data-id="#solution7" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">7</span></li><li class="pagination-solution-item"><span data-id="#solution8" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">8</span></li><li class="pagination-solution-item"><span data-id="#solution9" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">9</span></li><li class="pagination-solution-item"><span data-id="#solution10" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">10</span></li><li class="pagination-solution-item"><span data-id="#solution11" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">11</span></li><li class="pagination-solution-item"><span data-id="#solution12" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">12</span></li><li class="pagination-solution-item"><span data-id="#solution13" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">13</span></li><li class="pagination-solution-item"><span data-id="#solution14" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">14</span></li><li class="pagination-solution-item"><span data-id="#solution15" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">15</span></li></ul></nav><div id="solution1" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 1</h4><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>The examples have very different outcomes.</p>

<p>Before looking at the differences, the following should be noted:</p>

<ul>
<li>A constructor's <em>prototype</em> provides a way to share methods and values among instances via the instance's private <code>[[Prototype]]</code> property.</li>
<li>A function's <em>this</em> is set by how the function is called or by the use of <em>bind</em> (not discussed here). Where a function is called on an object (e.g. <code>myObj.method()</code>) then <em>this</em> within the method references the object. Where <em>this</em> is not set by the call or by the use of <em>bind</em>, it defaults to the global object (window in a browser) or in strict mode, remains undefined.</li>
<li>JavaScript is an object-oriented language, i.e. most values are objects, including functions. (Strings, numbers, and booleans are <em>not</em> objects.)</li>
</ul>

<p>So here are the snippets in question:</p>

<pre class="lang-js s-code-block"><code class="hljs language-javascript"><span class="hljs-keyword">var</span> A = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">x</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
        <span class="hljs-comment">//do something</span>
    };
};
</code></pre>

<p>In this case, variable <code>A</code> is assigned a value that is a reference to a function.  When that function is called using <code>A()</code>, the function's <em>this</em> isn't set by the call so it defaults to the global object and the expression <code>this.x</code> is effective <code>window.x</code>. The result is that a reference to the function expression on the right-hand side is assigned to <code>window.x</code>.</p>

<p>In the case of:</p>

<pre class="lang-js s-code-block"><code class="hljs language-javascript"><span class="hljs-keyword">var</span> A = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) { };
A.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">x</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
    <span class="hljs-comment">//do something</span>
};
</code></pre>

<p>something very different occurs.  In the first line, variable <code>A</code> is assigned a reference to a function.  In JavaScript, all functions objects have a <em>prototype</em> property by default so there is no separate code to create an <em>A.prototype</em> object.</p>

<p>In the second line, <em>A.prototype.x</em> is assigned a reference to a function. This will create an <em>x</em> property if it doesn't exist, or assign a new value if it does. So the difference with the first example in which object's <em>x</em> property is involved in the expression.</p>

<p>Another example is below.  It's similar to the first one (and maybe what you meant to ask about):</p>

<pre class="lang-js s-code-block"><code class="hljs language-javascript"><span class="hljs-keyword">var</span> A = <span class="hljs-keyword">new</span> <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">x</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
        <span class="hljs-comment">//do something</span>
    };
};
</code></pre>

<p>In this example, the <code>new</code> operator has been added before the function expression so that the function is called as a constructor. When called with <code>new</code>, the function's <em>this</em> is set to reference a new Object whose private <code>[[Prototype]]</code> property is set to reference the constructor's public <em>prototype</em>. So in the assignment statement, the <code>x</code> property will be created on this new object. When called as a constructor, a function returns its <em>this</em> object by default, so there is no need for a separate <code>return this;</code> statement.</p>

<p>To check that <em>A</em> has an <em>x</em> property:</p>

<pre class="lang-js s-code-block"><code class="hljs language-javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(A.<span class="hljs-property">x</span>) <span class="hljs-comment">// function () {</span>
                 <span class="hljs-comment">//   //do something</span>
                 <span class="hljs-comment">// };</span>
</code></pre>

<p>This is an uncommon use of <em>new</em> since the only way to reference the constructor is via <em>A.constructor</em>. It would be much more common to do:</p>

<pre class="lang-js s-code-block"><code class="hljs language-javascript"><span class="hljs-keyword">var</span> A = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">x</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
        <span class="hljs-comment">//do something</span>
    };
};
<span class="hljs-keyword">var</span> a = <span class="hljs-keyword">new</span> <span class="hljs-title function_">A</span>();
</code></pre>

<p>Another way of achieving a similar result is to use an immediately invoked function expression:</p>

<pre class="lang-js s-code-block"><code class="hljs language-javascript"><span class="hljs-keyword">var</span> A = (<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">x</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
        <span class="hljs-comment">//do something</span>
    };
}());
</code></pre>

<p>In this case, <code>A</code> assigned the return value of calling the function on the right-hand side. Here again, since <em>this</em> is not set in the call, it will reference the global object and <code>this.x</code> is effective <code>window.x</code>. Since the function doesn't return anything, <code>A</code> will have a value of <code>undefined</code>.</p>

<p>These differences between the two approaches also manifest if you're serializing and de-serializing your Javascript objects to/from JSON. Methods defined on an object's prototype are not serialized when you serialize the object, which can be convenient when for example you want to serialize just the data portions of an object, but not it's methods:</p>

<pre class="lang-js s-code-block"><code class="hljs language-javascript"><span class="hljs-keyword">var</span> A = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) { 
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">objectsOwnProperties</span> = <span class="hljs-string">"are serialized"</span>;
};
A.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">prototypeProperties</span> = <span class="hljs-string">"are NOT serialized"</span>;
<span class="hljs-keyword">var</span> instance = <span class="hljs-keyword">new</span> <span class="hljs-title function_">A</span>();
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(instance.<span class="hljs-property">prototypeProperties</span>); <span class="hljs-comment">// "are NOT serialized"</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(instance)); 
<span class="hljs-comment">// {"objectsOwnProperties":"are serialized"} </span>
</code></pre>

<p><strong>Related questions</strong>:</p>

<ul>
<li><a href="https://stackoverflow.com/questions/186244/what-does-it-mean-that-javascript-is-a-prototype-based-language"><strong>What does it mean that JavaScript is a prototypal language?</strong></a></li>
<li><a href="https://stackoverflow.com/questions/235360/what-is-the-scope-of-a-function-in-javascriptecmascript"><strong>What is the scope of a function in JavaScript?</strong></a></li>
<li><strong><a href="https://stackoverflow.com/questions/3127429/javascript-this-keyword">How does the "this" keyword work?</a></strong></li>
</ul>

<p><strong>Sidenote:</strong> There may not be any significant memory savings between the two approaches, however using the prototype to share methods and properties will likely use less memory than each instance having its own copy.</p>

<p>JavaScript isn't a low-level language.  It may not be very valuable to think of prototyping or other inheritance patterns as a way to explicitly change the way memory is allocated.</p>
    </div></div></div></div><div id="solution2" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 2</h4><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>As others have said the first version, using "this" results in every instance of the class A having its own independent copy of function method "x".  Whereas using "prototype" will mean that each instance of class A will use the same copy of method "x".</p>

<p>Here is some code to show this subtle difference:</p>

<pre class="lang-js s-code-block"><code class="hljs language-javascript"><span class="hljs-comment">// x is a method assigned to the object using "this"</span>
<span class="hljs-keyword">var</span> A = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">x</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) { <span class="hljs-title function_">alert</span>(<span class="hljs-string">'A'</span>); };
};
A.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">updateX</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"> value </span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">x</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) { <span class="hljs-title function_">alert</span>( value ); }
};

<span class="hljs-keyword">var</span> a1 = <span class="hljs-keyword">new</span> <span class="hljs-title function_">A</span>();
<span class="hljs-keyword">var</span> a2 = <span class="hljs-keyword">new</span> <span class="hljs-title function_">A</span>();
a1.<span class="hljs-title function_">x</span>();  <span class="hljs-comment">// Displays 'A'</span>
a2.<span class="hljs-title function_">x</span>();  <span class="hljs-comment">// Also displays 'A'</span>
a1.<span class="hljs-title function_">updateX</span>(<span class="hljs-string">'Z'</span>);
a1.<span class="hljs-title function_">x</span>();  <span class="hljs-comment">// Displays 'Z'</span>
a2.<span class="hljs-title function_">x</span>();  <span class="hljs-comment">// Still displays 'A'</span>

<span class="hljs-comment">// Here x is a method assigned to the object using "prototype"</span>
<span class="hljs-keyword">var</span> B = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) { };
B.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">x</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) { <span class="hljs-title function_">alert</span>(<span class="hljs-string">'B'</span>); };

B.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">updateX</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"> value </span>) {
    B.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">x</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) { <span class="hljs-title function_">alert</span>( value ); }
}

<span class="hljs-keyword">var</span> b1 = <span class="hljs-keyword">new</span> <span class="hljs-title function_">B</span>();
<span class="hljs-keyword">var</span> b2 = <span class="hljs-keyword">new</span> <span class="hljs-title function_">B</span>();
b1.<span class="hljs-title function_">x</span>();  <span class="hljs-comment">// Displays 'B'</span>
b2.<span class="hljs-title function_">x</span>();  <span class="hljs-comment">// Also displays 'B'</span>
b1.<span class="hljs-title function_">updateX</span>(<span class="hljs-string">'Y'</span>);
b1.<span class="hljs-title function_">x</span>();  <span class="hljs-comment">// Displays 'Y'</span>
b2.<span class="hljs-title function_">x</span>();  <span class="hljs-comment">// Also displays 'Y' because by using prototype we have changed it for all instances</span>
</code></pre>

<p>As others have mentioned, there are various reasons to choose one method or the other.  My sample is just meant to clearly demonstrate the difference.</p>
    </div></div></div></div><div id="solution3" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 3</h4><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Take these 2 examples:</p>

<pre class="lang-js s-code-block"><code class="hljs language-javascript"><span class="hljs-keyword">var</span> A = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) { <span class="hljs-variable language_">this</span>.<span class="hljs-property">hey</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) { <span class="hljs-title function_">alert</span>(<span class="hljs-string">'from A'</span>) } };
</code></pre>

<p>vs.</p>

<pre class="lang-js s-code-block"><code class="hljs language-javascript"><span class="hljs-keyword">var</span> A = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) {}
A.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">hey</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) { <span class="hljs-title function_">alert</span>(<span class="hljs-string">'from prototype'</span>) };
</code></pre>

<p>Most people here (especially the top-rated answers) tried to explain how they are different without explaining WHY. I think this is wrong and if you understand the fundamentals first, the difference will become obvious. Let's try to explain the fundamentals first...</p>

<p>a) A function is an object in JavaScript. EVERY object in JavaScript gets an internal property (meaning, you can't access it like other properties, except maybe in browsers like Chrome), often referred to as <code>__proto__</code> (you can actually type <code>anyObject.__proto__</code> in Chrome to see what it references. This is just that, a property, nothing more. A property in JavaScript = a variable inside an object, nothing more. What do variables do? They point to things.</p>

<p>So what does this <code>__proto__</code> property points to? Well, usually another object (we'll explain why later). The only way to force JavaScript for the <code>__proto__</code> property to NOT point to another object is to use <code>var newObj = Object.create(null)</code>. Even if you do this, the <code>__proto__</code> property STILL exists as a property of the object,  just it doesn't point to another object, it points to <code>null</code>.</p>

<p>Here's where most people get confused:</p>

<p>When you create a new function in JavaScript (which is an object as well, remember?), the moment it is defined, JavaScript automatically creates a new property on that function called <code>prototype</code>. Try it:</p>

<pre class="lang-js s-code-block"><code class="hljs language-javascript"><span class="hljs-keyword">var</span> A = [];
A.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> <span class="hljs-comment">// undefined</span>
A = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) {}
A.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> <span class="hljs-comment">// {} // got created when function() {} was defined</span>
</code></pre>

<p><code>A.prototype</code> is TOTALLY DIFFERENT from the <code>__proto__</code> property. In our example, 'A' now has TWO properties called 'prototype' and <code>__proto__</code> . This is a big confusion for people. <code>prototype</code> and <code>__proto__</code> properties are in no way related, they're separate things pointing to separate values.</p>

<p>You may wonder: Why does JavaScript has <code>__proto__</code> property created on every single object? Well, one word: <strong>delegation</strong>. When you call a property on an object and the object doesn't have it, then JavaScript looks for the object referenced by <code>__proto__</code> to see if it maybe has it. If it doesn't have it, then it looks at that object's <code>__proto__</code> property and so on...until the chain ends. Thus the name <strong>prototype chain</strong>. Of course, if <code>__proto__</code> doesn't point to an object and instead points to <code>null</code>, well tough luck, JavaScript realizes that and will return you <code>undefined</code> for the property.</p>

<p>You may also wonder, why does JavaScript creates a property called <code>prototype</code> for a function when you define the function? Because it tries to fool you, yes <strong>fool you</strong> that it works like class-based languages. </p>

<p>Let's go on with our example and create an "object" out of <code>A</code>:</p>

<pre class="lang-js s-code-block"><code class="hljs language-javascript"><span class="hljs-keyword">var</span> a1 = <span class="hljs-keyword">new</span> <span class="hljs-title function_">A</span>();
</code></pre>

<p>There's something happening in the background when this thing happened. <code>a1</code> is an ordinary variable which was assigned a new, empty object.</p>

<p>The fact that you used the operator <code>new</code> before a function invocation <code>A()</code> did something ADDITIONAL in the background. The <code>new</code> keyword created a new object which now references <code>a1</code> and that object is empty. Here's what happening additionally:</p>

<p>We said that on each function definition there's a new property created called <code>prototype</code> (which you can access it, unlike with the <code>__proto__</code> property) created? Well, that property is being used now.</p>

<p>So we're now at the point where we have a freshly baked empty <code>a1</code> object. We said that all objects in JavaScript have an internal <code>__proto__</code> property which points to something (<code>a1</code> also has it), whether it's null or another object. What the <code>new</code> operator does is that it sets that <code>__proto__</code> property to point to the function's <code>prototype</code> property. Read that again. It's basically this:</p>

<pre class="lang-js s-code-block"><code class="hljs language-javascript">a1.<span class="hljs-property">__proto__</span> = A.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>;
</code></pre>

<p>We said that <code>A.prototype</code> is nothing more than an empty object (unless we change it to something else before defining <code>a1</code>). So now basically <code>a1.__proto__</code> points to the same thing <code>A.prototype</code> points to, which is that empty object. They both point to the same object which was created when this line happened:</p>

<pre class="lang-js s-code-block"><code class="hljs language-javascript">A = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) {} <span class="hljs-comment">// JS: cool. let's also create A.prototype pointing to empty {}</span>
</code></pre>

<p>Now, there's another thing happening when <code>var a1 = new A()</code> statement is processed. Basically <code>A()</code> is executed and if A is something like this:</p>

<pre class="lang-js s-code-block"><code class="hljs language-javascript"><span class="hljs-keyword">var</span> A = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) { <span class="hljs-variable language_">this</span>.<span class="hljs-property">hey</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) { <span class="hljs-title function_">alert</span>(<span class="hljs-string">'from A'</span>) } };
</code></pre>

<p>All that stuff inside <code>function() { }</code> is going to execute. When you reach the <code>this.hey..</code> line, <code>this</code> is changed to <code>a1</code> and you get this:</p>

<pre class="lang-js s-code-block"><code class="hljs language-javascript">a1.<span class="hljs-property">hey</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) { <span class="hljs-title function_">alert</span>(<span class="hljs-string">'from A'</span>) }
</code></pre>

<p>I won't cover why <code>this</code> changes to <code>a1</code> but <a href="https://stackoverflow.com/a/80478/1085998">this is a great answer</a> to learn more.</p>

<p>So to summarize, when you do <code>var a1 = new A()</code> there are 3 things happening in the background:</p>

<ol>
<li>A totally new empty object is created and assigned to <code>a1</code>. <code>a1 = {}</code></li>
<li><p><code>a1.__proto__</code> property is assigned to point at the same thing as <code>A.prototype</code> points to (another empty object {} )</p></li>
<li><p>The function <code>A()</code> is being executed with <code>this</code> set to the new, empty object created in step 1 (read the answer I referenced above as to why <code>this</code> changes to <code>a1</code>)</p></li>
</ol>

<p>Now, let's try to create another object:</p>

<pre class="lang-js s-code-block"><code class="hljs language-javascript"><span class="hljs-keyword">var</span> a2 = <span class="hljs-keyword">new</span> <span class="hljs-title function_">A</span>();
</code></pre>

<p>Steps 1,2,3 will repeat. Do you notice something? The key word is <strong>repeat.</strong> Step 1: <code>a2</code> will be a new empty object, step 2: its <code>__proto__</code> property will point to the same thing <code>A.prototype</code> points to and most importantly, step 3: function <code>A()</code> is AGAIN executed, which means that <code>a2</code> will get <code>hey</code> property containing a function. <code>a1</code> and <code>a2</code> have two SEPARATE properties named <code>hey</code> which point to 2 SEPARATE functions! We now have duplicate functions in same two different objects doing the same thing, oops...You can imagine the memory implications of this if we have 1000 objects created with <code>new A</code>, after all functions declarations take more memory than something like the number 2. So how do we prevent this?</p>

<p>Remember why the <code>__proto__</code> property exists on every object? So that if you retrieve the <code>yoMan</code> property on <code>a1</code> (which doesn't exist), its <code>__proto__</code> property will be consulted, which if it's an object (and is most cases it is), it will check if it contains <code>yoMan</code>, and if it doesn't, it will consult that object's <code>__proto__</code> etc. If it does, it will take that property value and display it to you.</p>

<p>So someone decided to use this fact + the fact that when you create <code>a1</code>, its <code>__proto__</code> property points to the same (empty) object <code>A.prototype</code> points to and do this:</p>

<pre class="lang-js s-code-block"><code class="hljs language-javascript"><span class="hljs-keyword">var</span> A = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) {}
A.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">hey</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) { <span class="hljs-title function_">alert</span>(<span class="hljs-string">'from prototype'</span>) };
</code></pre>

<p>Cool! Now, when you create <code>a1</code>, it again goes through all of the 3 steps above, and in step 3, it doesn't do anything, since <code>function A()</code> has nothing to execute. And if we do:</p>

<pre class="lang-js s-code-block"><code class="hljs language-javascript">a1.<span class="hljs-property">hey</span>
</code></pre>

<p>It will see that <code>a1</code> does not contain <code>hey</code> and it will check its <code>__proto__</code> property object to see if it has it, which is the case.</p>

<p>With this approach we eliminate the part from step 3 where functions are duplicated on each new object creation. Instead of <code>a1</code> and <code>a2</code> having a separate <code>hey</code> property, now NONE of them has it. Which, I guess, you figured out yourself by now. That's the nice thing...if you understand <code>__proto__</code> and <code>Function.prototype</code>, questions like these will be pretty obvious.</p>

<p>NOTE: Some people tend to not call the internal Prototype property as <code>__proto__</code>, I've used this name through the post to distinguish it clearly to the <code>Functional.prototype</code> property as two different things.</p>
    </div></div></div></div><div id="solution4" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 4</h4><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>In most cases they are essentially the same, but the second version saves memory because there is only one instance of the function instead of a separate function for each object.</p>

<p>A reason to use the first form is to access "private members". For example:</p>

<pre class="lang-js s-code-block"><code class="hljs language-javascript"><span class="hljs-keyword">var</span> A = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
    <span class="hljs-keyword">var</span> private_var = ...;

    <span class="hljs-variable language_">this</span>.<span class="hljs-property">x</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
        <span class="hljs-keyword">return</span> private_var;
    };

    <span class="hljs-variable language_">this</span>.<span class="hljs-property">setX</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">new_x</span>) {
        private_var = new_x;
    };
};
</code></pre>

<p>Because of javascript's scoping rules, private_var is available to the function assigned to this.x, but not outside the object.</p>
    </div></div></div></div><div id="solution5" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 5</h4><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>The first example changes the interface for that object only. The second example changes the interface for all object of that class.</p>
    </div></div></div></div><div id="solution6" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 6</h4><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>The ultimate problem with using <code>this</code> instead of <code>prototype</code> is that when overriding a method, the constructor of the base class will still refer to the overridden method. Consider this:</p>

<pre class="lang-js s-code-block"><code class="hljs language-javascript"><span class="hljs-title class_">BaseClass</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">var</span> text = <span class="hljs-literal">null</span>;

    <span class="hljs-variable language_">this</span>.<span class="hljs-property">setText</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">value</span>) {
        text = value + <span class="hljs-string">" BaseClass!"</span>;
    };

    <span class="hljs-variable language_">this</span>.<span class="hljs-property">getText</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) {
        <span class="hljs-keyword">return</span> text;
    };

    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setText</span>(<span class="hljs-string">"Hello"</span>); <span class="hljs-comment">// This always calls BaseClass.setText()</span>
};

<span class="hljs-title class_">SubClass</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) {
    <span class="hljs-comment">// setText is not overridden yet,</span>
    <span class="hljs-comment">// so the constructor calls the superclass' method</span>
    <span class="hljs-title class_">BaseClass</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>);

    <span class="hljs-comment">// Keeping a reference to the superclass' method</span>
    <span class="hljs-keyword">var</span> super_setText = <span class="hljs-variable language_">this</span>.<span class="hljs-property">setText</span>;
    <span class="hljs-comment">// Overriding</span>
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">setText</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">value</span>) {
        super_setText.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>, <span class="hljs-string">"SubClass says: "</span> + value);
    };
};
<span class="hljs-title class_">SubClass</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">BaseClass</span>();

<span class="hljs-keyword">var</span> subClass = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SubClass</span>();
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(subClass.<span class="hljs-title function_">getText</span>()); <span class="hljs-comment">// Hello BaseClass!</span>

subClass.<span class="hljs-title function_">setText</span>(<span class="hljs-string">"Hello"</span>); <span class="hljs-comment">// setText is already overridden</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(subClass.<span class="hljs-title function_">getText</span>()); <span class="hljs-comment">// SubClass says: Hello BaseClass!</span>
</code></pre>

<p>versus:</p>

<pre class="lang-js s-code-block"><code class="hljs language-javascript"><span class="hljs-title class_">BaseClass</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setText</span>(<span class="hljs-string">"Hello"</span>); <span class="hljs-comment">// This calls the overridden method</span>
};

<span class="hljs-title class_">BaseClass</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">setText</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">value</span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">text</span> = value + <span class="hljs-string">" BaseClass!"</span>;
};

<span class="hljs-title class_">BaseClass</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">getText</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">text</span>;
};

<span class="hljs-title class_">SubClass</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) {
    <span class="hljs-comment">// setText is already overridden, so this works as expected</span>
    <span class="hljs-title class_">BaseClass</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>);
};
<span class="hljs-title class_">SubClass</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">BaseClass</span>();

<span class="hljs-title class_">SubClass</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">setText</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">value</span>) {
    <span class="hljs-title class_">BaseClass</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">setText</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>, <span class="hljs-string">"SubClass says: "</span> + value);
};

<span class="hljs-keyword">var</span> subClass = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SubClass</span>();
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(subClass.<span class="hljs-title function_">getText</span>()); <span class="hljs-comment">// SubClass says: Hello BaseClass!</span>
</code></pre>

<p>If you think this is not a problem, then it depends on whether you can live without private variables, and whether you are experienced enough to know a leak when you see one. Also, having to put the constructor logic after the method definitions is inconvenient.</p>

<pre class="lang-js s-code-block"><code class="hljs language-javascript"><span class="hljs-keyword">var</span> A = <span class="hljs-keyword">function</span> (<span class="hljs-params">param1</span>) {
    <span class="hljs-keyword">var</span> privateVar = <span class="hljs-literal">null</span>; <span class="hljs-comment">// Private variable</span>

    <span class="hljs-comment">// Calling this.setPrivateVar(param1) here would be an error</span>

    <span class="hljs-variable language_">this</span>.<span class="hljs-property">setPrivateVar</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">value</span>) {
        privateVar = value;
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"setPrivateVar value set to: "</span> + value);

        <span class="hljs-comment">// param1 is still here, possible memory leak</span>
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"setPrivateVar has param1: "</span> + param1);
    };

    <span class="hljs-comment">// The constructor logic starts here possibly after</span>
    <span class="hljs-comment">// many lines of code that define methods</span>

    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setPrivateVar</span>(param1); <span class="hljs-comment">// This is valid</span>
};

<span class="hljs-keyword">var</span> a = <span class="hljs-keyword">new</span> <span class="hljs-title function_">A</span>(<span class="hljs-number">0</span>);
<span class="hljs-comment">// setPrivateVar value set to: 0</span>
<span class="hljs-comment">// setPrivateVar has param1: 0</span>

a.<span class="hljs-title function_">setPrivateVar</span>(<span class="hljs-number">1</span>);
<span class="hljs-comment">//setPrivateVar value set to: 1</span>
<span class="hljs-comment">//setPrivateVar has param1: 0</span>
</code></pre>

<p>versus:</p>

<pre class="lang-js s-code-block"><code class="hljs language-javascript"><span class="hljs-keyword">var</span> A = <span class="hljs-keyword">function</span> (<span class="hljs-params">param1</span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setPublicVar</span>(param1); <span class="hljs-comment">// This is valid</span>
};
A.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">setPublicVar</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">value</span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">publicVar</span> = value; <span class="hljs-comment">// No private variable</span>
};

<span class="hljs-keyword">var</span> a = <span class="hljs-keyword">new</span> <span class="hljs-title function_">A</span>(<span class="hljs-number">0</span>);
a.<span class="hljs-title function_">setPublicVar</span>(<span class="hljs-number">1</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a.<span class="hljs-property">publicVar</span>); <span class="hljs-comment">// 1</span>
</code></pre>
    </div></div></div></div><div id="solution7" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 7</h4><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Every object is linked to a prototype object. When trying to access a property that does not exist, JavaScript will look in the object's prototype object for that property and return it if it exists.</p>

<p>The <code>prototype</code> property of a function constructor refers to the prototype object of all instances created with that function when using <code>new</code>.</p>

<hr>

<p>In your first example, you are adding a property <code>x</code> to each instance created with the <code>A</code> function.</p>

<pre class="lang-js s-code-block"><code class="hljs language-javascript"><span class="hljs-keyword">var</span> A = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">x</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
        <span class="hljs-comment">//do something</span>
    };
};

<span class="hljs-keyword">var</span> a = <span class="hljs-keyword">new</span> <span class="hljs-title function_">A</span>();    <span class="hljs-comment">// constructor function gets executed</span>
                    <span class="hljs-comment">// newly created object gets an 'x' property</span>
                    <span class="hljs-comment">// which is a function</span>
a.<span class="hljs-title function_">x</span>();              <span class="hljs-comment">// and can be called like this</span>
</code></pre>

<p>In the second example you are adding a property to the prototype object that all the instances created with <code>A</code> point to.</p>

<pre class="lang-js s-code-block"><code class="hljs language-javascript"><span class="hljs-keyword">var</span> A = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) { };
A.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">x</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
    <span class="hljs-comment">//do something</span>
};

<span class="hljs-keyword">var</span> a = <span class="hljs-keyword">new</span> <span class="hljs-title function_">A</span>();    <span class="hljs-comment">// constructor function gets executed</span>
                    <span class="hljs-comment">// which does nothing in this example</span>

a.<span class="hljs-title function_">x</span>();              <span class="hljs-comment">// you are trying to access the 'x' property of an instance of 'A'</span>
                    <span class="hljs-comment">// which does not exist</span>
                    <span class="hljs-comment">// so JavaScript looks for that property in the prototype object</span>
                    <span class="hljs-comment">// that was defined using the 'prototype' property of the constructor</span>
</code></pre>

<hr>

<p>In conclusion, in the first example <strong>a copy of the function is assigned to each instance</strong>. In the second example <strong>a single copy of the function is shared by all instances</strong>.</p>
    </div></div></div></div><div id="solution8" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 8</h4><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>What's the difference? =&gt; A lot.</p>

<p>I think, the <code>this</code> version is used to enable encapsulation, i.e. data hiding.
It helps to manipulate private variables.</p>

<p>Let us look at the following example:   </p>

<pre class="lang-js s-code-block"><code class="hljs language-javascript"><span class="hljs-keyword">var</span> <span class="hljs-title class_">AdultPerson</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) {

  <span class="hljs-keyword">var</span> age;

  <span class="hljs-variable language_">this</span>.<span class="hljs-property">setAge</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">val</span>) {
    <span class="hljs-comment">// some housekeeping</span>
    age = val &gt;= <span class="hljs-number">18</span> &amp;&amp; val;
  };

  <span class="hljs-variable language_">this</span>.<span class="hljs-property">getAge</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">return</span> age;
  };

  <span class="hljs-variable language_">this</span>.<span class="hljs-property">isValid</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">return</span> !!age;
  };
};
</code></pre>

<p>Now, the <code>prototype</code> structure can be applied as following:</p>

<p>Different adults have different ages, but all of the adults get the same rights.<br>
So, we add it using prototype, rather than this.</p>

<pre class="lang-js s-code-block"><code class="hljs language-javascript"><span class="hljs-title class_">AdultPerson</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">getRights</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) {
  <span class="hljs-comment">// Should be valid</span>
  <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">isValid</span>() &amp;&amp; [<span class="hljs-string">'Booze'</span>, <span class="hljs-string">'Drive'</span>];
};
</code></pre>

<p>Lets look at the implementation now.</p>

<pre class="lang-js s-code-block"><code class="hljs language-javascript"><span class="hljs-keyword">var</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">AdultPerson</span>;
p1.<span class="hljs-title function_">setAge</span>(<span class="hljs-number">12</span>); <span class="hljs-comment">// ( age = false )</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p1.<span class="hljs-title function_">getRights</span>()); <span class="hljs-comment">// false ( Kid alert! )</span>
p1.<span class="hljs-title function_">setAge</span>(<span class="hljs-number">19</span>); <span class="hljs-comment">// ( age = 19 )</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p1.<span class="hljs-title function_">getRights</span>()); <span class="hljs-comment">// ['Booze', 'Drive'] ( Welcome AdultPerson )</span>

<span class="hljs-keyword">var</span> p2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">AdultPerson</span>;
p2.<span class="hljs-title function_">setAge</span>(<span class="hljs-number">45</span>);    
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p2.<span class="hljs-title function_">getRights</span>()); <span class="hljs-comment">// The same getRights() method, *** not a new copy of it ***</span>
</code></pre>

<p>Hope this helps.</p>
    </div></div></div></div><div id="solution9" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 9</h4><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>I know this has been answered to death but I'd like to show an actual example of speed differences.</p>
<p>Function directly on object:</p>
<p></p><div class="snippet" data-lang="js" data-hide="false" data-console="true" data-babel="false">
<div class="snippet-code">
<pre class="snippet-code-js lang-js s-code-block"><code class="hljs language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">ExampleFn</span>(<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">print</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) {
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"Calling print! "</span>);
    }
}

<span class="hljs-keyword">var</span> objects = [];
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">time</span>(<span class="hljs-string">'x'</span>);
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">2000000</span>; i++) {
    objects.<span class="hljs-title function_">push</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ExampleFn</span>());
}
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">timeEnd</span>(<span class="hljs-string">'x'</span>);

<span class="hljs-comment">//x: 1151.960693359375ms</span></code></pre>
<div class="snippet-result"><div class="snippet-ctas"><button type="button" class="s-btn s-btn__primary"><span class="icon-play-white _hover"></span><span> Run code snippet</span></button><input class="copySnippet s-btn s-btn__filled" type="button" value="Copy snippet to answer" style="display: none;"><button type="button" class="s-btn hideResults" style="display: none;">Hide results</button><div class="popout-code"><a class="snippet-expand-link">Expand snippet</a></div></div><div class="snippet-result-code" style="display: none;"><iframe name="sif1" sandbox="allow-forms allow-modals allow-scripts" class="snippet-box-edit snippet-box-result" frameborder="0"></iframe></div></div></div>
</div>
<p></p>
<p>Function on prototype:</p>
<p></p><div class="snippet" data-lang="js" data-hide="false" data-console="true" data-babel="false">
<div class="snippet-code">
<pre class="snippet-code-js lang-js s-code-block"><code class="hljs language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">ExampleFn</span>(<span class="hljs-params"></span>) {
}
<span class="hljs-title class_">ExampleFn</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">print</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"Calling print!"</span>);
}

<span class="hljs-keyword">var</span> objects = [];
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">time</span>(<span class="hljs-string">'y'</span>);
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">2000000</span>; i++) {
    objects.<span class="hljs-title function_">push</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ExampleFn</span>());
}
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">timeEnd</span>(<span class="hljs-string">'y'</span>);

<span class="hljs-comment">//x: 617.866943359375ms</span></code></pre>
<div class="snippet-result"><div class="snippet-ctas"><button type="button" class="s-btn s-btn__primary"><span class="icon-play-white _hover"></span><span> Run code snippet</span></button><input class="copySnippet s-btn s-btn__filled" type="button" value="Copy snippet to answer" style="display: none;"><button type="button" class="s-btn hideResults" style="display: none;">Hide results</button><div class="popout-code"><a class="snippet-expand-link">Expand snippet</a></div></div><div class="snippet-result-code" style="display: none;"><iframe name="sif2" sandbox="allow-forms allow-modals allow-scripts" class="snippet-box-edit snippet-box-result" frameborder="0"></iframe></div></div></div>
</div>
<p></p>
<p>Here we're creating 2,000,000 new objects with a <code>print</code> method in Chrome. We're storing every object in an array. Putting <code>print</code> on the prototype takes about 1/2 as long.</p>
    </div></div></div></div><div id="solution10" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 10</h4><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Prototype is the template of the class; which applies to all future instances of it. Whereas this is the particular instance of the object.</p>
    </div></div></div></div><div id="solution11" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 11</h4><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Let me give you a more comprehensive answer that I learned during a JavaScript training course.</p>

<p>Most answers mentioned the difference already, i.e. when prototyping the function is shared with all (future) instances. Whereas declaring the function in the class will create a copy for each instance.</p>

<p>In general there is no right or wrong, it's more a matter of taste or a design decision depending on your requirements. The prototype however is the technique that is used to develop in an object oriented manner, as I hope you'll see at the end of this answer.</p>

<p>You showed two patterns in your question. I will try to explain two more and try to explain the differences if relevant. Feel free to edit/extend.
In all examples it is about a car object that has a location and can move.</p>

<h1>Object Decorator pattern</h1>

<p>Not sure if this pattern is still relevant nowadays, but it exists. And it is good to know about it.
You simply pass an object and a property to the decorator function. The decorator returns the object with property and method.</p>

<pre class="lang-js s-code-block"><code class="hljs language-javascript"><span class="hljs-keyword">var</span> carlike = <span class="hljs-keyword">function</span>(<span class="hljs-params">obj, loc</span>) {
    obj.<span class="hljs-property">loc</span> = loc;
    obj.<span class="hljs-property">move</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) {
        obj.<span class="hljs-property">loc</span>++;
    };
    <span class="hljs-keyword">return</span> obj;
};

<span class="hljs-keyword">var</span> amy = <span class="hljs-title function_">carlike</span>({}, <span class="hljs-number">1</span>);
amy.<span class="hljs-title function_">move</span>();
<span class="hljs-keyword">var</span> ben = <span class="hljs-title function_">carlike</span>({}, <span class="hljs-number">9</span>);
ben.<span class="hljs-title function_">move</span>();
</code></pre>

<h1>Functional Classes</h1>

<p>A function in JavaScript is a specialised object. In addition to being invoked, a function can store properties like any other object.</p>

<p>In this case <code>Car</code> is a <strong>function</strong> (<strong>also</strong> think <strong>object</strong>) that can be invoked as you are used to do. It has a property <code>methods</code> (which is an object with a <code>move</code> function). When <code>Car</code> is invoked the <code>extend</code> function is called, which does some magic, and extends the <code>Car</code> function (think object) with the methods defined within <code>methods</code>.</p>

<p>This example, though different, comes closest to the first example in the question.</p>

<pre class="lang-js s-code-block"><code class="hljs language-javascript"><span class="hljs-keyword">var</span> <span class="hljs-title class_">Car</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">loc</span>) {
    <span class="hljs-keyword">var</span> obj = {<span class="hljs-attr">loc</span>: loc};
    <span class="hljs-title function_">extend</span>(obj, <span class="hljs-title class_">Car</span>.<span class="hljs-property">methods</span>);
    <span class="hljs-keyword">return</span> obj;
};

<span class="hljs-title class_">Car</span>.<span class="hljs-property">methods</span> = {
    move : <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) {
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">loc</span>++;
    }
};

<span class="hljs-keyword">var</span> amy = <span class="hljs-title class_">Car</span>(<span class="hljs-number">1</span>);
amy.<span class="hljs-title function_">move</span>();
<span class="hljs-keyword">var</span> ben = <span class="hljs-title class_">Car</span>(<span class="hljs-number">9</span>);
ben.<span class="hljs-title function_">move</span>();
</code></pre>

<h1>Prototypal Classes</h1>

<p>The first two patterns allow a discussion of using techniques to define  shared methods or using methods that are defined inline in the body of the constructor. In both cases every instance has its own <code>move</code> function.</p>

<p>The prototypal pattern does not lend itself well to the same examination, because function sharing via a prototype delegation is the very goal for the prototypal pattern. As others pointed out, it is expected to have a better memory footprint.</p>

<p>However there is one point interesting to know:
Every <code>prototype</code> object has has a convenience property <code>constructor</code>, which points back to the function (think object) it came attached to.</p>

<p>Concerning the last three lines:</p>

<p>In this example <code>Car</code> links to the <code>prototype</code> object, which links via <code>constructor</code> to <code>Car</code> itself, i.e. <code>Car.prototype.constructor</code> is <code>Car</code> itself. This allows you to figure out which constructor function built a certain object.</p>

<p><code>amy.constructor</code>'s lookup fails and thus is delegated to <code>Car.prototype</code>, which does have the constructor property. And so <code>amy.constructor</code> is <code>Car</code>.</p>

<p>Furthermore, <code>amy</code> is an <code>instanceof</code> <code>Car</code>. The <code>instanceof</code> operator works by seeing if the right operand's prototype object (<code>Car</code>) can be found anywhere in the left operand's prototype (<code>amy</code>) chain.</p>

<pre class="lang-js s-code-block"><code class="hljs language-javascript"><span class="hljs-keyword">var</span> <span class="hljs-title class_">Car</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">loc</span>) {
    <span class="hljs-keyword">var</span> obj = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(<span class="hljs-title class_">Car</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>);
    obj.<span class="hljs-property">loc</span> = loc;
    <span class="hljs-keyword">return</span> obj;
};

<span class="hljs-title class_">Car</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">move</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) {
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">loc</span>++;
};

<span class="hljs-keyword">var</span> amy = <span class="hljs-title class_">Car</span>(<span class="hljs-number">1</span>);
amy.<span class="hljs-title function_">move</span>();
<span class="hljs-keyword">var</span> ben = <span class="hljs-title class_">Car</span>(<span class="hljs-number">9</span>);
ben.<span class="hljs-title function_">move</span>();

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Car</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">constructor</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(amy.<span class="hljs-property">constructor</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(amy <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Car</span>);
</code></pre>

<p>Some developers can be confused in the beginning. See below example:</p>

<pre class="lang-js s-code-block"><code class="hljs language-javascript"><span class="hljs-keyword">var</span> <span class="hljs-title class_">Dog</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">return</span> {<span class="hljs-attr">legs</span>: <span class="hljs-number">4</span>, <span class="hljs-attr">bark</span>: alert};
};

<span class="hljs-keyword">var</span> fido = <span class="hljs-title class_">Dog</span>();
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(fido <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Dog</span>);
</code></pre>

<p>The <code>instanceof</code> operator returns <code>false</code>, because <code>Dog</code>'s prototype cannot be found anywhere in <code>fido</code>'s prototype chain. <code>fido</code> is a simple object that is created with an object literal, i.e. it just delegates to <code>Object.prototype</code>.</p>

<h1>Pseudoclassical patterns</h1>

<p>This is really just another form of the prototypal pattern in simplified form and more familiar to do those who program in Java for example, since it uses the <code>new</code> constructor.</p>

<p>It does the same as in the prototypal pattern really, it is just syntactic sugar overtop of the prototypal pattern.</p>

<p>However, the primary difference is that there are optimizations implemented in JavaScript engines that only apply when using the pseudoclassical pattern. Think of the pseudoclassical pattern a probably faster version of the prototypal pattern; the object relations in both examples are the same.</p>

<pre class="lang-js s-code-block"><code class="hljs language-javascript"><span class="hljs-keyword">var</span> <span class="hljs-title class_">Car</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">loc</span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">loc</span> = loc;
};

<span class="hljs-title class_">Car</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">move</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) {
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">loc</span>++;
};

<span class="hljs-keyword">var</span> amy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Car</span>(<span class="hljs-number">1</span>);
amy.<span class="hljs-title function_">move</span>();
<span class="hljs-keyword">var</span> ben = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Car</span>(<span class="hljs-number">9</span>);
ben.<span class="hljs-title function_">move</span>();
</code></pre>

<hr>

<p>Finally, it should not be too difficult to realize how object oriented programming can be done. There are two sections. </p>

<p>One section that defines common properties/methods in the prototype (chain).</p>

<p>And another section where you put the definitions that distinguish the objects from each other (<code>loc</code> variable in the examples).</p>

<p>This is what allows us to apply concepts like superclass or subclass in JavaScript.</p>

<p>Feel free to add or edit. Once more complete I could make this a community wiki maybe.</p>
    </div></div></div></div><div id="solution12" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 12</h4><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>I believe that @Matthew Crumley is right.  They are <em>functionally</em>, if not structurally, equivalent.  If you use Firebug to look at the objects that are created using <code>new</code>, you can see that they are the same.  However, my preference would be the following.  I'm guessing that it just seems more like what I'm used to in C#/Java.  That is, define the class, define the fields, constructor, and methods.</p>

<pre class="lang-js s-code-block"><code class="hljs language-javascript"><span class="hljs-keyword">var</span> A = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) {};
A.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = {
    <span class="hljs-attr">_instance_var</span>: <span class="hljs-number">0</span>,

    <span class="hljs-attr">initialize</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">v</span>) { <span class="hljs-variable language_">this</span>.<span class="hljs-property">_instance_var</span> = v; },

    <span class="hljs-attr">x</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) {  <span class="hljs-title function_">alert</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">_instance_var</span>); }
};
</code></pre>

<p><strong>EDIT</strong> Didn't mean to imply that the scope of the variable was private, I was just trying to illustrate how I define my classes in javascript.  Variable name has been changed to reflect this.</p>
    </div></div></div></div><div id="solution13" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 13</h4><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>As discussed in other answers, it's really a performance consideration because the function in the prototype is shared with all of the instantiations - rather than the function being created for each instantiation.</p>

<p>I put together a jsperf to show this. There is a dramatic difference in the time it takes to instantiate the class, although it is really only relevant if you are making many instances.</p>

<p><a href="http://jsperf.com/functions-in-constructor-vs-prototype" rel="noreferrer">http://jsperf.com/functions-in-constructor-vs-prototype</a></p>
    </div></div></div></div><div id="solution14" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 14</h4><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Think about statically typed language, things on <code>prototype</code> are static and things on <code>this</code> are instance related.</p>
    </div></div></div></div><div id="solution15" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 15</h4><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>When you use prototype, the function will only be loaded only once into memory (independently on the amount of objects you create) and you can override the function whenever you want.</p>
    </div></div></div></div></div></div><div class="widget"><a href="/questions/srand()-why-call-it-only-once-1657387794760">srand()  why call it only once?</a><a href="/questions/what-is-the-difference-between-public-protected-package-private-and-private-in-java-1657387376262">What is the difference between public, protected, package-private and private in Java?</a><a href="/questions/servlet-returns-%22http-status-404-the-requested-resource-(servlet)-is-not-available%22-1657384850661">Servlet returns &quot;HTTP Status 404 The requested resource (/servlet) is not available&quot;</a><a href="/questions/efficiently-convert-rows-to-columns-in-sql-server-1657387919213">Efficiently convert rows to columns in sql server</a><a href="/questions/is-floating-point-math-broken-1657384238910">Is floating point math broken?</a><a href="/questions/why-does-a-regexp-with-global-flag-give-wrong-results-1657387788550">Why does a RegExp with global flag give wrong results?</a><a href="/questions/how-do-i-use-reflection-to-call-a-generic-method-1657387256751">How do I use reflection to call a generic method?</a><a href="/questions/removing-trailing-newline-character-from-fgets()-input-1657387308069">Removing trailing newline character from fgets() input</a><a href="/questions/returning-data-from-async-call-in-swift-function-1657387469218">Returning data from async call in Swift function</a><a href="/questions/what-is-the-difference-between-a-deep-copy-and-a-shallow-copy-1657388445063">What is the difference between a deep copy and a shallow copy?</a><a href="/questions/why-does-my-arraylist-contain-n-copies-of-the-last-item-added-to-the-list-1657387712003">Why does my ArrayList contain N copies of the last item added to the list?</a><a href="/questions/download-a-file-by-jquery.ajax-1657388220611">Download a file by jQuery.Ajax</a><a href="/questions/prefer-composition-over-inheritance-1657387399409">Prefer composition over inheritance?</a><a href="/questions/importing-files-from-different-folder-1657388203798">Importing files from different folder</a><a href="/questions/undefined-behavior-and-sequence-points-1657384639493">Undefined behavior and sequence points</a><a href="/questions/in-css-flexbox-why-are-there-no-%22justify-items%22-and-%22justify-self%22-properties-1657384782711">In CSS Flexbox, why are there no &quot;justify-items&quot; and &quot;justify-self&quot; properties?</a><a href="/questions/retrieving-the-last-record-in-each-group-mysql-1657384887369">Retrieving the last record in each group - MySQL</a><a href="/questions/deserialize-json-into-c-dynamic-object-1657388568720">Deserialize JSON into C# dynamic object?</a><a href="/questions/mergeflatten-an-array-of-arrays-1657387827427">Merge/flatten an array of arrays</a><a href="/questions/how-to-generate-all-permutations-of-a-list-1657388537371">How to generate all permutations of a list</a></div></div><span class="cursor-pointer text-lg p-2" style="position:fixed;bottom:20px;left:20px;background:#000;z-index:2000;color:white">Go go top</span></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"data":{"answer":["\n\u0026lt;p\u0026gt;The examples have very different outcomes.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Before looking at the differences, the following should be noted:\u0026lt;/p\u0026gt;\n\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;A constructor\u0026apos;s \u0026lt;em\u0026gt;prototype\u0026lt;/em\u0026gt; provides a way to share methods and values among instances via the instance\u0026apos;s private \u0026lt;code\u0026gt;[[Prototype]]\u0026lt;/code\u0026gt; property.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;A function\u0026apos;s \u0026lt;em\u0026gt;this\u0026lt;/em\u0026gt; is set by how the function is called or by the use of \u0026lt;em\u0026gt;bind\u0026lt;/em\u0026gt; (not discussed here). Where a function is called on an object (e.g. \u0026lt;code\u0026gt;myObj.method()\u0026lt;/code\u0026gt;) then \u0026lt;em\u0026gt;this\u0026lt;/em\u0026gt; within the method references the object. Where \u0026lt;em\u0026gt;this\u0026lt;/em\u0026gt; is not set by the call or by the use of \u0026lt;em\u0026gt;bind\u0026lt;/em\u0026gt;, it defaults to the global object (window in a browser) or in strict mode, remains undefined.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;JavaScript is an object-oriented language, i.e. most values are objects, including functions. (Strings, numbers, and booleans are \u0026lt;em\u0026gt;not\u0026lt;/em\u0026gt; objects.)\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\n\u0026lt;p\u0026gt;So here are the snippets in question:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; A = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt; (\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;) {\n    \u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;this\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;x\u0026lt;/span\u0026gt; = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt; (\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;) {\n        \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//do something\u0026lt;/span\u0026gt;\n    };\n};\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;In this case, variable \u0026lt;code\u0026gt;A\u0026lt;/code\u0026gt; is assigned a value that is a reference to a function.  When that function is called using \u0026lt;code\u0026gt;A()\u0026lt;/code\u0026gt;, the function\u0026apos;s \u0026lt;em\u0026gt;this\u0026lt;/em\u0026gt; isn\u0026apos;t set by the call so it defaults to the global object and the expression \u0026lt;code\u0026gt;this.x\u0026lt;/code\u0026gt; is effective \u0026lt;code\u0026gt;window.x\u0026lt;/code\u0026gt;. The result is that a reference to the function expression on the right-hand side is assigned to \u0026lt;code\u0026gt;window.x\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;In the case of:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; A = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt; (\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;) { };\nA.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;prototype\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;x\u0026lt;/span\u0026gt; = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt; (\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;) {\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//do something\u0026lt;/span\u0026gt;\n};\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;something very different occurs.  In the first line, variable \u0026lt;code\u0026gt;A\u0026lt;/code\u0026gt; is assigned a reference to a function.  In JavaScript, all functions objects have a \u0026lt;em\u0026gt;prototype\u0026lt;/em\u0026gt; property by default so there is no separate code to create an \u0026lt;em\u0026gt;A.prototype\u0026lt;/em\u0026gt; object.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;In the second line, \u0026lt;em\u0026gt;A.prototype.x\u0026lt;/em\u0026gt; is assigned a reference to a function. This will create an \u0026lt;em\u0026gt;x\u0026lt;/em\u0026gt; property if it doesn\u0026apos;t exist, or assign a new value if it does. So the difference with the first example in which object\u0026apos;s \u0026lt;em\u0026gt;x\u0026lt;/em\u0026gt; property is involved in the expression.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Another example is below.  It\u0026apos;s similar to the first one (and maybe what you meant to ask about):\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; A = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt; (\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;) {\n    \u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;this\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;x\u0026lt;/span\u0026gt; = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt; (\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;) {\n        \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//do something\u0026lt;/span\u0026gt;\n    };\n};\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;In this example, the \u0026lt;code\u0026gt;new\u0026lt;/code\u0026gt; operator has been added before the function expression so that the function is called as a constructor. When called with \u0026lt;code\u0026gt;new\u0026lt;/code\u0026gt;, the function\u0026apos;s \u0026lt;em\u0026gt;this\u0026lt;/em\u0026gt; is set to reference a new Object whose private \u0026lt;code\u0026gt;[[Prototype]]\u0026lt;/code\u0026gt; property is set to reference the constructor\u0026apos;s public \u0026lt;em\u0026gt;prototype\u0026lt;/em\u0026gt;. So in the assignment statement, the \u0026lt;code\u0026gt;x\u0026lt;/code\u0026gt; property will be created on this new object. When called as a constructor, a function returns its \u0026lt;em\u0026gt;this\u0026lt;/em\u0026gt; object by default, so there is no need for a separate \u0026lt;code\u0026gt;return this;\u0026lt;/code\u0026gt; statement.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;To check that \u0026lt;em\u0026gt;A\u0026lt;/em\u0026gt; has an \u0026lt;em\u0026gt;x\u0026lt;/em\u0026gt; property:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;console\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;log\u0026lt;/span\u0026gt;(A.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;x\u0026lt;/span\u0026gt;) \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// function () {\u0026lt;/span\u0026gt;\n                 \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//   //do something\u0026lt;/span\u0026gt;\n                 \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// };\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;This is an uncommon use of \u0026lt;em\u0026gt;new\u0026lt;/em\u0026gt; since the only way to reference the constructor is via \u0026lt;em\u0026gt;A.constructor\u0026lt;/em\u0026gt;. It would be much more common to do:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; A = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt; (\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;) {\n    \u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;this\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;x\u0026lt;/span\u0026gt; = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt; (\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;) {\n        \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//do something\u0026lt;/span\u0026gt;\n    };\n};\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; a = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;A\u0026lt;/span\u0026gt;();\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Another way of achieving a similar result is to use an immediately invoked function expression:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; A = (\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt; (\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;) {\n    \u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;this\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;x\u0026lt;/span\u0026gt; = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt; (\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;) {\n        \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//do something\u0026lt;/span\u0026gt;\n    };\n}());\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;In this case, \u0026lt;code\u0026gt;A\u0026lt;/code\u0026gt; assigned the return value of calling the function on the right-hand side. Here again, since \u0026lt;em\u0026gt;this\u0026lt;/em\u0026gt; is not set in the call, it will reference the global object and \u0026lt;code\u0026gt;this.x\u0026lt;/code\u0026gt; is effective \u0026lt;code\u0026gt;window.x\u0026lt;/code\u0026gt;. Since the function doesn\u0026apos;t return anything, \u0026lt;code\u0026gt;A\u0026lt;/code\u0026gt; will have a value of \u0026lt;code\u0026gt;undefined\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;These differences between the two approaches also manifest if you\u0026apos;re serializing and de-serializing your Javascript objects to/from JSON. Methods defined on an object\u0026apos;s prototype are not serialized when you serialize the object, which can be convenient when for example you want to serialize just the data portions of an object, but not it\u0026apos;s methods:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; A = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt; (\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;) { \n    \u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;this\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;objectsOwnProperties\u0026lt;/span\u0026gt; = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;are serialized\u0026quot;\u0026lt;/span\u0026gt;;\n};\nA.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;prototype\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;prototypeProperties\u0026lt;/span\u0026gt; = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;are NOT serialized\u0026quot;\u0026lt;/span\u0026gt;;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; instance = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;A\u0026lt;/span\u0026gt;();\n\u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;console\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;log\u0026lt;/span\u0026gt;(instance.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;prototypeProperties\u0026lt;/span\u0026gt;); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// \u0026quot;are NOT serialized\u0026quot;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;console\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;log\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;JSON\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;stringify\u0026lt;/span\u0026gt;(instance)); \n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// {\u0026quot;objectsOwnProperties\u0026quot;:\u0026quot;are serialized\u0026quot;} \u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Related questions\u0026lt;/strong\u0026gt;:\u0026lt;/p\u0026gt;\n\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;a href=\u0026quot;https://stackoverflow.com/questions/186244/what-does-it-mean-that-javascript-is-a-prototype-based-language\u0026quot;\u0026gt;\u0026lt;strong\u0026gt;What does it mean that JavaScript is a prototypal language?\u0026lt;/strong\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;a href=\u0026quot;https://stackoverflow.com/questions/235360/what-is-the-scope-of-a-function-in-javascriptecmascript\u0026quot;\u0026gt;\u0026lt;strong\u0026gt;What is the scope of a function in JavaScript?\u0026lt;/strong\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;strong\u0026gt;\u0026lt;a href=\u0026quot;https://stackoverflow.com/questions/3127429/javascript-this-keyword\u0026quot;\u0026gt;How does the \u0026quot;this\u0026quot; keyword work?\u0026lt;/a\u0026gt;\u0026lt;/strong\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Sidenote:\u0026lt;/strong\u0026gt; There may not be any significant memory savings between the two approaches, however using the prototype to share methods and properties will likely use less memory than each instance having its own copy.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;JavaScript isn\u0026apos;t a low-level language.  It may not be very valuable to think of prototyping or other inheritance patterns as a way to explicitly change the way memory is allocated.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;As others have said the first version, using \u0026quot;this\u0026quot; results in every instance of the class A having its own independent copy of function method \u0026quot;x\u0026quot;.  Whereas using \u0026quot;prototype\u0026quot; will mean that each instance of class A will use the same copy of method \u0026quot;x\u0026quot;.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Here is some code to show this subtle difference:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// x is a method assigned to the object using \u0026quot;this\u0026quot;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; A = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt; (\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;) {\n    \u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;this\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;x\u0026lt;/span\u0026gt; = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt; (\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;) { \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;alert\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;A\u0026apos;\u0026lt;/span\u0026gt;); };\n};\nA.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;prototype\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;updateX\u0026lt;/span\u0026gt; = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt; value \u0026lt;/span\u0026gt;) {\n    \u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;this\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;x\u0026lt;/span\u0026gt; = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;) { \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;alert\u0026lt;/span\u0026gt;( value ); }\n};\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; a1 = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;A\u0026lt;/span\u0026gt;();\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; a2 = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;A\u0026lt;/span\u0026gt;();\na1.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;x\u0026lt;/span\u0026gt;();  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Displays \u0026apos;A\u0026apos;\u0026lt;/span\u0026gt;\na2.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;x\u0026lt;/span\u0026gt;();  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Also displays \u0026apos;A\u0026apos;\u0026lt;/span\u0026gt;\na1.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;updateX\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;Z\u0026apos;\u0026lt;/span\u0026gt;);\na1.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;x\u0026lt;/span\u0026gt;();  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Displays \u0026apos;Z\u0026apos;\u0026lt;/span\u0026gt;\na2.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;x\u0026lt;/span\u0026gt;();  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Still displays \u0026apos;A\u0026apos;\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Here x is a method assigned to the object using \u0026quot;prototype\u0026quot;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; B = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt; (\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;) { };\nB.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;prototype\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;x\u0026lt;/span\u0026gt; = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt; (\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;) { \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;alert\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;B\u0026apos;\u0026lt;/span\u0026gt;); };\n\nB.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;prototype\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;updateX\u0026lt;/span\u0026gt; = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt; value \u0026lt;/span\u0026gt;) {\n    B.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;prototype\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;x\u0026lt;/span\u0026gt; = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;) { \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;alert\u0026lt;/span\u0026gt;( value ); }\n}\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; b1 = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;B\u0026lt;/span\u0026gt;();\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; b2 = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;B\u0026lt;/span\u0026gt;();\nb1.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;x\u0026lt;/span\u0026gt;();  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Displays \u0026apos;B\u0026apos;\u0026lt;/span\u0026gt;\nb2.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;x\u0026lt;/span\u0026gt;();  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Also displays \u0026apos;B\u0026apos;\u0026lt;/span\u0026gt;\nb1.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;updateX\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;Y\u0026apos;\u0026lt;/span\u0026gt;);\nb1.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;x\u0026lt;/span\u0026gt;();  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Displays \u0026apos;Y\u0026apos;\u0026lt;/span\u0026gt;\nb2.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;x\u0026lt;/span\u0026gt;();  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Also displays \u0026apos;Y\u0026apos; because by using prototype we have changed it for all instances\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;As others have mentioned, there are various reasons to choose one method or the other.  My sample is just meant to clearly demonstrate the difference.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Take these 2 examples:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; A = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;) { \u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;this\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;hey\u0026lt;/span\u0026gt; = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;) { \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;alert\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;from A\u0026apos;\u0026lt;/span\u0026gt;) } };\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;vs.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; A = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;) {}\nA.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;prototype\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;hey\u0026lt;/span\u0026gt; = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;) { \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;alert\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;from prototype\u0026apos;\u0026lt;/span\u0026gt;) };\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Most people here (especially the top-rated answers) tried to explain how they are different without explaining WHY. I think this is wrong and if you understand the fundamentals first, the difference will become obvious. Let\u0026apos;s try to explain the fundamentals first...\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;a) A function is an object in JavaScript. EVERY object in JavaScript gets an internal property (meaning, you can\u0026apos;t access it like other properties, except maybe in browsers like Chrome), often referred to as \u0026lt;code\u0026gt;__proto__\u0026lt;/code\u0026gt; (you can actually type \u0026lt;code\u0026gt;anyObject.__proto__\u0026lt;/code\u0026gt; in Chrome to see what it references. This is just that, a property, nothing more. A property in JavaScript = a variable inside an object, nothing more. What do variables do? They point to things.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;So what does this \u0026lt;code\u0026gt;__proto__\u0026lt;/code\u0026gt; property points to? Well, usually another object (we\u0026apos;ll explain why later). The only way to force JavaScript for the \u0026lt;code\u0026gt;__proto__\u0026lt;/code\u0026gt; property to NOT point to another object is to use \u0026lt;code\u0026gt;var newObj = Object.create(null)\u0026lt;/code\u0026gt;. Even if you do this, the \u0026lt;code\u0026gt;__proto__\u0026lt;/code\u0026gt; property STILL exists as a property of the object,  just it doesn\u0026apos;t point to another object, it points to \u0026lt;code\u0026gt;null\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Here\u0026apos;s where most people get confused:\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;When you create a new function in JavaScript (which is an object as well, remember?), the moment it is defined, JavaScript automatically creates a new property on that function called \u0026lt;code\u0026gt;prototype\u0026lt;/code\u0026gt;. Try it:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; A = [];\nA.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;prototype\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// undefined\u0026lt;/span\u0026gt;\nA = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;) {}\nA.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;prototype\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// {} // got created when function() {} was defined\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;code\u0026gt;A.prototype\u0026lt;/code\u0026gt; is TOTALLY DIFFERENT from the \u0026lt;code\u0026gt;__proto__\u0026lt;/code\u0026gt; property. In our example, \u0026apos;A\u0026apos; now has TWO properties called \u0026apos;prototype\u0026apos; and \u0026lt;code\u0026gt;__proto__\u0026lt;/code\u0026gt; . This is a big confusion for people. \u0026lt;code\u0026gt;prototype\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;__proto__\u0026lt;/code\u0026gt; properties are in no way related, they\u0026apos;re separate things pointing to separate values.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;You may wonder: Why does JavaScript has \u0026lt;code\u0026gt;__proto__\u0026lt;/code\u0026gt; property created on every single object? Well, one word: \u0026lt;strong\u0026gt;delegation\u0026lt;/strong\u0026gt;. When you call a property on an object and the object doesn\u0026apos;t have it, then JavaScript looks for the object referenced by \u0026lt;code\u0026gt;__proto__\u0026lt;/code\u0026gt; to see if it maybe has it. If it doesn\u0026apos;t have it, then it looks at that object\u0026apos;s \u0026lt;code\u0026gt;__proto__\u0026lt;/code\u0026gt; property and so on...until the chain ends. Thus the name \u0026lt;strong\u0026gt;prototype chain\u0026lt;/strong\u0026gt;. Of course, if \u0026lt;code\u0026gt;__proto__\u0026lt;/code\u0026gt; doesn\u0026apos;t point to an object and instead points to \u0026lt;code\u0026gt;null\u0026lt;/code\u0026gt;, well tough luck, JavaScript realizes that and will return you \u0026lt;code\u0026gt;undefined\u0026lt;/code\u0026gt; for the property.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;You may also wonder, why does JavaScript creates a property called \u0026lt;code\u0026gt;prototype\u0026lt;/code\u0026gt; for a function when you define the function? Because it tries to fool you, yes \u0026lt;strong\u0026gt;fool you\u0026lt;/strong\u0026gt; that it works like class-based languages. \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Let\u0026apos;s go on with our example and create an \u0026quot;object\u0026quot; out of \u0026lt;code\u0026gt;A\u0026lt;/code\u0026gt;:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; a1 = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;A\u0026lt;/span\u0026gt;();\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;There\u0026apos;s something happening in the background when this thing happened. \u0026lt;code\u0026gt;a1\u0026lt;/code\u0026gt; is an ordinary variable which was assigned a new, empty object.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;The fact that you used the operator \u0026lt;code\u0026gt;new\u0026lt;/code\u0026gt; before a function invocation \u0026lt;code\u0026gt;A()\u0026lt;/code\u0026gt; did something ADDITIONAL in the background. The \u0026lt;code\u0026gt;new\u0026lt;/code\u0026gt; keyword created a new object which now references \u0026lt;code\u0026gt;a1\u0026lt;/code\u0026gt; and that object is empty. Here\u0026apos;s what happening additionally:\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;We said that on each function definition there\u0026apos;s a new property created called \u0026lt;code\u0026gt;prototype\u0026lt;/code\u0026gt; (which you can access it, unlike with the \u0026lt;code\u0026gt;__proto__\u0026lt;/code\u0026gt; property) created? Well, that property is being used now.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;So we\u0026apos;re now at the point where we have a freshly baked empty \u0026lt;code\u0026gt;a1\u0026lt;/code\u0026gt; object. We said that all objects in JavaScript have an internal \u0026lt;code\u0026gt;__proto__\u0026lt;/code\u0026gt; property which points to something (\u0026lt;code\u0026gt;a1\u0026lt;/code\u0026gt; also has it), whether it\u0026apos;s null or another object. What the \u0026lt;code\u0026gt;new\u0026lt;/code\u0026gt; operator does is that it sets that \u0026lt;code\u0026gt;__proto__\u0026lt;/code\u0026gt; property to point to the function\u0026apos;s \u0026lt;code\u0026gt;prototype\u0026lt;/code\u0026gt; property. Read that again. It\u0026apos;s basically this:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;a1.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;__proto__\u0026lt;/span\u0026gt; = A.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;prototype\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;We said that \u0026lt;code\u0026gt;A.prototype\u0026lt;/code\u0026gt; is nothing more than an empty object (unless we change it to something else before defining \u0026lt;code\u0026gt;a1\u0026lt;/code\u0026gt;). So now basically \u0026lt;code\u0026gt;a1.__proto__\u0026lt;/code\u0026gt; points to the same thing \u0026lt;code\u0026gt;A.prototype\u0026lt;/code\u0026gt; points to, which is that empty object. They both point to the same object which was created when this line happened:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;A = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;) {} \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// JS: cool. let\u0026apos;s also create A.prototype pointing to empty {}\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Now, there\u0026apos;s another thing happening when \u0026lt;code\u0026gt;var a1 = new A()\u0026lt;/code\u0026gt; statement is processed. Basically \u0026lt;code\u0026gt;A()\u0026lt;/code\u0026gt; is executed and if A is something like this:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; A = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;) { \u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;this\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;hey\u0026lt;/span\u0026gt; = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;) { \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;alert\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;from A\u0026apos;\u0026lt;/span\u0026gt;) } };\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;All that stuff inside \u0026lt;code\u0026gt;function() { }\u0026lt;/code\u0026gt; is going to execute. When you reach the \u0026lt;code\u0026gt;this.hey..\u0026lt;/code\u0026gt; line, \u0026lt;code\u0026gt;this\u0026lt;/code\u0026gt; is changed to \u0026lt;code\u0026gt;a1\u0026lt;/code\u0026gt; and you get this:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;a1.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;hey\u0026lt;/span\u0026gt; = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;) { \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;alert\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;from A\u0026apos;\u0026lt;/span\u0026gt;) }\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;I won\u0026apos;t cover why \u0026lt;code\u0026gt;this\u0026lt;/code\u0026gt; changes to \u0026lt;code\u0026gt;a1\u0026lt;/code\u0026gt; but \u0026lt;a href=\u0026quot;https://stackoverflow.com/a/80478/1085998\u0026quot;\u0026gt;this is a great answer\u0026lt;/a\u0026gt; to learn more.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;So to summarize, when you do \u0026lt;code\u0026gt;var a1 = new A()\u0026lt;/code\u0026gt; there are 3 things happening in the background:\u0026lt;/p\u0026gt;\n\n\u0026lt;ol\u0026gt;\n\u0026lt;li\u0026gt;A totally new empty object is created and assigned to \u0026lt;code\u0026gt;a1\u0026lt;/code\u0026gt;. \u0026lt;code\u0026gt;a1 = {}\u0026lt;/code\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;\u0026lt;code\u0026gt;a1.__proto__\u0026lt;/code\u0026gt; property is assigned to point at the same thing as \u0026lt;code\u0026gt;A.prototype\u0026lt;/code\u0026gt; points to (another empty object {} )\u0026lt;/p\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;The function \u0026lt;code\u0026gt;A()\u0026lt;/code\u0026gt; is being executed with \u0026lt;code\u0026gt;this\u0026lt;/code\u0026gt; set to the new, empty object created in step 1 (read the answer I referenced above as to why \u0026lt;code\u0026gt;this\u0026lt;/code\u0026gt; changes to \u0026lt;code\u0026gt;a1\u0026lt;/code\u0026gt;)\u0026lt;/p\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;/ol\u0026gt;\n\n\u0026lt;p\u0026gt;Now, let\u0026apos;s try to create another object:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; a2 = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;A\u0026lt;/span\u0026gt;();\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Steps 1,2,3 will repeat. Do you notice something? The key word is \u0026lt;strong\u0026gt;repeat.\u0026lt;/strong\u0026gt; Step 1: \u0026lt;code\u0026gt;a2\u0026lt;/code\u0026gt; will be a new empty object, step 2: its \u0026lt;code\u0026gt;__proto__\u0026lt;/code\u0026gt; property will point to the same thing \u0026lt;code\u0026gt;A.prototype\u0026lt;/code\u0026gt; points to and most importantly, step 3: function \u0026lt;code\u0026gt;A()\u0026lt;/code\u0026gt; is AGAIN executed, which means that \u0026lt;code\u0026gt;a2\u0026lt;/code\u0026gt; will get \u0026lt;code\u0026gt;hey\u0026lt;/code\u0026gt; property containing a function. \u0026lt;code\u0026gt;a1\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;a2\u0026lt;/code\u0026gt; have two SEPARATE properties named \u0026lt;code\u0026gt;hey\u0026lt;/code\u0026gt; which point to 2 SEPARATE functions! We now have duplicate functions in same two different objects doing the same thing, oops...You can imagine the memory implications of this if we have 1000 objects created with \u0026lt;code\u0026gt;new A\u0026lt;/code\u0026gt;, after all functions declarations take more memory than something like the number 2. So how do we prevent this?\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Remember why the \u0026lt;code\u0026gt;__proto__\u0026lt;/code\u0026gt; property exists on every object? So that if you retrieve the \u0026lt;code\u0026gt;yoMan\u0026lt;/code\u0026gt; property on \u0026lt;code\u0026gt;a1\u0026lt;/code\u0026gt; (which doesn\u0026apos;t exist), its \u0026lt;code\u0026gt;__proto__\u0026lt;/code\u0026gt; property will be consulted, which if it\u0026apos;s an object (and is most cases it is), it will check if it contains \u0026lt;code\u0026gt;yoMan\u0026lt;/code\u0026gt;, and if it doesn\u0026apos;t, it will consult that object\u0026apos;s \u0026lt;code\u0026gt;__proto__\u0026lt;/code\u0026gt; etc. If it does, it will take that property value and display it to you.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;So someone decided to use this fact + the fact that when you create \u0026lt;code\u0026gt;a1\u0026lt;/code\u0026gt;, its \u0026lt;code\u0026gt;__proto__\u0026lt;/code\u0026gt; property points to the same (empty) object \u0026lt;code\u0026gt;A.prototype\u0026lt;/code\u0026gt; points to and do this:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; A = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;) {}\nA.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;prototype\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;hey\u0026lt;/span\u0026gt; = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;) { \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;alert\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;from prototype\u0026apos;\u0026lt;/span\u0026gt;) };\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Cool! Now, when you create \u0026lt;code\u0026gt;a1\u0026lt;/code\u0026gt;, it again goes through all of the 3 steps above, and in step 3, it doesn\u0026apos;t do anything, since \u0026lt;code\u0026gt;function A()\u0026lt;/code\u0026gt; has nothing to execute. And if we do:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;a1.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;hey\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;It will see that \u0026lt;code\u0026gt;a1\u0026lt;/code\u0026gt; does not contain \u0026lt;code\u0026gt;hey\u0026lt;/code\u0026gt; and it will check its \u0026lt;code\u0026gt;__proto__\u0026lt;/code\u0026gt; property object to see if it has it, which is the case.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;With this approach we eliminate the part from step 3 where functions are duplicated on each new object creation. Instead of \u0026lt;code\u0026gt;a1\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;a2\u0026lt;/code\u0026gt; having a separate \u0026lt;code\u0026gt;hey\u0026lt;/code\u0026gt; property, now NONE of them has it. Which, I guess, you figured out yourself by now. That\u0026apos;s the nice thing...if you understand \u0026lt;code\u0026gt;__proto__\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;Function.prototype\u0026lt;/code\u0026gt;, questions like these will be pretty obvious.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;NOTE: Some people tend to not call the internal Prototype property as \u0026lt;code\u0026gt;__proto__\u0026lt;/code\u0026gt;, I\u0026apos;ve used this name through the post to distinguish it clearly to the \u0026lt;code\u0026gt;Functional.prototype\u0026lt;/code\u0026gt; property as two different things.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;In most cases they are essentially the same, but the second version saves memory because there is only one instance of the function instead of a separate function for each object.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;A reason to use the first form is to access \u0026quot;private members\u0026quot;. For example:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; A = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt; (\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;) {\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; private_var = ...;\n\n    \u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;this\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;x\u0026lt;/span\u0026gt; = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt; (\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;) {\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; private_var;\n    };\n\n    \u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;this\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;setX\u0026lt;/span\u0026gt; = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt; (\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;new_x\u0026lt;/span\u0026gt;) {\n        private_var = new_x;\n    };\n};\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Because of javascript\u0026apos;s scoping rules, private_var is available to the function assigned to this.x, but not outside the object.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;The first example changes the interface for that object only. The second example changes the interface for all object of that class.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;The ultimate problem with using \u0026lt;code\u0026gt;this\u0026lt;/code\u0026gt; instead of \u0026lt;code\u0026gt;prototype\u0026lt;/code\u0026gt; is that when overriding a method, the constructor of the base class will still refer to the overridden method. Consider this:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;BaseClass\u0026lt;/span\u0026gt; = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;) {\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; text = \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;null\u0026lt;/span\u0026gt;;\n\n    \u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;this\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;setText\u0026lt;/span\u0026gt; = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;value\u0026lt;/span\u0026gt;) {\n        text = value + \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot; BaseClass!\u0026quot;\u0026lt;/span\u0026gt;;\n    };\n\n    \u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;this\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;getText\u0026lt;/span\u0026gt; = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;) {\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; text;\n    };\n\n    \u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;this\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;setText\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Hello\u0026quot;\u0026lt;/span\u0026gt;); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// This always calls BaseClass.setText()\u0026lt;/span\u0026gt;\n};\n\n\u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;SubClass\u0026lt;/span\u0026gt; = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;) {\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// setText is not overridden yet,\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// so the constructor calls the superclass\u0026apos; method\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;BaseClass\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;call\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;this\u0026lt;/span\u0026gt;);\n\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Keeping a reference to the superclass\u0026apos; method\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; super_setText = \u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;this\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;setText\u0026lt;/span\u0026gt;;\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Overriding\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;this\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;setText\u0026lt;/span\u0026gt; = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;value\u0026lt;/span\u0026gt;) {\n        super_setText.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;call\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;this\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;SubClass says: \u0026quot;\u0026lt;/span\u0026gt; + value);\n    };\n};\n\u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;SubClass\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;prototype\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt; = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;BaseClass\u0026lt;/span\u0026gt;();\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; subClass = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;SubClass\u0026lt;/span\u0026gt;();\n\u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;console\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;log\u0026lt;/span\u0026gt;(subClass.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;getText\u0026lt;/span\u0026gt;()); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Hello BaseClass!\u0026lt;/span\u0026gt;\n\nsubClass.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;setText\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Hello\u0026quot;\u0026lt;/span\u0026gt;); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// setText is already overridden\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;console\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;log\u0026lt;/span\u0026gt;(subClass.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;getText\u0026lt;/span\u0026gt;()); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// SubClass says: Hello BaseClass!\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;versus:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;BaseClass\u0026lt;/span\u0026gt; = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;) {\n    \u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;this\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;setText\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Hello\u0026quot;\u0026lt;/span\u0026gt;); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// This calls the overridden method\u0026lt;/span\u0026gt;\n};\n\n\u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;BaseClass\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;prototype\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;setText\u0026lt;/span\u0026gt; = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;value\u0026lt;/span\u0026gt;) {\n    \u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;this\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;text\u0026lt;/span\u0026gt; = value + \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot; BaseClass!\u0026quot;\u0026lt;/span\u0026gt;;\n};\n\n\u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;BaseClass\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;prototype\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;getText\u0026lt;/span\u0026gt; = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;) {\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;this\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;text\u0026lt;/span\u0026gt;;\n};\n\n\u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;SubClass\u0026lt;/span\u0026gt; = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;) {\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// setText is already overridden, so this works as expected\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;BaseClass\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;call\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;this\u0026lt;/span\u0026gt;);\n};\n\u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;SubClass\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;prototype\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt; = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;BaseClass\u0026lt;/span\u0026gt;();\n\n\u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;SubClass\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;prototype\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;setText\u0026lt;/span\u0026gt; = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;value\u0026lt;/span\u0026gt;) {\n    \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;BaseClass\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;prototype\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;setText\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;call\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;this\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;SubClass says: \u0026quot;\u0026lt;/span\u0026gt; + value);\n};\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; subClass = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;SubClass\u0026lt;/span\u0026gt;();\n\u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;console\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;log\u0026lt;/span\u0026gt;(subClass.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;getText\u0026lt;/span\u0026gt;()); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// SubClass says: Hello BaseClass!\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;If you think this is not a problem, then it depends on whether you can live without private variables, and whether you are experienced enough to know a leak when you see one. Also, having to put the constructor logic after the method definitions is inconvenient.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; A = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt; (\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;param1\u0026lt;/span\u0026gt;) {\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; privateVar = \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;null\u0026lt;/span\u0026gt;; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Private variable\u0026lt;/span\u0026gt;\n\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Calling this.setPrivateVar(param1) here would be an error\u0026lt;/span\u0026gt;\n\n    \u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;this\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;setPrivateVar\u0026lt;/span\u0026gt; = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt; (\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;value\u0026lt;/span\u0026gt;) {\n        privateVar = value;\n        \u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;console\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;log\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;setPrivateVar value set to: \u0026quot;\u0026lt;/span\u0026gt; + value);\n\n        \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// param1 is still here, possible memory leak\u0026lt;/span\u0026gt;\n        \u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;console\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;log\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;setPrivateVar has param1: \u0026quot;\u0026lt;/span\u0026gt; + param1);\n    };\n\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// The constructor logic starts here possibly after\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// many lines of code that define methods\u0026lt;/span\u0026gt;\n\n    \u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;this\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;setPrivateVar\u0026lt;/span\u0026gt;(param1); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// This is valid\u0026lt;/span\u0026gt;\n};\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; a = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;A\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;);\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// setPrivateVar value set to: 0\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// setPrivateVar has param1: 0\u0026lt;/span\u0026gt;\n\na.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;setPrivateVar\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;);\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//setPrivateVar value set to: 1\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//setPrivateVar has param1: 0\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;versus:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; A = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt; (\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;param1\u0026lt;/span\u0026gt;) {\n    \u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;this\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;setPublicVar\u0026lt;/span\u0026gt;(param1); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// This is valid\u0026lt;/span\u0026gt;\n};\nA.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;prototype\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;setPublicVar\u0026lt;/span\u0026gt; = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt; (\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;value\u0026lt;/span\u0026gt;) {\n    \u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;this\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;publicVar\u0026lt;/span\u0026gt; = value; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// No private variable\u0026lt;/span\u0026gt;\n};\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; a = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;A\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;);\na.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;setPublicVar\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;);\n\u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;console\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;log\u0026lt;/span\u0026gt;(a.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;publicVar\u0026lt;/span\u0026gt;); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// 1\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Every object is linked to a prototype object. When trying to access a property that does not exist, JavaScript will look in the object\u0026apos;s prototype object for that property and return it if it exists.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;The \u0026lt;code\u0026gt;prototype\u0026lt;/code\u0026gt; property of a function constructor refers to the prototype object of all instances created with that function when using \u0026lt;code\u0026gt;new\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n\n\u0026lt;hr\u0026gt;\n\n\u0026lt;p\u0026gt;In your first example, you are adding a property \u0026lt;code\u0026gt;x\u0026lt;/code\u0026gt; to each instance created with the \u0026lt;code\u0026gt;A\u0026lt;/code\u0026gt; function.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; A = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt; (\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;) {\n    \u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;this\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;x\u0026lt;/span\u0026gt; = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt; (\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;) {\n        \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//do something\u0026lt;/span\u0026gt;\n    };\n};\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; a = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;A\u0026lt;/span\u0026gt;();    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// constructor function gets executed\u0026lt;/span\u0026gt;\n                    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// newly created object gets an \u0026apos;x\u0026apos; property\u0026lt;/span\u0026gt;\n                    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// which is a function\u0026lt;/span\u0026gt;\na.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;x\u0026lt;/span\u0026gt;();              \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// and can be called like this\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;In the second example you are adding a property to the prototype object that all the instances created with \u0026lt;code\u0026gt;A\u0026lt;/code\u0026gt; point to.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; A = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt; (\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;) { };\nA.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;prototype\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;x\u0026lt;/span\u0026gt; = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt; (\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;) {\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//do something\u0026lt;/span\u0026gt;\n};\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; a = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;A\u0026lt;/span\u0026gt;();    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// constructor function gets executed\u0026lt;/span\u0026gt;\n                    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// which does nothing in this example\u0026lt;/span\u0026gt;\n\na.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;x\u0026lt;/span\u0026gt;();              \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// you are trying to access the \u0026apos;x\u0026apos; property of an instance of \u0026apos;A\u0026apos;\u0026lt;/span\u0026gt;\n                    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// which does not exist\u0026lt;/span\u0026gt;\n                    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// so JavaScript looks for that property in the prototype object\u0026lt;/span\u0026gt;\n                    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// that was defined using the \u0026apos;prototype\u0026apos; property of the constructor\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;hr\u0026gt;\n\n\u0026lt;p\u0026gt;In conclusion, in the first example \u0026lt;strong\u0026gt;a copy of the function is assigned to each instance\u0026lt;/strong\u0026gt;. In the second example \u0026lt;strong\u0026gt;a single copy of the function is shared by all instances\u0026lt;/strong\u0026gt;.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;What\u0026apos;s the difference? =\u0026amp;gt; A lot.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;I think, the \u0026lt;code\u0026gt;this\u0026lt;/code\u0026gt; version is used to enable encapsulation, i.e. data hiding.\nIt helps to manipulate private variables.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Let us look at the following example:   \u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;AdultPerson\u0026lt;/span\u0026gt; = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;) {\n\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; age;\n\n  \u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;this\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;setAge\u0026lt;/span\u0026gt; = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;val\u0026lt;/span\u0026gt;) {\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// some housekeeping\u0026lt;/span\u0026gt;\n    age = val \u0026amp;gt;= \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;18\u0026lt;/span\u0026gt; \u0026amp;amp;\u0026amp;amp; val;\n  };\n\n  \u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;this\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;getAge\u0026lt;/span\u0026gt; = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;) {\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; age;\n  };\n\n  \u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;this\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;isValid\u0026lt;/span\u0026gt; = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;) {\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; !!age;\n  };\n};\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Now, the \u0026lt;code\u0026gt;prototype\u0026lt;/code\u0026gt; structure can be applied as following:\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Different adults have different ages, but all of the adults get the same rights.\u0026lt;br\u0026gt;\nSo, we add it using prototype, rather than this.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;AdultPerson\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;prototype\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;getRights\u0026lt;/span\u0026gt; = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;) {\n  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Should be valid\u0026lt;/span\u0026gt;\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;this\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;isValid\u0026lt;/span\u0026gt;() \u0026amp;amp;\u0026amp;amp; [\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;Booze\u0026apos;\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;Drive\u0026apos;\u0026lt;/span\u0026gt;];\n};\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Lets look at the implementation now.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; p1 = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;AdultPerson\u0026lt;/span\u0026gt;;\np1.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;setAge\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;12\u0026lt;/span\u0026gt;); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// ( age = false )\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;console\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;log\u0026lt;/span\u0026gt;(p1.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;getRights\u0026lt;/span\u0026gt;()); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// false ( Kid alert! )\u0026lt;/span\u0026gt;\np1.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;setAge\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;19\u0026lt;/span\u0026gt;); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// ( age = 19 )\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;console\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;log\u0026lt;/span\u0026gt;(p1.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;getRights\u0026lt;/span\u0026gt;()); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// [\u0026apos;Booze\u0026apos;, \u0026apos;Drive\u0026apos;] ( Welcome AdultPerson )\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; p2 = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;AdultPerson\u0026lt;/span\u0026gt;;\np2.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;setAge\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;45\u0026lt;/span\u0026gt;);    \n\u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;console\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;log\u0026lt;/span\u0026gt;(p2.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;getRights\u0026lt;/span\u0026gt;()); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// The same getRights() method, *** not a new copy of it ***\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Hope this helps.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;I know this has been answered to death but I\u0026apos;d like to show an actual example of speed differences.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Function directly on object:\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;/p\u0026gt;\u0026lt;div class=\u0026quot;snippet\u0026quot; data-lang=\u0026quot;js\u0026quot; data-hide=\u0026quot;false\u0026quot; data-console=\u0026quot;true\u0026quot; data-babel=\u0026quot;false\u0026quot;\u0026gt;\n\u0026lt;div class=\u0026quot;snippet-code\u0026quot;\u0026gt;\n\u0026lt;pre class=\u0026quot;snippet-code-js lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;ExampleFn\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;) {\n    \u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;this\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt; = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;) {\n        \u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;console\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;log\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Calling print! \u0026quot;\u0026lt;/span\u0026gt;);\n    }\n}\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; objects = [];\n\u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;console\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;time\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;x\u0026apos;\u0026lt;/span\u0026gt;);\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt; (\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;let\u0026lt;/span\u0026gt; i = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;; i \u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2000000\u0026lt;/span\u0026gt;; i++) {\n    objects.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;push\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;ExampleFn\u0026lt;/span\u0026gt;());\n}\n\u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;console\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;timeEnd\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;x\u0026apos;\u0026lt;/span\u0026gt;);\n\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//x: 1151.960693359375ms\u0026lt;/span\u0026gt;\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;div class=\u0026quot;snippet-result\u0026quot;\u0026gt;\u0026lt;div class=\u0026quot;snippet-ctas\u0026quot;\u0026gt;\u0026lt;button type=\u0026quot;button\u0026quot; class=\u0026quot;s-btn s-btn__primary\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;icon-play-white _hover\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;\u0026lt;span\u0026gt; Run code snippet\u0026lt;/span\u0026gt;\u0026lt;/button\u0026gt;\u0026lt;input class=\u0026quot;copySnippet s-btn s-btn__filled\u0026quot; type=\u0026quot;button\u0026quot; value=\u0026quot;Copy snippet to answer\u0026quot; style=\u0026quot;display: none;\u0026quot;\u0026gt;\u0026lt;button type=\u0026quot;button\u0026quot; class=\u0026quot;s-btn hideResults\u0026quot; style=\u0026quot;display: none;\u0026quot;\u0026gt;Hide results\u0026lt;/button\u0026gt;\u0026lt;div class=\u0026quot;popout-code\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;snippet-expand-link\u0026quot;\u0026gt;Expand snippet\u0026lt;/a\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;div class=\u0026quot;snippet-result-code\u0026quot; style=\u0026quot;display: none;\u0026quot;\u0026gt;\u0026lt;iframe name=\u0026quot;sif1\u0026quot; sandbox=\u0026quot;allow-forms allow-modals allow-scripts\u0026quot; class=\u0026quot;snippet-box-edit snippet-box-result\u0026quot; frameborder=\u0026quot;0\u0026quot;\u0026gt;\u0026lt;/iframe\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;/div\u0026gt;\n\u0026lt;/div\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Function on prototype:\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;/p\u0026gt;\u0026lt;div class=\u0026quot;snippet\u0026quot; data-lang=\u0026quot;js\u0026quot; data-hide=\u0026quot;false\u0026quot; data-console=\u0026quot;true\u0026quot; data-babel=\u0026quot;false\u0026quot;\u0026gt;\n\u0026lt;div class=\u0026quot;snippet-code\u0026quot;\u0026gt;\n\u0026lt;pre class=\u0026quot;snippet-code-js lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;ExampleFn\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;) {\n}\n\u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;ExampleFn\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;prototype\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt; = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;) {\n    \u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;console\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;log\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Calling print!\u0026quot;\u0026lt;/span\u0026gt;);\n}\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; objects = [];\n\u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;console\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;time\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;y\u0026apos;\u0026lt;/span\u0026gt;);\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt; (\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;let\u0026lt;/span\u0026gt; i = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;; i \u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2000000\u0026lt;/span\u0026gt;; i++) {\n    objects.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;push\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;ExampleFn\u0026lt;/span\u0026gt;());\n}\n\u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;console\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;timeEnd\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;y\u0026apos;\u0026lt;/span\u0026gt;);\n\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//x: 617.866943359375ms\u0026lt;/span\u0026gt;\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;div class=\u0026quot;snippet-result\u0026quot;\u0026gt;\u0026lt;div class=\u0026quot;snippet-ctas\u0026quot;\u0026gt;\u0026lt;button type=\u0026quot;button\u0026quot; class=\u0026quot;s-btn s-btn__primary\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;icon-play-white _hover\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;\u0026lt;span\u0026gt; Run code snippet\u0026lt;/span\u0026gt;\u0026lt;/button\u0026gt;\u0026lt;input class=\u0026quot;copySnippet s-btn s-btn__filled\u0026quot; type=\u0026quot;button\u0026quot; value=\u0026quot;Copy snippet to answer\u0026quot; style=\u0026quot;display: none;\u0026quot;\u0026gt;\u0026lt;button type=\u0026quot;button\u0026quot; class=\u0026quot;s-btn hideResults\u0026quot; style=\u0026quot;display: none;\u0026quot;\u0026gt;Hide results\u0026lt;/button\u0026gt;\u0026lt;div class=\u0026quot;popout-code\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;snippet-expand-link\u0026quot;\u0026gt;Expand snippet\u0026lt;/a\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;div class=\u0026quot;snippet-result-code\u0026quot; style=\u0026quot;display: none;\u0026quot;\u0026gt;\u0026lt;iframe name=\u0026quot;sif2\u0026quot; sandbox=\u0026quot;allow-forms allow-modals allow-scripts\u0026quot; class=\u0026quot;snippet-box-edit snippet-box-result\u0026quot; frameborder=\u0026quot;0\u0026quot;\u0026gt;\u0026lt;/iframe\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;/div\u0026gt;\n\u0026lt;/div\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Here we\u0026apos;re creating 2,000,000 new objects with a \u0026lt;code\u0026gt;print\u0026lt;/code\u0026gt; method in Chrome. We\u0026apos;re storing every object in an array. Putting \u0026lt;code\u0026gt;print\u0026lt;/code\u0026gt; on the prototype takes about 1/2 as long.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Prototype is the template of the class; which applies to all future instances of it. Whereas this is the particular instance of the object.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Let me give you a more comprehensive answer that I learned during a JavaScript training course.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Most answers mentioned the difference already, i.e. when prototyping the function is shared with all (future) instances. Whereas declaring the function in the class will create a copy for each instance.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;In general there is no right or wrong, it\u0026apos;s more a matter of taste or a design decision depending on your requirements. The prototype however is the technique that is used to develop in an object oriented manner, as I hope you\u0026apos;ll see at the end of this answer.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;You showed two patterns in your question. I will try to explain two more and try to explain the differences if relevant. Feel free to edit/extend.\nIn all examples it is about a car object that has a location and can move.\u0026lt;/p\u0026gt;\n\n\u0026lt;h1\u0026gt;Object Decorator pattern\u0026lt;/h1\u0026gt;\n\n\u0026lt;p\u0026gt;Not sure if this pattern is still relevant nowadays, but it exists. And it is good to know about it.\nYou simply pass an object and a property to the decorator function. The decorator returns the object with property and method.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; carlike = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;obj, loc\u0026lt;/span\u0026gt;) {\n    obj.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;loc\u0026lt;/span\u0026gt; = loc;\n    obj.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;move\u0026lt;/span\u0026gt; = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;) {\n        obj.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;loc\u0026lt;/span\u0026gt;++;\n    };\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; obj;\n};\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; amy = \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;carlike\u0026lt;/span\u0026gt;({}, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;);\namy.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;move\u0026lt;/span\u0026gt;();\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; ben = \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;carlike\u0026lt;/span\u0026gt;({}, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;9\u0026lt;/span\u0026gt;);\nben.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;move\u0026lt;/span\u0026gt;();\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;h1\u0026gt;Functional Classes\u0026lt;/h1\u0026gt;\n\n\u0026lt;p\u0026gt;A function in JavaScript is a specialised object. In addition to being invoked, a function can store properties like any other object.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;In this case \u0026lt;code\u0026gt;Car\u0026lt;/code\u0026gt; is a \u0026lt;strong\u0026gt;function\u0026lt;/strong\u0026gt; (\u0026lt;strong\u0026gt;also\u0026lt;/strong\u0026gt; think \u0026lt;strong\u0026gt;object\u0026lt;/strong\u0026gt;) that can be invoked as you are used to do. It has a property \u0026lt;code\u0026gt;methods\u0026lt;/code\u0026gt; (which is an object with a \u0026lt;code\u0026gt;move\u0026lt;/code\u0026gt; function). When \u0026lt;code\u0026gt;Car\u0026lt;/code\u0026gt; is invoked the \u0026lt;code\u0026gt;extend\u0026lt;/code\u0026gt; function is called, which does some magic, and extends the \u0026lt;code\u0026gt;Car\u0026lt;/code\u0026gt; function (think object) with the methods defined within \u0026lt;code\u0026gt;methods\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;This example, though different, comes closest to the first example in the question.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Car\u0026lt;/span\u0026gt; = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;loc\u0026lt;/span\u0026gt;) {\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; obj = {\u0026lt;span class=\u0026quot;hljs-attr\u0026quot;\u0026gt;loc\u0026lt;/span\u0026gt;: loc};\n    \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;extend\u0026lt;/span\u0026gt;(obj, \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Car\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;methods\u0026lt;/span\u0026gt;);\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; obj;\n};\n\n\u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Car\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;methods\u0026lt;/span\u0026gt; = {\n    move : \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;) {\n        \u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;this\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;loc\u0026lt;/span\u0026gt;++;\n    }\n};\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; amy = \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Car\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;);\namy.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;move\u0026lt;/span\u0026gt;();\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; ben = \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Car\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;9\u0026lt;/span\u0026gt;);\nben.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;move\u0026lt;/span\u0026gt;();\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;h1\u0026gt;Prototypal Classes\u0026lt;/h1\u0026gt;\n\n\u0026lt;p\u0026gt;The first two patterns allow a discussion of using techniques to define  shared methods or using methods that are defined inline in the body of the constructor. In both cases every instance has its own \u0026lt;code\u0026gt;move\u0026lt;/code\u0026gt; function.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;The prototypal pattern does not lend itself well to the same examination, because function sharing via a prototype delegation is the very goal for the prototypal pattern. As others pointed out, it is expected to have a better memory footprint.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;However there is one point interesting to know:\nEvery \u0026lt;code\u0026gt;prototype\u0026lt;/code\u0026gt; object has has a convenience property \u0026lt;code\u0026gt;constructor\u0026lt;/code\u0026gt;, which points back to the function (think object) it came attached to.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Concerning the last three lines:\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;In this example \u0026lt;code\u0026gt;Car\u0026lt;/code\u0026gt; links to the \u0026lt;code\u0026gt;prototype\u0026lt;/code\u0026gt; object, which links via \u0026lt;code\u0026gt;constructor\u0026lt;/code\u0026gt; to \u0026lt;code\u0026gt;Car\u0026lt;/code\u0026gt; itself, i.e. \u0026lt;code\u0026gt;Car.prototype.constructor\u0026lt;/code\u0026gt; is \u0026lt;code\u0026gt;Car\u0026lt;/code\u0026gt; itself. This allows you to figure out which constructor function built a certain object.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;code\u0026gt;amy.constructor\u0026lt;/code\u0026gt;\u0026apos;s lookup fails and thus is delegated to \u0026lt;code\u0026gt;Car.prototype\u0026lt;/code\u0026gt;, which does have the constructor property. And so \u0026lt;code\u0026gt;amy.constructor\u0026lt;/code\u0026gt; is \u0026lt;code\u0026gt;Car\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Furthermore, \u0026lt;code\u0026gt;amy\u0026lt;/code\u0026gt; is an \u0026lt;code\u0026gt;instanceof\u0026lt;/code\u0026gt; \u0026lt;code\u0026gt;Car\u0026lt;/code\u0026gt;. The \u0026lt;code\u0026gt;instanceof\u0026lt;/code\u0026gt; operator works by seeing if the right operand\u0026apos;s prototype object (\u0026lt;code\u0026gt;Car\u0026lt;/code\u0026gt;) can be found anywhere in the left operand\u0026apos;s prototype (\u0026lt;code\u0026gt;amy\u0026lt;/code\u0026gt;) chain.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Car\u0026lt;/span\u0026gt; = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;loc\u0026lt;/span\u0026gt;) {\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; obj = \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Object\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;create\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Car\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;prototype\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;);\n    obj.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;loc\u0026lt;/span\u0026gt; = loc;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; obj;\n};\n\n\u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Car\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;prototype\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;move\u0026lt;/span\u0026gt; = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;) {\n        \u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;this\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;loc\u0026lt;/span\u0026gt;++;\n};\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; amy = \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Car\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;);\namy.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;move\u0026lt;/span\u0026gt;();\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; ben = \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Car\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;9\u0026lt;/span\u0026gt;);\nben.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;move\u0026lt;/span\u0026gt;();\n\n\u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;console\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;log\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Car\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;prototype\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;constructor\u0026lt;/span\u0026gt;);\n\u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;console\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;log\u0026lt;/span\u0026gt;(amy.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;constructor\u0026lt;/span\u0026gt;);\n\u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;console\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;log\u0026lt;/span\u0026gt;(amy \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;instanceof\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Car\u0026lt;/span\u0026gt;);\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Some developers can be confused in the beginning. See below example:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Dog\u0026lt;/span\u0026gt; = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;) {\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; {\u0026lt;span class=\u0026quot;hljs-attr\u0026quot;\u0026gt;legs\u0026lt;/span\u0026gt;: \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;4\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-attr\u0026quot;\u0026gt;bark\u0026lt;/span\u0026gt;: alert};\n};\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; fido = \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Dog\u0026lt;/span\u0026gt;();\n\u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;console\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;log\u0026lt;/span\u0026gt;(fido \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;instanceof\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Dog\u0026lt;/span\u0026gt;);\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;The \u0026lt;code\u0026gt;instanceof\u0026lt;/code\u0026gt; operator returns \u0026lt;code\u0026gt;false\u0026lt;/code\u0026gt;, because \u0026lt;code\u0026gt;Dog\u0026lt;/code\u0026gt;\u0026apos;s prototype cannot be found anywhere in \u0026lt;code\u0026gt;fido\u0026lt;/code\u0026gt;\u0026apos;s prototype chain. \u0026lt;code\u0026gt;fido\u0026lt;/code\u0026gt; is a simple object that is created with an object literal, i.e. it just delegates to \u0026lt;code\u0026gt;Object.prototype\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n\n\u0026lt;h1\u0026gt;Pseudoclassical patterns\u0026lt;/h1\u0026gt;\n\n\u0026lt;p\u0026gt;This is really just another form of the prototypal pattern in simplified form and more familiar to do those who program in Java for example, since it uses the \u0026lt;code\u0026gt;new\u0026lt;/code\u0026gt; constructor.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;It does the same as in the prototypal pattern really, it is just syntactic sugar overtop of the prototypal pattern.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;However, the primary difference is that there are optimizations implemented in JavaScript engines that only apply when using the pseudoclassical pattern. Think of the pseudoclassical pattern a probably faster version of the prototypal pattern; the object relations in both examples are the same.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Car\u0026lt;/span\u0026gt; = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;loc\u0026lt;/span\u0026gt;) {\n    \u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;this\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;loc\u0026lt;/span\u0026gt; = loc;\n};\n\n\u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Car\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;prototype\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;move\u0026lt;/span\u0026gt; = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;) {\n        \u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;this\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;loc\u0026lt;/span\u0026gt;++;\n};\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; amy = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Car\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;);\namy.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;move\u0026lt;/span\u0026gt;();\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; ben = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Car\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;9\u0026lt;/span\u0026gt;);\nben.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;move\u0026lt;/span\u0026gt;();\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;hr\u0026gt;\n\n\u0026lt;p\u0026gt;Finally, it should not be too difficult to realize how object oriented programming can be done. There are two sections. \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;One section that defines common properties/methods in the prototype (chain).\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;And another section where you put the definitions that distinguish the objects from each other (\u0026lt;code\u0026gt;loc\u0026lt;/code\u0026gt; variable in the examples).\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;This is what allows us to apply concepts like superclass or subclass in JavaScript.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Feel free to add or edit. Once more complete I could make this a community wiki maybe.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;I believe that @Matthew Crumley is right.  They are \u0026lt;em\u0026gt;functionally\u0026lt;/em\u0026gt;, if not structurally, equivalent.  If you use Firebug to look at the objects that are created using \u0026lt;code\u0026gt;new\u0026lt;/code\u0026gt;, you can see that they are the same.  However, my preference would be the following.  I\u0026apos;m guessing that it just seems more like what I\u0026apos;m used to in C#/Java.  That is, define the class, define the fields, constructor, and methods.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; A = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;) {};\nA.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;prototype\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt; = {\n    \u0026lt;span class=\u0026quot;hljs-attr\u0026quot;\u0026gt;_instance_var\u0026lt;/span\u0026gt;: \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;,\n\n    \u0026lt;span class=\u0026quot;hljs-attr\u0026quot;\u0026gt;initialize\u0026lt;/span\u0026gt;: \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;v\u0026lt;/span\u0026gt;) { \u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;this\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;_instance_var\u0026lt;/span\u0026gt; = v; },\n\n    \u0026lt;span class=\u0026quot;hljs-attr\u0026quot;\u0026gt;x\u0026lt;/span\u0026gt;: \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;) {  \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;alert\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;this\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;_instance_var\u0026lt;/span\u0026gt;); }\n};\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;EDIT\u0026lt;/strong\u0026gt; Didn\u0026apos;t mean to imply that the scope of the variable was private, I was just trying to illustrate how I define my classes in javascript.  Variable name has been changed to reflect this.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;As discussed in other answers, it\u0026apos;s really a performance consideration because the function in the prototype is shared with all of the instantiations - rather than the function being created for each instantiation.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;I put together a jsperf to show this. There is a dramatic difference in the time it takes to instantiate the class, although it is really only relevant if you are making many instances.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;a href=\u0026quot;http://jsperf.com/functions-in-constructor-vs-prototype\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;http://jsperf.com/functions-in-constructor-vs-prototype\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Think about statically typed language, things on \u0026lt;code\u0026gt;prototype\u0026lt;/code\u0026gt; are static and things on \u0026lt;code\u0026gt;this\u0026lt;/code\u0026gt; are instance related.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;When you use prototype, the function will only be loaded only once into memory (independently on the amount of objects you create) and you can override the function whenever you want.\u0026lt;/p\u0026gt;\n    "],"id":476,"title":"Use of 'prototype' vs. 'this' in JavaScript?","content":"\n                \n\u0026lt;p\u0026gt;What\u0026apos;s the difference between\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; A = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt; (\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;) {\n    \u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;this\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;x\u0026lt;/span\u0026gt; = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt; (\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;) {\n        \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//do something\u0026lt;/span\u0026gt;\n    };\n};\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;and\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; A = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt; (\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;) { };\nA.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;prototype\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;x\u0026lt;/span\u0026gt; = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt; (\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;) {\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//do something\u0026lt;/span\u0026gt;\n};\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","slug":"use-of-'prototype'-vs.-'this'-in-javascript-1657388117307","postType":"QUESTION","createdAt":"2022-07-09T17:35:17.000Z","updatedAt":"2022-07-09T17:35:17.000Z","tags":[],"relatedQuestions":[]},"randomQuestions":[{"title":"srand()  why call it only once?","slug":"srand()-why-call-it-only-once-1657387794760"},{"title":"What is the difference between public, protected, package-private and private in Java?","slug":"what-is-the-difference-between-public-protected-package-private-and-private-in-java-1657387376262"},{"title":"Servlet returns \"HTTP Status 404 The requested resource (/servlet) is not available\"","slug":"servlet-returns-\"http-status-404-the-requested-resource-(servlet)-is-not-available\"-1657384850661"},{"title":"Efficiently convert rows to columns in sql server","slug":"efficiently-convert-rows-to-columns-in-sql-server-1657387919213"},{"title":"Is floating point math broken?","slug":"is-floating-point-math-broken-1657384238910"},{"title":"Why does a RegExp with global flag give wrong results?","slug":"why-does-a-regexp-with-global-flag-give-wrong-results-1657387788550"},{"title":"How do I use reflection to call a generic method?","slug":"how-do-i-use-reflection-to-call-a-generic-method-1657387256751"},{"title":"Removing trailing newline character from fgets() input","slug":"removing-trailing-newline-character-from-fgets()-input-1657387308069"},{"title":"Returning data from async call in Swift function","slug":"returning-data-from-async-call-in-swift-function-1657387469218"},{"title":"What is the difference between a deep copy and a shallow copy?","slug":"what-is-the-difference-between-a-deep-copy-and-a-shallow-copy-1657388445063"},{"title":"Why does my ArrayList contain N copies of the last item added to the list?","slug":"why-does-my-arraylist-contain-n-copies-of-the-last-item-added-to-the-list-1657387712003"},{"title":"Download a file by jQuery.Ajax","slug":"download-a-file-by-jquery.ajax-1657388220611"},{"title":"Prefer composition over inheritance?","slug":"prefer-composition-over-inheritance-1657387399409"},{"title":"Importing files from different folder","slug":"importing-files-from-different-folder-1657388203798"},{"title":"Undefined behavior and sequence points","slug":"undefined-behavior-and-sequence-points-1657384639493"},{"title":"In CSS Flexbox, why are there no \"justify-items\" and \"justify-self\" properties?","slug":"in-css-flexbox-why-are-there-no-\"justify-items\"-and-\"justify-self\"-properties-1657384782711"},{"title":"Retrieving the last record in each group - MySQL","slug":"retrieving-the-last-record-in-each-group-mysql-1657384887369"},{"title":"Deserialize JSON into C# dynamic object?","slug":"deserialize-json-into-c-dynamic-object-1657388568720"},{"title":"Merge/flatten an array of arrays","slug":"mergeflatten-an-array-of-arrays-1657387827427"},{"title":"How to generate all permutations of a list","slug":"how-to-generate-all-permutations-of-a-list-1657388537371"}]},"__N_SSG":true},"page":"/questions/[slug]","query":{"slug":"use-of-'prototype'-vs.-'this'-in-javascript-1657388117307"},"buildId":"XDXakEY6gSPdgAODPxtjg","isFallback":false,"gsp":true,"locale":"en","locales":["en"],"defaultLocale":"en","scriptLoader":[]}</script></body></html>