{"pageProps":{"data":{"answer":["\n&lt;p&gt;&lt;strong&gt;&lt;code&gt;static_cast&lt;/code&gt;&lt;/strong&gt; is the first cast you should attempt to use. It does things like implicit conversions between types (such as &lt;code&gt;int&lt;/code&gt; to &lt;code&gt;float&lt;/code&gt;, or pointer to &lt;code&gt;void*&lt;/code&gt;), and it can also call explicit conversion functions (or implicit ones). In many cases, explicitly stating &lt;code&gt;static_cast&lt;/code&gt; isn&apos;t necessary, but it&apos;s important to note that the &lt;code&gt;T(something)&lt;/code&gt; syntax is equivalent to &lt;code&gt;(T)something&lt;/code&gt; and should be avoided (more on that later). A &lt;code&gt;T(something, something_else)&lt;/code&gt; is safe, however, and guaranteed to call the constructor.&lt;/p&gt;\n\n&lt;p&gt;&lt;code&gt;static_cast&lt;/code&gt; can also cast through inheritance hierarchies. It is unnecessary when casting upwards (towards a base class), but when casting downwards it can be used as long as it doesn&apos;t cast through &lt;code&gt;virtual&lt;/code&gt; inheritance. It does not do checking, however, and it is undefined behavior to &lt;code&gt;static_cast&lt;/code&gt; down a hierarchy to a type that isn&apos;t actually the type of the object.&lt;/p&gt;\n\n&lt;hr&gt;\n\n&lt;p&gt;&lt;strong&gt;&lt;code&gt;const_cast&lt;/code&gt;&lt;/strong&gt; can be used to remove or add &lt;code&gt;const&lt;/code&gt; to a variable; no other C++ cast is capable of removing it (not even &lt;code&gt;reinterpret_cast&lt;/code&gt;). It is important to note that modifying a formerly &lt;code&gt;const&lt;/code&gt; value is only undefined if the original variable is &lt;code&gt;const&lt;/code&gt;; if you use it to take the &lt;code&gt;const&lt;/code&gt; off a reference to something that wasn&apos;t declared with &lt;code&gt;const&lt;/code&gt;, it is safe. This can be useful when overloading member functions based on &lt;code&gt;const&lt;/code&gt;, for instance. It can also be used to add &lt;code&gt;const&lt;/code&gt; to an object, such as to call a member function overload.&lt;/p&gt;\n\n&lt;p&gt;&lt;code&gt;const_cast&lt;/code&gt; also works similarly on &lt;code&gt;volatile&lt;/code&gt;, though that&apos;s less common.&lt;/p&gt;\n\n&lt;hr&gt;\n\n&lt;p&gt;&lt;strong&gt;&lt;code&gt;dynamic_cast&lt;/code&gt;&lt;/strong&gt; is exclusively used for handling polymorphism. You can cast a pointer or reference to any polymorphic type to any other class type (a polymorphic type has at least one virtual function, declared or inherited). You can use it for more than just casting downwards  you can cast sideways or even up another chain. The &lt;code&gt;dynamic_cast&lt;/code&gt; will seek out the desired object and return it if possible. If it can&apos;t, it will return &lt;code&gt;nullptr&lt;/code&gt; in the case of a pointer, or throw &lt;code&gt;std::bad_cast&lt;/code&gt; in the case of a reference.&lt;/p&gt;\n\n&lt;p&gt;&lt;code&gt;dynamic_cast&lt;/code&gt; has some limitations, though. It doesn&apos;t work if there are multiple objects of the same type in the inheritance hierarchy (the so-called &apos;dreaded diamond&apos;) and you aren&apos;t using &lt;code&gt;virtual&lt;/code&gt; inheritance. It also can only go through public inheritance - it will always fail to travel through &lt;code&gt;protected&lt;/code&gt; or &lt;code&gt;private&lt;/code&gt; inheritance. This is rarely an issue, however, as such forms of inheritance are rare.&lt;/p&gt;\n\n&lt;hr&gt;\n\n&lt;p&gt;&lt;strong&gt;&lt;code&gt;reinterpret_cast&lt;/code&gt;&lt;/strong&gt; is the most dangerous cast, and should be used very sparingly. It turns one type directly into another  such as casting the value from one pointer to another, or storing a pointer in an &lt;code&gt;int&lt;/code&gt;, or all sorts of other nasty things. Largely, the only guarantee you get with &lt;code&gt;reinterpret_cast&lt;/code&gt; is that normally if you cast the result back to the original type, you will get the exact same value (but &lt;strong&gt;&lt;em&gt;not&lt;/em&gt;&lt;/strong&gt; if the intermediate type is smaller than the original type). There are a number of conversions that &lt;strong&gt;&lt;code&gt;reinterpret_cast&lt;/code&gt;&lt;/strong&gt; cannot do, too. It&apos;s used primarily for particularly weird conversions and bit manipulations, like turning a raw data stream into actual data, or storing data in the low bits of a pointer to aligned data.&lt;/p&gt;\n\n&lt;hr&gt;\n\n&lt;p&gt;&lt;strong&gt;C-style cast&lt;/strong&gt; and &lt;strong&gt;function-style cast&lt;/strong&gt; are casts using &lt;code&gt;(type)object&lt;/code&gt; or &lt;code&gt;type(object)&lt;/code&gt;, respectively, and are functionally equivalent. They are defined as the first of the following which succeeds:&lt;/p&gt;\n\n&lt;ul&gt;\n&lt;li&gt;&lt;code&gt;const_cast&lt;/code&gt;&lt;/li&gt;\n&lt;li&gt;&lt;code&gt;static_cast&lt;/code&gt; (though ignoring access restrictions)&lt;/li&gt;\n&lt;li&gt;&lt;code&gt;static_cast&lt;/code&gt; (see above), then &lt;code&gt;const_cast&lt;/code&gt;&lt;/li&gt;\n&lt;li&gt;&lt;code&gt;reinterpret_cast&lt;/code&gt;&lt;/li&gt;\n&lt;li&gt;&lt;code&gt;reinterpret_cast&lt;/code&gt;, then &lt;code&gt;const_cast&lt;/code&gt;&lt;/li&gt;\n&lt;/ul&gt;\n\n&lt;p&gt;It can therefore be used as a replacement for other casts in some instances, but can be extremely dangerous because of the ability to devolve into a &lt;code&gt;reinterpret_cast&lt;/code&gt;, and the latter should be preferred when explicit casting is needed, unless you are sure &lt;code&gt;static_cast&lt;/code&gt; will succeed or &lt;code&gt;reinterpret_cast&lt;/code&gt; will fail. Even then, consider the longer, more explicit option.&lt;/p&gt;\n\n&lt;p&gt;C-style casts also ignore access control when performing a &lt;code&gt;static_cast&lt;/code&gt;, which means that they have the ability to perform an operation that no other cast can. This is mostly a kludge, though, and in my mind is just another reason to avoid C-style casts.&lt;/p&gt;\n    ","\n&lt;ul&gt;\n&lt;li&gt;&lt;p&gt;Use &lt;code&gt;dynamic_cast&lt;/code&gt; for converting pointers/references within an inheritance hierarchy.&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;p&gt;Use &lt;code&gt;static_cast&lt;/code&gt; for ordinary type conversions.&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;p&gt;Use &lt;code&gt;reinterpret_cast&lt;/code&gt; for low-level reinterpreting of bit patterns.  Use with extreme caution.&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;p&gt;Use &lt;code&gt;const_cast&lt;/code&gt; for casting away &lt;code&gt;const/volatile&lt;/code&gt;.  Avoid this unless you are stuck using a const-incorrect API.&lt;/p&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n    ","\n&lt;p&gt;&lt;em&gt;(A lot of theoretical and conceptual explanation has been given above)&lt;/em&gt; &lt;/p&gt;\n\n&lt;p&gt;Below are some of the &lt;strong&gt;practical examples&lt;/strong&gt; when I used &lt;strong&gt;static_cast&lt;/strong&gt;, &lt;strong&gt;dynamic_cast&lt;/strong&gt;, &lt;strong&gt;const_cast&lt;/strong&gt;, &lt;strong&gt;reinterpret_cast&lt;/strong&gt;.&lt;/p&gt;\n\n&lt;p&gt;(Also referes this to understand the explaination : &lt;a href=&quot;http://www.cplusplus.com/doc/tutorial/typecasting/&quot; rel=&quot;noreferrer&quot;&gt;http://www.cplusplus.com/doc/tutorial/typecasting/&lt;/a&gt;)&lt;/p&gt;\n\n&lt;p&gt;&lt;strong&gt;static_cast :&lt;/strong&gt;&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;OnEventData&lt;/span&gt;(&lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt;* pData)\n\n{\n  ......\n\n  &lt;span class=&quot;hljs-comment&quot;&gt;//  pData is a void* pData, &lt;/span&gt;\n\n  &lt;span class=&quot;hljs-comment&quot;&gt;//  EventData is a structure e.g. &lt;/span&gt;\n  &lt;span class=&quot;hljs-comment&quot;&gt;//  typedef struct _EventData {&lt;/span&gt;\n  &lt;span class=&quot;hljs-comment&quot;&gt;//  std::string id;&lt;/span&gt;\n  &lt;span class=&quot;hljs-comment&quot;&gt;//  std:: string remote_id;&lt;/span&gt;\n  &lt;span class=&quot;hljs-comment&quot;&gt;//  } EventData;&lt;/span&gt;\n\n  &lt;span class=&quot;hljs-comment&quot;&gt;// On Some Situation a void pointer *pData&lt;/span&gt;\n  &lt;span class=&quot;hljs-comment&quot;&gt;// has been static_casted as &lt;/span&gt;\n  &lt;span class=&quot;hljs-comment&quot;&gt;// EventData* pointer &lt;/span&gt;\n\n  EventData *evtdata = &lt;span class=&quot;hljs-built_in&quot;&gt;static_cast&lt;/span&gt;&amp;lt;EventData*&amp;gt;(pData);\n  .....\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;&lt;strong&gt;dynamic_cast :&lt;/strong&gt;&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;DebugLog::OnMessage&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(Message *msg)&lt;/span&gt;\n&lt;/span&gt;{\n    &lt;span class=&quot;hljs-type&quot;&gt;static&lt;/span&gt; DebugMsgData *debug;\n    &lt;span class=&quot;hljs-type&quot;&gt;static&lt;/span&gt; XYZMsgData *xyz;\n\n    &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt;(debug = &lt;span class=&quot;hljs-built_in&quot;&gt;dynamic_cast&lt;/span&gt;&amp;lt;DebugMsgData*&amp;gt;(msg-&amp;gt;pdata)){\n        &lt;span class=&quot;hljs-comment&quot;&gt;// debug message&lt;/span&gt;\n    }\n    &lt;span class=&quot;hljs-keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt;(xyz = &lt;span class=&quot;hljs-built_in&quot;&gt;dynamic_cast&lt;/span&gt;&amp;lt;XYZMsgData*&amp;gt;(msg-&amp;gt;pdata)){\n        &lt;span class=&quot;hljs-comment&quot;&gt;// xyz message&lt;/span&gt;\n    }\n    &lt;span class=&quot;hljs-keyword&quot;&gt;else&lt;/span&gt;&lt;span class=&quot;hljs-comment&quot;&gt;/* if( ... )*/&lt;/span&gt;{\n        &lt;span class=&quot;hljs-comment&quot;&gt;// ...&lt;/span&gt;\n    }\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;&lt;strong&gt;const_cast :&lt;/strong&gt;&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-comment&quot;&gt;// *Passwd declared as a const&lt;/span&gt;\n\n&lt;span class=&quot;hljs-type&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;char&lt;/span&gt; *Passwd\n\n\n&lt;span class=&quot;hljs-comment&quot;&gt;// on some situation it require to remove its constness&lt;/span&gt;\n\n&lt;span class=&quot;hljs-built_in&quot;&gt;const_cast&lt;/span&gt;&amp;lt;&lt;span class=&quot;hljs-type&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;char&lt;/span&gt;*&amp;gt;(Passwd)\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;&lt;strong&gt;reinterpret_cast :&lt;/strong&gt;&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;short&lt;/span&gt; uint16;\n\n&lt;span class=&quot;hljs-comment&quot;&gt;// Read Bytes returns that 2 bytes got read. &lt;/span&gt;\n\n&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;bool&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;ByteBuffer::ReadUInt16&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(uint16&amp;amp; val)&lt;/span&gt; &lt;/span&gt;{\n  &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-built_in&quot;&gt;ReadBytes&lt;/span&gt;(&lt;span class=&quot;hljs-built_in&quot;&gt;reinterpret_cast&lt;/span&gt;&amp;lt;&lt;span class=&quot;hljs-type&quot;&gt;char&lt;/span&gt;*&amp;gt;(&amp;amp;val), &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;);\n}\n&lt;/code&gt;&lt;/pre&gt;\n    ","\n&lt;p&gt;It might help if you know little bit of internals...&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;static_cast&lt;/strong&gt;&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;C++ compiler already knows how to convert between scaler types such as &lt;code&gt;float&lt;/code&gt; to &lt;code&gt;int&lt;/code&gt;. Use &lt;code&gt;static_cast&lt;/code&gt; for them.&lt;/li&gt;\n&lt;li&gt;When you ask compiler to convert from type &lt;code&gt;A&lt;/code&gt; to &lt;code&gt;B&lt;/code&gt;, &lt;code&gt;static_cast&lt;/code&gt; calls &lt;code&gt;B&lt;/code&gt;&apos;s constructor passing &lt;code&gt;A&lt;/code&gt; as param. Alternatively, &lt;code&gt;A&lt;/code&gt; could have a conversion operator (i.e. &lt;code&gt;A::operator B()&lt;/code&gt;).  If &lt;code&gt;B&lt;/code&gt; doesn&apos;t have such constructor, or &lt;code&gt;A&lt;/code&gt; doesn&apos;t have a conversion operator, then you get compile time error.&lt;/li&gt;\n&lt;li&gt;Cast from &lt;code&gt;A*&lt;/code&gt; to &lt;code&gt;B*&lt;/code&gt; always succeeds if A and B are in inheritance hierarchy (or void) otherwise you get compile error.&lt;/li&gt;\n&lt;li&gt;&lt;strong&gt;Gotcha&lt;/strong&gt;: If you cast base pointer to derived pointer but if actual object is not really derived type then you &lt;em&gt;don&apos;t&lt;/em&gt; get error. You get bad pointer and  very likely a segfault at runtime. Same goes for &lt;code&gt;A&amp;amp;&lt;/code&gt; to &lt;code&gt;B&amp;amp;&lt;/code&gt;.&lt;/li&gt;\n&lt;li&gt;&lt;strong&gt;Gotcha&lt;/strong&gt;: Cast from Derived to Base or viceversa creates &lt;em&gt;new&lt;/em&gt; copy! For people coming from C#/Java, this can be a huge surprise because the result is basically a chopped off object created from Derived.&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;&lt;strong&gt;dynamic_cast&lt;/strong&gt;&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;dynamic_cast uses runtime type information to figure out if cast is valid. For example, &lt;code&gt;(Base*)&lt;/code&gt; to &lt;code&gt;(Derived*)&lt;/code&gt; may fail if pointer is not actually of derived type.&lt;/li&gt;\n&lt;li&gt;This means, dynamic_cast is very expensive compared to static_cast!&lt;/li&gt;\n&lt;li&gt;For &lt;code&gt;A*&lt;/code&gt; to &lt;code&gt;B*&lt;/code&gt;, if cast is invalid then dynamic_cast will return nullptr.&lt;/li&gt;\n&lt;li&gt;For &lt;code&gt;A&amp;amp;&lt;/code&gt; to &lt;code&gt;B&amp;amp;&lt;/code&gt; if cast is invalid then dynamic_cast will throw bad_cast exception.&lt;/li&gt;\n&lt;li&gt;Unlike other casts, there is runtime overhead.&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;&lt;strong&gt;const_cast&lt;/strong&gt;&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;While static_cast can do non-const to const it can&apos;t go other way around. The const_cast can do both ways.&lt;/li&gt;\n&lt;li&gt;One example where this comes handy is iterating through some container like &lt;code&gt;set&amp;lt;T&amp;gt;&lt;/code&gt; which only returns its elements as const to make sure you don&apos;t change its key. However if your intent is to modify object&apos;s non-key members then it should be ok. You can use const_cast to remove constness.&lt;/li&gt;\n&lt;li&gt;Another example is when you want to implement &lt;code&gt;T&amp;amp; SomeClass::foo()&lt;/code&gt; as well as &lt;code&gt;const T&amp;amp; SomeClass::foo() const&lt;/code&gt;. To avoid code duplication, you can apply const_cast to return value of one function from another.&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;&lt;strong&gt;reinterpret_cast&lt;/strong&gt;&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;This basically says that take these bytes at this memory location and think of it as given object.&lt;/li&gt;\n&lt;li&gt;For example, you can load 4 bytes of &lt;code&gt;float&lt;/code&gt; to 4 bytes of &lt;code&gt;int&lt;/code&gt; to see how bits in &lt;code&gt;float&lt;/code&gt; looks like.&lt;/li&gt;\n&lt;li&gt;Obviously, if data is not correct for the type, you may get segfault.&lt;/li&gt;\n&lt;li&gt;There is no runtime overhead for this cast.&lt;/li&gt;\n&lt;/ul&gt;\n    ","\n&lt;p&gt;Does &lt;a href=&quot;http://www.cppreference.com/wiki/keywords/casting_comparison&quot; rel=&quot;noreferrer&quot;&gt;this&lt;/a&gt; answer your question?&lt;/p&gt;\n\n&lt;p&gt;I have never used &lt;code&gt;reinterpret_cast&lt;/code&gt;, and wonder whether running into a case that needs it isn&apos;t a smell of bad design. In the code base I work on &lt;code&gt;dynamic_cast&lt;/code&gt; is used a lot. The difference with  &lt;code&gt;static_cast&lt;/code&gt; is that a &lt;code&gt;dynamic_cast&lt;/code&gt; does runtime checking which may (safer) or may not (more overhead) be what you want (see &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/c36yw7x9(VS.80).aspx&quot; rel=&quot;noreferrer&quot;&gt;msdn&lt;/a&gt;).&lt;/p&gt;\n    ","\n&lt;p&gt;In addition to the other answers so far, here is unobvious example where &lt;code&gt;static_cast&lt;/code&gt; is not sufficient so that &lt;code&gt;reinterpret_cast&lt;/code&gt; is needed. Suppose there is a function which in an output parameter returns pointers to objects of different classes (which do not share a common base class). A real example of such function is &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/windows/desktop/ms686615%28v=vs.85%29.aspx&quot; rel=&quot;noreferrer&quot;&gt;&lt;code&gt;CoCreateInstance()&lt;/code&gt;&lt;/a&gt; (see the last parameter, which is in fact &lt;code&gt;void**&lt;/code&gt;). Suppose you request particular class of object from this function, so you know in advance the type for the pointer (which you often do for COM objects). In this case you cannot cast pointer to your pointer into &lt;code&gt;void**&lt;/code&gt; with &lt;code&gt;static_cast&lt;/code&gt;: you need &lt;code&gt;reinterpret_cast&amp;lt;void**&amp;gt;(&amp;amp;yourPointer)&lt;/code&gt;. &lt;/p&gt;\n\n&lt;p&gt;In code:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&amp;lt;windows.h&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&amp;lt;netfw.h&amp;gt;&lt;/span&gt;&lt;/span&gt;\n.....\nINetFwPolicy2* pNetFwPolicy2 = &lt;span class=&quot;hljs-literal&quot;&gt;nullptr&lt;/span&gt;;\nHRESULT hr = &lt;span class=&quot;hljs-built_in&quot;&gt;CoCreateInstance&lt;/span&gt;(__uuidof(NetFwPolicy2), &lt;span class=&quot;hljs-literal&quot;&gt;nullptr&lt;/span&gt;,\n    CLSCTX_INPROC_SERVER, __uuidof(INetFwPolicy2),\n    &lt;span class=&quot;hljs-comment&quot;&gt;//static_cast&amp;lt;void**&amp;gt;(&amp;amp;pNetFwPolicy2) would give a compile error&lt;/span&gt;\n    &lt;span class=&quot;hljs-built_in&quot;&gt;reinterpret_cast&lt;/span&gt;&amp;lt;&lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt;**&amp;gt;(&amp;amp;pNetFwPolicy2) );\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;However, &lt;code&gt;static_cast&lt;/code&gt; works for simple pointers (not pointers to pointers), so the above code can be rewritten to avoid &lt;code&gt;reinterpret_cast&lt;/code&gt; (at a price of an extra variable) in the following way:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&amp;lt;windows.h&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&amp;lt;netfw.h&amp;gt;&lt;/span&gt;&lt;/span&gt;\n.....\nINetFwPolicy2* pNetFwPolicy2 = &lt;span class=&quot;hljs-literal&quot;&gt;nullptr&lt;/span&gt;;\n&lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt;* tmp = &lt;span class=&quot;hljs-literal&quot;&gt;nullptr&lt;/span&gt;;\nHRESULT hr = &lt;span class=&quot;hljs-built_in&quot;&gt;CoCreateInstance&lt;/span&gt;(__uuidof(NetFwPolicy2), &lt;span class=&quot;hljs-literal&quot;&gt;nullptr&lt;/span&gt;,\n    CLSCTX_INPROC_SERVER, __uuidof(INetFwPolicy2),\n    &amp;amp;tmp );\npNetFwPolicy2 = &lt;span class=&quot;hljs-built_in&quot;&gt;static_cast&lt;/span&gt;&amp;lt;INetFwPolicy2*&amp;gt;(tmp);\n&lt;/code&gt;&lt;/pre&gt;\n    ","\n&lt;p&gt;&lt;strong&gt;&lt;code&gt;static_cast&lt;/code&gt; vs &lt;code&gt;dynamic_cast&lt;/code&gt; vs &lt;code&gt;reinterpret_cast&lt;/code&gt; internals view on a downcast/upcast&lt;/strong&gt;&lt;/p&gt;\n&lt;p&gt;In this answer, I want to compare these three mechanisms on a concrete upcast/downcast example and analyze what happens to the underlying pointers/memory/assembly to give a concrete understanding of how they compare.&lt;/p&gt;\n&lt;p&gt;I believe that this will give a good intuition on how those casts are different:&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;p&gt;&lt;code&gt;static_cast&lt;/code&gt;: does one address offset at runtime (low runtime impact) and no safety checks that a downcast is correct.&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;p&gt;&lt;code&gt;dyanamic_cast&lt;/code&gt;: does the same address offset at runtime like &lt;code&gt;static_cast&lt;/code&gt;, but also and an expensive safety check that a downcast is correct using RTTI.&lt;/p&gt;\n&lt;p&gt;This safety check allows you to query if a base class pointer is of a given type at runtime by checking a return of &lt;code&gt;nullptr&lt;/code&gt; which indicates an invalid downcast.&lt;/p&gt;\n&lt;p&gt;Therefore, if your code is not able to check for that &lt;code&gt;nullptr&lt;/code&gt; and take a valid non-abort action, you should just use &lt;code&gt;static_cast&lt;/code&gt; instead of dynamic cast.&lt;/p&gt;\n&lt;p&gt;If an abort is the only action your code can take, maybe you only want to enable the &lt;code&gt;dynamic_cast&lt;/code&gt; in debug builds (&lt;code&gt;-NDEBUG&lt;/code&gt;), and use &lt;code&gt;static_cast&lt;/code&gt; otherwise, e.g. &lt;a href=&quot;https://github.com/gem5/gem5/blob/9fc9c67b4242c03f165951775be5cd0812f2a705/src/base/cast.hh#L40&quot; rel=&quot;noreferrer&quot;&gt;as done here&lt;/a&gt;, to not slow down your fast runs.&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;p&gt;&lt;code&gt;reinterpret_cast&lt;/code&gt;: does nothing at runtime, not even the address offset. The pointer must point exactly to the correct type, not even a base class works. You generally don&apos;t want this unless raw byte streams are involved.&lt;/p&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;Consider the following code example:&lt;/p&gt;\n&lt;p&gt;main.cpp&lt;/p&gt;\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;/span&gt;\n\n&lt;span class=&quot;hljs-keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;B1&lt;/span&gt; {\n    &lt;span class=&quot;hljs-built_in&quot;&gt;B1&lt;/span&gt;(&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; int_in_b1) : &lt;span class=&quot;hljs-built_in&quot;&gt;int_in_b1&lt;/span&gt;(int_in_b1) {}\n    &lt;span class=&quot;hljs-keyword&quot;&gt;virtual&lt;/span&gt; ~&lt;span class=&quot;hljs-built_in&quot;&gt;B1&lt;/span&gt;() {}\n    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;f0&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;{}\n    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;virtual&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;f1&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;{ &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;; }\n    &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; int_in_b1;\n};\n\n&lt;span class=&quot;hljs-keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;B2&lt;/span&gt; {\n    &lt;span class=&quot;hljs-built_in&quot;&gt;B2&lt;/span&gt;(&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; int_in_b2) : &lt;span class=&quot;hljs-built_in&quot;&gt;int_in_b2&lt;/span&gt;(int_in_b2) {}\n    &lt;span class=&quot;hljs-keyword&quot;&gt;virtual&lt;/span&gt; ~&lt;span class=&quot;hljs-built_in&quot;&gt;B2&lt;/span&gt;() {}\n    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;virtual&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;f2&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;{ &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;; }\n    &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; int_in_b2;\n};\n\n&lt;span class=&quot;hljs-keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;D&lt;/span&gt; : &lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; B1, &lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; B2 {\n    &lt;span class=&quot;hljs-built_in&quot;&gt;D&lt;/span&gt;(&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; int_in_b1, &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; int_in_b2, &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; int_in_d)\n        : &lt;span class=&quot;hljs-built_in&quot;&gt;B1&lt;/span&gt;(int_in_b1), &lt;span class=&quot;hljs-built_in&quot;&gt;B2&lt;/span&gt;(int_in_b2), &lt;span class=&quot;hljs-built_in&quot;&gt;int_in_d&lt;/span&gt;(int_in_d) {}\n    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;d&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;{}\n    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;f2&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;{ &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;; }\n    &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; int_in_d;\n};\n\n&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;{\n    B2 *b2s[&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;];\n    B2 b2{&lt;span class=&quot;hljs-number&quot;&gt;11&lt;/span&gt;};\n    D *dp;\n    D d{&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;};\n\n    &lt;span class=&quot;hljs-comment&quot;&gt;// The memory layout must support the virtual method call use case.&lt;/span&gt;\n    b2s[&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;] = &amp;amp;b2;\n    &lt;span class=&quot;hljs-comment&quot;&gt;// An upcast is an implicit static_cast&amp;lt;&amp;gt;().&lt;/span&gt;\n    b2s[&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;] = &amp;amp;d;\n    std::cout &amp;lt;&amp;lt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;&amp;amp;d           &quot;&lt;/span&gt; &amp;lt;&amp;lt; &amp;amp;d           &amp;lt;&amp;lt; std::endl;\n    std::cout &amp;lt;&amp;lt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;b2s[0]       &quot;&lt;/span&gt; &amp;lt;&amp;lt; b2s[&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;]       &amp;lt;&amp;lt; std::endl;\n    std::cout &amp;lt;&amp;lt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;b2s[1]       &quot;&lt;/span&gt; &amp;lt;&amp;lt; b2s[&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;]       &amp;lt;&amp;lt; std::endl;\n    std::cout &amp;lt;&amp;lt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;b2s[0]-&amp;gt;f2() &quot;&lt;/span&gt; &amp;lt;&amp;lt; b2s[&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;]-&amp;gt;&lt;span class=&quot;hljs-built_in&quot;&gt;f2&lt;/span&gt;() &amp;lt;&amp;lt; std::endl;\n    std::cout &amp;lt;&amp;lt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;b2s[1]-&amp;gt;f2() &quot;&lt;/span&gt; &amp;lt;&amp;lt; b2s[&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;]-&amp;gt;&lt;span class=&quot;hljs-built_in&quot;&gt;f2&lt;/span&gt;() &amp;lt;&amp;lt; std::endl;\n\n    &lt;span class=&quot;hljs-comment&quot;&gt;// Now for some downcasts.&lt;/span&gt;\n\n    &lt;span class=&quot;hljs-comment&quot;&gt;// Cannot be done implicitly&lt;/span&gt;\n    &lt;span class=&quot;hljs-comment&quot;&gt;// error: invalid conversion from B2* to D* [-fpermissive]&lt;/span&gt;\n    &lt;span class=&quot;hljs-comment&quot;&gt;// dp = (b2s[0]);&lt;/span&gt;\n\n    &lt;span class=&quot;hljs-comment&quot;&gt;// Undefined behaviour to an unrelated memory address because this is a B2, not D.&lt;/span&gt;\n    dp = &lt;span class=&quot;hljs-built_in&quot;&gt;static_cast&lt;/span&gt;&amp;lt;D*&amp;gt;(b2s[&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;]);\n    std::cout &amp;lt;&amp;lt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;static_cast&amp;lt;D*&amp;gt;(b2s[0])            &quot;&lt;/span&gt; &amp;lt;&amp;lt; dp           &amp;lt;&amp;lt; std::endl;\n    std::cout &amp;lt;&amp;lt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;static_cast&amp;lt;D*&amp;gt;(b2s[0])-&amp;gt;int_in_d  &quot;&lt;/span&gt; &amp;lt;&amp;lt; dp-&amp;gt;int_in_d &amp;lt;&amp;lt; std::endl;\n\n    &lt;span class=&quot;hljs-comment&quot;&gt;// OK&lt;/span&gt;\n    dp = &lt;span class=&quot;hljs-built_in&quot;&gt;static_cast&lt;/span&gt;&amp;lt;D*&amp;gt;(b2s[&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;]);\n    std::cout &amp;lt;&amp;lt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;static_cast&amp;lt;D*&amp;gt;(b2s[1])            &quot;&lt;/span&gt; &amp;lt;&amp;lt; dp           &amp;lt;&amp;lt; std::endl;\n    std::cout &amp;lt;&amp;lt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;static_cast&amp;lt;D*&amp;gt;(b2s[1])-&amp;gt;int_in_d  &quot;&lt;/span&gt; &amp;lt;&amp;lt; dp-&amp;gt;int_in_d &amp;lt;&amp;lt; std::endl;\n\n    &lt;span class=&quot;hljs-comment&quot;&gt;// Segfault because dp is nullptr.&lt;/span&gt;\n    dp = &lt;span class=&quot;hljs-built_in&quot;&gt;dynamic_cast&lt;/span&gt;&amp;lt;D*&amp;gt;(b2s[&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;]);\n    std::cout &amp;lt;&amp;lt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;dynamic_cast&amp;lt;D*&amp;gt;(b2s[0])           &quot;&lt;/span&gt; &amp;lt;&amp;lt; dp           &amp;lt;&amp;lt; std::endl;\n    &lt;span class=&quot;hljs-comment&quot;&gt;//std::cout &amp;lt;&amp;lt; &quot;dynamic_cast&amp;lt;D*&amp;gt;(b2s[0])-&amp;gt;int_in_d &quot; &amp;lt;&amp;lt; dp-&amp;gt;int_in_d &amp;lt;&amp;lt; std::endl;&lt;/span&gt;\n\n    &lt;span class=&quot;hljs-comment&quot;&gt;// OK&lt;/span&gt;\n    dp = &lt;span class=&quot;hljs-built_in&quot;&gt;dynamic_cast&lt;/span&gt;&amp;lt;D*&amp;gt;(b2s[&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;]);\n    std::cout &amp;lt;&amp;lt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;dynamic_cast&amp;lt;D*&amp;gt;(b2s[1])           &quot;&lt;/span&gt; &amp;lt;&amp;lt; dp           &amp;lt;&amp;lt; std::endl;\n    std::cout &amp;lt;&amp;lt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;dynamic_cast&amp;lt;D*&amp;gt;(b2s[1])-&amp;gt;int_in_d &quot;&lt;/span&gt; &amp;lt;&amp;lt; dp-&amp;gt;int_in_d &amp;lt;&amp;lt; std::endl;\n\n    &lt;span class=&quot;hljs-comment&quot;&gt;// Undefined behaviour to an unrelated memory address because this&lt;/span&gt;\n    &lt;span class=&quot;hljs-comment&quot;&gt;// did not calculate the offset to get from B2* to D*.&lt;/span&gt;\n    dp = &lt;span class=&quot;hljs-built_in&quot;&gt;reinterpret_cast&lt;/span&gt;&amp;lt;D*&amp;gt;(b2s[&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;]);\n    std::cout &amp;lt;&amp;lt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;reinterpret_cast&amp;lt;D*&amp;gt;(b2s[1])           &quot;&lt;/span&gt; &amp;lt;&amp;lt; dp           &amp;lt;&amp;lt; std::endl;\n    std::cout &amp;lt;&amp;lt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;reinterpret_cast&amp;lt;D*&amp;gt;(b2s[1])-&amp;gt;int_in_d &quot;&lt;/span&gt; &amp;lt;&amp;lt; dp-&amp;gt;int_in_d &amp;lt;&amp;lt; std::endl;\n}\n\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;Compile, run and disassemble with:&lt;/p&gt;\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;g++ -ggdb3 -O0 -std=c++&lt;span class=&quot;hljs-number&quot;&gt;11&lt;/span&gt; -Wall -Wextra -pedantic -o main.out main.cpp\nsetarch `uname -m` -R ./main.out\ngdb -batch -ex &lt;span class=&quot;hljs-string&quot;&gt;&quot;disassemble/rs main&quot;&lt;/span&gt; main.out\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;where &lt;code&gt;setarch&lt;/code&gt; is &lt;a href=&quot;https://stackoverflow.com/questions/11238457/disable-and-re-enable-address-space-layout-randomization-only-for-myself&quot;&gt;used to disable ASLR&lt;/a&gt; to make it easier to compare runs.&lt;/p&gt;\n&lt;p&gt;Possible output:&lt;/p&gt;\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&amp;amp;d           &lt;span class=&quot;hljs-number&quot;&gt;0x7fffffffc930&lt;/span&gt;\nb2s[&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;]       &lt;span class=&quot;hljs-number&quot;&gt;0x7fffffffc920&lt;/span&gt;\nb2s[&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;]       &lt;span class=&quot;hljs-number&quot;&gt;0x7fffffffc940&lt;/span&gt;\nb2s[&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;]-&amp;gt;&lt;span class=&quot;hljs-built_in&quot;&gt;f2&lt;/span&gt;() &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;\nb2s[&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;]-&amp;gt;&lt;span class=&quot;hljs-built_in&quot;&gt;f2&lt;/span&gt;() &lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;\n&lt;span class=&quot;hljs-built_in&quot;&gt;static_cast&lt;/span&gt;&amp;lt;D*&amp;gt;(b2s[&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;])            &lt;span class=&quot;hljs-number&quot;&gt;0x7fffffffc910&lt;/span&gt;\n&lt;span class=&quot;hljs-built_in&quot;&gt;static_cast&lt;/span&gt;&amp;lt;D*&amp;gt;(b2s[&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;])-&amp;gt;int_in_d  &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;\n&lt;span class=&quot;hljs-built_in&quot;&gt;static_cast&lt;/span&gt;&amp;lt;D*&amp;gt;(b2s[&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;])            &lt;span class=&quot;hljs-number&quot;&gt;0x7fffffffc930&lt;/span&gt;\n&lt;span class=&quot;hljs-built_in&quot;&gt;static_cast&lt;/span&gt;&amp;lt;D*&amp;gt;(b2s[&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;])-&amp;gt;int_in_d  &lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;\n&lt;span class=&quot;hljs-built_in&quot;&gt;dynamic_cast&lt;/span&gt;&amp;lt;D*&amp;gt;(b2s[&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;])           &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;\n&lt;span class=&quot;hljs-built_in&quot;&gt;dynamic_cast&lt;/span&gt;&amp;lt;D*&amp;gt;(b2s[&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;])           &lt;span class=&quot;hljs-number&quot;&gt;0x7fffffffc930&lt;/span&gt;\n&lt;span class=&quot;hljs-built_in&quot;&gt;dynamic_cast&lt;/span&gt;&amp;lt;D*&amp;gt;(b2s[&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;])-&amp;gt;int_in_d &lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;\n&lt;span class=&quot;hljs-built_in&quot;&gt;reinterpret_cast&lt;/span&gt;&amp;lt;D*&amp;gt;(b2s[&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;])           &lt;span class=&quot;hljs-number&quot;&gt;0x7fffffffc940&lt;/span&gt;\n&lt;span class=&quot;hljs-built_in&quot;&gt;reinterpret_cast&lt;/span&gt;&amp;lt;D*&amp;gt;(b2s[&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;])-&amp;gt;int_in_d &lt;span class=&quot;hljs-number&quot;&gt;32767&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;Now, as mentioned at: &lt;a href=&quot;https://en.wikipedia.org/wiki/Virtual_method_table&quot; rel=&quot;noreferrer&quot;&gt;https://en.wikipedia.org/wiki/Virtual_method_table&lt;/a&gt; in order to support the virtual method calls efficiently, supposing that the memory data structures of B1 is of form:&lt;/p&gt;\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;B1:\n  +&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;: pointer to &lt;span class=&quot;hljs-keyword&quot;&gt;virtual&lt;/span&gt; method table of B1\n  +&lt;span class=&quot;hljs-number&quot;&gt;4&lt;/span&gt;: value of int_in_b1\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;and &lt;code&gt;B2&lt;/code&gt; is of form:&lt;/p&gt;\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;B2:\n  +&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;: pointer to &lt;span class=&quot;hljs-keyword&quot;&gt;virtual&lt;/span&gt; method table of B2\n  +&lt;span class=&quot;hljs-number&quot;&gt;4&lt;/span&gt;: value of int_in_b2\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;then memory data structure of &lt;code&gt;D&lt;/code&gt; has to look something like:&lt;/p&gt;\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;D:\n  +&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;: &lt;span class=&quot;hljs-function&quot;&gt;pointer to &lt;span class=&quot;hljs-keyword&quot;&gt;virtual&lt;/span&gt; method table of &lt;span class=&quot;hljs-title&quot;&gt;D&lt;/span&gt; &lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; B1)&lt;/span&gt;\n  +4: value of int_in_b1\n  +&lt;span class=&quot;hljs-number&quot;&gt;8&lt;/span&gt;: pointer to virtual method table of D (for B2)\n +&lt;span class=&quot;hljs-number&quot;&gt;12&lt;/span&gt;: value of int_in_b2\n +&lt;span class=&quot;hljs-number&quot;&gt;16&lt;/span&gt;: value of int_in_d\n&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;The key fact is that the memory data structure of &lt;code&gt;D&lt;/code&gt; contains inside it memory structure identical to that of &lt;code&gt;B1&lt;/code&gt; and &lt;code&gt;B2&lt;/code&gt;, i.e.:&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;+0 looks exactly like a B1, with the B1 vtable for D followed by &lt;code&gt;int_in_b1&lt;/code&gt;&lt;/li&gt;\n&lt;li&gt;+8 looks exactly like a B2, with the B2 vtable for D followed by &lt;code&gt;int_in_b2&lt;/code&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;Therefore we reach the critical conclusion:&lt;/p&gt;\n&lt;blockquote&gt;\n&lt;p&gt;an upcast or downcast only needs to shift the pointer value by a value known at compile time&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;p&gt;This way, when &lt;code&gt;D&lt;/code&gt; gets passed to the base type array, the type cast actually calculates that offset and points something that looks exactly like a valid &lt;code&gt;B2&lt;/code&gt; in memory, except that this one has the vtable for &lt;code&gt;D&lt;/code&gt; instead of &lt;code&gt;B2&lt;/code&gt;, and therefore all virtual calls work transparently.&lt;/p&gt;\n&lt;p&gt;E.g.:&lt;/p&gt;\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;b2s[&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;] = &amp;amp;d;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;simply needs to get the address of &lt;code&gt;d&lt;/code&gt; + 8 to reach the corresponding B2-like data structure.&lt;/p&gt;\n&lt;p&gt;Now, we can finally get back to type casting and the analysis of our concrete example.&lt;/p&gt;\n&lt;p&gt;From the stdout output we see:&lt;/p&gt;\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&amp;amp;d           &lt;span class=&quot;hljs-number&quot;&gt;0x7fffffffc930&lt;/span&gt;\nb2s[&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;]       &lt;span class=&quot;hljs-number&quot;&gt;0x7fffffffc940&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;Therefore, the implicit &lt;code&gt;static_cast&lt;/code&gt; done there did correctly calculate the offset from the full &lt;code&gt;D&lt;/code&gt; data structure at 0x7fffffffc930 to the &lt;code&gt;B2&lt;/code&gt; like one which is at 0x7fffffffc940. We also infer that what lies between 0x7fffffffc930 and 0x7fffffffc940 is likely be the &lt;code&gt;B1&lt;/code&gt; data and vtable.&lt;/p&gt;\n&lt;p&gt;Then, on the downcast sections, it is now easy to understand how the invalid ones fail and why:&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;p&gt;&lt;code&gt;static_cast&amp;lt;D*&amp;gt;(b2s[0])            0x7fffffffc910&lt;/code&gt;: the compiler just went up 0x10 at compile time bytes to try and go from a &lt;code&gt;B2&lt;/code&gt; to the containing &lt;code&gt;D&lt;/code&gt;&lt;/p&gt;\n&lt;p&gt;But because &lt;code&gt;b2s[0]&lt;/code&gt; was not a &lt;code&gt;D&lt;/code&gt;, it now points to an undefined memory region.&lt;/p&gt;\n&lt;p&gt;The disassembly is:&lt;/p&gt;\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-number&quot;&gt;49&lt;/span&gt;          dp = &lt;span class=&quot;hljs-built_in&quot;&gt;static_cast&lt;/span&gt;&amp;lt;D*&amp;gt;(b2s[&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;]);\n   &lt;span class=&quot;hljs-number&quot;&gt;0x0000000000000fc8&lt;/span&gt; &amp;lt;+&lt;span class=&quot;hljs-number&quot;&gt;414&lt;/span&gt;&amp;gt;:   &lt;span class=&quot;hljs-number&quot;&gt;48&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;8b&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;45&lt;/span&gt; d0     mov    &lt;span class=&quot;hljs-number&quot;&gt;-0x30&lt;/span&gt;(%rbp),%rax\n   &lt;span class=&quot;hljs-number&quot;&gt;0x0000000000000fcc&lt;/span&gt; &amp;lt;+&lt;span class=&quot;hljs-number&quot;&gt;418&lt;/span&gt;&amp;gt;:   &lt;span class=&quot;hljs-number&quot;&gt;48&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;85&lt;/span&gt; c0        test   %rax,%rax\n   &lt;span class=&quot;hljs-number&quot;&gt;0x0000000000000fcf&lt;/span&gt; &amp;lt;+&lt;span class=&quot;hljs-number&quot;&gt;421&lt;/span&gt;&amp;gt;:   &lt;span class=&quot;hljs-number&quot;&gt;74&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;a   je     &lt;span class=&quot;hljs-number&quot;&gt;0xfdb&lt;/span&gt; &amp;lt;&lt;span class=&quot;hljs-built_in&quot;&gt;main&lt;/span&gt;()+&lt;span class=&quot;hljs-number&quot;&gt;433&lt;/span&gt;&amp;gt;\n   &lt;span class=&quot;hljs-number&quot;&gt;0x0000000000000fd1&lt;/span&gt; &amp;lt;+&lt;span class=&quot;hljs-number&quot;&gt;423&lt;/span&gt;&amp;gt;:   &lt;span class=&quot;hljs-number&quot;&gt;48&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;8b&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;45&lt;/span&gt; d0     mov    &lt;span class=&quot;hljs-number&quot;&gt;-0x30&lt;/span&gt;(%rbp),%rax\n   &lt;span class=&quot;hljs-number&quot;&gt;0x0000000000000fd5&lt;/span&gt; &amp;lt;+&lt;span class=&quot;hljs-number&quot;&gt;427&lt;/span&gt;&amp;gt;:   &lt;span class=&quot;hljs-number&quot;&gt;48&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;83&lt;/span&gt; e8 &lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;     sub    $&lt;span class=&quot;hljs-number&quot;&gt;0x10&lt;/span&gt;,%rax\n   &lt;span class=&quot;hljs-number&quot;&gt;0x0000000000000fd9&lt;/span&gt; &amp;lt;+&lt;span class=&quot;hljs-number&quot;&gt;431&lt;/span&gt;&amp;gt;:   eb &lt;span class=&quot;hljs-number&quot;&gt;05&lt;/span&gt;   jmp    &lt;span class=&quot;hljs-number&quot;&gt;0xfe0&lt;/span&gt; &amp;lt;&lt;span class=&quot;hljs-built_in&quot;&gt;main&lt;/span&gt;()+&lt;span class=&quot;hljs-number&quot;&gt;438&lt;/span&gt;&amp;gt;\n   &lt;span class=&quot;hljs-number&quot;&gt;0x0000000000000fdb&lt;/span&gt; &amp;lt;+&lt;span class=&quot;hljs-number&quot;&gt;433&lt;/span&gt;&amp;gt;:   b8 &lt;span class=&quot;hljs-number&quot;&gt;00&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;00&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;00&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;00&lt;/span&gt;  mov    $&lt;span class=&quot;hljs-number&quot;&gt;0x0&lt;/span&gt;,%eax\n   &lt;span class=&quot;hljs-number&quot;&gt;0x0000000000000fe0&lt;/span&gt; &amp;lt;+&lt;span class=&quot;hljs-number&quot;&gt;438&lt;/span&gt;&amp;gt;:   &lt;span class=&quot;hljs-number&quot;&gt;48&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;89&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;45&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;98&lt;/span&gt;     mov    %rax,&lt;span class=&quot;hljs-number&quot;&gt;-0x68&lt;/span&gt;(%rbp)\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;so we see that GCC does:&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;check if pointer is NULL, and if yes return NULL&lt;/li&gt;\n&lt;li&gt;otherwise, subtract 0x10 from it to reach the &lt;code&gt;D&lt;/code&gt; which does not exist&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;p&gt;&lt;code&gt;dynamic_cast&amp;lt;D*&amp;gt;(b2s[0])           0&lt;/code&gt;: C++ actually found that the cast was invalid and returned &lt;code&gt;nullptr&lt;/code&gt;!&lt;/p&gt;\n&lt;p&gt;There is no way this can be done at compile time, and we will confirm that from the disassembly:&lt;/p&gt;\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-number&quot;&gt;59&lt;/span&gt;          dp = &lt;span class=&quot;hljs-built_in&quot;&gt;dynamic_cast&lt;/span&gt;&amp;lt;D*&amp;gt;(b2s[&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;]);\n   &lt;span class=&quot;hljs-number&quot;&gt;0x00000000000010ec&lt;/span&gt; &amp;lt;+&lt;span class=&quot;hljs-number&quot;&gt;706&lt;/span&gt;&amp;gt;:   &lt;span class=&quot;hljs-number&quot;&gt;48&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;8b&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;45&lt;/span&gt; d0     mov    &lt;span class=&quot;hljs-number&quot;&gt;-0x30&lt;/span&gt;(%rbp),%rax\n   &lt;span class=&quot;hljs-number&quot;&gt;0x00000000000010f0&lt;/span&gt; &amp;lt;+&lt;span class=&quot;hljs-number&quot;&gt;710&lt;/span&gt;&amp;gt;:   &lt;span class=&quot;hljs-number&quot;&gt;48&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;85&lt;/span&gt; c0        test   %rax,%rax\n   &lt;span class=&quot;hljs-number&quot;&gt;0x00000000000010f3&lt;/span&gt; &amp;lt;+&lt;span class=&quot;hljs-number&quot;&gt;713&lt;/span&gt;&amp;gt;:   &lt;span class=&quot;hljs-number&quot;&gt;74&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;d   je     &lt;span class=&quot;hljs-number&quot;&gt;0x1112&lt;/span&gt; &amp;lt;&lt;span class=&quot;hljs-built_in&quot;&gt;main&lt;/span&gt;()+&lt;span class=&quot;hljs-number&quot;&gt;744&lt;/span&gt;&amp;gt;\n   &lt;span class=&quot;hljs-number&quot;&gt;0x00000000000010f5&lt;/span&gt; &amp;lt;+&lt;span class=&quot;hljs-number&quot;&gt;715&lt;/span&gt;&amp;gt;:   b9 &lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;00&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;00&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;00&lt;/span&gt;  mov    $&lt;span class=&quot;hljs-number&quot;&gt;0x10&lt;/span&gt;,%ecx\n   &lt;span class=&quot;hljs-number&quot;&gt;0x00000000000010fa&lt;/span&gt; &amp;lt;+&lt;span class=&quot;hljs-number&quot;&gt;720&lt;/span&gt;&amp;gt;:   &lt;span class=&quot;hljs-number&quot;&gt;48&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;8&lt;/span&gt;d &lt;span class=&quot;hljs-number&quot;&gt;15&lt;/span&gt; f7 &lt;span class=&quot;hljs-number&quot;&gt;0b&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;20&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;00&lt;/span&gt;    lea    &lt;span class=&quot;hljs-number&quot;&gt;0x200bf7&lt;/span&gt;(%rip),%rdx        # &lt;span class=&quot;hljs-number&quot;&gt;0x201cf8&lt;/span&gt; &amp;lt;_ZTI1D&amp;gt;\n   &lt;span class=&quot;hljs-number&quot;&gt;0x0000000000001101&lt;/span&gt; &amp;lt;+&lt;span class=&quot;hljs-number&quot;&gt;727&lt;/span&gt;&amp;gt;:   &lt;span class=&quot;hljs-number&quot;&gt;48&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;8&lt;/span&gt;d &lt;span class=&quot;hljs-number&quot;&gt;35&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;28&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;c &lt;span class=&quot;hljs-number&quot;&gt;20&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;00&lt;/span&gt;    lea    &lt;span class=&quot;hljs-number&quot;&gt;0x200c28&lt;/span&gt;(%rip),%rsi        # &lt;span class=&quot;hljs-number&quot;&gt;0x201d30&lt;/span&gt; &amp;lt;_ZTI2B2&amp;gt;\n   &lt;span class=&quot;hljs-number&quot;&gt;0x0000000000001108&lt;/span&gt; &amp;lt;+&lt;span class=&quot;hljs-number&quot;&gt;734&lt;/span&gt;&amp;gt;:   &lt;span class=&quot;hljs-number&quot;&gt;48&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;89&lt;/span&gt; c7        mov    %rax,%rdi\n   &lt;span class=&quot;hljs-number&quot;&gt;0x000000000000110b&lt;/span&gt; &amp;lt;+&lt;span class=&quot;hljs-number&quot;&gt;737&lt;/span&gt;&amp;gt;:   e8 c0 fb ff ff  callq  &lt;span class=&quot;hljs-number&quot;&gt;0xcd0&lt;/span&gt; &amp;lt;__dynamic_cast@plt&amp;gt;\n   &lt;span class=&quot;hljs-number&quot;&gt;0x0000000000001110&lt;/span&gt; &amp;lt;+&lt;span class=&quot;hljs-number&quot;&gt;742&lt;/span&gt;&amp;gt;:   eb &lt;span class=&quot;hljs-number&quot;&gt;05&lt;/span&gt;   jmp    &lt;span class=&quot;hljs-number&quot;&gt;0x1117&lt;/span&gt; &amp;lt;&lt;span class=&quot;hljs-built_in&quot;&gt;main&lt;/span&gt;()+&lt;span class=&quot;hljs-number&quot;&gt;749&lt;/span&gt;&amp;gt;\n   &lt;span class=&quot;hljs-number&quot;&gt;0x0000000000001112&lt;/span&gt; &amp;lt;+&lt;span class=&quot;hljs-number&quot;&gt;744&lt;/span&gt;&amp;gt;:   b8 &lt;span class=&quot;hljs-number&quot;&gt;00&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;00&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;00&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;00&lt;/span&gt;  mov    $&lt;span class=&quot;hljs-number&quot;&gt;0x0&lt;/span&gt;,%eax\n   &lt;span class=&quot;hljs-number&quot;&gt;0x0000000000001117&lt;/span&gt; &amp;lt;+&lt;span class=&quot;hljs-number&quot;&gt;749&lt;/span&gt;&amp;gt;:   &lt;span class=&quot;hljs-number&quot;&gt;48&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;89&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;45&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;98&lt;/span&gt;     mov    %rax,&lt;span class=&quot;hljs-number&quot;&gt;-0x68&lt;/span&gt;(%rbp)\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;First there is a NULL check, and it returns NULL if th einput is NULL.&lt;/p&gt;\n&lt;p&gt;Otherwise, it sets up some arguments in the RDX, RSI and RDI and calls &lt;code&gt;__dynamic_cast&lt;/code&gt;.&lt;/p&gt;\n&lt;p&gt;I don&apos;t have the patience to analyze this further now, but as others said, the only way for this to work is for &lt;code&gt;__dynamic_cast&lt;/code&gt; to access some extra RTTI in-memory data structures that represent the class hierarchy.&lt;/p&gt;\n&lt;p&gt;It must therefore start from the &lt;code&gt;B2&lt;/code&gt; entry for that table, then walk this class hierarchy until it finds that the vtable for a &lt;code&gt;D&lt;/code&gt; typecast from &lt;code&gt;b2s[0]&lt;/code&gt;.&lt;/p&gt;\n&lt;p&gt;This is why dynamic cast is potentially expensive! Here is &lt;a href=&quot;https://gem5-review.googlesource.com/c/public/gem5/+/25964&quot; rel=&quot;noreferrer&quot;&gt;an example where a one liner patch converting a &lt;code&gt;dynamic_cast&lt;/code&gt; to a &lt;code&gt;static_cast&lt;/code&gt; in a complex project reduced runtime by 33%!&lt;/a&gt;.&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;p&gt;&lt;code&gt;reinterpret_cast&amp;lt;D*&amp;gt;(b2s[1])           0x7fffffffc940&lt;/code&gt; this one just believes us blindly: we said there is a &lt;code&gt;D&lt;/code&gt; at address &lt;code&gt;b2s[1]&lt;/code&gt;, and the compiler does no offset calculations.&lt;/p&gt;\n&lt;p&gt;But this is wrong, because D is actually at 0x7fffffffc930, what is at 0x7fffffffc940 is the B2-like structure inside D! So trash gets accessed.&lt;/p&gt;\n&lt;p&gt;We can confirm this from the horrendous &lt;code&gt;-O0&lt;/code&gt; assembly that just moves the value around:&lt;/p&gt;\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-number&quot;&gt;70&lt;/span&gt;          dp = &lt;span class=&quot;hljs-built_in&quot;&gt;reinterpret_cast&lt;/span&gt;&amp;lt;D*&amp;gt;(b2s[&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;]);\n   &lt;span class=&quot;hljs-number&quot;&gt;0x00000000000011fa&lt;/span&gt; &amp;lt;+&lt;span class=&quot;hljs-number&quot;&gt;976&lt;/span&gt;&amp;gt;:   &lt;span class=&quot;hljs-number&quot;&gt;48&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;8b&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;45&lt;/span&gt; d8     mov    &lt;span class=&quot;hljs-number&quot;&gt;-0x28&lt;/span&gt;(%rbp),%rax\n   &lt;span class=&quot;hljs-number&quot;&gt;0x00000000000011fe&lt;/span&gt; &amp;lt;+&lt;span class=&quot;hljs-number&quot;&gt;980&lt;/span&gt;&amp;gt;:   &lt;span class=&quot;hljs-number&quot;&gt;48&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;89&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;45&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;98&lt;/span&gt;     mov    %rax,&lt;span class=&quot;hljs-number&quot;&gt;-0x68&lt;/span&gt;(%rbp)\n&lt;/code&gt;&lt;/pre&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;Related questions:&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=&quot;https://stackoverflow.com/questions/332030/when-should-static-cast-dynamic-cast-const-cast-and-reinterpret-cast-be-used&quot;&gt;When should static_cast, dynamic_cast, const_cast and reinterpret_cast be used?&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=&quot;https://stackoverflow.com/questions/18359780/how-is-dynamic-cast-implemented&quot;&gt;How is dynamic_cast implemented&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=&quot;https://stackoverflow.com/questions/6322949/downcasting-using-the-static-cast-in-c&quot;&gt;Downcasting using the &apos;static_cast&apos; in C++&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;Tested on Ubuntu 18.04 amd64, GCC 7.4.0.&lt;/p&gt;\n    ","\n&lt;p&gt;While other answers nicely described all differences between C++ casts, I would like to add a short note why you should not use C-style casts &lt;code&gt;(Type) var&lt;/code&gt; and &lt;code&gt;Type(var)&lt;/code&gt;.&lt;/p&gt;\n\n&lt;p&gt;For C++ beginners C-style casts look like being the superset operation over C++ casts (static_cast&amp;lt;&amp;gt;(), dynamic_cast&amp;lt;&amp;gt;(), const_cast&amp;lt;&amp;gt;(), reinterpret_cast&amp;lt;&amp;gt;()) and someone could prefer them over the C++ casts. In fact C-style cast is the superset and shorter to write.&lt;/p&gt;\n\n&lt;p&gt;The main problem of C-style casts is that they hide developer real intention of the cast. The C-style casts can do virtually all types of casting from normally safe casts done by static_cast&amp;lt;&amp;gt;() and dynamic_cast&amp;lt;&amp;gt;() to potentially dangerous casts like const_cast&amp;lt;&amp;gt;(), where const modifier can be removed so the const variables can be modified and reinterpret_cast&amp;lt;&amp;gt;() that can even reinterpret integer values to pointers.&lt;/p&gt;\n\n&lt;p&gt;Here is the sample.&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; a=&lt;span class=&quot;hljs-built_in&quot;&gt;rand&lt;/span&gt;(); &lt;span class=&quot;hljs-comment&quot;&gt;// Random number.&lt;/span&gt;\n\n&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt;* pa1=&lt;span class=&quot;hljs-built_in&quot;&gt;reinterpret_cast&lt;/span&gt;&amp;lt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt;*&amp;gt;(a); &lt;span class=&quot;hljs-comment&quot;&gt;// OK. Here developer clearly expressed he wanted to do this potentially dangerous operation.&lt;/span&gt;\n\n&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt;* pa2=&lt;span class=&quot;hljs-built_in&quot;&gt;static_cast&lt;/span&gt;&amp;lt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt;*&amp;gt;(a); &lt;span class=&quot;hljs-comment&quot;&gt;// Compiler error.&lt;/span&gt;\n&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt;* pa3=&lt;span class=&quot;hljs-built_in&quot;&gt;dynamic_cast&lt;/span&gt;&amp;lt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt;*&amp;gt;(a); &lt;span class=&quot;hljs-comment&quot;&gt;// Compiler error.&lt;/span&gt;\n\n&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt;* pa4=(&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt;*) a; &lt;span class=&quot;hljs-comment&quot;&gt;// OK. C-style cast can do such cast. The question is if it was intentional or developer just did some typo.&lt;/span&gt;\n\n*pa4=&lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt;; &lt;span class=&quot;hljs-comment&quot;&gt;// Program crashes.&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;The main reason why C++ casts were added to the language was to allow a developer to clarify his intentions - why he is going to do that cast. By using C-style casts which are perfectly valid in C++ you are making your code less readable and more error prone especially for other developers who didn&apos;t create your code. So to make your code more readable and explicit you should always prefer C++ casts over C-style casts.&lt;/p&gt;\n\n&lt;p&gt;Here is a short quote from Bjarne Stroustrup&apos;s (the author of C++) book The C++ Programming Language 4th edition - page 302.&lt;/p&gt;\n\n&lt;blockquote&gt;\n  &lt;p&gt;This C-style cast is far more dangerous than the named conversion operators\n  because the notation is harder to spot in a large program and the kind of conversion intended by the programmer is not explicit.&lt;/p&gt;\n&lt;/blockquote&gt;\n    ","\n&lt;p&gt;To understand, let&apos;s consider below code snippet:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;Foo&lt;/span&gt;{};\n&lt;span class=&quot;hljs-keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;Bar&lt;/span&gt;{};\n\n&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; argc, &lt;span class=&quot;hljs-type&quot;&gt;char&lt;/span&gt;** argv)&lt;/span&gt;\n&lt;/span&gt;{\n    Foo* f = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; Foo;\n\n    Bar* b1 = f;                              &lt;span class=&quot;hljs-comment&quot;&gt;// (1)&lt;/span&gt;\n    Bar* b2 = &lt;span class=&quot;hljs-built_in&quot;&gt;static_cast&lt;/span&gt;&amp;lt;Bar*&amp;gt;(f);           &lt;span class=&quot;hljs-comment&quot;&gt;// (2)&lt;/span&gt;\n    Bar* b3 = &lt;span class=&quot;hljs-built_in&quot;&gt;dynamic_cast&lt;/span&gt;&amp;lt;Bar*&amp;gt;(f);          &lt;span class=&quot;hljs-comment&quot;&gt;// (3)&lt;/span&gt;\n    Bar* b4 = &lt;span class=&quot;hljs-built_in&quot;&gt;reinterpret_cast&lt;/span&gt;&amp;lt;Bar*&amp;gt;(f);      &lt;span class=&quot;hljs-comment&quot;&gt;// (4)&lt;/span&gt;\n    Bar* b5 = &lt;span class=&quot;hljs-built_in&quot;&gt;const_cast&lt;/span&gt;&amp;lt;Bar*&amp;gt;(f);            &lt;span class=&quot;hljs-comment&quot;&gt;// (5)&lt;/span&gt;\n\n    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;;\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Only line (4) compiles without error. Only &lt;strong&gt;reinterpret_cast&lt;/strong&gt; can be used to convert a pointer to an object to a pointer to an any unrelated object type.&lt;/p&gt;\n\n&lt;p&gt;One this to be noted is: The &lt;strong&gt;dynamic_cast&lt;/strong&gt; would fail at run-time, however on most compilers it will also fail to compile because there are no virtual functions in the struct of the pointer being casted, meaning &lt;strong&gt;dynamic_cast&lt;/strong&gt; will work with only polymorphic class pointers.&lt;/p&gt;\n\n&lt;p&gt;&lt;strong&gt;When to use C++ cast&lt;/strong&gt;:&lt;/p&gt;\n\n&lt;ul&gt;\n&lt;li&gt;Use &lt;strong&gt;static_cast&lt;/strong&gt; as the equivalent of a C-style cast that does value conversion, or when we need to explicitly up-cast a pointer from a class to its superclass.&lt;/li&gt;\n&lt;li&gt;Use &lt;strong&gt;const_cast&lt;/strong&gt; to remove the const qualifier.  &lt;/li&gt;\n&lt;li&gt;Use &lt;strong&gt;reinterpret_cast&lt;/strong&gt; to do unsafe conversions of pointer types to and from integer and other pointer types. Use this only if we know what we are doing and we understand the aliasing issues.&lt;/li&gt;\n&lt;/ul&gt;\n    ","\n&lt;p&gt;Nice feature of &lt;code&gt;reinterpret_cast&lt;/code&gt;, not mentioned in the other answers, is that it allows us to create a sort of &lt;code&gt;void*&lt;/code&gt; pointer for function types. Normally, for object types one uses &lt;code&gt;static_cast&lt;/code&gt; to retrieve the original type of a pointer stored in &lt;code&gt;void*&lt;/code&gt;:&lt;/p&gt;\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;  &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;hljs-number&quot;&gt;13&lt;/span&gt;;\n  &lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt; *p = &amp;amp;i;\n  &lt;span class=&quot;hljs-keyword&quot;&gt;auto&lt;/span&gt; *pi = &lt;span class=&quot;hljs-built_in&quot;&gt;static_cast&lt;/span&gt;&amp;lt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt;*&amp;gt;(p);\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;For functions, we must use &lt;code&gt;reinterpret_cast&lt;/code&gt; twice:&lt;/p&gt;\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;include&lt;/span&gt;&lt;span class=&quot;hljs-string&quot;&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;/span&gt;\n\n&lt;span class=&quot;hljs-keyword&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;any_fcn_ptr_t&lt;/span&gt; = &lt;span class=&quot;hljs-built_in&quot;&gt;void&lt;/span&gt;(*)();\n\n\n&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; i)&lt;/span&gt;\n&lt;/span&gt;{\n   std::cout &amp;lt;&amp;lt; i &amp;lt;&amp;lt;std::endl;\n}\n\n&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt;\n&lt;/span&gt;{     \n  &lt;span class=&quot;hljs-comment&quot;&gt;//Create type-erased pointer to function:&lt;/span&gt;\n  &lt;span class=&quot;hljs-keyword&quot;&gt;auto&lt;/span&gt; any_ptr = &lt;span class=&quot;hljs-built_in&quot;&gt;reinterpret_cast&lt;/span&gt;&amp;lt;&lt;span class=&quot;hljs-type&quot;&gt;any_fcn_ptr_t&lt;/span&gt;&amp;gt;(&amp;amp;print);\n  \n  &lt;span class=&quot;hljs-comment&quot;&gt;//Retrieve the original pointer:&lt;/span&gt;\n  &lt;span class=&quot;hljs-keyword&quot;&gt;auto&lt;/span&gt; ptr = &lt;span class=&quot;hljs-built_in&quot;&gt;reinterpret_cast&lt;/span&gt;&amp;lt; &lt;span class=&quot;hljs-built_in&quot;&gt;void&lt;/span&gt;(*)(&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt;) &amp;gt;(any_ptr);\n  \n  &lt;span class=&quot;hljs-built_in&quot;&gt;ptr&lt;/span&gt;(&lt;span class=&quot;hljs-number&quot;&gt;7&lt;/span&gt;);\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;With &lt;code&gt;reinterpret_cast&lt;/code&gt; we can even get a similar sort-of-void* pointer for pointers to member functions.&lt;/p&gt;\n&lt;p&gt;As with plain &lt;code&gt;void*&lt;/code&gt; and &lt;code&gt;static_cast&lt;/code&gt;, C++ guarantees that &lt;code&gt;ptr&lt;/code&gt; points to &lt;code&gt;print&lt;/code&gt; function (as long as we pass the correct type to &lt;code&gt;reinterpret_cast&lt;/code&gt;).&lt;/p&gt;\n    "],"id":555,"title":"When should static_cast, dynamic_cast, const_cast, and reinterpret_cast be used?","content":"\n                \n&lt;p&gt;What are the proper uses of:&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=&quot;https://en.cppreference.com/w/cpp/language/static_cast&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;code&gt;static_cast&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=&quot;https://en.cppreference.com/w/cpp/language/dynamic_cast&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;code&gt;dynamic_cast&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=&quot;https://en.cppreference.com/w/cpp/language/const_cast&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;code&gt;const_cast&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=&quot;https://en.cppreference.com/w/cpp/language/reinterpret_cast&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;code&gt;reinterpret_cast&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=&quot;https://en.cppreference.com/w/cpp/language/explicit_cast&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;code&gt;(type)value&lt;/code&gt;&lt;/a&gt; (C-style cast)&lt;/li&gt;\n&lt;li&gt;&lt;a href=&quot;https://en.cppreference.com/w/cpp/language/explicit_cast&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;code&gt;type(value)&lt;/code&gt;&lt;/a&gt; (function-style cast)&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;How does one decide which to use in which specific cases?&lt;/p&gt;\n    ","slug":"when-should-static_cast-dynamic_cast-const_cast-and-reinterpret_cast-be-used-1657388406205","postType":"QUESTION","createdAt":"2022-07-09T17:40:06.000Z","updatedAt":"2022-07-09T17:40:06.000Z","tags":[],"relatedQuestions":[]},"randomQuestions":[{"title":"How to compare arrays in JavaScript?","slug":"how-to-compare-arrays-in-javascript-1657387352277"},{"title":"Big O, how do you calculate/approximate it?","slug":"big-o-how-do-you-calculateapproximate-it-1657387856392"},{"title":"What is a lambda expression in C++11?","slug":"what-is-a-lambda-expression-in-c++11-1657387999252"},{"title":"How to choose the right bean scope?","slug":"how-to-choose-the-right-bean-scope-1657387596513"},{"title":"How can I read inputs as numbers?","slug":"how-can-i-read-inputs-as-numbers-1657384503324"},{"title":"Should I avoid the use of set(Preferred|Maximum|Minimum)Size methods in Java Swing?","slug":"should-i-avoid-the-use-of-set(preferredormaximumorminimum)size-methods-in-java-swing-1657384628399"},{"title":"How do I return the response from an asynchronous call?","slug":"how-do-i-return-the-response-from-an-asynchronous-call-1657384208012"},{"title":"Reference — What does this symbol mean in PHP?","slug":"reference-what-does-this-symbol-mean-in-php-1657384561666"},{"title":"What is the meaning of single and double underscore before an object name?","slug":"what-is-the-meaning-of-single-and-double-underscore-before-an-object-name-1657387926929"},{"title":"String.equals versus == [duplicate]","slug":"string.equals-versus-duplicate-1657387599972"},{"title":"Reference - What does this regex mean?","slug":"reference-what-does-this-regex-mean-1657384291445"},{"title":"What is array to pointer decay?","slug":"what-is-array-to-pointer-decay-1657384709608"},{"title":"Providing white space in a Swing GUI","slug":"providing-white-space-in-a-swing-gui-1657384734588"},{"title":"Iterator invalidation rules for C++ containers","slug":"iterator-invalidation-rules-for-c++-containers-1657387561090"},{"title":"Returning data from async call in Swift function","slug":"returning-data-from-async-call-in-swift-function-1657387469218"},{"title":"How can I make an AJAX call without jQuery?","slug":"how-can-i-make-an-ajax-call-without-jquery-1657388448955"},{"title":"What happens if you use the 32-bit int 0x80 Linux ABI in 64-bit code?","slug":"what-happens-if-you-use-the-32-bit-int-0x80-linux-abi-in-64-bit-code-1657388560485"},{"title":"How to use java.util.Scanner to correctly read user input from System.in and act on it?","slug":"how-to-use-java.util.scanner-to-correctly-read-user-input-from-system.in-and-act-on-it-1657388546306"},{"title":"\"Cross origin requests are only supported for HTTP.\" error when loading a local file","slug":"\"cross-origin-requests-are-only-supported-for-http.\"-error-when-loading-a-local-file-1657387942403"},{"title":"What is the difference between JSON and Object Literal Notation?","slug":"what-is-the-difference-between-json-and-object-literal-notation-1657387515710"}]},"__N_SSG":true}