<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><meta name="twitter:card" content="summary_large_image"/><meta name="twitter:site" content="@solutionschecker.com"/><meta name="twitter:creator" content="@solutionschecker.com"/><meta property="og:url" content="https://solutionschecker.com"/><meta property="og:type" content="website"/><meta property="og:image" content="https://solutionschecker.com/solutions-checker-banner.png"/><meta property="og:image:alt" content="Find the solution to any question. We focus on finding the fastest possible solution for users. Main topics like coding, learning. - solutionschecker.com"/><link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png"/><link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png"/><link rel="manifest" href="/site.webmanifest"/><script type="application/ld+json">{"@context":"https://schema.org","@type":"Organization","logo":"/logo.svg","url":"https://solutionschecker.com"}</script><link name="keywords" content="import,relative-path,python-packaging,relative-import,solutions checker, solution checker, how to, solution for, check for solution, resolve question, what is, what solution for, find solution"/><script type="application/ld+json">{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"item":{"@id":"https://solutionschecker.com","name":"Home"}},{"@type":"ListItem","position":2,"item":{"@id":"https://solutionschecker.com/questions","name":"Questions"}},{"@type":"ListItem","position":3,"item":{"@id":"https://solutionschecker.com/questions/relative-imports-for-the-billionth-time-1657387756383","name":"Questions"}}]}</script><title>Relative imports for the billionth time | Solution Checker</title><meta name="robots" content="index,follow"/><meta name="description" content="I&#x27;ve been here:

http://www.python.org/dev/peps/pep-0328/
http://docs.python.org/2/tutorial/modules.html#packages
Python packages: relative imports
python relative import example code does not work
Relative imports in python 2.5
Relative imports in Python
Python: Disabling relative import

and plenty of URLs that I did not copy, some on SO, some on other sites, back when I thought I&#x27;d have the solution quickly.
The forever-recurring question is this: how do I solve this &quot;Attempted relative import in non-package&quot; message?
ImportError: attempted relative import with no known parent package

I built an exact replica of the package on pep-0328:
package/
    __init__.py
    subpackage1/
        __init__.py
        moduleX.py
        moduleY.py
    subpackage2/
        __init__.py
        moduleZ.py
    moduleA.py

The imports were done from the console.
I did make functions named spam and eggs in their appropriate modules.  Naturally, it didn&#x27;t work.  The answer is apparently in the 4th URL I listed, but it&#x27;s all alumni to me. There was this response on one of the URLs I visited:

Relative imports use a module&#x27;s name attribute to determine that module&#x27;s position in the package hierarchy. If the module&#x27;s name does not contain any package information (e.g. it is set to &#x27;main&#x27;) then relative imports are resolved as if the module were a top level module, regardless of where the module is actually located on the file system.

The above response looks promising, but it&#x27;s all hieroglyphs to me.  So my question, how do I make Python not return to me &quot;Attempted relative import in non-package&quot;? has an answer that involves -m, supposedly.
Can somebody please tell me why Python gives that error message, what it means by &quot;non-package&quot;, why and how do you define a &#x27;package&#x27;, and the precise answer put in terms easy enough for a kindergartener to understand.
    "/><meta property="og:title" content="Relative imports for the billionth time | Solution Checker"/><meta property="og:description" content="I&#x27;ve been here:

http://www.python.org/dev/peps/pep-0328/
http://docs.python.org/2/tutorial/modules.html#packages
Python packages: relative imports
python relative import example code does not work
Relative imports in python 2.5
Relative imports in Python
Python: Disabling relative import

and plenty of URLs that I did not copy, some on SO, some on other sites, back when I thought I&#x27;d have the solution quickly.
The forever-recurring question is this: how do I solve this &quot;Attempted relative import in non-package&quot; message?
ImportError: attempted relative import with no known parent package

I built an exact replica of the package on pep-0328:
package/
    __init__.py
    subpackage1/
        __init__.py
        moduleX.py
        moduleY.py
    subpackage2/
        __init__.py
        moduleZ.py
    moduleA.py

The imports were done from the console.
I did make functions named spam and eggs in their appropriate modules.  Naturally, it didn&#x27;t work.  The answer is apparently in the 4th URL I listed, but it&#x27;s all alumni to me. There was this response on one of the URLs I visited:

Relative imports use a module&#x27;s name attribute to determine that module&#x27;s position in the package hierarchy. If the module&#x27;s name does not contain any package information (e.g. it is set to &#x27;main&#x27;) then relative imports are resolved as if the module were a top level module, regardless of where the module is actually located on the file system.

The above response looks promising, but it&#x27;s all hieroglyphs to me.  So my question, how do I make Python not return to me &quot;Attempted relative import in non-package&quot;? has an answer that involves -m, supposedly.
Can somebody please tell me why Python gives that error message, what it means by &quot;non-package&quot;, why and how do you define a &#x27;package&#x27;, and the precise answer put in terms easy enough for a kindergartener to understand.
    "/><script type="application/ld+json">{"@context":"https://schema.org","@type":"QAPage","mainEntity":{"name":"Relative imports for the billionth time","text":"I&apos;ve been here:\n\nhttp://www.python.org/dev/peps/pep-0328/\nhttp://docs.python.org/2/tutorial/modules.html#packages\nPython packages: relative imports\npython relative import example code does not work\nRelative imports in python 2.5\nRelative imports in Python\nPython: Disabling relative import\n\nand plenty of URLs that I did not copy, some on SO, some on other sites, back when I thought I&apos;d have the solution quickly.\nThe forever-recurring question is this: how do I solve this &quot;Attempted relative import in non-package&quot; message?\nImportError: attempted relative import with no known parent package\n\nI built an exact replica of the package on pep-0328:\npackage/\n    __init__.py\n    subpackage1/\n        __init__.py\n        moduleX.py\n        moduleY.py\n    subpackage2/\n        __init__.py\n        moduleZ.py\n    moduleA.py\n\nThe imports were done from the console.\nI did make functions named spam and eggs in their appropriate modules.  Naturally, it didn&apos;t work.  The answer is apparently in the 4th URL I listed, but it&apos;s all alumni to me. There was this response on one of the URLs I visited:\n\nRelative imports use a module&apos;s name attribute to determine that module&apos;s position in the package hierarchy. If the module&apos;s name does not contain any package information (e.g. it is set to &apos;main&apos;) then relative imports are resolved as if the module were a top level module, regardless of where the module is actually located on the file system.\n\nThe above response looks promising, but it&apos;s all hieroglyphs to me.  So my question, how do I make Python not return to me &quot;Attempted relative import in non-package&quot;? has an answer that involves -m, supposedly.\nCan somebody please tell me why Python gives that error message, what it means by &quot;non-package&quot;, why and how do you define a &apos;package&apos;, and the precise answer put in terms easy enough for a kindergartener to understand.\n    ","answerCount":12,"upVoteCount":500,"suggestedAnswer":[{"text":"Script vs. Module\nHere&apos;s an explanation.  The short version is that there is a big difference between directly running a Python file, and importing that file from somewhere else.  Just knowing what directory a file is in does not determine what package Python thinks it is in.  That depends, additionally, on how you load the file into Python (by running or by importing).\nThere are two ways to load a Python file: as the top-level script, or as a\nmodule.  A file is loaded as the top-level script if you execute it directly, for instance by typing python myfile.py on the command line.  It is loaded as a module when an import statement is encountered inside some other file.  There can only be one top-level script at a time; the top-level script is the Python file you ran to start things off.\nNaming\nWhen a file is loaded, it is given a name (which is stored in its __name__ attribute).  If it was loaded as the top-level script, its name is __main__.  If it was loaded as a module, its name is the filename, preceded by the names of any packages/subpackages of which it is a part, separated by dots.\nSo for instance in your example:\npackage/\n    __init__.py\n    subpackage1/\n        __init__.py\n        moduleX.py\n    moduleA.py\n\nif you imported moduleX (note: imported, not directly executed), its name would be package.subpackage1.moduleX.  If you imported moduleA, its name would be package.moduleA.  However, if you directly run moduleX from the command line, its name will instead be __main__, and if you directly run moduleA from the command line, its name will be __main__.  When a module is run as the top-level script, it loses its normal name and its name is instead __main__.\nAccessing a module NOT through its containing package\nThere is an additional wrinkle: the module&apos;s name depends on whether it was imported &quot;directly&quot; from the directory it is in or imported via a package.  This only makes a difference if you run Python in a directory, and try to import a file in that same directory (or a subdirectory of it).  For instance, if you start the Python interpreter in the directory package/subpackage1 and then do import moduleX, the name of moduleX will just be moduleX, and not package.subpackage1.moduleX.  This is because Python adds the current directory to its search path when the interpreter is entered interactively; if it finds the to-be-imported module in the current directory, it will not know that that directory is part of a package, and the package information will not become part of the module&apos;s name.\nA special case is if you run the interpreter interactively (e.g., just type python and start entering Python code on the fly).  In this case, the name of that interactive session is __main__.\nNow here is the crucial thing for your error message: if a module&apos;s name has no dots, it is not considered to be part of a package.  It doesn&apos;t matter where the file actually is on disk.  All that matters is what its name is, and its name depends on how you loaded it.\nNow look at the quote you included in your question:\n\nRelative imports use a module&apos;s name attribute to determine that module&apos;s position in the package hierarchy. If the module&apos;s name does not contain any package information (e.g. it is set to &apos;main&apos;) then relative imports are resolved as if the module were a top-level module, regardless of where the module is actually located on the file system.\n\nRelative imports...\nRelative imports use the module&apos;s name to determine where it is in a package.  When you use a relative import like from .. import foo, the dots indicate to step up some number of levels in the package hierarchy.  For instance, if your current module&apos;s name is package.subpackage1.moduleX, then ..moduleA would mean package.moduleA.  For a from .. import to work, the module&apos;s name must have at least as many dots as there are in the import statement.\n... are only relative in a package\nHowever, if your module&apos;s name is __main__, it is not considered to be in a package.  Its name has no dots, and therefore you cannot use from .. import statements inside it.  If you try to do so, you will get the &quot;relative-import in non-package&quot; error.\nScripts can&apos;t import relative\nWhat you probably did is you tried to run moduleX or the like from the command line.  When you did this, its name was set to __main__, which means that relative imports within it will fail, because its name does not reveal that it is in a package. Note that this will also happen if you run Python from the same directory where a module is, and then try to import that module, because, as described above, Python will find the module in the current directory &quot;too early&quot; without realizing it is part of a package.\nAlso remember that when you run the interactive interpreter, the &quot;name&quot; of that interactive session is always __main__.  Thus you cannot do relative imports directly from an interactive session.  Relative imports are only for use within module files.\nTwo solutions:\n\nIf you really do want to run moduleX directly, but you still want it to be considered part of a package, you can do python -m package.subpackage1.moduleX.  The -m tells Python to load it as a module, not as the top-level script.\n\nOr perhaps you don&apos;t actually want to run moduleX, you just want to run some other script, say myfile.py, that uses functions inside moduleX.  If that is the case, put myfile.py somewhere else  not inside the package directory  and run it.  If inside myfile.py you do things like from package.moduleA import spam, it will work fine.\n\n\nNotes\n\nFor either of these solutions, the package directory (package in your example) must be accessible from the Python module search path (sys.path).  If it is not, you will not be able to use anything in the package reliably at all.\n\nSince Python 2.6, the module&apos;s &quot;name&quot; for package-resolution purposes is determined not just by its __name__ attributes but also by the __package__ attribute.  That&apos;s why I&apos;m avoiding using the explicit symbol __name__ to refer to the module&apos;s &quot;name&quot;.  Since Python 2.6 a module&apos;s &quot;name&quot; is effectively __package__ + &apos;.&apos; + __name__, or just __name__ if __package__ is None.)\n\n\n    ","url":"https://solutionschecker.com/questions/relative-imports-for-the-billionth-time-1657387756383#solution1","@type":"Answer","upvoteCount":0},{"text":"This is really a problem within python. The origin of confusion is that people mistakenly takes the relative import as path relative which is not. \n\nFor example when you write in faa.py:\n\nfrom .. import foo\n\n\nThis has a meaning only if faa.py was identified and loaded by python, during execution, as a part of a package. In that case,the module&apos;s name \n for faa.py would be for example some_packagename.faa. If the file was loaded just because it is in the current directory, when python is run, then its name would not refer to any package and eventually relative import would fail. \n\nA simple solution to refer modules in the current directory, is to use this:\n\nif __package__ is None or __package__ == &apos;&apos;:\n    # uses current directory visibility\n    import foo\nelse:\n    # uses current package visibility\n    from . import foo\n\n    ","url":"https://solutionschecker.com/questions/relative-imports-for-the-billionth-time-1657387756383#solution2","@type":"Answer","upvoteCount":0},{"text":"So after carping about this along with many others, I came across a note posted by Dorian B in this article that solved the specific problem I was having where I would develop modules and classes for use with a web service, but I also want to be able to test them as I&apos;m coding, using the debugger facilities in PyCharm. To run tests in a self-contained class, I would include the following at the end of my class file:\n\nif __name__ == &apos;__main__&apos;:\n   # run test code here...\n\n\nbut if I wanted to import other classes or modules in the same folder, I would then have to change all my import statements from relative notation to local references (i.e. remove the dot (.))  But after reading Dorian&apos;s suggestion, I tried his &apos;one-liner&apos; and it worked!  I can now test in PyCharm and leave my test code in place when I use the class in another class under test, or when I use it in my web service!\n\n# import any site-lib modules first, then...\nimport sys\nparent_module = sys.modules[&apos;.&apos;.join(__name__.split(&apos;.&apos;)[:-1]) or &apos;__main__&apos;]\nif __name__ == &apos;__main__&apos; or parent_module.__name__ == &apos;__main__&apos;:\n    from codex import Codex # these are in same folder as module under test!\n    from dblogger import DbLogger\nelse:\n    from .codex import Codex\n    from .dblogger import DbLogger\n\n\nThe if statement checks to see if we&apos;re running this module as main or if it&apos;s being used in another module that&apos;s being tested as main.  Perhaps this is obvious, but I offer this note here in case anyone else frustrated by the relative import issues above can make use of it.\n    ","url":"https://solutionschecker.com/questions/relative-imports-for-the-billionth-time-1657387756383#solution3","@type":"Answer","upvoteCount":0},{"text":"There are too much too long anwers in a foreign language. So I&apos;ll try to make it short.\nIf you write from . import module, opposite to  what you think, module will not be imported from current directory, but from the top level of your package! If you run .py file as a script, it simply doesn&apos;t know where the top level is and thus refuses to work.\nIf you start it like this py -m package.module from the directory above package, then python knows where the top level is. That&apos;s very similar to java: java -cp bin_directory package.class\n    ","url":"https://solutionschecker.com/questions/relative-imports-for-the-billionth-time-1657387756383#solution4","@type":"Answer","upvoteCount":0},{"text":"Here&apos;s a general recipe, modified to fit as an example, that I am using right now for dealing with Python libraries written as packages, that contain interdependent files, where I want to be able to test parts of them piecemeal.  Let&apos;s call this lib.foo and say that it needs access to lib.fileA for functions f1 and f2, and lib.fileB for class Class3.\nI have included a few print calls to help illustrate how this works.  In practice you would want to remove them (and maybe also the from __future__ import print_function line).\nThis particular example is too simple to show when we really need to insert an entry into sys.path.  (See Lars&apos; answer for a case where we do need it, when we have two or more levels of package directories, and then we use os.path.dirname(os.path.dirname(__file__))but it doesn&apos;t really hurt here either.)  It&apos;s also safe enough to do this without the if _i in sys.path test.  However, if each imported file inserts the same pathfor instance, if both fileA and fileB want to import utilities from the packagethis clutters up sys.path with the same path many times, so it&apos;s nice to have the if _i not in sys.path in the boilerplate.\nfrom __future__ import print_function # only when showing how this works\n\nif __package__:\n    print(&apos;Package named {!r}; __name__ is {!r}&apos;.format(__package__, __name__))\n    from .fileA import f1, f2\n    from .fileB import Class3\nelse:\n    print(&apos;Not a package; __name__ is {!r}&apos;.format(__name__))\n    # these next steps should be used only with care and if needed\n    # (remove the sys.path manipulation for simple cases!)\n    import os, sys\n    _i = os.path.dirname(os.path.abspath(__file__))\n    if _i not in sys.path:\n        print(&apos;inserting {!r} into sys.path&apos;.format(_i))\n        sys.path.insert(0, _i)\n    else:\n        print(&apos;{!r} is already in sys.path&apos;.format(_i))\n    del _i # clean up global name space\n\n    from fileA import f1, f2\n    from fileB import Class3\n\n... all the code as usual ...\n\nif __name__ == &apos;__main__&apos;:\n    import doctest, sys\n    ret = doctest.testmod()\n    sys.exit(0 if ret.failed == 0 else 1)\n\nThe idea here is this (and note that these all function the same across python2.7 and python 3.x):\n\nIf run as import lib or from lib import foo as a regular package import from ordinary code, __package is lib and __name__ is lib.foo.  We take the first code path, importing from .fileA, etc.\n\nIf run as python lib/foo.py, __package__ will be None and __name__ will be __main__.\nWe take the second code path.  The lib directory will already be in sys.path so there is no need to add it.  We import from fileA, etc.\n\nIf run within the lib directory as python foo.py, the behavior is the same as for case 2.\n\nIf run within the lib directory as python -m foo, the behavior is similar to cases 2 and 3.  However, the path to the lib directory is not in sys.path, so we add it before importing.  The same applies if we run Python and then import foo.\n(Since . is in sys.path, we don&apos;t really need to add the absolute version of the path here.  This is where a deeper package nesting structure, where we want to do from ..otherlib.fileC import ..., makes a difference.  If you&apos;re not doing this, you can omit all the sys.path manipulation entirely.)\n\n\nNotes\nThere is still a quirk.  If you run this whole thing from outside:\n$ python2 lib.foo\n\nor:\n$ python3 lib.foo\n\nthe behavior depends on the contents of lib/__init__.py.  If that exists and is empty, all is well:\nPackage named &apos;lib&apos;; __name__ is &apos;__main__&apos;\n\nBut if lib/__init__.py itself imports routine so that it can export routine.name directly as lib.name, you get:\n$ python2 lib.foo\nPackage named &apos;lib&apos;; __name__ is &apos;lib.foo&apos;\nPackage named &apos;lib&apos;; __name__ is &apos;__main__&apos;\n\nThat is, the module gets imported twice, once via the package and then again as __main__ so that it runs your main code.  Python 3.6 and later warn about this:\n$ python3 lib.routine\nPackage named &apos;lib&apos;; __name__ is &apos;lib.foo&apos;\n[...]/runpy.py:125: RuntimeWarning: &apos;lib.foo&apos; found in sys.modules\nafter import of package &apos;lib&apos;, but prior to execution of &apos;lib.foo&apos;;\nthis may result in unpredictable behaviour\n  warn(RuntimeWarning(msg))\nPackage named &apos;lib&apos;; __name__ is &apos;__main__&apos;\n\nThe warning is new, but the warned-about behavior is not.  It is part of what some call the double import trap.  (For additional details see issue 27487.)  Nick Coghlan says:\n\nThis next trap exists in all current versions of Python, including 3.3, and can be summed up in the following general guideline: &quot;Never add a package directory, or any directory inside a package, directly to the Python path&quot;.\n\nNote that while we violate that rule here, we do it only when the file being loaded is not being loaded as part of a package, and our modification is specifically designed to allow us to access other files in that package.  (And, as I noted, we probably shouldn&apos;t do this at all for single level packages.)  If we wanted to be extra-clean, we might rewrite this as, e.g.:\n    import os, sys\n    _i = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))\n    if _i not in sys.path:\n        sys.path.insert(0, _i)\n    else:\n        _i = None\n\n    from sub.fileA import f1, f2\n    from sub.fileB import Class3\n\n    if _i:\n        sys.path.remove(_i)\n    del _i\n\nThat is, we modify sys.path long enough to achieve our imports, then put it back the way it was (deleting one copy of _i if and only if we added one copy of _i).\n    ","url":"https://solutionschecker.com/questions/relative-imports-for-the-billionth-time-1657387756383#solution5","@type":"Answer","upvoteCount":0},{"text":"Here is one solution that I would not recommend, but might be useful in some situations where modules were simply not generated:\n\nimport os\nimport sys\nparent_dir_name = os.path.dirname(os.path.dirname(os.path.realpath(__file__)))\nsys.path.append(parent_dir_name + &quot;/your_dir&quot;)\nimport your_script\nyour_script.a_function()\n\n    ","url":"https://solutionschecker.com/questions/relative-imports-for-the-billionth-time-1657387756383#solution6","@type":"Answer","upvoteCount":0},{"text":"@BrenBarn&apos;s answer says it all, but if you&apos;re like me it might take a while to understand.  Here&apos;s my case and how @BrenBarn&apos;s answer applies to it, perhaps it will help you.\n\nThe case\n\npackage/\n    __init__.py\n    subpackage1/\n        __init__.py\n        moduleX.py\n    moduleA.py\n\n\nUsing our familiar example, and add to it that moduleX.py has a relative import to ..moduleA.  Given that I tried writing a test script in the subpackage1 directory that imported moduleX, but then got the dreaded error described by the OP.\n\nSolution\n\nMove test script to the same level as package and import package.subpackage1.moduleX\n\nExplanation\n\nAs explained, relative imports are made relative to the current name.  When my test script imports moduleX from the same directory, then module name inside moduleX is moduleX.  When it encounters a relative import the interpreter can&apos;t back up the package hierarchy because it&apos;s already at the top\n\nWhen I import moduleX from above, then name inside moduleX is package.subpackage1.moduleX and the relative import can be found\n    ","url":"https://solutionschecker.com/questions/relative-imports-for-the-billionth-time-1657387756383#solution7","@type":"Answer","upvoteCount":0},{"text":"I had a similar problem where I didn&apos;t want to change the Python module search \npath and needed to load a module relatively from a script (in spite of &quot;scripts can&apos;t import relative with all&quot; as BrenBarn explained nicely above).\n\nSo I used the following hack. Unfortunately, it relies on the imp module that \nbecame deprecated since version 3.4 to be dropped in favour of importlib.\n(Is this possible with importlib, too? I don&apos;t know.) Still, the hack works for now.\n\nExample for accessing members of moduleX in subpackage1 from a script residing in the subpackage2 folder:\n\n#!/usr/bin/env python3\n\nimport inspect\nimport imp\nimport os\n\ndef get_script_dir(follow_symlinks=True):\n    &quot;&quot;&quot;\n    Return directory of code defining this very function.\n    Should work from a module as well as from a script.\n    &quot;&quot;&quot;\n    script_path = inspect.getabsfile(get_script_dir)\n    if follow_symlinks:\n        script_path = os.path.realpath(script_path)\n    return os.path.dirname(script_path)\n\n# loading the module (hack, relying on deprecated imp-module)\nPARENT_PATH = os.path.dirname(get_script_dir())\n(x_file, x_path, x_desc) = imp.find_module(&apos;moduleX&apos;, [PARENT_PATH+&apos;/&apos;+&apos;subpackage1&apos;])\nmodule_x = imp.load_module(&apos;subpackage1.moduleX&apos;, x_file, x_path, x_desc)\n\n# importing a function and a value\nfunction = module_x.my_function\nVALUE = module_x.MY_CONST\n\n\nA cleaner approach seems to be to modify the sys.path used for loading modules as mentioned by Federico.\n\n#!/usr/bin/env python3\n\nif __name__ == &apos;__main__&apos; and __package__ is None:\n    from os import sys, path\n    # __file__ should be defined in this case\n    PARENT_DIR = path.dirname(path.dirname(path.abspath(__file__)))\n   sys.path.append(PARENT_DIR)\nfrom subpackage1.moduleX import *\n\n    ","url":"https://solutionschecker.com/questions/relative-imports-for-the-billionth-time-1657387756383#solution8","@type":"Answer","upvoteCount":0},{"text":"__name__ changes depending on whether the code in question is run in the global namespace or as part of an imported module.\n\nIf the code is not running in the global space, __name__ will be the name of the module. If it is running in global namespace -- for example, if you type it into a console, or run the module as a script using python.exe yourscriptnamehere.py then __name__ becomes &quot;__main__&quot;.  \n\nYou&apos;ll see a lot of python code with  if __name__ == &apos;__main__&apos; is used to test whether the code is being run from the global namespace  that allows you to have a module that doubles as a script. \n\nDid you try to do these imports from the console? \n    ","url":"https://solutionschecker.com/questions/relative-imports-for-the-billionth-time-1657387756383#solution9","@type":"Answer","upvoteCount":0},{"text":"Following up on what Lars has suggested I&apos;ve wrapped this approach in an experimental, new import library: ultraimport\nIt gives the programmer more control over imports and it allows file system based imports. Therefore, you can do relative imports from scripts. Parent package not necessary. ultraimports will always work, no matter how you run your code or what is your current working directory because ultraimport makes imports unambiguous. You don&apos;t need to change sys.path and also you don&apos;t need a try/except block to sometimes do relative imports and sometimes absolute.\nYou would then write in somefile.py something like:\nimport ultraimport\nfoo = ultraimport(&apos;__dir__/foo.py&apos;)\n\n__dir__ is the directory of somefile.py, the caller of ultraimport(). foo.py would live in the same directory as somefile.py.\nOne caveat when importing scripts like this is if they contain further relative imports. ultraimport has a builtin preprocessor to rewrite subsequent relative imports to ultraimports so they continue to work. Though, this is currently somewhat limited as original Python imports are ambiguous and there&apos;s only so much you can do about it.\n    ","url":"https://solutionschecker.com/questions/relative-imports-for-the-billionth-time-1657387756383#solution10","@type":"Answer","upvoteCount":0},{"text":"\n  Relative imports use a module&apos;s name attribute to determine that module&apos;s position in the package hierarchy. If the module&apos;s name does not contain any package information (e.g. it is set to &apos;main&apos;) then relative imports are resolved as if the module were a top level module, regardless of where the module is actually located on the file system.\n\n\nWrote a little python package to PyPi that might help viewers of this question. The package acts as workaround if one wishes to be able to run python files containing imports containing upper level packages from within a package / project without being directly in the importing file&apos;s directory. https://pypi.org/project/import-anywhere/ \n    ","url":"https://solutionschecker.com/questions/relative-imports-for-the-billionth-time-1657387756383#solution11","@type":"Answer","upvoteCount":0},{"text":"In most cases when I see the ValueError: attempted relative import beyond top-level package and pull my hair out, the solution is as follows:\nYou need to step one level higher in the file hierarchy!\n#dir/package/module1/foo.py\n\n#dir/package/module2/bar.py\nfrom ..module1 import foo\n\nImporting bar.py when interpreter is started in dir/package/ will result in error despite the import process never going beyond your current directory.\nImporting bar.py when interpreter is started in dir/ will succeed.\nSimilarly for unit tests:\npython3 -m unittest discover --start-directory=. successfully works from dir/, but not from dir/package/.\n    ","url":"https://solutionschecker.com/questions/relative-imports-for-the-billionth-time-1657387756383#solution12","@type":"Answer","upvoteCount":0}],"@type":"Question"}}</script><meta name="next-head-count" content="22"/><script id="google-analytics" data-nscript="beforeInteractive">(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
})(window,document,'script','dataLayer','GTM-NXVLL8B');</script><link rel="preload" href="/_next/static/css/c116652e2d6f4ad0.css" as="style"/><link rel="stylesheet" href="/_next/static/css/c116652e2d6f4ad0.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-0d1b80a048d4787e.js"></script><script src="/_next/static/chunks/webpack-42cdea76c8170223.js" defer=""></script><script src="/_next/static/chunks/framework-4556c45dd113b893.js" defer=""></script><script src="/_next/static/chunks/main-ccfab947c79712f4.js" defer=""></script><script src="/_next/static/chunks/pages/_app-862498b6ec7885c3.js" defer=""></script><script src="/_next/static/chunks/294-106ef8570fa99deb.js" defer=""></script><script src="/_next/static/chunks/490-7f0418bb4354ac73.js" defer=""></script><script src="/_next/static/chunks/pages/questions/%5Bslug%5D-47289857226115f9.js" defer=""></script><script src="/_next/static/xZs8haGjOP63QuDE0kxeX/_buildManifest.js" defer=""></script><script src="/_next/static/xZs8haGjOP63QuDE0kxeX/_ssgManifest.js" defer=""></script></head><body><noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-NXVLL8B"
        height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript><div id="__next"><div class="wrapper"><header><nav class="bg-white border-gray-200 px-4 lg:px-6 py-2.5 dark:bg-gray-800"><div class="flex flex-wrap justify-between items-center mx-auto max-w-screen-xl"><a class="flex items-center" href="/"><img src="/logo-second.png" class="mr-3 h-6 sm:h-9" alt="Solution Checker Logo"/><h1 class="self-center text-xl font-semibold whitespace-nowrap dark:text-white">Solution Checker</h1></a><div class="flex items-center lg:order-2"><button data-collapse-toggle="mobile-menu-2" type="button" class="inline-flex items-center p-2 ml-1 text-sm text-gray-500 rounded-lg lg:hidden hover:bg-gray-100 focus:outline-none focus:ring-2 focus:ring-gray-200 dark:text-gray-400 dark:hover:bg-gray-700 dark:focus:ring-gray-600" aria-controls="mobile-menu-2" aria-expanded="false"><span class="sr-only">Open main menu</span><svg class="w-6 h-6" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M3 5a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM3 10a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM3 15a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1z" clip-rule="evenodd"></path></svg><svg class="hidden w-6 h-6" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z" clip-rule="evenodd"></path></svg></button></div><div class="hidden justify-between items-center w-full lg:flex lg:w-auto lg:order-1" id="mobile-menu-2"><ul class="flex flex-col mt-4 font-medium lg:flex-row lg:space-x-8 lg:mt-0"><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" aria-current="page" href="/">Home</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/questions?tab=news">Questions</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/post?tab=news">Post</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/questions/relative-imports-for-the-billionth-time-1657387756383#">Coding</a></li></ul></div></div></nav></header><div class="main-content"><div class="question my-5"><div class="flex question-header items-center m-auto justify-center"><div class="rounded-xl w-full border p-5 shadow-md bg-white"><div class="flex w-full items-center justify-between border-b pb-3"><div class="flex items-center space-x-3"><div class="text-lg font-bold text-slate-700"><a href="/questions/relative-imports-for-the-billionth-time-1657387756383"><h1>Relative imports for the billionth time</h1></a></div></div><div class="flex flex-wrap h-auto justify-end items-center space-x-8"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold" href="/questions/tag/import">import</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold" href="/questions/tag/relative-path">relative-path</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold" href="/questions/tag/python-packaging">python-packaging</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold" href="/questions/tag/relative-import">relative-import</a></div></div><div class="question-content mt-5">
                
<p>I've been here:</p>
<ul>
<li><a href="http://www.python.org/dev/peps/pep-0328/" rel="noreferrer">http://www.python.org/dev/peps/pep-0328/</a></li>
<li><a href="http://docs.python.org/2/tutorial/modules.html#packages" rel="noreferrer">http://docs.python.org/2/tutorial/modules.html#packages</a></li>
<li><a href="https://stackoverflow.com/questions/10059002/python-packages-relative-imports">Python packages: relative imports</a></li>
<li><a href="https://stackoverflow.com/questions/9123062/python-relative-import-example-code-does-not-work">python relative import example code does not work</a></li>
<li><a href="https://stackoverflow.com/questions/8299270/ultimate-answer-to-relative-python-imports">Relative imports in python 2.5</a></li>
<li><a href="https://stackoverflow.com/questions/4175534/relative-imports-in-python">Relative imports in Python</a></li>
<li><a href="https://stackoverflow.com/questions/13233931/python-disabling-relative-import?rq=1">Python: Disabling relative import</a></li>
</ul>
<p>and plenty of URLs that I did not copy, some on SO, some on other sites, back when I thought I'd have the solution quickly.</p>
<p>The forever-recurring question is this: how do I solve this "Attempted relative import in non-package" message?</p>
<pre class="lang-py s-code-block"><code class="hljs language-python">ImportError: attempted relative <span class="hljs-keyword">import</span> <span class="hljs-keyword">with</span> no known parent package
</code></pre>
<p>I built an exact replica of the package on pep-0328:</p>
<pre class="lang-py s-code-block"><code class="hljs language-python">package/
    __init__.py
    subpackage1/
        __init__.py
        moduleX.py
        moduleY.py
    subpackage2/
        __init__.py
        moduleZ.py
    moduleA.py
</code></pre>
<p>The imports were done from the console.</p>
<p>I did make functions named spam and eggs in their appropriate modules.  Naturally, it didn't work.  The answer is apparently in the 4th URL I listed, but it's all alumni to me. There was this response on one of the URLs I visited:</p>
<blockquote>
<p>Relative imports use a module's name attribute to determine that module's position in the package hierarchy. If the module's name does not contain any package information (e.g. it is set to 'main') then relative imports are resolved as if the module were a top level module, regardless of where the module is actually located on the file system.</p>
</blockquote>
<p>The above response looks promising, but it's all hieroglyphs to me.  So my question, how do I make Python not return to me "Attempted relative import in non-package"? has an answer that involves -m, supposedly.</p>
<p>Can somebody please tell me why Python gives that error message, what it means by "non-package", why and how do you define a 'package', and <em>the precise answer put in terms easy enough for a kindergartener to understand</em>.</p>
    </div></div></div><div class="solution-section"><nav class="flex pagination-solution flex-col justify-end"><h1 class="text-lg font-semibold mb-5">Navigate to solutions: </h1><ul class="inline-flex -space-x-px overflow-auto"><li class="pagination-solution-item"><span data-id="#solution1" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">1</span></li><li class="pagination-solution-item"><span data-id="#solution2" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">2</span></li><li class="pagination-solution-item"><span data-id="#solution3" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">3</span></li><li class="pagination-solution-item"><span data-id="#solution4" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">4</span></li><li class="pagination-solution-item"><span data-id="#solution5" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">5</span></li><li class="pagination-solution-item"><span data-id="#solution6" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">6</span></li><li class="pagination-solution-item"><span data-id="#solution7" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">7</span></li><li class="pagination-solution-item"><span data-id="#solution8" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">8</span></li><li class="pagination-solution-item"><span data-id="#solution9" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">9</span></li><li class="pagination-solution-item"><span data-id="#solution10" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">10</span></li><li class="pagination-solution-item"><span data-id="#solution11" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">11</span></li><li class="pagination-solution-item"><span data-id="#solution12" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">12</span></li></ul></nav><div id="solution1" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 1</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/import">import</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/relative-path">relative-path</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/python-packaging">python-packaging</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/relative-import">relative-import</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p><strong>Script vs. Module</strong></p>
<p>Here's an explanation.  The short version is that there is a big difference between directly running a Python file, and importing that file from somewhere else.  <strong>Just knowing what directory a file is in does not determine what package Python thinks it is in.</strong>  That depends, additionally, on how you load the file into Python (by running or by importing).</p>
<p>There are two ways to load a Python file: as the top-level script, or as a
module.  A file is loaded as the top-level script if you execute it directly, for instance by typing <code>python myfile.py</code> on the command line.  It is loaded as a module when an <code>import</code> statement is encountered inside some other file.  There can only be one top-level script at a time; the top-level script is the Python file you ran to start things off.</p>
<p><strong>Naming</strong></p>
<p>When a file is loaded, it is given a name (which is stored in its <code>__name__</code> attribute).  If it was loaded as the top-level script, its name is <code>__main__</code>.  If it was loaded as a module, its name is the filename, preceded by the names of any packages/subpackages of which it is a part, separated by dots.</p>
<p>So for instance in your example:</p>
<pre class="lang-py s-code-block"><code class="hljs language-python">package/
    __init__.py
    subpackage1/
        __init__.py
        moduleX.py
    moduleA.py
</code></pre>
<p>if you imported <code>moduleX</code> (note: <em>imported</em>, not directly executed), its name would be <code>package.subpackage1.moduleX</code>.  If you imported <code>moduleA</code>, its name would be <code>package.moduleA</code>.  However, if you <em>directly run</em> <code>moduleX</code> from the command line, its name will instead be <code>__main__</code>, and if you directly run <code>moduleA</code> from the command line, its name will be <code>__main__</code>.  When a module is run as the top-level script, it loses its normal name and its name is instead <code>__main__</code>.</p>
<p><strong>Accessing a module NOT through its containing package</strong></p>
<p>There is an additional wrinkle: the module's name depends on whether it was imported "directly" from the directory it is in or imported via a package.  This only makes a difference if you run Python in a directory, and try to import a file in that same directory (or a subdirectory of it).  For instance, if you start the Python interpreter in the directory <code>package/subpackage1</code> and then do <code>import moduleX</code>, the name of <code>moduleX</code> will just be <code>moduleX</code>, and not <code>package.subpackage1.moduleX</code>.  This is because Python adds the current directory to its search path when the interpreter is entered interactively; if it finds the to-be-imported module in the current directory, it will not know that that directory is part of a package, and the package information will not become part of the module's name.</p>
<p>A special case is if you run the interpreter interactively (e.g., just type <code>python</code> and start entering Python code on the fly).  In this case, the name of that interactive session is <code>__main__</code>.</p>
<p>Now here is the crucial thing for your error message: <strong>if a module's name has no dots, it is not considered to be part of a package</strong>.  It doesn't matter where the file actually is on disk.  All that matters is what its name is, and its name depends on how you loaded it.</p>
<p>Now look at the quote you included in your question:</p>
<blockquote>
<p>Relative imports use a module's name attribute to determine that module's position in the package hierarchy. If the module's name does not contain any package information (e.g. it is set to 'main') then relative imports are resolved as if the module were a top-level module, regardless of where the module is actually located on the file system.</p>
</blockquote>
<p><strong>Relative imports...</strong></p>
<p>Relative imports use the module's <em>name</em> to determine where it is in a package.  When you use a relative import like <code>from .. import foo</code>, the dots indicate to step up some number of levels in the package hierarchy.  For instance, if your current module's name is <code>package.subpackage1.moduleX</code>, then <code>..moduleA</code> would mean <code>package.moduleA</code>.  For a <code>from .. import</code> to work, the module's name must have at least as many dots as there are in the <code>import</code> statement.</p>
<p><strong>... are only relative in a package</strong></p>
<p>However, if your module's name is <code>__main__</code>, it is not considered to be in a package.  Its name has no dots, and therefore you cannot use <code>from .. import</code> statements inside it.  If you try to do so, you will get the "relative-import in non-package" error.</p>
<p><strong>Scripts can't import relative</strong></p>
<p>What you probably did is you tried to run <code>moduleX</code> or the like from the command line.  When you did this, its name was set to <code>__main__</code>, which means that relative imports within it will fail, because its name does not reveal that it is in a package. Note that this will also happen if you run Python from the same directory where a module is, and then try to import that module, because, as described above, Python will find the module in the current directory "too early" without realizing it is part of a package.</p>
<p>Also remember that when you run the interactive interpreter, the "name" of that interactive session is always <code>__main__</code>.  Thus <strong>you cannot do relative imports directly from an interactive session</strong>.  Relative imports are only for use within module files.</p>
<p><strong>Two solutions:</strong></p>
<ol>
<li><p>If you really do want to run <code>moduleX</code> directly, but you still want it to be considered part of a package, you can do <code>python -m package.subpackage1.moduleX</code>.  The <code>-m</code> tells Python to load it as a module, not as the top-level script.</p>
</li>
<li><p>Or perhaps you don't actually want to <em>run</em> <code>moduleX</code>, you just want to run some other script, say <code>myfile.py</code>, that <em>uses</em> functions inside <code>moduleX</code>.  If that is the case, put <code>myfile.py</code> <em>somewhere else</em>  <em>not</em> inside the <code>package</code> directory  and run it.  If inside <code>myfile.py</code> you do things like <code>from package.moduleA import spam</code>, it will work fine.</p>
</li>
</ol>
<p><strong>Notes</strong></p>
<ul>
<li><p>For either of these solutions, the package directory (<code>package</code> in your example) must be accessible from the Python module search path (<code>sys.path</code>).  If it is not, you will not be able to use anything in the package reliably at all.</p>
</li>
<li><p>Since Python 2.6, the module's "name" for package-resolution purposes is determined not just by its <code>__name__</code> attributes but also by the <code>__package__</code> attribute.  That's why I'm avoiding using the explicit symbol <code>__name__</code> to refer to the module's "name".  Since Python 2.6 a module's "name" is effectively <code>__package__ + '.' + __name__</code>, or just <code>__name__</code> if <code>__package__</code> is <code>None</code>.)</p>
</li>
</ul>
    </div></div></div></div><div id="solution2" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 2</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/import">import</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/relative-path">relative-path</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/python-packaging">python-packaging</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/relative-import">relative-import</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>This is really a problem within python. <strong>The origin of confusion is that people mistakenly takes the relative import as path relative which is not.</strong> </p>

<p>For example when you write in <em>faa.py</em>:</p>

<pre class="lang-py s-code-block"><code class="hljs language-python"><span class="hljs-keyword">from</span> .. <span class="hljs-keyword">import</span> foo
</code></pre>

<p>This has a meaning only if <em>faa.py</em> was <em>identified and loaded</em> by python, during execution, as a part of a package. In that case,the <strong>module's name</strong> 
 for <em>faa.py</em> would be for example <em>some_packagename.faa</em>. If the file was loaded just because it is in the current directory, when python is run, then its name would not refer to any package and eventually relative import would fail. </p>

<p>A simple solution to refer modules in the current directory, is to use this:</p>

<pre class="lang-py s-code-block"><code class="hljs language-python"><span class="hljs-keyword">if</span> __package__ <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">or</span> __package__ == <span class="hljs-string">''</span>:
    <span class="hljs-comment"># uses current directory visibility</span>
    <span class="hljs-keyword">import</span> foo
<span class="hljs-keyword">else</span>:
    <span class="hljs-comment"># uses current package visibility</span>
    <span class="hljs-keyword">from</span> . <span class="hljs-keyword">import</span> foo
</code></pre>
    </div></div></div></div><div id="solution3" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 3</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/import">import</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/relative-path">relative-path</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/python-packaging">python-packaging</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/relative-import">relative-import</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>So after carping about this along with many others, I came across a note posted by <a href="https://stackoverflow.com/users/5420054/dorian-b">Dorian B</a> in this <a href="https://stackoverflow.com/questions/5286210/is-there-a-way-to-access-parent-modules-in-python">article</a> that solved the specific problem I was having where I would develop modules and classes for use with a web service, but I also want to be able to test them as I'm coding, using the debugger facilities in PyCharm. To run tests in a self-contained class, I would include the following at the end of my class file:</p>

<pre class="lang-py s-code-block"><code class="hljs language-python"><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:
   <span class="hljs-comment"># run test code here...</span>
</code></pre>

<p>but if I wanted to import other classes or modules in the same folder, I would then have to change all my import statements from relative notation to local references (i.e. remove the dot (.))  But after reading Dorian's suggestion, I tried his 'one-liner' and it worked!  I can now test in PyCharm and leave my test code in place when I use the class in another class under test, or when I use it in my web service!</p>

<pre class="lang-py s-code-block"><code class="hljs language-python"><span class="hljs-comment"># import any site-lib modules first, then...</span>
<span class="hljs-keyword">import</span> sys
parent_module = sys.modules[<span class="hljs-string">'.'</span>.join(__name__.split(<span class="hljs-string">'.'</span>)[:-<span class="hljs-number">1</span>]) <span class="hljs-keyword">or</span> <span class="hljs-string">'__main__'</span>]
<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span> <span class="hljs-keyword">or</span> parent_module.__name__ == <span class="hljs-string">'__main__'</span>:
    <span class="hljs-keyword">from</span> codex <span class="hljs-keyword">import</span> Codex <span class="hljs-comment"># these are in same folder as module under test!</span>
    <span class="hljs-keyword">from</span> dblogger <span class="hljs-keyword">import</span> DbLogger
<span class="hljs-keyword">else</span>:
    <span class="hljs-keyword">from</span> .codex <span class="hljs-keyword">import</span> Codex
    <span class="hljs-keyword">from</span> .dblogger <span class="hljs-keyword">import</span> DbLogger
</code></pre>

<p>The if statement checks to see if we're running this module as <strong>main</strong> or if it's being used in another module that's being tested as <strong>main</strong>.  Perhaps this is obvious, but I offer this note here in case anyone else frustrated by the relative import issues above can make use of it.</p>
    </div></div></div></div><div id="solution4" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 4</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/import">import</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/relative-path">relative-path</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/python-packaging">python-packaging</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/relative-import">relative-import</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>There are too much too long anwers in a foreign language. So I'll try to make it short.</p>
<p>If you write <code>from . import module</code>, opposite to  what you think, <code>module</code> will not be imported from current directory, but from the top level of your package! If you run .py file as a script, it simply doesn't know where the top level is and thus refuses to work.</p>
<p>If you start it like this <code>py -m package.module</code> from the directory above <code>package</code>, then python knows where the top level is. That's very similar to java: <code>java -cp bin_directory package.class</code></p>
    </div></div></div></div><div id="solution5" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 5</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/import">import</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/relative-path">relative-path</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/python-packaging">python-packaging</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/relative-import">relative-import</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Here's a general recipe, modified to fit as an example, that I am using right now for dealing with Python libraries written as packages, that contain interdependent files, where I want to be able to test parts of them piecemeal.  Let's call this <code>lib.foo</code> and say that it needs access to <code>lib.fileA</code> for functions <code>f1</code> and <code>f2</code>, and <code>lib.fileB</code> for class <code>Class3</code>.</p>
<p>I have included a few <code>print</code> calls to help illustrate how this works.  In practice you would want to remove them (and maybe also the <code>from __future__ import print_function</code> line).</p>
<p>This particular example is too simple to show when we really need to insert an entry into <code>sys.path</code>.  (See <a href="https://stackoverflow.com/a/38455936/1256452">Lars' answer</a> for a case where we <em>do</em> need it, when we have two or more levels of package directories, and then we use <code>os.path.dirname(os.path.dirname(__file__))</code>but it doesn't really <em>hurt</em> here either.)  It's also safe enough to do this without the <code>if _i in sys.path</code> test.  However, if each imported file inserts the same pathfor instance, if both <code>fileA</code> and <code>fileB</code> want to import utilities from the packagethis clutters up <code>sys.path</code> with the same path many times, so it's nice to have the <code>if _i not in sys.path</code> in the boilerplate.</p>
<pre class="lang-py s-code-block"><code class="hljs language-python"><span class="hljs-keyword">from</span> __future__ <span class="hljs-keyword">import</span> print_function <span class="hljs-comment"># only when showing how this works</span>

<span class="hljs-keyword">if</span> __package__:
    <span class="hljs-built_in">print</span>(<span class="hljs-string">'Package named {!r}; __name__ is {!r}'</span>.<span class="hljs-built_in">format</span>(__package__, __name__))
    <span class="hljs-keyword">from</span> .fileA <span class="hljs-keyword">import</span> f1, f2
    <span class="hljs-keyword">from</span> .fileB <span class="hljs-keyword">import</span> Class3
<span class="hljs-keyword">else</span>:
    <span class="hljs-built_in">print</span>(<span class="hljs-string">'Not a package; __name__ is {!r}'</span>.<span class="hljs-built_in">format</span>(__name__))
    <span class="hljs-comment"># these next steps should be used only with care and if needed</span>
    <span class="hljs-comment"># (remove the sys.path manipulation for simple cases!)</span>
    <span class="hljs-keyword">import</span> os, sys
    _i = os.path.dirname(os.path.abspath(__file__))
    <span class="hljs-keyword">if</span> _i <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> sys.path:
        <span class="hljs-built_in">print</span>(<span class="hljs-string">'inserting {!r} into sys.path'</span>.<span class="hljs-built_in">format</span>(_i))
        sys.path.insert(<span class="hljs-number">0</span>, _i)
    <span class="hljs-keyword">else</span>:
        <span class="hljs-built_in">print</span>(<span class="hljs-string">'{!r} is already in sys.path'</span>.<span class="hljs-built_in">format</span>(_i))
    <span class="hljs-keyword">del</span> _i <span class="hljs-comment"># clean up global name space</span>

    <span class="hljs-keyword">from</span> fileA <span class="hljs-keyword">import</span> f1, f2
    <span class="hljs-keyword">from</span> fileB <span class="hljs-keyword">import</span> Class3

<span class="hljs-meta">... </span><span class="hljs-built_in">all</span> the code <span class="hljs-keyword">as</span> usual ...

<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:
    <span class="hljs-keyword">import</span> doctest, sys
    ret = doctest.testmod()
    sys.exit(<span class="hljs-number">0</span> <span class="hljs-keyword">if</span> ret.failed == <span class="hljs-number">0</span> <span class="hljs-keyword">else</span> <span class="hljs-number">1</span>)
</code></pre>
<p>The idea here is this (and note that these all function the same across python2.7 and python 3.x):</p>
<ol>
<li><p>If run as <code>import lib</code> or <code>from lib import foo</code> as a regular package import from ordinary code, <code>__package</code> is <code>lib</code> and <code>__name__</code> is <code>lib.foo</code>.  We take the first code path, importing from <code>.fileA</code>, etc.</p>
</li>
<li><p>If run as <code>python lib/foo.py</code>, <code>__package__</code> will be None and <code>__name__</code> will be <code>__main__</code>.</p>
<p>We take the second code path.  The <code>lib</code> directory will already be in <code>sys.path</code> so there is no need to add it.  We import from <code>fileA</code>, etc.</p>
</li>
<li><p>If run within the <code>lib</code> directory as <code>python foo.py</code>, the behavior is the same as for case 2.</p>
</li>
<li><p>If run within the <code>lib</code> directory as <code>python -m foo</code>, the behavior is similar to cases 2 and 3.  However, the path to the <code>lib</code> directory is not in <code>sys.path</code>, so we add it before importing.  The same applies if we run Python and then <code>import foo</code>.</p>
<p>(Since <code>.</code> <em>is</em> in <code>sys.path</code>, we don't really need to add the absolute version of the path here.  This is where a deeper package nesting structure, where we want to do <code>from ..otherlib.fileC import ...</code>, makes a difference.  If you're not doing this, you can omit all the <code>sys.path</code> manipulation entirely.)</p>
</li>
</ol>
<h3>Notes</h3>
<p>There is still a quirk.  If you run this whole thing from outside:</p>
<pre class="lang-py s-code-block"><code class="hljs language-python">$ python2 lib.foo
</code></pre>
<p>or:</p>
<pre class="lang-py s-code-block"><code class="hljs language-python">$ python3 lib.foo
</code></pre>
<p>the behavior depends on the contents of <code>lib/__init__.py</code>.  If that exists and <em>is empty</em>, all is well:</p>
<pre class="lang-py s-code-block"><code class="hljs language-python">Package named <span class="hljs-string">'lib'</span>; __name__ <span class="hljs-keyword">is</span> <span class="hljs-string">'__main__'</span>
</code></pre>
<p>But if <code>lib/__init__.py</code> <em>itself</em> imports <code>routine</code> so that it can export <code>routine.name</code> directly as <code>lib.name</code>, you get:</p>
<pre class="lang-py s-code-block"><code class="hljs language-python">$ python2 lib.foo
Package named <span class="hljs-string">'lib'</span>; __name__ <span class="hljs-keyword">is</span> <span class="hljs-string">'lib.foo'</span>
Package named <span class="hljs-string">'lib'</span>; __name__ <span class="hljs-keyword">is</span> <span class="hljs-string">'__main__'</span>
</code></pre>
<p>That is, the module gets imported twice, once via the package and then again as <code>__main__</code> so that it runs your <code>main</code> code.  Python 3.6 and later warn about this:</p>
<pre class="lang-py s-code-block"><code class="hljs language-python">$ python3 lib.routine
Package named <span class="hljs-string">'lib'</span>; __name__ <span class="hljs-keyword">is</span> <span class="hljs-string">'lib.foo'</span>
[...]/runpy.py:<span class="hljs-number">125</span>: RuntimeWarning: <span class="hljs-string">'lib.foo'</span> found <span class="hljs-keyword">in</span> sys.modules
after <span class="hljs-keyword">import</span> of package <span class="hljs-string">'lib'</span>, but prior to execution of <span class="hljs-string">'lib.foo'</span>;
this may result <span class="hljs-keyword">in</span> unpredictable behaviour
  warn(RuntimeWarning(msg))
Package named <span class="hljs-string">'lib'</span>; __name__ <span class="hljs-keyword">is</span> <span class="hljs-string">'__main__'</span>
</code></pre>
<p>The <em>warning</em> is new, but the warned-about behavior is not.  It is part of what some call <a href="http://python-notes.curiousefficiency.org/en/latest/python_concepts/import_traps.html#the-double-import-trap" rel="noreferrer">the double import trap</a>.  (For additional details see <a href="https://bugs.python.org/issue27487" rel="noreferrer">issue 27487</a>.)  Nick Coghlan says:</p>
<blockquote>
<p>This next trap exists in all current versions of Python, including 3.3, and can be summed up in the following general guideline: "Never add a package directory, or any directory inside a package, directly to the Python path".</p>
</blockquote>
<p>Note that while we violate that rule here, we do it <em>only</em> when the file being loaded is <em>not</em> being loaded as part of a package, and our modification is specifically designed to allow us to access other files in that package.  (And, as I noted, we probably shouldn't do this at all for single level packages.)  If we wanted to be extra-clean, we might rewrite this as, e.g.:</p>
<pre class="lang-py s-code-block"><code class="hljs language-python">    <span class="hljs-keyword">import</span> os, sys
    _i = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
    <span class="hljs-keyword">if</span> _i <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> sys.path:
        sys.path.insert(<span class="hljs-number">0</span>, _i)
    <span class="hljs-keyword">else</span>:
        _i = <span class="hljs-literal">None</span>

    <span class="hljs-keyword">from</span> sub.fileA <span class="hljs-keyword">import</span> f1, f2
    <span class="hljs-keyword">from</span> sub.fileB <span class="hljs-keyword">import</span> Class3

    <span class="hljs-keyword">if</span> _i:
        sys.path.remove(_i)
    <span class="hljs-keyword">del</span> _i
</code></pre>
<p>That is, we modify <code>sys.path</code> long enough to achieve our imports, then put it back the way it was (deleting one copy of <code>_i</code> if and only if we added one copy of <code>_i</code>).</p>
    </div></div></div></div><div id="solution6" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 6</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/import">import</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/relative-path">relative-path</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/python-packaging">python-packaging</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/relative-import">relative-import</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Here is one solution that I would not recommend, but might be useful in some situations where modules were simply not generated:</p>

<pre class="lang-py s-code-block"><code class="hljs language-python"><span class="hljs-keyword">import</span> os
<span class="hljs-keyword">import</span> sys
parent_dir_name = os.path.dirname(os.path.dirname(os.path.realpath(__file__)))
sys.path.append(parent_dir_name + <span class="hljs-string">"/your_dir"</span>)
<span class="hljs-keyword">import</span> your_script
your_script.a_function()
</code></pre>
    </div></div></div></div><div id="solution7" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 7</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/import">import</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/relative-path">relative-path</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/python-packaging">python-packaging</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/relative-import">relative-import</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>@BrenBarn's answer says it all, but if you're like me it might take a while to understand.  Here's my case and how @BrenBarn's answer applies to it, perhaps it will help you.</p>

<p><strong>The case</strong></p>

<pre class="lang-py s-code-block"><code class="hljs language-python">package/
    __init__.py
    subpackage1/
        __init__.py
        moduleX.py
    moduleA.py
</code></pre>

<p>Using our familiar example, and add to it that moduleX.py has a relative import to ..moduleA.  Given that I tried writing a test script in the subpackage1 directory that imported moduleX, but then got the dreaded error described by the OP.</p>

<p><strong>Solution</strong></p>

<p>Move test script to the same level as package and import package.subpackage1.moduleX</p>

<p><strong>Explanation</strong></p>

<p>As explained, relative imports are made relative to the current name.  When my test script imports moduleX from the same directory, then module name inside moduleX is moduleX.  When it encounters a relative import the interpreter can't back up the package hierarchy because it's already at the top</p>

<p>When I import moduleX from above, then name inside moduleX is package.subpackage1.moduleX and the relative import can be found</p>
    </div></div></div></div><div id="solution8" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 8</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/import">import</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/relative-path">relative-path</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/python-packaging">python-packaging</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/relative-import">relative-import</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>I had a similar problem where I didn't want to change the Python module search 
path and needed to load a module relatively <em>from a script</em> (in spite of <em>"scripts can't import relative with all"</em> as BrenBarn explained nicely above).</p>

<p>So I used the following hack. Unfortunately, it relies on the <code>imp</code> module that 
became deprecated since version 3.4 to be dropped in favour of <code>importlib</code>.
(Is this possible with <code>importlib</code>, too? I don't know.) Still, the hack works for now.</p>

<p>Example for accessing members of <code>moduleX</code> in <code>subpackage1</code> from a script residing in the <code>subpackage2</code> folder:</p>

<pre class="lang-py s-code-block"><code class="hljs language-python"><span class="hljs-comment">#!/usr/bin/env python3</span>

<span class="hljs-keyword">import</span> inspect
<span class="hljs-keyword">import</span> imp
<span class="hljs-keyword">import</span> os

<span class="hljs-keyword">def</span> <span class="hljs-title function_">get_script_dir</span>(<span class="hljs-params">follow_symlinks=<span class="hljs-literal">True</span></span>):
    <span class="hljs-string">"""
    Return directory of code defining this very function.
    Should work from a module as well as from a script.
    """</span>
    script_path = inspect.getabsfile(get_script_dir)
    <span class="hljs-keyword">if</span> follow_symlinks:
        script_path = os.path.realpath(script_path)
    <span class="hljs-keyword">return</span> os.path.dirname(script_path)

<span class="hljs-comment"># loading the module (hack, relying on deprecated imp-module)</span>
PARENT_PATH = os.path.dirname(get_script_dir())
(x_file, x_path, x_desc) = imp.find_module(<span class="hljs-string">'moduleX'</span>, [PARENT_PATH+<span class="hljs-string">'/'</span>+<span class="hljs-string">'subpackage1'</span>])
module_x = imp.load_module(<span class="hljs-string">'subpackage1.moduleX'</span>, x_file, x_path, x_desc)

<span class="hljs-comment"># importing a function and a value</span>
function = module_x.my_function
VALUE = module_x.MY_CONST
</code></pre>

<p>A cleaner approach seems to be to modify the sys.path used for loading modules as mentioned by Federico.</p>

<pre class="lang-py s-code-block"><code class="hljs language-python"><span class="hljs-comment">#!/usr/bin/env python3</span>

<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span> <span class="hljs-keyword">and</span> __package__ <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:
    <span class="hljs-keyword">from</span> os <span class="hljs-keyword">import</span> sys, path
    <span class="hljs-comment"># __file__ should be defined in this case</span>
    PARENT_DIR = path.dirname(path.dirname(path.abspath(__file__)))
   sys.path.append(PARENT_DIR)
<span class="hljs-keyword">from</span> subpackage1.moduleX <span class="hljs-keyword">import</span> *
</code></pre>
    </div></div></div></div><div id="solution9" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 9</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/import">import</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/relative-path">relative-path</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/python-packaging">python-packaging</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/relative-import">relative-import</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p><code>__name__</code> changes depending on whether the code in question is run in the global namespace or as part of an imported module.</p>

<p>If the code is not running in the global space, <code>__name__</code> will be the name of the module. If it is running in global namespace -- for example, if you type it into a console, or run the module as a script using <code>python.exe yourscriptnamehere.py</code> then <code>__name__</code> becomes <code>"__main__"</code>.  </p>

<p>You'll see a lot of python code with  <code>if __name__ == '__main__'</code> is used to test whether the code is being run from the global namespace  that allows you to have a module that doubles as a script. </p>

<p>Did you try to do these imports from the console? </p>
    </div></div></div></div><div id="solution10" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 10</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/import">import</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/relative-path">relative-path</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/python-packaging">python-packaging</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/relative-import">relative-import</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Following up on what Lars has suggested I've wrapped this approach in an experimental, new import library: <a href="https://github.com/ronny-rentner/ultraimport" rel="nofollow noreferrer">ultraimport</a></p>
<p>It gives the programmer more control over imports and it allows file system based imports. Therefore, you can do relative imports from scripts. Parent package not necessary. ultraimports will always work, no matter how you run your code or what is your current working directory because ultraimport makes imports unambiguous. You don't need to change sys.path and also you don't need a try/except block to sometimes do relative imports and sometimes absolute.</p>
<p>You would then write in somefile.py something like:</p>
<pre class="lang-py s-code-block"><code class="hljs language-python"><span class="hljs-keyword">import</span> ultraimport
foo = ultraimport(<span class="hljs-string">'__dir__/foo.py'</span>)
</code></pre>
<p>__dir__ is the directory of somefile.py, the caller of ultraimport(). foo.py would live in the same directory as somefile.py.</p>
<p>One caveat when importing scripts like this is if they contain further relative imports. ultraimport has a builtin preprocessor to rewrite subsequent relative imports to ultraimports so they continue to work. Though, this is currently somewhat limited as original Python imports are ambiguous and there's only so much you can do about it.</p>
    </div></div></div></div><div id="solution11" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 11</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/import">import</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/relative-path">relative-path</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/python-packaging">python-packaging</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/relative-import">relative-import</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<blockquote>
  <p>Relative imports use a module's name attribute to determine that module's position in the package hierarchy. If the module's name does not contain any package information (e.g. it is set to 'main') then relative imports are resolved as if the module were a top level module, regardless of where the module is actually located on the file system.</p>
</blockquote>

<p>Wrote a little python package to PyPi that might help viewers of this question. The package acts as workaround if one wishes to be able to run python files containing imports containing upper level packages from within a package / project without being directly in the importing file's directory. <a href="https://pypi.org/project/import-anywhere/" rel="nofollow noreferrer">https://pypi.org/project/import-anywhere/</a> </p>
    </div></div></div></div><div id="solution12" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 12</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/import">import</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/relative-path">relative-path</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/python-packaging">python-packaging</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/relative-import">relative-import</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>In most cases when I see the <code>ValueError: attempted relative import beyond top-level package</code> and pull my hair out, the solution is as follows:</p>
<p>You need to <strong>step one level higher</strong> in the file hierarchy!</p>
<pre class="lang-py s-code-block"><code class="hljs language-python"><span class="hljs-comment">#dir/package/module1/foo.py</span>

<span class="hljs-comment">#dir/package/module2/bar.py</span>
<span class="hljs-keyword">from</span> ..module1 <span class="hljs-keyword">import</span> foo
</code></pre>
<p>Importing <code>bar.py</code> when interpreter is started in <code>dir/package/</code> will result in error despite the import process never going beyond your current directory.</p>
<p>Importing <code>bar.py</code> when interpreter is started in <code>dir/</code> will succeed.</p>
<p>Similarly for unit tests:
<code>python3 -m unittest discover --start-directory=.</code> successfully works from <code>dir/</code>, but not from <code>dir/package/</code>.</p>
    </div></div></div></div></div></div><div class="widget"><a href="/questions/how-do-i-return-the-response-from-an-asynchronous-call-1657384208012">How do I return the response from an asynchronous call?</a><a href="/questions/why-does-my-function-that-calls-an-api-or-launches-a-coroutine-return-an-empty-or-null-value-1657388483820">Why does my function that calls an API or launches a coroutine return an empty or null value?</a><a href="/questions/what-is-the-self-parameter-in-class-methods-1657387518448">What is the `self` parameter in class methods?</a><a href="/questions/how-do-you-use-a-variable-in-a-regular-expression-1657387939007">How do you use a variable in a regular expression?</a><a href="/questions/how-to-use-java.util.scanner-to-correctly-read-user-input-from-system.in-and-act-on-it-1657388546306">How to use java.util.Scanner to correctly read user input from System.in and act on it?</a><a href="/questions/how-to-use-variables-in-sql-statement-in-python-1657388479077">How to use variables in SQL statement in Python?</a><a href="/questions/convert-form-data-to-javascript-object-with-jquery-1657388036834">Convert form data to JavaScript object with jQuery</a><a href="/questions/how-to-remove-%22noise%22-from-gccclang-assembly-output-1657387612391">How to remove &quot;noise&quot; from GCC/clang assembly output?</a><a href="/questions/why-is-using-&#x27;eval&#x27;-a-bad-practice-1657387348760">Why is using &#x27;eval&#x27; a bad practice?</a><a href="/questions/sorting-an-array-of-objects-by-property-values-1657387447490">Sorting an array of objects by property values</a><a href="/questions/how-to-remove-items-from-a-list-while-iterating-1657384496375">How to remove items from a list while iterating?</a><a href="/questions/short-description-of-the-scoping-rules-1657384853121">Short description of the scoping rules?</a><a href="/questions/how-do-i-modify-the-url-without-reloading-the-page-1657387509731">How do I modify the URL without reloading the page?</a><a href="/questions/how-can-i-sort-arrays-and-data-in-php-1657384726665">How can I sort arrays and data in PHP?</a><a href="/questions/how-to-remove-the-space-between-inlineinline-block-elements-1657384532273">How to remove the space between inline/inline-block elements?</a><a href="/questions/convert-one-date-format-into-another-in-php-1657384566234">Convert one date format into another in PHP</a><a href="/questions/difference-between-sh-and-bash-1657388197713">Difference between sh and Bash</a><a href="/questions/transitions-on-the-css-display-property-1657387761601">Transitions on the CSS display property</a><a href="/questions/var-functionname-function()-vs-function-functionname()-1657384724077">var functionName = function() {} vs function functionName() {}</a><a href="/questions/how-to-extract-and-access-data-from-json-with-php-1657384483259">How to extract and access data from JSON with PHP?</a></div></div><span class="cursor-pointer text-lg p-2" style="position:fixed;bottom:20px;left:20px;background:#000;z-index:2000;color:white">Go go top</span></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"data":{"answer":["\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Script vs. Module\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Here\u0026apos;s an explanation.  The short version is that there is a big difference between directly running a Python file, and importing that file from somewhere else.  \u0026lt;strong\u0026gt;Just knowing what directory a file is in does not determine what package Python thinks it is in.\u0026lt;/strong\u0026gt;  That depends, additionally, on how you load the file into Python (by running or by importing).\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;There are two ways to load a Python file: as the top-level script, or as a\nmodule.  A file is loaded as the top-level script if you execute it directly, for instance by typing \u0026lt;code\u0026gt;python myfile.py\u0026lt;/code\u0026gt; on the command line.  It is loaded as a module when an \u0026lt;code\u0026gt;import\u0026lt;/code\u0026gt; statement is encountered inside some other file.  There can only be one top-level script at a time; the top-level script is the Python file you ran to start things off.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Naming\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;When a file is loaded, it is given a name (which is stored in its \u0026lt;code\u0026gt;__name__\u0026lt;/code\u0026gt; attribute).  If it was loaded as the top-level script, its name is \u0026lt;code\u0026gt;__main__\u0026lt;/code\u0026gt;.  If it was loaded as a module, its name is the filename, preceded by the names of any packages/subpackages of which it is a part, separated by dots.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;So for instance in your example:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;package/\n    __init__.py\n    subpackage1/\n        __init__.py\n        moduleX.py\n    moduleA.py\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;if you imported \u0026lt;code\u0026gt;moduleX\u0026lt;/code\u0026gt; (note: \u0026lt;em\u0026gt;imported\u0026lt;/em\u0026gt;, not directly executed), its name would be \u0026lt;code\u0026gt;package.subpackage1.moduleX\u0026lt;/code\u0026gt;.  If you imported \u0026lt;code\u0026gt;moduleA\u0026lt;/code\u0026gt;, its name would be \u0026lt;code\u0026gt;package.moduleA\u0026lt;/code\u0026gt;.  However, if you \u0026lt;em\u0026gt;directly run\u0026lt;/em\u0026gt; \u0026lt;code\u0026gt;moduleX\u0026lt;/code\u0026gt; from the command line, its name will instead be \u0026lt;code\u0026gt;__main__\u0026lt;/code\u0026gt;, and if you directly run \u0026lt;code\u0026gt;moduleA\u0026lt;/code\u0026gt; from the command line, its name will be \u0026lt;code\u0026gt;__main__\u0026lt;/code\u0026gt;.  When a module is run as the top-level script, it loses its normal name and its name is instead \u0026lt;code\u0026gt;__main__\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Accessing a module NOT through its containing package\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;There is an additional wrinkle: the module\u0026apos;s name depends on whether it was imported \u0026quot;directly\u0026quot; from the directory it is in or imported via a package.  This only makes a difference if you run Python in a directory, and try to import a file in that same directory (or a subdirectory of it).  For instance, if you start the Python interpreter in the directory \u0026lt;code\u0026gt;package/subpackage1\u0026lt;/code\u0026gt; and then do \u0026lt;code\u0026gt;import moduleX\u0026lt;/code\u0026gt;, the name of \u0026lt;code\u0026gt;moduleX\u0026lt;/code\u0026gt; will just be \u0026lt;code\u0026gt;moduleX\u0026lt;/code\u0026gt;, and not \u0026lt;code\u0026gt;package.subpackage1.moduleX\u0026lt;/code\u0026gt;.  This is because Python adds the current directory to its search path when the interpreter is entered interactively; if it finds the to-be-imported module in the current directory, it will not know that that directory is part of a package, and the package information will not become part of the module\u0026apos;s name.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;A special case is if you run the interpreter interactively (e.g., just type \u0026lt;code\u0026gt;python\u0026lt;/code\u0026gt; and start entering Python code on the fly).  In this case, the name of that interactive session is \u0026lt;code\u0026gt;__main__\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Now here is the crucial thing for your error message: \u0026lt;strong\u0026gt;if a module\u0026apos;s name has no dots, it is not considered to be part of a package\u0026lt;/strong\u0026gt;.  It doesn\u0026apos;t matter where the file actually is on disk.  All that matters is what its name is, and its name depends on how you loaded it.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Now look at the quote you included in your question:\u0026lt;/p\u0026gt;\n\u0026lt;blockquote\u0026gt;\n\u0026lt;p\u0026gt;Relative imports use a module\u0026apos;s name attribute to determine that module\u0026apos;s position in the package hierarchy. If the module\u0026apos;s name does not contain any package information (e.g. it is set to \u0026apos;main\u0026apos;) then relative imports are resolved as if the module were a top-level module, regardless of where the module is actually located on the file system.\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Relative imports...\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Relative imports use the module\u0026apos;s \u0026lt;em\u0026gt;name\u0026lt;/em\u0026gt; to determine where it is in a package.  When you use a relative import like \u0026lt;code\u0026gt;from .. import foo\u0026lt;/code\u0026gt;, the dots indicate to step up some number of levels in the package hierarchy.  For instance, if your current module\u0026apos;s name is \u0026lt;code\u0026gt;package.subpackage1.moduleX\u0026lt;/code\u0026gt;, then \u0026lt;code\u0026gt;..moduleA\u0026lt;/code\u0026gt; would mean \u0026lt;code\u0026gt;package.moduleA\u0026lt;/code\u0026gt;.  For a \u0026lt;code\u0026gt;from .. import\u0026lt;/code\u0026gt; to work, the module\u0026apos;s name must have at least as many dots as there are in the \u0026lt;code\u0026gt;import\u0026lt;/code\u0026gt; statement.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;... are only relative in a package\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;However, if your module\u0026apos;s name is \u0026lt;code\u0026gt;__main__\u0026lt;/code\u0026gt;, it is not considered to be in a package.  Its name has no dots, and therefore you cannot use \u0026lt;code\u0026gt;from .. import\u0026lt;/code\u0026gt; statements inside it.  If you try to do so, you will get the \u0026quot;relative-import in non-package\u0026quot; error.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Scripts can\u0026apos;t import relative\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;What you probably did is you tried to run \u0026lt;code\u0026gt;moduleX\u0026lt;/code\u0026gt; or the like from the command line.  When you did this, its name was set to \u0026lt;code\u0026gt;__main__\u0026lt;/code\u0026gt;, which means that relative imports within it will fail, because its name does not reveal that it is in a package. Note that this will also happen if you run Python from the same directory where a module is, and then try to import that module, because, as described above, Python will find the module in the current directory \u0026quot;too early\u0026quot; without realizing it is part of a package.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Also remember that when you run the interactive interpreter, the \u0026quot;name\u0026quot; of that interactive session is always \u0026lt;code\u0026gt;__main__\u0026lt;/code\u0026gt;.  Thus \u0026lt;strong\u0026gt;you cannot do relative imports directly from an interactive session\u0026lt;/strong\u0026gt;.  Relative imports are only for use within module files.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Two solutions:\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;ol\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;If you really do want to run \u0026lt;code\u0026gt;moduleX\u0026lt;/code\u0026gt; directly, but you still want it to be considered part of a package, you can do \u0026lt;code\u0026gt;python -m package.subpackage1.moduleX\u0026lt;/code\u0026gt;.  The \u0026lt;code\u0026gt;-m\u0026lt;/code\u0026gt; tells Python to load it as a module, not as the top-level script.\u0026lt;/p\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;Or perhaps you don\u0026apos;t actually want to \u0026lt;em\u0026gt;run\u0026lt;/em\u0026gt; \u0026lt;code\u0026gt;moduleX\u0026lt;/code\u0026gt;, you just want to run some other script, say \u0026lt;code\u0026gt;myfile.py\u0026lt;/code\u0026gt;, that \u0026lt;em\u0026gt;uses\u0026lt;/em\u0026gt; functions inside \u0026lt;code\u0026gt;moduleX\u0026lt;/code\u0026gt;.  If that is the case, put \u0026lt;code\u0026gt;myfile.py\u0026lt;/code\u0026gt; \u0026lt;em\u0026gt;somewhere else\u0026lt;/em\u0026gt;  \u0026lt;em\u0026gt;not\u0026lt;/em\u0026gt; inside the \u0026lt;code\u0026gt;package\u0026lt;/code\u0026gt; directory  and run it.  If inside \u0026lt;code\u0026gt;myfile.py\u0026lt;/code\u0026gt; you do things like \u0026lt;code\u0026gt;from package.moduleA import spam\u0026lt;/code\u0026gt;, it will work fine.\u0026lt;/p\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;/ol\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Notes\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;For either of these solutions, the package directory (\u0026lt;code\u0026gt;package\u0026lt;/code\u0026gt; in your example) must be accessible from the Python module search path (\u0026lt;code\u0026gt;sys.path\u0026lt;/code\u0026gt;).  If it is not, you will not be able to use anything in the package reliably at all.\u0026lt;/p\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;Since Python 2.6, the module\u0026apos;s \u0026quot;name\u0026quot; for package-resolution purposes is determined not just by its \u0026lt;code\u0026gt;__name__\u0026lt;/code\u0026gt; attributes but also by the \u0026lt;code\u0026gt;__package__\u0026lt;/code\u0026gt; attribute.  That\u0026apos;s why I\u0026apos;m avoiding using the explicit symbol \u0026lt;code\u0026gt;__name__\u0026lt;/code\u0026gt; to refer to the module\u0026apos;s \u0026quot;name\u0026quot;.  Since Python 2.6 a module\u0026apos;s \u0026quot;name\u0026quot; is effectively \u0026lt;code\u0026gt;__package__ + \u0026apos;.\u0026apos; + __name__\u0026lt;/code\u0026gt;, or just \u0026lt;code\u0026gt;__name__\u0026lt;/code\u0026gt; if \u0026lt;code\u0026gt;__package__\u0026lt;/code\u0026gt; is \u0026lt;code\u0026gt;None\u0026lt;/code\u0026gt;.)\u0026lt;/p\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n    ","\n\u0026lt;p\u0026gt;This is really a problem within python. \u0026lt;strong\u0026gt;The origin of confusion is that people mistakenly takes the relative import as path relative which is not.\u0026lt;/strong\u0026gt; \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;For example when you write in \u0026lt;em\u0026gt;faa.py\u0026lt;/em\u0026gt;:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;from\u0026lt;/span\u0026gt; .. \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;import\u0026lt;/span\u0026gt; foo\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;This has a meaning only if \u0026lt;em\u0026gt;faa.py\u0026lt;/em\u0026gt; was \u0026lt;em\u0026gt;identified and loaded\u0026lt;/em\u0026gt; by python, during execution, as a part of a package. In that case,the \u0026lt;strong\u0026gt;module\u0026apos;s name\u0026lt;/strong\u0026gt; \n for \u0026lt;em\u0026gt;faa.py\u0026lt;/em\u0026gt; would be for example \u0026lt;em\u0026gt;some_packagename.faa\u0026lt;/em\u0026gt;. If the file was loaded just because it is in the current directory, when python is run, then its name would not refer to any package and eventually relative import would fail. \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;A simple solution to refer modules in the current directory, is to use this:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; __package__ \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;is\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;None\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;or\u0026lt;/span\u0026gt; __package__ == \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;\u0026apos;\u0026lt;/span\u0026gt;:\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;# uses current directory visibility\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;import\u0026lt;/span\u0026gt; foo\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;else\u0026lt;/span\u0026gt;:\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;# uses current package visibility\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;from\u0026lt;/span\u0026gt; . \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;import\u0026lt;/span\u0026gt; foo\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;So after carping about this along with many others, I came across a note posted by \u0026lt;a href=\u0026quot;https://stackoverflow.com/users/5420054/dorian-b\u0026quot;\u0026gt;Dorian B\u0026lt;/a\u0026gt; in this \u0026lt;a href=\u0026quot;https://stackoverflow.com/questions/5286210/is-there-a-way-to-access-parent-modules-in-python\u0026quot;\u0026gt;article\u0026lt;/a\u0026gt; that solved the specific problem I was having where I would develop modules and classes for use with a web service, but I also want to be able to test them as I\u0026apos;m coding, using the debugger facilities in PyCharm. To run tests in a self-contained class, I would include the following at the end of my class file:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; __name__ == \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;__main__\u0026apos;\u0026lt;/span\u0026gt;:\n   \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;# run test code here...\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;but if I wanted to import other classes or modules in the same folder, I would then have to change all my import statements from relative notation to local references (i.e. remove the dot (.))  But after reading Dorian\u0026apos;s suggestion, I tried his \u0026apos;one-liner\u0026apos; and it worked!  I can now test in PyCharm and leave my test code in place when I use the class in another class under test, or when I use it in my web service!\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;# import any site-lib modules first, then...\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;import\u0026lt;/span\u0026gt; sys\nparent_module = sys.modules[\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;.\u0026apos;\u0026lt;/span\u0026gt;.join(__name__.split(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;.\u0026apos;\u0026lt;/span\u0026gt;)[:-\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;]) \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;or\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;__main__\u0026apos;\u0026lt;/span\u0026gt;]\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; __name__ == \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;__main__\u0026apos;\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;or\u0026lt;/span\u0026gt; parent_module.__name__ == \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;__main__\u0026apos;\u0026lt;/span\u0026gt;:\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;from\u0026lt;/span\u0026gt; codex \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;import\u0026lt;/span\u0026gt; Codex \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;# these are in same folder as module under test!\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;from\u0026lt;/span\u0026gt; dblogger \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;import\u0026lt;/span\u0026gt; DbLogger\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;else\u0026lt;/span\u0026gt;:\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;from\u0026lt;/span\u0026gt; .codex \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;import\u0026lt;/span\u0026gt; Codex\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;from\u0026lt;/span\u0026gt; .dblogger \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;import\u0026lt;/span\u0026gt; DbLogger\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;The if statement checks to see if we\u0026apos;re running this module as \u0026lt;strong\u0026gt;main\u0026lt;/strong\u0026gt; or if it\u0026apos;s being used in another module that\u0026apos;s being tested as \u0026lt;strong\u0026gt;main\u0026lt;/strong\u0026gt;.  Perhaps this is obvious, but I offer this note here in case anyone else frustrated by the relative import issues above can make use of it.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;There are too much too long anwers in a foreign language. So I\u0026apos;ll try to make it short.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;If you write \u0026lt;code\u0026gt;from . import module\u0026lt;/code\u0026gt;, opposite to  what you think, \u0026lt;code\u0026gt;module\u0026lt;/code\u0026gt; will not be imported from current directory, but from the top level of your package! If you run .py file as a script, it simply doesn\u0026apos;t know where the top level is and thus refuses to work.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;If you start it like this \u0026lt;code\u0026gt;py -m package.module\u0026lt;/code\u0026gt; from the directory above \u0026lt;code\u0026gt;package\u0026lt;/code\u0026gt;, then python knows where the top level is. That\u0026apos;s very similar to java: \u0026lt;code\u0026gt;java -cp bin_directory package.class\u0026lt;/code\u0026gt;\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Here\u0026apos;s a general recipe, modified to fit as an example, that I am using right now for dealing with Python libraries written as packages, that contain interdependent files, where I want to be able to test parts of them piecemeal.  Let\u0026apos;s call this \u0026lt;code\u0026gt;lib.foo\u0026lt;/code\u0026gt; and say that it needs access to \u0026lt;code\u0026gt;lib.fileA\u0026lt;/code\u0026gt; for functions \u0026lt;code\u0026gt;f1\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;f2\u0026lt;/code\u0026gt;, and \u0026lt;code\u0026gt;lib.fileB\u0026lt;/code\u0026gt; for class \u0026lt;code\u0026gt;Class3\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;I have included a few \u0026lt;code\u0026gt;print\u0026lt;/code\u0026gt; calls to help illustrate how this works.  In practice you would want to remove them (and maybe also the \u0026lt;code\u0026gt;from __future__ import print_function\u0026lt;/code\u0026gt; line).\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;This particular example is too simple to show when we really need to insert an entry into \u0026lt;code\u0026gt;sys.path\u0026lt;/code\u0026gt;.  (See \u0026lt;a href=\u0026quot;https://stackoverflow.com/a/38455936/1256452\u0026quot;\u0026gt;Lars\u0026apos; answer\u0026lt;/a\u0026gt; for a case where we \u0026lt;em\u0026gt;do\u0026lt;/em\u0026gt; need it, when we have two or more levels of package directories, and then we use \u0026lt;code\u0026gt;os.path.dirname(os.path.dirname(__file__))\u0026lt;/code\u0026gt;but it doesn\u0026apos;t really \u0026lt;em\u0026gt;hurt\u0026lt;/em\u0026gt; here either.)  It\u0026apos;s also safe enough to do this without the \u0026lt;code\u0026gt;if _i in sys.path\u0026lt;/code\u0026gt; test.  However, if each imported file inserts the same pathfor instance, if both \u0026lt;code\u0026gt;fileA\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;fileB\u0026lt;/code\u0026gt; want to import utilities from the packagethis clutters up \u0026lt;code\u0026gt;sys.path\u0026lt;/code\u0026gt; with the same path many times, so it\u0026apos;s nice to have the \u0026lt;code\u0026gt;if _i not in sys.path\u0026lt;/code\u0026gt; in the boilerplate.\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;from\u0026lt;/span\u0026gt; __future__ \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;import\u0026lt;/span\u0026gt; print_function \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;# only when showing how this works\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; __package__:\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;Package named {!r}; __name__ is {!r}\u0026apos;\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;format\u0026lt;/span\u0026gt;(__package__, __name__))\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;from\u0026lt;/span\u0026gt; .fileA \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;import\u0026lt;/span\u0026gt; f1, f2\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;from\u0026lt;/span\u0026gt; .fileB \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;import\u0026lt;/span\u0026gt; Class3\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;else\u0026lt;/span\u0026gt;:\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;Not a package; __name__ is {!r}\u0026apos;\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;format\u0026lt;/span\u0026gt;(__name__))\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;# these next steps should be used only with care and if needed\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;# (remove the sys.path manipulation for simple cases!)\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;import\u0026lt;/span\u0026gt; os, sys\n    _i = os.path.dirname(os.path.abspath(__file__))\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; _i \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;not\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;in\u0026lt;/span\u0026gt; sys.path:\n        \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;inserting {!r} into sys.path\u0026apos;\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;format\u0026lt;/span\u0026gt;(_i))\n        sys.path.insert(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;, _i)\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;else\u0026lt;/span\u0026gt;:\n        \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;{!r} is already in sys.path\u0026apos;\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;format\u0026lt;/span\u0026gt;(_i))\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;del\u0026lt;/span\u0026gt; _i \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;# clean up global name space\u0026lt;/span\u0026gt;\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;from\u0026lt;/span\u0026gt; fileA \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;import\u0026lt;/span\u0026gt; f1, f2\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;from\u0026lt;/span\u0026gt; fileB \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;import\u0026lt;/span\u0026gt; Class3\n\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;... \u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;all\u0026lt;/span\u0026gt; the code \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;as\u0026lt;/span\u0026gt; usual ...\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; __name__ == \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;__main__\u0026apos;\u0026lt;/span\u0026gt;:\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;import\u0026lt;/span\u0026gt; doctest, sys\n    ret = doctest.testmod()\n    sys.exit(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; ret.failed == \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;else\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;)\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;The idea here is this (and note that these all function the same across python2.7 and python 3.x):\u0026lt;/p\u0026gt;\n\u0026lt;ol\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;If run as \u0026lt;code\u0026gt;import lib\u0026lt;/code\u0026gt; or \u0026lt;code\u0026gt;from lib import foo\u0026lt;/code\u0026gt; as a regular package import from ordinary code, \u0026lt;code\u0026gt;__package\u0026lt;/code\u0026gt; is \u0026lt;code\u0026gt;lib\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;__name__\u0026lt;/code\u0026gt; is \u0026lt;code\u0026gt;lib.foo\u0026lt;/code\u0026gt;.  We take the first code path, importing from \u0026lt;code\u0026gt;.fileA\u0026lt;/code\u0026gt;, etc.\u0026lt;/p\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;If run as \u0026lt;code\u0026gt;python lib/foo.py\u0026lt;/code\u0026gt;, \u0026lt;code\u0026gt;__package__\u0026lt;/code\u0026gt; will be None and \u0026lt;code\u0026gt;__name__\u0026lt;/code\u0026gt; will be \u0026lt;code\u0026gt;__main__\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;We take the second code path.  The \u0026lt;code\u0026gt;lib\u0026lt;/code\u0026gt; directory will already be in \u0026lt;code\u0026gt;sys.path\u0026lt;/code\u0026gt; so there is no need to add it.  We import from \u0026lt;code\u0026gt;fileA\u0026lt;/code\u0026gt;, etc.\u0026lt;/p\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;If run within the \u0026lt;code\u0026gt;lib\u0026lt;/code\u0026gt; directory as \u0026lt;code\u0026gt;python foo.py\u0026lt;/code\u0026gt;, the behavior is the same as for case 2.\u0026lt;/p\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;If run within the \u0026lt;code\u0026gt;lib\u0026lt;/code\u0026gt; directory as \u0026lt;code\u0026gt;python -m foo\u0026lt;/code\u0026gt;, the behavior is similar to cases 2 and 3.  However, the path to the \u0026lt;code\u0026gt;lib\u0026lt;/code\u0026gt; directory is not in \u0026lt;code\u0026gt;sys.path\u0026lt;/code\u0026gt;, so we add it before importing.  The same applies if we run Python and then \u0026lt;code\u0026gt;import foo\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;(Since \u0026lt;code\u0026gt;.\u0026lt;/code\u0026gt; \u0026lt;em\u0026gt;is\u0026lt;/em\u0026gt; in \u0026lt;code\u0026gt;sys.path\u0026lt;/code\u0026gt;, we don\u0026apos;t really need to add the absolute version of the path here.  This is where a deeper package nesting structure, where we want to do \u0026lt;code\u0026gt;from ..otherlib.fileC import ...\u0026lt;/code\u0026gt;, makes a difference.  If you\u0026apos;re not doing this, you can omit all the \u0026lt;code\u0026gt;sys.path\u0026lt;/code\u0026gt; manipulation entirely.)\u0026lt;/p\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;/ol\u0026gt;\n\u0026lt;h3\u0026gt;Notes\u0026lt;/h3\u0026gt;\n\u0026lt;p\u0026gt;There is still a quirk.  If you run this whole thing from outside:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;$ python2 lib.foo\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;or:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;$ python3 lib.foo\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;the behavior depends on the contents of \u0026lt;code\u0026gt;lib/__init__.py\u0026lt;/code\u0026gt;.  If that exists and \u0026lt;em\u0026gt;is empty\u0026lt;/em\u0026gt;, all is well:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;Package named \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;lib\u0026apos;\u0026lt;/span\u0026gt;; __name__ \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;is\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;__main__\u0026apos;\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;But if \u0026lt;code\u0026gt;lib/__init__.py\u0026lt;/code\u0026gt; \u0026lt;em\u0026gt;itself\u0026lt;/em\u0026gt; imports \u0026lt;code\u0026gt;routine\u0026lt;/code\u0026gt; so that it can export \u0026lt;code\u0026gt;routine.name\u0026lt;/code\u0026gt; directly as \u0026lt;code\u0026gt;lib.name\u0026lt;/code\u0026gt;, you get:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;$ python2 lib.foo\nPackage named \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;lib\u0026apos;\u0026lt;/span\u0026gt;; __name__ \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;is\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;lib.foo\u0026apos;\u0026lt;/span\u0026gt;\nPackage named \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;lib\u0026apos;\u0026lt;/span\u0026gt;; __name__ \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;is\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;__main__\u0026apos;\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;That is, the module gets imported twice, once via the package and then again as \u0026lt;code\u0026gt;__main__\u0026lt;/code\u0026gt; so that it runs your \u0026lt;code\u0026gt;main\u0026lt;/code\u0026gt; code.  Python 3.6 and later warn about this:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;$ python3 lib.routine\nPackage named \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;lib\u0026apos;\u0026lt;/span\u0026gt;; __name__ \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;is\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;lib.foo\u0026apos;\u0026lt;/span\u0026gt;\n[...]/runpy.py:\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;125\u0026lt;/span\u0026gt;: RuntimeWarning: \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;lib.foo\u0026apos;\u0026lt;/span\u0026gt; found \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;in\u0026lt;/span\u0026gt; sys.modules\nafter \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;import\u0026lt;/span\u0026gt; of package \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;lib\u0026apos;\u0026lt;/span\u0026gt;, but prior to execution of \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;lib.foo\u0026apos;\u0026lt;/span\u0026gt;;\nthis may result \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;in\u0026lt;/span\u0026gt; unpredictable behaviour\n  warn(RuntimeWarning(msg))\nPackage named \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;lib\u0026apos;\u0026lt;/span\u0026gt;; __name__ \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;is\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;__main__\u0026apos;\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;The \u0026lt;em\u0026gt;warning\u0026lt;/em\u0026gt; is new, but the warned-about behavior is not.  It is part of what some call \u0026lt;a href=\u0026quot;http://python-notes.curiousefficiency.org/en/latest/python_concepts/import_traps.html#the-double-import-trap\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;the double import trap\u0026lt;/a\u0026gt;.  (For additional details see \u0026lt;a href=\u0026quot;https://bugs.python.org/issue27487\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;issue 27487\u0026lt;/a\u0026gt;.)  Nick Coghlan says:\u0026lt;/p\u0026gt;\n\u0026lt;blockquote\u0026gt;\n\u0026lt;p\u0026gt;This next trap exists in all current versions of Python, including 3.3, and can be summed up in the following general guideline: \u0026quot;Never add a package directory, or any directory inside a package, directly to the Python path\u0026quot;.\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\u0026lt;p\u0026gt;Note that while we violate that rule here, we do it \u0026lt;em\u0026gt;only\u0026lt;/em\u0026gt; when the file being loaded is \u0026lt;em\u0026gt;not\u0026lt;/em\u0026gt; being loaded as part of a package, and our modification is specifically designed to allow us to access other files in that package.  (And, as I noted, we probably shouldn\u0026apos;t do this at all for single level packages.)  If we wanted to be extra-clean, we might rewrite this as, e.g.:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;import\u0026lt;/span\u0026gt; os, sys\n    _i = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; _i \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;not\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;in\u0026lt;/span\u0026gt; sys.path:\n        sys.path.insert(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;, _i)\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;else\u0026lt;/span\u0026gt;:\n        _i = \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;None\u0026lt;/span\u0026gt;\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;from\u0026lt;/span\u0026gt; sub.fileA \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;import\u0026lt;/span\u0026gt; f1, f2\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;from\u0026lt;/span\u0026gt; sub.fileB \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;import\u0026lt;/span\u0026gt; Class3\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; _i:\n        sys.path.remove(_i)\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;del\u0026lt;/span\u0026gt; _i\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;That is, we modify \u0026lt;code\u0026gt;sys.path\u0026lt;/code\u0026gt; long enough to achieve our imports, then put it back the way it was (deleting one copy of \u0026lt;code\u0026gt;_i\u0026lt;/code\u0026gt; if and only if we added one copy of \u0026lt;code\u0026gt;_i\u0026lt;/code\u0026gt;).\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Here is one solution that I would not recommend, but might be useful in some situations where modules were simply not generated:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;import\u0026lt;/span\u0026gt; os\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;import\u0026lt;/span\u0026gt; sys\nparent_dir_name = os.path.dirname(os.path.dirname(os.path.realpath(__file__)))\nsys.path.append(parent_dir_name + \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;/your_dir\u0026quot;\u0026lt;/span\u0026gt;)\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;import\u0026lt;/span\u0026gt; your_script\nyour_script.a_function()\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;@BrenBarn\u0026apos;s answer says it all, but if you\u0026apos;re like me it might take a while to understand.  Here\u0026apos;s my case and how @BrenBarn\u0026apos;s answer applies to it, perhaps it will help you.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;The case\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;package/\n    __init__.py\n    subpackage1/\n        __init__.py\n        moduleX.py\n    moduleA.py\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Using our familiar example, and add to it that moduleX.py has a relative import to ..moduleA.  Given that I tried writing a test script in the subpackage1 directory that imported moduleX, but then got the dreaded error described by the OP.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Solution\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Move test script to the same level as package and import package.subpackage1.moduleX\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Explanation\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;As explained, relative imports are made relative to the current name.  When my test script imports moduleX from the same directory, then module name inside moduleX is moduleX.  When it encounters a relative import the interpreter can\u0026apos;t back up the package hierarchy because it\u0026apos;s already at the top\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;When I import moduleX from above, then name inside moduleX is package.subpackage1.moduleX and the relative import can be found\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;I had a similar problem where I didn\u0026apos;t want to change the Python module search \npath and needed to load a module relatively \u0026lt;em\u0026gt;from a script\u0026lt;/em\u0026gt; (in spite of \u0026lt;em\u0026gt;\u0026quot;scripts can\u0026apos;t import relative with all\u0026quot;\u0026lt;/em\u0026gt; as BrenBarn explained nicely above).\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;So I used the following hack. Unfortunately, it relies on the \u0026lt;code\u0026gt;imp\u0026lt;/code\u0026gt; module that \nbecame deprecated since version 3.4 to be dropped in favour of \u0026lt;code\u0026gt;importlib\u0026lt;/code\u0026gt;.\n(Is this possible with \u0026lt;code\u0026gt;importlib\u0026lt;/code\u0026gt;, too? I don\u0026apos;t know.) Still, the hack works for now.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Example for accessing members of \u0026lt;code\u0026gt;moduleX\u0026lt;/code\u0026gt; in \u0026lt;code\u0026gt;subpackage1\u0026lt;/code\u0026gt; from a script residing in the \u0026lt;code\u0026gt;subpackage2\u0026lt;/code\u0026gt; folder:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;#!/usr/bin/env python3\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;import\u0026lt;/span\u0026gt; inspect\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;import\u0026lt;/span\u0026gt; imp\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;import\u0026lt;/span\u0026gt; os\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;def\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;get_script_dir\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;follow_symlinks=\u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;True\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;):\n    \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;\u0026quot;\u0026quot;\n    Return directory of code defining this very function.\n    Should work from a module as well as from a script.\n    \u0026quot;\u0026quot;\u0026quot;\u0026lt;/span\u0026gt;\n    script_path = inspect.getabsfile(get_script_dir)\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; follow_symlinks:\n        script_path = os.path.realpath(script_path)\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; os.path.dirname(script_path)\n\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;# loading the module (hack, relying on deprecated imp-module)\u0026lt;/span\u0026gt;\nPARENT_PATH = os.path.dirname(get_script_dir())\n(x_file, x_path, x_desc) = imp.find_module(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;moduleX\u0026apos;\u0026lt;/span\u0026gt;, [PARENT_PATH+\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;/\u0026apos;\u0026lt;/span\u0026gt;+\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;subpackage1\u0026apos;\u0026lt;/span\u0026gt;])\nmodule_x = imp.load_module(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;subpackage1.moduleX\u0026apos;\u0026lt;/span\u0026gt;, x_file, x_path, x_desc)\n\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;# importing a function and a value\u0026lt;/span\u0026gt;\nfunction = module_x.my_function\nVALUE = module_x.MY_CONST\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;A cleaner approach seems to be to modify the sys.path used for loading modules as mentioned by Federico.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;#!/usr/bin/env python3\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; __name__ == \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;__main__\u0026apos;\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;and\u0026lt;/span\u0026gt; __package__ \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;is\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;None\u0026lt;/span\u0026gt;:\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;from\u0026lt;/span\u0026gt; os \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;import\u0026lt;/span\u0026gt; sys, path\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;# __file__ should be defined in this case\u0026lt;/span\u0026gt;\n    PARENT_DIR = path.dirname(path.dirname(path.abspath(__file__)))\n   sys.path.append(PARENT_DIR)\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;from\u0026lt;/span\u0026gt; subpackage1.moduleX \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;import\u0026lt;/span\u0026gt; *\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;\u0026lt;code\u0026gt;__name__\u0026lt;/code\u0026gt; changes depending on whether the code in question is run in the global namespace or as part of an imported module.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;If the code is not running in the global space, \u0026lt;code\u0026gt;__name__\u0026lt;/code\u0026gt; will be the name of the module. If it is running in global namespace -- for example, if you type it into a console, or run the module as a script using \u0026lt;code\u0026gt;python.exe yourscriptnamehere.py\u0026lt;/code\u0026gt; then \u0026lt;code\u0026gt;__name__\u0026lt;/code\u0026gt; becomes \u0026lt;code\u0026gt;\u0026quot;__main__\u0026quot;\u0026lt;/code\u0026gt;.  \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;You\u0026apos;ll see a lot of python code with  \u0026lt;code\u0026gt;if __name__ == \u0026apos;__main__\u0026apos;\u0026lt;/code\u0026gt; is used to test whether the code is being run from the global namespace  that allows you to have a module that doubles as a script. \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Did you try to do these imports from the console? \u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Following up on what Lars has suggested I\u0026apos;ve wrapped this approach in an experimental, new import library: \u0026lt;a href=\u0026quot;https://github.com/ronny-rentner/ultraimport\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;ultraimport\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;It gives the programmer more control over imports and it allows file system based imports. Therefore, you can do relative imports from scripts. Parent package not necessary. ultraimports will always work, no matter how you run your code or what is your current working directory because ultraimport makes imports unambiguous. You don\u0026apos;t need to change sys.path and also you don\u0026apos;t need a try/except block to sometimes do relative imports and sometimes absolute.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;You would then write in somefile.py something like:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;import\u0026lt;/span\u0026gt; ultraimport\nfoo = ultraimport(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;__dir__/foo.py\u0026apos;\u0026lt;/span\u0026gt;)\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;__dir__ is the directory of somefile.py, the caller of ultraimport(). foo.py would live in the same directory as somefile.py.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;One caveat when importing scripts like this is if they contain further relative imports. ultraimport has a builtin preprocessor to rewrite subsequent relative imports to ultraimports so they continue to work. Though, this is currently somewhat limited as original Python imports are ambiguous and there\u0026apos;s only so much you can do about it.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;Relative imports use a module\u0026apos;s name attribute to determine that module\u0026apos;s position in the package hierarchy. If the module\u0026apos;s name does not contain any package information (e.g. it is set to \u0026apos;main\u0026apos;) then relative imports are resolved as if the module were a top level module, regardless of where the module is actually located on the file system.\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;p\u0026gt;Wrote a little python package to PyPi that might help viewers of this question. The package acts as workaround if one wishes to be able to run python files containing imports containing upper level packages from within a package / project without being directly in the importing file\u0026apos;s directory. \u0026lt;a href=\u0026quot;https://pypi.org/project/import-anywhere/\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;https://pypi.org/project/import-anywhere/\u0026lt;/a\u0026gt; \u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;In most cases when I see the \u0026lt;code\u0026gt;ValueError: attempted relative import beyond top-level package\u0026lt;/code\u0026gt; and pull my hair out, the solution is as follows:\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;You need to \u0026lt;strong\u0026gt;step one level higher\u0026lt;/strong\u0026gt; in the file hierarchy!\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;#dir/package/module1/foo.py\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;#dir/package/module2/bar.py\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;from\u0026lt;/span\u0026gt; ..module1 \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;import\u0026lt;/span\u0026gt; foo\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;Importing \u0026lt;code\u0026gt;bar.py\u0026lt;/code\u0026gt; when interpreter is started in \u0026lt;code\u0026gt;dir/package/\u0026lt;/code\u0026gt; will result in error despite the import process never going beyond your current directory.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Importing \u0026lt;code\u0026gt;bar.py\u0026lt;/code\u0026gt; when interpreter is started in \u0026lt;code\u0026gt;dir/\u0026lt;/code\u0026gt; will succeed.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Similarly for unit tests:\n\u0026lt;code\u0026gt;python3 -m unittest discover --start-directory=.\u0026lt;/code\u0026gt; successfully works from \u0026lt;code\u0026gt;dir/\u0026lt;/code\u0026gt;, but not from \u0026lt;code\u0026gt;dir/package/\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n    "],"id":365,"title":"Relative imports for the billionth time","content":"\n                \n\u0026lt;p\u0026gt;I\u0026apos;ve been here:\u0026lt;/p\u0026gt;\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;a href=\u0026quot;http://www.python.org/dev/peps/pep-0328/\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;http://www.python.org/dev/peps/pep-0328/\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;a href=\u0026quot;http://docs.python.org/2/tutorial/modules.html#packages\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;http://docs.python.org/2/tutorial/modules.html#packages\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;a href=\u0026quot;https://stackoverflow.com/questions/10059002/python-packages-relative-imports\u0026quot;\u0026gt;Python packages: relative imports\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;a href=\u0026quot;https://stackoverflow.com/questions/9123062/python-relative-import-example-code-does-not-work\u0026quot;\u0026gt;python relative import example code does not work\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;a href=\u0026quot;https://stackoverflow.com/questions/8299270/ultimate-answer-to-relative-python-imports\u0026quot;\u0026gt;Relative imports in python 2.5\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;a href=\u0026quot;https://stackoverflow.com/questions/4175534/relative-imports-in-python\u0026quot;\u0026gt;Relative imports in Python\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;a href=\u0026quot;https://stackoverflow.com/questions/13233931/python-disabling-relative-import?rq=1\u0026quot;\u0026gt;Python: Disabling relative import\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;p\u0026gt;and plenty of URLs that I did not copy, some on SO, some on other sites, back when I thought I\u0026apos;d have the solution quickly.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;The forever-recurring question is this: how do I solve this \u0026quot;Attempted relative import in non-package\u0026quot; message?\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;ImportError: attempted relative \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;import\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;with\u0026lt;/span\u0026gt; no known parent package\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;I built an exact replica of the package on pep-0328:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;package/\n    __init__.py\n    subpackage1/\n        __init__.py\n        moduleX.py\n        moduleY.py\n    subpackage2/\n        __init__.py\n        moduleZ.py\n    moduleA.py\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;The imports were done from the console.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;I did make functions named spam and eggs in their appropriate modules.  Naturally, it didn\u0026apos;t work.  The answer is apparently in the 4th URL I listed, but it\u0026apos;s all alumni to me. There was this response on one of the URLs I visited:\u0026lt;/p\u0026gt;\n\u0026lt;blockquote\u0026gt;\n\u0026lt;p\u0026gt;Relative imports use a module\u0026apos;s name attribute to determine that module\u0026apos;s position in the package hierarchy. If the module\u0026apos;s name does not contain any package information (e.g. it is set to \u0026apos;main\u0026apos;) then relative imports are resolved as if the module were a top level module, regardless of where the module is actually located on the file system.\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\u0026lt;p\u0026gt;The above response looks promising, but it\u0026apos;s all hieroglyphs to me.  So my question, how do I make Python not return to me \u0026quot;Attempted relative import in non-package\u0026quot;? has an answer that involves -m, supposedly.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Can somebody please tell me why Python gives that error message, what it means by \u0026quot;non-package\u0026quot;, why and how do you define a \u0026apos;package\u0026apos;, and \u0026lt;em\u0026gt;the precise answer put in terms easy enough for a kindergartener to understand\u0026lt;/em\u0026gt;.\u0026lt;/p\u0026gt;\n    ","slug":"relative-imports-for-the-billionth-time-1657387756383","postType":"QUESTION","createdAt":"2022-07-09T17:29:16.000Z","updatedAt":"2022-07-09T17:29:16.000Z","tags":[{"id":2021,"name":"import","slug":"import","createdAt":"2022-07-09T17:29:16.000Z","updatedAt":"2022-07-09T17:29:16.000Z","Questions_Tags":{"questionId":365,"tagId":2021}},{"id":2022,"name":"relative-path","slug":"relative-path","createdAt":"2022-07-09T17:29:16.000Z","updatedAt":"2022-07-09T17:29:16.000Z","Questions_Tags":{"questionId":365,"tagId":2022}},{"id":2023,"name":"python-packaging","slug":"python-packaging","createdAt":"2022-07-09T17:29:16.000Z","updatedAt":"2022-07-09T17:29:16.000Z","Questions_Tags":{"questionId":365,"tagId":2023}},{"id":2024,"name":"relative-import","slug":"relative-import","createdAt":"2022-07-09T17:29:16.000Z","updatedAt":"2022-07-09T17:29:16.000Z","Questions_Tags":{"questionId":365,"tagId":2024}}],"relatedQuestions":[{"title":"Relative imports for the billionth time","slug":"relative-imports-for-the-billionth-time-1657387756383","tags":[{"name":"import","Questions_Tags":{"questionId":365,"tagId":2021}},{"name":"relative-path","Questions_Tags":{"questionId":365,"tagId":2022}},{"name":"python-packaging","Questions_Tags":{"questionId":365,"tagId":2023}},{"name":"relative-import","Questions_Tags":{"questionId":365,"tagId":2024}}]}]},"randomQuestions":[{"title":"How do I return the response from an asynchronous call?","slug":"how-do-i-return-the-response-from-an-asynchronous-call-1657384208012"},{"title":"Why does my function that calls an API or launches a coroutine return an empty or null value?","slug":"why-does-my-function-that-calls-an-api-or-launches-a-coroutine-return-an-empty-or-null-value-1657388483820"},{"title":"What is the `self` parameter in class methods?","slug":"what-is-the-self-parameter-in-class-methods-1657387518448"},{"title":"How do you use a variable in a regular expression?","slug":"how-do-you-use-a-variable-in-a-regular-expression-1657387939007"},{"title":"How to use java.util.Scanner to correctly read user input from System.in and act on it?","slug":"how-to-use-java.util.scanner-to-correctly-read-user-input-from-system.in-and-act-on-it-1657388546306"},{"title":"How to use variables in SQL statement in Python?","slug":"how-to-use-variables-in-sql-statement-in-python-1657388479077"},{"title":"Convert form data to JavaScript object with jQuery","slug":"convert-form-data-to-javascript-object-with-jquery-1657388036834"},{"title":"How to remove \"noise\" from GCC/clang assembly output?","slug":"how-to-remove-\"noise\"-from-gccclang-assembly-output-1657387612391"},{"title":"Why is using 'eval' a bad practice?","slug":"why-is-using-'eval'-a-bad-practice-1657387348760"},{"title":"Sorting an array of objects by property values","slug":"sorting-an-array-of-objects-by-property-values-1657387447490"},{"title":"How to remove items from a list while iterating?","slug":"how-to-remove-items-from-a-list-while-iterating-1657384496375"},{"title":"Short description of the scoping rules?","slug":"short-description-of-the-scoping-rules-1657384853121"},{"title":"How do I modify the URL without reloading the page?","slug":"how-do-i-modify-the-url-without-reloading-the-page-1657387509731"},{"title":"How can I sort arrays and data in PHP?","slug":"how-can-i-sort-arrays-and-data-in-php-1657384726665"},{"title":"How to remove the space between inline/inline-block elements?","slug":"how-to-remove-the-space-between-inlineinline-block-elements-1657384532273"},{"title":"Convert one date format into another in PHP","slug":"convert-one-date-format-into-another-in-php-1657384566234"},{"title":"Difference between sh and Bash","slug":"difference-between-sh-and-bash-1657388197713"},{"title":"Transitions on the CSS display property","slug":"transitions-on-the-css-display-property-1657387761601"},{"title":"var functionName = function() {} vs function functionName() {}","slug":"var-functionname-function()-vs-function-functionname()-1657384724077"},{"title":"How to extract and access data from JSON with PHP?","slug":"how-to-extract-and-access-data-from-json-with-php-1657384483259"}]},"__N_SSG":true},"page":"/questions/[slug]","query":{"slug":"relative-imports-for-the-billionth-time-1657387756383"},"buildId":"xZs8haGjOP63QuDE0kxeX","isFallback":false,"gsp":true,"locale":"en","locales":["en"],"defaultLocale":"en","scriptLoader":[]}</script></body></html>