<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><meta name="twitter:card" content="summary_large_image"/><meta name="twitter:site" content="@solutionschecker.com"/><meta name="twitter:creator" content="@solutionschecker.com"/><meta property="og:url" content="https://solutionschecker.com"/><meta property="og:type" content="website"/><meta property="og:image" content="https://solutionschecker.com/solutions-checker-banner.png"/><meta property="og:image:alt" content="Find the solution to any question. We focus on finding the fastest possible solution for users. Main topics like coding, learning. - solutionschecker.com"/><link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png"/><link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png"/><link rel="manifest" href="/site.webmanifest"/><script type="application/ld+json">{"@context":"https://schema.org","@type":"Organization","logo":"/logo.svg","url":"https://solutionschecker.com"}</script><link name="keywords" content="template-meta-programming,sfinae,solutions checker, solution checker, how to, solution for, check for solution, resolve question, what is, what solution for, find solution"/><script type="application/ld+json">{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"item":{"@id":"https://solutionschecker.com","name":"Home"}},{"@type":"ListItem","position":2,"item":{"@id":"https://solutionschecker.com/questions","name":"Questions"}},{"@type":"ListItem","position":3,"item":{"@id":"https://solutionschecker.com/questions/templated-check-for-the-existence-of-a-class-member-function-1657388363414","name":"Questions"}}]}</script><title>Templated check for the existence of a class member function? | Solution Checker</title><meta name="robots" content="index,follow"/><meta name="description" content="Is it possible to write a template that changes behavior depending on if a certain member function is defined on a class?

Here&#x27;s a simple example of what I would want to write:

template&lt;class T&gt;
std::string optionalToString(T* obj)
{
    if (FUNCTION_EXISTS(T-&gt;toString))
        return obj-&gt;toString();
    else
        return &quot;toString not defined&quot;;
}


So, if class T has toString() defined, then it uses it; otherwise, it doesn&#x27;t. The magical part that I don&#x27;t know how to do is the &quot;FUNCTION_EXISTS&quot; part.
    "/><meta property="og:title" content="Templated check for the existence of a class member function? | Solution Checker"/><meta property="og:description" content="Is it possible to write a template that changes behavior depending on if a certain member function is defined on a class?

Here&#x27;s a simple example of what I would want to write:

template&lt;class T&gt;
std::string optionalToString(T* obj)
{
    if (FUNCTION_EXISTS(T-&gt;toString))
        return obj-&gt;toString();
    else
        return &quot;toString not defined&quot;;
}


So, if class T has toString() defined, then it uses it; otherwise, it doesn&#x27;t. The magical part that I don&#x27;t know how to do is the &quot;FUNCTION_EXISTS&quot; part.
    "/><script type="application/ld+json">{"@context":"https://schema.org","@type":"QAPage","mainEntity":{"name":"Templated check for the existence of a class member function?","text":"Is it possible to write a template that changes behavior depending on if a certain member function is defined on a class?\n\nHere&apos;s a simple example of what I would want to write:\n\ntemplate&lt;class T&gt;\nstd::string optionalToString(T* obj)\n{\n    if (FUNCTION_EXISTS(T-&gt;toString))\n        return obj-&gt;toString();\n    else\n        return &quot;toString not defined&quot;;\n}\n\n\nSo, if class T has toString() defined, then it uses it; otherwise, it doesn&apos;t. The magical part that I don&apos;t know how to do is the &quot;FUNCTION_EXISTS&quot; part.\n    ","answerCount":30,"upVoteCount":500,"suggestedAnswer":[{"text":"Yes, with SFINAE you can check if a given class does provide a certain method. Here&apos;s the working code:\n#include &lt;iostream&gt;\n\nstruct Hello\n{\n    int helloworld() { return 0; }\n};\n\nstruct Generic {};    \n\n// SFINAE test\ntemplate &lt;typename T&gt;\nclass has_helloworld\n{\n    typedef char one;\n    struct two { char x[2]; };\n\n    template &lt;typename C&gt; static one test( decltype(&amp;C::helloworld) ) ;\n    template &lt;typename C&gt; static two test(...);    \n\npublic:\n    enum { value = sizeof(test&lt;T&gt;(0)) == sizeof(char) };\n};\n    \nint main(int argc, char *argv[])\n{\n    std::cout &lt;&lt; has_helloworld&lt;Hello&gt;::value &lt;&lt; std::endl;\n    std::cout &lt;&lt; has_helloworld&lt;Generic&gt;::value &lt;&lt; std::endl;\n    return 0;\n}\n\nI&apos;ve just tested it with Linux and gcc 4.1/4.3. I don&apos;t know if it&apos;s portable to other platforms running different compilers.\n    ","url":"/questions/[slug]#solution1","@type":"Answer","upvoteCount":0},{"text":"This question is old, but with C++11 we got a new way to check for a functions existence (or existence of any non-type member, really), relying on SFINAE again:\n\ntemplate&lt;class T&gt;\nauto serialize_imp(std::ostream&amp; os, T const&amp; obj, int)\n    -&gt; decltype(os &lt;&lt; obj, void())\n{\n  os &lt;&lt; obj;\n}\n\ntemplate&lt;class T&gt;\nauto serialize_imp(std::ostream&amp; os, T const&amp; obj, long)\n    -&gt; decltype(obj.stream(os), void())\n{\n  obj.stream(os);\n}\n\ntemplate&lt;class T&gt;\nauto serialize(std::ostream&amp; os, T const&amp; obj)\n    -&gt; decltype(serialize_imp(os, obj, 0), void())\n{\n  serialize_imp(os, obj, 0);\n}\n\n\nNow onto some explanations. First thing, I use expression SFINAE to exclude the serialize(_imp) functions from overload resolution, if the first expression inside decltype isn&apos;t valid (aka, the function doesn&apos;t exist).\n\nThe void() is used to make the return type of all those functions void.\n\nThe 0 argument is used to prefer the os &lt;&lt; obj overload if both are available (literal 0 is of type int and as such the first overload is a better match).\n\n\n\nNow, you probably want a trait to check if a function exists. Luckily, it&apos;s easy to write that. Note, though, that you need to write a trait yourself for every different function name you might want.\n\n#include &lt;type_traits&gt;\n\ntemplate&lt;class&gt;\nstruct sfinae_true : std::true_type{};\n\nnamespace detail{\n  template&lt;class T, class A0&gt;\n  static auto test_stream(int)\n      -&gt; sfinae_true&lt;decltype(std::declval&lt;T&gt;().stream(std::declval&lt;A0&gt;()))&gt;;\n  template&lt;class, class A0&gt;\n  static auto test_stream(long) -&gt; std::false_type;\n} // detail::\n\ntemplate&lt;class T, class Arg&gt;\nstruct has_stream : decltype(detail::test_stream&lt;T, Arg&gt;(0)){};\n\n\nLive example.\n\nAnd on to explanations. First, sfinae_true is a helper type, and it basically amounts to the same as writing decltype(void(std::declval&lt;T&gt;().stream(a0)), std::true_type{}). The advantage is simply that it&apos;s shorter.\nNext, the struct has_stream : decltype(...) inherits from either std::true_type or std::false_type in the end, depending on whether the decltype check in test_stream fails or not.\nLast, std::declval gives you a &quot;value&quot; of whatever type you pass, without you needing to know how you can construct it. Note that this is only possible inside an unevaluated context, such as decltype, sizeof and others.\n\n\n\nNote that decltype is not necessarily needed, as sizeof (and all unevaluated contexts) got that enhancement. It&apos;s just that decltype already delivers a type and as such is just cleaner. Here&apos;s a sizeof version of one of the overloads:\n\ntemplate&lt;class T&gt;\nvoid serialize_imp(std::ostream&amp; os, T const&amp; obj, int,\n    int(*)[sizeof((os &lt;&lt; obj),0)] = 0)\n{\n  os &lt;&lt; obj;\n}\n\n\nThe int and long parameters are still there for the same reason. The array pointer is used to provide a context where sizeof can be used.\n    ","url":"/questions/[slug]#solution2","@type":"Answer","upvoteCount":0},{"text":"C++ allows SFINAE to be used for this (notice that with C++11 features this is simplier because it supports extended SFINAE on nearly arbitrary expressions - the below was crafted to work with common C++03 compilers):\n#define HAS_MEM_FUNC(func, name)                                        \\\n    template&lt;typename T, typename Sign&gt;                                 \\\n    struct name {                                                       \\\n        typedef char yes[1];                                            \\\n        typedef char no [2];                                            \\\n        template &lt;typename U, U&gt; struct type_check;                     \\\n        template &lt;typename _1&gt; static yes &amp;chk(type_check&lt;Sign, &amp;_1::func &gt; *); \\\n        template &lt;typename   &gt; static no  &amp;chk(...);                    \\\n        static bool const value = sizeof(chk&lt;T&gt;(0)) == sizeof(yes);     \\\n    }\n\nThe above template and macro tries to instantiate a template, giving it a member function pointer type, and the actual member function pointer. If the types do not fit, SFINAE causes the template to be ignored. Usage like this:\nHAS_MEM_FUNC(toString, has_to_string);\n\ntemplate&lt;typename T&gt; void\ndoSomething() {\n   if(has_to_string&lt;T, std::string(T::*)()&gt;::value) {\n      ...\n   } else {\n      ...\n   }\n}\n\nBut note that you cannot just call that toString function in that if branch. Since the compiler will check for validity in both branches, that would fail for cases the function doesn&apos;t exist. One way is to use SFINAE once again (enable_if can be obtained from boost, too):\ntemplate&lt;bool C, typename T = void&gt;\nstruct enable_if {\n  typedef T type;\n};\n\ntemplate&lt;typename T&gt;\nstruct enable_if&lt;false, T&gt; { };\n\nHAS_MEM_FUNC(toString, has_to_string);\n\ntemplate&lt;typename T&gt; \ntypename enable_if&lt;has_to_string&lt;T, \n                   std::string(T::*)()&gt;::value, std::string&gt;::type\ndoSomething(T * t) {\n   /* something when T has toString ... */\n   return t-&gt;toString();\n}\n\ntemplate&lt;typename T&gt; \ntypename enable_if&lt;!has_to_string&lt;T, \n                   std::string(T::*)()&gt;::value, std::string&gt;::type\ndoSomething(T * t) {\n   /* something when T doesnt have toString ... */\n   return &quot;T::toString() does not exist.&quot;;\n}\n\nHave fun using it. The advantage of it is that it also works for overloaded member functions, and also for const member functions (remember using  std::string(T::*)() const as the member function pointer type then!).\n    ","url":"/questions/[slug]#solution3","@type":"Answer","upvoteCount":0},{"text":"C++20 - requires expressions\nWith C++20 come concepts and assorted tools such as requires expressions which are a built-in way to check for a function existence. With them you could rewrite your optionalToString function as follows:\ntemplate&lt;class T&gt;\nstd::string optionalToString(T* obj)\n{\n    constexpr bool has_toString = requires(const T&amp; t) {\n        t.toString();\n    };\n\n    if constexpr (has_toString)\n        return obj-&gt;toString();\n    else\n        return &quot;toString not defined&quot;;\n}\n\nPre-C++20 - Detection toolkit\nN4502 proposes a detection toolkit for inclusion into the C++17 standard library that eventually made it into the library fundamentals TS v2. It most likely won&apos;t ever get into the standard because it has been subsumed by requires expressions since, but it still solves the problem in a somewhat elegant manner. The toolkit introduces some metafunctions, including std::is_detected which can be used to easily write type or function detection metafunctions on the top of it. Here is how you could use it:\ntemplate&lt;typename T&gt;\nusing toString_t = decltype( std::declval&lt;T&amp;&gt;().toString() );\n\ntemplate&lt;typename T&gt;\nconstexpr bool has_toString = std::is_detected_v&lt;toString_t, T&gt;;\n\nNote that the example above is untested. The detection toolkit is not available in standard libraries yet but the proposal contains a full implementation that you can easily copy if you really need it. It plays nice with the C++17 feature if constexpr:\ntemplate&lt;class T&gt;\nstd::string optionalToString(T* obj)\n{\n    if constexpr (has_toString&lt;T&gt;)\n        return obj-&gt;toString();\n    else\n        return &quot;toString not defined&quot;;\n}\n\nC++14 - Boost.Hana\nBoost.Hana apparently builds upon this specific example and provides a solution for C++14 in its documentation, so I&apos;m going to quote it directly:\n\n[...] Hana provides a is_valid function that can be combined with C++14 generic lambdas to obtain a much cleaner implementation of the same thing:\nauto has_toString = hana::is_valid([](auto&amp;&amp; obj) -&gt; decltype(obj.toString()) { });\n\nThis leaves us with a function object has_toString which returns whether the given expression is valid on the argument we pass to it. The result is returned as an IntegralConstant, so constexpr-ness is not an issue here because the result of the function is represented as a type anyway. Now, in addition to being less verbose (that&apos;s a one liner!), the intent is much clearer. Other benefits are the fact that has_toString can be passed to higher order algorithms and it can also be defined at function scope, so there is no need to pollute the namespace scope with implementation details.\n\nBoost.TTI\nAnother somewhat idiomatic toolkit to perform such a check - even though less elegant - is Boost.TTI, introduced in Boost 1.54.0. For your example, you would have to use the macro BOOST_TTI_HAS_MEMBER_FUNCTION. Here is how you could use it:\n#include &lt;boost/tti/has_member_function.hpp&gt;\n\n// Generate the metafunction\nBOOST_TTI_HAS_MEMBER_FUNCTION(toString)\n\n// Check whether T has a member function toString\n// which takes no parameter and returns a std::string\nconstexpr bool foo = has_member_function_toString&lt;T, std::string&gt;::value;\n\nThen, you could use the bool to create a SFINAE check.\nExplanation\nThe macro BOOST_TTI_HAS_MEMBER_FUNCTION generates the metafunction has_member_function_toString which takes the checked type as its first template parameter. The second template parameter corresponds to the return type of the member function, and the following parameters correspond to the types of the function&apos;s parameters. The member value contains true if the class T has a member function std::string toString().\nAlternatively, has_member_function_toString can take a member function pointer as a template parameter. Therefore, it is possible to replace has_member_function_toString&lt;T, std::string&gt;::value by has_member_function_toString&lt;std::string T::* ()&gt;::value.\n    ","url":"/questions/[slug]#solution4","@type":"Answer","upvoteCount":0},{"text":"Though this question is two years old, I&apos;ll dare to add my answer. Hopefully it will clarify the previous, indisputably excellent, solution. I took the very helpful answers of Nicola Bonelli and Johannes Schaub and merged them into a solution that is, IMHO, more readable, clear and does not require the typeof extension:\n\ntemplate &lt;class Type&gt;\nclass TypeHasToString\n{\n    // This type won&apos;t compile if the second template parameter isn&apos;t of type T,\n    // so I can put a function pointer type in the first parameter and the function\n    // itself in the second thus checking that the function has a specific signature.\n    template &lt;typename T, T&gt; struct TypeCheck;\n\n    typedef char Yes;\n    typedef long No;\n\n    // A helper struct to hold the declaration of the function pointer.\n    // Change it if the function signature changes.\n    template &lt;typename T&gt; struct ToString\n    {\n        typedef void (T::*fptr)();\n    };\n\n    template &lt;typename T&gt; static Yes HasToString(TypeCheck&lt; typename ToString&lt;T&gt;::fptr, &amp;T::toString &gt;*);\n    template &lt;typename T&gt; static No  HasToString(...);\n\npublic:\n    static bool const value = (sizeof(HasToString&lt;Type&gt;(0)) == sizeof(Yes));\n};\n\n\nI checked it with gcc 4.1.2.\nThe credit goes mainly to Nicola Bonelli and Johannes Schaub, so give them a vote up if my answer helps you :)\n    ","url":"/questions/[slug]#solution5","@type":"Answer","upvoteCount":0},{"text":"A simple solution for C++11:\n\ntemplate&lt;class T&gt;\nauto optionalToString(T* obj)\n -&gt; decltype(  obj-&gt;toString()  )\n{\n    return     obj-&gt;toString();\n}\nauto optionalToString(...) -&gt; string\n{\n    return &quot;toString not defined&quot;;\n}\n\n\nUpdate, 3 years later: (and this is untested). To test for the existence, I think this will work:\n\ntemplate&lt;class T&gt;\nconstexpr auto test_has_toString_method(T* obj)\n -&gt; decltype(  obj-&gt;toString() , std::true_type{} )\n{\n    return     obj-&gt;toString();\n}\nconstexpr auto test_has_toString_method(...) -&gt; std::false_type\n{\n    return &quot;toString not defined&quot;;\n}\n\n    ","url":"/questions/[slug]#solution6","@type":"Answer","upvoteCount":0},{"text":"Well, this question has a long list of answers already, but I would like to emphasize the comment from Morwenn: there is a proposal for C++17 that makes it really much simpler.  See N4502 for details, but as a self-contained example consider the following.\n\nThis part is the constant part, put it in a header.\n\n// See http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4502.pdf.\ntemplate &lt;typename...&gt;\nusing void_t = void;\n\n// Primary template handles all types not supporting the operation.\ntemplate &lt;typename, template &lt;typename&gt; class, typename = void_t&lt;&gt;&gt;\nstruct detect : std::false_type {};\n\n// Specialization recognizes/validates only types supporting the archetype.\ntemplate &lt;typename T, template &lt;typename&gt; class Op&gt;\nstruct detect&lt;T, Op, void_t&lt;Op&lt;T&gt;&gt;&gt; : std::true_type {};\n\n\nthen there is the variable part, where you specify what you are looking for (a type, a member type, a function, a member function etc.).  In the case of the OP:\n\ntemplate &lt;typename T&gt;\nusing toString_t = decltype(std::declval&lt;T&gt;().toString());\n\ntemplate &lt;typename T&gt;\nusing has_toString = detect&lt;T, toString_t&gt;;\n\n\nThe following example, taken from N4502, shows a more elaborate probe:\n\n// Archetypal expression for assignment operation.\ntemplate &lt;typename T&gt;\nusing assign_t = decltype(std::declval&lt;T&amp;&gt;() = std::declval&lt;T const &amp;&gt;())\n\n// Trait corresponding to that archetype.\ntemplate &lt;typename T&gt;\nusing is_assignable = detect&lt;T, assign_t&gt;;\n\n\nCompared to the other implementations described above, this one is fairly simple: a reduced set of tools (void_t and detect) suffices, no need for hairy macros.  Besides, it was reported (see N4502) that it is measurably more efficient (compile-time and compiler memory consumption) than previous approaches.\n\nHere is a live example.  It works fine with Clang, but unfortunately, GCC versions before 5.1 followed a different interpretation of the C++11 standard which caused void_t to not work as expected.  Yakk already provided the work-around: use the following definition of void_t (void_t in parameter list works but not as return type):\n\n#if __GNUC__ &lt; 5 &amp;&amp; ! defined __clang__\n// https://stackoverflow.com/a/28967049/1353549\ntemplate &lt;typename...&gt;\nstruct voider\n{\n  using type = void;\n};\ntemplate &lt;typename...Ts&gt;\nusing void_t = typename voider&lt;Ts...&gt;::type;\n#else\ntemplate &lt;typename...&gt;\nusing void_t = void;\n#endif\n\n    ","url":"/questions/[slug]#solution7","@type":"Answer","upvoteCount":0},{"text":"This is what type traits are there for. Unfortunately, they have to be defined manually. In your case, imagine the following:\n\ntemplate &lt;typename T&gt;\nstruct response_trait {\n    static bool const has_tostring = false;\n};\n\ntemplate &lt;&gt;\nstruct response_trait&lt;your_type_with_tostring&gt; {\n    static bool const has_tostring = true;\n}\n\n    ","url":"/questions/[slug]#solution8","@type":"Answer","upvoteCount":0},{"text":"This is a C++11 solution for the general problem if &quot;If I did X, would it compile?&quot;\n\ntemplate&lt;class&gt; struct type_sink { typedef void type; }; // consumes a type, and makes it `void`\ntemplate&lt;class T&gt; using type_sink_t = typename type_sink&lt;T&gt;::type;\ntemplate&lt;class T, class=void&gt; struct has_to_string : std::false_type {}; \\\ntemplate&lt;class T&gt; struct has_to_string&lt;\n  T,\n  type_sink_t&lt; decltype( std::declval&lt;T&gt;().toString() ) &gt;\n&gt;: std::true_type {};\n\n\nTrait has_to_string such that has_to_string&lt;T&gt;::value is true if and only if T has a method .toString that can be invoked with 0 arguments in this context.\n\nNext, I&apos;d use tag dispatching:\n\nnamespace details {\n  template&lt;class T&gt;\n  std::string optionalToString_helper(T* obj, std::true_type /*has_to_string*/) {\n    return obj-&gt;toString();\n  }\n  template&lt;class T&gt;\n  std::string optionalToString_helper(T* obj, std::false_type /*has_to_string*/) {\n    return &quot;toString not defined&quot;;\n  }\n}\ntemplate&lt;class T&gt;\nstd::string optionalToString(T* obj) {\n  return details::optionalToString_helper( obj, has_to_string&lt;T&gt;{} );\n}\n\n\nwhich tends to be more maintainable than complex SFINAE expressions.\n\nYou can write these traits with a macro if you find yourself doing it alot, but they are relatively simple (a few lines each) so maybe not worth it:\n\n#define MAKE_CODE_TRAIT( TRAIT_NAME, ... ) \\\ntemplate&lt;class T, class=void&gt; struct TRAIT_NAME : std::false_type {}; \\\ntemplate&lt;class T&gt; struct TRAIT_NAME&lt; T, type_sink_t&lt; decltype( __VA_ARGS__ ) &gt; &gt;: std::true_type {};\n\n\nwhat the above does is create a macro MAKE_CODE_TRAIT.  You pass it the name of the trait you want, and some code that can test the type T.  Thus:\n\nMAKE_CODE_TRAIT( has_to_string, std::declval&lt;T&gt;().toString() )\n\n\ncreates the above traits class.\n\nAs an aside, the above technique is part of what MS calls &quot;expression SFINAE&quot;, and their 2013 compiler fails pretty hard.\n\nNote that in C++1y the following syntax is possible:\n\ntemplate&lt;class T&gt;\nstd::string optionalToString(T* obj) {\n  return compiled_if&lt; has_to_string &gt;(*obj, [&amp;](auto&amp;&amp; obj) {\n    return obj.toString();\n  }) *compiled_else ([&amp;]{ \n    return &quot;toString not defined&quot;;\n  });\n}\n\n\nwhich is an inline compilation conditional branch that abuses lots of C++ features.  Doing so is probably not worth it, as the benefit (of code being inline) is not worth the cost (of next to nobody understanding how it works), but the existence of that above solution may be of interest.\n    ","url":"/questions/[slug]#solution9","@type":"Answer","upvoteCount":0},{"text":"With C++ 20 you can write the following:\n\ntemplate&lt;typename T&gt;\nconcept has_toString = requires(const T&amp; t) {\n    t.toString();\n};\n\ntemplate&lt;typename T&gt;\nstd::string optionalToString(const T&amp; obj)\n{\n    if constexpr (has_toString&lt;T&gt;)\n        return obj.toString();\n    else\n        return &quot;toString not defined&quot;;\n}\n\n    ","url":"/questions/[slug]#solution10","@type":"Answer","upvoteCount":0},{"text":"Here are some usage snippets:\n*The guts for all this are farther down\n\nCheck for member x in a given class.  Could be var, func, class, union, or enum:\n\nCREATE_MEMBER_CHECK(x);\nbool has_x = has_member_x&lt;class_to_check_for_x&gt;::value;\n\n\nCheck for member function void x():\n\n//Func signature MUST have T as template variable here... simpler this way :\\\nCREATE_MEMBER_FUNC_SIG_CHECK(x, void (T::*)(), void__x);\nbool has_func_sig_void__x = has_member_func_void__x&lt;class_to_check_for_x&gt;::value;\n\n\nCheck for member variable x:\n\nCREATE_MEMBER_VAR_CHECK(x);\nbool has_var_x = has_member_var_x&lt;class_to_check_for_x&gt;::value;\n\n\nCheck for member class x:\n\nCREATE_MEMBER_CLASS_CHECK(x);\nbool has_class_x = has_member_class_x&lt;class_to_check_for_x&gt;::value;\n\n\nCheck for member union x:\n\nCREATE_MEMBER_UNION_CHECK(x);\nbool has_union_x = has_member_union_x&lt;class_to_check_for_x&gt;::value;\n\n\nCheck for member enum x:\n\nCREATE_MEMBER_ENUM_CHECK(x);\nbool has_enum_x = has_member_enum_x&lt;class_to_check_for_x&gt;::value;\n\n\nCheck for any member function x regardless of signature:\n\nCREATE_MEMBER_CHECK(x);\nCREATE_MEMBER_VAR_CHECK(x);\nCREATE_MEMBER_CLASS_CHECK(x);\nCREATE_MEMBER_UNION_CHECK(x);\nCREATE_MEMBER_ENUM_CHECK(x);\nCREATE_MEMBER_FUNC_CHECK(x);\nbool has_any_func_x = has_member_func_x&lt;class_to_check_for_x&gt;::value;\n\n\nOR\n\nCREATE_MEMBER_CHECKS(x);  //Just stamps out the same macro calls as above.\nbool has_any_func_x = has_member_func_x&lt;class_to_check_for_x&gt;::value;\n\n\nDetails and core:\n\n/*\n    - Multiple inheritance forces ambiguity of member names.\n    - SFINAE is used to make aliases to member names.\n    - Expression SFINAE is used in just one generic has_member that can accept\n      any alias we pass it.\n*/\n\n//Variadic to force ambiguity of class members.  C++11 and up.\ntemplate &lt;typename... Args&gt; struct ambiguate : public Args... {};\n\n//Non-variadic version of the line above.\n//template &lt;typename A, typename B&gt; struct ambiguate : public A, public B {};\n\ntemplate&lt;typename A, typename = void&gt;\nstruct got_type : std::false_type {};\n\ntemplate&lt;typename A&gt;\nstruct got_type&lt;A&gt; : std::true_type {\n    typedef A type;\n};\n\ntemplate&lt;typename T, T&gt;\nstruct sig_check : std::true_type {};\n\ntemplate&lt;typename Alias, typename AmbiguitySeed&gt;\nstruct has_member {\n    template&lt;typename C&gt; static char ((&amp;f(decltype(&amp;C::value))))[1];\n    template&lt;typename C&gt; static char ((&amp;f(...)))[2];\n\n    //Make sure the member name is consistently spelled the same.\n    static_assert(\n        (sizeof(f&lt;AmbiguitySeed&gt;(0)) == 1)\n        , &quot;Member name specified in AmbiguitySeed is different from member name specified in Alias, or wrong Alias/AmbiguitySeed has been specified.&quot;\n    );\n\n    static bool const value = sizeof(f&lt;Alias&gt;(0)) == 2;\n};\n\n\nMacros (El Diablo!):\n\nCREATE_MEMBER_CHECK:\n\n//Check for any member with given name, whether var, func, class, union, enum.\n#define CREATE_MEMBER_CHECK(member)                                         \\\n                                                                            \\\ntemplate&lt;typename T, typename = std::true_type&gt;                             \\\nstruct Alias_##member;                                                      \\\n                                                                            \\\ntemplate&lt;typename T&gt;                                                        \\\nstruct Alias_##member &lt;                                                     \\\n    T, std::integral_constant&lt;bool, got_type&lt;decltype(&amp;T::member)&gt;::value&gt;  \\\n&gt; { static const decltype(&amp;T::member) value; };                             \\\n                                                                            \\\nstruct AmbiguitySeed_##member { char member; };                             \\\n                                                                            \\\ntemplate&lt;typename T&gt;                                                        \\\nstruct has_member_##member {                                                \\\n    static const bool value                                                 \\\n        = has_member&lt;                                                       \\\n            Alias_##member&lt;ambiguate&lt;T, AmbiguitySeed_##member&gt;&gt;            \\\n            , Alias_##member&lt;AmbiguitySeed_##member&gt;                        \\\n        &gt;::value                                                            \\\n    ;                                                                       \\\n}\n\n\nCREATE_MEMBER_VAR_CHECK:\n\n//Check for member variable with given name.\n#define CREATE_MEMBER_VAR_CHECK(var_name)                                   \\\n                                                                            \\\ntemplate&lt;typename T, typename = std::true_type&gt;                             \\\nstruct has_member_var_##var_name : std::false_type {};                      \\\n                                                                            \\\ntemplate&lt;typename T&gt;                                                        \\\nstruct has_member_var_##var_name&lt;                                           \\\n    T                                                                       \\\n    , std::integral_constant&lt;                                               \\\n        bool                                                                \\\n        , !std::is_member_function_pointer&lt;decltype(&amp;T::var_name)&gt;::value   \\\n    &gt;                                                                       \\\n&gt; : std::true_type {}\n\n\nCREATE_MEMBER_FUNC_SIG_CHECK:\n\n//Check for member function with given name AND signature.\n#define CREATE_MEMBER_FUNC_SIG_CHECK(func_name, func_sig, templ_postfix)    \\\n                                                                            \\\ntemplate&lt;typename T, typename = std::true_type&gt;                             \\\nstruct has_member_func_##templ_postfix : std::false_type {};                \\\n                                                                            \\\ntemplate&lt;typename T&gt;                                                        \\\nstruct has_member_func_##templ_postfix&lt;                                     \\\n    T, std::integral_constant&lt;                                              \\\n        bool                                                                \\\n        , sig_check&lt;func_sig, &amp;T::func_name&gt;::value                         \\\n    &gt;                                                                       \\\n&gt; : std::true_type {}\n\n\nCREATE_MEMBER_CLASS_CHECK:\n\n//Check for member class with given name.\n#define CREATE_MEMBER_CLASS_CHECK(class_name)               \\\n                                                            \\\ntemplate&lt;typename T, typename = std::true_type&gt;             \\\nstruct has_member_class_##class_name : std::false_type {};  \\\n                                                            \\\ntemplate&lt;typename T&gt;                                        \\\nstruct has_member_class_##class_name&lt;                       \\\n    T                                                       \\\n    , std::integral_constant&lt;                               \\\n        bool                                                \\\n        , std::is_class&lt;                                    \\\n            typename got_type&lt;typename T::class_name&gt;::type \\\n        &gt;::value                                            \\\n    &gt;                                                       \\\n&gt; : std::true_type {}\n\n\nCREATE_MEMBER_UNION_CHECK:\n\n//Check for member union with given name.\n#define CREATE_MEMBER_UNION_CHECK(union_name)               \\\n                                                            \\\ntemplate&lt;typename T, typename = std::true_type&gt;             \\\nstruct has_member_union_##union_name : std::false_type {};  \\\n                                                            \\\ntemplate&lt;typename T&gt;                                        \\\nstruct has_member_union_##union_name&lt;                       \\\n    T                                                       \\\n    , std::integral_constant&lt;                               \\\n        bool                                                \\\n        , std::is_union&lt;                                    \\\n            typename got_type&lt;typename T::union_name&gt;::type \\\n        &gt;::value                                            \\\n    &gt;                                                       \\\n&gt; : std::true_type {}\n\n\nCREATE_MEMBER_ENUM_CHECK:\n\n//Check for member enum with given name.\n#define CREATE_MEMBER_ENUM_CHECK(enum_name)                 \\\n                                                            \\\ntemplate&lt;typename T, typename = std::true_type&gt;             \\\nstruct has_member_enum_##enum_name : std::false_type {};    \\\n                                                            \\\ntemplate&lt;typename T&gt;                                        \\\nstruct has_member_enum_##enum_name&lt;                         \\\n    T                                                       \\\n    , std::integral_constant&lt;                               \\\n        bool                                                \\\n        , std::is_enum&lt;                                     \\\n            typename got_type&lt;typename T::enum_name&gt;::type  \\\n        &gt;::value                                            \\\n    &gt;                                                       \\\n&gt; : std::true_type {}\n\n\nCREATE_MEMBER_FUNC_CHECK:\n\n//Check for function with given name, any signature.\n#define CREATE_MEMBER_FUNC_CHECK(func)          \\\ntemplate&lt;typename T&gt;                            \\\nstruct has_member_func_##func {                 \\\n    static const bool value                     \\\n        = has_member_##func&lt;T&gt;::value           \\\n        &amp;&amp; !has_member_var_##func&lt;T&gt;::value     \\\n        &amp;&amp; !has_member_class_##func&lt;T&gt;::value   \\\n        &amp;&amp; !has_member_union_##func&lt;T&gt;::value   \\\n        &amp;&amp; !has_member_enum_##func&lt;T&gt;::value    \\\n    ;                                           \\\n}\n\n\nCREATE_MEMBER_CHECKS:\n\n//Create all the checks for one member.  Does NOT include func sig checks.\n#define CREATE_MEMBER_CHECKS(member)    \\\nCREATE_MEMBER_CHECK(member);            \\\nCREATE_MEMBER_VAR_CHECK(member);        \\\nCREATE_MEMBER_CLASS_CHECK(member);      \\\nCREATE_MEMBER_UNION_CHECK(member);      \\\nCREATE_MEMBER_ENUM_CHECK(member);       \\\nCREATE_MEMBER_FUNC_CHECK(member)\n\n    ","url":"/questions/[slug]#solution11","@type":"Answer","upvoteCount":0},{"text":"Yet another way to do it in C++17 (inspired by boost:hana).\nThis solution does not require has_something&lt;T&gt; SFINAE type traits classes.\nSolution\n////////////////////////////////////////////\n// has_member implementation\n////////////////////////////////////////////\n\n#include &lt;type_traits&gt;\n\ntemplate&lt;typename T, typename F&gt;\nconstexpr auto has_member_impl(F&amp;&amp; f) -&gt; decltype(f(std::declval&lt;T&gt;()), true)\n{\n  return true;\n}\n\ntemplate&lt;typename&gt;\nconstexpr bool has_member_impl(...) { return false; }\n\n#define has_member(T, EXPR) \\\n has_member_impl&lt;T&gt;( [](auto&amp;&amp; obj)-&gt;decltype(obj.EXPR){} )\n\n\nTest\n////////////////////////////////////////////\n// Test\n////////////////////////////////////////////\n\n#include &lt;iostream&gt;\n#include &lt;string&gt;\n\nstruct Example {\n    int Foo;\n    void Bar() {}\n    std::string toString() { return &quot;Hello from Example::toString()!&quot;; }\n};\n\nstruct Example2 {\n    int X;\n};\n\ntemplate&lt;class T&gt;\nstd::string optionalToString(T* obj)\n{\n    if constexpr(has_member(T, toString()))\n        return obj-&gt;toString();\n    else\n        return &quot;toString not defined&quot;;\n}\n\nint main() {\n    static_assert(has_member(Example, Foo), \n                  &quot;Example class must have Foo member&quot;);\n    static_assert(has_member(Example, Bar()), \n                  &quot;Example class must have Bar() member function&quot;);\n    static_assert(!has_member(Example, ZFoo), \n                  &quot;Example class must not have ZFoo member.&quot;);\n    static_assert(!has_member(Example, ZBar()), \n                  &quot;Example class must not have ZBar() member function&quot;);\n\n    Example e1;\n    Example2 e2;\n\n    std::cout &lt;&lt; &quot;e1: &quot; &lt;&lt; optionalToString(&amp;e1) &lt;&lt; &quot;\\n&quot;;\n    std::cout &lt;&lt; &quot;e1: &quot; &lt;&lt; optionalToString(&amp;e2) &lt;&lt; &quot;\\n&quot;;\n}\n\n    ","url":"/questions/[slug]#solution12","@type":"Answer","upvoteCount":0},{"text":"I wrote an answer to this in another thread that (unlike the solutions above) also checks inherited member functions:\n\nSFINAE to check for inherited member functions\n\nHere are some example from that solution:\n\nExample1:\n\nWe are checking for a member with the following signature: \nT::const_iterator begin() const\n\ntemplate&lt;class T&gt; struct has_const_begin\n{\n    typedef char (&amp;Yes)[1];\n    typedef char (&amp;No)[2];\n\n    template&lt;class U&gt; \n    static Yes test(U const * data, \n                    typename std::enable_if&lt;std::is_same&lt;\n                             typename U::const_iterator, \n                             decltype(data-&gt;begin())\n                    &gt;::value&gt;::type * = 0);\n    static No test(...);\n    static const bool value = sizeof(Yes) == sizeof(has_const_begin::test((typename std::remove_reference&lt;T&gt;::type*)0));\n};\n\n\nPlease notice that it even checks the constness of the method, and works with primitive types, as well. (I mean has_const_begin&lt;int&gt;::value is false and doesn&apos;t cause a compile-time error.) \n\nExample 2\n\nNow we are looking for the signature: void foo(MyClass&amp;, unsigned)\n\ntemplate&lt;class T&gt; struct has_foo\n{\n    typedef char (&amp;Yes)[1];\n    typedef char (&amp;No)[2];\n\n    template&lt;class U&gt;\n    static Yes test(U * data, MyClass* arg1 = 0,\n                    typename std::enable_if&lt;std::is_void&lt;\n                             decltype(data-&gt;foo(*arg1, 1u))\n                    &gt;::value&gt;::type * = 0);\n    static No test(...);\n    static const bool value = sizeof(Yes) == sizeof(has_foo::test((typename std::remove_reference&lt;T&gt;::type*)0));\n};\n\n\nPlease notice that MyClass doesn&apos;t has to be default constructible or to satisfy any special concept. The technique works with template members, as well.\n\nI am eagerly waiting opinions regarding this.\n    ","url":"/questions/[slug]#solution13","@type":"Answer","upvoteCount":0},{"text":"Here is the most concise way I found in C++20, which is very close from your question:\ntemplate&lt;class T&gt;\nstd::string optionalToString(T* obj)\n{\n  if constexpr (requires { obj-&gt;toString(); })\n    return obj-&gt;toString();\n  else\n    return &quot;toString not defined&quot;;\n}\n\nSee it live on godbolt: https://gcc.godbolt.org/z/5jb1d93Ms\n    ","url":"/questions/[slug]#solution14","@type":"Answer","upvoteCount":0},{"text":"The standard C++ solution presented here by litb will not work as expected if the method happens to be defined in a base class. \n\nFor a solution that handles this situation refer to :\n\nIn Russian :\nhttp://www.rsdn.ru/forum/message/2759773.1.aspx \n\nEnglish Translation by Roman.Perepelitsa : \nhttp://groups.google.com/group/comp.lang.c++.moderated/tree/browse_frm/thread/4f7c7a96f9afbe44/c95a7b4c645e449f?pli=1 \n\nIt is insanely clever. However one issue with this solutiion is that gives compiler errors if the type being tested is one that cannot be used as a base class (e.g. primitive types)\n\nIn Visual Studio, I noticed that if working with method having no arguments, an extra pair of redundant ( )  needs to be inserted around the argments to deduce( )  in the sizeof expression.\n    ","url":"/questions/[slug]#solution15","@type":"Answer","upvoteCount":0},{"text":"Now this was a nice little puzzle - great question!\n\nHere&apos;s an alternative to Nicola Bonelli&apos;s solution that does not rely on the non-standard typeof operator.\n\nUnfortunately, it does not work on GCC (MinGW) 3.4.5 or Digital Mars 8.42n, but it does work on all versions of MSVC (including VC6) and on Comeau C++.\n\nThe longer comment block has the details on how it works (or is supposed to work).  As it says, I&apos;m not sure which behavior is standards compliant - I&apos;d welcome commentary on that.\n\n\n\nupdate - 7 Nov 2008:\n\nIt looks like while this code is syntactically correct, the behavior that MSVC and Comeau C++ show does not follow the standard (thanks to Leon Timmermans and litb for pointing me in the right direction).  The C++03 standard says the following:\n\n\n  14.6.2 Dependent names [temp.dep]\n  \n  Paragraph 3\n  \n  In the definition of a class template\n  or a member of a class template, if a\n  base class of the class template\n  depends on a template-parameter, the\n  base class scope is not examined\n  during unqualified name lookup either\n  at the point of definition of the\n  class template or member or during an\n  instantiation of the class template or\n  member.\n\n\nSo, it looks like that when MSVC or Comeau consider the toString() member function of T performing name lookup at the call site in doToString() when the template is instantiated, that is incorrect (even though it&apos;s actually the behavior I was looking for in this case).\n\nThe behavior of GCC and Digital Mars looks to be correct - in both cases the non-member toString() function is bound to the call.\n\nRats - I thought I might have found a clever solution, instead I uncovered a couple compiler bugs...\n\n\n\n#include &lt;iostream&gt;\n#include &lt;string&gt;\n\nstruct Hello\n{\n    std::string toString() {\n        return &quot;Hello&quot;;\n    }\n};\n\nstruct Generic {};\n\n\n// the following namespace keeps the toString() method out of\n//  most everything - except the other stuff in this\n//  compilation unit\n\nnamespace {\n    std::string toString()\n    {\n        return &quot;toString not defined&quot;;\n    }\n\n    template &lt;typename T&gt;\n    class optionalToStringImpl : public T\n    {\n    public:\n        std::string doToString() {\n\n            // in theory, the name lookup for this call to \n            //  toString() should find the toString() in \n            //  the base class T if one exists, but if one \n            //  doesn&apos;t exist in the base class, it&apos;ll \n            //  find the free toString() function in \n            //  the private namespace.\n            //\n            // This theory works for MSVC (all versions\n            //  from VC6 to VC9) and Comeau C++, but\n            //  does not work with MinGW 3.4.5 or \n            //  Digital Mars 8.42n\n            //\n            // I&apos;m honestly not sure what the standard says \n            //  is the correct behavior here - it&apos;s sort \n            //  of like ADL (Argument Dependent Lookup - \n            //  also known as Koenig Lookup) but without\n            //  arguments (except the implied &quot;this&quot; pointer)\n\n            return toString();\n        }\n    };\n}\n\ntemplate &lt;typename T&gt;\nstd::string optionalToString(T &amp; obj)\n{\n    // ugly, hacky cast...\n    optionalToStringImpl&lt;T&gt;* temp = reinterpret_cast&lt;optionalToStringImpl&lt;T&gt;*&gt;( &amp;obj);\n\n    return temp-&gt;doToString();\n}\n\n\n\nint\nmain(int argc, char *argv[])\n{\n    Hello helloObj;\n    Generic genericObj;\n\n    std::cout &lt;&lt; optionalToString( helloObj) &lt;&lt; std::endl;\n    std::cout &lt;&lt; optionalToString( genericObj) &lt;&lt; std::endl;\n    return 0;\n}\n\n    ","url":"/questions/[slug]#solution16","@type":"Answer","upvoteCount":0},{"text":"An example using SFINAE and template partial specialization, by writing a Has_foo concept check: \n\n#include &lt;type_traits&gt;\nstruct A{};\n\nstruct B{ int foo(int a, int b);};\n\nstruct C{void foo(int a, int b);};\n\nstruct D{int foo();};\n\nstruct E: public B{};\n\n// available in C++17 onwards as part of &lt;type_traits&gt;\ntemplate&lt;typename...&gt;\nusing void_t = void;\n\ntemplate&lt;typename T, typename = void&gt; struct Has_foo: std::false_type{};\n\ntemplate&lt;typename T&gt; \nstruct Has_foo&lt;T, void_t&lt;\n    std::enable_if_t&lt;\n        std::is_same&lt;\n            int, \n            decltype(std::declval&lt;T&gt;().foo((int)0, (int)0))\n        &gt;::value\n    &gt;\n&gt;&gt;: std::true_type{};\n\n\nstatic_assert(not Has_foo&lt;A&gt;::value, &quot;A does not have a foo&quot;);\nstatic_assert(Has_foo&lt;B&gt;::value, &quot;B has a foo&quot;);\nstatic_assert(not Has_foo&lt;C&gt;::value, &quot;C has a foo with the wrong return. &quot;);\nstatic_assert(not Has_foo&lt;D&gt;::value, &quot;D has a foo with the wrong arguments. &quot;);\nstatic_assert(Has_foo&lt;E&gt;::value, &quot;E has a foo since it inherits from B&quot;);\n\n    ","url":"/questions/[slug]#solution17","@type":"Answer","upvoteCount":0},{"text":"MSVC has the __if_exists and __if_not_exists keywords (Doc). Together with the typeof-SFINAE approach of Nicola I could create a check for GCC and MSVC like the OP looked for.\n\nUpdate: Source can be found Here\n    ","url":"/questions/[slug]#solution18","@type":"Answer","upvoteCount":0},{"text":"I modified the solution provided in https://stackoverflow.com/a/264088/2712152 to make it a bit more general. Also since it doesn&apos;t use any of the new C++11 features we can use it with old compilers and should also work with msvc. But the compilers should enable C99 to use this since it uses variadic macros.\n\nThe following macro can be used to check if a particular class has a particular typedef or not.\n\n/** \n * @class      : HAS_TYPEDEF\n * @brief      : This macro will be used to check if a class has a particular\n * typedef or not.\n * @param typedef_name : Name of Typedef\n * @param name  : Name of struct which is going to be run the test for\n * the given particular typedef specified in typedef_name\n */\n#define HAS_TYPEDEF(typedef_name, name)                           \\\n   template &lt;typename T&gt;                                          \\\n   struct name {                                                  \\\n      typedef char yes[1];                                        \\\n      typedef char no[2];                                         \\\n      template &lt;typename U&gt;                                       \\\n      struct type_check;                                          \\\n      template &lt;typename _1&gt;                                      \\\n      static yes&amp; chk(type_check&lt;typename _1::typedef_name&gt;*);    \\\n      template &lt;typename&gt;                                         \\\n      static no&amp; chk(...);                                        \\\n      static bool const value = sizeof(chk&lt;T&gt;(0)) == sizeof(yes); \\\n   }\n\n\nThe following macro can be used to check if a particular class has a particular member function or not with any given number of arguments.\n\n/** \n * @class      : HAS_MEM_FUNC\n * @brief      : This macro will be used to check if a class has a particular\n * member function implemented in the public section or not. \n * @param func : Name of Member Function\n * @param name : Name of struct which is going to be run the test for\n * the given particular member function name specified in func\n * @param return_type: Return type of the member function\n * @param ellipsis(...) : Since this is macro should provide test case for every\n * possible member function we use variadic macros to cover all possibilities\n */\n#define HAS_MEM_FUNC(func, name, return_type, ...)                \\\n   template &lt;typename T&gt;                                          \\\n   struct name {                                                  \\\n      typedef return_type (T::*Sign)(__VA_ARGS__);                \\\n      typedef char yes[1];                                        \\\n      typedef char no[2];                                         \\\n      template &lt;typename U, U&gt;                                    \\\n      struct type_check;                                          \\\n      template &lt;typename _1&gt;                                      \\\n      static yes&amp; chk(type_check&lt;Sign, &amp;_1::func&gt;*);              \\\n      template &lt;typename&gt;                                         \\\n      static no&amp; chk(...);                                        \\\n      static bool const value = sizeof(chk&lt;T&gt;(0)) == sizeof(yes); \\\n   }\n\n\nWe can use the above 2 macros to perform the checks for has_typedef and has_mem_func as:\n\nclass A {\npublic:\n  typedef int check;\n  void check_function() {}\n};\n\nclass B {\npublic:\n  void hello(int a, double b) {}\n  void hello() {}\n};\n\nHAS_MEM_FUNC(check_function, has_check_function, void, void);\nHAS_MEM_FUNC(hello, hello_check, void, int, double);\nHAS_MEM_FUNC(hello, hello_void_check, void, void);\nHAS_TYPEDEF(check, has_typedef_check);\n\nint main() {\n  std::cout &lt;&lt; &quot;Check Function A:&quot; &lt;&lt; has_check_function&lt;A&gt;::value &lt;&lt; std::endl;\n  std::cout &lt;&lt; &quot;Check Function B:&quot; &lt;&lt; has_check_function&lt;B&gt;::value &lt;&lt; std::endl;\n  std::cout &lt;&lt; &quot;Hello Function A:&quot; &lt;&lt; hello_check&lt;A&gt;::value &lt;&lt; std::endl;\n  std::cout &lt;&lt; &quot;Hello Function B:&quot; &lt;&lt; hello_check&lt;B&gt;::value &lt;&lt; std::endl;\n  std::cout &lt;&lt; &quot;Hello void Function A:&quot; &lt;&lt; hello_void_check&lt;A&gt;::value &lt;&lt; std::endl;\n  std::cout &lt;&lt; &quot;Hello void Function B:&quot; &lt;&lt; hello_void_check&lt;B&gt;::value &lt;&lt; std::endl;\n  std::cout &lt;&lt; &quot;Check Typedef A:&quot; &lt;&lt; has_typedef_check&lt;A&gt;::value &lt;&lt; std::endl;\n  std::cout &lt;&lt; &quot;Check Typedef B:&quot; &lt;&lt; has_typedef_check&lt;B&gt;::value &lt;&lt; std::endl;\n}\n\n    ","url":"/questions/[slug]#solution19","@type":"Answer","upvoteCount":0},{"text":"Strange nobody suggested the following nice trick I saw once on this very site :\n\ntemplate &lt;class T&gt;\nstruct has_foo\n{\n    struct S { void foo(...); };\n    struct derived : S, T {};\n\n    template &lt;typename V, V&gt; struct W {};\n\n    template &lt;typename X&gt;\n    char (&amp;test(W&lt;void (X::*)(), &amp;X::foo&gt; *))[1];\n\n    template &lt;typename&gt;\n    char (&amp;test(...))[2];\n\n    static const bool value = sizeof(test&lt;derived&gt;(0)) == 1;\n};\n\n\nYou have to make sure T is a class. It seems that ambiguity in the lookup of foo is a substitution failure. I made it work on gcc, not sure if it is standard though.\n    ","url":"/questions/[slug]#solution20","@type":"Answer","upvoteCount":0},{"text":"The generic template that can be used for checking if some &quot;feature&quot; is supported by the type:\n\n#include &lt;type_traits&gt;\n\ntemplate &lt;template &lt;typename&gt; class TypeChecker, typename Type&gt;\nstruct is_supported\n{\n    // these structs are used to recognize which version\n    // of the two functions was chosen during overload resolution\n    struct supported {};\n    struct not_supported {};\n\n    // this overload of chk will be ignored by SFINAE principle\n    // if TypeChecker&lt;Type_&gt; is invalid type\n    template &lt;typename Type_&gt;\n    static supported chk(typename std::decay&lt;TypeChecker&lt;Type_&gt;&gt;::type *);\n\n    // ellipsis has the lowest conversion rank, so this overload will be\n    // chosen during overload resolution only if the template overload above is ignored\n    template &lt;typename Type_&gt;\n    static not_supported chk(...);\n\n    // if the template overload of chk is chosen during\n    // overload resolution then the feature is supported\n    // if the ellipses overload is chosen the the feature is not supported\n    static constexpr bool value = std::is_same&lt;decltype(chk&lt;Type&gt;(nullptr)),supported&gt;::value;\n};\n\n\nThe template that checks whether there is a method foo that is compatible with signature double(const char*)\n\n// if T doesn&apos;t have foo method with the signature that allows to compile the bellow\n// expression then instantiating this template is Substitution Failure (SF)\n// which Is Not An Error (INAE) if this happens during overload resolution\ntemplate &lt;typename T&gt;\nusing has_foo = decltype(double(std::declval&lt;T&gt;().foo(std::declval&lt;const char*&gt;())));\n\n\nExamples\n\n// types that support has_foo\nstruct struct1 { double foo(const char*); };            // exact signature match\nstruct struct2 { int    foo(const std::string &amp;str); }; // compatible signature\nstruct struct3 { float  foo(...); };                    // compatible ellipsis signature\nstruct struct4 { template &lt;typename T&gt;\n                 int    foo(T t); };                    // compatible template signature\n\n// types that do not support has_foo\nstruct struct5 { void        foo(const char*); }; // returns void\nstruct struct6 { std::string foo(const char*); }; // std::string can&apos;t be converted to double\nstruct struct7 { double      foo(      int *); }; // const char* can&apos;t be converted to int*\nstruct struct8 { double      bar(const char*); }; // there is no foo method\n\nint main()\n{\n    std::cout &lt;&lt; std::boolalpha;\n\n    std::cout &lt;&lt; is_supported&lt;has_foo, int    &gt;::value &lt;&lt; std::endl; // false\n    std::cout &lt;&lt; is_supported&lt;has_foo, double &gt;::value &lt;&lt; std::endl; // false\n\n    std::cout &lt;&lt; is_supported&lt;has_foo, struct1&gt;::value &lt;&lt; std::endl; // true\n    std::cout &lt;&lt; is_supported&lt;has_foo, struct2&gt;::value &lt;&lt; std::endl; // true\n    std::cout &lt;&lt; is_supported&lt;has_foo, struct3&gt;::value &lt;&lt; std::endl; // true\n    std::cout &lt;&lt; is_supported&lt;has_foo, struct4&gt;::value &lt;&lt; std::endl; // true\n\n    std::cout &lt;&lt; is_supported&lt;has_foo, struct5&gt;::value &lt;&lt; std::endl; // false\n    std::cout &lt;&lt; is_supported&lt;has_foo, struct6&gt;::value &lt;&lt; std::endl; // false\n    std::cout &lt;&lt; is_supported&lt;has_foo, struct7&gt;::value &lt;&lt; std::endl; // false\n    std::cout &lt;&lt; is_supported&lt;has_foo, struct8&gt;::value &lt;&lt; std::endl; // false\n\n    return 0;\n}\n\n\nhttp://coliru.stacked-crooked.com/a/83c6a631ed42cea4\n    ","url":"/questions/[slug]#solution21","@type":"Answer","upvoteCount":0},{"text":"I know that this question is years old, but I think it would useful for people like me to have a more complete updated answer that also works for const overloaded methods such as std::vector&lt;&gt;::begin.\nBased on that answer and that answer from my follow up question, here&apos;s a more complete answer. Note that this will only work with C++11 and higher.\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nclass EmptyClass{};\n\ntemplate &lt;typename T&gt;\nclass has_begin\n{\n    private:\n    has_begin() = delete;\n    \n    struct one { char x[1]; };\n    struct two { char x[2]; };\n\n    template &lt;typename C&gt; static one test( decltype(void(std::declval&lt;C &amp;&gt;().begin())) * ) ;\n    template &lt;typename C&gt; static two test(...);    \n\npublic:\n    static constexpr bool value = sizeof(test&lt;T&gt;(0)) == sizeof(one);\n};\n    \nint main(int argc, char *argv[])\n{\n    std::cout &lt;&lt; std::boolalpha;\n    std::cout &lt;&lt; &quot;vector&lt;int&gt;::begin() exists: &quot; &lt;&lt; has_begin&lt;std::vector&lt;int&gt;&gt;::value &lt;&lt; std::endl;\n    std::cout &lt;&lt; &quot;EmptyClass::begin() exists: &quot; &lt;&lt; has_begin&lt;EmptyClass&gt;::value &lt;&lt; std::endl;\n    return 0;\n}\n\nOr the shorter version:\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nclass EmptyClass{};\n\ntemplate &lt;typename T, typename = void&gt;\nstruct has_begin : std::false_type {};\n\ntemplate &lt;typename T&gt;\nstruct has_begin&lt;T, decltype(void(std::declval&lt;T &amp;&gt;().begin()))&gt; : std::true_type {};\n\nint main(int argc, char *argv[])\n{\n    std::cout &lt;&lt; std::boolalpha;\n    std::cout &lt;&lt; &quot;vector&lt;int&gt;::begin() exists: &quot; &lt;&lt; has_begin&lt;std::vector&lt;int&gt;&gt;::value &lt;&lt; std::endl;\n    std::cout &lt;&lt; &quot;EmptyClass exists: &quot; &lt;&lt; has_begin&lt;EmptyClass&gt;::value &lt;&lt; std::endl;\n}\n\nNote that here a complete sample call must be provided. This means that if we tested for the resize method&apos;s existence then we would have put resize(0).\nDeep magic explanation:\nThe first answer posted of this question used test( decltype(&amp;C::helloworld) ); however this is problematic when the method it is testing is ambiguous due const overloading, thus making the substitution attempt fail.\nTo solve this ambiguity we use a void statement which can take any parameters because it is always translated into a noop and thus the ambiguity is nullified and the call is valid as long as the method exists:\nhas_begin&lt;T, decltype(void(std::declval&lt;T &amp;&gt;().begin()))&gt;\n\nHere&apos;s what&apos;s happening in order:\nWe use std::declval&lt;T &amp;&gt;() to create a callable value for which begin can then be called. After that the value of begin is passed as a parameter to a void statement. We then retrieve the type of that void expression using the builtin decltype so that it can be used as a template type argument. If begin doesn&apos;t exist then the substitution is invalid and as per SFINAE the other declaration is used instead.\n    ","url":"/questions/[slug]#solution22","@type":"Answer","upvoteCount":0},{"text":"How about this solution?\n\n#include &lt;type_traits&gt;\n\ntemplate &lt;typename U, typename = void&gt; struct hasToString : std::false_type { };\n\ntemplate &lt;typename U&gt;\nstruct hasToString&lt;U,\n  typename std::enable_if&lt;bool(sizeof(&amp;U::toString))&gt;::type\n&gt; : std::true_type { };\n\n    ","url":"/questions/[slug]#solution23","@type":"Answer","upvoteCount":0},{"text":"There are a lot of answers here, but I failed, to find a version, that performs real method resolution ordering, while not using any of the newer c++ features (only using c++98 features).\nNote: This version is tested and working with vc++2013, g++ 5.2.0 and the onlline compiler.\n\nSo I came up with a version, that only uses sizeof():\n\ntemplate&lt;typename T&gt; T declval(void);\n\nstruct fake_void { };\ntemplate&lt;typename T&gt; T &amp;operator,(T &amp;,fake_void);\ntemplate&lt;typename T&gt; T const &amp;operator,(T const &amp;,fake_void);\ntemplate&lt;typename T&gt; T volatile &amp;operator,(T volatile &amp;,fake_void);\ntemplate&lt;typename T&gt; T const volatile &amp;operator,(T const volatile &amp;,fake_void);\n\nstruct yes { char v[1]; };\nstruct no  { char v[2]; };\ntemplate&lt;bool&gt; struct yes_no:yes{};\ntemplate&lt;&gt; struct yes_no&lt;false&gt;:no{};\n\ntemplate&lt;typename T&gt;\nstruct has_awesome_member {\n template&lt;typename U&gt; static yes_no&lt;(sizeof((\n   declval&lt;U&gt;().awesome_member(),fake_void()\n  ))!=0)&gt; check(int);\n template&lt;typename&gt; static no check(...);\n enum{value=sizeof(check&lt;T&gt;(0)) == sizeof(yes)};\n};\n\n\nstruct foo { int awesome_member(void); };\nstruct bar { };\nstruct foo_void { void awesome_member(void); };\nstruct wrong_params { void awesome_member(int); };\n\nstatic_assert(has_awesome_member&lt;foo&gt;::value,&quot;&quot;);\nstatic_assert(!has_awesome_member&lt;bar&gt;::value,&quot;&quot;);\nstatic_assert(has_awesome_member&lt;foo_void&gt;::value,&quot;&quot;);\nstatic_assert(!has_awesome_member&lt;wrong_params&gt;::value,&quot;&quot;);\n\n\nLive demo (with extended return type checking and vc++2010 workaround): http://cpp.sh/5b2vs\n\nNo source, as I came up with it myself.\n\nWhen running the Live demo on the g++ compiler, please note that array sizes of 0 are allowed, meaning that the static_assert used will not trigger a compiler error, even when it fails.\nA commonly used work-around is to replace the &apos;typedef&apos; in the macro with &apos;extern&apos;.\n    ","url":"/questions/[slug]#solution24","@type":"Answer","upvoteCount":0},{"text":"My take: to universally determine if something is callable without making verbose type traits for each and every one, or using experimental features, or long code:\ntemplate&lt;typename Callable, typename... Args, typename = decltype(declval&lt;Callable&gt;()(declval&lt;Args&gt;()...))&gt;\nstd::true_type isCallableImpl(Callable, Args...) { return {}; }\n\nstd::false_type isCallableImpl(...) { return {}; }\n\ntemplate&lt;typename... Args, typename Callable&gt;\nconstexpr bool isCallable(Callable callable) {\n    return decltype(isCallableImpl(callable, declval&lt;Args&gt;()...)){};\n}\n\nUsage:\nconstexpr auto TO_STRING_TEST = [](auto in) -&gt; decltype(in.toString()) { return {}; };\nconstexpr bool TO_STRING_WORKS = isCallable&lt;T&gt;(TO_STRING_TEST);\n\n    ","url":"/questions/[slug]#solution25","@type":"Answer","upvoteCount":0},{"text":"Here is my version that handles all possible member function overloads with arbitrary arity, including template member functions, possibly with default arguments. It distinguishes 3 mutually exclusive scenarios when making a member function call to some class type, with given arg types: (1) valid, or (2) ambiguous, or (3) non-viable. Example usage:\n\n#include &lt;string&gt;\n#include &lt;vector&gt;\n\nHAS_MEM(bar)\nHAS_MEM_FUN_CALL(bar)\n\nstruct test\n{\n   void bar(int);\n   void bar(double);\n   void bar(int,double);\n\n   template &lt; typename T &gt;\n   typename std::enable_if&lt; not std::is_integral&lt;T&gt;::value &gt;::type\n   bar(const T&amp;, int=0){}\n\n   template &lt; typename T &gt;\n   typename std::enable_if&lt; std::is_integral&lt;T&gt;::value &gt;::type\n   bar(const std::vector&lt;T&gt;&amp;, T*){}\n\n   template &lt; typename T &gt;\n   int bar(const std::string&amp;, int){}\n};\n\n\nNow you can use it like this:\n\nint main(int argc, const char * argv[])\n{\n   static_assert( has_mem_bar&lt;test&gt;::value , &quot;&quot;);\n\n   static_assert( has_valid_mem_fun_call_bar&lt;test(char const*,long)&gt;::value , &quot;&quot;);\n   static_assert( has_valid_mem_fun_call_bar&lt;test(std::string&amp;,long)&gt;::value , &quot;&quot;);\n\n   static_assert( has_valid_mem_fun_call_bar&lt;test(std::vector&lt;int&gt;, int*)&gt;::value , &quot;&quot;);\n   static_assert( has_no_viable_mem_fun_call_bar&lt;test(std::vector&lt;double&gt;, double*)&gt;::value , &quot;&quot;);\n\n   static_assert( has_valid_mem_fun_call_bar&lt;test(int)&gt;::value , &quot;&quot;);\n   static_assert( std::is_same&lt;void,result_of_mem_fun_call_bar&lt;test(int)&gt;::type&gt;::value , &quot;&quot;);\n\n   static_assert( has_valid_mem_fun_call_bar&lt;test(int,double)&gt;::value , &quot;&quot;);\n   static_assert( not has_valid_mem_fun_call_bar&lt;test(int,double,int)&gt;::value , &quot;&quot;);\n\n   static_assert( not has_ambiguous_mem_fun_call_bar&lt;test(double)&gt;::value , &quot;&quot;);\n   static_assert( has_ambiguous_mem_fun_call_bar&lt;test(unsigned)&gt;::value , &quot;&quot;);\n\n   static_assert( has_viable_mem_fun_call_bar&lt;test(unsigned)&gt;::value , &quot;&quot;);\n   static_assert( has_viable_mem_fun_call_bar&lt;test(int)&gt;::value , &quot;&quot;);\n\n   static_assert( has_no_viable_mem_fun_call_bar&lt;test(void)&gt;::value , &quot;&quot;);\n\n   return 0;\n}\n\n\nHere is the code, written in c++11, however, you can easily port it (with minor tweaks) to non-c++11 that has typeof extensions (e.g. gcc). You can replace the HAS_MEM macro with your own.\n\n#pragma once\n\n#if __cplusplus &gt;= 201103\n\n#include &lt;utility&gt;\n#include &lt;type_traits&gt;\n\n#define HAS_MEM(mem)                                                                                     \\\n                                                                                                     \\\ntemplate &lt; typename T &gt;                                                                               \\\nstruct has_mem_##mem                                                                                  \\\n{                                                                                                     \\\n  struct yes {};                                                                                     \\\n  struct no  {};                                                                                     \\\n                                                                                                     \\\n  struct ambiguate_seed { char mem; };                                                               \\\n  template &lt; typename U &gt; struct ambiguate : U, ambiguate_seed {};                                   \\\n                                                                                                     \\\n  template &lt; typename U, typename = decltype(&amp;U::mem) &gt; static constexpr no  test(int);              \\\n  template &lt; typename                                 &gt; static constexpr yes test(...);              \\\n                                                                                                     \\\n  static bool constexpr value = std::is_same&lt;decltype(test&lt; ambiguate&lt;T&gt; &gt;(0)),yes&gt;::value ;         \\\n  typedef std::integral_constant&lt;bool,value&gt;    type;                                                \\\n};\n\n\n#define HAS_MEM_FUN_CALL(memfun)                                                                         \\\n                                                                                                     \\\ntemplate &lt; typename Signature &gt;                                                                       \\\nstruct has_valid_mem_fun_call_##memfun;                                                               \\\n                                                                                                     \\\ntemplate &lt; typename T, typename... Args &gt;                                                             \\\nstruct has_valid_mem_fun_call_##memfun&lt; T(Args...) &gt;                                                  \\\n{                                                                                                     \\\n  struct yes {};                                                                                     \\\n  struct no  {};                                                                                     \\\n                                                                                                     \\\n  template &lt; typename U, bool = has_mem_##memfun&lt;U&gt;::value &gt;                                         \\\n  struct impl                                                                                        \\\n  {                                                                                                  \\\n     template &lt; typename V, typename = decltype(std::declval&lt;V&gt;().memfun(std::declval&lt;Args&gt;()...)) &gt; \\\n     struct test_result { using type = yes; };                                                       \\\n                                                                                                     \\\n     template &lt; typename V &gt; static constexpr typename test_result&lt;V&gt;::type test(int);               \\\n     template &lt; typename   &gt; static constexpr                            no test(...);               \\\n                                                                                                     \\\n     static constexpr bool value = std::is_same&lt;decltype(test&lt;U&gt;(0)),yes&gt;::value;                    \\\n     using type = std::integral_constant&lt;bool, value&gt;;                                               \\\n  };                                                                                                 \\\n                                                                                                     \\\n  template &lt; typename U &gt;                                                                            \\\n  struct impl&lt;U,false&gt; : std::false_type {};                                                         \\\n                                                                                                     \\\n  static constexpr bool value = impl&lt;T&gt;::value;                                                      \\\n  using type = std::integral_constant&lt;bool, value&gt;;                                                  \\\n};                                                                                                    \\\n                                                                                                     \\\ntemplate &lt; typename Signature &gt;                                                                       \\\nstruct has_ambiguous_mem_fun_call_##memfun;                                                           \\\n                                                                                                     \\\ntemplate &lt; typename T, typename... Args &gt;                                                             \\\nstruct has_ambiguous_mem_fun_call_##memfun&lt; T(Args...) &gt;                                              \\\n{                                                                                                     \\\n  struct ambiguate_seed { void memfun(...); };                                                       \\\n                                                                                                     \\\n  template &lt; class U, bool = has_mem_##memfun&lt;U&gt;::value &gt;                                            \\\n  struct ambiguate : U, ambiguate_seed                                                               \\\n  {                                                                                                  \\\n    using ambiguate_seed::memfun;                                                                    \\\n    using U::memfun;                                                                                 \\\n  };                                                                                                 \\\n                                                                                                     \\\n  template &lt; class U &gt;                                                                               \\\n  struct ambiguate&lt;U,false&gt; : ambiguate_seed {};                                                     \\\n                                                                                                     \\\n  static constexpr bool value = not has_valid_mem_fun_call_##memfun&lt; ambiguate&lt;T&gt;(Args...) &gt;::value; \\\n  using type = std::integral_constant&lt;bool, value&gt;;                                                  \\\n};                                                                                                    \\\n                                                                                                     \\\ntemplate &lt; typename Signature &gt;                                                                       \\\nstruct has_viable_mem_fun_call_##memfun;                                                              \\\n                                                                                                     \\\ntemplate &lt; typename T, typename... Args &gt;                                                             \\\nstruct has_viable_mem_fun_call_##memfun&lt; T(Args...) &gt;                                                 \\\n{                                                                                                     \\\n  static constexpr bool value = has_valid_mem_fun_call_##memfun&lt;T(Args...)&gt;::value                   \\\n                             or has_ambiguous_mem_fun_call_##memfun&lt;T(Args...)&gt;::value;              \\\n  using type = std::integral_constant&lt;bool, value&gt;;                                                  \\\n};                                                                                                    \\\n                                                                                                     \\\ntemplate &lt; typename Signature &gt;                                                                       \\\nstruct has_no_viable_mem_fun_call_##memfun;                                                           \\\n                                                                                                     \\\ntemplate &lt; typename T, typename... Args &gt;                                                             \\\nstruct has_no_viable_mem_fun_call_##memfun &lt; T(Args...) &gt;                                             \\\n{                                                                                                     \\\n  static constexpr bool value = not has_viable_mem_fun_call_##memfun&lt;T(Args...)&gt;::value;             \\\n  using type = std::integral_constant&lt;bool, value&gt;;                                                  \\\n};                                                                                                    \\\n                                                                                                     \\\ntemplate &lt; typename Signature &gt;                                                                       \\\nstruct result_of_mem_fun_call_##memfun;                                                               \\\n                                                                                                     \\\ntemplate &lt; typename T, typename... Args &gt;                                                             \\\nstruct result_of_mem_fun_call_##memfun&lt; T(Args...) &gt;                                                  \\\n{                                                                                                     \\\n  using type = decltype(std::declval&lt;T&gt;().memfun(std::declval&lt;Args&gt;()...));                          \\\n};\n\n#endif\n\n\n\n    ","url":"/questions/[slug]#solution26","@type":"Answer","upvoteCount":0},{"text":"You can skip all the metaprogramming in C++14, and just write this using fit::conditional from the Fit library:\n\ntemplate&lt;class T&gt;\nstd::string optionalToString(T* x)\n{\n    return fit::conditional(\n        [](auto* obj) -&gt; decltype(obj-&gt;toString()) { return obj-&gt;toString(); },\n        [](auto*) { return &quot;toString not defined&quot;; }\n    )(x);\n}\n\n\nYou can also create the function directly from the lambdas as well:\n\nFIT_STATIC_LAMBDA_FUNCTION(optionalToString) = fit::conditional(\n    [](auto* obj) -&gt; decltype(obj-&gt;toString(), std::string()) { return obj-&gt;toString(); },\n    [](auto*) -&gt; std::string { return &quot;toString not defined&quot;; }\n);\n\n\nHowever, if you are using a compiler that doesn&apos;t support generic lambdas, you will have to write separate function objects:\n\nstruct withToString\n{\n    template&lt;class T&gt;\n    auto operator()(T* obj) const -&gt; decltype(obj-&gt;toString(), std::string())\n    {\n        return obj-&gt;toString();\n    }\n};\n\nstruct withoutToString\n{\n    template&lt;class T&gt;\n    std::string operator()(T*) const\n    {\n        return &quot;toString not defined&quot;;\n    }\n};\n\nFIT_STATIC_FUNCTION(optionalToString) = fit::conditional(\n    withToString(),\n    withoutToString()\n);\n\n    ","url":"/questions/[slug]#solution27","@type":"Answer","upvoteCount":0},{"text":"Probably not as good as other examples, but this is what I came up with for C++11. This works for picking overloaded methods.\ntemplate &lt;typename... Args&gt;\nstruct Pack {};\n\n#define Proxy(T) ((T &amp;)(*(int *)(nullptr)))\n\ntemplate &lt;typename Class, typename ArgPack, typename = nullptr_t&gt;\nstruct HasFoo\n{\n    enum { value = false };\n};\n\ntemplate &lt;typename Class, typename... Args&gt;\nstruct HasFoo&lt;\n    Class,\n    Pack&lt;Args...&gt;,\n    decltype((void)(Proxy(Class).foo(Proxy(Args)...)), nullptr)&gt;\n{\n    enum { value = true };\n};\n\nExample usage\nstruct Object\n{\n    int foo(int n)         { return n; }\n#if SOME_CONDITION\n    int foo(int n, char c) { return n + c; }\n#endif\n};\n\ntemplate &lt;bool has_foo_int_char&gt;\nstruct Dispatcher;\n\ntemplate &lt;&gt;\nstruct Dispatcher&lt;false&gt;\n{\n    template &lt;typename Object&gt;\n    static int exec(Object &amp;object, int n, char c)\n    {\n        return object.foo(n) + c;\n    }\n};\n\ntemplate &lt;&gt;\nstruct Dispatcher&lt;true&gt;\n{\n    template &lt;typename Object&gt;\n    static int exec(Object &amp;object, int n, char c)\n    {\n        return object.foo(n, c);\n    }\n};\n\nint runExample()\n{\n    using Args = Pack&lt;int, char&gt;;\n    enum { has_overload = HasFoo&lt;Object, Args&gt;::value };\n    Object object;\n    return Dispatcher&lt;has_overload&gt;::exec(object, 100, &apos;a&apos;);\n}\n\n    ","url":"/questions/[slug]#solution28","@type":"Answer","upvoteCount":0},{"text":"Here is an example of the working code.\n\ntemplate&lt;typename T&gt;\nusing toStringFn = decltype(std::declval&lt;const T&gt;().toString());\n\ntemplate &lt;class T, toStringFn&lt;T&gt;* = nullptr&gt;\nstd::string optionalToString(const T* obj, int)\n{\n    return obj-&gt;toString();\n}\n\ntemplate &lt;class T&gt;\nstd::string optionalToString(const T* obj, long)\n{\n    return &quot;toString not defined&quot;;\n}\n\nint main()\n{\n    A* a;\n    B* b;\n\n    std::cout &lt;&lt; optionalToString(a, 0) &lt;&lt; std::endl; // This is A\n    std::cout &lt;&lt; optionalToString(b, 0) &lt;&lt; std::endl; // toString not defined\n}\n\n\ntoStringFn&lt;T&gt;* = nullptr will enable the function which takes extra int argument which has a priority over function which takes long when called with 0.\n\nYou can use the same principle for the functions which returns true if function is implemented.\n\ntemplate &lt;typename T&gt;\nconstexpr bool toStringExists(long)\n{\n    return false;\n}\n\ntemplate &lt;typename T, toStringFn&lt;T&gt;* = nullptr&gt;\nconstexpr bool toStringExists(int)\n{\n    return true;\n}\n\n\nint main()\n{\n    A* a;\n    B* b;\n\n    std::cout &lt;&lt; toStringExists&lt;A&gt;(0) &lt;&lt; std::endl; // true\n    std::cout &lt;&lt; toStringExists&lt;B&gt;(0) &lt;&lt; std::endl; // false\n}\n\n    ","url":"/questions/[slug]#solution29","@type":"Answer","upvoteCount":0},{"text":"I had a similar problem:\n\nA template class that may be derived from few base classes, some that have a certain member and others that do not.\n\nI solved it similarly to the &quot;typeof&quot; (Nicola Bonelli&apos;s) answer, but with decltype so it compiles and runs correctly on MSVS:\n\n#include &lt;iostream&gt;\n#include &lt;string&gt;\n\nstruct Generic {};    \nstruct HasMember \n{\n  HasMember() : _a(1) {};\n  int _a;\n};    \n\n// SFINAE test\ntemplate &lt;typename T&gt;\nclass S : public T\n{\npublic:\n  std::string foo (std::string b)\n  {\n    return foo2&lt;T&gt;(b,0);\n  }\n\nprotected:\n  template &lt;typename T&gt; std::string foo2 (std::string b, decltype (T::_a))\n  {\n    return b + std::to_string(T::_a);\n  }\n  template &lt;typename T&gt; std::string foo2 (std::string b, ...)\n  {\n    return b + &quot;No&quot;;\n  }\n};\n\nint main(int argc, char *argv[])\n{\n  S&lt;HasMember&gt; d1;\n  S&lt;Generic&gt; d2;\n\n  std::cout &lt;&lt; d1.foo(&quot;HasMember: &quot;) &lt;&lt; std::endl;\n  std::cout &lt;&lt; d2.foo(&quot;Generic: &quot;) &lt;&lt; std::endl;\n  return 0;\n}\n\n    ","url":"/questions/[slug]#solution30","@type":"Answer","upvoteCount":0}],"@type":"Question"}}</script><meta name="next-head-count" content="22"/><link rel="preload" href="/_next/static/css/4f7b2847abfe82c6.css" as="style"/><link rel="stylesheet" href="/_next/static/css/4f7b2847abfe82c6.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-0d1b80a048d4787e.js"></script><script src="/_next/static/chunks/webpack-42cdea76c8170223.js" defer=""></script><script src="/_next/static/chunks/framework-4556c45dd113b893.js" defer=""></script><script src="/_next/static/chunks/main-ccfab947c79712f4.js" defer=""></script><script src="/_next/static/chunks/pages/_app-c0d2dcb5e85faf18.js" defer=""></script><script src="/_next/static/chunks/294-106ef8570fa99deb.js" defer=""></script><script src="/_next/static/chunks/490-7f0418bb4354ac73.js" defer=""></script><script src="/_next/static/chunks/pages/questions/%5Bslug%5D-50e201fdaa1e0fd1.js" defer=""></script><script src="/_next/static/eGqQHYKGZKE-nXShFn8wX/_buildManifest.js" defer=""></script><script src="/_next/static/eGqQHYKGZKE-nXShFn8wX/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="wrapper"><header><nav class="bg-white border-gray-200 px-4 lg:px-6 py-2.5 dark:bg-gray-800"><div class="flex flex-wrap justify-between items-center mx-auto max-w-screen-xl"><a class="flex items-center" href="/"><img src="/logo-second.png" class="mr-3 h-6 sm:h-9" alt="Solution Checker Logo"/><h1 class="self-center text-xl font-semibold whitespace-nowrap dark:text-white">Solution Checker</h1></a><div class="flex items-center lg:order-2"><button data-collapse-toggle="mobile-menu-2" type="button" class="inline-flex items-center p-2 ml-1 text-sm text-gray-500 rounded-lg lg:hidden hover:bg-gray-100 focus:outline-none focus:ring-2 focus:ring-gray-200 dark:text-gray-400 dark:hover:bg-gray-700 dark:focus:ring-gray-600" aria-controls="mobile-menu-2" aria-expanded="false"><span class="sr-only">Open main menu</span><svg class="w-6 h-6" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M3 5a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM3 10a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM3 15a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1z" clip-rule="evenodd"></path></svg><svg class="hidden w-6 h-6" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z" clip-rule="evenodd"></path></svg></button></div><div class="hidden justify-between items-center w-full lg:flex lg:w-auto lg:order-1" id="mobile-menu-2"><ul class="flex flex-col mt-4 font-medium lg:flex-row lg:space-x-8 lg:mt-0"><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" aria-current="page" href="/">Home</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/questions?tab=news">Questions</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/post?tab=news">Post</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/questions/templated-check-for-the-existence-of-a-class-member-function-1657388363414#">Coding</a></li></ul></div></div></nav></header><div class="main-content"><div class="question my-5"><div class="flex question-header items-center m-auto justify-center"><div class="rounded-xl w-full border p-5 shadow-md bg-white"><div class="flex w-full items-center justify-between border-b pb-3"><div class="flex items-center space-x-3"><div class="text-lg font-bold text-slate-700"><a href="/questions/templated-check-for-the-existence-of-a-class-member-function-1657388363414"><h1>Templated check for the existence of a class member function?</h1></a></div></div><div class="flex flex-wrap h-auto justify-end items-center space-x-8"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold" href="/questions/tag/template-meta-programming">template-meta-programming</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold" href="/questions/tag/sfinae">sfinae</a></div></div><div class="question-content mt-5">
                
<p>Is it possible to write a template that changes behavior depending on if a certain member function is defined on a class?</p>

<p>Here's a simple example of what I would want to write:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> T&gt;
std::string <span class="hljs-title">optionalToString</span><span class="hljs-params">(T* obj)</span>
</span>{
    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">FUNCTION_EXISTS</span>(T-&gt;toString))
        <span class="hljs-keyword">return</span> obj-&gt;<span class="hljs-built_in">toString</span>();
    <span class="hljs-keyword">else</span>
        <span class="hljs-keyword">return</span> <span class="hljs-string">"toString not defined"</span>;
}
</code></pre>

<p>So, if <code>class T</code> has <code>toString()</code> defined, then it uses it; otherwise, it doesn't. The magical part that I don't know how to do is the "FUNCTION_EXISTS" part.</p>
    </div></div></div><div class="solution-section"><nav class="flex pagination-solution flex-col justify-end"><h1 class="text-lg font-semibold mb-5">Navigate to solutions: </h1><ul class="inline-flex -space-x-px overflow-auto"><li class="pagination-solution-item"><span data-id="#solution1" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">1</span></li><li class="pagination-solution-item"><span data-id="#solution2" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">2</span></li><li class="pagination-solution-item"><span data-id="#solution3" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">3</span></li><li class="pagination-solution-item"><span data-id="#solution4" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">4</span></li><li class="pagination-solution-item"><span data-id="#solution5" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">5</span></li><li class="pagination-solution-item"><span data-id="#solution6" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">6</span></li><li class="pagination-solution-item"><span data-id="#solution7" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">7</span></li><li class="pagination-solution-item"><span data-id="#solution8" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">8</span></li><li class="pagination-solution-item"><span data-id="#solution9" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">9</span></li><li class="pagination-solution-item"><span data-id="#solution10" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">10</span></li><li class="pagination-solution-item"><span data-id="#solution11" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">11</span></li><li class="pagination-solution-item"><span data-id="#solution12" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">12</span></li><li class="pagination-solution-item"><span data-id="#solution13" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">13</span></li><li class="pagination-solution-item"><span data-id="#solution14" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">14</span></li><li class="pagination-solution-item"><span data-id="#solution15" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">15</span></li><li class="pagination-solution-item"><span data-id="#solution16" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">16</span></li><li class="pagination-solution-item"><span data-id="#solution17" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">17</span></li><li class="pagination-solution-item"><span data-id="#solution18" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">18</span></li><li class="pagination-solution-item"><span data-id="#solution19" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">19</span></li><li class="pagination-solution-item"><span data-id="#solution20" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">20</span></li><li class="pagination-solution-item"><span data-id="#solution21" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">21</span></li><li class="pagination-solution-item"><span data-id="#solution22" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">22</span></li><li class="pagination-solution-item"><span data-id="#solution23" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">23</span></li><li class="pagination-solution-item"><span data-id="#solution24" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">24</span></li><li class="pagination-solution-item"><span data-id="#solution25" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">25</span></li><li class="pagination-solution-item"><span data-id="#solution26" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">26</span></li><li class="pagination-solution-item"><span data-id="#solution27" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">27</span></li><li class="pagination-solution-item"><span data-id="#solution28" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">28</span></li><li class="pagination-solution-item"><span data-id="#solution29" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">29</span></li><li class="pagination-solution-item"><span data-id="#solution30" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">30</span></li></ul></nav><div id="solution1" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 1</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/template-meta-programming">template-meta-programming</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/sfinae">sfinae</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Yes, with SFINAE you can check if a given class does provide a certain method. Here's the working code:</p>
<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>

<span class="hljs-keyword">struct</span> <span class="hljs-title class_">Hello</span>
{
    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">helloworld</span><span class="hljs-params">()</span> </span>{ <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; }
};

<span class="hljs-keyword">struct</span> <span class="hljs-title class_">Generic</span> {};    

<span class="hljs-comment">// SFINAE test</span>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">class</span> <span class="hljs-title class_">has_helloworld</span>
{
    <span class="hljs-keyword">typedef</span> <span class="hljs-type">char</span> one;
    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">two</span> { <span class="hljs-type">char</span> x[<span class="hljs-number">2</span>]; };

    <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> C&gt; <span class="hljs-function"><span class="hljs-type">static</span> one <span class="hljs-title">test</span><span class="hljs-params">( <span class="hljs-keyword">decltype</span>(&amp;C::helloworld) )</span> </span>;
    <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> C&gt; <span class="hljs-function"><span class="hljs-type">static</span> two <span class="hljs-title">test</span><span class="hljs-params">(...)</span></span>;    

<span class="hljs-keyword">public</span>:
    <span class="hljs-keyword">enum</span> { value = <span class="hljs-built_in">sizeof</span>(<span class="hljs-built_in">test</span>&lt;T&gt;(<span class="hljs-number">0</span>)) == <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">char</span>) };
};
    
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span>
</span>{
    std::cout &lt;&lt; has_helloworld&lt;Hello&gt;::value &lt;&lt; std::endl;
    std::cout &lt;&lt; has_helloworld&lt;Generic&gt;::value &lt;&lt; std::endl;
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>
<p>I've just tested it with Linux and gcc 4.1/4.3. I don't know if it's portable to other platforms running different compilers.</p>
    </div></div></div></div><div id="solution2" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 2</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/template-meta-programming">template-meta-programming</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/sfinae">sfinae</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>This question is old, but with C++11 we got a new way to check for a functions existence (or existence of any non-type member, really), relying on SFINAE again:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> T&gt;
<span class="hljs-keyword">auto</span> <span class="hljs-title">serialize_imp</span><span class="hljs-params">(std::ostream&amp; os, T <span class="hljs-type">const</span>&amp; obj, <span class="hljs-type">int</span>)</span>
    -&gt; <span class="hljs-title">decltype</span><span class="hljs-params">(os &lt;&lt; obj, <span class="hljs-type">void</span>())</span>
</span>{
  os &lt;&lt; obj;
}

<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> T&gt;
<span class="hljs-keyword">auto</span> <span class="hljs-title">serialize_imp</span><span class="hljs-params">(std::ostream&amp; os, T <span class="hljs-type">const</span>&amp; obj, <span class="hljs-type">long</span>)</span>
    -&gt; <span class="hljs-title">decltype</span><span class="hljs-params">(obj.stream(os), <span class="hljs-type">void</span>())</span>
</span>{
  obj.<span class="hljs-built_in">stream</span>(os);
}

<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> T&gt;
<span class="hljs-keyword">auto</span> <span class="hljs-title">serialize</span><span class="hljs-params">(std::ostream&amp; os, T <span class="hljs-type">const</span>&amp; obj)</span>
    -&gt; <span class="hljs-title">decltype</span><span class="hljs-params">(serialize_imp(os, obj, <span class="hljs-number">0</span>), <span class="hljs-type">void</span>())</span>
</span>{
  <span class="hljs-built_in">serialize_imp</span>(os, obj, <span class="hljs-number">0</span>);
}
</code></pre>

<p>Now onto some explanations. First thing, I use <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2634.html" rel="noreferrer">expression SFINAE</a> to exclude the <code>serialize(_imp)</code> functions from overload resolution, if the first expression inside <code>decltype</code> isn't valid (aka, the function doesn't exist).</p>

<p>The <code>void()</code> is used to make the return type of all those functions <code>void</code>.</p>

<p>The <code>0</code> argument is used to prefer the <code>os &lt;&lt; obj</code> overload if both are available (literal <code>0</code> is of type <code>int</code> and as such the first overload is a better match).</p>

<hr>

<p>Now, you probably want a trait to check if a function exists. Luckily, it's easy to write that. Note, though, that you need to write a trait <em>yourself</em> for every different function name you might want.</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;type_traits&gt;</span></span>

<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span>&gt;
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">sfinae_true</span> : std::true_type{};

<span class="hljs-keyword">namespace</span> detail{
  <span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> T, <span class="hljs-keyword">class</span> A0&gt;
  <span class="hljs-type">static</span> <span class="hljs-keyword">auto</span> <span class="hljs-title">test_stream</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span>
      -&gt; sfinae_true&lt;<span class="hljs-title">decltype</span><span class="hljs-params">(std::declval&lt;T&gt;().stream(std::declval&lt;A0&gt;()))</span>&gt;</span>;
  <span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span>, <span class="hljs-keyword">class</span> A0&gt;
  <span class="hljs-type">static</span> <span class="hljs-keyword">auto</span> <span class="hljs-title">test_stream</span><span class="hljs-params">(<span class="hljs-type">long</span>)</span> -&gt; std::false_type</span>;
} <span class="hljs-comment">// detail::</span>

<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">Arg</span>&gt;
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">has_stream</span> : <span class="hljs-keyword">decltype</span>(detail::<span class="hljs-built_in">test_stream</span>&lt;T, Arg&gt;(<span class="hljs-number">0</span>)){};
</code></pre>

<p><a href="http://coliru.stacked-crooked.com/a/cd139d95d214c5c3" rel="noreferrer">Live example.</a></p>

<p>And on to explanations. First, <code>sfinae_true</code> is a helper type, and it basically amounts to the same as writing <code>decltype(void(std::declval&lt;T&gt;().stream(a0)), std::true_type{})</code>. The advantage is simply that it's shorter.<br>
Next, the <code>struct has_stream : decltype(...)</code> inherits from either <code>std::true_type</code> or <code>std::false_type</code> in the end, depending on whether the <code>decltype</code> check in <code>test_stream</code> fails or not.<br>
Last, <code>std::declval</code> gives you a "value" of whatever type you pass, without you needing to know how you can construct it. Note that this is only possible inside an unevaluated context, such as <code>decltype</code>, <code>sizeof</code> and others.</p>

<hr>

<p>Note that <code>decltype</code> is not necessarily needed, as <code>sizeof</code> (and all unevaluated contexts) got that enhancement. It's just that <code>decltype</code> already delivers a type and as such is just cleaner. Here's a <code>sizeof</code> version of one of the overloads:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> T&gt;
<span class="hljs-type">void</span> <span class="hljs-title">serialize_imp</span><span class="hljs-params">(std::ostream&amp; os, T <span class="hljs-type">const</span>&amp; obj, <span class="hljs-type">int</span>,
    <span class="hljs-type">int</span>(*)[<span class="hljs-keyword">sizeof</span>((os &lt;&lt; obj),<span class="hljs-number">0</span>)] = <span class="hljs-number">0</span>)</span>
</span>{
  os &lt;&lt; obj;
}
</code></pre>

<p>The <code>int</code> and <code>long</code> parameters are still there for the same reason. The array pointer is used to provide a context where <code>sizeof</code> can be used.</p>
    </div></div></div></div><div id="solution3" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 3</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/template-meta-programming">template-meta-programming</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/sfinae">sfinae</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>C++ allows <a href="http://en.wikipedia.org/wiki/SFINAE" rel="nofollow noreferrer">SFINAE</a> to be used for this (notice that with C++11 features this is simplier because it supports extended SFINAE on nearly arbitrary expressions - the below was crafted to work with common C++03 compilers):</p>
<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> HAS_MEM_FUNC(func, name)                                        \
    template<span class="hljs-string">&lt;typename T, typename Sign&gt;</span>                                 \
    struct name {                                                       \
        typedef char yes[1];                                            \
        typedef char no [2];                                            \
        template <span class="hljs-string">&lt;typename U, U&gt;</span> struct type_check;                     \
        template <span class="hljs-string">&lt;typename _1&gt;</span> static yes &amp;chk(type_check<span class="hljs-string">&lt;Sign, &amp;_1::func &gt;</span> *); \
        template <span class="hljs-string">&lt;typename   &gt;</span> static no  &amp;chk(...);                    \
        static bool const value = sizeof(chk<span class="hljs-string">&lt;T&gt;</span>(0)) == sizeof(yes);     \
    }</span>
</code></pre>
<p>The above template and macro tries to instantiate a template, giving it a member function pointer type, and the actual member function pointer. If the types do not fit, SFINAE causes the template to be ignored. Usage like this:</p>
<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-built_in">HAS_MEM_FUNC</span>(toString, has_to_string);

<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-type">void</span>
<span class="hljs-title">doSomething</span><span class="hljs-params">()</span> </span>{
   <span class="hljs-keyword">if</span>(has_to_string&lt;T, std::<span class="hljs-built_in">string</span>(T::*)()&gt;::value) {
      ...
   } <span class="hljs-keyword">else</span> {
      ...
   }
}
</code></pre>
<p>But note that you cannot just call that <code>toString</code> function in that <code>if</code> branch. Since the compiler will check for validity in both branches, that would fail for cases the function doesn't exist. One way is to use SFINAE once again (<code>enable_if</code> can be obtained from boost, too):</p>
<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-type">bool</span> C, <span class="hljs-keyword">typename</span> T = <span class="hljs-type">void</span>&gt;
<span class="hljs-keyword">struct</span> enable_if {
  <span class="hljs-keyword">typedef</span> T type;
};

<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">enable_if</span>&lt;<span class="hljs-literal">false</span>, T&gt; { };

<span class="hljs-built_in">HAS_MEM_FUNC</span>(toString, has_to_string);

<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt; 
<span class="hljs-keyword">typename</span> enable_if&lt;has_to_string&lt;T, 
                   std::<span class="hljs-built_in">string</span>(T::*)()&gt;::value, std::string&gt;::<span class="hljs-function">type
<span class="hljs-title">doSomething</span><span class="hljs-params">(T * t)</span> </span>{
   <span class="hljs-comment">/* something when T has toString ... */</span>
   <span class="hljs-keyword">return</span> t-&gt;<span class="hljs-built_in">toString</span>();
}

<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt; 
<span class="hljs-keyword">typename</span> enable_if&lt;!has_to_string&lt;T, 
                   std::<span class="hljs-built_in">string</span>(T::*)()&gt;::value, std::string&gt;::<span class="hljs-function">type
<span class="hljs-title">doSomething</span><span class="hljs-params">(T * t)</span> </span>{
   <span class="hljs-comment">/* something when T doesnt have toString ... */</span>
   <span class="hljs-keyword">return</span> <span class="hljs-string">"T::toString() does not exist."</span>;
}
</code></pre>
<p>Have fun using it. The advantage of it is that it also works for overloaded member functions, and also for <code>const</code> member functions (remember using  <code>std::string(T::*)() const</code> as the member function pointer type then!).</p>
    </div></div></div></div><div id="solution4" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 4</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/template-meta-programming">template-meta-programming</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/sfinae">sfinae</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<h2>C++20 - <code>requires</code> expressions</h2>
<p>With C++20 come concepts and assorted tools such as <a href="https://en.cppreference.com/w/cpp/language/constraints" rel="noreferrer"><code>requires</code> expressions</a> which are a built-in way to check for a function existence. With them you could rewrite your <code>optionalToString</code> function as follows:</p>
<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> T&gt;
std::string <span class="hljs-title">optionalToString</span><span class="hljs-params">(T* obj)</span>
</span>{
    <span class="hljs-keyword">constexpr</span> <span class="hljs-type">bool</span> has_toString = <span class="hljs-built_in">requires</span>(<span class="hljs-type">const</span> T&amp; t) {
        t.<span class="hljs-built_in">toString</span>();
    };

    <span class="hljs-function"><span class="hljs-keyword">if</span> <span class="hljs-title">constexpr</span> <span class="hljs-params">(has_toString)</span>
        <span class="hljs-keyword">return</span> obj-&gt;<span class="hljs-title">toString</span><span class="hljs-params">()</span></span>;
    <span class="hljs-keyword">else</span>
        <span class="hljs-keyword">return</span> <span class="hljs-string">"toString not defined"</span>;
}
</code></pre>
<h2>Pre-C++20 - Detection toolkit</h2>
<p><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4502.pdf" rel="noreferrer">N4502</a> proposes a detection toolkit for inclusion into the C++17 standard library that eventually made it into the library fundamentals TS v2. It most likely won't ever get into the standard because it has been subsumed by <code>requires</code> expressions since, but it still solves the problem in a somewhat elegant manner. The toolkit introduces some metafunctions, including <a href="http://en.cppreference.com/w/cpp/experimental/is_detected" rel="noreferrer"><code>std::is_detected</code></a> which can be used to easily write type or function detection metafunctions on the top of it. Here is how you could use it:</p>
<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">using</span> toString_t = <span class="hljs-keyword">decltype</span>( std::<span class="hljs-built_in">declval</span>&lt;T&amp;&gt;().<span class="hljs-built_in">toString</span>() );

<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">constexpr</span> <span class="hljs-type">bool</span> has_toString = std::is_detected_v&lt;toString_t, T&gt;;
</code></pre>
<p>Note that the example above is untested. The detection toolkit is not available in standard libraries yet but the proposal contains a full implementation that you can easily copy if you really need it. It plays nice with the C++17 feature <code>if constexpr</code>:</p>
<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> T&gt;
std::string <span class="hljs-title">optionalToString</span><span class="hljs-params">(T* obj)</span>
</span>{
    <span class="hljs-function"><span class="hljs-keyword">if</span> <span class="hljs-title">constexpr</span> <span class="hljs-params">(has_toString&lt;T&gt;)</span>
        <span class="hljs-keyword">return</span> obj-&gt;<span class="hljs-title">toString</span><span class="hljs-params">()</span></span>;
    <span class="hljs-keyword">else</span>
        <span class="hljs-keyword">return</span> <span class="hljs-string">"toString not defined"</span>;
}
</code></pre>
<h2>C++14 - Boost.Hana</h2>
<p>Boost.Hana apparently builds upon this specific example and provides a solution for C++14 in its documentation, so I'm going to quote it directly:</p>
<blockquote>
<p>[...] Hana provides a <code>is_valid</code> function that can be combined with C++14 generic lambdas to obtain a much cleaner implementation of the same thing:</p>
<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-keyword">auto</span> has_toString = hana::<span class="hljs-built_in">is_valid</span>([](<span class="hljs-keyword">auto</span>&amp;&amp; obj) -&gt; <span class="hljs-keyword">decltype</span>(obj.<span class="hljs-built_in">toString</span>()) { });
</code></pre>
<p>This leaves us with a function object <code>has_toString</code> which returns whether the given expression is valid on the argument we pass to it. The result is returned as an <code>IntegralConstant</code>, so constexpr-ness is not an issue here because the result of the function is represented as a type anyway. Now, in addition to being less verbose (that's a one liner!), the intent is much clearer. Other benefits are the fact that <code>has_toString</code> can be passed to higher order algorithms and it can also be defined at function scope, so there is no need to pollute the namespace scope with implementation details.</p>
</blockquote>
<h2>Boost.TTI</h2>
<p>Another somewhat idiomatic toolkit to perform such a check - even though less elegant - is <a href="http://www.boost.org/doc/libs/1_55_0/libs/tti/doc/html/index.html" rel="noreferrer">Boost.TTI</a>, introduced in Boost 1.54.0. For your example, you would have to use the macro <code>BOOST_TTI_HAS_MEMBER_FUNCTION</code>. Here is how you could use it:</p>
<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;boost/tti/has_member_function.hpp&gt;</span></span>

<span class="hljs-comment">// Generate the metafunction</span>
<span class="hljs-built_in">BOOST_TTI_HAS_MEMBER_FUNCTION</span>(toString)

<span class="hljs-comment">// Check whether T has a member function toString</span>
<span class="hljs-comment">// which takes no parameter and returns a std::string</span>
<span class="hljs-keyword">constexpr</span> <span class="hljs-type">bool</span> foo = has_member_function_toString&lt;T, std::string&gt;::value;
</code></pre>
<p>Then, you could use the <code>bool</code> to create a SFINAE check.</p>
<p><em>Explanation</em></p>
<p>The macro <code>BOOST_TTI_HAS_MEMBER_FUNCTION</code> generates the metafunction <code>has_member_function_toString</code> which takes the checked type as its first template parameter. The second template parameter corresponds to the return type of the member function, and the following parameters correspond to the types of the function's parameters. The member <code>value</code> contains <code>true</code> if the class <code>T</code> has a member function <code>std::string toString()</code>.</p>
<p>Alternatively, <code>has_member_function_toString</code> can take a member function pointer as a template parameter. Therefore, it is possible to replace <code>has_member_function_toString&lt;T, std::string&gt;::value</code> by <code>has_member_function_toString&lt;std::string T::* ()&gt;::value</code>.</p>
    </div></div></div></div><div id="solution5" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 5</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/template-meta-programming">template-meta-programming</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/sfinae">sfinae</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Though this question is two years old, I'll dare to add my answer. Hopefully it will clarify the previous, indisputably excellent, solution. I took the very helpful answers of Nicola Bonelli and Johannes Schaub and merged them into a solution that is, IMHO, more readable, clear and does not require the <code>typeof</code> extension:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Type</span>&gt;
<span class="hljs-keyword">class</span> <span class="hljs-title class_">TypeHasToString</span>
{
    <span class="hljs-comment">// This type won't compile if the second template parameter isn't of type T,</span>
    <span class="hljs-comment">// so I can put a function pointer type in the first parameter and the function</span>
    <span class="hljs-comment">// itself in the second thus checking that the function has a specific signature.</span>
    <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T, T&gt; <span class="hljs-keyword">struct</span> <span class="hljs-title class_">TypeCheck</span>;

    <span class="hljs-keyword">typedef</span> <span class="hljs-type">char</span> Yes;
    <span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> No;

    <span class="hljs-comment">// A helper struct to hold the declaration of the function pointer.</span>
    <span class="hljs-comment">// Change it if the function signature changes.</span>
    <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-keyword">struct</span> <span class="hljs-title class_">ToString</span>
    {
        <span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">void</span> <span class="hljs-params">(T::*fptr)</span><span class="hljs-params">()</span></span>;
    };

    <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-function"><span class="hljs-type">static</span> Yes <span class="hljs-title">HasToString</span><span class="hljs-params">(TypeCheck&lt; <span class="hljs-keyword">typename</span> ToString&lt;T&gt;::fptr, &amp;T::toString &gt;*)</span></span>;
    <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-function"><span class="hljs-type">static</span> No  <span class="hljs-title">HasToString</span><span class="hljs-params">(...)</span></span>;

<span class="hljs-keyword">public</span>:
    <span class="hljs-type">static</span> <span class="hljs-type">bool</span> <span class="hljs-type">const</span> value = (<span class="hljs-built_in">sizeof</span>(<span class="hljs-built_in">HasToString</span>&lt;Type&gt;(<span class="hljs-number">0</span>)) == <span class="hljs-built_in">sizeof</span>(Yes));
};
</code></pre>

<p>I checked it with gcc 4.1.2.
The credit goes mainly to Nicola Bonelli and Johannes Schaub, so give them a vote up if my answer helps you :)</p>
    </div></div></div></div><div id="solution6" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 6</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/template-meta-programming">template-meta-programming</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/sfinae">sfinae</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>A simple solution for C++11:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> T&gt;
<span class="hljs-keyword">auto</span> <span class="hljs-title">optionalToString</span><span class="hljs-params">(T* obj)</span>
 -&gt; <span class="hljs-title">decltype</span><span class="hljs-params">(  obj-&gt;toString()  )</span>
</span>{
    <span class="hljs-keyword">return</span>     obj-&gt;<span class="hljs-built_in">toString</span>();
}
<span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">optionalToString</span><span class="hljs-params">(...)</span> -&gt; string
</span>{
    <span class="hljs-keyword">return</span> <span class="hljs-string">"toString not defined"</span>;
}
</code></pre>

<p>Update, 3 years later: (and this is untested). To test for the existence, I think this will work:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> T&gt;
<span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">auto</span> <span class="hljs-title">test_has_toString_method</span><span class="hljs-params">(T* obj)</span>
 -&gt; <span class="hljs-title">decltype</span><span class="hljs-params">(  obj-&gt;toString() , std::true_type{} )</span>
</span>{
    <span class="hljs-keyword">return</span>     obj-&gt;<span class="hljs-built_in">toString</span>();
}
<span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">auto</span> <span class="hljs-title">test_has_toString_method</span><span class="hljs-params">(...)</span> -&gt; std::false_type
</span>{
    <span class="hljs-keyword">return</span> <span class="hljs-string">"toString not defined"</span>;
}
</code></pre>
    </div></div></div></div><div id="solution7" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 7</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/template-meta-programming">template-meta-programming</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/sfinae">sfinae</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Well, this question has a long list of answers already, but I would like to emphasize the comment from Morwenn: there is a proposal for C++17 that makes it really much simpler.  See <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4502.pdf" rel="noreferrer" title="Proposing Standard Library Support for the C++ Detection Idiom, v2">N4502</a> for details, but as a self-contained example consider the following.</p>

<p>This part is the constant part, put it in a header.</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-comment">// See http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4502.pdf.</span>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span>...&gt;
<span class="hljs-keyword">using</span> <span class="hljs-type">void_t</span> = <span class="hljs-type">void</span>;

<span class="hljs-comment">// Primary template handles all types not supporting the operation.</span>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span>, <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span>&gt; <span class="hljs-keyword">class</span>, <span class="hljs-keyword">typename</span> = <span class="hljs-type">void_t</span>&lt;&gt;&gt;
<span class="hljs-keyword">struct</span> detect : std::false_type {};

<span class="hljs-comment">// Specialization recognizes/validates only types supporting the archetype.</span>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span>&gt; <span class="hljs-keyword">class</span> <span class="hljs-title class_">Op</span>&gt;
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">detect</span>&lt;T, Op, <span class="hljs-type">void_t</span>&lt;Op&lt;T&gt;&gt;&gt; : std::true_type {};
</code></pre>

<p>then there is the variable part, where you specify what you are looking for (a type, a member type, a function, a member function etc.).  In the case of the OP:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">using</span> toString_t = <span class="hljs-keyword">decltype</span>(std::<span class="hljs-built_in">declval</span>&lt;T&gt;().<span class="hljs-built_in">toString</span>());

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">using</span> has_toString = detect&lt;T, toString_t&gt;;
</code></pre>

<p>The following example, taken from <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4502.pdf" rel="noreferrer" title="Proposing Standard Library Support for the C++ Detection Idiom, v2">N4502</a>, shows a more elaborate probe:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-comment">// Archetypal expression for assignment operation.</span>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">using</span> <span class="hljs-type">assign_t</span> = <span class="hljs-keyword">decltype</span>(std::<span class="hljs-built_in">declval</span>&lt;T&amp;&gt;() = std::<span class="hljs-built_in">declval</span>&lt;T <span class="hljs-type">const</span> &amp;&gt;())

<span class="hljs-comment">// Trait corresponding to that archetype.</span>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">using</span> is_assignable = detect&lt;T, <span class="hljs-type">assign_t</span>&gt;;
</code></pre>

<p>Compared to the other implementations described above, this one is fairly simple: a reduced set of tools (<code>void_t</code> and <code>detect</code>) suffices, no need for hairy macros.  Besides, it was reported (see <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4502.pdf" rel="noreferrer" title="Proposing Standard Library Support for the C++ Detection Idiom, v2">N4502</a>) that it is measurably more efficient (compile-time and compiler memory consumption) than previous approaches.</p>

<p>Here is a <a href="http://coliru.stacked-crooked.com/a/7eae9c76232a2d20" rel="noreferrer" title="Detection idiom">live example</a>.  It works fine with Clang, but unfortunately, GCC versions before 5.1 followed a different interpretation of the C++11 standard which caused <code>void_t</code> to not work as expected.  Yakk already provided the work-around: use the following definition of <code>void_t</code> (<a href="https://stackoverflow.com/questions/28967003/void-t-in-parameter-list-works-but-not-as-return-type/28967049#28967049">void_t in parameter list works but not as return type</a>):</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-meta">#<span class="hljs-keyword">if</span> __GNUC__ &lt; 5 &amp;&amp; ! defined __clang__</span>
<span class="hljs-comment">// https://stackoverflow.com/a/28967049/1353549</span>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span>...&gt;
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">voider</span>
{
  <span class="hljs-keyword">using</span> type = <span class="hljs-type">void</span>;
};
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span>...Ts&gt;
<span class="hljs-keyword">using</span> <span class="hljs-type">void_t</span> = <span class="hljs-keyword">typename</span> voider&lt;Ts...&gt;::type;
<span class="hljs-meta">#<span class="hljs-keyword">else</span></span>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span>...&gt;
<span class="hljs-keyword">using</span> <span class="hljs-type">void_t</span> = <span class="hljs-type">void</span>;
<span class="hljs-meta">#<span class="hljs-keyword">endif</span></span>
</code></pre>
    </div></div></div></div><div id="solution8" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 8</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/template-meta-programming">template-meta-programming</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/sfinae">sfinae</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>This is what type traits are there for. Unfortunately, they have to be defined manually. In your case, imagine the following:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">response_trait</span> {
    <span class="hljs-type">static</span> <span class="hljs-type">bool</span> <span class="hljs-type">const</span> has_tostring = <span class="hljs-literal">false</span>;
};

<span class="hljs-keyword">template</span> &lt;&gt;
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">response_trait</span>&lt;your_type_with_tostring&gt; {
    <span class="hljs-type">static</span> <span class="hljs-type">bool</span> <span class="hljs-type">const</span> has_tostring = <span class="hljs-literal">true</span>;
}
</code></pre>
    </div></div></div></div><div id="solution9" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 9</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/template-meta-programming">template-meta-programming</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/sfinae">sfinae</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>This is a C++11 solution for the general problem if "If I did X, would it compile?"</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span>&gt; <span class="hljs-keyword">struct</span> <span class="hljs-title class_">type_sink</span> { <span class="hljs-keyword">typedef</span> <span class="hljs-type">void</span> type; }; <span class="hljs-comment">// consumes a type, and makes it `void`</span>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt; <span class="hljs-keyword">using</span> <span class="hljs-type">type_sink_t</span> = <span class="hljs-keyword">typename</span> type_sink&lt;T&gt;::type;
<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>, <span class="hljs-keyword">class</span>=<span class="hljs-type">void</span>&gt; <span class="hljs-keyword">struct</span> has_to_string : std::false_type {}; \
<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt; <span class="hljs-keyword">struct</span> <span class="hljs-title class_">has_to_string</span>&lt;
  T,
  <span class="hljs-type">type_sink_t</span>&lt; <span class="hljs-keyword">decltype</span>( std::<span class="hljs-built_in">declval</span>&lt;T&gt;().<span class="hljs-built_in">toString</span>() ) &gt;
&gt;: std::true_type {};
</code></pre>

<p>Trait <code>has_to_string</code> such that <code>has_to_string&lt;T&gt;::value</code> is <code>true</code> if and only if <code>T</code> has a method <code>.toString</code> that can be invoked with 0 arguments in this context.</p>

<p>Next, I'd use tag dispatching:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-keyword">namespace</span> details {
  <span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> T&gt;
  std::string <span class="hljs-title">optionalToString_helper</span><span class="hljs-params">(T* obj, std::true_type <span class="hljs-comment">/*has_to_string*/</span>)</span> </span>{
    <span class="hljs-keyword">return</span> obj-&gt;<span class="hljs-built_in">toString</span>();
  }
  <span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> T&gt;
  std::string <span class="hljs-title">optionalToString_helper</span><span class="hljs-params">(T* obj, std::false_type <span class="hljs-comment">/*has_to_string*/</span>)</span> </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-string">"toString not defined"</span>;
  }
}
<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> T&gt;
std::string <span class="hljs-title">optionalToString</span><span class="hljs-params">(T* obj)</span> </span>{
  <span class="hljs-keyword">return</span> details::<span class="hljs-built_in">optionalToString_helper</span>( obj, has_to_string&lt;T&gt;{} );
}
</code></pre>

<p>which tends to be more maintainable than complex SFINAE expressions.</p>

<p>You can write these traits with a macro if you find yourself doing it alot, but they are relatively simple (a few lines each) so maybe not worth it:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAKE_CODE_TRAIT( TRAIT_NAME, ... ) \
template<span class="hljs-string">&lt;class T, class=void&gt;</span> struct TRAIT_NAME : std::false_type {}; \
template<span class="hljs-string">&lt;class T&gt;</span> struct TRAIT_NAME<span class="hljs-string">&lt; T, type_sink_t&lt; decltype( __VA_ARGS__ ) &gt;</span> &gt;: std::true_type {};</span>
</code></pre>

<p>what the above does is create a macro <code>MAKE_CODE_TRAIT</code>.  You pass it the name of the trait you want, and some code that can test the type <code>T</code>.  Thus:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-built_in">MAKE_CODE_TRAIT</span>( has_to_string, std::<span class="hljs-built_in">declval</span>&lt;T&gt;().<span class="hljs-built_in">toString</span>() )
</code></pre>

<p>creates the above traits class.</p>

<p>As an aside, the above technique is part of what MS calls "expression SFINAE", and their 2013 compiler fails pretty hard.</p>

<p>Note that in C++1y the following syntax is possible:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> T&gt;
std::string <span class="hljs-title">optionalToString</span><span class="hljs-params">(T* obj)</span> </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-built_in">compiled_if</span>&lt; has_to_string &gt;(*obj, [&amp;](<span class="hljs-keyword">auto</span>&amp;&amp; obj) {
    <span class="hljs-keyword">return</span> obj.<span class="hljs-built_in">toString</span>();
  }) *<span class="hljs-built_in">compiled_else</span> ([&amp;]{ 
    <span class="hljs-keyword">return</span> <span class="hljs-string">"toString not defined"</span>;
  });
}
</code></pre>

<p>which is an inline compilation conditional branch that abuses lots of C++ features.  Doing so is probably not worth it, as the benefit (of code being inline) is not worth the cost (of next to nobody understanding how it works), but the existence of that above solution may be of interest.</p>
    </div></div></div></div><div id="solution10" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 10</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/template-meta-programming">template-meta-programming</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/sfinae">sfinae</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>With C++ 20 you can write the following:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">concept</span> has_toString = <span class="hljs-built_in">requires</span>(<span class="hljs-type">const</span> T&amp; t) {
    t.<span class="hljs-built_in">toString</span>();
};

<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;
std::string <span class="hljs-title">optionalToString</span><span class="hljs-params">(<span class="hljs-type">const</span> T&amp; obj)</span>
</span>{
    <span class="hljs-function"><span class="hljs-keyword">if</span> <span class="hljs-title">constexpr</span> <span class="hljs-params">(has_toString&lt;T&gt;)</span>
        <span class="hljs-keyword">return</span> obj.<span class="hljs-title">toString</span><span class="hljs-params">()</span></span>;
    <span class="hljs-keyword">else</span>
        <span class="hljs-keyword">return</span> <span class="hljs-string">"toString not defined"</span>;
}
</code></pre>
    </div></div></div></div><div id="solution11" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 11</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/template-meta-programming">template-meta-programming</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/sfinae">sfinae</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Here are some usage snippets:
*The guts for all this are farther down</p>

<p><strong>Check for member <code>x</code> in a given class.  Could be var, func, class, union, or enum:</strong></p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-built_in">CREATE_MEMBER_CHECK</span>(x);
<span class="hljs-type">bool</span> has_x = has_member_x&lt;class_to_check_for_x&gt;::value;
</code></pre>

<p><strong>Check for member function <code>void x()</code>:</strong></p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-comment">//Func signature MUST have T as template variable here... simpler this way :\
CREATE_MEMBER_FUNC_SIG_CHECK(x, void (T::*)(), void__x);</span>
<span class="hljs-type">bool</span> has_func_sig_void__x = has_member_func_void__x&lt;class_to_check_for_x&gt;::value;
</code></pre>

<p><strong>Check for member variable <code>x</code>:</strong></p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-built_in">CREATE_MEMBER_VAR_CHECK</span>(x);
<span class="hljs-type">bool</span> has_var_x = has_member_var_x&lt;class_to_check_for_x&gt;::value;
</code></pre>

<p><strong>Check for member class <code>x</code>:</strong></p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-built_in">CREATE_MEMBER_CLASS_CHECK</span>(x);
<span class="hljs-type">bool</span> has_class_x = has_member_class_x&lt;class_to_check_for_x&gt;::value;
</code></pre>

<p><strong>Check for member union <code>x</code>:</strong></p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-built_in">CREATE_MEMBER_UNION_CHECK</span>(x);
<span class="hljs-type">bool</span> has_union_x = has_member_union_x&lt;class_to_check_for_x&gt;::value;
</code></pre>

<p><strong>Check for member enum <code>x</code>:</strong></p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-built_in">CREATE_MEMBER_ENUM_CHECK</span>(x);
<span class="hljs-type">bool</span> has_enum_x = has_member_enum_x&lt;class_to_check_for_x&gt;::value;
</code></pre>

<p><strong>Check for any member function <code>x</code> regardless of signature:</strong></p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-built_in">CREATE_MEMBER_CHECK</span>(x);
<span class="hljs-built_in">CREATE_MEMBER_VAR_CHECK</span>(x);
<span class="hljs-built_in">CREATE_MEMBER_CLASS_CHECK</span>(x);
<span class="hljs-built_in">CREATE_MEMBER_UNION_CHECK</span>(x);
<span class="hljs-built_in">CREATE_MEMBER_ENUM_CHECK</span>(x);
<span class="hljs-built_in">CREATE_MEMBER_FUNC_CHECK</span>(x);
<span class="hljs-type">bool</span> has_any_func_x = has_member_func_x&lt;class_to_check_for_x&gt;::value;
</code></pre>

<p>OR</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-built_in">CREATE_MEMBER_CHECKS</span>(x);  <span class="hljs-comment">//Just stamps out the same macro calls as above.</span>
<span class="hljs-type">bool</span> has_any_func_x = has_member_func_x&lt;class_to_check_for_x&gt;::value;
</code></pre>

<p><strong>Details and core:</strong></p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-comment">/*
    - Multiple inheritance forces ambiguity of member names.
    - SFINAE is used to make aliases to member names.
    - Expression SFINAE is used in just one generic has_member that can accept
      any alias we pass it.
*/</span>

<span class="hljs-comment">//Variadic to force ambiguity of class members.  C++11 and up.</span>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span>... Args&gt; <span class="hljs-keyword">struct</span> <span class="hljs-title class_">ambiguate</span> : <span class="hljs-keyword">public</span> Args... {};

<span class="hljs-comment">//Non-variadic version of the line above.</span>
<span class="hljs-comment">//template &lt;typename A, typename B&gt; struct ambiguate : public A, public B {};</span>

<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> A, <span class="hljs-keyword">typename</span> = <span class="hljs-type">void</span>&gt;
<span class="hljs-keyword">struct</span> got_type : std::false_type {};

<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> A&gt;
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">got_type</span>&lt;A&gt; : std::true_type {
    <span class="hljs-keyword">typedef</span> A type;
};

<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T, T&gt;
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">sig_check</span> : std::true_type {};

<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Alias, <span class="hljs-keyword">typename</span> AmbiguitySeed&gt;
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">has_member</span> {
    <span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> C&gt; <span class="hljs-type">static</span> <span class="hljs-title">char</span> <span class="hljs-params">((&amp;f(<span class="hljs-keyword">decltype</span>(&amp;C::value))))</span>[1]</span>;
    <span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> C&gt; <span class="hljs-type">static</span> <span class="hljs-title">char</span> <span class="hljs-params">((&amp;f(...)))</span>[2]</span>;

    <span class="hljs-comment">//Make sure the member name is consistently spelled the same.</span>
    <span class="hljs-built_in">static_assert</span>(
        (<span class="hljs-built_in">sizeof</span>(<span class="hljs-built_in">f</span>&lt;AmbiguitySeed&gt;(<span class="hljs-number">0</span>)) == <span class="hljs-number">1</span>)
        , <span class="hljs-string">"Member name specified in AmbiguitySeed is different from member name specified in Alias, or wrong Alias/AmbiguitySeed has been specified."</span>
    );

    <span class="hljs-type">static</span> <span class="hljs-type">bool</span> <span class="hljs-type">const</span> value = <span class="hljs-built_in">sizeof</span>(<span class="hljs-built_in">f</span>&lt;Alias&gt;(<span class="hljs-number">0</span>)) == <span class="hljs-number">2</span>;
};
</code></pre>

<p><em><strong>Macros (El Diablo!):</strong></em></p>

<p><strong>CREATE_MEMBER_CHECK:</strong></p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-comment">//Check for any member with given name, whether var, func, class, union, enum.</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> CREATE_MEMBER_CHECK(member)                                         \
                                                                            \
template<span class="hljs-string">&lt;typename T, typename = std::true_type&gt;</span>                             \
struct Alias_##member;                                                      \
                                                                            \
template<span class="hljs-string">&lt;typename T&gt;</span>                                                        \
struct Alias_##member &lt;                                                     \
    T, std::integral_constant<span class="hljs-string">&lt;bool, got_type&lt;decltype(&amp;T::member)&gt;</span>::value&gt;  \
&gt; { static const decltype(&amp;T::member) value; };                             \
                                                                            \
struct AmbiguitySeed_##member { char member; };                             \
                                                                            \
template<span class="hljs-string">&lt;typename T&gt;</span>                                                        \
struct has_member_##member {                                                \
    static const bool value                                                 \
        = has_member&lt;                                                       \
            Alias_##member<span class="hljs-string">&lt;ambiguate&lt;T, AmbiguitySeed_##member&gt;</span>&gt;            \
            , Alias_##member<span class="hljs-string">&lt;AmbiguitySeed_##member&gt;</span>                        \
        &gt;::value                                                            \
    ;                                                                       \
}</span>
</code></pre>

<p><strong>CREATE_MEMBER_VAR_CHECK:</strong></p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-comment">//Check for member variable with given name.</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> CREATE_MEMBER_VAR_CHECK(var_name)                                   \
                                                                            \
template<span class="hljs-string">&lt;typename T, typename = std::true_type&gt;</span>                             \
struct has_member_var_##var_name : std::false_type {};                      \
                                                                            \
template<span class="hljs-string">&lt;typename T&gt;</span>                                                        \
struct has_member_var_##var_name&lt;                                           \
    T                                                                       \
    , std::integral_constant&lt;                                               \
        bool                                                                \
        , !std::is_member_function_pointer<span class="hljs-string">&lt;decltype(&amp;T::var_name)&gt;</span>::value   \
    &gt;                                                                       \
&gt; : std::true_type {}</span>
</code></pre>

<p><strong>CREATE_MEMBER_FUNC_SIG_CHECK:</strong></p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-comment">//Check for member function with given name AND signature.</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> CREATE_MEMBER_FUNC_SIG_CHECK(func_name, func_sig, templ_postfix)    \
                                                                            \
template<span class="hljs-string">&lt;typename T, typename = std::true_type&gt;</span>                             \
struct has_member_func_##templ_postfix : std::false_type {};                \
                                                                            \
template<span class="hljs-string">&lt;typename T&gt;</span>                                                        \
struct has_member_func_##templ_postfix&lt;                                     \
    T, std::integral_constant&lt;                                              \
        bool                                                                \
        , sig_check<span class="hljs-string">&lt;func_sig, &amp;T::func_name&gt;</span>::value                         \
    &gt;                                                                       \
&gt; : std::true_type {}</span>
</code></pre>

<p><strong>CREATE_MEMBER_CLASS_CHECK:</strong></p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-comment">//Check for member class with given name.</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> CREATE_MEMBER_CLASS_CHECK(class_name)               \
                                                            \
template<span class="hljs-string">&lt;typename T, typename = std::true_type&gt;</span>             \
struct has_member_class_##class_name : std::false_type {};  \
                                                            \
template<span class="hljs-string">&lt;typename T&gt;</span>                                        \
struct has_member_class_##class_name&lt;                       \
    T                                                       \
    , std::integral_constant&lt;                               \
        bool                                                \
        , std::is_class&lt;                                    \
            typename got_type<span class="hljs-string">&lt;typename T::class_name&gt;</span>::type \
        &gt;::value                                            \
    &gt;                                                       \
&gt; : std::true_type {}</span>
</code></pre>

<p><strong>CREATE_MEMBER_UNION_CHECK:</strong></p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-comment">//Check for member union with given name.</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> CREATE_MEMBER_UNION_CHECK(union_name)               \
                                                            \
template<span class="hljs-string">&lt;typename T, typename = std::true_type&gt;</span>             \
struct has_member_union_##union_name : std::false_type {};  \
                                                            \
template<span class="hljs-string">&lt;typename T&gt;</span>                                        \
struct has_member_union_##union_name&lt;                       \
    T                                                       \
    , std::integral_constant&lt;                               \
        bool                                                \
        , std::is_union&lt;                                    \
            typename got_type<span class="hljs-string">&lt;typename T::union_name&gt;</span>::type \
        &gt;::value                                            \
    &gt;                                                       \
&gt; : std::true_type {}</span>
</code></pre>

<p><strong>CREATE_MEMBER_ENUM_CHECK:</strong></p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-comment">//Check for member enum with given name.</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> CREATE_MEMBER_ENUM_CHECK(enum_name)                 \
                                                            \
template<span class="hljs-string">&lt;typename T, typename = std::true_type&gt;</span>             \
struct has_member_enum_##enum_name : std::false_type {};    \
                                                            \
template<span class="hljs-string">&lt;typename T&gt;</span>                                        \
struct has_member_enum_##enum_name&lt;                         \
    T                                                       \
    , std::integral_constant&lt;                               \
        bool                                                \
        , std::is_enum&lt;                                     \
            typename got_type<span class="hljs-string">&lt;typename T::enum_name&gt;</span>::type  \
        &gt;::value                                            \
    &gt;                                                       \
&gt; : std::true_type {}</span>
</code></pre>

<p><strong>CREATE_MEMBER_FUNC_CHECK:</strong></p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-comment">//Check for function with given name, any signature.</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> CREATE_MEMBER_FUNC_CHECK(func)          \
template<span class="hljs-string">&lt;typename T&gt;</span>                            \
struct has_member_func_##func {                 \
    static const bool value                     \
        = has_member_##func<span class="hljs-string">&lt;T&gt;</span>::value           \
        &amp;&amp; !has_member_var_##func<span class="hljs-string">&lt;T&gt;</span>::value     \
        &amp;&amp; !has_member_class_##func<span class="hljs-string">&lt;T&gt;</span>::value   \
        &amp;&amp; !has_member_union_##func<span class="hljs-string">&lt;T&gt;</span>::value   \
        &amp;&amp; !has_member_enum_##func<span class="hljs-string">&lt;T&gt;</span>::value    \
    ;                                           \
}</span>
</code></pre>

<p><strong>CREATE_MEMBER_CHECKS:</strong></p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-comment">//Create all the checks for one member.  Does NOT include func sig checks.</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> CREATE_MEMBER_CHECKS(member)    \
CREATE_MEMBER_CHECK(member);            \
CREATE_MEMBER_VAR_CHECK(member);        \
CREATE_MEMBER_CLASS_CHECK(member);      \
CREATE_MEMBER_UNION_CHECK(member);      \
CREATE_MEMBER_ENUM_CHECK(member);       \
CREATE_MEMBER_FUNC_CHECK(member)</span>
</code></pre>
    </div></div></div></div><div id="solution12" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 12</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/template-meta-programming">template-meta-programming</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/sfinae">sfinae</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Yet another way to do it in C++17 (inspired by <code>boost:hana</code>).</p>
<p>This solution does not require <code>has_something&lt;T&gt;</code> SFINAE type traits classes.</p>
<h3>Solution</h3>
<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-comment">////////////////////////////////////////////</span>
<span class="hljs-comment">// has_member implementation</span>
<span class="hljs-comment">////////////////////////////////////////////</span>

<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;type_traits&gt;</span></span>

<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> F&gt;
<span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">auto</span> <span class="hljs-title">has_member_impl</span><span class="hljs-params">(F&amp;&amp; f)</span> -&gt; <span class="hljs-title">decltype</span><span class="hljs-params">(f(std::declval&lt;T&gt;()), <span class="hljs-literal">true</span>)</span>
</span>{
  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
}

<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span>&gt;
<span class="hljs-keyword">constexpr</span> <span class="hljs-type">bool</span> <span class="hljs-title">has_member_impl</span><span class="hljs-params">(...)</span> </span>{ <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; }

<span class="hljs-meta">#<span class="hljs-keyword">define</span> has_member(T, EXPR) \
 has_member_impl<span class="hljs-string">&lt;T&gt;</span>( [](auto&amp;&amp; obj)-&gt;decltype(obj.EXPR){} )</span>

</code></pre>
<h3>Test</h3>
<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-comment">////////////////////////////////////////////</span>
<span class="hljs-comment">// Test</span>
<span class="hljs-comment">////////////////////////////////////////////</span>

<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span>

<span class="hljs-keyword">struct</span> <span class="hljs-title class_">Example</span> {
    <span class="hljs-type">int</span> Foo;
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Bar</span><span class="hljs-params">()</span> </span>{}
    <span class="hljs-function">std::string <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>{ <span class="hljs-keyword">return</span> <span class="hljs-string">"Hello from Example::toString()!"</span>; }
};

<span class="hljs-keyword">struct</span> <span class="hljs-title class_">Example2</span> {
    <span class="hljs-type">int</span> X;
};

<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> T&gt;
std::string <span class="hljs-title">optionalToString</span><span class="hljs-params">(T* obj)</span>
</span>{
    <span class="hljs-function"><span class="hljs-keyword">if</span> <span class="hljs-title">constexpr</span><span class="hljs-params">(has_member(T, toString()))</span>
        <span class="hljs-keyword">return</span> obj-&gt;<span class="hljs-title">toString</span><span class="hljs-params">()</span></span>;
    <span class="hljs-keyword">else</span>
        <span class="hljs-keyword">return</span> <span class="hljs-string">"toString not defined"</span>;
}

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-built_in">static_assert</span>(<span class="hljs-built_in">has_member</span>(Example, Foo), 
                  <span class="hljs-string">"Example class must have Foo member"</span>);
    <span class="hljs-built_in">static_assert</span>(<span class="hljs-built_in">has_member</span>(Example, <span class="hljs-built_in">Bar</span>()), 
                  <span class="hljs-string">"Example class must have Bar() member function"</span>);
    <span class="hljs-built_in">static_assert</span>(!<span class="hljs-built_in">has_member</span>(Example, ZFoo), 
                  <span class="hljs-string">"Example class must not have ZFoo member."</span>);
    <span class="hljs-built_in">static_assert</span>(!<span class="hljs-built_in">has_member</span>(Example, <span class="hljs-built_in">ZBar</span>()), 
                  <span class="hljs-string">"Example class must not have ZBar() member function"</span>);

    Example e1;
    Example2 e2;

    std::cout &lt;&lt; <span class="hljs-string">"e1: "</span> &lt;&lt; <span class="hljs-built_in">optionalToString</span>(&amp;e1) &lt;&lt; <span class="hljs-string">"\n"</span>;
    std::cout &lt;&lt; <span class="hljs-string">"e1: "</span> &lt;&lt; <span class="hljs-built_in">optionalToString</span>(&amp;e2) &lt;&lt; <span class="hljs-string">"\n"</span>;
}
</code></pre>
    </div></div></div></div><div id="solution13" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 13</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/template-meta-programming">template-meta-programming</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/sfinae">sfinae</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>I wrote an answer to this in another thread that (unlike the solutions above) also checks inherited member functions:</p>

<p><a href="https://stackoverflow.com/questions/1966362/sfinae-to-check-for-inherited-member-functions/8752988#8752988">SFINAE to check for inherited member functions</a></p>

<p>Here are some example from that solution:</p>

<h2>Example1:</h2>

<p>We are checking for a member with the following signature: 
<code>T::const_iterator begin() const</code></p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt; <span class="hljs-keyword">struct</span> <span class="hljs-title class_">has_const_begin</span>
{
    <span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">char</span> <span class="hljs-params">(&amp;Yes)</span>[1]</span>;
    <span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">char</span> <span class="hljs-params">(&amp;No)</span>[2]</span>;

    <span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> U&gt; 
    <span class="hljs-type">static</span> Yes <span class="hljs-title">test</span><span class="hljs-params">(U <span class="hljs-type">const</span> * data, 
                    <span class="hljs-keyword">typename</span> std::enable_if&lt;std::is_same&lt;
                             <span class="hljs-keyword">typename</span> U::const_iterator, 
                             <span class="hljs-keyword">decltype</span>(data-&gt;begin())
                    &gt;::value&gt;::type * = <span class="hljs-number">0</span>)</span></span>;
    <span class="hljs-function"><span class="hljs-type">static</span> No <span class="hljs-title">test</span><span class="hljs-params">(...)</span></span>;
    <span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">bool</span> value = <span class="hljs-built_in">sizeof</span>(Yes) == <span class="hljs-built_in">sizeof</span>(has_const_begin::<span class="hljs-built_in">test</span>((<span class="hljs-keyword">typename</span> std::remove_reference&lt;T&gt;::type*)<span class="hljs-number">0</span>));
};
</code></pre>

<p>Please notice that it even checks the constness of the method, and works with primitive types, as well. (I mean <code>has_const_begin&lt;int&gt;::value</code> is false and doesn't cause a compile-time error.) </p>

<h2>Example 2</h2>

<p>Now we are looking for the signature: <code>void foo(MyClass&amp;, unsigned)</code></p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt; <span class="hljs-keyword">struct</span> <span class="hljs-title class_">has_foo</span>
{
    <span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">char</span> <span class="hljs-params">(&amp;Yes)</span>[1]</span>;
    <span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">char</span> <span class="hljs-params">(&amp;No)</span>[2]</span>;

    <span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> U&gt;
    <span class="hljs-type">static</span> Yes <span class="hljs-title">test</span><span class="hljs-params">(U * data, MyClass* arg1 = <span class="hljs-number">0</span>,
                    <span class="hljs-keyword">typename</span> std::enable_if&lt;std::is_void&lt;
                             <span class="hljs-keyword">decltype</span>(data-&gt;foo(*arg1, <span class="hljs-number">1u</span>))
                    &gt;::value&gt;::type * = <span class="hljs-number">0</span>)</span></span>;
    <span class="hljs-function"><span class="hljs-type">static</span> No <span class="hljs-title">test</span><span class="hljs-params">(...)</span></span>;
    <span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">bool</span> value = <span class="hljs-built_in">sizeof</span>(Yes) == <span class="hljs-built_in">sizeof</span>(has_foo::<span class="hljs-built_in">test</span>((<span class="hljs-keyword">typename</span> std::remove_reference&lt;T&gt;::type*)<span class="hljs-number">0</span>));
};
</code></pre>

<p>Please notice that MyClass doesn't has to be default constructible or to satisfy any special concept. The technique works with template members, as well.</p>

<p>I am eagerly waiting opinions regarding this.</p>
    </div></div></div></div><div id="solution14" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 14</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/template-meta-programming">template-meta-programming</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/sfinae">sfinae</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Here is the most concise way I found in C++20, which is very close from your question:</p>
<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> T&gt;
std::string <span class="hljs-title">optionalToString</span><span class="hljs-params">(T* obj)</span>
</span>{
  <span class="hljs-function"><span class="hljs-keyword">if</span> <span class="hljs-title">constexpr</span> <span class="hljs-params">(<span class="hljs-keyword">requires</span> { obj-&gt;toString(); })</span>
    <span class="hljs-keyword">return</span> obj-&gt;<span class="hljs-title">toString</span><span class="hljs-params">()</span></span>;
  <span class="hljs-keyword">else</span>
    <span class="hljs-keyword">return</span> <span class="hljs-string">"toString not defined"</span>;
}
</code></pre>
<p>See it live on godbolt: <a href="https://gcc.godbolt.org/z/5jb1d93Ms" rel="noreferrer">https://gcc.godbolt.org/z/5jb1d93Ms</a></p>
    </div></div></div></div><div id="solution15" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 15</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/template-meta-programming">template-meta-programming</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/sfinae">sfinae</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>The standard C++ solution presented here by litb will not work as expected if the method happens to be defined in a base class. </p>

<p>For a solution that handles this situation refer to :</p>

<p>In Russian :
<a href="http://www.rsdn.ru/forum/message/2759773.1.aspx" rel="noreferrer">http://www.rsdn.ru/forum/message/2759773.1.aspx</a> </p>

<p>English Translation by Roman.Perepelitsa : 
<a href="http://groups.google.com/group/comp.lang.c++.moderated/tree/browse_frm/thread/4f7c7a96f9afbe44/c95a7b4c645e449f?pli=1" rel="noreferrer">http://groups.google.com/group/comp.lang.c++.moderated/tree/browse_frm/thread/4f7c7a96f9afbe44/c95a7b4c645e449f?pli=1</a> </p>

<p>It is insanely clever. However one issue with this solutiion is that gives compiler errors if the type being tested is one that cannot be used as a base class (e.g. primitive types)</p>

<p>In Visual Studio, I noticed that if working with method having no arguments, an extra pair of redundant ( )  needs to be inserted around the argments to deduce( )  in the sizeof expression.</p>
    </div></div></div></div><div id="solution16" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 16</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/template-meta-programming">template-meta-programming</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/sfinae">sfinae</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Now this was a <em>nice</em> little puzzle - great question!</p>

<p>Here's an alternative to <a href="https://stackoverflow.com/questions/257288/possible-for-c-template-to-check-for-a-functions-existence#257382">Nicola Bonelli's solution</a> that does not rely on the non-standard <code>typeof</code> operator.</p>

<p>Unfortunately, it does not work on GCC (MinGW) 3.4.5 or Digital Mars 8.42n, but it does work on all versions of MSVC (including VC6) and on Comeau C++.</p>

<p>The longer comment block has the details on how it works (or is supposed to work).  As it says, I'm not sure which behavior is standards compliant - I'd welcome commentary on that.</p>

<hr>

<p>update - 7 Nov 2008:</p>

<p>It looks like while this code is syntactically correct, the behavior that MSVC and Comeau C++ show does not follow the standard (thanks to <a href="https://stackoverflow.com/users/4727/leon-timmermans">Leon Timmermans</a> and <a href="https://stackoverflow.com/users/34509/litb">litb</a> for pointing me in the right direction).  The C++03 standard says the following:</p>

<blockquote>
  <p>14.6.2 Dependent names [temp.dep]</p>
  
  <p>Paragraph 3</p>
  
  <p>In the definition of a class template
  or a member of a class template, if a
  base class of the class template
  depends on a template-parameter, the
  base class scope is not examined
  during unqualified name lookup either
  at the point of definition of the
  class template or member or during an
  instantiation of the class template or
  member.</p>
</blockquote>

<p>So, it looks like that when MSVC or Comeau consider the <code>toString()</code> member function of <code>T</code> performing name lookup at the call site in <code>doToString()</code> when the template is instantiated, that is incorrect (even though it's actually the behavior I was looking for in this case).</p>

<p>The behavior of GCC and Digital Mars looks to be correct - in both cases the non-member <code>toString()</code> function is bound to the call.</p>

<p>Rats - I thought I might have found a clever solution, instead I uncovered a couple compiler bugs...</p>

<hr>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span>

<span class="hljs-keyword">struct</span> <span class="hljs-title class_">Hello</span>
{
    <span class="hljs-function">std::string <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-string">"Hello"</span>;
    }
};

<span class="hljs-keyword">struct</span> <span class="hljs-title class_">Generic</span> {};


<span class="hljs-comment">// the following namespace keeps the toString() method out of</span>
<span class="hljs-comment">//  most everything - except the other stuff in this</span>
<span class="hljs-comment">//  compilation unit</span>

<span class="hljs-keyword">namespace</span> {
    <span class="hljs-function">std::string <span class="hljs-title">toString</span><span class="hljs-params">()</span>
    </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-string">"toString not defined"</span>;
    }

    <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
    <span class="hljs-keyword">class</span> <span class="hljs-title class_">optionalToStringImpl</span> : <span class="hljs-keyword">public</span> T
    {
    <span class="hljs-keyword">public</span>:
        <span class="hljs-function">std::string <span class="hljs-title">doToString</span><span class="hljs-params">()</span> </span>{

            <span class="hljs-comment">// in theory, the name lookup for this call to </span>
            <span class="hljs-comment">//  toString() should find the toString() in </span>
            <span class="hljs-comment">//  the base class T if one exists, but if one </span>
            <span class="hljs-comment">//  doesn't exist in the base class, it'll </span>
            <span class="hljs-comment">//  find the free toString() function in </span>
            <span class="hljs-comment">//  the private namespace.</span>
            <span class="hljs-comment">//</span>
            <span class="hljs-comment">// This theory works for MSVC (all versions</span>
            <span class="hljs-comment">//  from VC6 to VC9) and Comeau C++, but</span>
            <span class="hljs-comment">//  does not work with MinGW 3.4.5 or </span>
            <span class="hljs-comment">//  Digital Mars 8.42n</span>
            <span class="hljs-comment">//</span>
            <span class="hljs-comment">// I'm honestly not sure what the standard says </span>
            <span class="hljs-comment">//  is the correct behavior here - it's sort </span>
            <span class="hljs-comment">//  of like ADL (Argument Dependent Lookup - </span>
            <span class="hljs-comment">//  also known as Koenig Lookup) but without</span>
            <span class="hljs-comment">//  arguments (except the implied "this" pointer)</span>

            <span class="hljs-keyword">return</span> <span class="hljs-built_in">toString</span>();
        }
    };
}

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-function">std::string <span class="hljs-title">optionalToString</span><span class="hljs-params">(T &amp; obj)</span>
</span>{
    <span class="hljs-comment">// ugly, hacky cast...</span>
    optionalToStringImpl&lt;T&gt;* temp = <span class="hljs-keyword">reinterpret_cast</span>&lt;optionalToStringImpl&lt;T&gt;*&gt;( &amp;obj);

    <span class="hljs-keyword">return</span> temp-&gt;<span class="hljs-built_in">doToString</span>();
}



<span class="hljs-function"><span class="hljs-type">int</span>
<span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span>
</span>{
    Hello helloObj;
    Generic genericObj;

    std::cout &lt;&lt; <span class="hljs-built_in">optionalToString</span>( helloObj) &lt;&lt; std::endl;
    std::cout &lt;&lt; <span class="hljs-built_in">optionalToString</span>( genericObj) &lt;&lt; std::endl;
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>
    </div></div></div></div><div id="solution17" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 17</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/template-meta-programming">template-meta-programming</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/sfinae">sfinae</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>An example using SFINAE and template partial specialization, by writing a <code>Has_foo</code> concept check: </p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;type_traits&gt;</span></span>
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">A</span>{};

<span class="hljs-keyword">struct</span> <span class="hljs-title class_">B</span>{ <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">foo</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span></span>;};

<span class="hljs-keyword">struct</span> <span class="hljs-title class_">C</span>{<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span></span>;};

<span class="hljs-keyword">struct</span> <span class="hljs-title class_">D</span>{<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span></span>;};

<span class="hljs-keyword">struct</span> <span class="hljs-title class_">E</span>: <span class="hljs-keyword">public</span> B{};

<span class="hljs-comment">// available in C++17 onwards as part of &lt;type_traits&gt;</span>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span>...&gt;
<span class="hljs-keyword">using</span> <span class="hljs-type">void_t</span> = <span class="hljs-type">void</span>;

<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> = <span class="hljs-type">void</span>&gt; <span class="hljs-keyword">struct</span> Has_foo: std::false_type{};

<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt; 
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">Has_foo</span>&lt;T, <span class="hljs-type">void_t</span>&lt;
    std::<span class="hljs-type">enable_if_t</span>&lt;
        std::is_same&lt;
            <span class="hljs-type">int</span>, 
            <span class="hljs-keyword">decltype</span>(std::<span class="hljs-built_in">declval</span>&lt;T&gt;().<span class="hljs-built_in">foo</span>((<span class="hljs-type">int</span>)<span class="hljs-number">0</span>, (<span class="hljs-type">int</span>)<span class="hljs-number">0</span>))
        &gt;::value
    &gt;
&gt;&gt;: std::true_type{};


<span class="hljs-built_in">static_assert</span>(<span class="hljs-keyword">not</span> Has_foo&lt;A&gt;::value, <span class="hljs-string">"A does not have a foo"</span>);
<span class="hljs-built_in">static_assert</span>(Has_foo&lt;B&gt;::value, <span class="hljs-string">"B has a foo"</span>);
<span class="hljs-built_in">static_assert</span>(<span class="hljs-keyword">not</span> Has_foo&lt;C&gt;::value, <span class="hljs-string">"C has a foo with the wrong return. "</span>);
<span class="hljs-built_in">static_assert</span>(<span class="hljs-keyword">not</span> Has_foo&lt;D&gt;::value, <span class="hljs-string">"D has a foo with the wrong arguments. "</span>);
<span class="hljs-built_in">static_assert</span>(Has_foo&lt;E&gt;::value, <span class="hljs-string">"E has a foo since it inherits from B"</span>);
</code></pre>
    </div></div></div></div><div id="solution18" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 18</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/template-meta-programming">template-meta-programming</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/sfinae">sfinae</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>MSVC has the __if_exists and __if_not_exists keywords (<a href="http://msdn.microsoft.com/en-us/library/x7wy9xh3(VS.80).aspx" rel="noreferrer">Doc</a>). Together with the typeof-SFINAE approach of Nicola I could create a check for GCC and MSVC like the OP looked for.</p>

<p><strong>Update:</strong> Source can be found <a href="https://github.com/nob13/sfserialization/blob/master/sfserialization/isdefault.h" rel="noreferrer">Here</a></p>
    </div></div></div></div><div id="solution19" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 19</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/template-meta-programming">template-meta-programming</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/sfinae">sfinae</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>I modified the solution provided in <a href="https://stackoverflow.com/a/264088/2712152">https://stackoverflow.com/a/264088/2712152</a> to make it a bit more general. Also since it doesn't use any of the new C++11 features we can use it with old compilers and should also work with msvc. But the compilers should enable C99 to use this since it uses variadic macros.</p>

<p>The following macro can be used to check if a particular class has a particular typedef or not.</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-comment">/** 
 * @class      : HAS_TYPEDEF
 * @brief      : This macro will be used to check if a class has a particular
 * typedef or not.
 * @param typedef_name : Name of Typedef
 * @param name  : Name of struct which is going to be run the test for
 * the given particular typedef specified in typedef_name
 */</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> HAS_TYPEDEF(typedef_name, name)                           \
   template <span class="hljs-string">&lt;typename T&gt;</span>                                          \
   struct name {                                                  \
      typedef char yes[1];                                        \
      typedef char no[2];                                         \
      template <span class="hljs-string">&lt;typename U&gt;</span>                                       \
      struct type_check;                                          \
      template <span class="hljs-string">&lt;typename _1&gt;</span>                                      \
      static yes&amp; chk(type_check<span class="hljs-string">&lt;typename _1::typedef_name&gt;</span>*);    \
      template <span class="hljs-string">&lt;typename&gt;</span>                                         \
      static no&amp; chk(...);                                        \
      static bool const value = sizeof(chk<span class="hljs-string">&lt;T&gt;</span>(0)) == sizeof(yes); \
   }</span>
</code></pre>

<p>The following macro can be used to check if a particular class has a particular member function or not with any given number of arguments.</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-comment">/** 
 * @class      : HAS_MEM_FUNC
 * @brief      : This macro will be used to check if a class has a particular
 * member function implemented in the public section or not. 
 * @param func : Name of Member Function
 * @param name : Name of struct which is going to be run the test for
 * the given particular member function name specified in func
 * @param return_type: Return type of the member function
 * @param ellipsis(...) : Since this is macro should provide test case for every
 * possible member function we use variadic macros to cover all possibilities
 */</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> HAS_MEM_FUNC(func, name, return_type, ...)                \
   template <span class="hljs-string">&lt;typename T&gt;</span>                                          \
   struct name {                                                  \
      typedef return_type (T::*Sign)(__VA_ARGS__);                \
      typedef char yes[1];                                        \
      typedef char no[2];                                         \
      template <span class="hljs-string">&lt;typename U, U&gt;</span>                                    \
      struct type_check;                                          \
      template <span class="hljs-string">&lt;typename _1&gt;</span>                                      \
      static yes&amp; chk(type_check<span class="hljs-string">&lt;Sign, &amp;_1::func&gt;</span>*);              \
      template <span class="hljs-string">&lt;typename&gt;</span>                                         \
      static no&amp; chk(...);                                        \
      static bool const value = sizeof(chk<span class="hljs-string">&lt;T&gt;</span>(0)) == sizeof(yes); \
   }</span>
</code></pre>

<p>We can use the above 2 macros to perform the checks for has_typedef and has_mem_func as:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> {
<span class="hljs-keyword">public</span>:
  <span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> check;
  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">check_function</span><span class="hljs-params">()</span> </span>{}
};

<span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> {
<span class="hljs-keyword">public</span>:
  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">hello</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">double</span> b)</span> </span>{}
  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">hello</span><span class="hljs-params">()</span> </span>{}
};

<span class="hljs-built_in">HAS_MEM_FUNC</span>(check_function, has_check_function, <span class="hljs-type">void</span>, <span class="hljs-type">void</span>);
<span class="hljs-built_in">HAS_MEM_FUNC</span>(hello, hello_check, <span class="hljs-type">void</span>, <span class="hljs-type">int</span>, <span class="hljs-type">double</span>);
<span class="hljs-built_in">HAS_MEM_FUNC</span>(hello, hello_void_check, <span class="hljs-type">void</span>, <span class="hljs-type">void</span>);
<span class="hljs-built_in">HAS_TYPEDEF</span>(check, has_typedef_check);

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
  std::cout &lt;&lt; <span class="hljs-string">"Check Function A:"</span> &lt;&lt; has_check_function&lt;A&gt;::value &lt;&lt; std::endl;
  std::cout &lt;&lt; <span class="hljs-string">"Check Function B:"</span> &lt;&lt; has_check_function&lt;B&gt;::value &lt;&lt; std::endl;
  std::cout &lt;&lt; <span class="hljs-string">"Hello Function A:"</span> &lt;&lt; hello_check&lt;A&gt;::value &lt;&lt; std::endl;
  std::cout &lt;&lt; <span class="hljs-string">"Hello Function B:"</span> &lt;&lt; hello_check&lt;B&gt;::value &lt;&lt; std::endl;
  std::cout &lt;&lt; <span class="hljs-string">"Hello void Function A:"</span> &lt;&lt; hello_void_check&lt;A&gt;::value &lt;&lt; std::endl;
  std::cout &lt;&lt; <span class="hljs-string">"Hello void Function B:"</span> &lt;&lt; hello_void_check&lt;B&gt;::value &lt;&lt; std::endl;
  std::cout &lt;&lt; <span class="hljs-string">"Check Typedef A:"</span> &lt;&lt; has_typedef_check&lt;A&gt;::value &lt;&lt; std::endl;
  std::cout &lt;&lt; <span class="hljs-string">"Check Typedef B:"</span> &lt;&lt; has_typedef_check&lt;B&gt;::value &lt;&lt; std::endl;
}
</code></pre>
    </div></div></div></div><div id="solution20" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 20</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/template-meta-programming">template-meta-programming</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/sfinae">sfinae</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Strange nobody suggested the following nice trick I saw once on this very site :</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">has_foo</span>
{
    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">S</span> { <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">(...)</span></span>; };
    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">derived</span> : S, T {};

    <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> V, V&gt; <span class="hljs-keyword">struct</span> <span class="hljs-title class_">W</span> {};

    <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> X&gt;
    <span class="hljs-built_in">char</span> (&amp;<span class="hljs-built_in">test</span>(W&lt;<span class="hljs-built_in">void</span> (X::*)(), &amp;X::foo&gt; *))[<span class="hljs-number">1</span>];

    <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span>&gt;
    <span class="hljs-built_in">char</span> (&amp;<span class="hljs-built_in">test</span>(...))[<span class="hljs-number">2</span>];

    <span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">bool</span> value = <span class="hljs-built_in">sizeof</span>(<span class="hljs-built_in">test</span>&lt;derived&gt;(<span class="hljs-number">0</span>)) == <span class="hljs-number">1</span>;
};
</code></pre>

<p>You have to make sure T is a class. It seems that ambiguity in the lookup of foo is a substitution failure. I made it work on gcc, not sure if it is standard though.</p>
    </div></div></div></div><div id="solution21" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 21</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/template-meta-programming">template-meta-programming</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/sfinae">sfinae</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>The generic template that can be used for checking if some "feature" is supported by the type:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;type_traits&gt;</span></span>

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span>&gt; <span class="hljs-keyword">class</span> <span class="hljs-title class_">TypeChecker</span>, <span class="hljs-keyword">typename</span> Type&gt;
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">is_supported</span>
{
    <span class="hljs-comment">// these structs are used to recognize which version</span>
    <span class="hljs-comment">// of the two functions was chosen during overload resolution</span>
    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">supported</span> {};
    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">not_supported</span> {};

    <span class="hljs-comment">// this overload of chk will be ignored by SFINAE principle</span>
    <span class="hljs-comment">// if TypeChecker&lt;Type_&gt; is invalid type</span>
    <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Type_&gt;
    <span class="hljs-function"><span class="hljs-type">static</span> supported <span class="hljs-title">chk</span><span class="hljs-params">(<span class="hljs-keyword">typename</span> std::decay&lt;TypeChecker&lt;Type_&gt;&gt;::type *)</span></span>;

    <span class="hljs-comment">// ellipsis has the lowest conversion rank, so this overload will be</span>
    <span class="hljs-comment">// chosen during overload resolution only if the template overload above is ignored</span>
    <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Type_&gt;
    <span class="hljs-function"><span class="hljs-type">static</span> not_supported <span class="hljs-title">chk</span><span class="hljs-params">(...)</span></span>;

    <span class="hljs-comment">// if the template overload of chk is chosen during</span>
    <span class="hljs-comment">// overload resolution then the feature is supported</span>
    <span class="hljs-comment">// if the ellipses overload is chosen the the feature is not supported</span>
    <span class="hljs-type">static</span> <span class="hljs-keyword">constexpr</span> <span class="hljs-type">bool</span> value = std::is_same&lt;<span class="hljs-keyword">decltype</span>(<span class="hljs-built_in">chk</span>&lt;Type&gt;(<span class="hljs-literal">nullptr</span>)),supported&gt;::value;
};
</code></pre>

<p>The template that checks whether there is a method <code>foo</code> that is compatible with signature <code>double(const char*)</code></p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-comment">// if T doesn't have foo method with the signature that allows to compile the bellow</span>
<span class="hljs-comment">// expression then instantiating this template is Substitution Failure (SF)</span>
<span class="hljs-comment">// which Is Not An Error (INAE) if this happens during overload resolution</span>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">using</span> has_foo = <span class="hljs-keyword">decltype</span>(<span class="hljs-built_in">double</span>(std::<span class="hljs-built_in">declval</span>&lt;T&gt;().<span class="hljs-built_in">foo</span>(std::<span class="hljs-built_in">declval</span>&lt;<span class="hljs-type">const</span> <span class="hljs-type">char</span>*&gt;())));
</code></pre>

<p>Examples</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-comment">// types that support has_foo</span>
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">struct1</span> { <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">foo</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>*)</span></span>; };            <span class="hljs-comment">// exact signature match</span>
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">struct2</span> { <span class="hljs-function"><span class="hljs-type">int</span>    <span class="hljs-title">foo</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string &amp;str)</span></span>; }; <span class="hljs-comment">// compatible signature</span>
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">struct3</span> { <span class="hljs-function"><span class="hljs-type">float</span>  <span class="hljs-title">foo</span><span class="hljs-params">(...)</span></span>; };                    <span class="hljs-comment">// compatible ellipsis signature</span>
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">struct4</span> { <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
                 <span class="hljs-function"><span class="hljs-type">int</span>    <span class="hljs-title">foo</span><span class="hljs-params">(T t)</span></span>; };                    <span class="hljs-comment">// compatible template signature</span>

<span class="hljs-comment">// types that do not support has_foo</span>
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">struct5</span> { <span class="hljs-function"><span class="hljs-type">void</span>        <span class="hljs-title">foo</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>*)</span></span>; }; <span class="hljs-comment">// returns void</span>
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">struct6</span> { <span class="hljs-function">std::string <span class="hljs-title">foo</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>*)</span></span>; }; <span class="hljs-comment">// std::string can't be converted to double</span>
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">struct7</span> { <span class="hljs-function"><span class="hljs-type">double</span>      <span class="hljs-title">foo</span><span class="hljs-params">(      <span class="hljs-type">int</span> *)</span></span>; }; <span class="hljs-comment">// const char* can't be converted to int*</span>
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">struct8</span> { <span class="hljs-function"><span class="hljs-type">double</span>      <span class="hljs-title">bar</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>*)</span></span>; }; <span class="hljs-comment">// there is no foo method</span>

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    std::cout &lt;&lt; std::boolalpha;

    std::cout &lt;&lt; is_supported&lt;has_foo, <span class="hljs-type">int</span>    &gt;::value &lt;&lt; std::endl; <span class="hljs-comment">// false</span>
    std::cout &lt;&lt; is_supported&lt;has_foo, <span class="hljs-type">double</span> &gt;::value &lt;&lt; std::endl; <span class="hljs-comment">// false</span>

    std::cout &lt;&lt; is_supported&lt;has_foo, struct1&gt;::value &lt;&lt; std::endl; <span class="hljs-comment">// true</span>
    std::cout &lt;&lt; is_supported&lt;has_foo, struct2&gt;::value &lt;&lt; std::endl; <span class="hljs-comment">// true</span>
    std::cout &lt;&lt; is_supported&lt;has_foo, struct3&gt;::value &lt;&lt; std::endl; <span class="hljs-comment">// true</span>
    std::cout &lt;&lt; is_supported&lt;has_foo, struct4&gt;::value &lt;&lt; std::endl; <span class="hljs-comment">// true</span>

    std::cout &lt;&lt; is_supported&lt;has_foo, struct5&gt;::value &lt;&lt; std::endl; <span class="hljs-comment">// false</span>
    std::cout &lt;&lt; is_supported&lt;has_foo, struct6&gt;::value &lt;&lt; std::endl; <span class="hljs-comment">// false</span>
    std::cout &lt;&lt; is_supported&lt;has_foo, struct7&gt;::value &lt;&lt; std::endl; <span class="hljs-comment">// false</span>
    std::cout &lt;&lt; is_supported&lt;has_foo, struct8&gt;::value &lt;&lt; std::endl; <span class="hljs-comment">// false</span>

    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>

<p><a href="http://coliru.stacked-crooked.com/a/83c6a631ed42cea4" rel="nofollow">http://coliru.stacked-crooked.com/a/83c6a631ed42cea4</a></p>
    </div></div></div></div><div id="solution22" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 22</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/template-meta-programming">template-meta-programming</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/sfinae">sfinae</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>I know that this question is years old, but I think it would useful for people like me to have a more complete updated answer that also works for <code>const</code> overloaded methods such as <code>std::vector&lt;&gt;::begin</code>.</p>
<p>Based on that <a href="https://stackoverflow.com/a/257382/4602726">answer</a> and that <a href="https://stackoverflow.com/a/63818399/4602726">answer</a> from my follow up question, here's a more complete answer. Note that this will only work with C++11 and higher.</p>
<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span>

<span class="hljs-keyword">class</span> <span class="hljs-title class_">EmptyClass</span>{};

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">class</span> <span class="hljs-title class_">has_begin</span>
{
    <span class="hljs-keyword">private</span>:
    <span class="hljs-built_in">has_begin</span>() = <span class="hljs-keyword">delete</span>;
    
    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">one</span> { <span class="hljs-type">char</span> x[<span class="hljs-number">1</span>]; };
    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">two</span> { <span class="hljs-type">char</span> x[<span class="hljs-number">2</span>]; };

    <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> C&gt; <span class="hljs-function"><span class="hljs-type">static</span> one <span class="hljs-title">test</span><span class="hljs-params">( <span class="hljs-keyword">decltype</span>(<span class="hljs-type">void</span>(std::declval&lt;C &amp;&gt;().begin())) * )</span> </span>;
    <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> C&gt; <span class="hljs-function"><span class="hljs-type">static</span> two <span class="hljs-title">test</span><span class="hljs-params">(...)</span></span>;    

<span class="hljs-keyword">public</span>:
    <span class="hljs-type">static</span> <span class="hljs-keyword">constexpr</span> <span class="hljs-type">bool</span> value = <span class="hljs-built_in">sizeof</span>(<span class="hljs-built_in">test</span>&lt;T&gt;(<span class="hljs-number">0</span>)) == <span class="hljs-built_in">sizeof</span>(one);
};
    
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span>
</span>{
    std::cout &lt;&lt; std::boolalpha;
    std::cout &lt;&lt; <span class="hljs-string">"vector&lt;int&gt;::begin() exists: "</span> &lt;&lt; has_begin&lt;std::vector&lt;<span class="hljs-type">int</span>&gt;&gt;::value &lt;&lt; std::endl;
    std::cout &lt;&lt; <span class="hljs-string">"EmptyClass::begin() exists: "</span> &lt;&lt; has_begin&lt;EmptyClass&gt;::value &lt;&lt; std::endl;
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>
<p>Or the shorter version:</p>
<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span>

<span class="hljs-keyword">class</span> <span class="hljs-title class_">EmptyClass</span>{};

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> = <span class="hljs-type">void</span>&gt;
<span class="hljs-keyword">struct</span> has_begin : std::false_type {};

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">has_begin</span>&lt;T, <span class="hljs-keyword">decltype</span>(<span class="hljs-built_in">void</span>(std::<span class="hljs-built_in">declval</span>&lt;T &amp;&gt;().<span class="hljs-built_in">begin</span>()))&gt; : std::true_type {};

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span>
</span>{
    std::cout &lt;&lt; std::boolalpha;
    std::cout &lt;&lt; <span class="hljs-string">"vector&lt;int&gt;::begin() exists: "</span> &lt;&lt; has_begin&lt;std::vector&lt;<span class="hljs-type">int</span>&gt;&gt;::value &lt;&lt; std::endl;
    std::cout &lt;&lt; <span class="hljs-string">"EmptyClass exists: "</span> &lt;&lt; has_begin&lt;EmptyClass&gt;::value &lt;&lt; std::endl;
}
</code></pre>
<p>Note that here a complete sample call must be provided. This means that if we tested for the <code>resize</code> method's existence then we would have put <code>resize(0)</code>.</p>
<p><strong>Deep magic explanation</strong>:</p>
<p>The first answer posted of this question used <code>test( decltype(&amp;C::helloworld) )</code>; however this is problematic when the method it is testing is ambiguous due const overloading, thus making the substitution attempt fail.</p>
<p>To solve this ambiguity we use a void statement which can take any parameters because it is always translated into a <code>noop</code> and thus the ambiguity is nullified and the call is valid as long as the method exists:</p>
<pre class="lang-cpp s-code-block"><code class="hljs language-cpp">has_begin&lt;T, <span class="hljs-keyword">decltype</span>(<span class="hljs-built_in">void</span>(std::<span class="hljs-built_in">declval</span>&lt;T &amp;&gt;().<span class="hljs-built_in">begin</span>()))&gt;
</code></pre>
<p>Here's what's happening in order:
We use <code>std::declval&lt;T &amp;&gt;()</code> to create a callable value for which <code>begin</code> can then be called. After that the value of <code>begin</code> is passed as a parameter to a void statement. We then retrieve the type of that void expression using the builtin <code>decltype</code> so that it can be used as a template type argument. If <code>begin</code> doesn't exist then the substitution is invalid and as per SFINAE the other declaration is used instead.</p>
    </div></div></div></div><div id="solution23" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 23</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/template-meta-programming">template-meta-programming</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/sfinae">sfinae</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>How about this solution?</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;type_traits&gt;</span></span>

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> U, <span class="hljs-keyword">typename</span> = <span class="hljs-type">void</span>&gt; <span class="hljs-keyword">struct</span> hasToString : std::false_type { };

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> U&gt;
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">hasToString</span>&lt;U,
  <span class="hljs-keyword">typename</span> std::enable_if&lt;<span class="hljs-built_in">bool</span>(<span class="hljs-built_in">sizeof</span>(&amp;U::toString))&gt;::type
&gt; : std::true_type { };
</code></pre>
    </div></div></div></div><div id="solution24" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 24</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/template-meta-programming">template-meta-programming</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/sfinae">sfinae</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>There are a lot of answers here, but I failed, to find a version, that performs <em>real</em> method resolution ordering, while not using any of the newer c++ features (only using c++98 features).<br>
Note: This version is tested and working with vc++2013, g++ 5.2.0 and the onlline compiler.<br></p>

<p>So I came up with a version, that only uses sizeof():</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt; T <span class="hljs-title">declval</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>;

<span class="hljs-keyword">struct</span> <span class="hljs-title class_">fake_void</span> { };
<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt; T &amp;<span class="hljs-keyword">operator</span>,(T &amp;,fake_void);
<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt; T <span class="hljs-type">const</span> &amp;<span class="hljs-keyword">operator</span>,(T <span class="hljs-type">const</span> &amp;,fake_void);
<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt; T <span class="hljs-keyword">volatile</span> &amp;<span class="hljs-keyword">operator</span>,(T <span class="hljs-keyword">volatile</span> &amp;,fake_void);
<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt; T <span class="hljs-type">const</span> <span class="hljs-keyword">volatile</span> &amp;<span class="hljs-keyword">operator</span>,(T <span class="hljs-type">const</span> <span class="hljs-keyword">volatile</span> &amp;,fake_void);

<span class="hljs-keyword">struct</span> <span class="hljs-title class_">yes</span> { <span class="hljs-type">char</span> v[<span class="hljs-number">1</span>]; };
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">no</span>  { <span class="hljs-type">char</span> v[<span class="hljs-number">2</span>]; };
<span class="hljs-keyword">template</span>&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-keyword">struct</span> <span class="hljs-title class_">yes_no</span>:yes{};
<span class="hljs-keyword">template</span>&lt;&gt; <span class="hljs-keyword">struct</span> <span class="hljs-title class_">yes_no</span>&lt;<span class="hljs-literal">false</span>&gt;:no{};

<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">has_awesome_member</span> {
 <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> U&gt; <span class="hljs-type">static</span> yes_no&lt;(<span class="hljs-built_in">sizeof</span>((
   <span class="hljs-built_in">declval</span>&lt;U&gt;().<span class="hljs-built_in">awesome_member</span>(),<span class="hljs-built_in">fake_void</span>()
  ))!=<span class="hljs-number">0</span>)&gt; <span class="hljs-built_in">check</span>(<span class="hljs-type">int</span>);
 <span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span>&gt; <span class="hljs-type">static</span> no <span class="hljs-title">check</span><span class="hljs-params">(...)</span></span>;
 <span class="hljs-keyword">enum</span>{value=<span class="hljs-built_in">sizeof</span>(<span class="hljs-built_in">check</span>&lt;T&gt;(<span class="hljs-number">0</span>)) == <span class="hljs-built_in">sizeof</span>(yes)};
};


<span class="hljs-keyword">struct</span> <span class="hljs-title class_">foo</span> { <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">awesome_member</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>; };
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">bar</span> { };
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">foo_void</span> { <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">awesome_member</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>; };
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">wrong_params</span> { <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">awesome_member</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span></span>; };

<span class="hljs-built_in">static_assert</span>(has_awesome_member&lt;foo&gt;::value,<span class="hljs-string">""</span>);
<span class="hljs-built_in">static_assert</span>(!has_awesome_member&lt;bar&gt;::value,<span class="hljs-string">""</span>);
<span class="hljs-built_in">static_assert</span>(has_awesome_member&lt;foo_void&gt;::value,<span class="hljs-string">""</span>);
<span class="hljs-built_in">static_assert</span>(!has_awesome_member&lt;wrong_params&gt;::value,<span class="hljs-string">""</span>);
</code></pre>

<p>Live demo (with extended return type checking and vc++2010 workaround): <a href="http://cpp.sh/5b2vs" rel="nofollow noreferrer">http://cpp.sh/5b2vs</a></p>

<p>No source, as I came up with it myself.</p>

<p>When running the Live demo on the g++ compiler, please note that array sizes of 0 are allowed, meaning that the static_assert used will not trigger a compiler error, even when it fails.<br>
A commonly used work-around is to replace the 'typedef' in the macro with 'extern'.</p>
    </div></div></div></div><div id="solution25" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 25</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/template-meta-programming">template-meta-programming</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/sfinae">sfinae</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>My take: to universally determine if something is callable without making verbose type traits for each and every one, or using experimental features, or long code:</p>
<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Callable, <span class="hljs-keyword">typename</span>... Args, <span class="hljs-keyword">typename</span> = <span class="hljs-keyword">decltype</span>(<span class="hljs-built_in">declval</span>&lt;Callable&gt;()(<span class="hljs-built_in">declval</span>&lt;Args&gt;()...))&gt;
std::true_type <span class="hljs-built_in">isCallableImpl</span>(Callable, Args...) { <span class="hljs-keyword">return</span> {}; }

<span class="hljs-function">std::false_type <span class="hljs-title">isCallableImpl</span><span class="hljs-params">(...)</span> </span>{ <span class="hljs-keyword">return</span> {}; }

<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span>... Args, <span class="hljs-keyword">typename</span> Callable&gt;
<span class="hljs-keyword">constexpr</span> <span class="hljs-type">bool</span> <span class="hljs-title">isCallable</span><span class="hljs-params">(Callable callable)</span> </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">decltype</span>(<span class="hljs-built_in">isCallableImpl</span>(callable, <span class="hljs-built_in">declval</span>&lt;Args&gt;()...)){};
}
</code></pre>
<p>Usage:</p>
<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">auto</span> TO_STRING_TEST = [](<span class="hljs-keyword">auto</span> in) -&gt; <span class="hljs-keyword">decltype</span>(in.<span class="hljs-built_in">toString</span>()) { <span class="hljs-keyword">return</span> {}; };
<span class="hljs-keyword">constexpr</span> <span class="hljs-type">bool</span> TO_STRING_WORKS = <span class="hljs-built_in">isCallable</span>&lt;T&gt;(TO_STRING_TEST);
</code></pre>
    </div></div></div></div><div id="solution26" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 26</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/template-meta-programming">template-meta-programming</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/sfinae">sfinae</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Here is my version that handles all possible member function overloads with arbitrary arity, including template member functions, possibly with default arguments. It distinguishes 3 mutually exclusive scenarios when making a member function call to some class type, with given arg types: (1) valid, or (2) ambiguous, or (3) non-viable. Example usage:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span>

<span class="hljs-built_in">HAS_MEM</span>(bar)
<span class="hljs-built_in">HAS_MEM_FUN_CALL</span>(bar)

<span class="hljs-keyword">struct</span> <span class="hljs-title class_">test</span>
{
   <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bar</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span></span>;
   <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bar</span><span class="hljs-params">(<span class="hljs-type">double</span>)</span></span>;
   <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bar</span><span class="hljs-params">(<span class="hljs-type">int</span>,<span class="hljs-type">double</span>)</span></span>;

   <span class="hljs-keyword">template</span> &lt; <span class="hljs-keyword">typename</span> T &gt;
   <span class="hljs-keyword">typename</span> std::enable_if&lt; <span class="hljs-keyword">not</span> std::is_integral&lt;T&gt;::value &gt;::<span class="hljs-function">type
   <span class="hljs-title">bar</span><span class="hljs-params">(<span class="hljs-type">const</span> T&amp;, <span class="hljs-type">int</span>=<span class="hljs-number">0</span>)</span></span>{}

   <span class="hljs-keyword">template</span> &lt; <span class="hljs-keyword">typename</span> T &gt;
   <span class="hljs-keyword">typename</span> std::enable_if&lt; std::is_integral&lt;T&gt;::value &gt;::<span class="hljs-function">type
   <span class="hljs-title">bar</span><span class="hljs-params">(<span class="hljs-type">const</span> std::vector&lt;T&gt;&amp;, T*)</span></span>{}

   <span class="hljs-keyword">template</span> &lt; <span class="hljs-keyword">typename</span> T &gt;
   <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">bar</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp;, <span class="hljs-type">int</span>)</span></span>{}
};
</code></pre>

<p>Now you can use it like this:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">const</span> <span class="hljs-type">char</span> * argv[])</span>
</span>{
   <span class="hljs-built_in">static_assert</span>( has_mem_bar&lt;test&gt;::value , <span class="hljs-string">""</span>);

   <span class="hljs-built_in">static_assert</span>( has_valid_mem_fun_call_bar&lt;<span class="hljs-built_in">test</span>(<span class="hljs-type">char</span> <span class="hljs-type">const</span>*,<span class="hljs-type">long</span>)&gt;::value , <span class="hljs-string">""</span>);
   <span class="hljs-built_in">static_assert</span>( has_valid_mem_fun_call_bar&lt;<span class="hljs-built_in">test</span>(std::string&amp;,<span class="hljs-type">long</span>)&gt;::value , <span class="hljs-string">""</span>);

   <span class="hljs-built_in">static_assert</span>( has_valid_mem_fun_call_bar&lt;<span class="hljs-built_in">test</span>(std::vector&lt;<span class="hljs-type">int</span>&gt;, <span class="hljs-type">int</span>*)&gt;::value , <span class="hljs-string">""</span>);
   <span class="hljs-built_in">static_assert</span>( has_no_viable_mem_fun_call_bar&lt;<span class="hljs-built_in">test</span>(std::vector&lt;<span class="hljs-type">double</span>&gt;, <span class="hljs-type">double</span>*)&gt;::value , <span class="hljs-string">""</span>);

   <span class="hljs-built_in">static_assert</span>( has_valid_mem_fun_call_bar&lt;<span class="hljs-built_in">test</span>(<span class="hljs-type">int</span>)&gt;::value , <span class="hljs-string">""</span>);
   <span class="hljs-built_in">static_assert</span>( std::is_same&lt;<span class="hljs-type">void</span>,result_of_mem_fun_call_bar&lt;<span class="hljs-built_in">test</span>(<span class="hljs-type">int</span>)&gt;::type&gt;::value , <span class="hljs-string">""</span>);

   <span class="hljs-built_in">static_assert</span>( has_valid_mem_fun_call_bar&lt;<span class="hljs-built_in">test</span>(<span class="hljs-type">int</span>,<span class="hljs-type">double</span>)&gt;::value , <span class="hljs-string">""</span>);
   <span class="hljs-built_in">static_assert</span>( <span class="hljs-keyword">not</span> has_valid_mem_fun_call_bar&lt;<span class="hljs-built_in">test</span>(<span class="hljs-type">int</span>,<span class="hljs-type">double</span>,<span class="hljs-type">int</span>)&gt;::value , <span class="hljs-string">""</span>);

   <span class="hljs-built_in">static_assert</span>( <span class="hljs-keyword">not</span> has_ambiguous_mem_fun_call_bar&lt;<span class="hljs-built_in">test</span>(<span class="hljs-type">double</span>)&gt;::value , <span class="hljs-string">""</span>);
   <span class="hljs-built_in">static_assert</span>( has_ambiguous_mem_fun_call_bar&lt;<span class="hljs-built_in">test</span>(<span class="hljs-type">unsigned</span>)&gt;::value , <span class="hljs-string">""</span>);

   <span class="hljs-built_in">static_assert</span>( has_viable_mem_fun_call_bar&lt;<span class="hljs-built_in">test</span>(<span class="hljs-type">unsigned</span>)&gt;::value , <span class="hljs-string">""</span>);
   <span class="hljs-built_in">static_assert</span>( has_viable_mem_fun_call_bar&lt;<span class="hljs-built_in">test</span>(<span class="hljs-type">int</span>)&gt;::value , <span class="hljs-string">""</span>);

   <span class="hljs-built_in">static_assert</span>( has_no_viable_mem_fun_call_bar&lt;<span class="hljs-built_in">test</span>(<span class="hljs-type">void</span>)&gt;::value , <span class="hljs-string">""</span>);

   <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>

<p>Here is the code, written in c++11, however, you can easily port it (with minor tweaks) to non-c++11 that has typeof extensions (e.g. gcc). You can replace the HAS_MEM macro with your own.</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> once</span>

<span class="hljs-meta">#<span class="hljs-keyword">if</span> __cplusplus &gt;= 201103</span>

<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;utility&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;type_traits&gt;</span></span>

<span class="hljs-meta">#<span class="hljs-keyword">define</span> HAS_MEM(mem)                                                                                     \
                                                                                                     \
template <span class="hljs-string">&lt; typename T &gt;</span>                                                                               \
struct has_mem_##mem                                                                                  \
{                                                                                                     \
  struct yes {};                                                                                     \
  struct no  {};                                                                                     \
                                                                                                     \
  struct ambiguate_seed { char mem; };                                                               \
  template <span class="hljs-string">&lt; typename U &gt;</span> struct ambiguate : U, ambiguate_seed {};                                   \
                                                                                                     \
  template <span class="hljs-string">&lt; typename U, typename = decltype(&amp;U::mem) &gt;</span> static constexpr no  test(int);              \
  template <span class="hljs-string">&lt; typename                                 &gt;</span> static constexpr yes test(...);              \
                                                                                                     \
  static bool constexpr value = std::is_same<span class="hljs-string">&lt;decltype(test&lt; ambiguate&lt;T&gt;</span> &gt;(0)),yes&gt;::value ;         \
  typedef std::integral_constant<span class="hljs-string">&lt;bool,value&gt;</span>    type;                                                \
};</span>


<span class="hljs-meta">#<span class="hljs-keyword">define</span> HAS_MEM_FUN_CALL(memfun)                                                                         \
                                                                                                     \
template <span class="hljs-string">&lt; typename Signature &gt;</span>                                                                       \
struct has_valid_mem_fun_call_##memfun;                                                               \
                                                                                                     \
template <span class="hljs-string">&lt; typename T, typename... Args &gt;</span>                                                             \
struct has_valid_mem_fun_call_##memfun<span class="hljs-string">&lt; T(Args...) &gt;</span>                                                  \
{                                                                                                     \
  struct yes {};                                                                                     \
  struct no  {};                                                                                     \
                                                                                                     \
  template <span class="hljs-string">&lt; typename U, bool = has_mem_##memfun&lt;U&gt;</span>::value &gt;                                         \
  struct impl                                                                                        \
  {                                                                                                  \
     template <span class="hljs-string">&lt; typename V, typename = decltype(std::declval&lt;V&gt;</span>().memfun(std::declval<span class="hljs-string">&lt;Args&gt;</span>()...)) &gt; \
     struct test_result { using type = yes; };                                                       \
                                                                                                     \
     template <span class="hljs-string">&lt; typename V &gt;</span> static constexpr typename test_result<span class="hljs-string">&lt;V&gt;</span>::type test(int);               \
     template <span class="hljs-string">&lt; typename   &gt;</span> static constexpr                            no test(...);               \
                                                                                                     \
     static constexpr bool value = std::is_same<span class="hljs-string">&lt;decltype(test&lt;U&gt;</span>(0)),yes&gt;::value;                    \
     using type = std::integral_constant<span class="hljs-string">&lt;bool, value&gt;</span>;                                               \
  };                                                                                                 \
                                                                                                     \
  template <span class="hljs-string">&lt; typename U &gt;</span>                                                                            \
  struct impl<span class="hljs-string">&lt;U,false&gt;</span> : std::false_type {};                                                         \
                                                                                                     \
  static constexpr bool value = impl<span class="hljs-string">&lt;T&gt;</span>::value;                                                      \
  using type = std::integral_constant<span class="hljs-string">&lt;bool, value&gt;</span>;                                                  \
};                                                                                                    \
                                                                                                     \
template <span class="hljs-string">&lt; typename Signature &gt;</span>                                                                       \
struct has_ambiguous_mem_fun_call_##memfun;                                                           \
                                                                                                     \
template <span class="hljs-string">&lt; typename T, typename... Args &gt;</span>                                                             \
struct has_ambiguous_mem_fun_call_##memfun<span class="hljs-string">&lt; T(Args...) &gt;</span>                                              \
{                                                                                                     \
  struct ambiguate_seed { void memfun(...); };                                                       \
                                                                                                     \
  template <span class="hljs-string">&lt; class U, bool = has_mem_##memfun&lt;U&gt;</span>::value &gt;                                            \
  struct ambiguate : U, ambiguate_seed                                                               \
  {                                                                                                  \
    using ambiguate_seed::memfun;                                                                    \
    using U::memfun;                                                                                 \
  };                                                                                                 \
                                                                                                     \
  template <span class="hljs-string">&lt; class U &gt;</span>                                                                               \
  struct ambiguate<span class="hljs-string">&lt;U,false&gt;</span> : ambiguate_seed {};                                                     \
                                                                                                     \
  static constexpr bool value = not has_valid_mem_fun_call_##memfun<span class="hljs-string">&lt; ambiguate&lt;T&gt;</span>(Args...) &gt;::value; \
  using type = std::integral_constant<span class="hljs-string">&lt;bool, value&gt;</span>;                                                  \
};                                                                                                    \
                                                                                                     \
template <span class="hljs-string">&lt; typename Signature &gt;</span>                                                                       \
struct has_viable_mem_fun_call_##memfun;                                                              \
                                                                                                     \
template <span class="hljs-string">&lt; typename T, typename... Args &gt;</span>                                                             \
struct has_viable_mem_fun_call_##memfun<span class="hljs-string">&lt; T(Args...) &gt;</span>                                                 \
{                                                                                                     \
  static constexpr bool value = has_valid_mem_fun_call_##memfun<span class="hljs-string">&lt;T(Args...)&gt;</span>::value                   \
                             or has_ambiguous_mem_fun_call_##memfun<span class="hljs-string">&lt;T(Args...)&gt;</span>::value;              \
  using type = std::integral_constant<span class="hljs-string">&lt;bool, value&gt;</span>;                                                  \
};                                                                                                    \
                                                                                                     \
template <span class="hljs-string">&lt; typename Signature &gt;</span>                                                                       \
struct has_no_viable_mem_fun_call_##memfun;                                                           \
                                                                                                     \
template <span class="hljs-string">&lt; typename T, typename... Args &gt;</span>                                                             \
struct has_no_viable_mem_fun_call_##memfun <span class="hljs-string">&lt; T(Args...) &gt;</span>                                             \
{                                                                                                     \
  static constexpr bool value = not has_viable_mem_fun_call_##memfun<span class="hljs-string">&lt;T(Args...)&gt;</span>::value;             \
  using type = std::integral_constant<span class="hljs-string">&lt;bool, value&gt;</span>;                                                  \
};                                                                                                    \
                                                                                                     \
template <span class="hljs-string">&lt; typename Signature &gt;</span>                                                                       \
struct result_of_mem_fun_call_##memfun;                                                               \
                                                                                                     \
template <span class="hljs-string">&lt; typename T, typename... Args &gt;</span>                                                             \
struct result_of_mem_fun_call_##memfun<span class="hljs-string">&lt; T(Args...) &gt;</span>                                                  \
{                                                                                                     \
  using type = decltype(std::declval<span class="hljs-string">&lt;T&gt;</span>().memfun(std::declval<span class="hljs-string">&lt;Args&gt;</span>()...));                          \
};</span>

<span class="hljs-meta">#<span class="hljs-keyword">endif</span></span>
</code></pre>

<hr>
    </div></div></div></div><div id="solution27" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 27</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/template-meta-programming">template-meta-programming</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/sfinae">sfinae</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>You can skip all the metaprogramming in C++14, and just write this using <a href="http://fit.readthedocs.io/en/latest/include/fit/conditional.html" rel="nofollow noreferrer"><code>fit::conditional</code></a> from the <a href="https://github.com/pfultz2/Fit" rel="nofollow noreferrer">Fit</a> library:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> T&gt;
std::string <span class="hljs-title">optionalToString</span><span class="hljs-params">(T* x)</span>
</span>{
    <span class="hljs-keyword">return</span> fit::<span class="hljs-built_in">conditional</span>(
        [](<span class="hljs-keyword">auto</span>* obj) -&gt; <span class="hljs-keyword">decltype</span>(obj-&gt;<span class="hljs-built_in">toString</span>()) { <span class="hljs-keyword">return</span> obj-&gt;<span class="hljs-built_in">toString</span>(); },
        [](<span class="hljs-keyword">auto</span>*) { <span class="hljs-keyword">return</span> <span class="hljs-string">"toString not defined"</span>; }
    )(x);
}
</code></pre>

<p>You can also create the function directly from the lambdas as well:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-built_in">FIT_STATIC_LAMBDA_FUNCTION</span>(optionalToString) = fit::<span class="hljs-built_in">conditional</span>(
    [](<span class="hljs-keyword">auto</span>* obj) -&gt; <span class="hljs-keyword">decltype</span>(obj-&gt;<span class="hljs-built_in">toString</span>(), std::<span class="hljs-built_in">string</span>()) { <span class="hljs-keyword">return</span> obj-&gt;<span class="hljs-built_in">toString</span>(); },
    [](<span class="hljs-keyword">auto</span>*) -&gt; std::string { <span class="hljs-keyword">return</span> <span class="hljs-string">"toString not defined"</span>; }
);
</code></pre>

<p>However, if you are using a compiler that doesn't support generic lambdas, you will have to write separate function objects:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">withToString</span>
{
    <span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> T&gt;
    <span class="hljs-keyword">auto</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(T* obj)</span> <span class="hljs-type">const</span> -&gt; <span class="hljs-title">decltype</span><span class="hljs-params">(obj-&gt;toString(), std::string())</span>
    </span>{
        <span class="hljs-keyword">return</span> obj-&gt;<span class="hljs-built_in">toString</span>();
    }
};

<span class="hljs-keyword">struct</span> <span class="hljs-title class_">withoutToString</span>
{
    <span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> T&gt;
    std::string <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(T*)</span> <span class="hljs-type">const</span>
    </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-string">"toString not defined"</span>;
    }
};

<span class="hljs-built_in">FIT_STATIC_FUNCTION</span>(optionalToString) = fit::<span class="hljs-built_in">conditional</span>(
    <span class="hljs-built_in">withToString</span>(),
    <span class="hljs-built_in">withoutToString</span>()
);
</code></pre>
    </div></div></div></div><div id="solution28" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 28</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/template-meta-programming">template-meta-programming</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/sfinae">sfinae</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Probably not as good as other examples, but this is what I came up with for C++11. This works for picking overloaded methods.</p>
<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span>... Args&gt;
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">Pack</span> {};

<span class="hljs-meta">#<span class="hljs-keyword">define</span> Proxy(T) ((T &amp;)(*(int *)(nullptr)))</span>

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Class, <span class="hljs-keyword">typename</span> ArgPack, <span class="hljs-keyword">typename</span> = <span class="hljs-type">nullptr_t</span>&gt;
<span class="hljs-keyword">struct</span> HasFoo
{
    <span class="hljs-keyword">enum</span> { value = <span class="hljs-literal">false</span> };
};

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Class, <span class="hljs-keyword">typename</span>... Args&gt;
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">HasFoo</span>&lt;
    Class,
    Pack&lt;Args...&gt;,
    <span class="hljs-keyword">decltype</span>((<span class="hljs-type">void</span>)(<span class="hljs-built_in">Proxy</span>(Class).<span class="hljs-built_in">foo</span>(<span class="hljs-built_in">Proxy</span>(Args)...)), <span class="hljs-literal">nullptr</span>)&gt;
{
    <span class="hljs-keyword">enum</span> { value = <span class="hljs-literal">true</span> };
};
</code></pre>
<p>Example usage</p>
<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Object</span>
{
    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">foo</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span>         </span>{ <span class="hljs-keyword">return</span> n; }
<span class="hljs-meta">#<span class="hljs-keyword">if</span> SOME_CONDITION</span>
    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">foo</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">char</span> c)</span> </span>{ <span class="hljs-keyword">return</span> n + c; }
<span class="hljs-meta">#<span class="hljs-keyword">endif</span></span>
};

<span class="hljs-keyword">template</span> &lt;<span class="hljs-type">bool</span> has_foo_int_char&gt;
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">Dispatcher</span>;

<span class="hljs-keyword">template</span> &lt;&gt;
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">Dispatcher</span>&lt;<span class="hljs-literal">false</span>&gt;
{
    <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Object&gt;
    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title">exec</span><span class="hljs-params">(Object &amp;object, <span class="hljs-type">int</span> n, <span class="hljs-type">char</span> c)</span>
    </span>{
        <span class="hljs-keyword">return</span> object.<span class="hljs-built_in">foo</span>(n) + c;
    }
};

<span class="hljs-keyword">template</span> &lt;&gt;
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">Dispatcher</span>&lt;<span class="hljs-literal">true</span>&gt;
{
    <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Object&gt;
    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title">exec</span><span class="hljs-params">(Object &amp;object, <span class="hljs-type">int</span> n, <span class="hljs-type">char</span> c)</span>
    </span>{
        <span class="hljs-keyword">return</span> object.<span class="hljs-built_in">foo</span>(n, c);
    }
};

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">runExample</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-keyword">using</span> Args = Pack&lt;<span class="hljs-type">int</span>, <span class="hljs-type">char</span>&gt;;
    <span class="hljs-keyword">enum</span> { has_overload = HasFoo&lt;Object, Args&gt;::value };
    Object object;
    <span class="hljs-keyword">return</span> Dispatcher&lt;has_overload&gt;::<span class="hljs-built_in">exec</span>(object, <span class="hljs-number">100</span>, <span class="hljs-string">'a'</span>);
}
</code></pre>
    </div></div></div></div><div id="solution29" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 29</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/template-meta-programming">template-meta-programming</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/sfinae">sfinae</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Here is an example of the working code.</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">using</span> toStringFn = <span class="hljs-keyword">decltype</span>(std::<span class="hljs-built_in">declval</span>&lt;<span class="hljs-type">const</span> T&gt;().<span class="hljs-built_in">toString</span>());

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>, toStringFn&lt;T&gt;* = <span class="hljs-literal">nullptr</span>&gt;
std::string <span class="hljs-built_in">optionalToString</span>(<span class="hljs-type">const</span> T* obj, <span class="hljs-type">int</span>)
{
    <span class="hljs-keyword">return</span> obj-&gt;<span class="hljs-built_in">toString</span>();
}

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;
<span class="hljs-function">std::string <span class="hljs-title">optionalToString</span><span class="hljs-params">(<span class="hljs-type">const</span> T* obj, <span class="hljs-type">long</span>)</span>
</span>{
    <span class="hljs-keyword">return</span> <span class="hljs-string">"toString not defined"</span>;
}

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    A* a;
    B* b;

    std::cout &lt;&lt; <span class="hljs-built_in">optionalToString</span>(a, <span class="hljs-number">0</span>) &lt;&lt; std::endl; <span class="hljs-comment">// This is A</span>
    std::cout &lt;&lt; <span class="hljs-built_in">optionalToString</span>(b, <span class="hljs-number">0</span>) &lt;&lt; std::endl; <span class="hljs-comment">// toString not defined</span>
}
</code></pre>

<p><code>toStringFn&lt;T&gt;* = nullptr</code> will enable the function which takes extra <code>int</code> argument which has a priority over function which takes <code>long</code> when called with <code>0</code>.</p>

<p>You can use the same principle for the functions which returns <code>true</code> if function is implemented.</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-type">bool</span> <span class="hljs-title">toStringExists</span><span class="hljs-params">(<span class="hljs-type">long</span>)</span>
</span>{
    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
}

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T, toStringFn&lt;T&gt;* = <span class="hljs-literal">nullptr</span>&gt;
<span class="hljs-keyword">constexpr</span> <span class="hljs-type">bool</span> <span class="hljs-built_in">toStringExists</span>(<span class="hljs-type">int</span>)
{
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
}


<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    A* a;
    B* b;

    std::cout &lt;&lt; <span class="hljs-built_in">toStringExists</span>&lt;A&gt;(<span class="hljs-number">0</span>) &lt;&lt; std::endl; <span class="hljs-comment">// true</span>
    std::cout &lt;&lt; <span class="hljs-built_in">toStringExists</span>&lt;B&gt;(<span class="hljs-number">0</span>) &lt;&lt; std::endl; <span class="hljs-comment">// false</span>
}
</code></pre>
    </div></div></div></div><div id="solution30" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 30</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/template-meta-programming">template-meta-programming</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/sfinae">sfinae</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>I had a similar problem:</p>

<p>A template class that may be derived from few base classes, some that have a certain member and others that do not.</p>

<p>I solved it similarly to the "typeof" (Nicola Bonelli's) answer, but with decltype so it compiles and runs correctly on MSVS:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span>

<span class="hljs-keyword">struct</span> <span class="hljs-title class_">Generic</span> {};    
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">HasMember</span> 
{
  <span class="hljs-built_in">HasMember</span>() : _a(<span class="hljs-number">1</span>) {};
  <span class="hljs-type">int</span> _a;
};    

<span class="hljs-comment">// SFINAE test</span>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">class</span> <span class="hljs-title class_">S</span> : <span class="hljs-keyword">public</span> T
{
<span class="hljs-keyword">public</span>:
  <span class="hljs-function">std::string <span class="hljs-title">foo</span> <span class="hljs-params">(std::string b)</span>
  </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">foo2</span>&lt;T&gt;(b,<span class="hljs-number">0</span>);
  }

<span class="hljs-keyword">protected</span>:
  <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-function">std::string <span class="hljs-title">foo2</span> <span class="hljs-params">(std::string b, <span class="hljs-keyword">decltype</span> (T::_a))</span>
  </span>{
    <span class="hljs-keyword">return</span> b + std::<span class="hljs-built_in">to_string</span>(T::_a);
  }
  <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-function">std::string <span class="hljs-title">foo2</span> <span class="hljs-params">(std::string b, ...)</span>
  </span>{
    <span class="hljs-keyword">return</span> b + <span class="hljs-string">"No"</span>;
  }
};

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span>
</span>{
  S&lt;HasMember&gt; d1;
  S&lt;Generic&gt; d2;

  std::cout &lt;&lt; d1.<span class="hljs-built_in">foo</span>(<span class="hljs-string">"HasMember: "</span>) &lt;&lt; std::endl;
  std::cout &lt;&lt; d2.<span class="hljs-built_in">foo</span>(<span class="hljs-string">"Generic: "</span>) &lt;&lt; std::endl;
  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>
    </div></div></div></div></div></div><div class="widget"><a href="/questions/php-mail-function-doesn&#x27;t-complete-sending-of-e-mail-1657384307499">PHP mail function doesn&#x27;t complete sending of e-mail</a><a href="/questions/using-fflush(stdin)-1657387602771">Using fflush(stdin)</a><a href="/questions/what&#x27;s-the-simplest-way-to-print-a-java-array-1657384702397">What&#x27;s the simplest way to print a Java array?</a><a href="/questions/importing-installed-package-from-script-raises-%22attributeerror:-module-has-no-attribute%22-or-%22importerror:-cannot-import-name%22-1657387790607">Importing installed package from script raises &quot;AttributeError: module has no attribute&quot; or &quot;ImportError: cannot import name&quot;</a><a href="/questions/is-javascript-a-pass-by-reference-or-pass-by-value-language-1657384675679">Is JavaScript a pass-by-reference or pass-by-value language?</a><a href="/questions/what-is-the-difference-between-char-s-and-char-*s-1657387823570">What is the difference between char s[] and char *s?</a><a href="/questions/what-are-the-basic-rules-and-idioms-for-operator-overloading-1657384449752">What are the basic rules and idioms for operator overloading?</a><a href="/questions/why-is-using-the-javascript-eval-function-a-bad-idea-1657387485165">Why is using the JavaScript eval function a bad idea?</a><a href="/questions/resolve-build-errors-due-to-circular-dependency-amongst-classes-1657384903462">Resolve build errors due to circular dependency amongst classes</a><a href="/questions/unfortunately-myapp-has-stopped.-how-can-i-solve-this-1657384402171">Unfortunately MyApp has stopped. How can I solve this?</a><a href="/questions/how-do-i-check-if-an-array-includes-a-value-in-javascript-1657387421185">How do I check if an array includes a value in JavaScript?</a><a href="/questions/how-to-sum-a-variable-by-group-1657384838148">How to sum a variable by group</a><a href="/questions/jquery-ajax-post-example-with-php-1657387402634">jQuery Ajax POST example with PHP</a><a href="/questions/servlet-returns-%22http-status-404-the-requested-resource-(servlet)-is-not-available%22-1657384850661">Servlet returns &quot;HTTP Status 404 The requested resource (/servlet) is not available&quot;</a><a href="/questions/where-do-i-find-the-current-c-or-c++-standard-documents-1657388006897">Where do I find the current C or C++ standard documents?</a><a href="/questions/the-definitive-c-book-guide-and-list-1657384747653">The Definitive C Book Guide and List</a><a href="/questions/with-arrays-why-is-it-the-case-that-a5-5a-1657387956216">With arrays, why is it the case that a[5] == 5[a]?</a><a href="/questions/why-not-use-tables-for-layout-in-html-closed-1657387752327">Why not use tables for layout in HTML? [closed]</a><a href="/questions/how-do-i-profile-c++-code-running-on-linux-1657384754272">How do I profile C++ code running on Linux?</a><a href="/questions/why-is-iostream::eof-inside-a-loop-condition-(i.e.-while-(!stream.eof()))-considered-wrong-1657384355427">Why is iostream::eof inside a loop condition (i.e. `while (!stream.eof())`) considered wrong?</a></div></div><span class="cursor-pointer text-lg p-2" style="position:fixed;bottom:20px;left:20px;background:#000;z-index:2000;color:white">Go go top</span></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"data":{"answer":["\n\u0026lt;p\u0026gt;Yes, with SFINAE you can check if a given class does provide a certain method. Here\u0026apos;s the working code:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;iostream\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Hello\u0026lt;/span\u0026gt;\n{\n    \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;helloworld\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt; \u0026lt;/span\u0026gt;{ \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;; }\n};\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Generic\u0026lt;/span\u0026gt; {};    \n\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// SFINAE test\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; T\u0026amp;gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;has_helloworld\u0026lt;/span\u0026gt;\n{\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typedef\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; one;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;two\u0026lt;/span\u0026gt; { \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; x[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;]; };\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; C\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;static\u0026lt;/span\u0026gt; one \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;test\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;( \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;decltype\u0026lt;/span\u0026gt;(\u0026amp;amp;C::helloworld) )\u0026lt;/span\u0026gt; \u0026lt;/span\u0026gt;;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; C\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;static\u0026lt;/span\u0026gt; two \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;test\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(...)\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;;    \n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt;:\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;enum\u0026lt;/span\u0026gt; { value = \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;sizeof\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;test\u0026lt;/span\u0026gt;\u0026amp;lt;T\u0026amp;gt;(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;)) == \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;sizeof\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt;) };\n};\n    \n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;main\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; argc, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; *argv[])\u0026lt;/span\u0026gt;\n\u0026lt;/span\u0026gt;{\n    std::cout \u0026amp;lt;\u0026amp;lt; has_helloworld\u0026amp;lt;Hello\u0026amp;gt;::value \u0026amp;lt;\u0026amp;lt; std::endl;\n    std::cout \u0026amp;lt;\u0026amp;lt; has_helloworld\u0026amp;lt;Generic\u0026amp;gt;::value \u0026amp;lt;\u0026amp;lt; std::endl;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;I\u0026apos;ve just tested it with Linux and gcc 4.1/4.3. I don\u0026apos;t know if it\u0026apos;s portable to other platforms running different compilers.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;This question is old, but with C++11 we got a new way to check for a functions existence (or existence of any non-type member, really), relying on SFINAE again:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; T\u0026amp;gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;auto\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;serialize_imp\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(std::ostream\u0026amp;amp; os, T \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt;\u0026amp;amp; obj, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;)\u0026lt;/span\u0026gt;\n    -\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;decltype\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(os \u0026amp;lt;\u0026amp;lt; obj, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt;())\u0026lt;/span\u0026gt;\n\u0026lt;/span\u0026gt;{\n  os \u0026amp;lt;\u0026amp;lt; obj;\n}\n\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; T\u0026amp;gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;auto\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;serialize_imp\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(std::ostream\u0026amp;amp; os, T \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt;\u0026amp;amp; obj, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;long\u0026lt;/span\u0026gt;)\u0026lt;/span\u0026gt;\n    -\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;decltype\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(obj.stream(os), \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt;())\u0026lt;/span\u0026gt;\n\u0026lt;/span\u0026gt;{\n  obj.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;stream\u0026lt;/span\u0026gt;(os);\n}\n\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; T\u0026amp;gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;auto\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;serialize\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(std::ostream\u0026amp;amp; os, T \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt;\u0026amp;amp; obj)\u0026lt;/span\u0026gt;\n    -\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;decltype\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(serialize_imp(os, obj, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;), \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt;())\u0026lt;/span\u0026gt;\n\u0026lt;/span\u0026gt;{\n  \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;serialize_imp\u0026lt;/span\u0026gt;(os, obj, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;);\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Now onto some explanations. First thing, I use \u0026lt;a href=\u0026quot;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2634.html\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;expression SFINAE\u0026lt;/a\u0026gt; to exclude the \u0026lt;code\u0026gt;serialize(_imp)\u0026lt;/code\u0026gt; functions from overload resolution, if the first expression inside \u0026lt;code\u0026gt;decltype\u0026lt;/code\u0026gt; isn\u0026apos;t valid (aka, the function doesn\u0026apos;t exist).\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;The \u0026lt;code\u0026gt;void()\u0026lt;/code\u0026gt; is used to make the return type of all those functions \u0026lt;code\u0026gt;void\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;The \u0026lt;code\u0026gt;0\u0026lt;/code\u0026gt; argument is used to prefer the \u0026lt;code\u0026gt;os \u0026amp;lt;\u0026amp;lt; obj\u0026lt;/code\u0026gt; overload if both are available (literal \u0026lt;code\u0026gt;0\u0026lt;/code\u0026gt; is of type \u0026lt;code\u0026gt;int\u0026lt;/code\u0026gt; and as such the first overload is a better match).\u0026lt;/p\u0026gt;\n\n\u0026lt;hr\u0026gt;\n\n\u0026lt;p\u0026gt;Now, you probably want a trait to check if a function exists. Luckily, it\u0026apos;s easy to write that. Note, though, that you need to write a trait \u0026lt;em\u0026gt;yourself\u0026lt;/em\u0026gt; for every different function name you might want.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;type_traits\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt;\u0026amp;gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;sfinae_true\u0026lt;/span\u0026gt; : std::true_type{};\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;namespace\u0026lt;/span\u0026gt; detail{\n  \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; T, \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; A0\u0026amp;gt;\n  \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;static\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;auto\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;test_stream\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;)\u0026lt;/span\u0026gt;\n      -\u0026amp;gt; sfinae_true\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;decltype\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(std::declval\u0026amp;lt;T\u0026amp;gt;().stream(std::declval\u0026amp;lt;A0\u0026amp;gt;()))\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026lt;/span\u0026gt;;\n  \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; A0\u0026amp;gt;\n  \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;static\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;auto\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;test_stream\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;long\u0026lt;/span\u0026gt;)\u0026lt;/span\u0026gt; -\u0026amp;gt; std::false_type\u0026lt;/span\u0026gt;;\n} \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// detail::\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;T\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Arg\u0026lt;/span\u0026gt;\u0026amp;gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;has_stream\u0026lt;/span\u0026gt; : \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;decltype\u0026lt;/span\u0026gt;(detail::\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;test_stream\u0026lt;/span\u0026gt;\u0026amp;lt;T, Arg\u0026amp;gt;(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;)){};\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;a href=\u0026quot;http://coliru.stacked-crooked.com/a/cd139d95d214c5c3\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;Live example.\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;And on to explanations. First, \u0026lt;code\u0026gt;sfinae_true\u0026lt;/code\u0026gt; is a helper type, and it basically amounts to the same as writing \u0026lt;code\u0026gt;decltype(void(std::declval\u0026amp;lt;T\u0026amp;gt;().stream(a0)), std::true_type{})\u0026lt;/code\u0026gt;. The advantage is simply that it\u0026apos;s shorter.\u0026lt;br\u0026gt;\nNext, the \u0026lt;code\u0026gt;struct has_stream : decltype(...)\u0026lt;/code\u0026gt; inherits from either \u0026lt;code\u0026gt;std::true_type\u0026lt;/code\u0026gt; or \u0026lt;code\u0026gt;std::false_type\u0026lt;/code\u0026gt; in the end, depending on whether the \u0026lt;code\u0026gt;decltype\u0026lt;/code\u0026gt; check in \u0026lt;code\u0026gt;test_stream\u0026lt;/code\u0026gt; fails or not.\u0026lt;br\u0026gt;\nLast, \u0026lt;code\u0026gt;std::declval\u0026lt;/code\u0026gt; gives you a \u0026quot;value\u0026quot; of whatever type you pass, without you needing to know how you can construct it. Note that this is only possible inside an unevaluated context, such as \u0026lt;code\u0026gt;decltype\u0026lt;/code\u0026gt;, \u0026lt;code\u0026gt;sizeof\u0026lt;/code\u0026gt; and others.\u0026lt;/p\u0026gt;\n\n\u0026lt;hr\u0026gt;\n\n\u0026lt;p\u0026gt;Note that \u0026lt;code\u0026gt;decltype\u0026lt;/code\u0026gt; is not necessarily needed, as \u0026lt;code\u0026gt;sizeof\u0026lt;/code\u0026gt; (and all unevaluated contexts) got that enhancement. It\u0026apos;s just that \u0026lt;code\u0026gt;decltype\u0026lt;/code\u0026gt; already delivers a type and as such is just cleaner. Here\u0026apos;s a \u0026lt;code\u0026gt;sizeof\u0026lt;/code\u0026gt; version of one of the overloads:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; T\u0026amp;gt;\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;serialize_imp\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(std::ostream\u0026amp;amp; os, T \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt;\u0026amp;amp; obj, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;,\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;(*)[\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;sizeof\u0026lt;/span\u0026gt;((os \u0026amp;lt;\u0026amp;lt; obj),\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;)] = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;)\u0026lt;/span\u0026gt;\n\u0026lt;/span\u0026gt;{\n  os \u0026amp;lt;\u0026amp;lt; obj;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;The \u0026lt;code\u0026gt;int\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;long\u0026lt;/code\u0026gt; parameters are still there for the same reason. The array pointer is used to provide a context where \u0026lt;code\u0026gt;sizeof\u0026lt;/code\u0026gt; can be used.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;C++ allows \u0026lt;a href=\u0026quot;http://en.wikipedia.org/wiki/SFINAE\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;SFINAE\u0026lt;/a\u0026gt; to be used for this (notice that with C++11 features this is simplier because it supports extended SFINAE on nearly arbitrary expressions - the below was crafted to work with common C++03 compilers):\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;define\u0026lt;/span\u0026gt; HAS_MEM_FUNC(func, name)                                        \\\n    template\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;typename T, typename Sign\u0026amp;gt;\u0026lt;/span\u0026gt;                                 \\\n    struct name {                                                       \\\n        typedef char yes[1];                                            \\\n        typedef char no [2];                                            \\\n        template \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;typename U, U\u0026amp;gt;\u0026lt;/span\u0026gt; struct type_check;                     \\\n        template \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;typename _1\u0026amp;gt;\u0026lt;/span\u0026gt; static yes \u0026amp;amp;chk(type_check\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;Sign, \u0026amp;amp;_1::func \u0026amp;gt;\u0026lt;/span\u0026gt; *); \\\n        template \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;typename   \u0026amp;gt;\u0026lt;/span\u0026gt; static no  \u0026amp;amp;chk(...);                    \\\n        static bool const value = sizeof(chk\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;T\u0026amp;gt;\u0026lt;/span\u0026gt;(0)) == sizeof(yes);     \\\n    }\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;The above template and macro tries to instantiate a template, giving it a member function pointer type, and the actual member function pointer. If the types do not fit, SFINAE causes the template to be ignored. Usage like this:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;HAS_MEM_FUNC\u0026lt;/span\u0026gt;(toString, has_to_string);\n\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; T\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;doSomething\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt; \u0026lt;/span\u0026gt;{\n   \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt;(has_to_string\u0026amp;lt;T, std::\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;string\u0026lt;/span\u0026gt;(T::*)()\u0026amp;gt;::value) {\n      ...\n   } \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;else\u0026lt;/span\u0026gt; {\n      ...\n   }\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;But note that you cannot just call that \u0026lt;code\u0026gt;toString\u0026lt;/code\u0026gt; function in that \u0026lt;code\u0026gt;if\u0026lt;/code\u0026gt; branch. Since the compiler will check for validity in both branches, that would fail for cases the function doesn\u0026apos;t exist. One way is to use SFINAE once again (\u0026lt;code\u0026gt;enable_if\u0026lt;/code\u0026gt; can be obtained from boost, too):\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;bool\u0026lt;/span\u0026gt; C, \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; T = \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt;\u0026amp;gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; enable_if {\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typedef\u0026lt;/span\u0026gt; T type;\n};\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; T\u0026amp;gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;enable_if\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;false\u0026lt;/span\u0026gt;, T\u0026amp;gt; { };\n\n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;HAS_MEM_FUNC\u0026lt;/span\u0026gt;(toString, has_to_string);\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; T\u0026amp;gt; \n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; enable_if\u0026amp;lt;has_to_string\u0026amp;lt;T, \n                   std::\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;string\u0026lt;/span\u0026gt;(T::*)()\u0026amp;gt;::value, std::string\u0026amp;gt;::\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;type\n\u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;doSomething\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(T * t)\u0026lt;/span\u0026gt; \u0026lt;/span\u0026gt;{\n   \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;/* something when T has toString ... */\u0026lt;/span\u0026gt;\n   \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; t-\u0026amp;gt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;toString\u0026lt;/span\u0026gt;();\n}\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; T\u0026amp;gt; \n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; enable_if\u0026amp;lt;!has_to_string\u0026amp;lt;T, \n                   std::\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;string\u0026lt;/span\u0026gt;(T::*)()\u0026amp;gt;::value, std::string\u0026amp;gt;::\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;type\n\u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;doSomething\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(T * t)\u0026lt;/span\u0026gt; \u0026lt;/span\u0026gt;{\n   \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;/* something when T doesnt have toString ... */\u0026lt;/span\u0026gt;\n   \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;T::toString() does not exist.\u0026quot;\u0026lt;/span\u0026gt;;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;Have fun using it. The advantage of it is that it also works for overloaded member functions, and also for \u0026lt;code\u0026gt;const\u0026lt;/code\u0026gt; member functions (remember using  \u0026lt;code\u0026gt;std::string(T::*)() const\u0026lt;/code\u0026gt; as the member function pointer type then!).\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;h2\u0026gt;C++20 - \u0026lt;code\u0026gt;requires\u0026lt;/code\u0026gt; expressions\u0026lt;/h2\u0026gt;\n\u0026lt;p\u0026gt;With C++20 come concepts and assorted tools such as \u0026lt;a href=\u0026quot;https://en.cppreference.com/w/cpp/language/constraints\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;\u0026lt;code\u0026gt;requires\u0026lt;/code\u0026gt; expressions\u0026lt;/a\u0026gt; which are a built-in way to check for a function existence. With them you could rewrite your \u0026lt;code\u0026gt;optionalToString\u0026lt;/code\u0026gt; function as follows:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; T\u0026amp;gt;\nstd::string \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;optionalToString\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(T* obj)\u0026lt;/span\u0026gt;\n\u0026lt;/span\u0026gt;{\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;constexpr\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;bool\u0026lt;/span\u0026gt; has_toString = \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;requires\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; T\u0026amp;amp; t) {\n        t.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;toString\u0026lt;/span\u0026gt;();\n    };\n\n    \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;constexpr\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(has_toString)\u0026lt;/span\u0026gt;\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; obj-\u0026amp;gt;\u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;toString\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;else\u0026lt;/span\u0026gt;\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;toString not defined\u0026quot;\u0026lt;/span\u0026gt;;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;h2\u0026gt;Pre-C++20 - Detection toolkit\u0026lt;/h2\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;a href=\u0026quot;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4502.pdf\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;N4502\u0026lt;/a\u0026gt; proposes a detection toolkit for inclusion into the C++17 standard library that eventually made it into the library fundamentals TS v2. It most likely won\u0026apos;t ever get into the standard because it has been subsumed by \u0026lt;code\u0026gt;requires\u0026lt;/code\u0026gt; expressions since, but it still solves the problem in a somewhat elegant manner. The toolkit introduces some metafunctions, including \u0026lt;a href=\u0026quot;http://en.cppreference.com/w/cpp/experimental/is_detected\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;\u0026lt;code\u0026gt;std::is_detected\u0026lt;/code\u0026gt;\u0026lt;/a\u0026gt; which can be used to easily write type or function detection metafunctions on the top of it. Here is how you could use it:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; T\u0026amp;gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;using\u0026lt;/span\u0026gt; toString_t = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;decltype\u0026lt;/span\u0026gt;( std::\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;declval\u0026lt;/span\u0026gt;\u0026amp;lt;T\u0026amp;amp;\u0026amp;gt;().\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;toString\u0026lt;/span\u0026gt;() );\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; T\u0026amp;gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;constexpr\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;bool\u0026lt;/span\u0026gt; has_toString = std::is_detected_v\u0026amp;lt;toString_t, T\u0026amp;gt;;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;Note that the example above is untested. The detection toolkit is not available in standard libraries yet but the proposal contains a full implementation that you can easily copy if you really need it. It plays nice with the C++17 feature \u0026lt;code\u0026gt;if constexpr\u0026lt;/code\u0026gt;:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; T\u0026amp;gt;\nstd::string \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;optionalToString\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(T* obj)\u0026lt;/span\u0026gt;\n\u0026lt;/span\u0026gt;{\n    \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;constexpr\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(has_toString\u0026amp;lt;T\u0026amp;gt;)\u0026lt;/span\u0026gt;\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; obj-\u0026amp;gt;\u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;toString\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;else\u0026lt;/span\u0026gt;\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;toString not defined\u0026quot;\u0026lt;/span\u0026gt;;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;h2\u0026gt;C++14 - Boost.Hana\u0026lt;/h2\u0026gt;\n\u0026lt;p\u0026gt;Boost.Hana apparently builds upon this specific example and provides a solution for C++14 in its documentation, so I\u0026apos;m going to quote it directly:\u0026lt;/p\u0026gt;\n\u0026lt;blockquote\u0026gt;\n\u0026lt;p\u0026gt;[...] Hana provides a \u0026lt;code\u0026gt;is_valid\u0026lt;/code\u0026gt; function that can be combined with C++14 generic lambdas to obtain a much cleaner implementation of the same thing:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;auto\u0026lt;/span\u0026gt; has_toString = hana::\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;is_valid\u0026lt;/span\u0026gt;([](\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;auto\u0026lt;/span\u0026gt;\u0026amp;amp;\u0026amp;amp; obj) -\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;decltype\u0026lt;/span\u0026gt;(obj.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;toString\u0026lt;/span\u0026gt;()) { });\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;This leaves us with a function object \u0026lt;code\u0026gt;has_toString\u0026lt;/code\u0026gt; which returns whether the given expression is valid on the argument we pass to it. The result is returned as an \u0026lt;code\u0026gt;IntegralConstant\u0026lt;/code\u0026gt;, so constexpr-ness is not an issue here because the result of the function is represented as a type anyway. Now, in addition to being less verbose (that\u0026apos;s a one liner!), the intent is much clearer. Other benefits are the fact that \u0026lt;code\u0026gt;has_toString\u0026lt;/code\u0026gt; can be passed to higher order algorithms and it can also be defined at function scope, so there is no need to pollute the namespace scope with implementation details.\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\u0026lt;h2\u0026gt;Boost.TTI\u0026lt;/h2\u0026gt;\n\u0026lt;p\u0026gt;Another somewhat idiomatic toolkit to perform such a check - even though less elegant - is \u0026lt;a href=\u0026quot;http://www.boost.org/doc/libs/1_55_0/libs/tti/doc/html/index.html\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;Boost.TTI\u0026lt;/a\u0026gt;, introduced in Boost 1.54.0. For your example, you would have to use the macro \u0026lt;code\u0026gt;BOOST_TTI_HAS_MEMBER_FUNCTION\u0026lt;/code\u0026gt;. Here is how you could use it:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;boost/tti/has_member_function.hpp\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Generate the metafunction\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;BOOST_TTI_HAS_MEMBER_FUNCTION\u0026lt;/span\u0026gt;(toString)\n\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Check whether T has a member function toString\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// which takes no parameter and returns a std::string\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;constexpr\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;bool\u0026lt;/span\u0026gt; foo = has_member_function_toString\u0026amp;lt;T, std::string\u0026amp;gt;::value;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;Then, you could use the \u0026lt;code\u0026gt;bool\u0026lt;/code\u0026gt; to create a SFINAE check.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;em\u0026gt;Explanation\u0026lt;/em\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;The macro \u0026lt;code\u0026gt;BOOST_TTI_HAS_MEMBER_FUNCTION\u0026lt;/code\u0026gt; generates the metafunction \u0026lt;code\u0026gt;has_member_function_toString\u0026lt;/code\u0026gt; which takes the checked type as its first template parameter. The second template parameter corresponds to the return type of the member function, and the following parameters correspond to the types of the function\u0026apos;s parameters. The member \u0026lt;code\u0026gt;value\u0026lt;/code\u0026gt; contains \u0026lt;code\u0026gt;true\u0026lt;/code\u0026gt; if the class \u0026lt;code\u0026gt;T\u0026lt;/code\u0026gt; has a member function \u0026lt;code\u0026gt;std::string toString()\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Alternatively, \u0026lt;code\u0026gt;has_member_function_toString\u0026lt;/code\u0026gt; can take a member function pointer as a template parameter. Therefore, it is possible to replace \u0026lt;code\u0026gt;has_member_function_toString\u0026amp;lt;T, std::string\u0026amp;gt;::value\u0026lt;/code\u0026gt; by \u0026lt;code\u0026gt;has_member_function_toString\u0026amp;lt;std::string T::* ()\u0026amp;gt;::value\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Though this question is two years old, I\u0026apos;ll dare to add my answer. Hopefully it will clarify the previous, indisputably excellent, solution. I took the very helpful answers of Nicola Bonelli and Johannes Schaub and merged them into a solution that is, IMHO, more readable, clear and does not require the \u0026lt;code\u0026gt;typeof\u0026lt;/code\u0026gt; extension:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Type\u0026lt;/span\u0026gt;\u0026amp;gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;TypeHasToString\u0026lt;/span\u0026gt;\n{\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// This type won\u0026apos;t compile if the second template parameter isn\u0026apos;t of type T,\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// so I can put a function pointer type in the first parameter and the function\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// itself in the second thus checking that the function has a specific signature.\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; T, T\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;TypeCheck\u0026lt;/span\u0026gt;;\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typedef\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; Yes;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typedef\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;long\u0026lt;/span\u0026gt; No;\n\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// A helper struct to hold the declaration of the function pointer.\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Change it if the function signature changes.\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; T\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;ToString\u0026lt;/span\u0026gt;\n    {\n        \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typedef\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(T::*fptr)\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;;\n    };\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; T\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;static\u0026lt;/span\u0026gt; Yes \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;HasToString\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(TypeCheck\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; ToString\u0026amp;lt;T\u0026amp;gt;::fptr, \u0026amp;amp;T::toString \u0026amp;gt;*)\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; T\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;static\u0026lt;/span\u0026gt; No  \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;HasToString\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(...)\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;;\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt;:\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;static\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;bool\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; value = (\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;sizeof\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;HasToString\u0026lt;/span\u0026gt;\u0026amp;lt;Type\u0026amp;gt;(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;)) == \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;sizeof\u0026lt;/span\u0026gt;(Yes));\n};\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;I checked it with gcc 4.1.2.\nThe credit goes mainly to Nicola Bonelli and Johannes Schaub, so give them a vote up if my answer helps you :)\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;A simple solution for C++11:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; T\u0026amp;gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;auto\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;optionalToString\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(T* obj)\u0026lt;/span\u0026gt;\n -\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;decltype\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(  obj-\u0026amp;gt;toString()  )\u0026lt;/span\u0026gt;\n\u0026lt;/span\u0026gt;{\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt;     obj-\u0026amp;gt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;toString\u0026lt;/span\u0026gt;();\n}\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;auto\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;optionalToString\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(...)\u0026lt;/span\u0026gt; -\u0026amp;gt; string\n\u0026lt;/span\u0026gt;{\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;toString not defined\u0026quot;\u0026lt;/span\u0026gt;;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Update, 3 years later: (and this is untested). To test for the existence, I think this will work:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; T\u0026amp;gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;constexpr\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;auto\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;test_has_toString_method\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(T* obj)\u0026lt;/span\u0026gt;\n -\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;decltype\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(  obj-\u0026amp;gt;toString() , std::true_type{} )\u0026lt;/span\u0026gt;\n\u0026lt;/span\u0026gt;{\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt;     obj-\u0026amp;gt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;toString\u0026lt;/span\u0026gt;();\n}\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;constexpr\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;auto\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;test_has_toString_method\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(...)\u0026lt;/span\u0026gt; -\u0026amp;gt; std::false_type\n\u0026lt;/span\u0026gt;{\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;toString not defined\u0026quot;\u0026lt;/span\u0026gt;;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Well, this question has a long list of answers already, but I would like to emphasize the comment from Morwenn: there is a proposal for C++17 that makes it really much simpler.  See \u0026lt;a href=\u0026quot;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4502.pdf\u0026quot; rel=\u0026quot;noreferrer\u0026quot; title=\u0026quot;Proposing Standard Library Support for the C++ Detection Idiom, v2\u0026quot;\u0026gt;N4502\u0026lt;/a\u0026gt; for details, but as a self-contained example consider the following.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;This part is the constant part, put it in a header.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// See http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4502.pdf.\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt;...\u0026amp;gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;using\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void_t\u0026lt;/span\u0026gt; = \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt;;\n\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Primary template handles all types not supporting the operation.\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt;\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; = \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void_t\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026amp;gt;\u0026amp;gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; detect : std::false_type {};\n\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Specialization recognizes/validates only types supporting the archetype.\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; T, \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt;\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Op\u0026lt;/span\u0026gt;\u0026amp;gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;detect\u0026lt;/span\u0026gt;\u0026amp;lt;T, Op, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void_t\u0026lt;/span\u0026gt;\u0026amp;lt;Op\u0026amp;lt;T\u0026amp;gt;\u0026amp;gt;\u0026amp;gt; : std::true_type {};\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;then there is the variable part, where you specify what you are looking for (a type, a member type, a function, a member function etc.).  In the case of the OP:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; T\u0026amp;gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;using\u0026lt;/span\u0026gt; toString_t = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;decltype\u0026lt;/span\u0026gt;(std::\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;declval\u0026lt;/span\u0026gt;\u0026amp;lt;T\u0026amp;gt;().\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;toString\u0026lt;/span\u0026gt;());\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; T\u0026amp;gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;using\u0026lt;/span\u0026gt; has_toString = detect\u0026amp;lt;T, toString_t\u0026amp;gt;;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;The following example, taken from \u0026lt;a href=\u0026quot;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4502.pdf\u0026quot; rel=\u0026quot;noreferrer\u0026quot; title=\u0026quot;Proposing Standard Library Support for the C++ Detection Idiom, v2\u0026quot;\u0026gt;N4502\u0026lt;/a\u0026gt;, shows a more elaborate probe:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Archetypal expression for assignment operation.\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; T\u0026amp;gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;using\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;assign_t\u0026lt;/span\u0026gt; = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;decltype\u0026lt;/span\u0026gt;(std::\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;declval\u0026lt;/span\u0026gt;\u0026amp;lt;T\u0026amp;amp;\u0026amp;gt;() = std::\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;declval\u0026lt;/span\u0026gt;\u0026amp;lt;T \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; \u0026amp;amp;\u0026amp;gt;())\n\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Trait corresponding to that archetype.\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; T\u0026amp;gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;using\u0026lt;/span\u0026gt; is_assignable = detect\u0026amp;lt;T, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;assign_t\u0026lt;/span\u0026gt;\u0026amp;gt;;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Compared to the other implementations described above, this one is fairly simple: a reduced set of tools (\u0026lt;code\u0026gt;void_t\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;detect\u0026lt;/code\u0026gt;) suffices, no need for hairy macros.  Besides, it was reported (see \u0026lt;a href=\u0026quot;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4502.pdf\u0026quot; rel=\u0026quot;noreferrer\u0026quot; title=\u0026quot;Proposing Standard Library Support for the C++ Detection Idiom, v2\u0026quot;\u0026gt;N4502\u0026lt;/a\u0026gt;) that it is measurably more efficient (compile-time and compiler memory consumption) than previous approaches.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Here is a \u0026lt;a href=\u0026quot;http://coliru.stacked-crooked.com/a/7eae9c76232a2d20\u0026quot; rel=\u0026quot;noreferrer\u0026quot; title=\u0026quot;Detection idiom\u0026quot;\u0026gt;live example\u0026lt;/a\u0026gt;.  It works fine with Clang, but unfortunately, GCC versions before 5.1 followed a different interpretation of the C++11 standard which caused \u0026lt;code\u0026gt;void_t\u0026lt;/code\u0026gt; to not work as expected.  Yakk already provided the work-around: use the following definition of \u0026lt;code\u0026gt;void_t\u0026lt;/code\u0026gt; (\u0026lt;a href=\u0026quot;https://stackoverflow.com/questions/28967003/void-t-in-parameter-list-works-but-not-as-return-type/28967049#28967049\u0026quot;\u0026gt;void_t in parameter list works but not as return type\u0026lt;/a\u0026gt;):\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; __GNUC__ \u0026amp;lt; 5 \u0026amp;amp;\u0026amp;amp; ! defined __clang__\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// https://stackoverflow.com/a/28967049/1353549\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt;...\u0026amp;gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;voider\u0026lt;/span\u0026gt;\n{\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;using\u0026lt;/span\u0026gt; type = \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt;;\n};\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt;...Ts\u0026amp;gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;using\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void_t\u0026lt;/span\u0026gt; = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; voider\u0026amp;lt;Ts...\u0026amp;gt;::type;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;else\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt;...\u0026amp;gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;using\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void_t\u0026lt;/span\u0026gt; = \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt;;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;endif\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;This is what type traits are there for. Unfortunately, they have to be defined manually. In your case, imagine the following:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; T\u0026amp;gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;response_trait\u0026lt;/span\u0026gt; {\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;static\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;bool\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; has_tostring = \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;false\u0026lt;/span\u0026gt;;\n};\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026amp;gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;response_trait\u0026lt;/span\u0026gt;\u0026amp;lt;your_type_with_tostring\u0026amp;gt; {\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;static\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;bool\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; has_tostring = \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;true\u0026lt;/span\u0026gt;;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;This is a C++11 solution for the general problem if \u0026quot;If I did X, would it compile?\u0026quot;\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt;\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;type_sink\u0026lt;/span\u0026gt; { \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typedef\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; type; }; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// consumes a type, and makes it `void`\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;T\u0026lt;/span\u0026gt;\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;using\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;type_sink_t\u0026lt;/span\u0026gt; = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; type_sink\u0026amp;lt;T\u0026amp;gt;::type;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;T\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt;=\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt;\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; has_to_string : std::false_type {}; \\\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;T\u0026lt;/span\u0026gt;\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;has_to_string\u0026lt;/span\u0026gt;\u0026amp;lt;\n  T,\n  \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;type_sink_t\u0026lt;/span\u0026gt;\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;decltype\u0026lt;/span\u0026gt;( std::\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;declval\u0026lt;/span\u0026gt;\u0026amp;lt;T\u0026amp;gt;().\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;toString\u0026lt;/span\u0026gt;() ) \u0026amp;gt;\n\u0026amp;gt;: std::true_type {};\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Trait \u0026lt;code\u0026gt;has_to_string\u0026lt;/code\u0026gt; such that \u0026lt;code\u0026gt;has_to_string\u0026amp;lt;T\u0026amp;gt;::value\u0026lt;/code\u0026gt; is \u0026lt;code\u0026gt;true\u0026lt;/code\u0026gt; if and only if \u0026lt;code\u0026gt;T\u0026lt;/code\u0026gt; has a method \u0026lt;code\u0026gt;.toString\u0026lt;/code\u0026gt; that can be invoked with 0 arguments in this context.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Next, I\u0026apos;d use tag dispatching:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;namespace\u0026lt;/span\u0026gt; details {\n  \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; T\u0026amp;gt;\n  std::string \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;optionalToString_helper\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(T* obj, std::true_type \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;/*has_to_string*/\u0026lt;/span\u0026gt;)\u0026lt;/span\u0026gt; \u0026lt;/span\u0026gt;{\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; obj-\u0026amp;gt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;toString\u0026lt;/span\u0026gt;();\n  }\n  \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; T\u0026amp;gt;\n  std::string \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;optionalToString_helper\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(T* obj, std::false_type \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;/*has_to_string*/\u0026lt;/span\u0026gt;)\u0026lt;/span\u0026gt; \u0026lt;/span\u0026gt;{\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;toString not defined\u0026quot;\u0026lt;/span\u0026gt;;\n  }\n}\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; T\u0026amp;gt;\nstd::string \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;optionalToString\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(T* obj)\u0026lt;/span\u0026gt; \u0026lt;/span\u0026gt;{\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; details::\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;optionalToString_helper\u0026lt;/span\u0026gt;( obj, has_to_string\u0026amp;lt;T\u0026amp;gt;{} );\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;which tends to be more maintainable than complex SFINAE expressions.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;You can write these traits with a macro if you find yourself doing it alot, but they are relatively simple (a few lines each) so maybe not worth it:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;define\u0026lt;/span\u0026gt; MAKE_CODE_TRAIT( TRAIT_NAME, ... ) \\\ntemplate\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;class T, class=void\u0026amp;gt;\u0026lt;/span\u0026gt; struct TRAIT_NAME : std::false_type {}; \\\ntemplate\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;class T\u0026amp;gt;\u0026lt;/span\u0026gt; struct TRAIT_NAME\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt; T, type_sink_t\u0026amp;lt; decltype( __VA_ARGS__ ) \u0026amp;gt;\u0026lt;/span\u0026gt; \u0026amp;gt;: std::true_type {};\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;what the above does is create a macro \u0026lt;code\u0026gt;MAKE_CODE_TRAIT\u0026lt;/code\u0026gt;.  You pass it the name of the trait you want, and some code that can test the type \u0026lt;code\u0026gt;T\u0026lt;/code\u0026gt;.  Thus:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;MAKE_CODE_TRAIT\u0026lt;/span\u0026gt;( has_to_string, std::\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;declval\u0026lt;/span\u0026gt;\u0026amp;lt;T\u0026amp;gt;().\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;toString\u0026lt;/span\u0026gt;() )\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;creates the above traits class.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;As an aside, the above technique is part of what MS calls \u0026quot;expression SFINAE\u0026quot;, and their 2013 compiler fails pretty hard.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Note that in C++1y the following syntax is possible:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; T\u0026amp;gt;\nstd::string \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;optionalToString\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(T* obj)\u0026lt;/span\u0026gt; \u0026lt;/span\u0026gt;{\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;compiled_if\u0026lt;/span\u0026gt;\u0026amp;lt; has_to_string \u0026amp;gt;(*obj, [\u0026amp;amp;](\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;auto\u0026lt;/span\u0026gt;\u0026amp;amp;\u0026amp;amp; obj) {\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; obj.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;toString\u0026lt;/span\u0026gt;();\n  }) *\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;compiled_else\u0026lt;/span\u0026gt; ([\u0026amp;amp;]{ \n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;toString not defined\u0026quot;\u0026lt;/span\u0026gt;;\n  });\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;which is an inline compilation conditional branch that abuses lots of C++ features.  Doing so is probably not worth it, as the benefit (of code being inline) is not worth the cost (of next to nobody understanding how it works), but the existence of that above solution may be of interest.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;With C++ 20 you can write the following:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; T\u0026amp;gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;concept\u0026lt;/span\u0026gt; has_toString = \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;requires\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; T\u0026amp;amp; t) {\n    t.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;toString\u0026lt;/span\u0026gt;();\n};\n\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; T\u0026amp;gt;\nstd::string \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;optionalToString\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; T\u0026amp;amp; obj)\u0026lt;/span\u0026gt;\n\u0026lt;/span\u0026gt;{\n    \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;constexpr\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(has_toString\u0026amp;lt;T\u0026amp;gt;)\u0026lt;/span\u0026gt;\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; obj.\u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;toString\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;else\u0026lt;/span\u0026gt;\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;toString not defined\u0026quot;\u0026lt;/span\u0026gt;;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Here are some usage snippets:\n*The guts for all this are farther down\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Check for member \u0026lt;code\u0026gt;x\u0026lt;/code\u0026gt; in a given class.  Could be var, func, class, union, or enum:\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;CREATE_MEMBER_CHECK\u0026lt;/span\u0026gt;(x);\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;bool\u0026lt;/span\u0026gt; has_x = has_member_x\u0026amp;lt;class_to_check_for_x\u0026amp;gt;::value;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Check for member function \u0026lt;code\u0026gt;void x()\u0026lt;/code\u0026gt;:\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//Func signature MUST have T as template variable here... simpler this way :\\\nCREATE_MEMBER_FUNC_SIG_CHECK(x, void (T::*)(), void__x);\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;bool\u0026lt;/span\u0026gt; has_func_sig_void__x = has_member_func_void__x\u0026amp;lt;class_to_check_for_x\u0026amp;gt;::value;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Check for member variable \u0026lt;code\u0026gt;x\u0026lt;/code\u0026gt;:\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;CREATE_MEMBER_VAR_CHECK\u0026lt;/span\u0026gt;(x);\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;bool\u0026lt;/span\u0026gt; has_var_x = has_member_var_x\u0026amp;lt;class_to_check_for_x\u0026amp;gt;::value;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Check for member class \u0026lt;code\u0026gt;x\u0026lt;/code\u0026gt;:\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;CREATE_MEMBER_CLASS_CHECK\u0026lt;/span\u0026gt;(x);\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;bool\u0026lt;/span\u0026gt; has_class_x = has_member_class_x\u0026amp;lt;class_to_check_for_x\u0026amp;gt;::value;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Check for member union \u0026lt;code\u0026gt;x\u0026lt;/code\u0026gt;:\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;CREATE_MEMBER_UNION_CHECK\u0026lt;/span\u0026gt;(x);\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;bool\u0026lt;/span\u0026gt; has_union_x = has_member_union_x\u0026amp;lt;class_to_check_for_x\u0026amp;gt;::value;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Check for member enum \u0026lt;code\u0026gt;x\u0026lt;/code\u0026gt;:\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;CREATE_MEMBER_ENUM_CHECK\u0026lt;/span\u0026gt;(x);\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;bool\u0026lt;/span\u0026gt; has_enum_x = has_member_enum_x\u0026amp;lt;class_to_check_for_x\u0026amp;gt;::value;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Check for any member function \u0026lt;code\u0026gt;x\u0026lt;/code\u0026gt; regardless of signature:\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;CREATE_MEMBER_CHECK\u0026lt;/span\u0026gt;(x);\n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;CREATE_MEMBER_VAR_CHECK\u0026lt;/span\u0026gt;(x);\n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;CREATE_MEMBER_CLASS_CHECK\u0026lt;/span\u0026gt;(x);\n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;CREATE_MEMBER_UNION_CHECK\u0026lt;/span\u0026gt;(x);\n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;CREATE_MEMBER_ENUM_CHECK\u0026lt;/span\u0026gt;(x);\n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;CREATE_MEMBER_FUNC_CHECK\u0026lt;/span\u0026gt;(x);\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;bool\u0026lt;/span\u0026gt; has_any_func_x = has_member_func_x\u0026amp;lt;class_to_check_for_x\u0026amp;gt;::value;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;OR\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;CREATE_MEMBER_CHECKS\u0026lt;/span\u0026gt;(x);  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//Just stamps out the same macro calls as above.\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;bool\u0026lt;/span\u0026gt; has_any_func_x = has_member_func_x\u0026amp;lt;class_to_check_for_x\u0026amp;gt;::value;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Details and core:\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;/*\n    - Multiple inheritance forces ambiguity of member names.\n    - SFINAE is used to make aliases to member names.\n    - Expression SFINAE is used in just one generic has_member that can accept\n      any alias we pass it.\n*/\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//Variadic to force ambiguity of class members.  C++11 and up.\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt;... Args\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;ambiguate\u0026lt;/span\u0026gt; : \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; Args... {};\n\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//Non-variadic version of the line above.\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//template \u0026amp;lt;typename A, typename B\u0026amp;gt; struct ambiguate : public A, public B {};\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; A, \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; = \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt;\u0026amp;gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; got_type : std::false_type {};\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; A\u0026amp;gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;got_type\u0026lt;/span\u0026gt;\u0026amp;lt;A\u0026amp;gt; : std::true_type {\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typedef\u0026lt;/span\u0026gt; A type;\n};\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; T, T\u0026amp;gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;sig_check\u0026lt;/span\u0026gt; : std::true_type {};\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; Alias, \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; AmbiguitySeed\u0026amp;gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;has_member\u0026lt;/span\u0026gt; {\n    \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; C\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;static\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;((\u0026amp;amp;f(\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;decltype\u0026lt;/span\u0026gt;(\u0026amp;amp;C::value))))\u0026lt;/span\u0026gt;[1]\u0026lt;/span\u0026gt;;\n    \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; C\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;static\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;((\u0026amp;amp;f(...)))\u0026lt;/span\u0026gt;[2]\u0026lt;/span\u0026gt;;\n\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//Make sure the member name is consistently spelled the same.\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;static_assert\u0026lt;/span\u0026gt;(\n        (\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;sizeof\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;f\u0026lt;/span\u0026gt;\u0026amp;lt;AmbiguitySeed\u0026amp;gt;(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;)) == \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;)\n        , \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Member name specified in AmbiguitySeed is different from member name specified in Alias, or wrong Alias/AmbiguitySeed has been specified.\u0026quot;\u0026lt;/span\u0026gt;\n    );\n\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;static\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;bool\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; value = \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;sizeof\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;f\u0026lt;/span\u0026gt;\u0026amp;lt;Alias\u0026amp;gt;(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;)) == \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;;\n};\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;em\u0026gt;\u0026lt;strong\u0026gt;Macros (El Diablo!):\u0026lt;/strong\u0026gt;\u0026lt;/em\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;CREATE_MEMBER_CHECK:\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//Check for any member with given name, whether var, func, class, union, enum.\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;define\u0026lt;/span\u0026gt; CREATE_MEMBER_CHECK(member)                                         \\\n                                                                            \\\ntemplate\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;typename T, typename = std::true_type\u0026amp;gt;\u0026lt;/span\u0026gt;                             \\\nstruct Alias_##member;                                                      \\\n                                                                            \\\ntemplate\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;typename T\u0026amp;gt;\u0026lt;/span\u0026gt;                                                        \\\nstruct Alias_##member \u0026amp;lt;                                                     \\\n    T, std::integral_constant\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;bool, got_type\u0026amp;lt;decltype(\u0026amp;amp;T::member)\u0026amp;gt;\u0026lt;/span\u0026gt;::value\u0026amp;gt;  \\\n\u0026amp;gt; { static const decltype(\u0026amp;amp;T::member) value; };                             \\\n                                                                            \\\nstruct AmbiguitySeed_##member { char member; };                             \\\n                                                                            \\\ntemplate\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;typename T\u0026amp;gt;\u0026lt;/span\u0026gt;                                                        \\\nstruct has_member_##member {                                                \\\n    static const bool value                                                 \\\n        = has_member\u0026amp;lt;                                                       \\\n            Alias_##member\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;ambiguate\u0026amp;lt;T, AmbiguitySeed_##member\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026amp;gt;            \\\n            , Alias_##member\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;AmbiguitySeed_##member\u0026amp;gt;\u0026lt;/span\u0026gt;                        \\\n        \u0026amp;gt;::value                                                            \\\n    ;                                                                       \\\n}\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;CREATE_MEMBER_VAR_CHECK:\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//Check for member variable with given name.\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;define\u0026lt;/span\u0026gt; CREATE_MEMBER_VAR_CHECK(var_name)                                   \\\n                                                                            \\\ntemplate\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;typename T, typename = std::true_type\u0026amp;gt;\u0026lt;/span\u0026gt;                             \\\nstruct has_member_var_##var_name : std::false_type {};                      \\\n                                                                            \\\ntemplate\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;typename T\u0026amp;gt;\u0026lt;/span\u0026gt;                                                        \\\nstruct has_member_var_##var_name\u0026amp;lt;                                           \\\n    T                                                                       \\\n    , std::integral_constant\u0026amp;lt;                                               \\\n        bool                                                                \\\n        , !std::is_member_function_pointer\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;decltype(\u0026amp;amp;T::var_name)\u0026amp;gt;\u0026lt;/span\u0026gt;::value   \\\n    \u0026amp;gt;                                                                       \\\n\u0026amp;gt; : std::true_type {}\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;CREATE_MEMBER_FUNC_SIG_CHECK:\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//Check for member function with given name AND signature.\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;define\u0026lt;/span\u0026gt; CREATE_MEMBER_FUNC_SIG_CHECK(func_name, func_sig, templ_postfix)    \\\n                                                                            \\\ntemplate\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;typename T, typename = std::true_type\u0026amp;gt;\u0026lt;/span\u0026gt;                             \\\nstruct has_member_func_##templ_postfix : std::false_type {};                \\\n                                                                            \\\ntemplate\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;typename T\u0026amp;gt;\u0026lt;/span\u0026gt;                                                        \\\nstruct has_member_func_##templ_postfix\u0026amp;lt;                                     \\\n    T, std::integral_constant\u0026amp;lt;                                              \\\n        bool                                                                \\\n        , sig_check\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;func_sig, \u0026amp;amp;T::func_name\u0026amp;gt;\u0026lt;/span\u0026gt;::value                         \\\n    \u0026amp;gt;                                                                       \\\n\u0026amp;gt; : std::true_type {}\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;CREATE_MEMBER_CLASS_CHECK:\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//Check for member class with given name.\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;define\u0026lt;/span\u0026gt; CREATE_MEMBER_CLASS_CHECK(class_name)               \\\n                                                            \\\ntemplate\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;typename T, typename = std::true_type\u0026amp;gt;\u0026lt;/span\u0026gt;             \\\nstruct has_member_class_##class_name : std::false_type {};  \\\n                                                            \\\ntemplate\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;typename T\u0026amp;gt;\u0026lt;/span\u0026gt;                                        \\\nstruct has_member_class_##class_name\u0026amp;lt;                       \\\n    T                                                       \\\n    , std::integral_constant\u0026amp;lt;                               \\\n        bool                                                \\\n        , std::is_class\u0026amp;lt;                                    \\\n            typename got_type\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;typename T::class_name\u0026amp;gt;\u0026lt;/span\u0026gt;::type \\\n        \u0026amp;gt;::value                                            \\\n    \u0026amp;gt;                                                       \\\n\u0026amp;gt; : std::true_type {}\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;CREATE_MEMBER_UNION_CHECK:\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//Check for member union with given name.\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;define\u0026lt;/span\u0026gt; CREATE_MEMBER_UNION_CHECK(union_name)               \\\n                                                            \\\ntemplate\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;typename T, typename = std::true_type\u0026amp;gt;\u0026lt;/span\u0026gt;             \\\nstruct has_member_union_##union_name : std::false_type {};  \\\n                                                            \\\ntemplate\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;typename T\u0026amp;gt;\u0026lt;/span\u0026gt;                                        \\\nstruct has_member_union_##union_name\u0026amp;lt;                       \\\n    T                                                       \\\n    , std::integral_constant\u0026amp;lt;                               \\\n        bool                                                \\\n        , std::is_union\u0026amp;lt;                                    \\\n            typename got_type\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;typename T::union_name\u0026amp;gt;\u0026lt;/span\u0026gt;::type \\\n        \u0026amp;gt;::value                                            \\\n    \u0026amp;gt;                                                       \\\n\u0026amp;gt; : std::true_type {}\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;CREATE_MEMBER_ENUM_CHECK:\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//Check for member enum with given name.\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;define\u0026lt;/span\u0026gt; CREATE_MEMBER_ENUM_CHECK(enum_name)                 \\\n                                                            \\\ntemplate\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;typename T, typename = std::true_type\u0026amp;gt;\u0026lt;/span\u0026gt;             \\\nstruct has_member_enum_##enum_name : std::false_type {};    \\\n                                                            \\\ntemplate\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;typename T\u0026amp;gt;\u0026lt;/span\u0026gt;                                        \\\nstruct has_member_enum_##enum_name\u0026amp;lt;                         \\\n    T                                                       \\\n    , std::integral_constant\u0026amp;lt;                               \\\n        bool                                                \\\n        , std::is_enum\u0026amp;lt;                                     \\\n            typename got_type\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;typename T::enum_name\u0026amp;gt;\u0026lt;/span\u0026gt;::type  \\\n        \u0026amp;gt;::value                                            \\\n    \u0026amp;gt;                                                       \\\n\u0026amp;gt; : std::true_type {}\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;CREATE_MEMBER_FUNC_CHECK:\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//Check for function with given name, any signature.\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;define\u0026lt;/span\u0026gt; CREATE_MEMBER_FUNC_CHECK(func)          \\\ntemplate\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;typename T\u0026amp;gt;\u0026lt;/span\u0026gt;                            \\\nstruct has_member_func_##func {                 \\\n    static const bool value                     \\\n        = has_member_##func\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;T\u0026amp;gt;\u0026lt;/span\u0026gt;::value           \\\n        \u0026amp;amp;\u0026amp;amp; !has_member_var_##func\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;T\u0026amp;gt;\u0026lt;/span\u0026gt;::value     \\\n        \u0026amp;amp;\u0026amp;amp; !has_member_class_##func\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;T\u0026amp;gt;\u0026lt;/span\u0026gt;::value   \\\n        \u0026amp;amp;\u0026amp;amp; !has_member_union_##func\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;T\u0026amp;gt;\u0026lt;/span\u0026gt;::value   \\\n        \u0026amp;amp;\u0026amp;amp; !has_member_enum_##func\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;T\u0026amp;gt;\u0026lt;/span\u0026gt;::value    \\\n    ;                                           \\\n}\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;CREATE_MEMBER_CHECKS:\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//Create all the checks for one member.  Does NOT include func sig checks.\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;define\u0026lt;/span\u0026gt; CREATE_MEMBER_CHECKS(member)    \\\nCREATE_MEMBER_CHECK(member);            \\\nCREATE_MEMBER_VAR_CHECK(member);        \\\nCREATE_MEMBER_CLASS_CHECK(member);      \\\nCREATE_MEMBER_UNION_CHECK(member);      \\\nCREATE_MEMBER_ENUM_CHECK(member);       \\\nCREATE_MEMBER_FUNC_CHECK(member)\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Yet another way to do it in C++17 (inspired by \u0026lt;code\u0026gt;boost:hana\u0026lt;/code\u0026gt;).\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;This solution does not require \u0026lt;code\u0026gt;has_something\u0026amp;lt;T\u0026amp;gt;\u0026lt;/code\u0026gt; SFINAE type traits classes.\u0026lt;/p\u0026gt;\n\u0026lt;h3\u0026gt;Solution\u0026lt;/h3\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;////////////////////////////////////////////\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// has_member implementation\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;////////////////////////////////////////////\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;type_traits\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; T, \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; F\u0026amp;gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;constexpr\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;auto\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;has_member_impl\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(F\u0026amp;amp;\u0026amp;amp; f)\u0026lt;/span\u0026gt; -\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;decltype\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(f(std::declval\u0026amp;lt;T\u0026amp;gt;()), \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;true\u0026lt;/span\u0026gt;)\u0026lt;/span\u0026gt;\n\u0026lt;/span\u0026gt;{\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;true\u0026lt;/span\u0026gt;;\n}\n\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt;\u0026amp;gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;constexpr\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;bool\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;has_member_impl\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(...)\u0026lt;/span\u0026gt; \u0026lt;/span\u0026gt;{ \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;false\u0026lt;/span\u0026gt;; }\n\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;define\u0026lt;/span\u0026gt; has_member(T, EXPR) \\\n has_member_impl\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;T\u0026amp;gt;\u0026lt;/span\u0026gt;( [](auto\u0026amp;amp;\u0026amp;amp; obj)-\u0026amp;gt;decltype(obj.EXPR){} )\u0026lt;/span\u0026gt;\n\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;h3\u0026gt;Test\u0026lt;/h3\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;////////////////////////////////////////////\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Test\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;////////////////////////////////////////////\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;iostream\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;string\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Example\u0026lt;/span\u0026gt; {\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; Foo;\n    \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;Bar\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt; \u0026lt;/span\u0026gt;{}\n    \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;std::string \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;toString\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt; \u0026lt;/span\u0026gt;{ \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Hello from Example::toString()!\u0026quot;\u0026lt;/span\u0026gt;; }\n};\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Example2\u0026lt;/span\u0026gt; {\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; X;\n};\n\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; T\u0026amp;gt;\nstd::string \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;optionalToString\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(T* obj)\u0026lt;/span\u0026gt;\n\u0026lt;/span\u0026gt;{\n    \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;constexpr\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(has_member(T, toString()))\u0026lt;/span\u0026gt;\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; obj-\u0026amp;gt;\u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;toString\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;else\u0026lt;/span\u0026gt;\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;toString not defined\u0026quot;\u0026lt;/span\u0026gt;;\n}\n\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;main\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt; \u0026lt;/span\u0026gt;{\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;static_assert\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;has_member\u0026lt;/span\u0026gt;(Example, Foo), \n                  \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Example class must have Foo member\u0026quot;\u0026lt;/span\u0026gt;);\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;static_assert\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;has_member\u0026lt;/span\u0026gt;(Example, \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;Bar\u0026lt;/span\u0026gt;()), \n                  \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Example class must have Bar() member function\u0026quot;\u0026lt;/span\u0026gt;);\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;static_assert\u0026lt;/span\u0026gt;(!\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;has_member\u0026lt;/span\u0026gt;(Example, ZFoo), \n                  \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Example class must not have ZFoo member.\u0026quot;\u0026lt;/span\u0026gt;);\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;static_assert\u0026lt;/span\u0026gt;(!\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;has_member\u0026lt;/span\u0026gt;(Example, \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;ZBar\u0026lt;/span\u0026gt;()), \n                  \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Example class must not have ZBar() member function\u0026quot;\u0026lt;/span\u0026gt;);\n\n    Example e1;\n    Example2 e2;\n\n    std::cout \u0026amp;lt;\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;e1: \u0026quot;\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;optionalToString\u0026lt;/span\u0026gt;(\u0026amp;amp;e1) \u0026amp;lt;\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;\\n\u0026quot;\u0026lt;/span\u0026gt;;\n    std::cout \u0026amp;lt;\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;e1: \u0026quot;\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;optionalToString\u0026lt;/span\u0026gt;(\u0026amp;amp;e2) \u0026amp;lt;\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;\\n\u0026quot;\u0026lt;/span\u0026gt;;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;I wrote an answer to this in another thread that (unlike the solutions above) also checks inherited member functions:\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;a href=\u0026quot;https://stackoverflow.com/questions/1966362/sfinae-to-check-for-inherited-member-functions/8752988#8752988\u0026quot;\u0026gt;SFINAE to check for inherited member functions\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Here are some example from that solution:\u0026lt;/p\u0026gt;\n\n\u0026lt;h2\u0026gt;Example1:\u0026lt;/h2\u0026gt;\n\n\u0026lt;p\u0026gt;We are checking for a member with the following signature: \n\u0026lt;code\u0026gt;T::const_iterator begin() const\u0026lt;/code\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;T\u0026lt;/span\u0026gt;\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;has_const_begin\u0026lt;/span\u0026gt;\n{\n    \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typedef\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026amp;amp;Yes)\u0026lt;/span\u0026gt;[1]\u0026lt;/span\u0026gt;;\n    \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typedef\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026amp;amp;No)\u0026lt;/span\u0026gt;[2]\u0026lt;/span\u0026gt;;\n\n    \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; U\u0026amp;gt; \n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;static\u0026lt;/span\u0026gt; Yes \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;test\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(U \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; * data, \n                    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; std::enable_if\u0026amp;lt;std::is_same\u0026amp;lt;\n                             \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; U::const_iterator, \n                             \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;decltype\u0026lt;/span\u0026gt;(data-\u0026amp;gt;begin())\n                    \u0026amp;gt;::value\u0026amp;gt;::type * = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;)\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;;\n    \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;static\u0026lt;/span\u0026gt; No \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;test\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(...)\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;;\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;static\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;bool\u0026lt;/span\u0026gt; value = \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;sizeof\u0026lt;/span\u0026gt;(Yes) == \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;sizeof\u0026lt;/span\u0026gt;(has_const_begin::\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;test\u0026lt;/span\u0026gt;((\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; std::remove_reference\u0026amp;lt;T\u0026amp;gt;::type*)\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;));\n};\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Please notice that it even checks the constness of the method, and works with primitive types, as well. (I mean \u0026lt;code\u0026gt;has_const_begin\u0026amp;lt;int\u0026amp;gt;::value\u0026lt;/code\u0026gt; is false and doesn\u0026apos;t cause a compile-time error.) \u0026lt;/p\u0026gt;\n\n\u0026lt;h2\u0026gt;Example 2\u0026lt;/h2\u0026gt;\n\n\u0026lt;p\u0026gt;Now we are looking for the signature: \u0026lt;code\u0026gt;void foo(MyClass\u0026amp;amp;, unsigned)\u0026lt;/code\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;T\u0026lt;/span\u0026gt;\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;has_foo\u0026lt;/span\u0026gt;\n{\n    \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typedef\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026amp;amp;Yes)\u0026lt;/span\u0026gt;[1]\u0026lt;/span\u0026gt;;\n    \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typedef\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026amp;amp;No)\u0026lt;/span\u0026gt;[2]\u0026lt;/span\u0026gt;;\n\n    \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; U\u0026amp;gt;\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;static\u0026lt;/span\u0026gt; Yes \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;test\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(U * data, MyClass* arg1 = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;,\n                    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; std::enable_if\u0026amp;lt;std::is_void\u0026amp;lt;\n                             \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;decltype\u0026lt;/span\u0026gt;(data-\u0026amp;gt;foo(*arg1, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1u\u0026lt;/span\u0026gt;))\n                    \u0026amp;gt;::value\u0026amp;gt;::type * = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;)\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;;\n    \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;static\u0026lt;/span\u0026gt; No \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;test\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(...)\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;;\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;static\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;bool\u0026lt;/span\u0026gt; value = \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;sizeof\u0026lt;/span\u0026gt;(Yes) == \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;sizeof\u0026lt;/span\u0026gt;(has_foo::\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;test\u0026lt;/span\u0026gt;((\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; std::remove_reference\u0026amp;lt;T\u0026amp;gt;::type*)\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;));\n};\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Please notice that MyClass doesn\u0026apos;t has to be default constructible or to satisfy any special concept. The technique works with template members, as well.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;I am eagerly waiting opinions regarding this.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Here is the most concise way I found in C++20, which is very close from your question:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; T\u0026amp;gt;\nstd::string \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;optionalToString\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(T* obj)\u0026lt;/span\u0026gt;\n\u0026lt;/span\u0026gt;{\n  \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;constexpr\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;requires\u0026lt;/span\u0026gt; { obj-\u0026amp;gt;toString(); })\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; obj-\u0026amp;gt;\u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;toString\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;;\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;else\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;toString not defined\u0026quot;\u0026lt;/span\u0026gt;;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;See it live on godbolt: \u0026lt;a href=\u0026quot;https://gcc.godbolt.org/z/5jb1d93Ms\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;https://gcc.godbolt.org/z/5jb1d93Ms\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;The standard C++ solution presented here by litb will not work as expected if the method happens to be defined in a base class. \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;For a solution that handles this situation refer to :\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;In Russian :\n\u0026lt;a href=\u0026quot;http://www.rsdn.ru/forum/message/2759773.1.aspx\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;http://www.rsdn.ru/forum/message/2759773.1.aspx\u0026lt;/a\u0026gt; \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;English Translation by Roman.Perepelitsa : \n\u0026lt;a href=\u0026quot;http://groups.google.com/group/comp.lang.c++.moderated/tree/browse_frm/thread/4f7c7a96f9afbe44/c95a7b4c645e449f?pli=1\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;http://groups.google.com/group/comp.lang.c++.moderated/tree/browse_frm/thread/4f7c7a96f9afbe44/c95a7b4c645e449f?pli=1\u0026lt;/a\u0026gt; \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;It is insanely clever. However one issue with this solutiion is that gives compiler errors if the type being tested is one that cannot be used as a base class (e.g. primitive types)\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;In Visual Studio, I noticed that if working with method having no arguments, an extra pair of redundant ( )  needs to be inserted around the argments to deduce( )  in the sizeof expression.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Now this was a \u0026lt;em\u0026gt;nice\u0026lt;/em\u0026gt; little puzzle - great question!\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Here\u0026apos;s an alternative to \u0026lt;a href=\u0026quot;https://stackoverflow.com/questions/257288/possible-for-c-template-to-check-for-a-functions-existence#257382\u0026quot;\u0026gt;Nicola Bonelli\u0026apos;s solution\u0026lt;/a\u0026gt; that does not rely on the non-standard \u0026lt;code\u0026gt;typeof\u0026lt;/code\u0026gt; operator.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Unfortunately, it does not work on GCC (MinGW) 3.4.5 or Digital Mars 8.42n, but it does work on all versions of MSVC (including VC6) and on Comeau C++.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;The longer comment block has the details on how it works (or is supposed to work).  As it says, I\u0026apos;m not sure which behavior is standards compliant - I\u0026apos;d welcome commentary on that.\u0026lt;/p\u0026gt;\n\n\u0026lt;hr\u0026gt;\n\n\u0026lt;p\u0026gt;update - 7 Nov 2008:\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;It looks like while this code is syntactically correct, the behavior that MSVC and Comeau C++ show does not follow the standard (thanks to \u0026lt;a href=\u0026quot;https://stackoverflow.com/users/4727/leon-timmermans\u0026quot;\u0026gt;Leon Timmermans\u0026lt;/a\u0026gt; and \u0026lt;a href=\u0026quot;https://stackoverflow.com/users/34509/litb\u0026quot;\u0026gt;litb\u0026lt;/a\u0026gt; for pointing me in the right direction).  The C++03 standard says the following:\u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;14.6.2 Dependent names [temp.dep]\u0026lt;/p\u0026gt;\n  \n  \u0026lt;p\u0026gt;Paragraph 3\u0026lt;/p\u0026gt;\n  \n  \u0026lt;p\u0026gt;In the definition of a class template\n  or a member of a class template, if a\n  base class of the class template\n  depends on a template-parameter, the\n  base class scope is not examined\n  during unqualified name lookup either\n  at the point of definition of the\n  class template or member or during an\n  instantiation of the class template or\n  member.\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;p\u0026gt;So, it looks like that when MSVC or Comeau consider the \u0026lt;code\u0026gt;toString()\u0026lt;/code\u0026gt; member function of \u0026lt;code\u0026gt;T\u0026lt;/code\u0026gt; performing name lookup at the call site in \u0026lt;code\u0026gt;doToString()\u0026lt;/code\u0026gt; when the template is instantiated, that is incorrect (even though it\u0026apos;s actually the behavior I was looking for in this case).\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;The behavior of GCC and Digital Mars looks to be correct - in both cases the non-member \u0026lt;code\u0026gt;toString()\u0026lt;/code\u0026gt; function is bound to the call.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Rats - I thought I might have found a clever solution, instead I uncovered a couple compiler bugs...\u0026lt;/p\u0026gt;\n\n\u0026lt;hr\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;iostream\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;string\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Hello\u0026lt;/span\u0026gt;\n{\n    \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;std::string \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;toString\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt; \u0026lt;/span\u0026gt;{\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Hello\u0026quot;\u0026lt;/span\u0026gt;;\n    }\n};\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Generic\u0026lt;/span\u0026gt; {};\n\n\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// the following namespace keeps the toString() method out of\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//  most everything - except the other stuff in this\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//  compilation unit\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;namespace\u0026lt;/span\u0026gt; {\n    \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;std::string \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;toString\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt;\n    \u0026lt;/span\u0026gt;{\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;toString not defined\u0026quot;\u0026lt;/span\u0026gt;;\n    }\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; T\u0026amp;gt;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;optionalToStringImpl\u0026lt;/span\u0026gt; : \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; T\n    {\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt;:\n        \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;std::string \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;doToString\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt; \u0026lt;/span\u0026gt;{\n\n            \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// in theory, the name lookup for this call to \u0026lt;/span\u0026gt;\n            \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//  toString() should find the toString() in \u0026lt;/span\u0026gt;\n            \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//  the base class T if one exists, but if one \u0026lt;/span\u0026gt;\n            \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//  doesn\u0026apos;t exist in the base class, it\u0026apos;ll \u0026lt;/span\u0026gt;\n            \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//  find the free toString() function in \u0026lt;/span\u0026gt;\n            \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//  the private namespace.\u0026lt;/span\u0026gt;\n            \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//\u0026lt;/span\u0026gt;\n            \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// This theory works for MSVC (all versions\u0026lt;/span\u0026gt;\n            \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//  from VC6 to VC9) and Comeau C++, but\u0026lt;/span\u0026gt;\n            \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//  does not work with MinGW 3.4.5 or \u0026lt;/span\u0026gt;\n            \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//  Digital Mars 8.42n\u0026lt;/span\u0026gt;\n            \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//\u0026lt;/span\u0026gt;\n            \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// I\u0026apos;m honestly not sure what the standard says \u0026lt;/span\u0026gt;\n            \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//  is the correct behavior here - it\u0026apos;s sort \u0026lt;/span\u0026gt;\n            \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//  of like ADL (Argument Dependent Lookup - \u0026lt;/span\u0026gt;\n            \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//  also known as Koenig Lookup) but without\u0026lt;/span\u0026gt;\n            \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//  arguments (except the implied \u0026quot;this\u0026quot; pointer)\u0026lt;/span\u0026gt;\n\n            \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;toString\u0026lt;/span\u0026gt;();\n        }\n    };\n}\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; T\u0026amp;gt;\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;std::string \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;optionalToString\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(T \u0026amp;amp; obj)\u0026lt;/span\u0026gt;\n\u0026lt;/span\u0026gt;{\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// ugly, hacky cast...\u0026lt;/span\u0026gt;\n    optionalToStringImpl\u0026amp;lt;T\u0026amp;gt;* temp = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;reinterpret_cast\u0026lt;/span\u0026gt;\u0026amp;lt;optionalToStringImpl\u0026amp;lt;T\u0026amp;gt;*\u0026amp;gt;( \u0026amp;amp;obj);\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; temp-\u0026amp;gt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;doToString\u0026lt;/span\u0026gt;();\n}\n\n\n\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;main\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; argc, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; *argv[])\u0026lt;/span\u0026gt;\n\u0026lt;/span\u0026gt;{\n    Hello helloObj;\n    Generic genericObj;\n\n    std::cout \u0026amp;lt;\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;optionalToString\u0026lt;/span\u0026gt;( helloObj) \u0026amp;lt;\u0026amp;lt; std::endl;\n    std::cout \u0026amp;lt;\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;optionalToString\u0026lt;/span\u0026gt;( genericObj) \u0026amp;lt;\u0026amp;lt; std::endl;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;An example using SFINAE and template partial specialization, by writing a \u0026lt;code\u0026gt;Has_foo\u0026lt;/code\u0026gt; concept check: \u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;type_traits\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;A\u0026lt;/span\u0026gt;{};\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;B\u0026lt;/span\u0026gt;{ \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;foo\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; a, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; b)\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;;};\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;C\u0026lt;/span\u0026gt;{\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;foo\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; a, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; b)\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;;};\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;D\u0026lt;/span\u0026gt;{\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;foo\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;;};\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;E\u0026lt;/span\u0026gt;: \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; B{};\n\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// available in C++17 onwards as part of \u0026amp;lt;type_traits\u0026amp;gt;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt;...\u0026amp;gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;using\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void_t\u0026lt;/span\u0026gt; = \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt;;\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; T, \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; = \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt;\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; Has_foo: std::false_type{};\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; T\u0026amp;gt; \n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Has_foo\u0026lt;/span\u0026gt;\u0026amp;lt;T, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void_t\u0026lt;/span\u0026gt;\u0026amp;lt;\n    std::\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;enable_if_t\u0026lt;/span\u0026gt;\u0026amp;lt;\n        std::is_same\u0026amp;lt;\n            \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;, \n            \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;decltype\u0026lt;/span\u0026gt;(std::\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;declval\u0026lt;/span\u0026gt;\u0026amp;lt;T\u0026amp;gt;().\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;foo\u0026lt;/span\u0026gt;((\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;)\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;, (\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;)\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;))\n        \u0026amp;gt;::value\n    \u0026amp;gt;\n\u0026amp;gt;\u0026amp;gt;: std::true_type{};\n\n\n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;static_assert\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;not\u0026lt;/span\u0026gt; Has_foo\u0026amp;lt;A\u0026amp;gt;::value, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;A does not have a foo\u0026quot;\u0026lt;/span\u0026gt;);\n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;static_assert\u0026lt;/span\u0026gt;(Has_foo\u0026amp;lt;B\u0026amp;gt;::value, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;B has a foo\u0026quot;\u0026lt;/span\u0026gt;);\n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;static_assert\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;not\u0026lt;/span\u0026gt; Has_foo\u0026amp;lt;C\u0026amp;gt;::value, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;C has a foo with the wrong return. \u0026quot;\u0026lt;/span\u0026gt;);\n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;static_assert\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;not\u0026lt;/span\u0026gt; Has_foo\u0026amp;lt;D\u0026amp;gt;::value, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;D has a foo with the wrong arguments. \u0026quot;\u0026lt;/span\u0026gt;);\n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;static_assert\u0026lt;/span\u0026gt;(Has_foo\u0026amp;lt;E\u0026amp;gt;::value, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;E has a foo since it inherits from B\u0026quot;\u0026lt;/span\u0026gt;);\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;MSVC has the __if_exists and __if_not_exists keywords (\u0026lt;a href=\u0026quot;http://msdn.microsoft.com/en-us/library/x7wy9xh3(VS.80).aspx\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;Doc\u0026lt;/a\u0026gt;). Together with the typeof-SFINAE approach of Nicola I could create a check for GCC and MSVC like the OP looked for.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Update:\u0026lt;/strong\u0026gt; Source can be found \u0026lt;a href=\u0026quot;https://github.com/nob13/sfserialization/blob/master/sfserialization/isdefault.h\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;Here\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;I modified the solution provided in \u0026lt;a href=\u0026quot;https://stackoverflow.com/a/264088/2712152\u0026quot;\u0026gt;https://stackoverflow.com/a/264088/2712152\u0026lt;/a\u0026gt; to make it a bit more general. Also since it doesn\u0026apos;t use any of the new C++11 features we can use it with old compilers and should also work with msvc. But the compilers should enable C99 to use this since it uses variadic macros.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;The following macro can be used to check if a particular class has a particular typedef or not.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;/** \n * @class      : HAS_TYPEDEF\n * @brief      : This macro will be used to check if a class has a particular\n * typedef or not.\n * @param typedef_name : Name of Typedef\n * @param name  : Name of struct which is going to be run the test for\n * the given particular typedef specified in typedef_name\n */\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;define\u0026lt;/span\u0026gt; HAS_TYPEDEF(typedef_name, name)                           \\\n   template \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;typename T\u0026amp;gt;\u0026lt;/span\u0026gt;                                          \\\n   struct name {                                                  \\\n      typedef char yes[1];                                        \\\n      typedef char no[2];                                         \\\n      template \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;typename U\u0026amp;gt;\u0026lt;/span\u0026gt;                                       \\\n      struct type_check;                                          \\\n      template \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;typename _1\u0026amp;gt;\u0026lt;/span\u0026gt;                                      \\\n      static yes\u0026amp;amp; chk(type_check\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;typename _1::typedef_name\u0026amp;gt;\u0026lt;/span\u0026gt;*);    \\\n      template \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;typename\u0026amp;gt;\u0026lt;/span\u0026gt;                                         \\\n      static no\u0026amp;amp; chk(...);                                        \\\n      static bool const value = sizeof(chk\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;T\u0026amp;gt;\u0026lt;/span\u0026gt;(0)) == sizeof(yes); \\\n   }\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;The following macro can be used to check if a particular class has a particular member function or not with any given number of arguments.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;/** \n * @class      : HAS_MEM_FUNC\n * @brief      : This macro will be used to check if a class has a particular\n * member function implemented in the public section or not. \n * @param func : Name of Member Function\n * @param name : Name of struct which is going to be run the test for\n * the given particular member function name specified in func\n * @param return_type: Return type of the member function\n * @param ellipsis(...) : Since this is macro should provide test case for every\n * possible member function we use variadic macros to cover all possibilities\n */\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;define\u0026lt;/span\u0026gt; HAS_MEM_FUNC(func, name, return_type, ...)                \\\n   template \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;typename T\u0026amp;gt;\u0026lt;/span\u0026gt;                                          \\\n   struct name {                                                  \\\n      typedef return_type (T::*Sign)(__VA_ARGS__);                \\\n      typedef char yes[1];                                        \\\n      typedef char no[2];                                         \\\n      template \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;typename U, U\u0026amp;gt;\u0026lt;/span\u0026gt;                                    \\\n      struct type_check;                                          \\\n      template \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;typename _1\u0026amp;gt;\u0026lt;/span\u0026gt;                                      \\\n      static yes\u0026amp;amp; chk(type_check\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;Sign, \u0026amp;amp;_1::func\u0026amp;gt;\u0026lt;/span\u0026gt;*);              \\\n      template \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;typename\u0026amp;gt;\u0026lt;/span\u0026gt;                                         \\\n      static no\u0026amp;amp; chk(...);                                        \\\n      static bool const value = sizeof(chk\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;T\u0026amp;gt;\u0026lt;/span\u0026gt;(0)) == sizeof(yes); \\\n   }\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;We can use the above 2 macros to perform the checks for has_typedef and has_mem_func as:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;A\u0026lt;/span\u0026gt; {\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt;:\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typedef\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; check;\n  \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;check_function\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt; \u0026lt;/span\u0026gt;{}\n};\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;B\u0026lt;/span\u0026gt; {\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt;:\n  \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;hello\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; a, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;double\u0026lt;/span\u0026gt; b)\u0026lt;/span\u0026gt; \u0026lt;/span\u0026gt;{}\n  \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;hello\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt; \u0026lt;/span\u0026gt;{}\n};\n\n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;HAS_MEM_FUNC\u0026lt;/span\u0026gt;(check_function, has_check_function, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt;);\n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;HAS_MEM_FUNC\u0026lt;/span\u0026gt;(hello, hello_check, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;double\u0026lt;/span\u0026gt;);\n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;HAS_MEM_FUNC\u0026lt;/span\u0026gt;(hello, hello_void_check, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt;);\n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;HAS_TYPEDEF\u0026lt;/span\u0026gt;(check, has_typedef_check);\n\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;main\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt; \u0026lt;/span\u0026gt;{\n  std::cout \u0026amp;lt;\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Check Function A:\u0026quot;\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026amp;lt; has_check_function\u0026amp;lt;A\u0026amp;gt;::value \u0026amp;lt;\u0026amp;lt; std::endl;\n  std::cout \u0026amp;lt;\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Check Function B:\u0026quot;\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026amp;lt; has_check_function\u0026amp;lt;B\u0026amp;gt;::value \u0026amp;lt;\u0026amp;lt; std::endl;\n  std::cout \u0026amp;lt;\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Hello Function A:\u0026quot;\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026amp;lt; hello_check\u0026amp;lt;A\u0026amp;gt;::value \u0026amp;lt;\u0026amp;lt; std::endl;\n  std::cout \u0026amp;lt;\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Hello Function B:\u0026quot;\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026amp;lt; hello_check\u0026amp;lt;B\u0026amp;gt;::value \u0026amp;lt;\u0026amp;lt; std::endl;\n  std::cout \u0026amp;lt;\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Hello void Function A:\u0026quot;\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026amp;lt; hello_void_check\u0026amp;lt;A\u0026amp;gt;::value \u0026amp;lt;\u0026amp;lt; std::endl;\n  std::cout \u0026amp;lt;\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Hello void Function B:\u0026quot;\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026amp;lt; hello_void_check\u0026amp;lt;B\u0026amp;gt;::value \u0026amp;lt;\u0026amp;lt; std::endl;\n  std::cout \u0026amp;lt;\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Check Typedef A:\u0026quot;\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026amp;lt; has_typedef_check\u0026amp;lt;A\u0026amp;gt;::value \u0026amp;lt;\u0026amp;lt; std::endl;\n  std::cout \u0026amp;lt;\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Check Typedef B:\u0026quot;\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026amp;lt; has_typedef_check\u0026amp;lt;B\u0026amp;gt;::value \u0026amp;lt;\u0026amp;lt; std::endl;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Strange nobody suggested the following nice trick I saw once on this very site :\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;T\u0026lt;/span\u0026gt;\u0026amp;gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;has_foo\u0026lt;/span\u0026gt;\n{\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;S\u0026lt;/span\u0026gt; { \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;foo\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(...)\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;; };\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;derived\u0026lt;/span\u0026gt; : S, T {};\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; V, V\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;W\u0026lt;/span\u0026gt; {};\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; X\u0026amp;gt;\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; (\u0026amp;amp;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;test\u0026lt;/span\u0026gt;(W\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; (X::*)(), \u0026amp;amp;X::foo\u0026amp;gt; *))[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;];\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt;\u0026amp;gt;\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; (\u0026amp;amp;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;test\u0026lt;/span\u0026gt;(...))[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;];\n\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;static\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;bool\u0026lt;/span\u0026gt; value = \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;sizeof\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;test\u0026lt;/span\u0026gt;\u0026amp;lt;derived\u0026amp;gt;(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;)) == \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;;\n};\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;You have to make sure T is a class. It seems that ambiguity in the lookup of foo is a substitution failure. I made it work on gcc, not sure if it is standard though.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;The generic template that can be used for checking if some \u0026quot;feature\u0026quot; is supported by the type:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;type_traits\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt;\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;TypeChecker\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; Type\u0026amp;gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;is_supported\u0026lt;/span\u0026gt;\n{\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// these structs are used to recognize which version\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// of the two functions was chosen during overload resolution\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;supported\u0026lt;/span\u0026gt; {};\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;not_supported\u0026lt;/span\u0026gt; {};\n\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// this overload of chk will be ignored by SFINAE principle\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// if TypeChecker\u0026amp;lt;Type_\u0026amp;gt; is invalid type\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; Type_\u0026amp;gt;\n    \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;static\u0026lt;/span\u0026gt; supported \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;chk\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; std::decay\u0026amp;lt;TypeChecker\u0026amp;lt;Type_\u0026amp;gt;\u0026amp;gt;::type *)\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;;\n\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// ellipsis has the lowest conversion rank, so this overload will be\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// chosen during overload resolution only if the template overload above is ignored\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; Type_\u0026amp;gt;\n    \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;static\u0026lt;/span\u0026gt; not_supported \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;chk\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(...)\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;;\n\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// if the template overload of chk is chosen during\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// overload resolution then the feature is supported\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// if the ellipses overload is chosen the the feature is not supported\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;static\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;constexpr\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;bool\u0026lt;/span\u0026gt; value = std::is_same\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;decltype\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;chk\u0026lt;/span\u0026gt;\u0026amp;lt;Type\u0026amp;gt;(\u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;nullptr\u0026lt;/span\u0026gt;)),supported\u0026amp;gt;::value;\n};\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;The template that checks whether there is a method \u0026lt;code\u0026gt;foo\u0026lt;/code\u0026gt; that is compatible with signature \u0026lt;code\u0026gt;double(const char*)\u0026lt;/code\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// if T doesn\u0026apos;t have foo method with the signature that allows to compile the bellow\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// expression then instantiating this template is Substitution Failure (SF)\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// which Is Not An Error (INAE) if this happens during overload resolution\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; T\u0026amp;gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;using\u0026lt;/span\u0026gt; has_foo = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;decltype\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;double\u0026lt;/span\u0026gt;(std::\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;declval\u0026lt;/span\u0026gt;\u0026amp;lt;T\u0026amp;gt;().\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;foo\u0026lt;/span\u0026gt;(std::\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;declval\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt;*\u0026amp;gt;())));\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Examples\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// types that support has_foo\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;struct1\u0026lt;/span\u0026gt; { \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;double\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;foo\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt;*)\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;; };            \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// exact signature match\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;struct2\u0026lt;/span\u0026gt; { \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;    \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;foo\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; std::string \u0026amp;amp;str)\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;; }; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// compatible signature\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;struct3\u0026lt;/span\u0026gt; { \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;float\u0026lt;/span\u0026gt;  \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;foo\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(...)\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;; };                    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// compatible ellipsis signature\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;struct4\u0026lt;/span\u0026gt; { \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; T\u0026amp;gt;\n                 \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;    \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;foo\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(T t)\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;; };                    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// compatible template signature\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// types that do not support has_foo\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;struct5\u0026lt;/span\u0026gt; { \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt;        \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;foo\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt;*)\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;; }; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// returns void\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;struct6\u0026lt;/span\u0026gt; { \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;std::string \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;foo\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt;*)\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;; }; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// std::string can\u0026apos;t be converted to double\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;struct7\u0026lt;/span\u0026gt; { \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;double\u0026lt;/span\u0026gt;      \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;foo\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(      \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; *)\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;; }; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// const char* can\u0026apos;t be converted to int*\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;struct8\u0026lt;/span\u0026gt; { \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;double\u0026lt;/span\u0026gt;      \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;bar\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt;*)\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;; }; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// there is no foo method\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;main\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt;\n\u0026lt;/span\u0026gt;{\n    std::cout \u0026amp;lt;\u0026amp;lt; std::boolalpha;\n\n    std::cout \u0026amp;lt;\u0026amp;lt; is_supported\u0026amp;lt;has_foo, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;    \u0026amp;gt;::value \u0026amp;lt;\u0026amp;lt; std::endl; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// false\u0026lt;/span\u0026gt;\n    std::cout \u0026amp;lt;\u0026amp;lt; is_supported\u0026amp;lt;has_foo, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;double\u0026lt;/span\u0026gt; \u0026amp;gt;::value \u0026amp;lt;\u0026amp;lt; std::endl; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// false\u0026lt;/span\u0026gt;\n\n    std::cout \u0026amp;lt;\u0026amp;lt; is_supported\u0026amp;lt;has_foo, struct1\u0026amp;gt;::value \u0026amp;lt;\u0026amp;lt; std::endl; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// true\u0026lt;/span\u0026gt;\n    std::cout \u0026amp;lt;\u0026amp;lt; is_supported\u0026amp;lt;has_foo, struct2\u0026amp;gt;::value \u0026amp;lt;\u0026amp;lt; std::endl; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// true\u0026lt;/span\u0026gt;\n    std::cout \u0026amp;lt;\u0026amp;lt; is_supported\u0026amp;lt;has_foo, struct3\u0026amp;gt;::value \u0026amp;lt;\u0026amp;lt; std::endl; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// true\u0026lt;/span\u0026gt;\n    std::cout \u0026amp;lt;\u0026amp;lt; is_supported\u0026amp;lt;has_foo, struct4\u0026amp;gt;::value \u0026amp;lt;\u0026amp;lt; std::endl; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// true\u0026lt;/span\u0026gt;\n\n    std::cout \u0026amp;lt;\u0026amp;lt; is_supported\u0026amp;lt;has_foo, struct5\u0026amp;gt;::value \u0026amp;lt;\u0026amp;lt; std::endl; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// false\u0026lt;/span\u0026gt;\n    std::cout \u0026amp;lt;\u0026amp;lt; is_supported\u0026amp;lt;has_foo, struct6\u0026amp;gt;::value \u0026amp;lt;\u0026amp;lt; std::endl; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// false\u0026lt;/span\u0026gt;\n    std::cout \u0026amp;lt;\u0026amp;lt; is_supported\u0026amp;lt;has_foo, struct7\u0026amp;gt;::value \u0026amp;lt;\u0026amp;lt; std::endl; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// false\u0026lt;/span\u0026gt;\n    std::cout \u0026amp;lt;\u0026amp;lt; is_supported\u0026amp;lt;has_foo, struct8\u0026amp;gt;::value \u0026amp;lt;\u0026amp;lt; std::endl; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// false\u0026lt;/span\u0026gt;\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;a href=\u0026quot;http://coliru.stacked-crooked.com/a/83c6a631ed42cea4\u0026quot; rel=\u0026quot;nofollow\u0026quot;\u0026gt;http://coliru.stacked-crooked.com/a/83c6a631ed42cea4\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;I know that this question is years old, but I think it would useful for people like me to have a more complete updated answer that also works for \u0026lt;code\u0026gt;const\u0026lt;/code\u0026gt; overloaded methods such as \u0026lt;code\u0026gt;std::vector\u0026amp;lt;\u0026amp;gt;::begin\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Based on that \u0026lt;a href=\u0026quot;https://stackoverflow.com/a/257382/4602726\u0026quot;\u0026gt;answer\u0026lt;/a\u0026gt; and that \u0026lt;a href=\u0026quot;https://stackoverflow.com/a/63818399/4602726\u0026quot;\u0026gt;answer\u0026lt;/a\u0026gt; from my follow up question, here\u0026apos;s a more complete answer. Note that this will only work with C++11 and higher.\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;iostream\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;vector\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;EmptyClass\u0026lt;/span\u0026gt;{};\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; T\u0026amp;gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;has_begin\u0026lt;/span\u0026gt;\n{\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;private\u0026lt;/span\u0026gt;:\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;has_begin\u0026lt;/span\u0026gt;() = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;delete\u0026lt;/span\u0026gt;;\n    \n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;one\u0026lt;/span\u0026gt; { \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; x[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;]; };\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;two\u0026lt;/span\u0026gt; { \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; x[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;]; };\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; C\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;static\u0026lt;/span\u0026gt; one \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;test\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;( \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;decltype\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt;(std::declval\u0026amp;lt;C \u0026amp;amp;\u0026amp;gt;().begin())) * )\u0026lt;/span\u0026gt; \u0026lt;/span\u0026gt;;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; C\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;static\u0026lt;/span\u0026gt; two \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;test\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(...)\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;;    \n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt;:\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;static\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;constexpr\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;bool\u0026lt;/span\u0026gt; value = \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;sizeof\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;test\u0026lt;/span\u0026gt;\u0026amp;lt;T\u0026amp;gt;(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;)) == \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;sizeof\u0026lt;/span\u0026gt;(one);\n};\n    \n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;main\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; argc, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; *argv[])\u0026lt;/span\u0026gt;\n\u0026lt;/span\u0026gt;{\n    std::cout \u0026amp;lt;\u0026amp;lt; std::boolalpha;\n    std::cout \u0026amp;lt;\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;vector\u0026amp;lt;int\u0026amp;gt;::begin() exists: \u0026quot;\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026amp;lt; has_begin\u0026amp;lt;std::vector\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026amp;gt;::value \u0026amp;lt;\u0026amp;lt; std::endl;\n    std::cout \u0026amp;lt;\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;EmptyClass::begin() exists: \u0026quot;\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026amp;lt; has_begin\u0026amp;lt;EmptyClass\u0026amp;gt;::value \u0026amp;lt;\u0026amp;lt; std::endl;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;Or the shorter version:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;iostream\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;vector\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;EmptyClass\u0026lt;/span\u0026gt;{};\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; T, \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; = \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt;\u0026amp;gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; has_begin : std::false_type {};\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; T\u0026amp;gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;has_begin\u0026lt;/span\u0026gt;\u0026amp;lt;T, \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;decltype\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt;(std::\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;declval\u0026lt;/span\u0026gt;\u0026amp;lt;T \u0026amp;amp;\u0026amp;gt;().\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;begin\u0026lt;/span\u0026gt;()))\u0026amp;gt; : std::true_type {};\n\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;main\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; argc, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; *argv[])\u0026lt;/span\u0026gt;\n\u0026lt;/span\u0026gt;{\n    std::cout \u0026amp;lt;\u0026amp;lt; std::boolalpha;\n    std::cout \u0026amp;lt;\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;vector\u0026amp;lt;int\u0026amp;gt;::begin() exists: \u0026quot;\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026amp;lt; has_begin\u0026amp;lt;std::vector\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026amp;gt;::value \u0026amp;lt;\u0026amp;lt; std::endl;\n    std::cout \u0026amp;lt;\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;EmptyClass exists: \u0026quot;\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026amp;lt; has_begin\u0026amp;lt;EmptyClass\u0026amp;gt;::value \u0026amp;lt;\u0026amp;lt; std::endl;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;Note that here a complete sample call must be provided. This means that if we tested for the \u0026lt;code\u0026gt;resize\u0026lt;/code\u0026gt; method\u0026apos;s existence then we would have put \u0026lt;code\u0026gt;resize(0)\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Deep magic explanation\u0026lt;/strong\u0026gt;:\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;The first answer posted of this question used \u0026lt;code\u0026gt;test( decltype(\u0026amp;amp;C::helloworld) )\u0026lt;/code\u0026gt;; however this is problematic when the method it is testing is ambiguous due const overloading, thus making the substitution attempt fail.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;To solve this ambiguity we use a void statement which can take any parameters because it is always translated into a \u0026lt;code\u0026gt;noop\u0026lt;/code\u0026gt; and thus the ambiguity is nullified and the call is valid as long as the method exists:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;has_begin\u0026amp;lt;T, \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;decltype\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt;(std::\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;declval\u0026lt;/span\u0026gt;\u0026amp;lt;T \u0026amp;amp;\u0026amp;gt;().\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;begin\u0026lt;/span\u0026gt;()))\u0026amp;gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;Here\u0026apos;s what\u0026apos;s happening in order:\nWe use \u0026lt;code\u0026gt;std::declval\u0026amp;lt;T \u0026amp;amp;\u0026amp;gt;()\u0026lt;/code\u0026gt; to create a callable value for which \u0026lt;code\u0026gt;begin\u0026lt;/code\u0026gt; can then be called. After that the value of \u0026lt;code\u0026gt;begin\u0026lt;/code\u0026gt; is passed as a parameter to a void statement. We then retrieve the type of that void expression using the builtin \u0026lt;code\u0026gt;decltype\u0026lt;/code\u0026gt; so that it can be used as a template type argument. If \u0026lt;code\u0026gt;begin\u0026lt;/code\u0026gt; doesn\u0026apos;t exist then the substitution is invalid and as per SFINAE the other declaration is used instead.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;How about this solution?\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;type_traits\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; U, \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; = \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt;\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; hasToString : std::false_type { };\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; U\u0026amp;gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;hasToString\u0026lt;/span\u0026gt;\u0026amp;lt;U,\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; std::enable_if\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;bool\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;sizeof\u0026lt;/span\u0026gt;(\u0026amp;amp;U::toString))\u0026amp;gt;::type\n\u0026amp;gt; : std::true_type { };\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;There are a lot of answers here, but I failed, to find a version, that performs \u0026lt;em\u0026gt;real\u0026lt;/em\u0026gt; method resolution ordering, while not using any of the newer c++ features (only using c++98 features).\u0026lt;br\u0026gt;\nNote: This version is tested and working with vc++2013, g++ 5.2.0 and the onlline compiler.\u0026lt;br\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;So I came up with a version, that only uses sizeof():\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; T\u0026amp;gt; T \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;declval\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt;)\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;;\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;fake_void\u0026lt;/span\u0026gt; { };\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; T\u0026amp;gt; T \u0026amp;amp;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;operator\u0026lt;/span\u0026gt;,(T \u0026amp;amp;,fake_void);\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; T\u0026amp;gt; T \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; \u0026amp;amp;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;operator\u0026lt;/span\u0026gt;,(T \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; \u0026amp;amp;,fake_void);\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; T\u0026amp;gt; T \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;volatile\u0026lt;/span\u0026gt; \u0026amp;amp;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;operator\u0026lt;/span\u0026gt;,(T \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;volatile\u0026lt;/span\u0026gt; \u0026amp;amp;,fake_void);\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; T\u0026amp;gt; T \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;volatile\u0026lt;/span\u0026gt; \u0026amp;amp;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;operator\u0026lt;/span\u0026gt;,(T \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;volatile\u0026lt;/span\u0026gt; \u0026amp;amp;,fake_void);\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;yes\u0026lt;/span\u0026gt; { \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; v[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;]; };\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;no\u0026lt;/span\u0026gt;  { \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; v[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;]; };\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;bool\u0026lt;/span\u0026gt;\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;yes_no\u0026lt;/span\u0026gt;:yes{};\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;yes_no\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;false\u0026lt;/span\u0026gt;\u0026amp;gt;:no{};\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; T\u0026amp;gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;has_awesome_member\u0026lt;/span\u0026gt; {\n \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; U\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;static\u0026lt;/span\u0026gt; yes_no\u0026amp;lt;(\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;sizeof\u0026lt;/span\u0026gt;((\n   \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;declval\u0026lt;/span\u0026gt;\u0026amp;lt;U\u0026amp;gt;().\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;awesome_member\u0026lt;/span\u0026gt;(),\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;fake_void\u0026lt;/span\u0026gt;()\n  ))!=\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;)\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;check\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;);\n \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt;\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;static\u0026lt;/span\u0026gt; no \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;check\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(...)\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;;\n \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;enum\u0026lt;/span\u0026gt;{value=\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;sizeof\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;check\u0026lt;/span\u0026gt;\u0026amp;lt;T\u0026amp;gt;(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;)) == \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;sizeof\u0026lt;/span\u0026gt;(yes)};\n};\n\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;foo\u0026lt;/span\u0026gt; { \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;awesome_member\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt;)\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;; };\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;bar\u0026lt;/span\u0026gt; { };\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;foo_void\u0026lt;/span\u0026gt; { \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;awesome_member\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt;)\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;; };\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;wrong_params\u0026lt;/span\u0026gt; { \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;awesome_member\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;)\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;; };\n\n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;static_assert\u0026lt;/span\u0026gt;(has_awesome_member\u0026amp;lt;foo\u0026amp;gt;::value,\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;\u0026quot;\u0026lt;/span\u0026gt;);\n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;static_assert\u0026lt;/span\u0026gt;(!has_awesome_member\u0026amp;lt;bar\u0026amp;gt;::value,\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;\u0026quot;\u0026lt;/span\u0026gt;);\n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;static_assert\u0026lt;/span\u0026gt;(has_awesome_member\u0026amp;lt;foo_void\u0026amp;gt;::value,\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;\u0026quot;\u0026lt;/span\u0026gt;);\n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;static_assert\u0026lt;/span\u0026gt;(!has_awesome_member\u0026amp;lt;wrong_params\u0026amp;gt;::value,\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;\u0026quot;\u0026lt;/span\u0026gt;);\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Live demo (with extended return type checking and vc++2010 workaround): \u0026lt;a href=\u0026quot;http://cpp.sh/5b2vs\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;http://cpp.sh/5b2vs\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;No source, as I came up with it myself.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;When running the Live demo on the g++ compiler, please note that array sizes of 0 are allowed, meaning that the static_assert used will not trigger a compiler error, even when it fails.\u0026lt;br\u0026gt;\nA commonly used work-around is to replace the \u0026apos;typedef\u0026apos; in the macro with \u0026apos;extern\u0026apos;.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;My take: to universally determine if something is callable without making verbose type traits for each and every one, or using experimental features, or long code:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; Callable, \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt;... Args, \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;decltype\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;declval\u0026lt;/span\u0026gt;\u0026amp;lt;Callable\u0026amp;gt;()(\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;declval\u0026lt;/span\u0026gt;\u0026amp;lt;Args\u0026amp;gt;()...))\u0026amp;gt;\nstd::true_type \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;isCallableImpl\u0026lt;/span\u0026gt;(Callable, Args...) { \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; {}; }\n\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;std::false_type \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;isCallableImpl\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(...)\u0026lt;/span\u0026gt; \u0026lt;/span\u0026gt;{ \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; {}; }\n\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt;... Args, \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; Callable\u0026amp;gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;constexpr\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;bool\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;isCallable\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(Callable callable)\u0026lt;/span\u0026gt; \u0026lt;/span\u0026gt;{\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;decltype\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;isCallableImpl\u0026lt;/span\u0026gt;(callable, \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;declval\u0026lt;/span\u0026gt;\u0026amp;lt;Args\u0026amp;gt;()...)){};\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;Usage:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;constexpr\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;auto\u0026lt;/span\u0026gt; TO_STRING_TEST = [](\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;auto\u0026lt;/span\u0026gt; in) -\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;decltype\u0026lt;/span\u0026gt;(in.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;toString\u0026lt;/span\u0026gt;()) { \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; {}; };\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;constexpr\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;bool\u0026lt;/span\u0026gt; TO_STRING_WORKS = \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;isCallable\u0026lt;/span\u0026gt;\u0026amp;lt;T\u0026amp;gt;(TO_STRING_TEST);\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Here is my version that handles all possible member function overloads with arbitrary arity, including template member functions, possibly with default arguments. It distinguishes 3 mutually exclusive scenarios when making a member function call to some class type, with given arg types: (1) valid, or (2) ambiguous, or (3) non-viable. Example usage:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;string\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;vector\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;HAS_MEM\u0026lt;/span\u0026gt;(bar)\n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;HAS_MEM_FUN_CALL\u0026lt;/span\u0026gt;(bar)\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;test\u0026lt;/span\u0026gt;\n{\n   \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;bar\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;)\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;;\n   \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;bar\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;double\u0026lt;/span\u0026gt;)\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;;\n   \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;bar\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;,\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;double\u0026lt;/span\u0026gt;)\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;;\n\n   \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt; \u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; T \u0026amp;gt;\n   \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; std::enable_if\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;not\u0026lt;/span\u0026gt; std::is_integral\u0026amp;lt;T\u0026amp;gt;::value \u0026amp;gt;::\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;type\n   \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;bar\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; T\u0026amp;amp;, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;=\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;)\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;{}\n\n   \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt; \u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; T \u0026amp;gt;\n   \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; std::enable_if\u0026amp;lt; std::is_integral\u0026amp;lt;T\u0026amp;gt;::value \u0026amp;gt;::\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;type\n   \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;bar\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; std::vector\u0026amp;lt;T\u0026amp;gt;\u0026amp;amp;, T*)\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;{}\n\n   \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt; \u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; T \u0026amp;gt;\n   \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;bar\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; std::string\u0026amp;amp;, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;)\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;{}\n};\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Now you can use it like this:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;main\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; argc, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; * argv[])\u0026lt;/span\u0026gt;\n\u0026lt;/span\u0026gt;{\n   \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;static_assert\u0026lt;/span\u0026gt;( has_mem_bar\u0026amp;lt;test\u0026amp;gt;::value , \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;\u0026quot;\u0026lt;/span\u0026gt;);\n\n   \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;static_assert\u0026lt;/span\u0026gt;( has_valid_mem_fun_call_bar\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;test\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt;*,\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;long\u0026lt;/span\u0026gt;)\u0026amp;gt;::value , \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;\u0026quot;\u0026lt;/span\u0026gt;);\n   \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;static_assert\u0026lt;/span\u0026gt;( has_valid_mem_fun_call_bar\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;test\u0026lt;/span\u0026gt;(std::string\u0026amp;amp;,\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;long\u0026lt;/span\u0026gt;)\u0026amp;gt;::value , \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;\u0026quot;\u0026lt;/span\u0026gt;);\n\n   \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;static_assert\u0026lt;/span\u0026gt;( has_valid_mem_fun_call_bar\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;test\u0026lt;/span\u0026gt;(std::vector\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;\u0026amp;gt;, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;*)\u0026amp;gt;::value , \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;\u0026quot;\u0026lt;/span\u0026gt;);\n   \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;static_assert\u0026lt;/span\u0026gt;( has_no_viable_mem_fun_call_bar\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;test\u0026lt;/span\u0026gt;(std::vector\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;double\u0026lt;/span\u0026gt;\u0026amp;gt;, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;double\u0026lt;/span\u0026gt;*)\u0026amp;gt;::value , \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;\u0026quot;\u0026lt;/span\u0026gt;);\n\n   \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;static_assert\u0026lt;/span\u0026gt;( has_valid_mem_fun_call_bar\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;test\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;)\u0026amp;gt;::value , \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;\u0026quot;\u0026lt;/span\u0026gt;);\n   \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;static_assert\u0026lt;/span\u0026gt;( std::is_same\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt;,result_of_mem_fun_call_bar\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;test\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;)\u0026amp;gt;::type\u0026amp;gt;::value , \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;\u0026quot;\u0026lt;/span\u0026gt;);\n\n   \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;static_assert\u0026lt;/span\u0026gt;( has_valid_mem_fun_call_bar\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;test\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;,\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;double\u0026lt;/span\u0026gt;)\u0026amp;gt;::value , \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;\u0026quot;\u0026lt;/span\u0026gt;);\n   \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;static_assert\u0026lt;/span\u0026gt;( \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;not\u0026lt;/span\u0026gt; has_valid_mem_fun_call_bar\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;test\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;,\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;double\u0026lt;/span\u0026gt;,\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;)\u0026amp;gt;::value , \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;\u0026quot;\u0026lt;/span\u0026gt;);\n\n   \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;static_assert\u0026lt;/span\u0026gt;( \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;not\u0026lt;/span\u0026gt; has_ambiguous_mem_fun_call_bar\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;test\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;double\u0026lt;/span\u0026gt;)\u0026amp;gt;::value , \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;\u0026quot;\u0026lt;/span\u0026gt;);\n   \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;static_assert\u0026lt;/span\u0026gt;( has_ambiguous_mem_fun_call_bar\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;test\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;unsigned\u0026lt;/span\u0026gt;)\u0026amp;gt;::value , \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;\u0026quot;\u0026lt;/span\u0026gt;);\n\n   \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;static_assert\u0026lt;/span\u0026gt;( has_viable_mem_fun_call_bar\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;test\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;unsigned\u0026lt;/span\u0026gt;)\u0026amp;gt;::value , \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;\u0026quot;\u0026lt;/span\u0026gt;);\n   \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;static_assert\u0026lt;/span\u0026gt;( has_viable_mem_fun_call_bar\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;test\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;)\u0026amp;gt;::value , \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;\u0026quot;\u0026lt;/span\u0026gt;);\n\n   \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;static_assert\u0026lt;/span\u0026gt;( has_no_viable_mem_fun_call_bar\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;test\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt;)\u0026amp;gt;::value , \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;\u0026quot;\u0026lt;/span\u0026gt;);\n\n   \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Here is the code, written in c++11, however, you can easily port it (with minor tweaks) to non-c++11 that has typeof extensions (e.g. gcc). You can replace the HAS_MEM macro with your own.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;pragma\u0026lt;/span\u0026gt; once\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; __cplusplus \u0026amp;gt;= 201103\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;utility\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;type_traits\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;define\u0026lt;/span\u0026gt; HAS_MEM(mem)                                                                                     \\\n                                                                                                     \\\ntemplate \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt; typename T \u0026amp;gt;\u0026lt;/span\u0026gt;                                                                               \\\nstruct has_mem_##mem                                                                                  \\\n{                                                                                                     \\\n  struct yes {};                                                                                     \\\n  struct no  {};                                                                                     \\\n                                                                                                     \\\n  struct ambiguate_seed { char mem; };                                                               \\\n  template \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt; typename U \u0026amp;gt;\u0026lt;/span\u0026gt; struct ambiguate : U, ambiguate_seed {};                                   \\\n                                                                                                     \\\n  template \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt; typename U, typename = decltype(\u0026amp;amp;U::mem) \u0026amp;gt;\u0026lt;/span\u0026gt; static constexpr no  test(int);              \\\n  template \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt; typename                                 \u0026amp;gt;\u0026lt;/span\u0026gt; static constexpr yes test(...);              \\\n                                                                                                     \\\n  static bool constexpr value = std::is_same\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;decltype(test\u0026amp;lt; ambiguate\u0026amp;lt;T\u0026amp;gt;\u0026lt;/span\u0026gt; \u0026amp;gt;(0)),yes\u0026amp;gt;::value ;         \\\n  typedef std::integral_constant\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;bool,value\u0026amp;gt;\u0026lt;/span\u0026gt;    type;                                                \\\n};\u0026lt;/span\u0026gt;\n\n\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;define\u0026lt;/span\u0026gt; HAS_MEM_FUN_CALL(memfun)                                                                         \\\n                                                                                                     \\\ntemplate \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt; typename Signature \u0026amp;gt;\u0026lt;/span\u0026gt;                                                                       \\\nstruct has_valid_mem_fun_call_##memfun;                                                               \\\n                                                                                                     \\\ntemplate \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt; typename T, typename... Args \u0026amp;gt;\u0026lt;/span\u0026gt;                                                             \\\nstruct has_valid_mem_fun_call_##memfun\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt; T(Args...) \u0026amp;gt;\u0026lt;/span\u0026gt;                                                  \\\n{                                                                                                     \\\n  struct yes {};                                                                                     \\\n  struct no  {};                                                                                     \\\n                                                                                                     \\\n  template \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt; typename U, bool = has_mem_##memfun\u0026amp;lt;U\u0026amp;gt;\u0026lt;/span\u0026gt;::value \u0026amp;gt;                                         \\\n  struct impl                                                                                        \\\n  {                                                                                                  \\\n     template \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt; typename V, typename = decltype(std::declval\u0026amp;lt;V\u0026amp;gt;\u0026lt;/span\u0026gt;().memfun(std::declval\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;Args\u0026amp;gt;\u0026lt;/span\u0026gt;()...)) \u0026amp;gt; \\\n     struct test_result { using type = yes; };                                                       \\\n                                                                                                     \\\n     template \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt; typename V \u0026amp;gt;\u0026lt;/span\u0026gt; static constexpr typename test_result\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;V\u0026amp;gt;\u0026lt;/span\u0026gt;::type test(int);               \\\n     template \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt; typename   \u0026amp;gt;\u0026lt;/span\u0026gt; static constexpr                            no test(...);               \\\n                                                                                                     \\\n     static constexpr bool value = std::is_same\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;decltype(test\u0026amp;lt;U\u0026amp;gt;\u0026lt;/span\u0026gt;(0)),yes\u0026amp;gt;::value;                    \\\n     using type = std::integral_constant\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;bool, value\u0026amp;gt;\u0026lt;/span\u0026gt;;                                               \\\n  };                                                                                                 \\\n                                                                                                     \\\n  template \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt; typename U \u0026amp;gt;\u0026lt;/span\u0026gt;                                                                            \\\n  struct impl\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;U,false\u0026amp;gt;\u0026lt;/span\u0026gt; : std::false_type {};                                                         \\\n                                                                                                     \\\n  static constexpr bool value = impl\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;T\u0026amp;gt;\u0026lt;/span\u0026gt;::value;                                                      \\\n  using type = std::integral_constant\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;bool, value\u0026amp;gt;\u0026lt;/span\u0026gt;;                                                  \\\n};                                                                                                    \\\n                                                                                                     \\\ntemplate \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt; typename Signature \u0026amp;gt;\u0026lt;/span\u0026gt;                                                                       \\\nstruct has_ambiguous_mem_fun_call_##memfun;                                                           \\\n                                                                                                     \\\ntemplate \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt; typename T, typename... Args \u0026amp;gt;\u0026lt;/span\u0026gt;                                                             \\\nstruct has_ambiguous_mem_fun_call_##memfun\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt; T(Args...) \u0026amp;gt;\u0026lt;/span\u0026gt;                                              \\\n{                                                                                                     \\\n  struct ambiguate_seed { void memfun(...); };                                                       \\\n                                                                                                     \\\n  template \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt; class U, bool = has_mem_##memfun\u0026amp;lt;U\u0026amp;gt;\u0026lt;/span\u0026gt;::value \u0026amp;gt;                                            \\\n  struct ambiguate : U, ambiguate_seed                                                               \\\n  {                                                                                                  \\\n    using ambiguate_seed::memfun;                                                                    \\\n    using U::memfun;                                                                                 \\\n  };                                                                                                 \\\n                                                                                                     \\\n  template \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt; class U \u0026amp;gt;\u0026lt;/span\u0026gt;                                                                               \\\n  struct ambiguate\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;U,false\u0026amp;gt;\u0026lt;/span\u0026gt; : ambiguate_seed {};                                                     \\\n                                                                                                     \\\n  static constexpr bool value = not has_valid_mem_fun_call_##memfun\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt; ambiguate\u0026amp;lt;T\u0026amp;gt;\u0026lt;/span\u0026gt;(Args...) \u0026amp;gt;::value; \\\n  using type = std::integral_constant\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;bool, value\u0026amp;gt;\u0026lt;/span\u0026gt;;                                                  \\\n};                                                                                                    \\\n                                                                                                     \\\ntemplate \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt; typename Signature \u0026amp;gt;\u0026lt;/span\u0026gt;                                                                       \\\nstruct has_viable_mem_fun_call_##memfun;                                                              \\\n                                                                                                     \\\ntemplate \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt; typename T, typename... Args \u0026amp;gt;\u0026lt;/span\u0026gt;                                                             \\\nstruct has_viable_mem_fun_call_##memfun\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt; T(Args...) \u0026amp;gt;\u0026lt;/span\u0026gt;                                                 \\\n{                                                                                                     \\\n  static constexpr bool value = has_valid_mem_fun_call_##memfun\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;T(Args...)\u0026amp;gt;\u0026lt;/span\u0026gt;::value                   \\\n                             or has_ambiguous_mem_fun_call_##memfun\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;T(Args...)\u0026amp;gt;\u0026lt;/span\u0026gt;::value;              \\\n  using type = std::integral_constant\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;bool, value\u0026amp;gt;\u0026lt;/span\u0026gt;;                                                  \\\n};                                                                                                    \\\n                                                                                                     \\\ntemplate \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt; typename Signature \u0026amp;gt;\u0026lt;/span\u0026gt;                                                                       \\\nstruct has_no_viable_mem_fun_call_##memfun;                                                           \\\n                                                                                                     \\\ntemplate \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt; typename T, typename... Args \u0026amp;gt;\u0026lt;/span\u0026gt;                                                             \\\nstruct has_no_viable_mem_fun_call_##memfun \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt; T(Args...) \u0026amp;gt;\u0026lt;/span\u0026gt;                                             \\\n{                                                                                                     \\\n  static constexpr bool value = not has_viable_mem_fun_call_##memfun\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;T(Args...)\u0026amp;gt;\u0026lt;/span\u0026gt;::value;             \\\n  using type = std::integral_constant\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;bool, value\u0026amp;gt;\u0026lt;/span\u0026gt;;                                                  \\\n};                                                                                                    \\\n                                                                                                     \\\ntemplate \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt; typename Signature \u0026amp;gt;\u0026lt;/span\u0026gt;                                                                       \\\nstruct result_of_mem_fun_call_##memfun;                                                               \\\n                                                                                                     \\\ntemplate \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt; typename T, typename... Args \u0026amp;gt;\u0026lt;/span\u0026gt;                                                             \\\nstruct result_of_mem_fun_call_##memfun\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt; T(Args...) \u0026amp;gt;\u0026lt;/span\u0026gt;                                                  \\\n{                                                                                                     \\\n  using type = decltype(std::declval\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;T\u0026amp;gt;\u0026lt;/span\u0026gt;().memfun(std::declval\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;Args\u0026amp;gt;\u0026lt;/span\u0026gt;()...));                          \\\n};\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;endif\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;hr\u0026gt;\n    ","\n\u0026lt;p\u0026gt;You can skip all the metaprogramming in C++14, and just write this using \u0026lt;a href=\u0026quot;http://fit.readthedocs.io/en/latest/include/fit/conditional.html\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;\u0026lt;code\u0026gt;fit::conditional\u0026lt;/code\u0026gt;\u0026lt;/a\u0026gt; from the \u0026lt;a href=\u0026quot;https://github.com/pfultz2/Fit\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;Fit\u0026lt;/a\u0026gt; library:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; T\u0026amp;gt;\nstd::string \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;optionalToString\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(T* x)\u0026lt;/span\u0026gt;\n\u0026lt;/span\u0026gt;{\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; fit::\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;conditional\u0026lt;/span\u0026gt;(\n        [](\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;auto\u0026lt;/span\u0026gt;* obj) -\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;decltype\u0026lt;/span\u0026gt;(obj-\u0026amp;gt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;toString\u0026lt;/span\u0026gt;()) { \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; obj-\u0026amp;gt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;toString\u0026lt;/span\u0026gt;(); },\n        [](\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;auto\u0026lt;/span\u0026gt;*) { \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;toString not defined\u0026quot;\u0026lt;/span\u0026gt;; }\n    )(x);\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;You can also create the function directly from the lambdas as well:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;FIT_STATIC_LAMBDA_FUNCTION\u0026lt;/span\u0026gt;(optionalToString) = fit::\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;conditional\u0026lt;/span\u0026gt;(\n    [](\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;auto\u0026lt;/span\u0026gt;* obj) -\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;decltype\u0026lt;/span\u0026gt;(obj-\u0026amp;gt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;toString\u0026lt;/span\u0026gt;(), std::\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;string\u0026lt;/span\u0026gt;()) { \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; obj-\u0026amp;gt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;toString\u0026lt;/span\u0026gt;(); },\n    [](\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;auto\u0026lt;/span\u0026gt;*) -\u0026amp;gt; std::string { \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;toString not defined\u0026quot;\u0026lt;/span\u0026gt;; }\n);\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;However, if you are using a compiler that doesn\u0026apos;t support generic lambdas, you will have to write separate function objects:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;withToString\u0026lt;/span\u0026gt;\n{\n    \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; T\u0026amp;gt;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;auto\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;operator\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(T* obj)\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; -\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;decltype\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(obj-\u0026amp;gt;toString(), std::string())\u0026lt;/span\u0026gt;\n    \u0026lt;/span\u0026gt;{\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; obj-\u0026amp;gt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;toString\u0026lt;/span\u0026gt;();\n    }\n};\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;withoutToString\u0026lt;/span\u0026gt;\n{\n    \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; T\u0026amp;gt;\n    std::string \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;operator\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(T*)\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt;\n    \u0026lt;/span\u0026gt;{\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;toString not defined\u0026quot;\u0026lt;/span\u0026gt;;\n    }\n};\n\n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;FIT_STATIC_FUNCTION\u0026lt;/span\u0026gt;(optionalToString) = fit::\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;conditional\u0026lt;/span\u0026gt;(\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;withToString\u0026lt;/span\u0026gt;(),\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;withoutToString\u0026lt;/span\u0026gt;()\n);\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Probably not as good as other examples, but this is what I came up with for C++11. This works for picking overloaded methods.\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt;... Args\u0026amp;gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Pack\u0026lt;/span\u0026gt; {};\n\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;define\u0026lt;/span\u0026gt; Proxy(T) ((T \u0026amp;amp;)(*(int *)(nullptr)))\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; Class, \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; ArgPack, \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; = \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;nullptr_t\u0026lt;/span\u0026gt;\u0026amp;gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; HasFoo\n{\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;enum\u0026lt;/span\u0026gt; { value = \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;false\u0026lt;/span\u0026gt; };\n};\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; Class, \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt;... Args\u0026amp;gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;HasFoo\u0026lt;/span\u0026gt;\u0026amp;lt;\n    Class,\n    Pack\u0026amp;lt;Args...\u0026amp;gt;,\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;decltype\u0026lt;/span\u0026gt;((\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt;)(\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;Proxy\u0026lt;/span\u0026gt;(Class).\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;foo\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;Proxy\u0026lt;/span\u0026gt;(Args)...)), \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;nullptr\u0026lt;/span\u0026gt;)\u0026amp;gt;\n{\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;enum\u0026lt;/span\u0026gt; { value = \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;true\u0026lt;/span\u0026gt; };\n};\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;Example usage\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Object\u0026lt;/span\u0026gt;\n{\n    \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;foo\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; n)\u0026lt;/span\u0026gt;         \u0026lt;/span\u0026gt;{ \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; n; }\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; SOME_CONDITION\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;foo\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; n, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; c)\u0026lt;/span\u0026gt; \u0026lt;/span\u0026gt;{ \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; n + c; }\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;endif\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n};\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;bool\u0026lt;/span\u0026gt; has_foo_int_char\u0026amp;gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Dispatcher\u0026lt;/span\u0026gt;;\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026amp;gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Dispatcher\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;false\u0026lt;/span\u0026gt;\u0026amp;gt;\n{\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; Object\u0026amp;gt;\n    \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;static\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;exec\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(Object \u0026amp;amp;object, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; n, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; c)\u0026lt;/span\u0026gt;\n    \u0026lt;/span\u0026gt;{\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; object.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;foo\u0026lt;/span\u0026gt;(n) + c;\n    }\n};\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026amp;gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Dispatcher\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;true\u0026lt;/span\u0026gt;\u0026amp;gt;\n{\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; Object\u0026amp;gt;\n    \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;static\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;exec\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(Object \u0026amp;amp;object, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; n, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; c)\u0026lt;/span\u0026gt;\n    \u0026lt;/span\u0026gt;{\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; object.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;foo\u0026lt;/span\u0026gt;(n, c);\n    }\n};\n\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;runExample\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt;\n\u0026lt;/span\u0026gt;{\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;using\u0026lt;/span\u0026gt; Args = Pack\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt;\u0026amp;gt;;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;enum\u0026lt;/span\u0026gt; { has_overload = HasFoo\u0026amp;lt;Object, Args\u0026amp;gt;::value };\n    Object object;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; Dispatcher\u0026amp;lt;has_overload\u0026amp;gt;::\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;exec\u0026lt;/span\u0026gt;(object, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;100\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;a\u0026apos;\u0026lt;/span\u0026gt;);\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Here is an example of the working code.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; T\u0026amp;gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;using\u0026lt;/span\u0026gt; toStringFn = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;decltype\u0026lt;/span\u0026gt;(std::\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;declval\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; T\u0026amp;gt;().\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;toString\u0026lt;/span\u0026gt;());\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;T\u0026lt;/span\u0026gt;, toStringFn\u0026amp;lt;T\u0026amp;gt;* = \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;nullptr\u0026lt;/span\u0026gt;\u0026amp;gt;\nstd::string \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;optionalToString\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; T* obj, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;)\n{\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; obj-\u0026amp;gt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;toString\u0026lt;/span\u0026gt;();\n}\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;T\u0026lt;/span\u0026gt;\u0026amp;gt;\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;std::string \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;optionalToString\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; T* obj, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;long\u0026lt;/span\u0026gt;)\u0026lt;/span\u0026gt;\n\u0026lt;/span\u0026gt;{\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;toString not defined\u0026quot;\u0026lt;/span\u0026gt;;\n}\n\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;main\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt;\n\u0026lt;/span\u0026gt;{\n    A* a;\n    B* b;\n\n    std::cout \u0026amp;lt;\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;optionalToString\u0026lt;/span\u0026gt;(a, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;) \u0026amp;lt;\u0026amp;lt; std::endl; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// This is A\u0026lt;/span\u0026gt;\n    std::cout \u0026amp;lt;\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;optionalToString\u0026lt;/span\u0026gt;(b, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;) \u0026amp;lt;\u0026amp;lt; std::endl; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// toString not defined\u0026lt;/span\u0026gt;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;code\u0026gt;toStringFn\u0026amp;lt;T\u0026amp;gt;* = nullptr\u0026lt;/code\u0026gt; will enable the function which takes extra \u0026lt;code\u0026gt;int\u0026lt;/code\u0026gt; argument which has a priority over function which takes \u0026lt;code\u0026gt;long\u0026lt;/code\u0026gt; when called with \u0026lt;code\u0026gt;0\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;You can use the same principle for the functions which returns \u0026lt;code\u0026gt;true\u0026lt;/code\u0026gt; if function is implemented.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; T\u0026amp;gt;\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;constexpr\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;bool\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;toStringExists\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;long\u0026lt;/span\u0026gt;)\u0026lt;/span\u0026gt;\n\u0026lt;/span\u0026gt;{\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;false\u0026lt;/span\u0026gt;;\n}\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; T, toStringFn\u0026amp;lt;T\u0026amp;gt;* = \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;nullptr\u0026lt;/span\u0026gt;\u0026amp;gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;constexpr\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;bool\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;toStringExists\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;)\n{\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;true\u0026lt;/span\u0026gt;;\n}\n\n\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;main\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt;\n\u0026lt;/span\u0026gt;{\n    A* a;\n    B* b;\n\n    std::cout \u0026amp;lt;\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;toStringExists\u0026lt;/span\u0026gt;\u0026amp;lt;A\u0026amp;gt;(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;) \u0026amp;lt;\u0026amp;lt; std::endl; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// true\u0026lt;/span\u0026gt;\n    std::cout \u0026amp;lt;\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;toStringExists\u0026lt;/span\u0026gt;\u0026amp;lt;B\u0026amp;gt;(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;) \u0026amp;lt;\u0026amp;lt; std::endl; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// false\u0026lt;/span\u0026gt;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;I had a similar problem:\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;A template class that may be derived from few base classes, some that have a certain member and others that do not.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;I solved it similarly to the \u0026quot;typeof\u0026quot; (Nicola Bonelli\u0026apos;s) answer, but with decltype so it compiles and runs correctly on MSVS:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;iostream\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;string\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Generic\u0026lt;/span\u0026gt; {};    \n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;HasMember\u0026lt;/span\u0026gt; \n{\n  \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;HasMember\u0026lt;/span\u0026gt;() : _a(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;) {};\n  \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; _a;\n};    \n\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// SFINAE test\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; T\u0026amp;gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;S\u0026lt;/span\u0026gt; : \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; T\n{\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt;:\n  \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;std::string \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;foo\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(std::string b)\u0026lt;/span\u0026gt;\n  \u0026lt;/span\u0026gt;{\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;foo2\u0026lt;/span\u0026gt;\u0026amp;lt;T\u0026amp;gt;(b,\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;);\n  }\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;protected\u0026lt;/span\u0026gt;:\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; T\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;std::string \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;foo2\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(std::string b, \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;decltype\u0026lt;/span\u0026gt; (T::_a))\u0026lt;/span\u0026gt;\n  \u0026lt;/span\u0026gt;{\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; b + std::\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;to_string\u0026lt;/span\u0026gt;(T::_a);\n  }\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; T\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;std::string \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;foo2\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(std::string b, ...)\u0026lt;/span\u0026gt;\n  \u0026lt;/span\u0026gt;{\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; b + \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;No\u0026quot;\u0026lt;/span\u0026gt;;\n  }\n};\n\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;main\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; argc, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; *argv[])\u0026lt;/span\u0026gt;\n\u0026lt;/span\u0026gt;{\n  S\u0026amp;lt;HasMember\u0026amp;gt; d1;\n  S\u0026amp;lt;Generic\u0026amp;gt; d2;\n\n  std::cout \u0026amp;lt;\u0026amp;lt; d1.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;foo\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;HasMember: \u0026quot;\u0026lt;/span\u0026gt;) \u0026amp;lt;\u0026amp;lt; std::endl;\n  std::cout \u0026amp;lt;\u0026amp;lt; d2.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;foo\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Generic: \u0026quot;\u0026lt;/span\u0026gt;) \u0026amp;lt;\u0026amp;lt; std::endl;\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    "],"id":540,"title":"Templated check for the existence of a class member function?","content":"\n                \n\u0026lt;p\u0026gt;Is it possible to write a template that changes behavior depending on if a certain member function is defined on a class?\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Here\u0026apos;s a simple example of what I would want to write:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; T\u0026amp;gt;\nstd::string \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;optionalToString\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(T* obj)\u0026lt;/span\u0026gt;\n\u0026lt;/span\u0026gt;{\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;FUNCTION_EXISTS\u0026lt;/span\u0026gt;(T-\u0026amp;gt;toString))\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; obj-\u0026amp;gt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;toString\u0026lt;/span\u0026gt;();\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;else\u0026lt;/span\u0026gt;\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;toString not defined\u0026quot;\u0026lt;/span\u0026gt;;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;So, if \u0026lt;code\u0026gt;class T\u0026lt;/code\u0026gt; has \u0026lt;code\u0026gt;toString()\u0026lt;/code\u0026gt; defined, then it uses it; otherwise, it doesn\u0026apos;t. The magical part that I don\u0026apos;t know how to do is the \u0026quot;FUNCTION_EXISTS\u0026quot; part.\u0026lt;/p\u0026gt;\n    ","slug":"templated-check-for-the-existence-of-a-class-member-function-1657388363414","postType":"QUESTION","createdAt":"2022-07-09T17:39:23.000Z","updatedAt":"2022-07-09T17:39:23.000Z","tags":[{"id":2640,"name":"template-meta-programming","slug":"template-meta-programming","createdAt":"2022-07-09T17:39:23.000Z","updatedAt":"2022-07-09T17:39:23.000Z","Questions_Tags":{"questionId":540,"tagId":2640}},{"id":2641,"name":"sfinae","slug":"sfinae","createdAt":"2022-07-09T17:39:23.000Z","updatedAt":"2022-07-09T17:39:23.000Z","Questions_Tags":{"questionId":540,"tagId":2641}}],"relatedQuestions":[{"title":"Templated check for the existence of a class member function?","slug":"templated-check-for-the-existence-of-a-class-member-function-1657388363414","tags":[{"name":"template-meta-programming","Questions_Tags":{"questionId":540,"tagId":2640}},{"name":"sfinae","Questions_Tags":{"questionId":540,"tagId":2641}}]}]},"randomQuestions":[{"title":"PHP mail function doesn't complete sending of e-mail","slug":"php-mail-function-doesn't-complete-sending-of-e-mail-1657384307499"},{"title":"Using fflush(stdin)","slug":"using-fflush(stdin)-1657387602771"},{"title":"What's the simplest way to print a Java array?","slug":"what's-the-simplest-way-to-print-a-java-array-1657384702397"},{"title":"Importing installed package from script raises \"AttributeError: module has no attribute\" or \"ImportError: cannot import name\"","slug":"importing-installed-package-from-script-raises-\"attributeerror:-module-has-no-attribute\"-or-\"importerror:-cannot-import-name\"-1657387790607"},{"title":"Is JavaScript a pass-by-reference or pass-by-value language?","slug":"is-javascript-a-pass-by-reference-or-pass-by-value-language-1657384675679"},{"title":"What is the difference between char s[] and char *s?","slug":"what-is-the-difference-between-char-s-and-char-*s-1657387823570"},{"title":"What are the basic rules and idioms for operator overloading?","slug":"what-are-the-basic-rules-and-idioms-for-operator-overloading-1657384449752"},{"title":"Why is using the JavaScript eval function a bad idea?","slug":"why-is-using-the-javascript-eval-function-a-bad-idea-1657387485165"},{"title":"Resolve build errors due to circular dependency amongst classes","slug":"resolve-build-errors-due-to-circular-dependency-amongst-classes-1657384903462"},{"title":"Unfortunately MyApp has stopped. How can I solve this?","slug":"unfortunately-myapp-has-stopped.-how-can-i-solve-this-1657384402171"},{"title":"How do I check if an array includes a value in JavaScript?","slug":"how-do-i-check-if-an-array-includes-a-value-in-javascript-1657387421185"},{"title":"How to sum a variable by group","slug":"how-to-sum-a-variable-by-group-1657384838148"},{"title":"jQuery Ajax POST example with PHP","slug":"jquery-ajax-post-example-with-php-1657387402634"},{"title":"Servlet returns \"HTTP Status 404 The requested resource (/servlet) is not available\"","slug":"servlet-returns-\"http-status-404-the-requested-resource-(servlet)-is-not-available\"-1657384850661"},{"title":"Where do I find the current C or C++ standard documents?","slug":"where-do-i-find-the-current-c-or-c++-standard-documents-1657388006897"},{"title":"The Definitive C Book Guide and List","slug":"the-definitive-c-book-guide-and-list-1657384747653"},{"title":"With arrays, why is it the case that a[5] == 5[a]?","slug":"with-arrays-why-is-it-the-case-that-a5-5a-1657387956216"},{"title":"Why not use tables for layout in HTML? [closed]","slug":"why-not-use-tables-for-layout-in-html-closed-1657387752327"},{"title":"How do I profile C++ code running on Linux?","slug":"how-do-i-profile-c++-code-running-on-linux-1657384754272"},{"title":"Why is iostream::eof inside a loop condition (i.e. `while (!stream.eof())`) considered wrong?","slug":"why-is-iostream::eof-inside-a-loop-condition-(i.e.-while-(!stream.eof()))-considered-wrong-1657384355427"}]},"__N_SSG":true},"page":"/questions/[slug]","query":{"slug":"templated-check-for-the-existence-of-a-class-member-function-1657388363414"},"buildId":"eGqQHYKGZKE-nXShFn8wX","isFallback":false,"gsp":true,"locale":"en","locales":["en"],"defaultLocale":"en","scriptLoader":[]}</script></body></html>