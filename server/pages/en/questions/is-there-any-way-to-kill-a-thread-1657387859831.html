<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><meta name="twitter:card" content="summary_large_image"/><meta name="twitter:site" content="@solutionschecker.com"/><meta name="twitter:creator" content="@solutionschecker.com"/><meta property="og:url" content="https://solutionschecker.com"/><meta property="og:type" content="website"/><meta property="og:image" content="https://solutionschecker.com/solutions-checker-banner.png"/><meta property="og:image:alt" content="Find the solution to any question. We focus on finding the fastest possible solution for users. Main topics like coding, learning. - solutionschecker.com"/><link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png"/><link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png"/><link rel="manifest" href="/site.webmanifest"/><script type="application/ld+json">{"@context":"https://schema.org","@type":"Organization","logo":"/logo.svg","url":"https://solutionschecker.com"}</script><link name="keywords" content="kill,terminate,solutions checker, solution checker, how to, solution for, check for solution, resolve question, what is, what solution for, find solution"/><script type="application/ld+json">{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"item":{"@id":"https://solutionschecker.com","name":"Home"}},{"@type":"ListItem","position":2,"item":{"@id":"https://solutionschecker.com/questions","name":"Questions"}},{"@type":"ListItem","position":3,"item":{"@id":"https://solutionschecker.com/questions/is-there-any-way-to-kill-a-thread-1657387859831","name":"Questions"}}]}</script><title>Is there any way to kill a Thread? | Solution Checker</title><meta name="robots" content="index,follow"/><meta name="description" content="Is it possible to terminate a running thread without setting/checking any flags/semaphores/etc.?
    "/><meta property="og:title" content="Is there any way to kill a Thread? | Solution Checker"/><meta property="og:description" content="Is it possible to terminate a running thread without setting/checking any flags/semaphores/etc.?
    "/><script type="application/ld+json">{"@context":"https://schema.org","@type":"QAPage","mainEntity":{"name":"Is there any way to kill a Thread?","text":"Is it possible to terminate a running thread without setting/checking any flags/semaphores/etc.?\n    ","answerCount":30,"upVoteCount":500,"suggestedAnswer":[{"text":"It is generally a bad pattern to kill a thread abruptly, in Python, and in any language. Think of the following cases:\n\nthe thread is holding a critical resource that must be closed properly\nthe thread has created several other threads that must be killed as well.\n\nThe nice way of handling this, if you can afford it (if you are managing your own threads), is to have an exit_request flag that each thread checks on a regular interval to see if it is time for it to exit.\nFor example:\nimport threading\n\nclass StoppableThread(threading.Thread):\n    &quot;&quot;&quot;Thread class with a stop() method. The thread itself has to check\n    regularly for the stopped() condition.&quot;&quot;&quot;\n\n    def __init__(self,  *args, **kwargs):\n        super(StoppableThread, self).__init__(*args, **kwargs)\n        self._stop_event = threading.Event()\n\n    def stop(self):\n        self._stop_event.set()\n\n    def stopped(self):\n        return self._stop_event.is_set()\n\nIn this code, you should call stop() on the thread when you want it to exit, and wait for the thread to exit properly using join(). The thread should check the stop flag at regular intervals.\nThere are cases, however, when you really need to kill a thread. An example is when you are wrapping an external library that is busy for long calls, and you want to interrupt it.\nThe following code allows (with some restrictions) to raise an Exception in a Python thread:\ndef _async_raise(tid, exctype):\n    &apos;&apos;&apos;Raises an exception in the threads with id tid&apos;&apos;&apos;\n    if not inspect.isclass(exctype):\n        raise TypeError(&quot;Only types can be raised (not instances)&quot;)\n    res = ctypes.pythonapi.PyThreadState_SetAsyncExc(ctypes.c_long(tid),\n                                                     ctypes.py_object(exctype))\n    if res == 0:\n        raise ValueError(&quot;invalid thread id&quot;)\n    elif res != 1:\n        # &quot;if it returns a number greater than one, you&apos;re in trouble,\n        # and you should call it again with exc=NULL to revert the effect&quot;\n        ctypes.pythonapi.PyThreadState_SetAsyncExc(ctypes.c_long(tid), None)\n        raise SystemError(&quot;PyThreadState_SetAsyncExc failed&quot;)\n\nclass ThreadWithExc(threading.Thread):\n    &apos;&apos;&apos;A thread class that supports raising an exception in the thread from\n       another thread.\n    &apos;&apos;&apos;\n    def _get_my_tid(self):\n        &quot;&quot;&quot;determines this (self&apos;s) thread id\n\n        CAREFUL: this function is executed in the context of the caller\n        thread, to get the identity of the thread represented by this\n        instance.\n        &quot;&quot;&quot;\n        if not self.isAlive():\n            raise threading.ThreadError(&quot;the thread is not active&quot;)\n\n        # do we have it cached?\n        if hasattr(self, &quot;_thread_id&quot;):\n            return self._thread_id\n\n        # no, look for it in the _active dict\n        for tid, tobj in threading._active.items():\n            if tobj is self:\n                self._thread_id = tid\n                return tid\n\n        # TODO: in python 2.6, there&apos;s a simpler way to do: self.ident\n\n        raise AssertionError(&quot;could not determine the thread&apos;s id&quot;)\n\n    def raiseExc(self, exctype):\n        &quot;&quot;&quot;Raises the given exception type in the context of this thread.\n\n        If the thread is busy in a system call (time.sleep(),\n        socket.accept(), ...), the exception is simply ignored.\n\n        If you are sure that your exception should terminate the thread,\n        one way to ensure that it works is:\n\n            t = ThreadWithExc( ... )\n            ...\n            t.raiseExc( SomeException )\n            while t.isAlive():\n                time.sleep( 0.1 )\n                t.raiseExc( SomeException )\n\n        If the exception is to be caught by the thread, you need a way to\n        check that your thread has caught it.\n\n        CAREFUL: this function is executed in the context of the\n        caller thread, to raise an exception in the context of the\n        thread represented by this instance.\n        &quot;&quot;&quot;\n        _async_raise( self._get_my_tid(), exctype )\n\n(Based on Killable Threads by Tomer Filiba. The quote about the return value of PyThreadState_SetAsyncExc appears to be from an old version of Python.)\nAs noted in the documentation, this is not a magic bullet because if the thread is busy outside the Python interpreter, it will not catch the interruption.\nA good usage pattern of this code is to have the thread catch a specific exception and perform the cleanup. That way, you can interrupt a task and still have proper cleanup.\n    ","url":"/questions/[slug]#solution1","@type":"Answer","upvoteCount":0},{"text":"A multiprocessing.Process can p.terminate()\nIn the cases where I want to kill a thread, but do not want to use flags/locks/signals/semaphores/events/whatever, I promote the threads to full blown processes. For code that makes use of just a few threads the overhead is not that bad.\nE.g. this comes in handy to easily terminate helper &quot;threads&quot; which execute blocking I/O\nThe conversion is trivial: In related code replace all threading.Thread with multiprocessing.Process and all queue.Queue with multiprocessing.Queue and add the required calls of p.terminate() to your parent process which wants to kill its child p\nSee the Python documentation for multiprocessing.\nExample:\nimport multiprocessing\nproc = multiprocessing.Process(target=your_proc_function, args=())\nproc.start()\n# Terminate the process\nproc.terminate()  # sends a SIGTERM\n\n    ","url":"/questions/[slug]#solution2","@type":"Answer","upvoteCount":0},{"text":"There is no official API to do that, no.\n\nYou need to use platform API to kill the thread, e.g. pthread_kill, or TerminateThread. You can access such API e.g. through pythonwin, or through ctypes.\n\nNotice that this is inherently unsafe. It will likely lead to uncollectable garbage (from local variables of the stack frames that become garbage), and may lead to deadlocks, if the thread being killed has the GIL at the point when it is killed.\n    ","url":"/questions/[slug]#solution3","@type":"Answer","upvoteCount":0},{"text":"If you are trying to terminate the whole program you can set the thread as a &quot;daemon&quot;. see\nThread.daemon\n    ","url":"/questions/[slug]#solution4","@type":"Answer","upvoteCount":0},{"text":"As others have mentioned, the norm is to set a stop flag. For something lightweight (no subclassing of Thread, no global variable), a lambda callback is an option. (Note the parentheses in if stop().)\n\nimport threading\nimport time\n\ndef do_work(id, stop):\n    print(&quot;I am thread&quot;, id)\n    while True:\n        print(&quot;I am thread {} doing something&quot;.format(id))\n        if stop():\n            print(&quot;  Exiting loop.&quot;)\n            break\n    print(&quot;Thread {}, signing off&quot;.format(id))\n\n\ndef main():\n    stop_threads = False\n    workers = []\n    for id in range(0,3):\n        tmp = threading.Thread(target=do_work, args=(id, lambda: stop_threads))\n        workers.append(tmp)\n        tmp.start()\n    time.sleep(3)\n    print(&apos;main: done sleeping; time to stop the threads.&apos;)\n    stop_threads = True\n    for worker in workers:\n        worker.join()\n    print(&apos;Finis.&apos;)\n\nif __name__ == &apos;__main__&apos;:\n    main()\n\n\nReplacing print() with a pr() function that always flushes (sys.stdout.flush()) may improve the precision of the shell output.\n\n(Only tested on Windows/Eclipse/Python3.3)\n    ","url":"/questions/[slug]#solution5","@type":"Answer","upvoteCount":0},{"text":"In Python, you simply cannot kill a Thread directly.\n\nIf you do NOT really need to have a Thread (!), what you can do, instead of using the threading package , is to use the \nmultiprocessing package . Here, to kill a process, you can simply call the method:\n\nyourProcess.terminate()  # kill the process!\n\n\nPython will kill your process (on Unix through the SIGTERM signal, while on Windows through the TerminateProcess() call). Pay attention to use it while using a Queue or a Pipe! (it may corrupt the data in the Queue/Pipe)\n\nNote that the multiprocessing.Event and the multiprocessing.Semaphore work exactly in the same way of the threading.Event and the threading.Semaphore respectively. In fact, the first ones are clones of the latters.\n\nIf you REALLY need to use a Thread, there is no way to kill it directly. What you can do, however, is to use a &quot;daemon thread&quot;. In fact, in Python, a Thread can be flagged as daemon:\n\nyourThread.daemon = True  # set the Thread as a &quot;daemon thread&quot;\n\n\nThe main program will exit when no alive non-daemon threads are left. In other words, when your main thread (which is, of course, a non-daemon thread) will finish its operations, the program will exit even if there are still some daemon threads working.\n\nNote that it is necessary to set a Thread as daemon before the start() method is called!\n\nOf course you can, and should, use daemon even with multiprocessing. Here, when the main process exits, it attempts to terminate all of its daemonic child processes.\n\nFinally, please, note that sys.exit() and os.kill() are not choices.\n    ","url":"/questions/[slug]#solution6","@type":"Answer","upvoteCount":0},{"text":"This is based on the thread2 -- killable threads ActiveState recipe.\nYou need to call PyThreadState_SetAsyncExc(), which is only available through the ctypes module.\nThis has only been tested on Python 2.7.3, but it is likely to work with other recent 2.x releases. PyThreadState_SetAsyncExc() still exists in Python 3 for backwards compatibility (but I have not tested it).\nimport ctypes\n\ndef terminate_thread(thread):\n    &quot;&quot;&quot;Terminates a python thread from another thread.\n\n    :param thread: a threading.Thread instance\n    &quot;&quot;&quot;\n    if not thread.isAlive():\n        return\n\n    exc = ctypes.py_object(SystemExit)\n    res = ctypes.pythonapi.PyThreadState_SetAsyncExc(\n        ctypes.c_long(thread.ident), exc)\n    if res == 0:\n        raise ValueError(&quot;nonexistent thread id&quot;)\n    elif res &gt; 1:\n        # &quot;&quot;&quot;if it returns a number greater than one, you&apos;re in trouble,\n        # and you should call it again with exc=NULL to revert the effect&quot;&quot;&quot;\n        ctypes.pythonapi.PyThreadState_SetAsyncExc(thread.ident, None)\n        raise SystemError(&quot;PyThreadState_SetAsyncExc failed&quot;)\n\n    ","url":"/questions/[slug]#solution7","@type":"Answer","upvoteCount":0},{"text":"You should never forcibly kill a thread without cooperating with it.\n\nKilling a thread removes any guarantees that try/finally blocks set up so you might leave locks locked, files open, etc.\n\nThe only time you can argue that forcibly killing threads is a good idea is to kill a program fast, but never single threads.\n    ","url":"/questions/[slug]#solution8","@type":"Answer","upvoteCount":0},{"text":"If you are explicitly calling time.sleep() as part of your thread (say polling some external service), an improvement upon Phillipe&apos;s method is to use the timeout in the event&apos;s wait() method wherever you sleep()\n\nFor example:\n\nimport threading\n\nclass KillableThread(threading.Thread):\n    def __init__(self, sleep_interval=1):\n        super().__init__()\n        self._kill = threading.Event()\n        self._interval = sleep_interval\n\n    def run(self):\n        while True:\n            print(&quot;Do Something&quot;)\n\n            # If no kill signal is set, sleep for the interval,\n            # If kill signal comes in while sleeping, immediately\n            #  wake up and handle\n            is_killed = self._kill.wait(self._interval)\n            if is_killed:\n                break\n\n        print(&quot;Killing Thread&quot;)\n\n    def kill(self):\n        self._kill.set()\n\n\nThen to run it\n\nt = KillableThread(sleep_interval=5)\nt.start()\n# Every 5 seconds it prints:\n#: Do Something\nt.kill()\n#: Killing Thread\n\n\nThe advantage of using wait() instead of sleep()ing and regularly checking the event is that you can program in longer intervals of sleep, the thread is stopped almost immediately (when you would otherwise be sleep()ing) and in my opinion, the code for handling exit is significantly simpler.\n    ","url":"/questions/[slug]#solution9","@type":"Answer","upvoteCount":0},{"text":"You can kill a thread by installing trace into the thread that will exit the thread.   See attached link for one possible implementation.\n\nKill a thread in Python \n    ","url":"/questions/[slug]#solution10","@type":"Answer","upvoteCount":0},{"text":"It is better if you don&apos;t kill a thread.\nA way could be to introduce a &quot;try&quot; block into the thread&apos;s cycle and to throw an exception when you want to stop the thread (for example a break/return/... that stops your for/while/...). \nI&apos;ve used this on my app and it works...\n    ","url":"/questions/[slug]#solution11","@type":"Answer","upvoteCount":0},{"text":"It is definitely possible to implement a Thread.stop method as shown in the following example code:\n\nimport sys\nimport threading\nimport time\n\n\nclass StopThread(StopIteration):\n    pass\n\nthreading.SystemExit = SystemExit, StopThread\n\n\nclass Thread2(threading.Thread):\n\n    def stop(self):\n        self.__stop = True\n\n    def _bootstrap(self):\n        if threading._trace_hook is not None:\n            raise ValueError(&apos;Cannot run thread with tracing!&apos;)\n        self.__stop = False\n        sys.settrace(self.__trace)\n        super()._bootstrap()\n\n    def __trace(self, frame, event, arg):\n        if self.__stop:\n            raise StopThread()\n        return self.__trace\n\n\nclass Thread3(threading.Thread):\n\n    def _bootstrap(self, stop_thread=False):\n        def stop():\n            nonlocal stop_thread\n            stop_thread = True\n        self.stop = stop\n\n        def tracer(*_):\n            if stop_thread:\n                raise StopThread()\n            return tracer\n        sys.settrace(tracer)\n        super()._bootstrap()\n\n###############################################################################\n\n\ndef main():\n    test1 = Thread2(target=printer)\n    test1.start()\n    time.sleep(1)\n    test1.stop()\n    test1.join()\n    test2 = Thread2(target=speed_test)\n    test2.start()\n    time.sleep(1)\n    test2.stop()\n    test2.join()\n    test3 = Thread3(target=speed_test)\n    test3.start()\n    time.sleep(1)\n    test3.stop()\n    test3.join()\n\n\ndef printer():\n    while True:\n        print(time.time() % 1)\n        time.sleep(0.1)\n\n\ndef speed_test(count=0):\n    try:\n        while True:\n            count += 1\n    except StopThread:\n        print(&apos;Count =&apos;, count)\n\nif __name__ == &apos;__main__&apos;:\n    main()\n\n\nThe Thread3 class appears to run code approximately 33% faster than the Thread2 class.\n    ","url":"/questions/[slug]#solution12","@type":"Answer","upvoteCount":0},{"text":"I&apos;m way late to this game, but I&apos;ve been wrestling with a similar question and the following appears to both resolve the issue perfectly for me AND lets me do some basic thread state checking and cleanup when the daemonized sub-thread exits:\n\nimport threading\nimport time\nimport atexit\n\ndef do_work():\n\n  i = 0\n  @atexit.register\n  def goodbye():\n    print (&quot;&apos;CLEANLY&apos; kill sub-thread with value: %s [THREAD: %s]&quot; %\n           (i, threading.currentThread().ident))\n\n  while True:\n    print i\n    i += 1\n    time.sleep(1)\n\nt = threading.Thread(target=do_work)\nt.daemon = True\nt.start()\n\ndef after_timeout():\n  print &quot;KILL MAIN THREAD: %s&quot; % threading.currentThread().ident\n  raise SystemExit\n\nthreading.Timer(2, after_timeout).start()\n\n\nYields:\n\n0\n1\nKILL MAIN THREAD: 140013208254208\n&apos;CLEANLY&apos; kill sub-thread with value: 2 [THREAD: 140013674317568]\n\n    ","url":"/questions/[slug]#solution13","@type":"Answer","upvoteCount":0},{"text":"Following workaround can be used to kill a thread:\n\nkill_threads = False\n\ndef doSomething():\n    global kill_threads\n    while True:\n        if kill_threads:\n            thread.exit()\n        ......\n        ......\n\nthread.start_new_thread(doSomething, ())\n\n\nThis can be used even for terminating threads, whose code is written in another module, from main thread. We can declare a global variable in that module and use it to terminate thread/s spawned in that module.\n\nI usually use this to terminate all the threads at the program exit. This might not be the perfect way to terminate thread/s but could help.\n    ","url":"/questions/[slug]#solution14","@type":"Answer","upvoteCount":0},{"text":"from ctypes import *\npthread = cdll.LoadLibrary(&quot;libpthread-2.15.so&quot;)\npthread.pthread_cancel(c_ulong(t.ident))\n\n\nt is your Thread object.\n\nRead the python source (Modules/threadmodule.c and Python/thread_pthread.h) you can see the Thread.ident is an pthread_t type, so you can do anything pthread can do in python use libpthread.\n    ","url":"/questions/[slug]#solution15","@type":"Answer","upvoteCount":0},{"text":"Here&apos;s yet another way to do it, but with extremely clean and simple code, that works in Python 3.7 in 2021:\nimport ctypes \n\ndef kill_thread(thread):\n    &quot;&quot;&quot;\n    thread: a threading.Thread object\n    &quot;&quot;&quot;\n    thread_id = thread.ident\n    res = ctypes.pythonapi.PyThreadState_SetAsyncExc(thread_id, ctypes.py_object(SystemExit))\n    if res &gt; 1:\n        ctypes.pythonapi.PyThreadState_SetAsyncExc(thread_id, 0)\n        print(&apos;Exception raise failure&apos;)\n\nAdapted from here: https://www.geeksforgeeks.org/python-different-ways-to-kill-a-thread/\n    ","url":"/questions/[slug]#solution16","@type":"Answer","upvoteCount":0},{"text":"One thing I want to add is that if you read official documentation in threading lib Python, it&apos;s recommended to avoid use of &quot;demonic&quot; threads, when you don&apos;t want threads end abruptly, with the flag that Paolo Rovelli mentioned.\n\nFrom official documentation:\n\n\n  Daemon threads are abruptly stopped at shutdown. Their resources (such as open files, database transactions, etc.) may not be released properly. If you want your threads to stop gracefully, make them non-daemonic and use a suitable signaling mechanism such as an Event.\n\n\nI think that creating daemonic threads depends of your application, but in general (and in my opinion) it&apos;s better to avoid killing them or making them daemonic. In multiprocessing you can use is_alive() to check process status  and &quot;terminate&quot; for finish them (Also you avoid GIL problems). But you can find more problems, sometimes, when you execute your code in Windows.\n\nAnd always remember that if you have &quot;live threads&quot;, the Python interpreter will be running for wait them. (Because of this daemonic can help you if don&apos;t matter abruptly ends).\n    ","url":"/questions/[slug]#solution17","@type":"Answer","upvoteCount":0},{"text":"There is a library built for this purpose, stopit. Although some of the same cautions listed herein still apply, at least this library presents a regular, repeatable technique for achieving the stated goal.\n    ","url":"/questions/[slug]#solution18","@type":"Answer","upvoteCount":0},{"text":"Asuming, that you want to have multiple threads of the same function, this is IMHO the easiest implementation to stop one by id:\n\nimport time\nfrom threading import Thread\n\ndef doit(id=0):\n    doit.stop=0\n    print(&quot;start id:%d&quot;%id)\n    while 1:\n        time.sleep(1)\n        print(&quot;.&quot;)\n        if doit.stop==id:\n            doit.stop=0\n            break\n    print(&quot;end thread %d&quot;%id)\n\nt5=Thread(target=doit, args=(5,))\nt6=Thread(target=doit, args=(6,))\n\nt5.start() ; t6.start()\ntime.sleep(2)\ndoit.stop =5  #kill t5\ntime.sleep(2)\ndoit.stop =6  #kill t6\n\n\nThe nice thing is here, you can have multiple of same and different functions, and stop them all by functionname.stop\n\nIf you want to have only one thread of the function then you don&apos;t need to remember the id. Just stop, if doit.stop &gt; 0.\n    ","url":"/questions/[slug]#solution19","@type":"Answer","upvoteCount":0},{"text":"Just to build up on @SCB&apos;s idea (which was exactly what I needed) to create a KillableThread  subclass with a customized function:\nfrom threading import Thread, Event\n\nclass KillableThread(Thread):\n    def __init__(self, sleep_interval=1, target=None, name=None, args=(), kwargs={}):\n        super().__init__(None, target, name, args, kwargs)\n        self._kill = Event()\n        self._interval = sleep_interval\n        print(self._target)\n\n    def run(self):\n        while True:\n            # Call custom function with arguments\n            self._target(*self._args)\n\n            # If no kill signal is set, sleep for the interval,\n            # If kill signal comes in while sleeping, immediately\n            #  wake up and handle\n            is_killed = self._kill.wait(self._interval)\n            if is_killed:\n                break\n\n        print(&quot;Killing Thread&quot;)\n\n    def kill(self):\n        self._kill.set()\n\nif __name__ == &apos;__main__&apos;:\n\n    def print_msg(msg):\n        print(msg)\n\n    t = KillableThread(10, print_msg, args=(&quot;hello world&quot;))\n    t.start()\n    time.sleep(6)\n    print(&quot;About to kill thread&quot;)\n    t.kill()\n\nNaturally, like with @SBC, the thread doesn&apos;t wait to run a new loop to stop. In this example, you would see the &quot;Killing Thread&quot; message printed right after the &quot;About to kill thread&quot; instead of waiting for 4 more seconds for the thread to complete (since we have slept for 6 seconds already).\nSecond argument in KillableThread constructor is your custom function (print_msg here). Args argument are the arguments that will be used when calling the function ((&quot;hello world&quot;)) here.\n    ","url":"/questions/[slug]#solution20","@type":"Answer","upvoteCount":0},{"text":"While it&apos;s rather old, this might be a handy solution for some:  \n\n\n  A little module that extends the threading&apos;s module functionality --\n  allows one thread to raise exceptions in the context of another\n  thread. By raising SystemExit, you can finally kill python threads.\n\n\nimport threading\nimport ctypes     \n\ndef _async_raise(tid, excobj):\n    res = ctypes.pythonapi.PyThreadState_SetAsyncExc(tid, ctypes.py_object(excobj))\n    if res == 0:\n        raise ValueError(&quot;nonexistent thread id&quot;)\n    elif res &gt; 1:\n        # &quot;&quot;&quot;if it returns a number greater than one, you&apos;re in trouble, \n        # and you should call it again with exc=NULL to revert the effect&quot;&quot;&quot;\n        ctypes.pythonapi.PyThreadState_SetAsyncExc(tid, 0)\n        raise SystemError(&quot;PyThreadState_SetAsyncExc failed&quot;)\n\nclass Thread(threading.Thread):\n    def raise_exc(self, excobj):\n        assert self.isAlive(), &quot;thread must be started&quot;\n        for tid, tobj in threading._active.items():\n            if tobj is self:\n                _async_raise(tid, excobj)\n                return\n\n        # the thread was alive when we entered the loop, but was not found \n        # in the dict, hence it must have been already terminated. should we raise\n        # an exception here? silently ignore?\n\n    def terminate(self):\n        # must raise the SystemExit type, instead of a SystemExit() instance\n        # due to a bug in PyThreadState_SetAsyncExc\n        self.raise_exc(SystemExit)\n\n\nSo, it allows a &quot;thread to raise exceptions in the context of another thread&quot; and in this way, the terminated thread can handle the termination without regularly checking an abort flag.\n\nHowever, according to its original source, there are some issues with this code.\n\n\n  \n  The exception will be raised only when executing python bytecode. If    your thread calls a native/built-in blocking function, the\n  exception    will be raised only when execution returns to the python\n  code. \n  \n  \n  There is also an issue if the built-in function internally calls    PyErr_Clear(), which would effectively cancel your pending exception. \n  You can try to raise it again.\n  \n  Only exception types can be raised    safely. Exception instances are likely to cause unexpected behavior,    and are thus restricted.\n  \n  \n  For example: t1.raise_exc(TypeError) and    not t1.raise_exc(TypeError(&quot;blah&quot;)).\n  IMHO it&apos;s a bug, and I reported it as one. For more info,    http://mail.python.org/pipermail/python-dev/2006-August/068158.html  \n  \n  I asked to expose this function in the built-in thread module, but    since ctypes has become a standard library (as of 2.5), and this\n  feature is not likely to be implementation-agnostic, it may be kept\n  unexposed.\n  \n\n    ","url":"/questions/[slug]#solution21","@type":"Answer","upvoteCount":0},{"text":"As mentioned in @Kozyarchuk&apos;s answer, installing trace works. Since this answer contained no code, here is a working ready-to-use example:\n\nimport sys, threading, time \n\nclass TraceThread(threading.Thread): \n    def __init__(self, *args, **keywords): \n        threading.Thread.__init__(self, *args, **keywords) \n        self.killed = False\n    def start(self): \n        self._run = self.run \n        self.run = self.settrace_and_run\n        threading.Thread.start(self) \n    def settrace_and_run(self): \n        sys.settrace(self.globaltrace) \n        self._run()\n    def globaltrace(self, frame, event, arg): \n        return self.localtrace if event == &apos;call&apos; else None\n    def localtrace(self, frame, event, arg): \n        if self.killed and event == &apos;line&apos;: \n            raise SystemExit() \n        return self.localtrace \n\ndef f(): \n    while True: \n        print(&apos;1&apos;) \n        time.sleep(2)\n        print(&apos;2&apos;) \n        time.sleep(2)\n        print(&apos;3&apos;) \n        time.sleep(2)\n\nt = TraceThread(target=f) \nt.start() \ntime.sleep(2.5) \nt.killed = True\n\n\nIt stops after having printed 1 and 2. 3 is not printed.\n    ","url":"/questions/[slug]#solution22","@type":"Answer","upvoteCount":0},{"text":"Python version: 3.8\nUsing daemon thread to execute what we wanted, if we want to daemon thread be terminated, all we need is making parent thread exit, then system will terminate daemon thread which parent thread created.\nAlso support coroutine and coroutine function.\ndef main():\n    start_time = time.perf_counter()\n    t1 = ExitThread(time.sleep, (10,), debug=False)\n    t1.start()\n    time.sleep(0.5)\n    t1.exit()\n    try:\n        print(t1.result_future.result())\n    except concurrent.futures.CancelledError:\n        pass\n    end_time = time.perf_counter()\n    print(f&quot;time cost {end_time - start_time:0.2f}&quot;)\n\nbelow is ExitThread source code\nimport concurrent.futures\nimport threading\nimport typing\nimport asyncio\n\n\nclass _WorkItem(object):\n    &quot;&quot;&quot; concurrent\\futures\\thread.py\n\n    &quot;&quot;&quot;\n\n    def __init__(self, future, fn, args, kwargs, *, debug=None):\n        self._debug = debug\n        self.future = future\n        self.fn = fn\n        self.args = args\n        self.kwargs = kwargs\n\n    def run(self):\n        if self._debug:\n            print(&quot;ExitThread._WorkItem run&quot;)\n        if not self.future.set_running_or_notify_cancel():\n            return\n\n        try:\n            coroutine = None\n            if asyncio.iscoroutinefunction(self.fn):\n                coroutine = self.fn(*self.args, **self.kwargs)\n            elif asyncio.iscoroutine(self.fn):\n                coroutine = self.fn\n            if coroutine is None:\n                result = self.fn(*self.args, **self.kwargs)\n            else:\n                result = asyncio.run(coroutine)\n            if self._debug:\n                print(&quot;_WorkItem done&quot;)\n        except BaseException as exc:\n            self.future.set_exception(exc)\n            # Break a reference cycle with the exception &apos;exc&apos;\n            self = None\n        else:\n            self.future.set_result(result)\n\n\nclass ExitThread:\n    &quot;&quot;&quot; Like a stoppable thread\n\n    Using coroutine for target then exit before running may cause RuntimeWarning.\n\n    &quot;&quot;&quot;\n\n    def __init__(self, target: typing.Union[typing.Coroutine, typing.Callable] = None\n                 , args=(), kwargs={}, *, daemon=None, debug=None):\n        #\n        self._debug = debug\n        self._parent_thread = threading.Thread(target=self._parent_thread_run, name=&quot;ExitThread_parent_thread&quot;\n                                               , daemon=daemon)\n        self._child_daemon_thread = None\n        self.result_future = concurrent.futures.Future()\n        self._workItem = _WorkItem(self.result_future, target, args, kwargs, debug=debug)\n        self._parent_thread_exit_lock = threading.Lock()\n        self._parent_thread_exit_lock.acquire()\n        self._parent_thread_exit_lock_released = False  # When done it will be True\n        self._started = False\n        self._exited = False\n        self.result_future.add_done_callback(self._release_parent_thread_exit_lock)\n\n    def _parent_thread_run(self):\n        self._child_daemon_thread = threading.Thread(target=self._child_daemon_thread_run\n                                                     , name=&quot;ExitThread_child_daemon_thread&quot;\n                                                     , daemon=True)\n        self._child_daemon_thread.start()\n        # Block manager thread\n        self._parent_thread_exit_lock.acquire()\n        self._parent_thread_exit_lock.release()\n        if self._debug:\n            print(&quot;ExitThread._parent_thread_run exit&quot;)\n\n    def _release_parent_thread_exit_lock(self, _future):\n        if self._debug:\n            print(f&quot;ExitThread._release_parent_thread_exit_lock {self._parent_thread_exit_lock_released} {_future}&quot;)\n        if not self._parent_thread_exit_lock_released:\n            self._parent_thread_exit_lock_released = True\n            self._parent_thread_exit_lock.release()\n\n    def _child_daemon_thread_run(self):\n        self._workItem.run()\n\n    def start(self):\n        if self._debug:\n            print(f&quot;ExitThread.start {self._started}&quot;)\n        if not self._started:\n            self._started = True\n            self._parent_thread.start()\n\n    def exit(self):\n        if self._debug:\n            print(f&quot;ExitThread.exit exited: {self._exited} lock_released: {self._parent_thread_exit_lock_released}&quot;)\n        if self._parent_thread_exit_lock_released:\n            return\n        if not self._exited:\n            self._exited = True\n            if not self.result_future.cancel():\n                if self.result_future.running():\n                    self.result_future.set_exception(concurrent.futures.CancelledError())\n\n    ","url":"/questions/[slug]#solution23","@type":"Answer","upvoteCount":0},{"text":"This seems to work with pywin32 on windows 7\n\nmy_thread = threading.Thread()\nmy_thread.start()\nmy_thread._Thread__stop()\n\n    ","url":"/questions/[slug]#solution24","@type":"Answer","upvoteCount":0},{"text":"Pieter Hintjens -- one of the founders of the ØMQ-project -- says, using ØMQ and avoiding synchronization primitives like locks, mutexes, events etc., is the sanest and securest way to write multi-threaded programs:\n\nhttp://zguide.zeromq.org/py:all#Multithreading-with-ZeroMQ\n\nThis includes telling a child thread, that it should cancel its work. This would be done by equipping the thread with a ØMQ-socket and polling on that socket for a message saying that it should cancel.\n\nThe link also provides an example on multi-threaded python code with ØMQ.\n    ","url":"/questions/[slug]#solution25","@type":"Answer","upvoteCount":0},{"text":"An alternative is to use signal.pthread_kill to send a stop signal.\nfrom signal import pthread_kill, SIGTSTP\nfrom threading import Thread\nfrom itertools import count\nfrom time import sleep\n\ndef target():\n    for num in count():\n        print(num)\n        sleep(1)\n\nthread = Thread(target=target)\nthread.start()\nsleep(5)\npthread_kill(thread.ident, SIGTSTP)\n\nresult\n0\n1\n2\n3\n4\n\n[14]+  Stopped\n\n    ","url":"/questions/[slug]#solution26","@type":"Answer","upvoteCount":0},{"text":"If you really need the ability to kill a sub-task, use an alternate implementation. multiprocessing and gevent both support indiscriminately killing a &quot;thread&quot;.\n\nPython&apos;s threading does not support cancellation. Do not even try. Your code is very likely to deadlock, corrupt or leak memory, or have other unintended &quot;interesting&quot; hard-to-debug effects which happen rarely and nondeterministically.\n    ","url":"/questions/[slug]#solution27","@type":"Answer","upvoteCount":0},{"text":"You can execute your command in a process and then kill it using the process id.\nI needed to sync between two thread one of which  doesnt return by itself.\n\nprocessIds = []\n\ndef executeRecord(command):\n    print(command)\n\n    process = subprocess.Popen(command, stdout=subprocess.PIPE)\n    processIds.append(process.pid)\n    print(processIds[0])\n\n    #Command that doesn&apos;t return by itself\n    process.stdout.read().decode(&quot;utf-8&quot;)\n    return;\n\n\ndef recordThread(command, timeOut):\n\n    thread = Thread(target=executeRecord, args=(command,))\n    thread.start()\n    thread.join(timeOut)\n\n    os.kill(processIds.pop(), signal.SIGINT)\n\n    return;\n\n    ","url":"/questions/[slug]#solution28","@type":"Answer","upvoteCount":0},{"text":"The most simple way is this:\nfrom threading import Thread\nfrom time import sleep\n\ndef do_something():\n    global thread_work\n    while thread_work:\n        print(&apos;doing something&apos;)\n        sleep(5)\n    print(&apos;Thread stopped&apos;)\n\nthread_work = True\nThread(target=do_something).start()\nsleep(5)\nthread_work = False\n\n    ","url":"/questions/[slug]#solution29","@type":"Answer","upvoteCount":0},{"text":"\n  This is a bad answer, see the comments\n\n\nHere&apos;s how to do it:\n\nfrom threading import *\n\n...\n\nfor thread in enumerate():\n    if thread.isAlive():\n        try:\n            thread._Thread__stop()\n        except:\n            print(str(thread.getName()) + &apos; could not be terminated&apos;))\n\n\nGive it a few seconds then your thread should be stopped. Check also the thread._Thread__delete() method.\n\nI&apos;d recommend a thread.quit() method for convenience. For example if you have a socket in your thread, I&apos;d recommend creating a quit() method in your socket-handle class, terminate the socket, then run a thread._Thread__stop() inside of your quit().\n    ","url":"/questions/[slug]#solution30","@type":"Answer","upvoteCount":0}],"@type":"Question"}}</script><meta name="next-head-count" content="22"/><link rel="preload" href="/_next/static/css/c116652e2d6f4ad0.css" as="style"/><link rel="stylesheet" href="/_next/static/css/c116652e2d6f4ad0.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-0d1b80a048d4787e.js"></script><script src="/_next/static/chunks/webpack-42cdea76c8170223.js" defer=""></script><script src="/_next/static/chunks/framework-4556c45dd113b893.js" defer=""></script><script src="/_next/static/chunks/main-ccfab947c79712f4.js" defer=""></script><script src="/_next/static/chunks/pages/_app-c0d2dcb5e85faf18.js" defer=""></script><script src="/_next/static/chunks/294-106ef8570fa99deb.js" defer=""></script><script src="/_next/static/chunks/490-7f0418bb4354ac73.js" defer=""></script><script src="/_next/static/chunks/pages/questions/%5Bslug%5D-50e201fdaa1e0fd1.js" defer=""></script><script src="/_next/static/DSpI0pSdXueTMCIVyw0q4/_buildManifest.js" defer=""></script><script src="/_next/static/DSpI0pSdXueTMCIVyw0q4/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="wrapper"><header><nav class="bg-white border-gray-200 px-4 lg:px-6 py-2.5 dark:bg-gray-800"><div class="flex flex-wrap justify-between items-center mx-auto max-w-screen-xl"><a class="flex items-center" href="/"><img src="/logo-second.png" class="mr-3 h-6 sm:h-9" alt="Solution Checker Logo"/><h1 class="self-center text-xl font-semibold whitespace-nowrap dark:text-white">Solution Checker</h1></a><div class="flex items-center lg:order-2"><button data-collapse-toggle="mobile-menu-2" type="button" class="inline-flex items-center p-2 ml-1 text-sm text-gray-500 rounded-lg lg:hidden hover:bg-gray-100 focus:outline-none focus:ring-2 focus:ring-gray-200 dark:text-gray-400 dark:hover:bg-gray-700 dark:focus:ring-gray-600" aria-controls="mobile-menu-2" aria-expanded="false"><span class="sr-only">Open main menu</span><svg class="w-6 h-6" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M3 5a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM3 10a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM3 15a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1z" clip-rule="evenodd"></path></svg><svg class="hidden w-6 h-6" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z" clip-rule="evenodd"></path></svg></button></div><div class="hidden justify-between items-center w-full lg:flex lg:w-auto lg:order-1" id="mobile-menu-2"><ul class="flex flex-col mt-4 font-medium lg:flex-row lg:space-x-8 lg:mt-0"><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" aria-current="page" href="/">Home</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/questions?tab=news">Questions</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/post?tab=news">Post</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/questions/is-there-any-way-to-kill-a-thread-1657387859831#">Coding</a></li></ul></div></div></nav></header><div class="main-content"><div class="question my-5"><div class="flex question-header items-center m-auto justify-center"><div class="rounded-xl w-full border p-5 shadow-md bg-white"><div class="flex w-full items-center justify-between border-b pb-3"><div class="flex items-center space-x-3"><div class="text-lg font-bold text-slate-700"><a href="/questions/is-there-any-way-to-kill-a-thread-1657387859831"><h1>Is there any way to kill a Thread?</h1></a></div></div><div class="flex flex-wrap h-auto justify-end items-center space-x-8"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold" href="/questions/tag/kill">kill</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold" href="/questions/tag/terminate">terminate</a></div></div><div class="question-content mt-5">
                
<p>Is it possible to terminate a running thread without setting/checking any flags/semaphores/etc.?</p>
    </div></div></div><div class="solution-section"><nav class="flex pagination-solution flex-col justify-end"><h1 class="text-lg font-semibold mb-5">Navigate to solutions: </h1><ul class="inline-flex -space-x-px overflow-auto"><li class="pagination-solution-item"><span data-id="#solution1" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">1</span></li><li class="pagination-solution-item"><span data-id="#solution2" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">2</span></li><li class="pagination-solution-item"><span data-id="#solution3" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">3</span></li><li class="pagination-solution-item"><span data-id="#solution4" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">4</span></li><li class="pagination-solution-item"><span data-id="#solution5" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">5</span></li><li class="pagination-solution-item"><span data-id="#solution6" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">6</span></li><li class="pagination-solution-item"><span data-id="#solution7" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">7</span></li><li class="pagination-solution-item"><span data-id="#solution8" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">8</span></li><li class="pagination-solution-item"><span data-id="#solution9" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">9</span></li><li class="pagination-solution-item"><span data-id="#solution10" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">10</span></li><li class="pagination-solution-item"><span data-id="#solution11" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">11</span></li><li class="pagination-solution-item"><span data-id="#solution12" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">12</span></li><li class="pagination-solution-item"><span data-id="#solution13" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">13</span></li><li class="pagination-solution-item"><span data-id="#solution14" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">14</span></li><li class="pagination-solution-item"><span data-id="#solution15" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">15</span></li><li class="pagination-solution-item"><span data-id="#solution16" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">16</span></li><li class="pagination-solution-item"><span data-id="#solution17" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">17</span></li><li class="pagination-solution-item"><span data-id="#solution18" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">18</span></li><li class="pagination-solution-item"><span data-id="#solution19" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">19</span></li><li class="pagination-solution-item"><span data-id="#solution20" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">20</span></li><li class="pagination-solution-item"><span data-id="#solution21" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">21</span></li><li class="pagination-solution-item"><span data-id="#solution22" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">22</span></li><li class="pagination-solution-item"><span data-id="#solution23" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">23</span></li><li class="pagination-solution-item"><span data-id="#solution24" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">24</span></li><li class="pagination-solution-item"><span data-id="#solution25" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">25</span></li><li class="pagination-solution-item"><span data-id="#solution26" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">26</span></li><li class="pagination-solution-item"><span data-id="#solution27" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">27</span></li><li class="pagination-solution-item"><span data-id="#solution28" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">28</span></li><li class="pagination-solution-item"><span data-id="#solution29" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">29</span></li><li class="pagination-solution-item"><span data-id="#solution30" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">30</span></li></ul></nav><div id="solution1" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 1</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/kill">kill</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/terminate">terminate</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>It is generally a bad pattern to kill a thread abruptly, in Python, and in any language. Think of the following cases:</p>
<ul>
<li>the thread is holding a critical resource that must be closed properly</li>
<li>the thread has created several other threads that must be killed as well.</li>
</ul>
<p>The nice way of handling this, if you can afford it (if you are managing your own threads), is to have an exit_request flag that each thread checks on a regular interval to see if it is time for it to exit.</p>
<p><strong>For example:</strong></p>
<pre class="lang-py s-code-block"><code class="hljs language-python"><span class="hljs-keyword">import</span> threading

<span class="hljs-keyword">class</span> <span class="hljs-title class_">StoppableThread</span>(threading.Thread):
    <span class="hljs-string">"""Thread class with a stop() method. The thread itself has to check
    regularly for the stopped() condition."""</span>

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self,  *args, **kwargs</span>):
        <span class="hljs-built_in">super</span>(StoppableThread, self).__init__(*args, **kwargs)
        self._stop_event = threading.Event()

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">stop</span>(<span class="hljs-params">self</span>):
        self._stop_event.<span class="hljs-built_in">set</span>()

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">stopped</span>(<span class="hljs-params">self</span>):
        <span class="hljs-keyword">return</span> self._stop_event.is_set()
</code></pre>
<p>In this code, you should call <code>stop()</code> on the thread when you want it to exit, and wait for the thread to exit properly using <code>join()</code>. The thread should check the stop flag at regular intervals.</p>
<p>There are cases, however, when you really need to kill a thread. An example is when you are wrapping an external library that is busy for long calls, and you want to interrupt it.</p>
<p>The following code allows (with some restrictions) to raise an Exception in a Python thread:</p>
<pre class="lang-py s-code-block"><code class="hljs language-python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">_async_raise</span>(<span class="hljs-params">tid, exctype</span>):
    <span class="hljs-string">'''Raises an exception in the threads with id tid'''</span>
    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> inspect.isclass(exctype):
        <span class="hljs-keyword">raise</span> TypeError(<span class="hljs-string">"Only types can be raised (not instances)"</span>)
    res = ctypes.pythonapi.PyThreadState_SetAsyncExc(ctypes.c_long(tid),
                                                     ctypes.py_object(exctype))
    <span class="hljs-keyword">if</span> res == <span class="hljs-number">0</span>:
        <span class="hljs-keyword">raise</span> ValueError(<span class="hljs-string">"invalid thread id"</span>)
    <span class="hljs-keyword">elif</span> res != <span class="hljs-number">1</span>:
        <span class="hljs-comment"># "if it returns a number greater than one, you're in trouble,</span>
        <span class="hljs-comment"># and you should call it again with exc=NULL to revert the effect"</span>
        ctypes.pythonapi.PyThreadState_SetAsyncExc(ctypes.c_long(tid), <span class="hljs-literal">None</span>)
        <span class="hljs-keyword">raise</span> SystemError(<span class="hljs-string">"PyThreadState_SetAsyncExc failed"</span>)

<span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadWithExc</span>(threading.Thread):
    <span class="hljs-string">'''A thread class that supports raising an exception in the thread from
       another thread.
    '''</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_get_my_tid</span>(<span class="hljs-params">self</span>):
        <span class="hljs-string">"""determines this (self's) thread id

        CAREFUL: this function is executed in the context of the caller
        thread, to get the identity of the thread represented by this
        instance.
        """</span>
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> self.isAlive():
            <span class="hljs-keyword">raise</span> threading.ThreadError(<span class="hljs-string">"the thread is not active"</span>)

        <span class="hljs-comment"># do we have it cached?</span>
        <span class="hljs-keyword">if</span> <span class="hljs-built_in">hasattr</span>(self, <span class="hljs-string">"_thread_id"</span>):
            <span class="hljs-keyword">return</span> self._thread_id

        <span class="hljs-comment"># no, look for it in the _active dict</span>
        <span class="hljs-keyword">for</span> tid, tobj <span class="hljs-keyword">in</span> threading._active.items():
            <span class="hljs-keyword">if</span> tobj <span class="hljs-keyword">is</span> self:
                self._thread_id = tid
                <span class="hljs-keyword">return</span> tid

        <span class="hljs-comment"># <span class="hljs-doctag">TODO:</span> in python 2.6, there's a simpler way to do: self.ident</span>

        <span class="hljs-keyword">raise</span> AssertionError(<span class="hljs-string">"could not determine the thread's id"</span>)

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">raiseExc</span>(<span class="hljs-params">self, exctype</span>):
        <span class="hljs-string">"""Raises the given exception type in the context of this thread.

        If the thread is busy in a system call (time.sleep(),
        socket.accept(), ...), the exception is simply ignored.

        If you are sure that your exception should terminate the thread,
        one way to ensure that it works is:

            t = ThreadWithExc( ... )
            ...
            t.raiseExc( SomeException )
            while t.isAlive():
                time.sleep( 0.1 )
                t.raiseExc( SomeException )

        If the exception is to be caught by the thread, you need a way to
        check that your thread has caught it.

        CAREFUL: this function is executed in the context of the
        caller thread, to raise an exception in the context of the
        thread represented by this instance.
        """</span>
        _async_raise( self._get_my_tid(), exctype )
</code></pre>
<p>(Based on <a href="http://tomerfiliba.com/recipes/Thread2/" rel="noreferrer">Killable Threads</a> by Tomer Filiba. The quote about the return value of <code>PyThreadState_SetAsyncExc</code> appears to be from an <a href="https://svn.python.org/projects/stackless/Python-2.4.3/dev/Python/pystate.c" rel="noreferrer">old version of Python</a>.)</p>
<p>As noted in the documentation, this is not a magic bullet because if the thread is busy outside the Python interpreter, it will not catch the interruption.</p>
<p>A good usage pattern of this code is to have the thread catch a specific exception and perform the cleanup. That way, you can interrupt a task and still have proper cleanup.</p>
    </div></div></div></div><div id="solution2" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 2</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/kill">kill</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/terminate">terminate</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>A <a href="https://docs.python.org/library/multiprocessing.html#multiprocessing.Process" rel="noreferrer"><code>multiprocessing.Process</code></a> can <a href="https://docs.python.org/library/multiprocessing.html#multiprocessing.Process.terminate" rel="noreferrer"><code>p.terminate()</code></a></p>
<p>In the cases where I want to kill a thread, but do not want to use flags/locks/signals/semaphores/events/whatever, I promote the threads to full blown processes. For code that makes use of just a few threads the overhead is not that bad.</p>
<p>E.g. this comes in handy to easily terminate helper "threads" which execute blocking I/O</p>
<p>The conversion is trivial: In related code replace all <code>threading.Thread</code> with <code>multiprocessing.Process</code> and all <code>queue.Queue</code> with <code>multiprocessing.Queue</code> and add the required calls of <code>p.terminate()</code> to your parent process which wants to kill its child <code>p</code></p>
<p>See the <a href="https://docs.python.org/library/multiprocessing.html" rel="noreferrer">Python documentation for <code>multiprocessing</code></a>.</p>
<p>Example:</p>
<pre class="lang-py s-code-block"><code class="hljs language-python"><span class="hljs-keyword">import</span> multiprocessing
proc = multiprocessing.Process(target=your_proc_function, args=())
proc.start()
<span class="hljs-comment"># Terminate the process</span>
proc.terminate()  <span class="hljs-comment"># sends a SIGTERM</span>
</code></pre>
    </div></div></div></div><div id="solution3" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 3</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/kill">kill</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/terminate">terminate</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>There is no official API to do that, no.</p>

<p>You need to use platform API to kill the thread, e.g. pthread_kill, or TerminateThread. You can access such API e.g. through pythonwin, or through ctypes.</p>

<p>Notice that this is inherently unsafe. It will likely lead to uncollectable garbage (from local variables of the stack frames that become garbage), and may lead to deadlocks, if the thread being killed has the GIL at the point when it is killed.</p>
    </div></div></div></div><div id="solution4" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 4</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/kill">kill</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/terminate">terminate</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>If you are trying to terminate the whole program you can set the thread as a "daemon". see
<a href="http://docs.python.org/library/threading.html#threading.Thread.daemon" rel="noreferrer">Thread.daemon</a></p>
    </div></div></div></div><div id="solution5" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 5</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/kill">kill</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/terminate">terminate</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>As others have mentioned, the norm is to set a stop flag. For something lightweight (no subclassing of Thread, no global variable), a lambda callback is an option. (Note the parentheses in <code>if stop()</code>.)</p>

<pre class="lang-py s-code-block"><code class="hljs language-python"><span class="hljs-keyword">import</span> threading
<span class="hljs-keyword">import</span> time

<span class="hljs-keyword">def</span> <span class="hljs-title function_">do_work</span>(<span class="hljs-params"><span class="hljs-built_in">id</span>, stop</span>):
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"I am thread"</span>, <span class="hljs-built_in">id</span>)
    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:
        <span class="hljs-built_in">print</span>(<span class="hljs-string">"I am thread {} doing something"</span>.<span class="hljs-built_in">format</span>(<span class="hljs-built_in">id</span>))
        <span class="hljs-keyword">if</span> stop():
            <span class="hljs-built_in">print</span>(<span class="hljs-string">"  Exiting loop."</span>)
            <span class="hljs-keyword">break</span>
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"Thread {}, signing off"</span>.<span class="hljs-built_in">format</span>(<span class="hljs-built_in">id</span>))


<span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>():
    stop_threads = <span class="hljs-literal">False</span>
    workers = []
    <span class="hljs-keyword">for</span> <span class="hljs-built_in">id</span> <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>,<span class="hljs-number">3</span>):
        tmp = threading.Thread(target=do_work, args=(<span class="hljs-built_in">id</span>, <span class="hljs-keyword">lambda</span>: stop_threads))
        workers.append(tmp)
        tmp.start()
    time.sleep(<span class="hljs-number">3</span>)
    <span class="hljs-built_in">print</span>(<span class="hljs-string">'main: done sleeping; time to stop the threads.'</span>)
    stop_threads = <span class="hljs-literal">True</span>
    <span class="hljs-keyword">for</span> worker <span class="hljs-keyword">in</span> workers:
        worker.join()
    <span class="hljs-built_in">print</span>(<span class="hljs-string">'Finis.'</span>)

<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:
    main()
</code></pre>

<p>Replacing <code>print()</code> with a <code>pr()</code> function that always flushes (<code>sys.stdout.flush()</code>) may improve the precision of the shell output.</p>

<p>(Only tested on Windows/Eclipse/Python3.3)</p>
    </div></div></div></div><div id="solution6" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 6</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/kill">kill</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/terminate">terminate</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>In Python, you simply cannot kill a Thread directly.</p>

<p>If you do NOT really need to have a Thread (!), what you can do, instead of using the <a href="http://docs.python.org/2/library/threading.html" rel="noreferrer"><em>threading</em> package </a>, is to use the 
<a href="http://docs.python.org/2/library/multiprocessing.html" rel="noreferrer"><em>multiprocessing</em> package </a>. Here, to kill a process, you can simply call the method:</p>

<pre class="lang-py s-code-block"><code class="hljs language-python">yourProcess.terminate()  <span class="hljs-comment"># kill the process!</span>
</code></pre>

<p>Python will kill your process (on Unix through the SIGTERM signal, while on Windows through the <code>TerminateProcess()</code> call). Pay attention to use it while using a Queue or a Pipe! (it may corrupt the data in the Queue/Pipe)</p>

<p>Note that the <code>multiprocessing.Event</code> and the <code>multiprocessing.Semaphore</code> work exactly in the same way of the <code>threading.Event</code> and the <code>threading.Semaphore</code> respectively. In fact, the first ones are clones of the latters.</p>

<p>If you REALLY need to use a Thread, there is no way to kill it directly. What you can do, however, is to use a <em>"daemon thread"</em>. In fact, in Python, a Thread can be flagged as <em>daemon</em>:</p>

<pre class="lang-py s-code-block"><code class="hljs language-python">yourThread.daemon = <span class="hljs-literal">True</span>  <span class="hljs-comment"># set the Thread as a "daemon thread"</span>
</code></pre>

<p>The main program will exit when no alive non-daemon threads are left. In other words, when your main thread (which is, of course, a non-daemon thread) will finish its operations, the program will exit even if there are still some daemon threads working.</p>

<p>Note that it is necessary to set a Thread as <code>daemon</code> before the <code>start()</code> method is called!</p>

<p>Of course you can, and should, use <code>daemon</code> even with <code>multiprocessing</code>. Here, when the main process exits, it attempts to terminate all of its daemonic child processes.</p>

<p>Finally, please, note that <code>sys.exit()</code> and <code>os.kill()</code> are not choices.</p>
    </div></div></div></div><div id="solution7" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 7</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/kill">kill</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/terminate">terminate</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>This is based on the <a href="https://web.archive.org/web/20100514180958id_/http://code.activestate.com:80/recipes/496960-thread2-killable-threads/?in=lang-python" rel="nofollow noreferrer">thread2 -- killable threads</a> ActiveState recipe.</p>
<p>You need to call <a href="https://docs.python.org/3/c-api/init.html#c.PyThreadState_SetAsyncExc" rel="nofollow noreferrer"><code>PyThreadState_SetAsyncExc()</code></a>, which is only available through the <a href="https://docs.python.org/3/library/ctypes.html#module-ctypes" rel="nofollow noreferrer"><code>ctypes</code></a> module.</p>
<p>This has only been tested on Python 2.7.3, but it is likely to work with other recent 2.x releases. <code>PyThreadState_SetAsyncExc()</code> still exists in Python 3 for backwards compatibility (but I have not tested it).</p>
<pre class="lang-py s-code-block"><code class="hljs language-python"><span class="hljs-keyword">import</span> ctypes

<span class="hljs-keyword">def</span> <span class="hljs-title function_">terminate_thread</span>(<span class="hljs-params">thread</span>):
    <span class="hljs-string">"""Terminates a python thread from another thread.

    :param thread: a threading.Thread instance
    """</span>
    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> thread.isAlive():
        <span class="hljs-keyword">return</span>

    exc = ctypes.py_object(SystemExit)
    res = ctypes.pythonapi.PyThreadState_SetAsyncExc(
        ctypes.c_long(thread.ident), exc)
    <span class="hljs-keyword">if</span> res == <span class="hljs-number">0</span>:
        <span class="hljs-keyword">raise</span> ValueError(<span class="hljs-string">"nonexistent thread id"</span>)
    <span class="hljs-keyword">elif</span> res &gt; <span class="hljs-number">1</span>:
        <span class="hljs-comment"># """if it returns a number greater than one, you're in trouble,</span>
        <span class="hljs-comment"># and you should call it again with exc=NULL to revert the effect"""</span>
        ctypes.pythonapi.PyThreadState_SetAsyncExc(thread.ident, <span class="hljs-literal">None</span>)
        <span class="hljs-keyword">raise</span> SystemError(<span class="hljs-string">"PyThreadState_SetAsyncExc failed"</span>)
</code></pre>
    </div></div></div></div><div id="solution8" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 8</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/kill">kill</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/terminate">terminate</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>You should never forcibly kill a thread without cooperating with it.</p>

<p>Killing a thread removes any guarantees that try/finally blocks set up so you might leave locks locked, files open, etc.</p>

<p>The only time you can argue that forcibly killing threads is a good idea is to kill a program fast, but never single threads.</p>
    </div></div></div></div><div id="solution9" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 9</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/kill">kill</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/terminate">terminate</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>If you are explicitly calling <code>time.sleep()</code> as part of your thread (say polling some external service), an improvement upon Phillipe's method is to use the timeout in the <code>event</code>'s <code>wait()</code> method wherever you <code>sleep()</code></p>

<p>For example:</p>

<pre class="lang-py s-code-block"><code class="hljs language-python"><span class="hljs-keyword">import</span> threading

<span class="hljs-keyword">class</span> <span class="hljs-title class_">KillableThread</span>(threading.Thread):
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, sleep_interval=<span class="hljs-number">1</span></span>):
        <span class="hljs-built_in">super</span>().__init__()
        self._kill = threading.Event()
        self._interval = sleep_interval

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">run</span>(<span class="hljs-params">self</span>):
        <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:
            <span class="hljs-built_in">print</span>(<span class="hljs-string">"Do Something"</span>)

            <span class="hljs-comment"># If no kill signal is set, sleep for the interval,</span>
            <span class="hljs-comment"># If kill signal comes in while sleeping, immediately</span>
            <span class="hljs-comment">#  wake up and handle</span>
            is_killed = self._kill.wait(self._interval)
            <span class="hljs-keyword">if</span> is_killed:
                <span class="hljs-keyword">break</span>

        <span class="hljs-built_in">print</span>(<span class="hljs-string">"Killing Thread"</span>)

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">kill</span>(<span class="hljs-params">self</span>):
        self._kill.<span class="hljs-built_in">set</span>()
</code></pre>

<p>Then to run it</p>

<pre class="lang-py s-code-block"><code class="hljs language-python">t = KillableThread(sleep_interval=<span class="hljs-number">5</span>)
t.start()
<span class="hljs-comment"># Every 5 seconds it prints:</span>
<span class="hljs-comment">#: Do Something</span>
t.kill()
<span class="hljs-comment">#: Killing Thread</span>
</code></pre>

<p>The advantage of using <code>wait()</code> instead of <code>sleep()</code>ing and regularly checking the event is that you can program in longer intervals of sleep, the thread is stopped almost immediately (when you would otherwise be <code>sleep()</code>ing) and in my opinion, the code for handling exit is significantly simpler.</p>
    </div></div></div></div><div id="solution10" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 10</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/kill">kill</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/terminate">terminate</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>You can kill a thread by installing trace into the thread that will exit the thread.   See attached link for one possible implementation.</p>

<p><a href="https://web.archive.org/web/20130503082442/http://mail.python.org/pipermail/python-list/2004-May/281943.html" rel="noreferrer">Kill a thread in Python</a> </p>
    </div></div></div></div><div id="solution11" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 11</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/kill">kill</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/terminate">terminate</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>It is better if you don't kill a thread.
A way could be to introduce a "try" block into the thread's cycle and to throw an exception when you want to stop the thread (for example a break/return/... that stops your for/while/...). 
I've used this on my app and it works...</p>
    </div></div></div></div><div id="solution12" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 12</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/kill">kill</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/terminate">terminate</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>It is definitely possible to implement a <code>Thread.stop</code> method as shown in the following example code:</p>

<pre class="lang-py s-code-block"><code class="hljs language-python"><span class="hljs-keyword">import</span> sys
<span class="hljs-keyword">import</span> threading
<span class="hljs-keyword">import</span> time


<span class="hljs-keyword">class</span> <span class="hljs-title class_">StopThread</span>(<span class="hljs-title class_ inherited__">StopIteration</span>):
    <span class="hljs-keyword">pass</span>

threading.SystemExit = SystemExit, StopThread


<span class="hljs-keyword">class</span> <span class="hljs-title class_">Thread2</span>(threading.Thread):

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">stop</span>(<span class="hljs-params">self</span>):
        self.__stop = <span class="hljs-literal">True</span>

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_bootstrap</span>(<span class="hljs-params">self</span>):
        <span class="hljs-keyword">if</span> threading._trace_hook <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:
            <span class="hljs-keyword">raise</span> ValueError(<span class="hljs-string">'Cannot run thread with tracing!'</span>)
        self.__stop = <span class="hljs-literal">False</span>
        sys.settrace(self.__trace)
        <span class="hljs-built_in">super</span>()._bootstrap()

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__trace</span>(<span class="hljs-params">self, frame, event, arg</span>):
        <span class="hljs-keyword">if</span> self.__stop:
            <span class="hljs-keyword">raise</span> StopThread()
        <span class="hljs-keyword">return</span> self.__trace


<span class="hljs-keyword">class</span> <span class="hljs-title class_">Thread3</span>(threading.Thread):

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_bootstrap</span>(<span class="hljs-params">self, stop_thread=<span class="hljs-literal">False</span></span>):
        <span class="hljs-keyword">def</span> <span class="hljs-title function_">stop</span>():
            <span class="hljs-keyword">nonlocal</span> stop_thread
            stop_thread = <span class="hljs-literal">True</span>
        self.stop = stop

        <span class="hljs-keyword">def</span> <span class="hljs-title function_">tracer</span>(<span class="hljs-params">*_</span>):
            <span class="hljs-keyword">if</span> stop_thread:
                <span class="hljs-keyword">raise</span> StopThread()
            <span class="hljs-keyword">return</span> tracer
        sys.settrace(tracer)
        <span class="hljs-built_in">super</span>()._bootstrap()

<span class="hljs-comment">###############################################################################</span>


<span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>():
    test1 = Thread2(target=printer)
    test1.start()
    time.sleep(<span class="hljs-number">1</span>)
    test1.stop()
    test1.join()
    test2 = Thread2(target=speed_test)
    test2.start()
    time.sleep(<span class="hljs-number">1</span>)
    test2.stop()
    test2.join()
    test3 = Thread3(target=speed_test)
    test3.start()
    time.sleep(<span class="hljs-number">1</span>)
    test3.stop()
    test3.join()


<span class="hljs-keyword">def</span> <span class="hljs-title function_">printer</span>():
    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:
        <span class="hljs-built_in">print</span>(time.time() % <span class="hljs-number">1</span>)
        time.sleep(<span class="hljs-number">0.1</span>)


<span class="hljs-keyword">def</span> <span class="hljs-title function_">speed_test</span>(<span class="hljs-params">count=<span class="hljs-number">0</span></span>):
    <span class="hljs-keyword">try</span>:
        <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:
            count += <span class="hljs-number">1</span>
    <span class="hljs-keyword">except</span> StopThread:
        <span class="hljs-built_in">print</span>(<span class="hljs-string">'Count ='</span>, count)

<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:
    main()
</code></pre>

<p>The <code>Thread3</code> class appears to run code approximately 33% faster than the <code>Thread2</code> class.</p>
    </div></div></div></div><div id="solution13" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 13</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/kill">kill</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/terminate">terminate</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>I'm way late to this game, but I've been wrestling with <a href="https://stackoverflow.com/q/50473309/2123176">a similar question</a> and the following appears to both resolve the issue perfectly for me AND lets me do some basic thread state checking and cleanup when the daemonized sub-thread exits:</p>

<pre class="lang-py s-code-block"><code class="hljs language-python"><span class="hljs-keyword">import</span> threading
<span class="hljs-keyword">import</span> time
<span class="hljs-keyword">import</span> atexit

<span class="hljs-keyword">def</span> <span class="hljs-title function_">do_work</span>():

  i = <span class="hljs-number">0</span>
<span class="hljs-meta">  @atexit.register</span>
  <span class="hljs-keyword">def</span> <span class="hljs-title function_">goodbye</span>():
    <span class="hljs-built_in">print</span> (<span class="hljs-string">"'CLEANLY' kill sub-thread with value: %s [THREAD: %s]"</span> %
           (i, threading.currentThread().ident))

  <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:
    <span class="hljs-built_in">print</span> i
    i += <span class="hljs-number">1</span>
    time.sleep(<span class="hljs-number">1</span>)

t = threading.Thread(target=do_work)
t.daemon = <span class="hljs-literal">True</span>
t.start()

<span class="hljs-keyword">def</span> <span class="hljs-title function_">after_timeout</span>():
  <span class="hljs-built_in">print</span> <span class="hljs-string">"KILL MAIN THREAD: %s"</span> % threading.currentThread().ident
  <span class="hljs-keyword">raise</span> SystemExit

threading.Timer(<span class="hljs-number">2</span>, after_timeout).start()
</code></pre>

<p>Yields:</p>

<pre class="lang-py s-code-block"><code class="hljs language-python"><span class="hljs-number">0</span>
<span class="hljs-number">1</span>
KILL MAIN THREAD: <span class="hljs-number">140013208254208</span>
<span class="hljs-string">'CLEANLY'</span> kill sub-thread <span class="hljs-keyword">with</span> value: <span class="hljs-number">2</span> [THREAD: <span class="hljs-number">140013674317568</span>]
</code></pre>
    </div></div></div></div><div id="solution14" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 14</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/kill">kill</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/terminate">terminate</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Following workaround can be used to kill a thread:</p>

<pre class="lang-py s-code-block"><code class="hljs language-python">kill_threads = <span class="hljs-literal">False</span>

<span class="hljs-keyword">def</span> <span class="hljs-title function_">doSomething</span>():
    <span class="hljs-keyword">global</span> kill_threads
    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:
        <span class="hljs-keyword">if</span> kill_threads:
            thread.exit()
        ......
        ......

thread.start_new_thread(doSomething, ())
</code></pre>

<p>This can be used even for terminating threads, whose code is written in another module, from main thread. We can declare a global variable in that module and use it to terminate thread/s spawned in that module.</p>

<p>I usually use this to terminate all the threads at the program exit. This might not be the perfect way to terminate thread/s but could help.</p>
    </div></div></div></div><div id="solution15" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 15</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/kill">kill</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/terminate">terminate</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<pre class="lang-py s-code-block"><code class="hljs language-python"><span class="hljs-keyword">from</span> ctypes <span class="hljs-keyword">import</span> *
pthread = cdll.LoadLibrary(<span class="hljs-string">"libpthread-2.15.so"</span>)
pthread.pthread_cancel(c_ulong(t.ident))
</code></pre>

<p><strong>t</strong> is your <code>Thread</code> object.</p>

<p>Read the python source (<code>Modules/threadmodule.c</code> and <code>Python/thread_pthread.h</code>) you can see the <code>Thread.ident</code> is an <code>pthread_t</code> type, so you can do anything <code>pthread</code> can do in python use <code>libpthread</code>.</p>
    </div></div></div></div><div id="solution16" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 16</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/kill">kill</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/terminate">terminate</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Here's yet another way to do it, but with extremely clean and simple code, that works in Python 3.7 in 2021:</p>
<pre class="lang-py s-code-block"><code class="hljs language-python"><span class="hljs-keyword">import</span> ctypes 

<span class="hljs-keyword">def</span> <span class="hljs-title function_">kill_thread</span>(<span class="hljs-params">thread</span>):
    <span class="hljs-string">"""
    thread: a threading.Thread object
    """</span>
    thread_id = thread.ident
    res = ctypes.pythonapi.PyThreadState_SetAsyncExc(thread_id, ctypes.py_object(SystemExit))
    <span class="hljs-keyword">if</span> res &gt; <span class="hljs-number">1</span>:
        ctypes.pythonapi.PyThreadState_SetAsyncExc(thread_id, <span class="hljs-number">0</span>)
        <span class="hljs-built_in">print</span>(<span class="hljs-string">'Exception raise failure'</span>)
</code></pre>
<p>Adapted from here: <a href="https://www.geeksforgeeks.org/python-different-ways-to-kill-a-thread/" rel="noreferrer">https://www.geeksforgeeks.org/python-different-ways-to-kill-a-thread/</a></p>
    </div></div></div></div><div id="solution17" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 17</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/kill">kill</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/terminate">terminate</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>One thing I want to add is that if you read official documentation in <a href="https://docs.python.org/2/library/threading.html" rel="nofollow noreferrer">threading lib Python</a>, it's recommended to avoid use of "demonic" threads, when you don't want threads end abruptly, with the flag that Paolo Rovelli <a href="https://stackoverflow.com/a/15185771">mentioned</a>.</p>

<p>From official documentation:</p>

<blockquote>
  <p>Daemon threads are abruptly stopped at shutdown. Their resources (such as open files, database transactions, etc.) may not be released properly. If you want your threads to stop gracefully, make them non-daemonic and use a suitable signaling mechanism such as an Event.</p>
</blockquote>

<p>I think that creating daemonic threads depends of your application, but in general (and in my opinion) it's better to avoid killing them or making them daemonic. In multiprocessing you can use <code>is_alive()</code> to check process status  and "terminate" for finish them (Also you avoid GIL problems). But you can find more problems, sometimes, when you execute your code in Windows.</p>

<p>And always remember that if you have "live threads", the Python interpreter will be running for wait them. (Because of this daemonic can help you if don't matter abruptly ends).</p>
    </div></div></div></div><div id="solution18" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 18</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/kill">kill</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/terminate">terminate</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>There is a library built for this purpose, <a href="https://pypi.org/project/stopit/" rel="nofollow noreferrer">stopit</a>. Although some of the same cautions listed herein still apply, at least this library presents a regular, repeatable technique for achieving the stated goal.</p>
    </div></div></div></div><div id="solution19" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 19</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/kill">kill</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/terminate">terminate</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Asuming, that you want to have multiple threads of the same function, this is IMHO the easiest implementation to stop one by id:</p>

<pre class="lang-py s-code-block"><code class="hljs language-python"><span class="hljs-keyword">import</span> time
<span class="hljs-keyword">from</span> threading <span class="hljs-keyword">import</span> Thread

<span class="hljs-keyword">def</span> <span class="hljs-title function_">doit</span>(<span class="hljs-params"><span class="hljs-built_in">id</span>=<span class="hljs-number">0</span></span>):
    doit.stop=<span class="hljs-number">0</span>
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"start id:%d"</span>%<span class="hljs-built_in">id</span>)
    <span class="hljs-keyword">while</span> <span class="hljs-number">1</span>:
        time.sleep(<span class="hljs-number">1</span>)
        <span class="hljs-built_in">print</span>(<span class="hljs-string">"."</span>)
        <span class="hljs-keyword">if</span> doit.stop==<span class="hljs-built_in">id</span>:
            doit.stop=<span class="hljs-number">0</span>
            <span class="hljs-keyword">break</span>
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"end thread %d"</span>%<span class="hljs-built_in">id</span>)

t5=Thread(target=doit, args=(<span class="hljs-number">5</span>,))
t6=Thread(target=doit, args=(<span class="hljs-number">6</span>,))

t5.start() ; t6.start()
time.sleep(<span class="hljs-number">2</span>)
doit.stop =<span class="hljs-number">5</span>  <span class="hljs-comment">#kill t5</span>
time.sleep(<span class="hljs-number">2</span>)
doit.stop =<span class="hljs-number">6</span>  <span class="hljs-comment">#kill t6</span>
</code></pre>

<p>The nice thing is here, you can have multiple of same and different functions, and stop them all by <code>functionname.stop</code></p>

<p>If you want to have only one thread of the function then you don't need to remember the id. Just stop, if <code>doit.stop</code> &gt; 0.</p>
    </div></div></div></div><div id="solution20" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 20</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/kill">kill</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/terminate">terminate</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Just to build up on @SCB's idea (which was exactly what I needed) to create a KillableThread  subclass with a customized function:</p>
<pre class="lang-py s-code-block"><code class="hljs language-python"><span class="hljs-keyword">from</span> threading <span class="hljs-keyword">import</span> Thread, Event

<span class="hljs-keyword">class</span> <span class="hljs-title class_">KillableThread</span>(<span class="hljs-title class_ inherited__">Thread</span>):
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, sleep_interval=<span class="hljs-number">1</span>, target=<span class="hljs-literal">None</span>, name=<span class="hljs-literal">None</span>, args=(<span class="hljs-params"></span>), kwargs={}</span>):
        <span class="hljs-built_in">super</span>().__init__(<span class="hljs-literal">None</span>, target, name, args, kwargs)
        self._kill = Event()
        self._interval = sleep_interval
        <span class="hljs-built_in">print</span>(self._target)

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">run</span>(<span class="hljs-params">self</span>):
        <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:
            <span class="hljs-comment"># Call custom function with arguments</span>
            self._target(*self._args)

            <span class="hljs-comment"># If no kill signal is set, sleep for the interval,</span>
            <span class="hljs-comment"># If kill signal comes in while sleeping, immediately</span>
            <span class="hljs-comment">#  wake up and handle</span>
            is_killed = self._kill.wait(self._interval)
            <span class="hljs-keyword">if</span> is_killed:
                <span class="hljs-keyword">break</span>

        <span class="hljs-built_in">print</span>(<span class="hljs-string">"Killing Thread"</span>)

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">kill</span>(<span class="hljs-params">self</span>):
        self._kill.<span class="hljs-built_in">set</span>()

<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">print_msg</span>(<span class="hljs-params">msg</span>):
        <span class="hljs-built_in">print</span>(msg)

    t = KillableThread(<span class="hljs-number">10</span>, print_msg, args=(<span class="hljs-string">"hello world"</span>))
    t.start()
    time.sleep(<span class="hljs-number">6</span>)
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"About to kill thread"</span>)
    t.kill()
</code></pre>
<p>Naturally, like with @SBC, the thread doesn't wait to run a new loop to stop. In this example, you would see the "Killing Thread" message printed right after the "About to kill thread" instead of waiting for 4 more seconds for the thread to complete (since we have slept for 6 seconds already).</p>
<p>Second argument in KillableThread constructor is your custom function (print_msg here). Args argument are the arguments that will be used when calling the function (("hello world")) here.</p>
    </div></div></div></div><div id="solution21" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 21</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/kill">kill</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/terminate">terminate</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>While it's rather old, <a href="http://code.activestate.com/recipes/496960-thread2-killable-threads/" rel="nofollow noreferrer">this</a> might be a handy solution for some:  </p>

<blockquote>
  <p>A little module that extends the threading's module functionality --
  allows one thread to raise exceptions in the context of another
  thread. By raising <code>SystemExit</code>, you can finally kill python threads.</p>
</blockquote>

<pre class="lang-py s-code-block"><code class="hljs language-python"><span class="hljs-keyword">import</span> threading
<span class="hljs-keyword">import</span> ctypes     

<span class="hljs-keyword">def</span> <span class="hljs-title function_">_async_raise</span>(<span class="hljs-params">tid, excobj</span>):
    res = ctypes.pythonapi.PyThreadState_SetAsyncExc(tid, ctypes.py_object(excobj))
    <span class="hljs-keyword">if</span> res == <span class="hljs-number">0</span>:
        <span class="hljs-keyword">raise</span> ValueError(<span class="hljs-string">"nonexistent thread id"</span>)
    <span class="hljs-keyword">elif</span> res &gt; <span class="hljs-number">1</span>:
        <span class="hljs-comment"># """if it returns a number greater than one, you're in trouble, </span>
        <span class="hljs-comment"># and you should call it again with exc=NULL to revert the effect"""</span>
        ctypes.pythonapi.PyThreadState_SetAsyncExc(tid, <span class="hljs-number">0</span>)
        <span class="hljs-keyword">raise</span> SystemError(<span class="hljs-string">"PyThreadState_SetAsyncExc failed"</span>)

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Thread</span>(threading.Thread):
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">raise_exc</span>(<span class="hljs-params">self, excobj</span>):
        <span class="hljs-keyword">assert</span> self.isAlive(), <span class="hljs-string">"thread must be started"</span>
        <span class="hljs-keyword">for</span> tid, tobj <span class="hljs-keyword">in</span> threading._active.items():
            <span class="hljs-keyword">if</span> tobj <span class="hljs-keyword">is</span> self:
                _async_raise(tid, excobj)
                <span class="hljs-keyword">return</span>

        <span class="hljs-comment"># the thread was alive when we entered the loop, but was not found </span>
        <span class="hljs-comment"># in the dict, hence it must have been already terminated. should we raise</span>
        <span class="hljs-comment"># an exception here? silently ignore?</span>

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">terminate</span>(<span class="hljs-params">self</span>):
        <span class="hljs-comment"># must raise the SystemExit type, instead of a SystemExit() instance</span>
        <span class="hljs-comment"># due to a bug in PyThreadState_SetAsyncExc</span>
        self.raise_exc(SystemExit)
</code></pre>

<p>So, it allows a "thread to raise exceptions in the context of another thread" and in this way, the terminated thread can handle the termination without regularly checking an abort flag.</p>

<p>However, according to its <a href="http://tomerfiliba.com/recipes/Thread2/" rel="nofollow noreferrer">original source</a>, there are some issues with this code.</p>

<blockquote>
  <ul>
  <li>The exception will be raised only when executing python bytecode. If    your thread calls a native/built-in blocking function, the
  exception    will be raised only when execution returns to the python
  code. 
  
  <ul>
  <li>There is also an issue if the built-in function internally calls    PyErr_Clear(), which would effectively cancel your pending exception. 
  You can try to raise it again.</li>
  </ul></li>
  <li>Only exception types can be raised    safely. Exception instances are likely to cause unexpected behavior,    and are thus restricted.
  
  <ul>
  <li>For example: t1.raise_exc(TypeError) and    not t1.raise_exc(TypeError("blah")).</li>
  <li>IMHO it's a bug, and I reported it as one. For more info,    <a href="http://mail.python.org/pipermail/python-dev/2006-August/068158.html" rel="nofollow noreferrer">http://mail.python.org/pipermail/python-dev/2006-August/068158.html</a>  </li>
  </ul></li>
  <li>I asked to expose this function in the built-in thread module, but    since ctypes has become a standard library (as of 2.5), and this<br>
  feature is not likely to be implementation-agnostic, it may be kept<br>
  unexposed.</li>
  </ul>
</blockquote>
    </div></div></div></div><div id="solution22" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 22</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/kill">kill</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/terminate">terminate</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>As mentioned in @Kozyarchuk's <a href="https://stackoverflow.com/questions/323972/is-there-any-way-to-kill-a-thread/325027#325027">answer</a>, installing trace works. Since this answer contained no code, here is a working ready-to-use example:</p>

<pre class="lang-py s-code-block"><code class="hljs language-python"><span class="hljs-keyword">import</span> sys, threading, time 

<span class="hljs-keyword">class</span> <span class="hljs-title class_">TraceThread</span>(threading.Thread): 
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, *args, **keywords</span>): 
        threading.Thread.__init__(self, *args, **keywords) 
        self.killed = <span class="hljs-literal">False</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">start</span>(<span class="hljs-params">self</span>): 
        self._run = self.run 
        self.run = self.settrace_and_run
        threading.Thread.start(self) 
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">settrace_and_run</span>(<span class="hljs-params">self</span>): 
        sys.settrace(self.globaltrace) 
        self._run()
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">globaltrace</span>(<span class="hljs-params">self, frame, event, arg</span>): 
        <span class="hljs-keyword">return</span> self.localtrace <span class="hljs-keyword">if</span> event == <span class="hljs-string">'call'</span> <span class="hljs-keyword">else</span> <span class="hljs-literal">None</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">localtrace</span>(<span class="hljs-params">self, frame, event, arg</span>): 
        <span class="hljs-keyword">if</span> self.killed <span class="hljs-keyword">and</span> event == <span class="hljs-string">'line'</span>: 
            <span class="hljs-keyword">raise</span> SystemExit() 
        <span class="hljs-keyword">return</span> self.localtrace 

<span class="hljs-keyword">def</span> <span class="hljs-title function_">f</span>(): 
    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>: 
        <span class="hljs-built_in">print</span>(<span class="hljs-string">'1'</span>) 
        time.sleep(<span class="hljs-number">2</span>)
        <span class="hljs-built_in">print</span>(<span class="hljs-string">'2'</span>) 
        time.sleep(<span class="hljs-number">2</span>)
        <span class="hljs-built_in">print</span>(<span class="hljs-string">'3'</span>) 
        time.sleep(<span class="hljs-number">2</span>)

t = TraceThread(target=f) 
t.start() 
time.sleep(<span class="hljs-number">2.5</span>) 
t.killed = <span class="hljs-literal">True</span>
</code></pre>

<p>It stops after having printed <code>1</code> and <code>2</code>. <code>3</code> is not printed.</p>
    </div></div></div></div><div id="solution23" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 23</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/kill">kill</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/terminate">terminate</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Python version: 3.8</p>
<p>Using daemon thread to execute what we wanted, if we want to daemon thread be terminated, all we need is making parent thread exit, then system will terminate daemon thread which parent thread created.</p>
<p>Also support coroutine and coroutine function.</p>
<pre class="lang-py s-code-block"><code class="hljs language-python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>():
    start_time = time.perf_counter()
    t1 = ExitThread(time.sleep, (<span class="hljs-number">10</span>,), debug=<span class="hljs-literal">False</span>)
    t1.start()
    time.sleep(<span class="hljs-number">0.5</span>)
    t1.exit()
    <span class="hljs-keyword">try</span>:
        <span class="hljs-built_in">print</span>(t1.result_future.result())
    <span class="hljs-keyword">except</span> concurrent.futures.CancelledError:
        <span class="hljs-keyword">pass</span>
    end_time = time.perf_counter()
    <span class="hljs-built_in">print</span>(<span class="hljs-string">f"time cost <span class="hljs-subst">{end_time - start_time:<span class="hljs-number">0.2</span>f}</span>"</span>)
</code></pre>
<p>below is ExitThread source code</p>
<pre class="lang-py s-code-block"><code class="hljs language-python"><span class="hljs-keyword">import</span> concurrent.futures
<span class="hljs-keyword">import</span> threading
<span class="hljs-keyword">import</span> typing
<span class="hljs-keyword">import</span> asyncio


<span class="hljs-keyword">class</span> <span class="hljs-title class_">_WorkItem</span>(<span class="hljs-title class_ inherited__">object</span>):
    <span class="hljs-string">""" concurrent\futures\thread.py

    """</span>

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, future, fn, args, kwargs, *, debug=<span class="hljs-literal">None</span></span>):
        self._debug = debug
        self.future = future
        self.fn = fn
        self.args = args
        self.kwargs = kwargs

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">run</span>(<span class="hljs-params">self</span>):
        <span class="hljs-keyword">if</span> self._debug:
            <span class="hljs-built_in">print</span>(<span class="hljs-string">"ExitThread._WorkItem run"</span>)
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> self.future.set_running_or_notify_cancel():
            <span class="hljs-keyword">return</span>

        <span class="hljs-keyword">try</span>:
            coroutine = <span class="hljs-literal">None</span>
            <span class="hljs-keyword">if</span> asyncio.iscoroutinefunction(self.fn):
                coroutine = self.fn(*self.args, **self.kwargs)
            <span class="hljs-keyword">elif</span> asyncio.iscoroutine(self.fn):
                coroutine = self.fn
            <span class="hljs-keyword">if</span> coroutine <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:
                result = self.fn(*self.args, **self.kwargs)
            <span class="hljs-keyword">else</span>:
                result = asyncio.run(coroutine)
            <span class="hljs-keyword">if</span> self._debug:
                <span class="hljs-built_in">print</span>(<span class="hljs-string">"_WorkItem done"</span>)
        <span class="hljs-keyword">except</span> BaseException <span class="hljs-keyword">as</span> exc:
            self.future.set_exception(exc)
            <span class="hljs-comment"># Break a reference cycle with the exception 'exc'</span>
            self = <span class="hljs-literal">None</span>
        <span class="hljs-keyword">else</span>:
            self.future.set_result(result)


<span class="hljs-keyword">class</span> <span class="hljs-title class_">ExitThread</span>:
    <span class="hljs-string">""" Like a stoppable thread

    Using coroutine for target then exit before running may cause RuntimeWarning.

    """</span>

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, target: typing.<span class="hljs-type">Union</span>[typing.<span class="hljs-type">Coroutine</span>, typing.<span class="hljs-type">Callable</span>] = <span class="hljs-literal">None</span>
                 , args=(<span class="hljs-params"></span>), kwargs={}, *, daemon=<span class="hljs-literal">None</span>, debug=<span class="hljs-literal">None</span></span>):
        <span class="hljs-comment">#</span>
        self._debug = debug
        self._parent_thread = threading.Thread(target=self._parent_thread_run, name=<span class="hljs-string">"ExitThread_parent_thread"</span>
                                               , daemon=daemon)
        self._child_daemon_thread = <span class="hljs-literal">None</span>
        self.result_future = concurrent.futures.Future()
        self._workItem = _WorkItem(self.result_future, target, args, kwargs, debug=debug)
        self._parent_thread_exit_lock = threading.Lock()
        self._parent_thread_exit_lock.acquire()
        self._parent_thread_exit_lock_released = <span class="hljs-literal">False</span>  <span class="hljs-comment"># When done it will be True</span>
        self._started = <span class="hljs-literal">False</span>
        self._exited = <span class="hljs-literal">False</span>
        self.result_future.add_done_callback(self._release_parent_thread_exit_lock)

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_parent_thread_run</span>(<span class="hljs-params">self</span>):
        self._child_daemon_thread = threading.Thread(target=self._child_daemon_thread_run
                                                     , name=<span class="hljs-string">"ExitThread_child_daemon_thread"</span>
                                                     , daemon=<span class="hljs-literal">True</span>)
        self._child_daemon_thread.start()
        <span class="hljs-comment"># Block manager thread</span>
        self._parent_thread_exit_lock.acquire()
        self._parent_thread_exit_lock.release()
        <span class="hljs-keyword">if</span> self._debug:
            <span class="hljs-built_in">print</span>(<span class="hljs-string">"ExitThread._parent_thread_run exit"</span>)

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_release_parent_thread_exit_lock</span>(<span class="hljs-params">self, _future</span>):
        <span class="hljs-keyword">if</span> self._debug:
            <span class="hljs-built_in">print</span>(<span class="hljs-string">f"ExitThread._release_parent_thread_exit_lock <span class="hljs-subst">{self._parent_thread_exit_lock_released}</span> <span class="hljs-subst">{_future}</span>"</span>)
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> self._parent_thread_exit_lock_released:
            self._parent_thread_exit_lock_released = <span class="hljs-literal">True</span>
            self._parent_thread_exit_lock.release()

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_child_daemon_thread_run</span>(<span class="hljs-params">self</span>):
        self._workItem.run()

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">start</span>(<span class="hljs-params">self</span>):
        <span class="hljs-keyword">if</span> self._debug:
            <span class="hljs-built_in">print</span>(<span class="hljs-string">f"ExitThread.start <span class="hljs-subst">{self._started}</span>"</span>)
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> self._started:
            self._started = <span class="hljs-literal">True</span>
            self._parent_thread.start()

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">exit</span>(<span class="hljs-params">self</span>):
        <span class="hljs-keyword">if</span> self._debug:
            <span class="hljs-built_in">print</span>(<span class="hljs-string">f"ExitThread.exit exited: <span class="hljs-subst">{self._exited}</span> lock_released: <span class="hljs-subst">{self._parent_thread_exit_lock_released}</span>"</span>)
        <span class="hljs-keyword">if</span> self._parent_thread_exit_lock_released:
            <span class="hljs-keyword">return</span>
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> self._exited:
            self._exited = <span class="hljs-literal">True</span>
            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> self.result_future.cancel():
                <span class="hljs-keyword">if</span> self.result_future.running():
                    self.result_future.set_exception(concurrent.futures.CancelledError())
</code></pre>
    </div></div></div></div><div id="solution24" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 24</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/kill">kill</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/terminate">terminate</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>This seems to work with pywin32 on windows 7</p>

<pre class="lang-py s-code-block"><code class="hljs language-python">my_thread = threading.Thread()
my_thread.start()
my_thread._Thread__stop()
</code></pre>
    </div></div></div></div><div id="solution25" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 25</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/kill">kill</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/terminate">terminate</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Pieter Hintjens -- one of the founders of the <a href="http://zguide.zeromq.org/py:all" rel="nofollow noreferrer">ØMQ</a>-project -- says, using ØMQ and avoiding synchronization primitives like locks, mutexes, events etc., is the sanest and securest way to write multi-threaded programs:</p>

<p><a href="http://zguide.zeromq.org/py:all#Multithreading-with-ZeroMQ" rel="nofollow noreferrer">http://zguide.zeromq.org/py:all#Multithreading-with-ZeroMQ</a></p>

<p>This includes telling a child thread, that it should cancel its work. This would be done by equipping the thread with a ØMQ-socket and polling on that socket for a message saying that it should cancel.</p>

<p>The link also provides an example on multi-threaded python code with ØMQ.</p>
    </div></div></div></div><div id="solution26" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 26</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/kill">kill</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/terminate">terminate</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>An alternative is to use <a href="https://docs.python.org/3/library/signal.html#signal.pthread_kill" rel="nofollow noreferrer"><code>signal.pthread_kill</code></a> to send a stop signal.</p>
<pre class="lang-py s-code-block"><code class="hljs language-python"><span class="hljs-keyword">from</span> signal <span class="hljs-keyword">import</span> pthread_kill, SIGTSTP
<span class="hljs-keyword">from</span> threading <span class="hljs-keyword">import</span> Thread
<span class="hljs-keyword">from</span> itertools <span class="hljs-keyword">import</span> count
<span class="hljs-keyword">from</span> time <span class="hljs-keyword">import</span> sleep

<span class="hljs-keyword">def</span> <span class="hljs-title function_">target</span>():
    <span class="hljs-keyword">for</span> num <span class="hljs-keyword">in</span> count():
        <span class="hljs-built_in">print</span>(num)
        sleep(<span class="hljs-number">1</span>)

thread = Thread(target=target)
thread.start()
sleep(<span class="hljs-number">5</span>)
pthread_kill(thread.ident, SIGTSTP)
</code></pre>
<p>result</p>
<pre class="lang-bash s-code-block"><code class="hljs language-bash">0
1
2
3
4

[14]+  Stopped
</code></pre>
    </div></div></div></div><div id="solution27" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 27</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/kill">kill</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/terminate">terminate</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>If you really need the ability to kill a sub-task, use an alternate implementation. <code>multiprocessing</code> and <code>gevent</code> both support indiscriminately killing a "thread".</p>

<p>Python's threading does not support cancellation. Do not even try. Your code is very likely to deadlock, corrupt or leak memory, or have other unintended "interesting" hard-to-debug effects which happen rarely and nondeterministically.</p>
    </div></div></div></div><div id="solution28" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 28</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/kill">kill</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/terminate">terminate</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>You can execute your command in a process and then kill it using the process id.
I needed to sync between two thread one of which  doesnt return by itself.</p>

<pre class="lang-py s-code-block"><code class="hljs language-python">processIds = []

<span class="hljs-keyword">def</span> <span class="hljs-title function_">executeRecord</span>(<span class="hljs-params">command</span>):
    <span class="hljs-built_in">print</span>(command)

    process = subprocess.Popen(command, stdout=subprocess.PIPE)
    processIds.append(process.pid)
    <span class="hljs-built_in">print</span>(processIds[<span class="hljs-number">0</span>])

    <span class="hljs-comment">#Command that doesn't return by itself</span>
    process.stdout.read().decode(<span class="hljs-string">"utf-8"</span>)
    <span class="hljs-keyword">return</span>;


<span class="hljs-keyword">def</span> <span class="hljs-title function_">recordThread</span>(<span class="hljs-params">command, timeOut</span>):

    thread = Thread(target=executeRecord, args=(command,))
    thread.start()
    thread.join(timeOut)

    os.kill(processIds.pop(), signal.SIGINT)

    <span class="hljs-keyword">return</span>;
</code></pre>
    </div></div></div></div><div id="solution29" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 29</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/kill">kill</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/terminate">terminate</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>The most simple way is this:</p>
<pre class="lang-py s-code-block"><code class="hljs language-python"><span class="hljs-keyword">from</span> threading <span class="hljs-keyword">import</span> Thread
<span class="hljs-keyword">from</span> time <span class="hljs-keyword">import</span> sleep

<span class="hljs-keyword">def</span> <span class="hljs-title function_">do_something</span>():
    <span class="hljs-keyword">global</span> thread_work
    <span class="hljs-keyword">while</span> thread_work:
        <span class="hljs-built_in">print</span>(<span class="hljs-string">'doing something'</span>)
        sleep(<span class="hljs-number">5</span>)
    <span class="hljs-built_in">print</span>(<span class="hljs-string">'Thread stopped'</span>)

thread_work = <span class="hljs-literal">True</span>
Thread(target=do_something).start()
sleep(<span class="hljs-number">5</span>)
thread_work = <span class="hljs-literal">False</span>
</code></pre>
    </div></div></div></div><div id="solution30" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 30</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/kill">kill</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/terminate">terminate</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<blockquote>
  <p><strong>This is a bad answer, see the comments</strong></p>
</blockquote>

<p>Here's how to do it:</p>

<pre class="lang-py s-code-block"><code class="hljs language-python"><span class="hljs-keyword">from</span> threading <span class="hljs-keyword">import</span> *

...

<span class="hljs-keyword">for</span> thread <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>():
    <span class="hljs-keyword">if</span> thread.isAlive():
        <span class="hljs-keyword">try</span>:
            thread._Thread__stop()
        <span class="hljs-keyword">except</span>:
            <span class="hljs-built_in">print</span>(<span class="hljs-built_in">str</span>(thread.getName()) + <span class="hljs-string">' could not be terminated'</span>))
</code></pre>

<p>Give it a few seconds then your thread should be stopped. Check also the <code>thread._Thread__delete()</code> method.</p>

<p>I'd recommend a <code>thread.quit()</code> method for convenience. For example if you have a socket in your thread, I'd recommend creating a <code>quit()</code> method in your socket-handle class, terminate the socket, then run a <code>thread._Thread__stop()</code> inside of your <code>quit()</code>.</p>
    </div></div></div></div></div></div><div class="widget"><a href="/questions/var-functionname-function()-vs-function-functionname()-1657384724077">var functionName = function() {} vs function functionName() {}</a><a href="/questions/transitions-on-the-css-display-property-1657387761601">Transitions on the CSS display property</a><a href="/questions/calculate-distance-between-two-latitude-longitude-points-(haversine-formula)-1657388500103">Calculate distance between two latitude-longitude points? (Haversine formula)</a><a href="/questions/undefined-behavior-and-sequence-points-1657384639493">Undefined behavior and sequence points</a><a href="/questions/how-do-you-get-the-footer-to-stay-at-the-bottom-of-a-web-page-1657387817544">How do you get the footer to stay at the bottom of a Web page?</a><a href="/questions/flatten-an-irregular-list-of-lists-1657387315571">Flatten an irregular list of lists</a><a href="/questions/selecting-and-manipulating-css-pseudo-elements-such-as-::before-and-::after-using-javascript-(or-jquery)-1657387406132">Selecting and manipulating CSS pseudo-elements such as ::before and ::after using javascript (or jQuery)</a><a href="/questions/why-does-tkinter-image-not-show-up-if-created-in-a-function-1657387388233">Why does Tkinter image not show up if created in a function?</a><a href="/questions/how-to-check-if-element-is-visible-after-scrolling-1657387987960">How to check if element is visible after scrolling?</a><a href="/questions/default-constructor-with-empty-brackets-1657388246967">Default constructor with empty brackets</a><a href="/questions/iterating-over-dictionaries-using-&#x27;for&#x27;-loops-1657388334481">Iterating over dictionaries using &#x27;for&#x27; loops</a><a href="/questions/how-do-i-detect-collision-in-pygame-1657387496338">How do I detect collision in pygame?</a><a href="/questions/how-can-i-return-pivot-table-output-in-mysql-1657384715043">How can I return pivot table output in MySQL?</a><a href="/questions/how-to-parse-json-in-java-1657384575136">How to parse JSON in Java</a><a href="/questions/aggregate-summarize-multiple-variables-per-group-(e.g.-sum-mean)-1657387764061">Aggregate / summarize multiple variables per group (e.g. sum, mean)</a><a href="/questions/daylight-saving-time-and-time-zone-best-practices-closed-1657387973687">Daylight saving time and time zone best practices [closed]</a><a href="/questions/what-is-the-difference-between-a-deep-copy-and-a-shallow-copy-1657388445063">What is the difference between a deep copy and a shallow copy?</a><a href="/questions/why-is-using-the-javascript-eval-function-a-bad-idea-1657387485165">Why is using the JavaScript eval function a bad idea?</a><a href="/questions/what&#x27;s-the-difference-between-inner-join-left-join-right-join-and-full-join-duplicate-1657388082887">What&#x27;s the difference between INNER JOIN, LEFT JOIN, RIGHT JOIN and FULL JOIN? [duplicate]</a><a href="/questions/javascript-closure-inside-loops-simple-practical-example-1657384278449">JavaScript closure inside loops – simple practical example</a></div></div><span class="cursor-pointer text-lg p-2" style="position:fixed;bottom:20px;left:20px;background:#000;z-index:2000;color:white">Go go top</span></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"data":{"answer":["\n\u0026lt;p\u0026gt;It is generally a bad pattern to kill a thread abruptly, in Python, and in any language. Think of the following cases:\u0026lt;/p\u0026gt;\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;the thread is holding a critical resource that must be closed properly\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;the thread has created several other threads that must be killed as well.\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;p\u0026gt;The nice way of handling this, if you can afford it (if you are managing your own threads), is to have an exit_request flag that each thread checks on a regular interval to see if it is time for it to exit.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;For example:\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;import\u0026lt;/span\u0026gt; threading\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;StoppableThread\u0026lt;/span\u0026gt;(threading.Thread):\n    \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;\u0026quot;\u0026quot;Thread class with a stop() method. The thread itself has to check\n    regularly for the stopped() condition.\u0026quot;\u0026quot;\u0026quot;\u0026lt;/span\u0026gt;\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;def\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;__init__\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;self,  *args, **kwargs\u0026lt;/span\u0026gt;):\n        \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;super\u0026lt;/span\u0026gt;(StoppableThread, self).__init__(*args, **kwargs)\n        self._stop_event = threading.Event()\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;def\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;stop\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;self\u0026lt;/span\u0026gt;):\n        self._stop_event.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;set\u0026lt;/span\u0026gt;()\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;def\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;stopped\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;self\u0026lt;/span\u0026gt;):\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; self._stop_event.is_set()\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;In this code, you should call \u0026lt;code\u0026gt;stop()\u0026lt;/code\u0026gt; on the thread when you want it to exit, and wait for the thread to exit properly using \u0026lt;code\u0026gt;join()\u0026lt;/code\u0026gt;. The thread should check the stop flag at regular intervals.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;There are cases, however, when you really need to kill a thread. An example is when you are wrapping an external library that is busy for long calls, and you want to interrupt it.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;The following code allows (with some restrictions) to raise an Exception in a Python thread:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;def\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;_async_raise\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;tid, exctype\u0026lt;/span\u0026gt;):\n    \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;\u0026apos;\u0026apos;Raises an exception in the threads with id tid\u0026apos;\u0026apos;\u0026apos;\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;not\u0026lt;/span\u0026gt; inspect.isclass(exctype):\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;raise\u0026lt;/span\u0026gt; TypeError(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Only types can be raised (not instances)\u0026quot;\u0026lt;/span\u0026gt;)\n    res = ctypes.pythonapi.PyThreadState_SetAsyncExc(ctypes.c_long(tid),\n                                                     ctypes.py_object(exctype))\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; res == \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;:\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;raise\u0026lt;/span\u0026gt; ValueError(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;invalid thread id\u0026quot;\u0026lt;/span\u0026gt;)\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;elif\u0026lt;/span\u0026gt; res != \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;:\n        \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;# \u0026quot;if it returns a number greater than one, you\u0026apos;re in trouble,\u0026lt;/span\u0026gt;\n        \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;# and you should call it again with exc=NULL to revert the effect\u0026quot;\u0026lt;/span\u0026gt;\n        ctypes.pythonapi.PyThreadState_SetAsyncExc(ctypes.c_long(tid), \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;None\u0026lt;/span\u0026gt;)\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;raise\u0026lt;/span\u0026gt; SystemError(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;PyThreadState_SetAsyncExc failed\u0026quot;\u0026lt;/span\u0026gt;)\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;ThreadWithExc\u0026lt;/span\u0026gt;(threading.Thread):\n    \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;\u0026apos;\u0026apos;A thread class that supports raising an exception in the thread from\n       another thread.\n    \u0026apos;\u0026apos;\u0026apos;\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;def\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;_get_my_tid\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;self\u0026lt;/span\u0026gt;):\n        \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;\u0026quot;\u0026quot;determines this (self\u0026apos;s) thread id\n\n        CAREFUL: this function is executed in the context of the caller\n        thread, to get the identity of the thread represented by this\n        instance.\n        \u0026quot;\u0026quot;\u0026quot;\u0026lt;/span\u0026gt;\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;not\u0026lt;/span\u0026gt; self.isAlive():\n            \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;raise\u0026lt;/span\u0026gt; threading.ThreadError(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;the thread is not active\u0026quot;\u0026lt;/span\u0026gt;)\n\n        \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;# do we have it cached?\u0026lt;/span\u0026gt;\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;hasattr\u0026lt;/span\u0026gt;(self, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;_thread_id\u0026quot;\u0026lt;/span\u0026gt;):\n            \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; self._thread_id\n\n        \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;# no, look for it in the _active dict\u0026lt;/span\u0026gt;\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt; tid, tobj \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;in\u0026lt;/span\u0026gt; threading._active.items():\n            \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; tobj \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;is\u0026lt;/span\u0026gt; self:\n                self._thread_id = tid\n                \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; tid\n\n        \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;# \u0026lt;span class=\u0026quot;hljs-doctag\u0026quot;\u0026gt;TODO:\u0026lt;/span\u0026gt; in python 2.6, there\u0026apos;s a simpler way to do: self.ident\u0026lt;/span\u0026gt;\n\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;raise\u0026lt;/span\u0026gt; AssertionError(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;could not determine the thread\u0026apos;s id\u0026quot;\u0026lt;/span\u0026gt;)\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;def\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;raiseExc\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;self, exctype\u0026lt;/span\u0026gt;):\n        \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;\u0026quot;\u0026quot;Raises the given exception type in the context of this thread.\n\n        If the thread is busy in a system call (time.sleep(),\n        socket.accept(), ...), the exception is simply ignored.\n\n        If you are sure that your exception should terminate the thread,\n        one way to ensure that it works is:\n\n            t = ThreadWithExc( ... )\n            ...\n            t.raiseExc( SomeException )\n            while t.isAlive():\n                time.sleep( 0.1 )\n                t.raiseExc( SomeException )\n\n        If the exception is to be caught by the thread, you need a way to\n        check that your thread has caught it.\n\n        CAREFUL: this function is executed in the context of the\n        caller thread, to raise an exception in the context of the\n        thread represented by this instance.\n        \u0026quot;\u0026quot;\u0026quot;\u0026lt;/span\u0026gt;\n        _async_raise( self._get_my_tid(), exctype )\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;(Based on \u0026lt;a href=\u0026quot;http://tomerfiliba.com/recipes/Thread2/\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;Killable Threads\u0026lt;/a\u0026gt; by Tomer Filiba. The quote about the return value of \u0026lt;code\u0026gt;PyThreadState_SetAsyncExc\u0026lt;/code\u0026gt; appears to be from an \u0026lt;a href=\u0026quot;https://svn.python.org/projects/stackless/Python-2.4.3/dev/Python/pystate.c\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;old version of Python\u0026lt;/a\u0026gt;.)\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;As noted in the documentation, this is not a magic bullet because if the thread is busy outside the Python interpreter, it will not catch the interruption.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;A good usage pattern of this code is to have the thread catch a specific exception and perform the cleanup. That way, you can interrupt a task and still have proper cleanup.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;A \u0026lt;a href=\u0026quot;https://docs.python.org/library/multiprocessing.html#multiprocessing.Process\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;\u0026lt;code\u0026gt;multiprocessing.Process\u0026lt;/code\u0026gt;\u0026lt;/a\u0026gt; can \u0026lt;a href=\u0026quot;https://docs.python.org/library/multiprocessing.html#multiprocessing.Process.terminate\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;\u0026lt;code\u0026gt;p.terminate()\u0026lt;/code\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;In the cases where I want to kill a thread, but do not want to use flags/locks/signals/semaphores/events/whatever, I promote the threads to full blown processes. For code that makes use of just a few threads the overhead is not that bad.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;E.g. this comes in handy to easily terminate helper \u0026quot;threads\u0026quot; which execute blocking I/O\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;The conversion is trivial: In related code replace all \u0026lt;code\u0026gt;threading.Thread\u0026lt;/code\u0026gt; with \u0026lt;code\u0026gt;multiprocessing.Process\u0026lt;/code\u0026gt; and all \u0026lt;code\u0026gt;queue.Queue\u0026lt;/code\u0026gt; with \u0026lt;code\u0026gt;multiprocessing.Queue\u0026lt;/code\u0026gt; and add the required calls of \u0026lt;code\u0026gt;p.terminate()\u0026lt;/code\u0026gt; to your parent process which wants to kill its child \u0026lt;code\u0026gt;p\u0026lt;/code\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;See the \u0026lt;a href=\u0026quot;https://docs.python.org/library/multiprocessing.html\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;Python documentation for \u0026lt;code\u0026gt;multiprocessing\u0026lt;/code\u0026gt;\u0026lt;/a\u0026gt;.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Example:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;import\u0026lt;/span\u0026gt; multiprocessing\nproc = multiprocessing.Process(target=your_proc_function, args=())\nproc.start()\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;# Terminate the process\u0026lt;/span\u0026gt;\nproc.terminate()  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;# sends a SIGTERM\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;There is no official API to do that, no.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;You need to use platform API to kill the thread, e.g. pthread_kill, or TerminateThread. You can access such API e.g. through pythonwin, or through ctypes.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Notice that this is inherently unsafe. It will likely lead to uncollectable garbage (from local variables of the stack frames that become garbage), and may lead to deadlocks, if the thread being killed has the GIL at the point when it is killed.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;If you are trying to terminate the whole program you can set the thread as a \u0026quot;daemon\u0026quot;. see\n\u0026lt;a href=\u0026quot;http://docs.python.org/library/threading.html#threading.Thread.daemon\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;Thread.daemon\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;As others have mentioned, the norm is to set a stop flag. For something lightweight (no subclassing of Thread, no global variable), a lambda callback is an option. (Note the parentheses in \u0026lt;code\u0026gt;if stop()\u0026lt;/code\u0026gt;.)\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;import\u0026lt;/span\u0026gt; threading\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;import\u0026lt;/span\u0026gt; time\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;def\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;do_work\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;id\u0026lt;/span\u0026gt;, stop\u0026lt;/span\u0026gt;):\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;I am thread\u0026quot;\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;id\u0026lt;/span\u0026gt;)\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;while\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;True\u0026lt;/span\u0026gt;:\n        \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;I am thread {} doing something\u0026quot;\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;format\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;id\u0026lt;/span\u0026gt;))\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; stop():\n            \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;  Exiting loop.\u0026quot;\u0026lt;/span\u0026gt;)\n            \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;break\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Thread {}, signing off\u0026quot;\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;format\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;id\u0026lt;/span\u0026gt;))\n\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;def\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;main\u0026lt;/span\u0026gt;():\n    stop_threads = \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;False\u0026lt;/span\u0026gt;\n    workers = []\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;id\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;in\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;range\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;,\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3\u0026lt;/span\u0026gt;):\n        tmp = threading.Thread(target=do_work, args=(\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;id\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;lambda\u0026lt;/span\u0026gt;: stop_threads))\n        workers.append(tmp)\n        tmp.start()\n    time.sleep(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3\u0026lt;/span\u0026gt;)\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;main: done sleeping; time to stop the threads.\u0026apos;\u0026lt;/span\u0026gt;)\n    stop_threads = \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;True\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt; worker \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;in\u0026lt;/span\u0026gt; workers:\n        worker.join()\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;Finis.\u0026apos;\u0026lt;/span\u0026gt;)\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; __name__ == \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;__main__\u0026apos;\u0026lt;/span\u0026gt;:\n    main()\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Replacing \u0026lt;code\u0026gt;print()\u0026lt;/code\u0026gt; with a \u0026lt;code\u0026gt;pr()\u0026lt;/code\u0026gt; function that always flushes (\u0026lt;code\u0026gt;sys.stdout.flush()\u0026lt;/code\u0026gt;) may improve the precision of the shell output.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;(Only tested on Windows/Eclipse/Python3.3)\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;In Python, you simply cannot kill a Thread directly.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;If you do NOT really need to have a Thread (!), what you can do, instead of using the \u0026lt;a href=\u0026quot;http://docs.python.org/2/library/threading.html\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;\u0026lt;em\u0026gt;threading\u0026lt;/em\u0026gt; package \u0026lt;/a\u0026gt;, is to use the \n\u0026lt;a href=\u0026quot;http://docs.python.org/2/library/multiprocessing.html\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;\u0026lt;em\u0026gt;multiprocessing\u0026lt;/em\u0026gt; package \u0026lt;/a\u0026gt;. Here, to kill a process, you can simply call the method:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;yourProcess.terminate()  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;# kill the process!\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Python will kill your process (on Unix through the SIGTERM signal, while on Windows through the \u0026lt;code\u0026gt;TerminateProcess()\u0026lt;/code\u0026gt; call). Pay attention to use it while using a Queue or a Pipe! (it may corrupt the data in the Queue/Pipe)\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Note that the \u0026lt;code\u0026gt;multiprocessing.Event\u0026lt;/code\u0026gt; and the \u0026lt;code\u0026gt;multiprocessing.Semaphore\u0026lt;/code\u0026gt; work exactly in the same way of the \u0026lt;code\u0026gt;threading.Event\u0026lt;/code\u0026gt; and the \u0026lt;code\u0026gt;threading.Semaphore\u0026lt;/code\u0026gt; respectively. In fact, the first ones are clones of the latters.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;If you REALLY need to use a Thread, there is no way to kill it directly. What you can do, however, is to use a \u0026lt;em\u0026gt;\u0026quot;daemon thread\u0026quot;\u0026lt;/em\u0026gt;. In fact, in Python, a Thread can be flagged as \u0026lt;em\u0026gt;daemon\u0026lt;/em\u0026gt;:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;yourThread.daemon = \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;True\u0026lt;/span\u0026gt;  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;# set the Thread as a \u0026quot;daemon thread\u0026quot;\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;The main program will exit when no alive non-daemon threads are left. In other words, when your main thread (which is, of course, a non-daemon thread) will finish its operations, the program will exit even if there are still some daemon threads working.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Note that it is necessary to set a Thread as \u0026lt;code\u0026gt;daemon\u0026lt;/code\u0026gt; before the \u0026lt;code\u0026gt;start()\u0026lt;/code\u0026gt; method is called!\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Of course you can, and should, use \u0026lt;code\u0026gt;daemon\u0026lt;/code\u0026gt; even with \u0026lt;code\u0026gt;multiprocessing\u0026lt;/code\u0026gt;. Here, when the main process exits, it attempts to terminate all of its daemonic child processes.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Finally, please, note that \u0026lt;code\u0026gt;sys.exit()\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;os.kill()\u0026lt;/code\u0026gt; are not choices.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;This is based on the \u0026lt;a href=\u0026quot;https://web.archive.org/web/20100514180958id_/http://code.activestate.com:80/recipes/496960-thread2-killable-threads/?in=lang-python\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;thread2 -- killable threads\u0026lt;/a\u0026gt; ActiveState recipe.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;You need to call \u0026lt;a href=\u0026quot;https://docs.python.org/3/c-api/init.html#c.PyThreadState_SetAsyncExc\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;\u0026lt;code\u0026gt;PyThreadState_SetAsyncExc()\u0026lt;/code\u0026gt;\u0026lt;/a\u0026gt;, which is only available through the \u0026lt;a href=\u0026quot;https://docs.python.org/3/library/ctypes.html#module-ctypes\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;\u0026lt;code\u0026gt;ctypes\u0026lt;/code\u0026gt;\u0026lt;/a\u0026gt; module.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;This has only been tested on Python 2.7.3, but it is likely to work with other recent 2.x releases. \u0026lt;code\u0026gt;PyThreadState_SetAsyncExc()\u0026lt;/code\u0026gt; still exists in Python 3 for backwards compatibility (but I have not tested it).\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;import\u0026lt;/span\u0026gt; ctypes\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;def\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;terminate_thread\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;thread\u0026lt;/span\u0026gt;):\n    \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;\u0026quot;\u0026quot;Terminates a python thread from another thread.\n\n    :param thread: a threading.Thread instance\n    \u0026quot;\u0026quot;\u0026quot;\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;not\u0026lt;/span\u0026gt; thread.isAlive():\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt;\n\n    exc = ctypes.py_object(SystemExit)\n    res = ctypes.pythonapi.PyThreadState_SetAsyncExc(\n        ctypes.c_long(thread.ident), exc)\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; res == \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;:\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;raise\u0026lt;/span\u0026gt; ValueError(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;nonexistent thread id\u0026quot;\u0026lt;/span\u0026gt;)\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;elif\u0026lt;/span\u0026gt; res \u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;:\n        \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;# \u0026quot;\u0026quot;\u0026quot;if it returns a number greater than one, you\u0026apos;re in trouble,\u0026lt;/span\u0026gt;\n        \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;# and you should call it again with exc=NULL to revert the effect\u0026quot;\u0026quot;\u0026quot;\u0026lt;/span\u0026gt;\n        ctypes.pythonapi.PyThreadState_SetAsyncExc(thread.ident, \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;None\u0026lt;/span\u0026gt;)\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;raise\u0026lt;/span\u0026gt; SystemError(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;PyThreadState_SetAsyncExc failed\u0026quot;\u0026lt;/span\u0026gt;)\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;You should never forcibly kill a thread without cooperating with it.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Killing a thread removes any guarantees that try/finally blocks set up so you might leave locks locked, files open, etc.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;The only time you can argue that forcibly killing threads is a good idea is to kill a program fast, but never single threads.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;If you are explicitly calling \u0026lt;code\u0026gt;time.sleep()\u0026lt;/code\u0026gt; as part of your thread (say polling some external service), an improvement upon Phillipe\u0026apos;s method is to use the timeout in the \u0026lt;code\u0026gt;event\u0026lt;/code\u0026gt;\u0026apos;s \u0026lt;code\u0026gt;wait()\u0026lt;/code\u0026gt; method wherever you \u0026lt;code\u0026gt;sleep()\u0026lt;/code\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;For example:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;import\u0026lt;/span\u0026gt; threading\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;KillableThread\u0026lt;/span\u0026gt;(threading.Thread):\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;def\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;__init__\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;self, sleep_interval=\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;):\n        \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;super\u0026lt;/span\u0026gt;().__init__()\n        self._kill = threading.Event()\n        self._interval = sleep_interval\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;def\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;run\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;self\u0026lt;/span\u0026gt;):\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;while\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;True\u0026lt;/span\u0026gt;:\n            \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Do Something\u0026quot;\u0026lt;/span\u0026gt;)\n\n            \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;# If no kill signal is set, sleep for the interval,\u0026lt;/span\u0026gt;\n            \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;# If kill signal comes in while sleeping, immediately\u0026lt;/span\u0026gt;\n            \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;#  wake up and handle\u0026lt;/span\u0026gt;\n            is_killed = self._kill.wait(self._interval)\n            \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; is_killed:\n                \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;break\u0026lt;/span\u0026gt;\n\n        \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Killing Thread\u0026quot;\u0026lt;/span\u0026gt;)\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;def\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;kill\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;self\u0026lt;/span\u0026gt;):\n        self._kill.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;set\u0026lt;/span\u0026gt;()\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Then to run it\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;t = KillableThread(sleep_interval=\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;5\u0026lt;/span\u0026gt;)\nt.start()\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;# Every 5 seconds it prints:\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;#: Do Something\u0026lt;/span\u0026gt;\nt.kill()\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;#: Killing Thread\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;The advantage of using \u0026lt;code\u0026gt;wait()\u0026lt;/code\u0026gt; instead of \u0026lt;code\u0026gt;sleep()\u0026lt;/code\u0026gt;ing and regularly checking the event is that you can program in longer intervals of sleep, the thread is stopped almost immediately (when you would otherwise be \u0026lt;code\u0026gt;sleep()\u0026lt;/code\u0026gt;ing) and in my opinion, the code for handling exit is significantly simpler.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;You can kill a thread by installing trace into the thread that will exit the thread.   See attached link for one possible implementation.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;a href=\u0026quot;https://web.archive.org/web/20130503082442/http://mail.python.org/pipermail/python-list/2004-May/281943.html\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;Kill a thread in Python\u0026lt;/a\u0026gt; \u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;It is better if you don\u0026apos;t kill a thread.\nA way could be to introduce a \u0026quot;try\u0026quot; block into the thread\u0026apos;s cycle and to throw an exception when you want to stop the thread (for example a break/return/... that stops your for/while/...). \nI\u0026apos;ve used this on my app and it works...\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;It is definitely possible to implement a \u0026lt;code\u0026gt;Thread.stop\u0026lt;/code\u0026gt; method as shown in the following example code:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;import\u0026lt;/span\u0026gt; sys\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;import\u0026lt;/span\u0026gt; threading\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;import\u0026lt;/span\u0026gt; time\n\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;StopThread\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-title class_ inherited__\u0026quot;\u0026gt;StopIteration\u0026lt;/span\u0026gt;):\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;pass\u0026lt;/span\u0026gt;\n\nthreading.SystemExit = SystemExit, StopThread\n\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Thread2\u0026lt;/span\u0026gt;(threading.Thread):\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;def\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;stop\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;self\u0026lt;/span\u0026gt;):\n        self.__stop = \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;True\u0026lt;/span\u0026gt;\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;def\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;_bootstrap\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;self\u0026lt;/span\u0026gt;):\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; threading._trace_hook \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;is\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;not\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;None\u0026lt;/span\u0026gt;:\n            \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;raise\u0026lt;/span\u0026gt; ValueError(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;Cannot run thread with tracing!\u0026apos;\u0026lt;/span\u0026gt;)\n        self.__stop = \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;False\u0026lt;/span\u0026gt;\n        sys.settrace(self.__trace)\n        \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;super\u0026lt;/span\u0026gt;()._bootstrap()\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;def\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;__trace\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;self, frame, event, arg\u0026lt;/span\u0026gt;):\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; self.__stop:\n            \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;raise\u0026lt;/span\u0026gt; StopThread()\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; self.__trace\n\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Thread3\u0026lt;/span\u0026gt;(threading.Thread):\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;def\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;_bootstrap\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;self, stop_thread=\u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;False\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;):\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;def\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;stop\u0026lt;/span\u0026gt;():\n            \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;nonlocal\u0026lt;/span\u0026gt; stop_thread\n            stop_thread = \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;True\u0026lt;/span\u0026gt;\n        self.stop = stop\n\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;def\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;tracer\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;*_\u0026lt;/span\u0026gt;):\n            \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; stop_thread:\n                \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;raise\u0026lt;/span\u0026gt; StopThread()\n            \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; tracer\n        sys.settrace(tracer)\n        \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;super\u0026lt;/span\u0026gt;()._bootstrap()\n\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;###############################################################################\u0026lt;/span\u0026gt;\n\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;def\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;main\u0026lt;/span\u0026gt;():\n    test1 = Thread2(target=printer)\n    test1.start()\n    time.sleep(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;)\n    test1.stop()\n    test1.join()\n    test2 = Thread2(target=speed_test)\n    test2.start()\n    time.sleep(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;)\n    test2.stop()\n    test2.join()\n    test3 = Thread3(target=speed_test)\n    test3.start()\n    time.sleep(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;)\n    test3.stop()\n    test3.join()\n\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;def\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;printer\u0026lt;/span\u0026gt;():\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;while\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;True\u0026lt;/span\u0026gt;:\n        \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt;(time.time() % \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;)\n        time.sleep(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0.1\u0026lt;/span\u0026gt;)\n\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;def\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;speed_test\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;count=\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;):\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;try\u0026lt;/span\u0026gt;:\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;while\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;True\u0026lt;/span\u0026gt;:\n            count += \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;except\u0026lt;/span\u0026gt; StopThread:\n        \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;Count =\u0026apos;\u0026lt;/span\u0026gt;, count)\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; __name__ == \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;__main__\u0026apos;\u0026lt;/span\u0026gt;:\n    main()\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;The \u0026lt;code\u0026gt;Thread3\u0026lt;/code\u0026gt; class appears to run code approximately 33% faster than the \u0026lt;code\u0026gt;Thread2\u0026lt;/code\u0026gt; class.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;I\u0026apos;m way late to this game, but I\u0026apos;ve been wrestling with \u0026lt;a href=\u0026quot;https://stackoverflow.com/q/50473309/2123176\u0026quot;\u0026gt;a similar question\u0026lt;/a\u0026gt; and the following appears to both resolve the issue perfectly for me AND lets me do some basic thread state checking and cleanup when the daemonized sub-thread exits:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;import\u0026lt;/span\u0026gt; threading\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;import\u0026lt;/span\u0026gt; time\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;import\u0026lt;/span\u0026gt; atexit\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;def\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;do_work\u0026lt;/span\u0026gt;():\n\n  i = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;  @atexit.register\u0026lt;/span\u0026gt;\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;def\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;goodbye\u0026lt;/span\u0026gt;():\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt; (\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;\u0026apos;CLEANLY\u0026apos; kill sub-thread with value: %s [THREAD: %s]\u0026quot;\u0026lt;/span\u0026gt; %\n           (i, threading.currentThread().ident))\n\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;while\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;True\u0026lt;/span\u0026gt;:\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt; i\n    i += \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;\n    time.sleep(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;)\n\nt = threading.Thread(target=do_work)\nt.daemon = \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;True\u0026lt;/span\u0026gt;\nt.start()\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;def\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;after_timeout\u0026lt;/span\u0026gt;():\n  \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;KILL MAIN THREAD: %s\u0026quot;\u0026lt;/span\u0026gt; % threading.currentThread().ident\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;raise\u0026lt;/span\u0026gt; SystemExit\n\nthreading.Timer(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;, after_timeout).start()\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Yields:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;\nKILL MAIN THREAD: \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;140013208254208\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;CLEANLY\u0026apos;\u0026lt;/span\u0026gt; kill sub-thread \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;with\u0026lt;/span\u0026gt; value: \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt; [THREAD: \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;140013674317568\u0026lt;/span\u0026gt;]\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Following workaround can be used to kill a thread:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;kill_threads = \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;False\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;def\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;doSomething\u0026lt;/span\u0026gt;():\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;global\u0026lt;/span\u0026gt; kill_threads\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;while\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;True\u0026lt;/span\u0026gt;:\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; kill_threads:\n            thread.exit()\n        ......\n        ......\n\nthread.start_new_thread(doSomething, ())\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;This can be used even for terminating threads, whose code is written in another module, from main thread. We can declare a global variable in that module and use it to terminate thread/s spawned in that module.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;I usually use this to terminate all the threads at the program exit. This might not be the perfect way to terminate thread/s but could help.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;from\u0026lt;/span\u0026gt; ctypes \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;import\u0026lt;/span\u0026gt; *\npthread = cdll.LoadLibrary(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;libpthread-2.15.so\u0026quot;\u0026lt;/span\u0026gt;)\npthread.pthread_cancel(c_ulong(t.ident))\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;t\u0026lt;/strong\u0026gt; is your \u0026lt;code\u0026gt;Thread\u0026lt;/code\u0026gt; object.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Read the python source (\u0026lt;code\u0026gt;Modules/threadmodule.c\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;Python/thread_pthread.h\u0026lt;/code\u0026gt;) you can see the \u0026lt;code\u0026gt;Thread.ident\u0026lt;/code\u0026gt; is an \u0026lt;code\u0026gt;pthread_t\u0026lt;/code\u0026gt; type, so you can do anything \u0026lt;code\u0026gt;pthread\u0026lt;/code\u0026gt; can do in python use \u0026lt;code\u0026gt;libpthread\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Here\u0026apos;s yet another way to do it, but with extremely clean and simple code, that works in Python 3.7 in 2021:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;import\u0026lt;/span\u0026gt; ctypes \n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;def\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;kill_thread\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;thread\u0026lt;/span\u0026gt;):\n    \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;\u0026quot;\u0026quot;\n    thread: a threading.Thread object\n    \u0026quot;\u0026quot;\u0026quot;\u0026lt;/span\u0026gt;\n    thread_id = thread.ident\n    res = ctypes.pythonapi.PyThreadState_SetAsyncExc(thread_id, ctypes.py_object(SystemExit))\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; res \u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;:\n        ctypes.pythonapi.PyThreadState_SetAsyncExc(thread_id, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;)\n        \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;Exception raise failure\u0026apos;\u0026lt;/span\u0026gt;)\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;Adapted from here: \u0026lt;a href=\u0026quot;https://www.geeksforgeeks.org/python-different-ways-to-kill-a-thread/\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;https://www.geeksforgeeks.org/python-different-ways-to-kill-a-thread/\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;One thing I want to add is that if you read official documentation in \u0026lt;a href=\u0026quot;https://docs.python.org/2/library/threading.html\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;threading lib Python\u0026lt;/a\u0026gt;, it\u0026apos;s recommended to avoid use of \u0026quot;demonic\u0026quot; threads, when you don\u0026apos;t want threads end abruptly, with the flag that Paolo Rovelli \u0026lt;a href=\u0026quot;https://stackoverflow.com/a/15185771\u0026quot;\u0026gt;mentioned\u0026lt;/a\u0026gt;.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;From official documentation:\u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;Daemon threads are abruptly stopped at shutdown. Their resources (such as open files, database transactions, etc.) may not be released properly. If you want your threads to stop gracefully, make them non-daemonic and use a suitable signaling mechanism such as an Event.\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;p\u0026gt;I think that creating daemonic threads depends of your application, but in general (and in my opinion) it\u0026apos;s better to avoid killing them or making them daemonic. In multiprocessing you can use \u0026lt;code\u0026gt;is_alive()\u0026lt;/code\u0026gt; to check process status  and \u0026quot;terminate\u0026quot; for finish them (Also you avoid GIL problems). But you can find more problems, sometimes, when you execute your code in Windows.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;And always remember that if you have \u0026quot;live threads\u0026quot;, the Python interpreter will be running for wait them. (Because of this daemonic can help you if don\u0026apos;t matter abruptly ends).\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;There is a library built for this purpose, \u0026lt;a href=\u0026quot;https://pypi.org/project/stopit/\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;stopit\u0026lt;/a\u0026gt;. Although some of the same cautions listed herein still apply, at least this library presents a regular, repeatable technique for achieving the stated goal.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Asuming, that you want to have multiple threads of the same function, this is IMHO the easiest implementation to stop one by id:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;import\u0026lt;/span\u0026gt; time\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;from\u0026lt;/span\u0026gt; threading \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;import\u0026lt;/span\u0026gt; Thread\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;def\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;doit\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;id\u0026lt;/span\u0026gt;=\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;):\n    doit.stop=\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;start id:%d\u0026quot;\u0026lt;/span\u0026gt;%\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;id\u0026lt;/span\u0026gt;)\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;while\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;:\n        time.sleep(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;)\n        \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;.\u0026quot;\u0026lt;/span\u0026gt;)\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; doit.stop==\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;id\u0026lt;/span\u0026gt;:\n            doit.stop=\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;\n            \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;break\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;end thread %d\u0026quot;\u0026lt;/span\u0026gt;%\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;id\u0026lt;/span\u0026gt;)\n\nt5=Thread(target=doit, args=(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;5\u0026lt;/span\u0026gt;,))\nt6=Thread(target=doit, args=(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;6\u0026lt;/span\u0026gt;,))\n\nt5.start() ; t6.start()\ntime.sleep(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;)\ndoit.stop =\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;5\u0026lt;/span\u0026gt;  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;#kill t5\u0026lt;/span\u0026gt;\ntime.sleep(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;)\ndoit.stop =\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;6\u0026lt;/span\u0026gt;  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;#kill t6\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;The nice thing is here, you can have multiple of same and different functions, and stop them all by \u0026lt;code\u0026gt;functionname.stop\u0026lt;/code\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;If you want to have only one thread of the function then you don\u0026apos;t need to remember the id. Just stop, if \u0026lt;code\u0026gt;doit.stop\u0026lt;/code\u0026gt; \u0026amp;gt; 0.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Just to build up on @SCB\u0026apos;s idea (which was exactly what I needed) to create a KillableThread  subclass with a customized function:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;from\u0026lt;/span\u0026gt; threading \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;import\u0026lt;/span\u0026gt; Thread, Event\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;KillableThread\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-title class_ inherited__\u0026quot;\u0026gt;Thread\u0026lt;/span\u0026gt;):\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;def\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;__init__\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;self, sleep_interval=\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;, target=\u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;None\u0026lt;/span\u0026gt;, name=\u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;None\u0026lt;/span\u0026gt;, args=(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;), kwargs={}\u0026lt;/span\u0026gt;):\n        \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;super\u0026lt;/span\u0026gt;().__init__(\u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;None\u0026lt;/span\u0026gt;, target, name, args, kwargs)\n        self._kill = Event()\n        self._interval = sleep_interval\n        \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt;(self._target)\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;def\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;run\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;self\u0026lt;/span\u0026gt;):\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;while\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;True\u0026lt;/span\u0026gt;:\n            \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;# Call custom function with arguments\u0026lt;/span\u0026gt;\n            self._target(*self._args)\n\n            \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;# If no kill signal is set, sleep for the interval,\u0026lt;/span\u0026gt;\n            \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;# If kill signal comes in while sleeping, immediately\u0026lt;/span\u0026gt;\n            \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;#  wake up and handle\u0026lt;/span\u0026gt;\n            is_killed = self._kill.wait(self._interval)\n            \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; is_killed:\n                \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;break\u0026lt;/span\u0026gt;\n\n        \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Killing Thread\u0026quot;\u0026lt;/span\u0026gt;)\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;def\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;kill\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;self\u0026lt;/span\u0026gt;):\n        self._kill.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;set\u0026lt;/span\u0026gt;()\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; __name__ == \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;__main__\u0026apos;\u0026lt;/span\u0026gt;:\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;def\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;print_msg\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;msg\u0026lt;/span\u0026gt;):\n        \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt;(msg)\n\n    t = KillableThread(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;10\u0026lt;/span\u0026gt;, print_msg, args=(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;hello world\u0026quot;\u0026lt;/span\u0026gt;))\n    t.start()\n    time.sleep(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;6\u0026lt;/span\u0026gt;)\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;About to kill thread\u0026quot;\u0026lt;/span\u0026gt;)\n    t.kill()\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;Naturally, like with @SBC, the thread doesn\u0026apos;t wait to run a new loop to stop. In this example, you would see the \u0026quot;Killing Thread\u0026quot; message printed right after the \u0026quot;About to kill thread\u0026quot; instead of waiting for 4 more seconds for the thread to complete (since we have slept for 6 seconds already).\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Second argument in KillableThread constructor is your custom function (print_msg here). Args argument are the arguments that will be used when calling the function ((\u0026quot;hello world\u0026quot;)) here.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;While it\u0026apos;s rather old, \u0026lt;a href=\u0026quot;http://code.activestate.com/recipes/496960-thread2-killable-threads/\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;this\u0026lt;/a\u0026gt; might be a handy solution for some:  \u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;A little module that extends the threading\u0026apos;s module functionality --\n  allows one thread to raise exceptions in the context of another\n  thread. By raising \u0026lt;code\u0026gt;SystemExit\u0026lt;/code\u0026gt;, you can finally kill python threads.\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;import\u0026lt;/span\u0026gt; threading\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;import\u0026lt;/span\u0026gt; ctypes     \n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;def\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;_async_raise\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;tid, excobj\u0026lt;/span\u0026gt;):\n    res = ctypes.pythonapi.PyThreadState_SetAsyncExc(tid, ctypes.py_object(excobj))\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; res == \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;:\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;raise\u0026lt;/span\u0026gt; ValueError(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;nonexistent thread id\u0026quot;\u0026lt;/span\u0026gt;)\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;elif\u0026lt;/span\u0026gt; res \u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;:\n        \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;# \u0026quot;\u0026quot;\u0026quot;if it returns a number greater than one, you\u0026apos;re in trouble, \u0026lt;/span\u0026gt;\n        \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;# and you should call it again with exc=NULL to revert the effect\u0026quot;\u0026quot;\u0026quot;\u0026lt;/span\u0026gt;\n        ctypes.pythonapi.PyThreadState_SetAsyncExc(tid, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;)\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;raise\u0026lt;/span\u0026gt; SystemError(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;PyThreadState_SetAsyncExc failed\u0026quot;\u0026lt;/span\u0026gt;)\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Thread\u0026lt;/span\u0026gt;(threading.Thread):\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;def\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;raise_exc\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;self, excobj\u0026lt;/span\u0026gt;):\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;assert\u0026lt;/span\u0026gt; self.isAlive(), \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;thread must be started\u0026quot;\u0026lt;/span\u0026gt;\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt; tid, tobj \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;in\u0026lt;/span\u0026gt; threading._active.items():\n            \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; tobj \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;is\u0026lt;/span\u0026gt; self:\n                _async_raise(tid, excobj)\n                \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt;\n\n        \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;# the thread was alive when we entered the loop, but was not found \u0026lt;/span\u0026gt;\n        \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;# in the dict, hence it must have been already terminated. should we raise\u0026lt;/span\u0026gt;\n        \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;# an exception here? silently ignore?\u0026lt;/span\u0026gt;\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;def\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;terminate\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;self\u0026lt;/span\u0026gt;):\n        \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;# must raise the SystemExit type, instead of a SystemExit() instance\u0026lt;/span\u0026gt;\n        \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;# due to a bug in PyThreadState_SetAsyncExc\u0026lt;/span\u0026gt;\n        self.raise_exc(SystemExit)\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;So, it allows a \u0026quot;thread to raise exceptions in the context of another thread\u0026quot; and in this way, the terminated thread can handle the termination without regularly checking an abort flag.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;However, according to its \u0026lt;a href=\u0026quot;http://tomerfiliba.com/recipes/Thread2/\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;original source\u0026lt;/a\u0026gt;, there are some issues with this code.\u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;ul\u0026gt;\n  \u0026lt;li\u0026gt;The exception will be raised only when executing python bytecode. If    your thread calls a native/built-in blocking function, the\n  exception    will be raised only when execution returns to the python\n  code. \n  \n  \u0026lt;ul\u0026gt;\n  \u0026lt;li\u0026gt;There is also an issue if the built-in function internally calls    PyErr_Clear(), which would effectively cancel your pending exception. \n  You can try to raise it again.\u0026lt;/li\u0026gt;\n  \u0026lt;/ul\u0026gt;\u0026lt;/li\u0026gt;\n  \u0026lt;li\u0026gt;Only exception types can be raised    safely. Exception instances are likely to cause unexpected behavior,    and are thus restricted.\n  \n  \u0026lt;ul\u0026gt;\n  \u0026lt;li\u0026gt;For example: t1.raise_exc(TypeError) and    not t1.raise_exc(TypeError(\u0026quot;blah\u0026quot;)).\u0026lt;/li\u0026gt;\n  \u0026lt;li\u0026gt;IMHO it\u0026apos;s a bug, and I reported it as one. For more info,    \u0026lt;a href=\u0026quot;http://mail.python.org/pipermail/python-dev/2006-August/068158.html\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;http://mail.python.org/pipermail/python-dev/2006-August/068158.html\u0026lt;/a\u0026gt;  \u0026lt;/li\u0026gt;\n  \u0026lt;/ul\u0026gt;\u0026lt;/li\u0026gt;\n  \u0026lt;li\u0026gt;I asked to expose this function in the built-in thread module, but    since ctypes has become a standard library (as of 2.5), and this\u0026lt;br\u0026gt;\n  feature is not likely to be implementation-agnostic, it may be kept\u0026lt;br\u0026gt;\n  unexposed.\u0026lt;/li\u0026gt;\n  \u0026lt;/ul\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n    ","\n\u0026lt;p\u0026gt;As mentioned in @Kozyarchuk\u0026apos;s \u0026lt;a href=\u0026quot;https://stackoverflow.com/questions/323972/is-there-any-way-to-kill-a-thread/325027#325027\u0026quot;\u0026gt;answer\u0026lt;/a\u0026gt;, installing trace works. Since this answer contained no code, here is a working ready-to-use example:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;import\u0026lt;/span\u0026gt; sys, threading, time \n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;TraceThread\u0026lt;/span\u0026gt;(threading.Thread): \n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;def\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;__init__\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;self, *args, **keywords\u0026lt;/span\u0026gt;): \n        threading.Thread.__init__(self, *args, **keywords) \n        self.killed = \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;False\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;def\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;start\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;self\u0026lt;/span\u0026gt;): \n        self._run = self.run \n        self.run = self.settrace_and_run\n        threading.Thread.start(self) \n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;def\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;settrace_and_run\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;self\u0026lt;/span\u0026gt;): \n        sys.settrace(self.globaltrace) \n        self._run()\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;def\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;globaltrace\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;self, frame, event, arg\u0026lt;/span\u0026gt;): \n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; self.localtrace \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; event == \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;call\u0026apos;\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;else\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;None\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;def\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;localtrace\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;self, frame, event, arg\u0026lt;/span\u0026gt;): \n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; self.killed \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;and\u0026lt;/span\u0026gt; event == \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;line\u0026apos;\u0026lt;/span\u0026gt;: \n            \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;raise\u0026lt;/span\u0026gt; SystemExit() \n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; self.localtrace \n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;def\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;f\u0026lt;/span\u0026gt;(): \n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;while\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;True\u0026lt;/span\u0026gt;: \n        \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;1\u0026apos;\u0026lt;/span\u0026gt;) \n        time.sleep(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;)\n        \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;2\u0026apos;\u0026lt;/span\u0026gt;) \n        time.sleep(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;)\n        \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;3\u0026apos;\u0026lt;/span\u0026gt;) \n        time.sleep(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;)\n\nt = TraceThread(target=f) \nt.start() \ntime.sleep(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2.5\u0026lt;/span\u0026gt;) \nt.killed = \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;True\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;It stops after having printed \u0026lt;code\u0026gt;1\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;2\u0026lt;/code\u0026gt;. \u0026lt;code\u0026gt;3\u0026lt;/code\u0026gt; is not printed.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Python version: 3.8\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Using daemon thread to execute what we wanted, if we want to daemon thread be terminated, all we need is making parent thread exit, then system will terminate daemon thread which parent thread created.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Also support coroutine and coroutine function.\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;def\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;main\u0026lt;/span\u0026gt;():\n    start_time = time.perf_counter()\n    t1 = ExitThread(time.sleep, (\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;10\u0026lt;/span\u0026gt;,), debug=\u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;False\u0026lt;/span\u0026gt;)\n    t1.start()\n    time.sleep(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0.5\u0026lt;/span\u0026gt;)\n    t1.exit()\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;try\u0026lt;/span\u0026gt;:\n        \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt;(t1.result_future.result())\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;except\u0026lt;/span\u0026gt; concurrent.futures.CancelledError:\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;pass\u0026lt;/span\u0026gt;\n    end_time = time.perf_counter()\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;f\u0026quot;time cost \u0026lt;span class=\u0026quot;hljs-subst\u0026quot;\u0026gt;{end_time - start_time:\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0.2\u0026lt;/span\u0026gt;f}\u0026lt;/span\u0026gt;\u0026quot;\u0026lt;/span\u0026gt;)\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;below is ExitThread source code\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;import\u0026lt;/span\u0026gt; concurrent.futures\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;import\u0026lt;/span\u0026gt; threading\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;import\u0026lt;/span\u0026gt; typing\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;import\u0026lt;/span\u0026gt; asyncio\n\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;_WorkItem\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-title class_ inherited__\u0026quot;\u0026gt;object\u0026lt;/span\u0026gt;):\n    \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;\u0026quot;\u0026quot; concurrent\\futures\\thread.py\n\n    \u0026quot;\u0026quot;\u0026quot;\u0026lt;/span\u0026gt;\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;def\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;__init__\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;self, future, fn, args, kwargs, *, debug=\u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;None\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;):\n        self._debug = debug\n        self.future = future\n        self.fn = fn\n        self.args = args\n        self.kwargs = kwargs\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;def\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;run\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;self\u0026lt;/span\u0026gt;):\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; self._debug:\n            \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;ExitThread._WorkItem run\u0026quot;\u0026lt;/span\u0026gt;)\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;not\u0026lt;/span\u0026gt; self.future.set_running_or_notify_cancel():\n            \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt;\n\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;try\u0026lt;/span\u0026gt;:\n            coroutine = \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;None\u0026lt;/span\u0026gt;\n            \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; asyncio.iscoroutinefunction(self.fn):\n                coroutine = self.fn(*self.args, **self.kwargs)\n            \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;elif\u0026lt;/span\u0026gt; asyncio.iscoroutine(self.fn):\n                coroutine = self.fn\n            \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; coroutine \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;is\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;None\u0026lt;/span\u0026gt;:\n                result = self.fn(*self.args, **self.kwargs)\n            \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;else\u0026lt;/span\u0026gt;:\n                result = asyncio.run(coroutine)\n            \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; self._debug:\n                \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;_WorkItem done\u0026quot;\u0026lt;/span\u0026gt;)\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;except\u0026lt;/span\u0026gt; BaseException \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;as\u0026lt;/span\u0026gt; exc:\n            self.future.set_exception(exc)\n            \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;# Break a reference cycle with the exception \u0026apos;exc\u0026apos;\u0026lt;/span\u0026gt;\n            self = \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;None\u0026lt;/span\u0026gt;\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;else\u0026lt;/span\u0026gt;:\n            self.future.set_result(result)\n\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;ExitThread\u0026lt;/span\u0026gt;:\n    \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;\u0026quot;\u0026quot; Like a stoppable thread\n\n    Using coroutine for target then exit before running may cause RuntimeWarning.\n\n    \u0026quot;\u0026quot;\u0026quot;\u0026lt;/span\u0026gt;\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;def\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;__init__\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;self, target: typing.\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;Union\u0026lt;/span\u0026gt;[typing.\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;Coroutine\u0026lt;/span\u0026gt;, typing.\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;Callable\u0026lt;/span\u0026gt;] = \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;None\u0026lt;/span\u0026gt;\n                 , args=(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;), kwargs={}, *, daemon=\u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;None\u0026lt;/span\u0026gt;, debug=\u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;None\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;):\n        \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;#\u0026lt;/span\u0026gt;\n        self._debug = debug\n        self._parent_thread = threading.Thread(target=self._parent_thread_run, name=\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;ExitThread_parent_thread\u0026quot;\u0026lt;/span\u0026gt;\n                                               , daemon=daemon)\n        self._child_daemon_thread = \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;None\u0026lt;/span\u0026gt;\n        self.result_future = concurrent.futures.Future()\n        self._workItem = _WorkItem(self.result_future, target, args, kwargs, debug=debug)\n        self._parent_thread_exit_lock = threading.Lock()\n        self._parent_thread_exit_lock.acquire()\n        self._parent_thread_exit_lock_released = \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;False\u0026lt;/span\u0026gt;  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;# When done it will be True\u0026lt;/span\u0026gt;\n        self._started = \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;False\u0026lt;/span\u0026gt;\n        self._exited = \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;False\u0026lt;/span\u0026gt;\n        self.result_future.add_done_callback(self._release_parent_thread_exit_lock)\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;def\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;_parent_thread_run\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;self\u0026lt;/span\u0026gt;):\n        self._child_daemon_thread = threading.Thread(target=self._child_daemon_thread_run\n                                                     , name=\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;ExitThread_child_daemon_thread\u0026quot;\u0026lt;/span\u0026gt;\n                                                     , daemon=\u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;True\u0026lt;/span\u0026gt;)\n        self._child_daemon_thread.start()\n        \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;# Block manager thread\u0026lt;/span\u0026gt;\n        self._parent_thread_exit_lock.acquire()\n        self._parent_thread_exit_lock.release()\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; self._debug:\n            \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;ExitThread._parent_thread_run exit\u0026quot;\u0026lt;/span\u0026gt;)\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;def\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;_release_parent_thread_exit_lock\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;self, _future\u0026lt;/span\u0026gt;):\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; self._debug:\n            \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;f\u0026quot;ExitThread._release_parent_thread_exit_lock \u0026lt;span class=\u0026quot;hljs-subst\u0026quot;\u0026gt;{self._parent_thread_exit_lock_released}\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-subst\u0026quot;\u0026gt;{_future}\u0026lt;/span\u0026gt;\u0026quot;\u0026lt;/span\u0026gt;)\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;not\u0026lt;/span\u0026gt; self._parent_thread_exit_lock_released:\n            self._parent_thread_exit_lock_released = \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;True\u0026lt;/span\u0026gt;\n            self._parent_thread_exit_lock.release()\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;def\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;_child_daemon_thread_run\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;self\u0026lt;/span\u0026gt;):\n        self._workItem.run()\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;def\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;start\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;self\u0026lt;/span\u0026gt;):\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; self._debug:\n            \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;f\u0026quot;ExitThread.start \u0026lt;span class=\u0026quot;hljs-subst\u0026quot;\u0026gt;{self._started}\u0026lt;/span\u0026gt;\u0026quot;\u0026lt;/span\u0026gt;)\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;not\u0026lt;/span\u0026gt; self._started:\n            self._started = \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;True\u0026lt;/span\u0026gt;\n            self._parent_thread.start()\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;def\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;exit\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;self\u0026lt;/span\u0026gt;):\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; self._debug:\n            \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;f\u0026quot;ExitThread.exit exited: \u0026lt;span class=\u0026quot;hljs-subst\u0026quot;\u0026gt;{self._exited}\u0026lt;/span\u0026gt; lock_released: \u0026lt;span class=\u0026quot;hljs-subst\u0026quot;\u0026gt;{self._parent_thread_exit_lock_released}\u0026lt;/span\u0026gt;\u0026quot;\u0026lt;/span\u0026gt;)\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; self._parent_thread_exit_lock_released:\n            \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt;\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;not\u0026lt;/span\u0026gt; self._exited:\n            self._exited = \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;True\u0026lt;/span\u0026gt;\n            \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;not\u0026lt;/span\u0026gt; self.result_future.cancel():\n                \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; self.result_future.running():\n                    self.result_future.set_exception(concurrent.futures.CancelledError())\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;This seems to work with pywin32 on windows 7\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;my_thread = threading.Thread()\nmy_thread.start()\nmy_thread._Thread__stop()\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Pieter Hintjens -- one of the founders of the \u0026lt;a href=\u0026quot;http://zguide.zeromq.org/py:all\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;ØMQ\u0026lt;/a\u0026gt;-project -- says, using ØMQ and avoiding synchronization primitives like locks, mutexes, events etc., is the sanest and securest way to write multi-threaded programs:\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;a href=\u0026quot;http://zguide.zeromq.org/py:all#Multithreading-with-ZeroMQ\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;http://zguide.zeromq.org/py:all#Multithreading-with-ZeroMQ\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;This includes telling a child thread, that it should cancel its work. This would be done by equipping the thread with a ØMQ-socket and polling on that socket for a message saying that it should cancel.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;The link also provides an example on multi-threaded python code with ØMQ.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;An alternative is to use \u0026lt;a href=\u0026quot;https://docs.python.org/3/library/signal.html#signal.pthread_kill\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;\u0026lt;code\u0026gt;signal.pthread_kill\u0026lt;/code\u0026gt;\u0026lt;/a\u0026gt; to send a stop signal.\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;from\u0026lt;/span\u0026gt; signal \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;import\u0026lt;/span\u0026gt; pthread_kill, SIGTSTP\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;from\u0026lt;/span\u0026gt; threading \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;import\u0026lt;/span\u0026gt; Thread\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;from\u0026lt;/span\u0026gt; itertools \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;import\u0026lt;/span\u0026gt; count\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;from\u0026lt;/span\u0026gt; time \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;import\u0026lt;/span\u0026gt; sleep\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;def\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;target\u0026lt;/span\u0026gt;():\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt; num \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;in\u0026lt;/span\u0026gt; count():\n        \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt;(num)\n        sleep(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;)\n\nthread = Thread(target=target)\nthread.start()\nsleep(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;5\u0026lt;/span\u0026gt;)\npthread_kill(thread.ident, SIGTSTP)\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;result\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-bash s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-bash\u0026quot;\u0026gt;0\n1\n2\n3\n4\n\n[14]+  Stopped\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;If you really need the ability to kill a sub-task, use an alternate implementation. \u0026lt;code\u0026gt;multiprocessing\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;gevent\u0026lt;/code\u0026gt; both support indiscriminately killing a \u0026quot;thread\u0026quot;.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Python\u0026apos;s threading does not support cancellation. Do not even try. Your code is very likely to deadlock, corrupt or leak memory, or have other unintended \u0026quot;interesting\u0026quot; hard-to-debug effects which happen rarely and nondeterministically.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;You can execute your command in a process and then kill it using the process id.\nI needed to sync between two thread one of which  doesnt return by itself.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;processIds = []\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;def\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;executeRecord\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;command\u0026lt;/span\u0026gt;):\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt;(command)\n\n    process = subprocess.Popen(command, stdout=subprocess.PIPE)\n    processIds.append(process.pid)\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt;(processIds[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;])\n\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;#Command that doesn\u0026apos;t return by itself\u0026lt;/span\u0026gt;\n    process.stdout.read().decode(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;utf-8\u0026quot;\u0026lt;/span\u0026gt;)\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt;;\n\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;def\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;recordThread\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;command, timeOut\u0026lt;/span\u0026gt;):\n\n    thread = Thread(target=executeRecord, args=(command,))\n    thread.start()\n    thread.join(timeOut)\n\n    os.kill(processIds.pop(), signal.SIGINT)\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt;;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;The most simple way is this:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;from\u0026lt;/span\u0026gt; threading \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;import\u0026lt;/span\u0026gt; Thread\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;from\u0026lt;/span\u0026gt; time \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;import\u0026lt;/span\u0026gt; sleep\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;def\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;do_something\u0026lt;/span\u0026gt;():\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;global\u0026lt;/span\u0026gt; thread_work\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;while\u0026lt;/span\u0026gt; thread_work:\n        \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;doing something\u0026apos;\u0026lt;/span\u0026gt;)\n        sleep(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;5\u0026lt;/span\u0026gt;)\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;Thread stopped\u0026apos;\u0026lt;/span\u0026gt;)\n\nthread_work = \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;True\u0026lt;/span\u0026gt;\nThread(target=do_something).start()\nsleep(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;5\u0026lt;/span\u0026gt;)\nthread_work = \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;False\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;This is a bad answer, see the comments\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;p\u0026gt;Here\u0026apos;s how to do it:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;from\u0026lt;/span\u0026gt; threading \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;import\u0026lt;/span\u0026gt; *\n\n...\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt; thread \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;in\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;enumerate\u0026lt;/span\u0026gt;():\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; thread.isAlive():\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;try\u0026lt;/span\u0026gt;:\n            thread._Thread__stop()\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;except\u0026lt;/span\u0026gt;:\n            \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;str\u0026lt;/span\u0026gt;(thread.getName()) + \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos; could not be terminated\u0026apos;\u0026lt;/span\u0026gt;))\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Give it a few seconds then your thread should be stopped. Check also the \u0026lt;code\u0026gt;thread._Thread__delete()\u0026lt;/code\u0026gt; method.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;I\u0026apos;d recommend a \u0026lt;code\u0026gt;thread.quit()\u0026lt;/code\u0026gt; method for convenience. For example if you have a socket in your thread, I\u0026apos;d recommend creating a \u0026lt;code\u0026gt;quit()\u0026lt;/code\u0026gt; method in your socket-handle class, terminate the socket, then run a \u0026lt;code\u0026gt;thread._Thread__stop()\u0026lt;/code\u0026gt; inside of your \u0026lt;code\u0026gt;quit()\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n    "],"id":399,"title":"Is there any way to kill a Thread?","content":"\n                \n\u0026lt;p\u0026gt;Is it possible to terminate a running thread without setting/checking any flags/semaphores/etc.?\u0026lt;/p\u0026gt;\n    ","slug":"is-there-any-way-to-kill-a-thread-1657387859831","postType":"QUESTION","createdAt":"2022-07-09T17:30:59.000Z","updatedAt":"2022-07-09T17:30:59.000Z","tags":[{"id":2148,"name":"kill","slug":"kill","createdAt":"2022-07-09T17:30:59.000Z","updatedAt":"2022-07-09T17:30:59.000Z","Questions_Tags":{"questionId":399,"tagId":2148}},{"id":2149,"name":"terminate","slug":"terminate","createdAt":"2022-07-09T17:30:59.000Z","updatedAt":"2022-07-09T17:30:59.000Z","Questions_Tags":{"questionId":399,"tagId":2149}}],"relatedQuestions":[{"title":"Is there any way to kill a Thread?","slug":"is-there-any-way-to-kill-a-thread-1657387859831","tags":[{"name":"kill","Questions_Tags":{"questionId":399,"tagId":2148}},{"name":"terminate","Questions_Tags":{"questionId":399,"tagId":2149}}]}]},"randomQuestions":[{"title":"var functionName = function() {} vs function functionName() {}","slug":"var-functionname-function()-vs-function-functionname()-1657384724077"},{"title":"Transitions on the CSS display property","slug":"transitions-on-the-css-display-property-1657387761601"},{"title":"Calculate distance between two latitude-longitude points? (Haversine formula)","slug":"calculate-distance-between-two-latitude-longitude-points-(haversine-formula)-1657388500103"},{"title":"Undefined behavior and sequence points","slug":"undefined-behavior-and-sequence-points-1657384639493"},{"title":"How do you get the footer to stay at the bottom of a Web page?","slug":"how-do-you-get-the-footer-to-stay-at-the-bottom-of-a-web-page-1657387817544"},{"title":"Flatten an irregular list of lists","slug":"flatten-an-irregular-list-of-lists-1657387315571"},{"title":"Selecting and manipulating CSS pseudo-elements such as ::before and ::after using javascript (or jQuery)","slug":"selecting-and-manipulating-css-pseudo-elements-such-as-::before-and-::after-using-javascript-(or-jquery)-1657387406132"},{"title":"Why does Tkinter image not show up if created in a function?","slug":"why-does-tkinter-image-not-show-up-if-created-in-a-function-1657387388233"},{"title":"How to check if element is visible after scrolling?","slug":"how-to-check-if-element-is-visible-after-scrolling-1657387987960"},{"title":"Default constructor with empty brackets","slug":"default-constructor-with-empty-brackets-1657388246967"},{"title":"Iterating over dictionaries using 'for' loops","slug":"iterating-over-dictionaries-using-'for'-loops-1657388334481"},{"title":"How do I detect collision in pygame?","slug":"how-do-i-detect-collision-in-pygame-1657387496338"},{"title":"How can I return pivot table output in MySQL?","slug":"how-can-i-return-pivot-table-output-in-mysql-1657384715043"},{"title":"How to parse JSON in Java","slug":"how-to-parse-json-in-java-1657384575136"},{"title":"Aggregate / summarize multiple variables per group (e.g. sum, mean)","slug":"aggregate-summarize-multiple-variables-per-group-(e.g.-sum-mean)-1657387764061"},{"title":"Daylight saving time and time zone best practices [closed]","slug":"daylight-saving-time-and-time-zone-best-practices-closed-1657387973687"},{"title":"What is the difference between a deep copy and a shallow copy?","slug":"what-is-the-difference-between-a-deep-copy-and-a-shallow-copy-1657388445063"},{"title":"Why is using the JavaScript eval function a bad idea?","slug":"why-is-using-the-javascript-eval-function-a-bad-idea-1657387485165"},{"title":"What's the difference between INNER JOIN, LEFT JOIN, RIGHT JOIN and FULL JOIN? [duplicate]","slug":"what's-the-difference-between-inner-join-left-join-right-join-and-full-join-duplicate-1657388082887"},{"title":"JavaScript closure inside loops – simple practical example","slug":"javascript-closure-inside-loops-simple-practical-example-1657384278449"}]},"__N_SSG":true},"page":"/questions/[slug]","query":{"slug":"is-there-any-way-to-kill-a-thread-1657387859831"},"buildId":"DSpI0pSdXueTMCIVyw0q4","isFallback":false,"gsp":true,"locale":"en","locales":["en"],"defaultLocale":"en","scriptLoader":[]}</script></body></html>