<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><meta name="twitter:card" content="summary_large_image"/><meta name="twitter:site" content="@solutionschecker.com"/><meta name="twitter:creator" content="@solutionschecker.com"/><meta property="og:url" content="https://solutionschecker.com"/><meta property="og:type" content="website"/><meta property="og:image" content="https://solutionschecker.com/solutions-checker-banner.png"/><meta property="og:image:alt" content="Find the solution to any question. We focus on finding the fastest possible solution for users. Main topics like coding, learning. - solutionschecker.com"/><link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png"/><link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png"/><link rel="manifest" href="/site.webmanifest"/><script type="application/ld+json">{"@context":"https://schema.org","@type":"Organization","logo":"/logo.svg","url":"https://solutionschecker.com"}</script><link name="keywords" content="scope,solutions checker, solution checker, how to, solution for, check for solution, resolve question, what is, what solution for, find solution"/><script type="application/ld+json">{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"item":{"@id":"https://solutionschecker.com","name":"Home"}},{"@type":"ListItem","position":2,"item":{"@id":"https://solutionschecker.com/questions","name":"Questions"}},{"@type":"ListItem","position":3,"item":{"@id":"https://solutionschecker.com/questions/how-do-javascript-closures-work-1657384418555","name":"Questions"}}]}</script><title>How do JavaScript closures work? | Solution Checker</title><meta name="robots" content="index,follow"/><meta name="description" content="
            
        
            
                    
                        
                    
                
                    
                        This question&#x27;s answers are a community effort. Edit existing answers to improve this post. It is not currently accepting new answers or interactions.
                        
                    
                
            
        


    

How would you explain JavaScript closures to someone with a knowledge of the concepts they consist of (for example functions, variables and the like), but does not understand closures themselves?

I have seen the Scheme example given on Wikipedia, but unfortunately it did not help.
    "/><meta property="og:title" content="How do JavaScript closures work? | Solution Checker"/><meta property="og:description" content="
            
        
            
                    
                        
                    
                
                    
                        This question&#x27;s answers are a community effort. Edit existing answers to improve this post. It is not currently accepting new answers or interactions.
                        
                    
                
            
        


    

How would you explain JavaScript closures to someone with a knowledge of the concepts they consist of (for example functions, variables and the like), but does not understand closures themselves?

I have seen the Scheme example given on Wikipedia, but unfortunately it did not help.
    "/><script type="application/ld+json">{"@context":"https://schema.org","@type":"QAPage","mainEntity":{"name":"How do JavaScript closures work?","text":"\n            \n        \n            \n                    \n                        \n                    \n                \n                    \n                        This question&apos;s answers are a community effort. Edit existing answers to improve this post. It is not currently accepting new answers or interactions.\n                        \n                    \n                \n            \n        \n\n\n    \n\nHow would you explain JavaScript closures to someone with a knowledge of the concepts they consist of (for example functions, variables and the like), but does not understand closures themselves?\n\nI have seen the Scheme example given on Wikipedia, but unfortunately it did not help.\n    ","answerCount":30,"upVoteCount":500,"suggestedAnswer":[{"text":"A closure is a pairing of:\n\nA function and\nA reference to that function&apos;s outer scope (lexical environment)\n\nA lexical environment is part of every execution context (stack frame) and is a map between identifiers (i.e. local variable names) and values.\nEvery function in JavaScript maintains a reference to its outer lexical environment. This reference is used to configure the execution context created when a function is invoked. This reference enables code inside the function to &quot;see&quot; variables declared outside the function, regardless of when and where the function is called.\nIf a function was called by a function, which in turn was called by another function, then a chain of references to outer lexical environments is created. This chain is called the scope chain.\nIn the following code, inner forms a closure with the lexical environment of the execution context created when foo is invoked, closing over variable secret:\n\n\nfunction foo() {\n  const secret = Math.trunc(Math.random() * 100)\n  return function inner() {\n    console.log(`The secret number is ${secret}.`)\n  }\n}\nconst f = foo() // `secret` is not directly accessible from outside `foo`\nf() // The only way to retrieve `secret`, is to invoke `f`\n Run code snippetHide resultsExpand snippet\n\n\nIn other words: in JavaScript, functions carry a reference to a private &quot;box of state&quot;, to which only they (and any other functions declared within the same lexical environment) have access. This box of the state is invisible to the caller of the function, delivering an excellent mechanism for data-hiding and encapsulation.\nAnd remember: functions in JavaScript can be passed around like variables (first-class functions), meaning these pairings of functionality and state can be passed around your program: similar to how you might pass an instance of a class around in C++.\nIf JavaScript did not have closures, then more states would have to be passed between functions explicitly, making parameter lists longer and code noisier.\nSo, if you want a function to always have access to a private piece of state, you can use a closure.\n...and frequently we do want to associate the state with a function. For example, in Java or C++, when you add a private instance variable and a method to a class, you are associating the state with functionality.\nIn C and most other common languages, after a function returns, all the local variables are no longer accessible because the stack-frame is destroyed. In JavaScript, if you declare a function within another function, then the local variables of the outer function can remain accessible after returning from it. In this way, in the code above, secret remains available to the function object inner, after it has been returned from foo.\nUses of Closures\nClosures are useful whenever you need a private state associated with a function. This is a very common scenario - and remember: JavaScript did not have a class syntax until 2015, and it still does not have a private field syntax. Closures meet this need.\nPrivate Instance Variables\nIn the following code, the function toString closes over the details of the car.\n\n\nfunction Car(manufacturer, model, year, color) {\n  return {\n    toString() {\n      return `${manufacturer} ${model} (${year}, ${color})`\n    }\n  }\n}\n\nconst car = new Car(&apos;Aston Martin&apos;, &apos;V8 Vantage&apos;, &apos;2012&apos;, &apos;Quantum Silver&apos;)\nconsole.log(car.toString())\n Run code snippetHide resultsExpand snippet\n\n\nFunctional Programming\nIn the following code, the function inner closes over both fn and args.\n\n\nfunction curry(fn) {\n  const args = []\n  return function inner(arg) {\n    if(args.length === fn.length) return fn(...args)\n    args.push(arg)\n    return inner\n  }\n}\n\nfunction add(a, b) {\n  return a + b\n}\n\nconst curriedAdd = curry(add)\nconsole.log(curriedAdd(2)(3)()) // 5\n Run code snippetHide resultsExpand snippet\n\n\nEvent-Oriented Programming\nIn the following code, function onClick closes over variable BACKGROUND_COLOR.\n\n\nconst $ = document.querySelector.bind(document)\nconst BACKGROUND_COLOR = &apos;rgba(200, 200, 242, 1)&apos;\n\nfunction onClick() {\n  $(&apos;body&apos;).style.background = BACKGROUND_COLOR\n}\n\n$(&apos;button&apos;).addEventListener(&apos;click&apos;, onClick)\n&lt;button&gt;Set background color&lt;/button&gt;\n Run code snippetHide resultsExpand snippet\n\n\nModularization\nIn the following example, all the implementation details are hidden inside an immediately executed function expression. The functions tick and toString close over the private state and functions they need to complete their work. Closures have enabled us to modularize and encapsulate our code.\n\n\nlet namespace = {};\n\n(function foo(n) {\n  let numbers = []\n\n  function format(n) {\n    return Math.trunc(n)\n  }\n\n  function tick() {\n    numbers.push(Math.random() * 100)\n  }\n\n  function toString() {\n    return numbers.map(format)\n  }\n\n  n.counter = {\n    tick,\n    toString\n  }\n}(namespace))\n\nconst counter = namespace.counter\ncounter.tick()\ncounter.tick()\nconsole.log(counter.toString())\n Run code snippetHide resultsExpand snippet\n\n\nExamples\nExample 1\nThis example shows that the local variables are not copied in the closure: the closure maintains a reference to the original variables themselves. It is as though the stack-frame stays alive in memory even after the outer function exits.\n\n\nfunction foo() {\n  let x = 42\n  let inner = () =&gt; console.log(x)\n  x = x + 1\n  return inner\n}\n\nfoo()() // logs 43\n Run code snippetHide resultsExpand snippet\n\n\nExample 2\nIn the following code, three methods log, increment, and update all close over the same lexical environment.\nAnd every time createObject is called, a new execution context (stack frame) is created and a completely new variable x, and a new set of functions (log etc.) are created, that close over this new variable.\n\n\nfunction createObject() {\n  let x = 42;\n  return {\n    log() { console.log(x) },\n    increment() { x++ },\n    update(value) { x = value }\n  }\n}\n\nconst o = createObject()\no.increment()\no.log() // 43\no.update(5)\no.log() // 5\nconst p = createObject()\np.log() // 42\n Run code snippetHide resultsExpand snippet\n\n\nExample 3\nIf you are using variables declared using var, be careful you understand which variable you are closing over. Variables declared using var are hoisted. This is much less of a problem in modern JavaScript due to the introduction of let and const.\nIn the following code, each time around the loop, a new function inner is created, which closes over i. But because var i is hoisted outside the loop, all of these inner functions close over the same variable, meaning that the final value of i (3) is printed, three times.\n\n\nfunction foo() {\n  var result = []\n  for (var i = 0; i &lt; 3; i++) {\n    result.push(function inner() { console.log(i) } )\n  }\n\n  return result\n}\n\nconst result = foo()\n// The following will print `3`, three times...\nfor (var i = 0; i &lt; 3; i++) {\n  result[i]() \n}\n Run code snippetHide resultsExpand snippet\n\n\nFinal points:\n\nWhenever a function is declared in JavaScript closure is created.\nReturning a function from inside another function is the classic example of closure, because the state inside the outer function is implicitly available to the returned inner function, even after the outer function has completed execution.\nWhenever you use eval() inside a function, a closure is used. The text you eval can reference local variables of the function, and in the non-strict mode, you can even create new local variables by using eval(&apos;var foo = &apos;).\nWhen you use new Function() (the Function constructor) inside a function, it does not close over its lexical environment: it closes over the global context instead. The new function cannot reference the local variables of the outer function.\nA closure in JavaScript is like keeping a reference (NOT a copy) to the scope at the point of function declaration, which in turn keeps a reference to its outer scope, and so on, all the way to the global object at the top of the scope chain.\nA closure is created when a function is declared; this closure is used to configure the execution context when the function is invoked.\nA new set of local variables is created every time a function is called.\n\nLinks\n\nDouglas Crockford&apos;s simulated private attributes and private methods for an object, using closures.\nA great explanation of how closures can cause memory leaks in IE if you are not careful.\nMDN documentation on JavaScript Closures.\n\n    ","url":"https://solutionschecker.com/questions/how-do-javascript-closures-work-1657384418555#solution1","@type":"Answer","upvoteCount":0},{"text":"Every function in JavaScript maintains a link to its outer lexical environment. A lexical environment is a map of all the names (eg. variables, parameters) within a scope, with their values.\n\nSo, whenever you see the function keyword, code inside that function has access to variables declared outside the function.\n\n\n\nfunction foo(x) {\n  var tmp = 3;\n\n  function bar(y) {\n    console.log(x + y + (++tmp)); // will log 16\n  }\n\n  bar(10);\n}\n\nfoo(2);\n Run code snippetHide resultsExpand snippet\n\n\n\nThis will log 16 because function bar closes over the parameter x and the variable tmp, both of which exist in the lexical environment of outer function foo.\n\nFunction bar, together with its link with the lexical environment of function foo is a closure. \n\nA function doesn&apos;t have to return in order to create a closure. Simply by virtue of its declaration, every function closes over its enclosing lexical environment, forming a closure.\n\n\n\nfunction foo(x) {\n  var tmp = 3;\n\n  return function (y) {\n    console.log(x + y + (++tmp)); // will also log 16\n  }\n}\n\nvar bar = foo(2);\nbar(10); // 16\nbar(10); // 17\n Run code snippetHide resultsExpand snippet\n\n\n\nThe above function will also log 16, because the code inside bar can still refer to argument x and variable tmp, even though they are no longer directly in scope.\n\nHowever, since tmp is still hanging around inside bar&apos;s closure, it is available to be incremented. It will be incremented each time you call bar.\n\nThe simplest example of a closure is this:\n\n\n\nvar a = 10;\n\nfunction test() {\n  console.log(a); // will output 10\n  console.log(b); // will output 6\n}\nvar b = 6;\ntest();\n Run code snippetHide resultsExpand snippet\n\n\n\nWhen a JavaScript function is invoked, a new execution context ec is created. Together with the function arguments and the target object, this execution context also receives a link to the lexical environment of the calling execution context, meaning the variables declared in the outer lexical environment (in the above example, both a and b) are available from ec.\n\nEvery function creates a closure because every function has a link to its outer lexical environment. \n\nNote that variables themselves are visible from within a closure, not copies.\n    ","url":"https://solutionschecker.com/questions/how-do-javascript-closures-work-1657384418555#solution2","@type":"Answer","upvoteCount":0},{"text":"FOREWORD: this answer was written when the question was:\n\n\n  Like the old Albert said : &quot;If you can&apos;t explain it to a six-year old, you really don&apos;t understand it yourself.. Well I tried to explain JS closures to a 27 years old friend and completely failed.\n  \n  Can anybody consider that I am 6 and strangely interested in that subject ?\n\n\nI&apos;m pretty sure I was one of the only people that attempted to take the initial question literally. Since then, the question has mutated several times, so my answer may now seem incredibly silly &amp; out of place. Hopefully the general idea of the story remains fun for some.\n\n\n\nI&apos;m a big fan of analogy and metaphor when explaining difficult concepts, so let me try my hand with a story.\n\nOnce upon a time:\n\nThere was a princess...\n\nfunction princess() {\n\n\nShe lived in a wonderful world full of adventures. She met her Prince Charming, rode around her world on a unicorn, battled dragons, encountered talking animals, and many other fantastical things.\n\n    var adventures = [];\n\n    function princeCharming() { /* ... */ }\n\n    var unicorn = { /* ... */ },\n        dragons = [ /* ... */ ],\n        squirrel = &quot;Hello!&quot;;\n\n    /* ... */\n\n\nBut she would always have to return back to her dull world of chores and grown-ups.\n\n    return {\n\n\nAnd she would often tell them of her latest amazing adventure as a princess.\n\n        story: function() {\n            return adventures[adventures.length - 1];\n        }\n    };\n}\n\n\nBut all they would see is a little girl...\n\nvar littleGirl = princess();\n\n\n...telling stories about magic and fantasy.\n\nlittleGirl.story();\n\n\nAnd even though the grown-ups knew of real princesses, they would never believe in the unicorns or dragons because they could never see them. The grown-ups said that they only existed inside the little girl&apos;s imagination.\n\nBut we know the real truth; that the little girl with the princess inside...\n\n...is really a princess with a little girl inside.\n    ","url":"https://solutionschecker.com/questions/how-do-javascript-closures-work-1657384418555#solution3","@type":"Answer","upvoteCount":0},{"text":"Taking the question seriously, we should find out what a typical 6-year-old is capable of cognitively, though admittedly, one who is interested in JavaScript is not so typical.  \n\nOn  Childhood Development: 5 to 7 Years  it says:\n\n\n  Your child will be able to follow two-step directions. For example, if you say to your child, &quot;Go to the kitchen and get me a trash bag&quot; they will be able to remember that direction.\n\n\nWe can use this example to explain closures, as follows:\n\n\n  The kitchen is a closure that has a local variable, called trashBags.  There is a function inside the kitchen called getTrashBag that gets one trash bag and returns it.\n\n\nWe can code this in JavaScript like this:\n\n\n\nfunction makeKitchen() {\n  var trashBags = [&apos;A&apos;, &apos;B&apos;, &apos;C&apos;]; // only 3 at first\n\n  return {\n    getTrashBag: function() {\n      return trashBags.pop();\n    }\n  };\n}\n\nvar kitchen = makeKitchen();\n\nconsole.log(kitchen.getTrashBag()); // returns trash bag C\nconsole.log(kitchen.getTrashBag()); // returns trash bag B\nconsole.log(kitchen.getTrashBag()); // returns trash bag A\n Run code snippetHide resultsExpand snippet\n\n\n\nFurther points that explain why closures are interesting:\n\n\nEach time makeKitchen() is called, a new closure is created with its own separate trashBags.\nThe trashBags variable is local to the inside of each kitchen and is not accessible outside, but the inner function on the getTrashBag property does have access to it.  \nEvery function call creates a closure, but there would be no need to keep the closure around unless an inner function, which has access to the inside of the closure, can be called from outside the closure.  Returning the object with the getTrashBag function does that here.\n\n    ","url":"https://solutionschecker.com/questions/how-do-javascript-closures-work-1657384418555#solution4","@type":"Answer","upvoteCount":0},{"text":"The Straw Man\nI need to know how many times a button has been clicked and do something on every third click...\nFairly Obvious Solution\n\n\n// Declare counter outside event handler&apos;s scope\nvar counter = 0;\nvar element = document.getElementById(&apos;button&apos;);\n\nelement.addEventListener(&quot;click&quot;, function() {\n  // Increment outside counter\n  counter++;\n\n  if (counter === 3) {\n    // Do something every third time\n    console.log(&quot;Third time&apos;s the charm!&quot;);\n\n    // Reset counter\n    counter = 0;\n  }\n});\n&lt;button id=&quot;button&quot;&gt;Click Me!&lt;/button&gt;\n Run code snippetHide resultsExpand snippet\n\n\nNow this will work, but it does encroach into the outer scope by adding a variable, whose sole purpose is to keep track of the count. In some situations, this would be preferable as your outer application might need access to this information. But in this case, we are only changing every third click&apos;s behavior, so it is preferable to enclose this functionality inside the event handler.\nConsider this option\n\n\nvar element = document.getElementById(&apos;button&apos;);\n\nelement.addEventListener(&quot;click&quot;, (function() {\n  // init the count to 0\n  var count = 0;\n\n  return function(e) { // &lt;- This function becomes the click handler\n    count++; //    and will retain access to the above `count`\n\n    if (count === 3) {\n      // Do something every third time\n      console.log(&quot;Third time&apos;s the charm!&quot;);\n\n      //Reset counter\n      count = 0;\n    }\n  };\n})());\n&lt;button id=&quot;button&quot;&gt;Click Me!&lt;/button&gt;\n Run code snippetHide resultsExpand snippet\n\n\nNotice a few things here.\nIn the above example, I am using the closure behavior of JavaScript. This behavior allows any function to have access to the scope in which it was created, indefinitely. To practically apply this, I immediately invoke a function that returns another function, and because the function I&apos;m returning has access to the internal count variable (because of the closure behavior explained above) this results in a private scope for usage by the resulting function... Not so simple? Let&apos;s dilute it down...\nA simple one-line closure\n//          _______________________Immediately invoked______________________\n//         |                                                                |\n//         |        Scope retained for use      ___Returned as the____      |\n//         |       only by returned function   |    value of func     |     |\n//         |             |            |        |                      |     |\n//         v             v            v        v                      v     v\nvar func = (function() { var a = &apos;val&apos;; return function() { alert(a); }; })();\n\nAll variables outside the returned function are available to the returned function, but they are not directly available to the returned function object...\nfunc();  // Alerts &quot;val&quot;\nfunc.a;  // Undefined\n\nGet it? So in our primary example, the count variable is contained within the closure and always available to the event handler, so it retains its state from click to click.\nAlso, this private variable state is fully accessible, for both readings and assigning to its private scoped variables.\nThere you go; you&apos;re now fully encapsulating this behavior.\nFull Blog Post (including jQuery considerations)\n    ","url":"https://solutionschecker.com/questions/how-do-javascript-closures-work-1657384418555#solution5","@type":"Answer","upvoteCount":0},{"text":"Closures are hard to explain because they are used to make some behaviour work that everybody intuitively expects to work anyway. I find the best way to explain them (and the way that I learned what they do) is to imagine the situation without them:\n\n\nconst makePlus = function(x) {\n    return function(y) { return x + y; };\n}\n\nconst plus5 = makePlus(5);\nconsole.log(plus5(3));\n Run code snippetHide resultsExpand snippet\n\n\nWhat would happen here if JavaScript didn&apos;t know closures? Just replace the call in the last line by its method body (which is basically what function calls do) and you get:\nconsole.log(x + 3);\n\nNow, where&apos;s the definition of x? We didn&apos;t define it in the current scope. The only solution is to let plus5 carry its scope (or rather, its parent&apos;s scope) around. This way, x is well-defined and it is bound to the value 5.\n    ","url":"https://solutionschecker.com/questions/how-do-javascript-closures-work-1657384418555#solution6","@type":"Answer","upvoteCount":0},{"text":"TLDR\n\nA closure is a link between a function and its outer lexical (ie. as-written) environment, such that the identifiers (variables, parameters, function declarations etc) defined within that environment are visible from within the function, regardless of when or from where the function is invoked.\n\nDetails\n\nIn the terminology of the ECMAScript specification, a closure can be said to be implemented by the [[Environment]] reference of every function-object, which points to the lexical environment within which the function is defined.\n\nWhen a function is invoked via the internal [[Call]] method, the [[Environment]] reference on the function-object is copied into the outer environment reference of the environment record of the newly-created execution context (stack frame).\n\nIn the following example, function f closes over the lexical environment of the global execution context:\n\nfunction f() {}\n\n\nIn the following example, function h closes over the lexical environment of function g, which, in turn, closes over the lexical environment of the global execution context.\n\nfunction g() {\n    function h() {}\n}\n\n\nIf an inner function is returned by an outer, then the outer lexical environment will persist after the outer function has returned. This is because the outer lexical environment needs to be available if the inner function is eventually invoked.\n\nIn the following example, function j closes over the lexical environment of function i, meaning that variable x is visible from inside function j, long after function i has completed execution:\n\n\n\nfunction i() {\n    var x = &apos;mochacchino&apos;\n    return function j() {\n        console.log(&apos;Printing the value of x, from within function j: &apos;, x)\n    }\n} \n\nconst k = i()\nsetTimeout(k, 500) // invoke k (which is j) after 500ms\n Run code snippetHide resultsExpand snippet\n\n\n\nIn a closure, the variables in the outer lexical environment themselves are available, not copies.\n\n\n\nfunction l() {\n  var y = &apos;vanilla&apos;;\n\n  return {\n    setY: function(value) {\n      y = value;\n    },\n    logY: function(value) {\n      console.log(&apos;The value of y is: &apos;, y);\n    }\n  }\n}\n\nconst o = l()\no.logY() // The value of y is: vanilla\no.setY(&apos;chocolate&apos;)\no.logY() // The value of y is: chocolate\n Run code snippetHide resultsExpand snippet\n\n\n\nThe chain of lexical environments, linked between execution contexts via outer environment references, forms a scope chain and defines the identifiers visible from any given function.\n\nPlease note that in an attempt to improve clarity and accuracy, this answer has been substantially changed from the original.\n    ","url":"https://solutionschecker.com/questions/how-do-javascript-closures-work-1657384418555#solution7","@type":"Answer","upvoteCount":0},{"text":"OK, 6-year-old closures fan. Do you want to hear the simplest example of closure?\n\nLet&apos;s imagine the next situation: a driver is sitting in a car. That car is inside a plane. Plane is in the airport. The ability of driver to access things outside his car, but inside the plane, even if that plane leaves an airport, is a closure. That&apos;s it. When you turn 27, look at the more detailed explanation or at the example below.\n\nHere is how I can convert my plane story into the code.\n\n\n\nvar plane = function(defaultAirport) {\n\n  var lastAirportLeft = defaultAirport;\n\n  var car = {\n    driver: {\n      startAccessPlaneInfo: function() {\n        setInterval(function() {\n          console.log(&quot;Last airport was &quot; + lastAirportLeft);\n        }, 2000);\n      }\n    }\n  };\n  car.driver.startAccessPlaneInfo();\n\n  return {\n    leaveTheAirport: function(airPortName) {\n      lastAirportLeft = airPortName;\n    }\n  }\n}(&quot;Boryspil International Airport&quot;);\n\nplane.leaveTheAirport(&quot;John F. Kennedy&quot;);\n Run code snippetHide resultsExpand snippet\n\n\n    ","url":"https://solutionschecker.com/questions/how-do-javascript-closures-work-1657384418555#solution8","@type":"Answer","upvoteCount":0},{"text":"This is an attempt to clear up several (possible) misunderstandings about closures that appear in some of the other answers.\n\n\nA closure is not only created when you return an inner function. In fact, the enclosing function does not need to return at all in order for its closure to be created. You might instead assign your inner function to a variable in an outer scope, or pass it as an argument to another function where it could be called immediately or any time later. Therefore, the closure of the enclosing function is probably created as soon as the enclosing function is called since any inner function has access to that closure whenever the inner function is called, before or after the enclosing function returns. \nA closure does not reference a copy of the old values of variables in its scope. The variables themselves are part of the closure, and so the value seen when accessing one of those variables is the latest value at the time it is accessed. This is why inner functions created inside of loops can be tricky, since each one has access to the same outer variables rather than grabbing a copy of the variables at the time the function is created or called.\nThe &quot;variables&quot; in a closure include any named functions declared within the function. They also include arguments of the function. A closure also has access to its containing closure&apos;s variables, all the way up to the global scope.\nClosures use memory, but they don&apos;t cause memory leaks since JavaScript by itself cleans up its own circular structures that are not referenced. Internet Explorer memory leaks involving closures are created when it fails to disconnect DOM attribute values that reference closures, thus maintaining references to possibly circular structures.\n\n    ","url":"https://solutionschecker.com/questions/how-do-javascript-closures-work-1657384418555#solution9","@type":"Answer","upvoteCount":0},{"text":"I wrote a blog post a while back explaining closures. Here&apos;s what I said about closures in terms of why you&apos;d want one.\n\n\n  Closures are a way to let a function\n  have persistent, private variables -\n  that is, variables that only one\n  function knows about, where it can\n  keep track of info from previous times\n  that it was run.\n\n\nIn that sense, they let a function act a bit like an object with private attributes.\n\nFull post:\n\nSo what are these closure thingys?\n    ","url":"https://solutionschecker.com/questions/how-do-javascript-closures-work-1657384418555#solution10","@type":"Answer","upvoteCount":0},{"text":"The original question had a quote:\n\nIf you can&apos;t explain it to a six-year old, you really don&apos;t understand it yourself.\n\nThis is how I&apos;d try to explain it to an actual six-year-old:\nYou know how grown-ups can own a house, and they call it home? When a mom has a child, the child doesn&apos;t really own anything, right? But its parents own a house, so whenever someone asks the child &quot;Where&apos;s your home?&quot;, he/she can answer &quot;that house!&quot;, and point to the house of its parents. A &quot;Closure&quot; is the ability of the child to always (even if abroad) be able to say it has a home, even though it&apos;s really the parent&apos;s who own the house.\n    ","url":"https://solutionschecker.com/questions/how-do-javascript-closures-work-1657384418555#solution11","@type":"Answer","upvoteCount":0},{"text":"Closures are simple:\n\nThe following simple example covers all the main points of JavaScript closures.*\n \n\nHere is a factory that produces calculators that can add and multiply:\n\nfunction make_calculator() {\n  var n = 0; // this calculator stores a single number n\n  return {\n    add: function(a) {\n      n += a;\n      return n;\n    },\n    multiply: function(a) {\n      n *= a;\n      return n;\n    }\n  };\n}\n\nfirst_calculator = make_calculator();\nsecond_calculator = make_calculator();\n\nfirst_calculator.add(3); // returns 3\nsecond_calculator.add(400); // returns 400\n\nfirst_calculator.multiply(11); // returns 33\nsecond_calculator.multiply(10); // returns 4000\n\n\nThe key point: Each call to make_calculator creates a new local variable n, which continues to be usable by that calculator&apos;s add and multiply functions long after make_calculator returns.\n\nIf you are familiar with stack frames, these calculators seem strange: How can they keep accessing n after make_calculator returns?  The answer is to imagine that JavaScript doesn&apos;t use &quot;stack frames&quot;, but instead uses &quot;heap frames&quot;, which can persist after the function call that made them returns.\n\nInner functions like add and multiply, which access variables declared in an outer function**, are called closures.\n\nThat is pretty much all there is to closures.\n\n\n\n\n\n* For example, it covers all the points in the &quot;Closures for Dummies&quot; article given in another answer, except example 6, which simply shows that variables can be used before they are declared, a nice fact to know but completely unrelated to closures. It also covers all the points in the accepted answer, except for the points (1) that functions copy their arguments into local variables (the named function arguments), and (2) that copying numbers creates a new number, but copying an object reference gives you another reference to the same object. These are also good to know but again completely unrelated to closures. It is also very similar to the example in this answer but a bit shorter and less abstract. It does not cover the point of this answer or this comment, which is that JavaScript makes it difficult to plug the current value of a loop variable into your inner function: The &quot;plugging in&quot; step can only be done with a helper function that encloses your inner function and is invoked on each loop iteration. (Strictly speaking, the inner function accesses the helper function&apos;s copy of the variable, rather than having anything plugged in.) Again, very useful when creating closures, but not part of what a closure is or how it works. There is additional confusion due to closures working differently in functional languages like ML, where variables are bound to values rather than to storage space, providing a constant stream of people who understand closures in a way (namely the &quot;plugging in&quot; way) that is simply incorrect for JavaScript, where variables are always bound to storage space, and never to values. \n\n** Any outer function, if several are nested, or even in the global context, as this answer points out clearly.\n    ","url":"https://solutionschecker.com/questions/how-do-javascript-closures-work-1657384418555#solution12","@type":"Answer","upvoteCount":0},{"text":"Can you explain closures to a 5-year-old?*\nI still think Google&apos;s explanation works very well and is concise:\n/*\n*    When a function is defined in another function and it\n*    has access to the outer function&apos;s context even after\n*    the outer function returns.\n*\n* An important concept to learn in JavaScript.\n*/\n\nfunction outerFunction(someNum) {\n    var someString = &apos;Hey!&apos;;\n    var content = document.getElementById(&apos;content&apos;);\n    function innerFunction() {\n        content.innerHTML = someNum + &apos;: &apos; + someString;\n        content = null; // Internet Explorer memory leak for DOM reference\n    }\n    innerFunction();\n}\n\nouterFunction(1);\n\n\n*A C# question\n    ","url":"https://solutionschecker.com/questions/how-do-javascript-closures-work-1657384418555#solution13","@type":"Answer","upvoteCount":0},{"text":"I tend to learn better by GOOD/BAD comparisons. I like to see working code followed by non-working code that someone is likely to encounter. I put together a jsFiddle that does a comparison and tries to boil down the differences to the simplest explanations I could come up with.\nClosures done right:\nconsole.log(&apos;CLOSURES DONE RIGHT&apos;);\n\nvar arr = [];\n\nfunction createClosure(n) {\n    return function () {\n        return &apos;n = &apos; + n;\n    }\n}\n\nfor (var index = 0; index &lt; 10; index++) {\n    arr[index] = createClosure(index);\n}\n\nfor (var index in arr) {\n    console.log(arr[index]());\n}\n\n\nIn the above code createClosure(n) is invoked in every iteration of the loop. Note that I named the variable n to highlight that it is a new variable created in a new function scope and is not the same variable as index which is bound to the outer scope.\n\nThis creates a new scope and n is bound to that scope; this means we have 10 separate scopes, one for each iteration.\n\ncreateClosure(n) returns a function that returns the n within that scope.\n\nWithin each scope n is bound to whatever value it had when createClosure(n) was invoked so the nested function that gets returned will always return the value of n that it had when createClosure(n) was invoked.\n\n\nClosures done wrong:\nconsole.log(&apos;CLOSURES DONE WRONG&apos;);\n\nfunction createClosureArray() {\n    var badArr = [];\n\n    for (var index = 0; index &lt; 10; index++) {\n        badArr[index] = function () {\n            return &apos;n = &apos; + index;\n        };\n    }\n    return badArr;\n}\n\nvar badArr = createClosureArray();\n\nfor (var index in badArr) {\n    console.log(badArr[index]());\n}\n\n\nIn the above code the loop was moved within the createClosureArray() function and the function now just returns the completed array, which at first glance seems more intuitive.\n\nWhat might not be obvious is that since createClosureArray() is only invoked once only one scope is created for this function instead of one for every iteration of the loop.\n\nWithin this function a variable named index is defined. The loop runs and adds functions to the array that return index. Note that index is defined within the createClosureArray function which only ever gets invoked one time.\n\nBecause there was only one scope within the createClosureArray() function, index is only bound to a value within that scope. In other words, each time the loop changes the value of index, it changes it for everything that references it within that scope.\n\nAll of the functions added to the array return the SAME index variable from the parent scope where it was defined instead of 10 different ones from 10 different scopes like the first example. The end result is that all 10 functions return the same variable from the same scope.\n\nAfter the loop finished and index was done being modified the end value was 10, therefore every function added to the array returns the value of the single index variable which is now set to 10.\n\n\nResult\n\nCLOSURES DONE RIGHT\nn = 0\nn = 1\nn = 2\nn = 3\nn = 4\nn = 5\nn = 6\nn = 7\nn = 8\nn = 9\nCLOSURES DONE WRONG\nn = 10\nn = 10\nn = 10\nn = 10\nn = 10\nn = 10\nn = 10\nn = 10\nn = 10\nn = 10\n\n    ","url":"https://solutionschecker.com/questions/how-do-javascript-closures-work-1657384418555#solution14","@type":"Answer","upvoteCount":0},{"text":"Wikipedia on closures:\n\n\n  In computer science, a closure is a function together with a referencing environment for the nonlocal names (free variables) of that function.\n\n\nTechnically, in JavaScript, every function is a closure. It always has an access to variables defined in the surrounding scope.\n\nSince scope-defining construction in JavaScript is a function, not a code block like in many other languages, what we usually mean by closure in JavaScript is a function working with nonlocal variables defined in already executed surrounding function.\n\nClosures are often used for creating functions with some hidden private data (but it&apos;s not always the case).\n\nvar db = (function() {\n    // Create a hidden object, which will hold the data\n    // it&apos;s inaccessible from the outside.\n    var data = {};\n\n    // Make a function, which will provide some access to the data.\n    return function(key, val) {\n        if (val === undefined) { return data[key] } // Get\n        else { return data[key] = val } // Set\n    }\n    // We are calling the anonymous surrounding function,\n    // returning the above inner function, which is a closure.\n})();\n\ndb(&apos;x&apos;)    // -&gt; undefined\ndb(&apos;x&apos;, 1) // Set x to 1\ndb(&apos;x&apos;)    // -&gt; 1\n// It&apos;s impossible to access the data object itself.\n// We are able to get or set individual it.\n\n\nems\n\nThe example above is using an anonymous function, which was executed once. But it does not have to be. It can be named (e.g. mkdb) and executed later, generating a database function each time it is invoked. Every generated function will have its own hidden database object. Another usage example of closures is when we don&apos;t return a function, but an object containing multiple functions for different purposes, each of those function having access to the same data.\n    ","url":"https://solutionschecker.com/questions/how-do-javascript-closures-work-1657384418555#solution15","@type":"Answer","upvoteCount":0},{"text":"I put together an interactive JavaScript tutorial to explain how closures work.\nWhat&apos;s a Closure?\n\nHere&apos;s one of the examples:\n\nvar create = function (x) {\n    var f = function () {\n        return x; // We can refer to x here!\n    };\n    return f;\n};\n// &apos;create&apos; takes one argument, creates a function\n\nvar g = create(42);\n// g is a function that takes no arguments now\n\nvar y = g();\n// y is 42 here\n\n    ","url":"https://solutionschecker.com/questions/how-do-javascript-closures-work-1657384418555#solution16","@type":"Answer","upvoteCount":0},{"text":"\n  The children will always remember the secrets they have shared with their parents, even after their parents are\n  gone. This is what closures are for functions.\n\n\nThe secrets for JavaScript functions are the private variables\n\nvar parent = function() {\n var name = &quot;Mary&quot;; // secret\n}\n\n\nEvery time you call it, local variable &quot;name&quot; is created and given name &quot;Mary&quot;. And every time the function exits the variable is lost and the name is forgotten.\n\nAs you may guess, because the variables are re-created every time the function is called, and nobody else will know them, there must be a secret place where they are stored. It could be called Chamber of Secrets or stack or local scope but it doesn&apos;t really matter. We know they are there, somewhere, hidden in the memory.\n\nBut, in JavaScript there is this very special thing that functions which are created inside other functions, can also know the local variables of their parents and keep them as long as they live.\n\nvar parent = function() {\n  var name = &quot;Mary&quot;;\n  var child = function(childName) {\n    // I can also see that &quot;name&quot; is &quot;Mary&quot;\n  }\n}\n\n\nSo, as long as we are in the parent -function, it can create one or more child functions which do share the secret variables from the secret place.\n\nBut the sad thing is, if the child is also a private variable of its parent function, it would also die when the parent ends, and the secrets would die with them.\n\nSo to live, the child has to leave before it&apos;s too late\n\nvar parent = function() {\n  var name = &quot;Mary&quot;;\n  var child = function(childName) {\n    return &quot;My name is &quot; + childName  +&quot;, child of &quot; + name; \n  }\n  return child; // child leaves the parent -&gt;\n}\nvar child = parent(); // &lt; - and here it is outside \n\n\nAnd now, even though Mary is &quot;no longer running&quot;, the memory of her is not lost and her child will always remember her name and other secrets they shared during their time together.\n\nSo, if you call the child &quot;Alice&quot;, she will respond\n\nchild(&quot;Alice&quot;) =&gt; &quot;My name is Alice, child of Mary&quot;\n\n\nThat&apos;s all there is to tell.\n    ","url":"https://solutionschecker.com/questions/how-do-javascript-closures-work-1657384418555#solution17","@type":"Answer","upvoteCount":0},{"text":"I do not understand why the answers are so complex here.\nHere is a closure:\nvar a = 42;\n\nfunction b() { return a; }\n\nYes. You probably use that many times a day.\n\n\nThere is no reason to believe closures are a complex design hack to address specific problems. No, closures are just about using a variable that comes from a higher scope from the perspective of where the function was declared (not run).\nNow what it allows you to do can be more spectacular, see other answers.\n\n    ","url":"https://solutionschecker.com/questions/how-do-javascript-closures-work-1657384418555#solution18","@type":"Answer","upvoteCount":0},{"text":"Example for the first point by dlaliberte:\n\n\n  A closure is not only created when you return an inner function. In fact, the enclosing function does not need to return at all. You might instead assign your inner function to a variable in an outer scope, or pass it as an argument to another function where it could be used immediately. Therefore, the closure of the enclosing function probably already exists at the time that enclosing function was called since any inner function has access to it as soon as it is called.\n\n\nvar i;\nfunction foo(x) {\n    var tmp = 3;\n    i = function (y) {\n        console.log(x + y + (++tmp));\n    }\n}\nfoo(2);\ni(3);\n\n    ","url":"https://solutionschecker.com/questions/how-do-javascript-closures-work-1657384418555#solution19","@type":"Answer","upvoteCount":0},{"text":"A closure is where an inner function has access to variables in its outer function. That&apos;s probably the simplest one-line explanation you can get for closures.\n    ","url":"https://solutionschecker.com/questions/how-do-javascript-closures-work-1657384418555#solution20","@type":"Answer","upvoteCount":0},{"text":"I know there are plenty of solutions already, but I guess that this small and simple script can be useful to demonstrate the concept:\n\n// makeSequencer will return a &quot;sequencer&quot; function\nvar makeSequencer = function() {\n    var _count = 0; // not accessible outside this function\n    var sequencer = function () {\n        return _count++;\n    }\n    return sequencer;\n}\n\nvar fnext = makeSequencer();\nvar v0 = fnext();     // v0 = 0;\nvar v1 = fnext();     // v1 = 1;\nvar vz = fnext._count // vz = undefined\n\n    ","url":"https://solutionschecker.com/questions/how-do-javascript-closures-work-1657384418555#solution21","@type":"Answer","upvoteCount":0},{"text":"You&apos;re having a sleep over and you invite Dan.\nYou tell Dan to bring one XBox controller.\n\nDan invites Paul.\nDan asks Paul to bring one controller. How many controllers were brought to the party?\n\nfunction sleepOver(howManyControllersToBring) {\n\n    var numberOfDansControllers = howManyControllersToBring;\n\n    return function danInvitedPaul(numberOfPaulsControllers) {\n        var totalControllers = numberOfDansControllers + numberOfPaulsControllers;\n        return totalControllers;\n    }\n}\n\nvar howManyControllersToBring = 1;\n\nvar inviteDan = sleepOver(howManyControllersToBring);\n\n// The only reason Paul was invited is because Dan was invited. \n// So we set Paul&apos;s invitation = Dan&apos;s invitation.\n\nvar danInvitedPaul = inviteDan(howManyControllersToBring);\n\nalert(&quot;There were &quot; + danInvitedPaul + &quot; controllers brought to the party.&quot;);\n\n    ","url":"https://solutionschecker.com/questions/how-do-javascript-closures-work-1657384418555#solution22","@type":"Answer","upvoteCount":0},{"text":"The author of Closures has explained closures pretty well, explaining the reason why we need them and also explaining LexicalEnvironment which is necessary to understanding closures. \nHere is the summary:\n\nWhat if a variable is accessed, but it isnt local? Like here:\n\n\n\nIn this case, the interpreter finds the variable in the\nouter LexicalEnvironment object.\n\nThe process consists of two steps:\n\n\nFirst, when a function f is created, it is not created in an empty\nspace. There is a current LexicalEnvironment object. In the case\nabove, its window (a is undefined at the time of function\ncreation).\n\n\n\n\nWhen a function is created, it gets a hidden property, named [[Scope]], which references the current LexicalEnvironment.\n\n\n\nIf a variable is read, but can not be found anywhere, an error is generated.\n\nNested functions\n\nFunctions can be nested one inside another, forming a chain of LexicalEnvironments which can also be called a scope chain.\n\n\n\nSo, function g has access to g, a and f.\n\nClosures\n\nA nested function may continue to live after the outer function has finished:\n\n\n\nMarking up LexicalEnvironments:\n\n\n\nAs we see, this.say is a property in the user object, so it continues to live after User completed.\n\nAnd if you remember, when this.say is created, it (as every function) gets an internal reference this.say.[[Scope]] to the current LexicalEnvironment. So, the LexicalEnvironment of the current User execution stays in memory. All variables of User also are its properties, so they are also carefully kept, not junked as usually.\n\nThe whole point is to ensure that if the inner function wants to access an outer variable in the future, it is able to do so.\n\nTo summarize:\n\n\nThe inner function keeps a reference to the outer\nLexicalEnvironment.\nThe inner function may access variables from it\nany time even if the outer function is finished.\nThe browser keeps the LexicalEnvironment and all its properties (variables) in memory until there is an inner function which references it.\n\n\nThis is called a closure.\n    ","url":"https://solutionschecker.com/questions/how-do-javascript-closures-work-1657384418555#solution23","@type":"Answer","upvoteCount":0},{"text":"JavaScript functions can access their:\n\n\nArguments\nLocals (that is, their local variables and local functions)\nEnvironment, which includes:\n\n\nglobals, including the DOM\nanything in outer functions\n\n\n\nIf a function accesses its environment, then the function is a closure.\n\nNote that outer functions are not required, though they do offer benefits I don&apos;t discuss here. By accessing data in its environment, a closure keeps that data alive. In the subcase of outer/inner functions, an outer function can create local data and eventually exit, and yet, if any inner function(s) survive after the outer function exits, then the inner function(s) keep the outer function&apos;s local data alive.\n\nExample of a closure that uses the global environment:\n\nImagine that the Stack Overflow Vote-Up and Vote-Down button events are implemented as closures, voteUp_click and voteDown_click, that have access to external variables isVotedUp and isVotedDown, which are defined globally. (For simplicity&apos;s sake, I am referring to StackOverflow&apos;s Question Vote buttons, not the array of Answer Vote buttons.)\n\nWhen the user clicks the VoteUp button, the voteUp_click function checks whether isVotedDown == true to determine whether to vote up or merely cancel a down vote. Function voteUp_click is a closure because it is accessing its environment.\n\nvar isVotedUp = false;\nvar isVotedDown = false;\n\nfunction voteUp_click() {\n  if (isVotedUp)\n    return;\n  else if (isVotedDown)\n    SetDownVote(false);\n  else\n    SetUpVote(true);\n}\n\nfunction voteDown_click() {\n  if (isVotedDown)\n    return;\n  else if (isVotedUp)\n    SetUpVote(false);\n  else\n    SetDownVote(true);\n}\n\nfunction SetUpVote(status) {\n  isVotedUp = status;\n  // Do some CSS stuff to Vote-Up button\n}\n\nfunction SetDownVote(status) {\n  isVotedDown = status;\n  // Do some CSS stuff to Vote-Down button\n}\n\n\nAll four of these functions are closures as they all access their environment.\n    ","url":"https://solutionschecker.com/questions/how-do-javascript-closures-work-1657384418555#solution24","@type":"Answer","upvoteCount":0},{"text":"As a father of a 6-year-old, currently teaching young children (and a relative novice to coding with no formal education so corrections will be required), I think the lesson would stick best through hands-on play. If the 6-year-old is ready to understand what a closure is, then they are old enough to have a go themselves. I&apos;d suggest pasting the code into jsfiddle.net, explaining a bit, and leaving them alone to concoct a unique song. The explanatory text below is probably more appropriate for a 10 year old.\n\nfunction sing(person) {\n\n    var firstPart = &quot;There was &quot; + person + &quot; who swallowed &quot;;\n\n    var fly = function() {\n        var creature = &quot;a fly&quot;;\n        var result = &quot;Perhaps she&apos;ll die&quot;;\n        alert(firstPart + creature + &quot;\\n&quot; + result);\n    };\n\n    var spider = function() {\n        var creature = &quot;a spider&quot;;\n        var result = &quot;that wiggled and jiggled and tickled inside her&quot;;\n        alert(firstPart + creature + &quot;\\n&quot; + result);\n    };\n\n    var bird = function() {\n        var creature = &quot;a bird&quot;;\n        var result = &quot;How absurd!&quot;;\n        alert(firstPart + creature + &quot;\\n&quot; + result);\n    };\n\n    var cat = function() {\n        var creature = &quot;a cat&quot;;\n        var result = &quot;Imagine That!&quot;;\n        alert(firstPart + creature + &quot;\\n&quot; + result);\n    };\n\n    fly();\n    spider();\n    bird();\n    cat();\n}\n\nvar person=&quot;an old lady&quot;;\n\nsing(person);\n\n\nINSTRUCTIONS\n\nDATA: Data is a collection of facts. It can be numbers, words, measurements, observations or even just descriptions of things. You can&apos;t touch it, smell it or taste it. You can write it down, speak it and hear it. You could use it to create touch smell and taste using a computer. It can be made useful by a computer using code.\n\nCODE: All the writing above is called code. It is written in JavaScript.\n\nJAVASCRIPT: JavaScript is a language. Like English or French or Chinese are languages. There are lots of languages that are understood by computers and other electronic processors. For JavaScript to be understood by a computer it needs an interpreter. Imagine if a teacher who only speaks Russian comes to teach your class at school. When the teacher says &quot;все садятся&quot;, the class would not understand. But luckily you have a Russian pupil in your class who tells everyone this means &quot;everybody sit down&quot; - so you all do. The class is like a computer and the Russian pupil is the interpreter. For JavaScript the most common interpreter is called a browser.\n\nBROWSER: When you connect to the Internet on a computer, tablet or phone to visit a website, you use a browser. Examples you may know are Internet Explorer, Chrome, Firefox and Safari. The browser can understand JavaScript and tell the computer what it needs to do. The JavaScript instructions are called functions.\n\nFUNCTION: A function in JavaScript is like a factory. It might be a little factory with only one machine inside. Or it might contain many other little factories, each with many machines doing different jobs. In a real life clothes factory you might have reams of cloth and bobbins of thread going in and T-shirts and jeans coming out. Our JavaScript factory only processes data, it can&apos;t sew, drill a hole or melt metal. In our JavaScript factory data goes in and data comes out.\n\nAll this data stuff sounds a bit boring, but it is really very cool; we might have a function that tells a robot what to make for dinner. Let&apos;s say I invite you and your friend to my house. You like chicken legs best, I like sausages, your friend always wants what you want and my friend does not eat meat.\n\nI haven&apos;t got time to go shopping, so the function needs to know what we have in the fridge to make decisions. Each ingredient has a different cooking time and we want everything to be served hot by the robot at the same time. We need to provide the function with the data about what we like, the function could &apos;talk&apos; to the fridge, and the function could control the robot.\n\nA function normally has a name, parentheses and braces. Like this:\n\nfunction cookMeal() {  /*  STUFF INSIDE THE FUNCTION  */  }\n\n\nNote that /*...*/ and // stop code being read by the browser.\n\nNAME: You can call a function just about whatever word you want. The example &quot;cookMeal&quot; is typical in joining two words together and giving the second one a capital letter at the beginning - but this is not necessary. It can&apos;t have a space in it, and it can&apos;t be a number on its own.\n\nPARENTHESES: &quot;Parentheses&quot; or () are the letter box on the JavaScript function factory&apos;s door or a post box in the street for sending packets of information to the factory. Sometimes the postbox might be marked for example cookMeal(you, me, yourFriend, myFriend, fridge, dinnerTime), in which case you know what data you have to give it.\n\nBRACES: &quot;Braces&quot; which look like this {} are the tinted windows of our factory. From inside the factory you can see out, but from the outside you can&apos;t see in.\n\nTHE LONG CODE EXAMPLE ABOVE\n\nOur code begins with the word function, so we know that it is one! Then the name of the function sing - that&apos;s my own description of what the function is about. Then parentheses (). The parentheses are always there for a function. Sometimes they are empty, and sometimes they have something in. This one has a word in: (person). After this there is a brace like this { . This marks the start of the function sing(). It has a partner which marks the end of sing() like this }\n\nfunction sing(person) {  /* STUFF INSIDE THE FUNCTION */  }\n\n\nSo this function might have something to do with singing, and might need some data about a person. It has instructions inside to do something with that data.\n\nNow, after the function sing(), near the end of the code is the line\n\nvar person=&quot;an old lady&quot;;\n\n\nVARIABLE: The letters var stand for &quot;variable&quot;. A variable is like an envelope. On the outside this envelope is marked &quot;person&quot;. On the inside it contains a slip of paper with the information our function needs, some letters and spaces joined together like a piece of string (it&apos;s called a string) that make a phrase reading &quot;an old lady&quot;. Our envelope could contain other kinds of things like numbers (called integers), instructions (called functions), lists (called arrays). Because this variable is written outside of all the braces {}, and because you can see out through the tinted windows when you are inside the braces, this variable can be seen from anywhere in the code. We call this a &apos;global variable&apos;.\n\nGLOBAL VARIABLE: person is a global variable, meaning that if you change its value from &quot;an old lady&quot; to &quot;a young man&quot;, the person will keep being a young man until you decide to change it again and that any other function in the code can see that it&apos;s a young man. Press the F12 button or look at the Options settings to open the developer console of a browser and type &quot;person&quot; to see what this value is. Type person=&quot;a young man&quot; to change it and then type &quot;person&quot; again to see that it has changed.\n\nAfter this we have the line\n\nsing(person);\n\n\nThis line is calling the function, as if it were calling a dog\n\n\n  &quot;Come on sing, Come and get person!&quot;\n\n\nWhen the browser has loaded the JavaScript code an reached this line, it will start the function. I put the line at the end to make sure that the browser has all the information it needs to run it.\n\nFunctions define actions  - the main function is about singing. It contains a variable called firstPart which applies to the singing about the person that applies to each of the verses of the song: &quot;There was &quot; + person + &quot; who swallowed&quot;. If you type firstPart into the console, you won&apos;t get an answer because the variable is locked up in a function - the browser can&apos;t see inside the tinted windows of the braces.\n\nCLOSURES: The closures are the smaller functions that are inside the big sing() function. The little factories inside the big factory. They each have their own braces which mean that the variables inside them can&apos;t be seen from the outside. That&apos;s why the names of the variables (creature and result) can be repeated in the closures but with different values. If you type these variable names in the console window, you won&apos;t get its value because it&apos;s hidden by two layers of tinted windows.\n\nThe closures all know what the sing() function&apos;s variable called firstPart is, because they can see out from their tinted windows.\n\nAfter the closures come the lines\n\nfly();\nspider();\nbird();\ncat();\n\n\nThe sing() function will call each of these functions in the order they are given. Then the sing() function&apos;s work will be done.\n    ","url":"https://solutionschecker.com/questions/how-do-javascript-closures-work-1657384418555#solution25","@type":"Answer","upvoteCount":0},{"text":"Okay, talking with a 6-year old child, I would possibly use following associations.\n\n\n  Imagine - you are playing with your little brothers and sisters in the entire house, and you are moving around with your toys and brought some of them into your older brother&apos;s room. After a while your brother returned from the school and went to his room, and he locked inside it, so now you could not access toys left there anymore in a direct way. But you could knock the door and ask your brother for that toys. This is called toy&apos;s closure; your brother made it up for you, and he is now into outer scope.\n\n\nCompare with a situation when a door was locked by draft and nobody inside (general function execution), and then some local fire occur and burn down the room (garbage collector:D), and then a new room was build and now you may leave another toys there (new function instance), but never get the same toys which were left in the first room instance.\n\nFor an advanced child I would put something like the following. It is not perfect, but it makes you feel about what it is:\n\nfunction playingInBrothersRoom (withToys) {\n  // We closure toys which we played in the brother&apos;s room. When he come back and lock the door\n  // your brother is supposed to be into the outer [[scope]] object now. Thanks god you could communicate with him.\n  var closureToys = withToys || [],\n      returnToy, countIt, toy; // Just another closure helpers, for brother&apos;s inner use.\n\n  var brotherGivesToyBack = function (toy) {\n    // New request. There is not yet closureToys on brother&apos;s hand yet. Give him a time.\n    returnToy = null;\n    if (toy &amp;&amp; closureToys.length &gt; 0) { // If we ask for a specific toy, the brother is going to search for it.\n\n      for ( countIt = closureToys.length; countIt; countIt--) {\n        if (closureToys[countIt - 1] == toy) {\n          returnToy = &apos;Take your &apos; + closureToys.splice(countIt - 1, 1) + &apos;, little boy!&apos;;\n          break;\n        }\n      }\n      returnToy = returnToy || &apos;Hey, I could not find any &apos; + toy + &apos; here. Look for it in another room.&apos;;\n    }\n    else if (closureToys.length &gt; 0) { // Otherwise, just give back everything he has in the room.\n      returnToy = &apos;Behold! &apos; + closureToys.join(&apos;, &apos;) + &apos;.&apos;;\n      closureToys = [];\n    }\n    else {\n      returnToy = &apos;Hey, lil shrimp, I gave you everything!&apos;;\n    }\n    console.log(returnToy);\n  }\n  return brotherGivesToyBack;\n}\n// You are playing in the house, including the brother&apos;s room.\nvar toys = [&apos;teddybear&apos;, &apos;car&apos;, &apos;jumpingrope&apos;],\n    askBrotherForClosuredToy = playingInBrothersRoom(toys);\n\n// The door is locked, and the brother came from the school. You could not cheat and take it out directly.\nconsole.log(askBrotherForClosuredToy.closureToys); // Undefined\n\n// But you could ask your brother politely, to give it back.\naskBrotherForClosuredToy(&apos;teddybear&apos;); // Hooray, here it is, teddybear\naskBrotherForClosuredToy(&apos;ball&apos;); // The brother would not be able to find it.\naskBrotherForClosuredToy(); // The brother gives you all the rest\naskBrotherForClosuredToy(); // Nothing left in there\n\n\nAs you can see, the toys left in the room are still accessible via the brother and no matter if the room is locked. Here is a jsbin to play around with it.\n    ","url":"https://solutionschecker.com/questions/how-do-javascript-closures-work-1657384418555#solution26","@type":"Answer","upvoteCount":0},{"text":"A function in JavaScript is not just a reference to a set of instructions (as in C language), but it also includes a hidden data structure which is composed of references to all nonlocal variables it uses (captured variables). Such two-piece functions are called closures. Every function in JavaScript can be considered a closure.\n\nClosures are functions with a state. It is somewhat similar to &quot;this&quot; in the sense that &quot;this&quot; also provides state for a function but function and &quot;this&quot; are separate objects (&quot;this&quot; is just a fancy parameter, and the only way to bind it permanently to a function is to create a closure). While &quot;this&quot; and function always live separately, a function cannot be separated from its closure and the language provides no means to access captured variables.\n\nBecause all these external variables referenced by a lexically nested function are actually local variables in the chain of its lexically enclosing functions (global variables can be assumed to be local variables of some root function), and every single execution of a function creates new instances of its local variables, it follows that every execution of a function returning (or otherwise transferring it out, such as registering it as a callback) a nested function creates a new closure (with its own potentially unique set of referenced nonlocal variables which represent its execution context).\n\nAlso, it must be understood that local variables in JavaScript are created not on the stack frame, but on the heap and destroyed only when no one is referencing them. When a function returns, references to its local variables are decremented, but they can still be non-null if during the current execution they became part of a closure and are still referenced by its lexically nested functions (which can happen only if the references to these nested functions were returned or otherwise transferred to some external code).\n\nAn example:\n\nfunction foo (initValue) {\n   //This variable is not destroyed when the foo function exits.\n   //It is &apos;captured&apos; by the two nested functions returned below.\n   var value = initValue;\n\n   //Note that the two returned functions are created right now.\n   //If the foo function is called again, it will return\n   //new functions referencing a different &apos;value&apos; variable.\n   return {\n       getValue: function () { return value; },\n       setValue: function (newValue) { value = newValue; }\n   }\n}\n\nfunction bar () {\n    //foo sets its local variable &apos;value&apos; to 5 and returns an object with\n    //two functions still referencing that local variable\n    var obj = foo(5);\n\n    //Extracting functions just to show that no &apos;this&apos; is involved here\n    var getValue = obj.getValue;\n    var setValue = obj.setValue;\n\n    alert(getValue()); //Displays 5\n    setValue(10);\n    alert(getValue()); //Displays 10\n\n    //At this point getValue and setValue functions are destroyed\n    //(in reality they are destroyed at the next iteration of the garbage collector).\n    //The local variable &apos;value&apos; in the foo is no longer referenced by\n    //anything and is destroyed too.\n}\n\nbar();\n\n    ","url":"https://solutionschecker.com/questions/how-do-javascript-closures-work-1657384418555#solution27","@type":"Answer","upvoteCount":0},{"text":"An answer for a six-year-old (assuming he knows what a function is and what a variable is, and what data is):\n\nFunctions can return data. One kind of data you can return from a function is another function. When that new function gets returned, all the variables and arguments used in the function that created it don&apos;t go away. Instead, that parent function &quot;closes.&quot; In other words, nothing can look inside of it and see the variables it used except for the function it returned. That new function has a special ability to look back inside the function that created it and see the data inside of it.\n\nfunction the_closure() {\n  var x = 4;\n  return function () {\n    return x; // Here, we look back inside the_closure for the value of x\n  }\n}\n\nvar myFn = the_closure();\nmyFn(); //=&gt; 4\n\n\nAnother really simple way to explain it is in terms of scope:\n\nAny time you create a smaller scope inside of a larger scope, the smaller scope will always be able to see what is in the larger scope.\n    ","url":"https://solutionschecker.com/questions/how-do-javascript-closures-work-1657384418555#solution28","@type":"Answer","upvoteCount":0},{"text":"Perhaps a little beyond all but the most precocious of six-year-olds, but a few examples that helped make the concept of closure in JavaScript click for me.\n\nA closure is a function that has access to another function&apos;s scope (its variables and functions). The easiest way to create a closure is with a function within a function; the reason being that in JavaScript a function always has access to its containing functions scope.\n\n\n\nfunction outerFunction() {\n    var outerVar = &quot;monkey&quot;;\n    \n    function innerFunction() {\n        alert(outerVar);\n    }\n    \n    innerFunction();\n}\n\nouterFunction();\n Run code snippetHide resultsExpand snippet\n\n\n\nALERT: monkey\n\nIn the above example, outerFunction is called which in turn calls innerFunction. Note how outerVar is available to innerFunction, evidenced by its correctly alerting the value of outerVar.\n\nNow consider the following:\n\n\n\nfunction outerFunction() {\n    var outerVar = &quot;monkey&quot;;\n    \n    function innerFunction() {\n        return outerVar;\n    }\n    \n    return innerFunction;\n}\n\nvar referenceToInnerFunction = outerFunction();\nalert(referenceToInnerFunction());\n Run code snippetHide resultsExpand snippet\n\n\n\nALERT: monkey\n\nreferenceToInnerFunction is set to outerFunction(), which simply returns a reference to innerFunction. When referenceToInnerFunction is called, it returns outerVar. Again, as above, this demonstrates that innerFunction has access to outerVar, a variable of outerFunction. Furthermore, it is interesting to note that it retains this access even after outerFunction has finished executing.\n\nAnd here is where things get really interesting. If we were to get rid of outerFunction, say set it to null, you might think that referenceToInnerFunction would loose its access to the value of outerVar. But this is not the case. \n\n\n\nfunction outerFunction() {\n    var outerVar = &quot;monkey&quot;;\n    \n    function innerFunction() {\n        return outerVar;\n    }\n    \n    return innerFunction;\n}\n\nvar referenceToInnerFunction = outerFunction();\nalert(referenceToInnerFunction());\n\nouterFunction = null;\nalert(referenceToInnerFunction());\n Run code snippetHide resultsExpand snippet\n\n\n\nALERT: monkey\nALERT: monkey\n\nBut how is this so? How can referenceToInnerFunction still know the value of outerVar now that outerFunction has been set to null?\n\nThe reason that referenceToInnerFunction can still access the value of outerVar is because when the closure was first created by placing innerFunction inside of outerFunction, innerFunction added a reference to outerFunctions scope (its variables and functions) to its scope chain. What this means is that innerFunction has a pointer or reference to all of outerFunctions variables, including outerVar. So even when outerFunction has finished executing, or even if it is deleted or set to null, the variables in its scope, like outerVar, stick around in memory because of the outstanding reference to them on the part of the innerFunction that has been returned to referenceToInnerFunction. To truly release outerVar and the rest of outerFunctions variables from memory you would have to get rid of this outstanding reference to them, say by setting referenceToInnerFunction to null as well.\n\n//////////\n\nTwo other things about closures to note. First, the closure will always have access to the last values of its containing function.\n\n\n\nfunction outerFunction() {\n    var outerVar = &quot;monkey&quot;;\n    \n    function innerFunction() {\n        alert(outerVar);\n    }\n    \n    outerVar = &quot;gorilla&quot;;\n\n    innerFunction();\n}\n\nouterFunction();\n Run code snippetHide resultsExpand snippet\n\n\n\nALERT: gorilla\n\nSecond, when a closure is created, it retains a reference to all of its enclosing functions variables and functions; it doesnt get to pick and choose. And but so, closures should be used sparingly, or at least carefully, as they can be memory intensive; a lot of variables can be kept in memory long after a containing function has finished executing.\n    ","url":"https://solutionschecker.com/questions/how-do-javascript-closures-work-1657384418555#solution29","@type":"Answer","upvoteCount":0},{"text":"I&apos;d simply point them to the Mozilla Closures page. It&apos;s the best, most concise and simple explanation of closure basics and practical usage that I&apos;ve found. It is highly recommended to anyone learning JavaScript.\n\nAnd yes, I&apos;d even recommend it to a 6-year old -- if the 6-year old is learning about closures, then it&apos;s logical they&apos;re ready to comprehend the concise and simple explanation provided in the article.\n    ","url":"https://solutionschecker.com/questions/how-do-javascript-closures-work-1657384418555#solution30","@type":"Answer","upvoteCount":0}],"@type":"Question"}}</script><meta name="next-head-count" content="22"/><script id="google-analytics" data-nscript="beforeInteractive">(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
})(window,document,'script','dataLayer','GTM-NXVLL8B');</script><link rel="preload" href="/_next/static/css/c116652e2d6f4ad0.css" as="style"/><link rel="stylesheet" href="/_next/static/css/c116652e2d6f4ad0.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-0d1b80a048d4787e.js"></script><script src="/_next/static/chunks/webpack-42cdea76c8170223.js" defer=""></script><script src="/_next/static/chunks/framework-4556c45dd113b893.js" defer=""></script><script src="/_next/static/chunks/main-ccfab947c79712f4.js" defer=""></script><script src="/_next/static/chunks/pages/_app-862498b6ec7885c3.js" defer=""></script><script src="/_next/static/chunks/294-106ef8570fa99deb.js" defer=""></script><script src="/_next/static/chunks/490-7f0418bb4354ac73.js" defer=""></script><script src="/_next/static/chunks/pages/questions/%5Bslug%5D-47289857226115f9.js" defer=""></script><script src="/_next/static/xZs8haGjOP63QuDE0kxeX/_buildManifest.js" defer=""></script><script src="/_next/static/xZs8haGjOP63QuDE0kxeX/_ssgManifest.js" defer=""></script></head><body><noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-NXVLL8B"
        height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript><div id="__next"><div class="wrapper"><header><nav class="bg-white border-gray-200 px-4 lg:px-6 py-2.5 dark:bg-gray-800"><div class="flex flex-wrap justify-between items-center mx-auto max-w-screen-xl"><a class="flex items-center" href="/"><img src="/logo-second.png" class="mr-3 h-6 sm:h-9" alt="Solution Checker Logo"/><h1 class="self-center text-xl font-semibold whitespace-nowrap dark:text-white">Solution Checker</h1></a><div class="flex items-center lg:order-2"><button data-collapse-toggle="mobile-menu-2" type="button" class="inline-flex items-center p-2 ml-1 text-sm text-gray-500 rounded-lg lg:hidden hover:bg-gray-100 focus:outline-none focus:ring-2 focus:ring-gray-200 dark:text-gray-400 dark:hover:bg-gray-700 dark:focus:ring-gray-600" aria-controls="mobile-menu-2" aria-expanded="false"><span class="sr-only">Open main menu</span><svg class="w-6 h-6" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M3 5a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM3 10a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM3 15a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1z" clip-rule="evenodd"></path></svg><svg class="hidden w-6 h-6" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z" clip-rule="evenodd"></path></svg></button></div><div class="hidden justify-between items-center w-full lg:flex lg:w-auto lg:order-1" id="mobile-menu-2"><ul class="flex flex-col mt-4 font-medium lg:flex-row lg:space-x-8 lg:mt-0"><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" aria-current="page" href="/">Home</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/questions?tab=news">Questions</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/post?tab=news">Post</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/questions/how-do-javascript-closures-work-1657384418555#">Coding</a></li></ul></div></div></nav></header><div class="main-content"><div class="question my-5"><div class="flex question-header items-center m-auto justify-center"><div class="rounded-xl w-full border p-5 shadow-md bg-white"><div class="flex w-full items-center justify-between border-b pb-3"><div class="flex items-center space-x-3"><div class="text-lg font-bold text-slate-700"><a href="/questions/how-do-javascript-closures-work-1657384418555"><h1>How do JavaScript closures work?</h1></a></div></div><div class="flex flex-wrap h-auto justify-end items-center space-x-8"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold" href="/questions/tag/scope">scope</a></div></div><div class="question-content mt-5">
                    <div>
            <aside class="s-notice s-notice__info post-notice js-post-notice mb16" role="status">
        <div class="d-flex fd-column fw-nowrap">
            <div class="d-flex fw-nowrap">
                    <div class="flex--item mr8">
                        <svg aria-hidden="true" class="svg-icon iconLock" width="18" height="18" viewBox="0 0 18 18"><path d="M16 9a2 2 0 0 0-2-2V6A5 5 0 0 0 4 6v1a2 2 0 0 0-2 2v6c0 1.1.9 2 2 2h10a2 2 0 0 0 2-2V9Zm-7 5a2 2 0 1 1 0-4 2 2 0 0 1 0 4Zm3.1-7H5.9V6a3.1 3.1 0 0 1 6.2 0v1Z"></path></svg>
                    </div>
                <div class="flex--item wmn0 fl1 lh-lg">
                    <div class="flex--item fl1 lh-lg">
                        <b>This question's answers are a <a href="/help/privileges/edit-community-wiki">community effort</a></b>. Edit existing answers to improve this post. It is not currently accepting new answers or interactions.
                        
                    </div>
                </div>
            </div>
        </div>
</aside>

    </div>

<p>How would you explain JavaScript closures to someone with a knowledge of the concepts they consist of (for example functions, variables and the like), but does not understand closures themselves?</p>

<p>I have seen <a href="http://en.wikipedia.org/wiki/Scheme_%28programming_language%29" rel="noreferrer">the Scheme example</a> given on Wikipedia, but unfortunately it did not help.</p>
    </div></div></div><div class="solution-section"><nav class="flex pagination-solution flex-col justify-end"><h1 class="text-lg font-semibold mb-5">Navigate to solutions: </h1><ul class="inline-flex -space-x-px overflow-auto"><li class="pagination-solution-item"><span data-id="#solution1" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">1</span></li><li class="pagination-solution-item"><span data-id="#solution2" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">2</span></li><li class="pagination-solution-item"><span data-id="#solution3" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">3</span></li><li class="pagination-solution-item"><span data-id="#solution4" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">4</span></li><li class="pagination-solution-item"><span data-id="#solution5" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">5</span></li><li class="pagination-solution-item"><span data-id="#solution6" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">6</span></li><li class="pagination-solution-item"><span data-id="#solution7" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">7</span></li><li class="pagination-solution-item"><span data-id="#solution8" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">8</span></li><li class="pagination-solution-item"><span data-id="#solution9" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">9</span></li><li class="pagination-solution-item"><span data-id="#solution10" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">10</span></li><li class="pagination-solution-item"><span data-id="#solution11" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">11</span></li><li class="pagination-solution-item"><span data-id="#solution12" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">12</span></li><li class="pagination-solution-item"><span data-id="#solution13" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">13</span></li><li class="pagination-solution-item"><span data-id="#solution14" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">14</span></li><li class="pagination-solution-item"><span data-id="#solution15" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">15</span></li><li class="pagination-solution-item"><span data-id="#solution16" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">16</span></li><li class="pagination-solution-item"><span data-id="#solution17" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">17</span></li><li class="pagination-solution-item"><span data-id="#solution18" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">18</span></li><li class="pagination-solution-item"><span data-id="#solution19" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">19</span></li><li class="pagination-solution-item"><span data-id="#solution20" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">20</span></li><li class="pagination-solution-item"><span data-id="#solution21" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">21</span></li><li class="pagination-solution-item"><span data-id="#solution22" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">22</span></li><li class="pagination-solution-item"><span data-id="#solution23" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">23</span></li><li class="pagination-solution-item"><span data-id="#solution24" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">24</span></li><li class="pagination-solution-item"><span data-id="#solution25" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">25</span></li><li class="pagination-solution-item"><span data-id="#solution26" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">26</span></li><li class="pagination-solution-item"><span data-id="#solution27" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">27</span></li><li class="pagination-solution-item"><span data-id="#solution28" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">28</span></li><li class="pagination-solution-item"><span data-id="#solution29" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">29</span></li><li class="pagination-solution-item"><span data-id="#solution30" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">30</span></li></ul></nav><div id="solution1" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 1</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/scope">scope</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>A closure is a pairing of:</p>
<ol>
<li>A function and</li>
<li>A reference to that function's outer scope (lexical environment)</li>
</ol>
<p>A lexical environment is part of every execution context (stack frame) and is a map between identifiers (i.e. local variable names) and values.</p>
<p>Every function in JavaScript maintains a reference to its outer lexical environment. This reference is used to configure the execution context created when a function is invoked. This reference enables code inside the function to "see" variables declared outside the function, regardless of when and where the function is called.</p>
<p>If a function was called by a function, which in turn was called by another function, then a chain of references to outer lexical environments is created. This chain is called the scope chain.</p>
<p>In the following code, <code>inner</code> forms a closure with the lexical environment of the execution context created when <code>foo</code> is invoked, <em>closing over</em> variable <code>secret</code>:</p>
<p></p><div class="snippet" data-lang="js" data-hide="false" data-console="true" data-babel="false">
<div class="snippet-code">
<pre class="snippet-code-js lang-js s-code-block"><code class="hljs language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">const</span> secret = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">trunc</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>() * <span class="hljs-number">100</span>)
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">inner</span>(<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`The secret number is <span class="hljs-subst">${secret}</span>.`</span>)
  }
}
<span class="hljs-keyword">const</span> f = <span class="hljs-title function_">foo</span>() <span class="hljs-comment">// `secret` is not directly accessible from outside `foo`</span>
<span class="hljs-title function_">f</span>() <span class="hljs-comment">// The only way to retrieve `secret`, is to invoke `f`</span></code></pre>
<div class="snippet-result"><div class="snippet-ctas"><button type="button" class="s-btn s-btn__primary"><span class="icon-play-white _hover"></span><span> Run code snippet</span></button><input class="copySnippet s-btn s-btn__filled" type="button" value="Copy snippet to answer" style="display: none;"><button type="button" class="s-btn hideResults" style="display: none;">Hide results</button><div class="popout-code"><a class="snippet-expand-link">Expand snippet</a></div></div><div class="snippet-result-code" style="display: none;"><iframe name="sif1" sandbox="allow-forms allow-modals allow-scripts" class="snippet-box-edit snippet-box-result" frameborder="0"></iframe></div></div></div>
</div>
<p></p>
<p>In other words: in JavaScript, functions carry a reference to a private "box of state", to which only they (and any other functions declared within the same lexical environment) have access. This box of the state is invisible to the caller of the function, delivering an excellent mechanism for data-hiding and encapsulation.</p>
<p>And remember: functions in JavaScript can be passed around like variables (first-class functions), meaning these pairings of functionality and state can be passed around your program: similar to how you might pass an instance of a class around in C++.</p>
<p>If JavaScript did not have closures, then more states would have to be passed between functions <em>explicitly</em>, making parameter lists longer and code noisier.</p>
<p>So, if you want a function to always have access to a private piece of state, you can use a closure.</p>
<p>...and frequently we <em>do</em> want to associate the state with a function. For example, in Java or C++, when you add a private instance variable and a method to a class, you are associating the state with functionality.</p>
<p>In C and most other common languages, after a function returns, all the local variables are no longer accessible because the stack-frame is destroyed. In JavaScript, if you declare a function within another function, then the local variables of the outer function can remain accessible after returning from it. In this way, in the code above, <code>secret</code> remains available to the function object <code>inner</code>, <em>after</em> it has been returned from <code>foo</code>.</p>
<h2>Uses of Closures</h2>
<p>Closures are useful whenever you need a private state associated with a function. This is a very common scenario - and remember: JavaScript did not have a class syntax until 2015, and it still does not have a private field syntax. Closures meet this need.</p>
<h3>Private Instance Variables</h3>
<p>In the following code, the function <code>toString</code> closes over the details of the car.</p>
<p></p><div class="snippet" data-lang="js" data-hide="false" data-console="true" data-babel="false">
<div class="snippet-code">
<pre class="snippet-code-js lang-js s-code-block"><code class="hljs language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Car</span>(<span class="hljs-params">manufacturer, model, year, color</span>) {
  <span class="hljs-keyword">return</span> {
    <span class="hljs-title function_">toString</span>(<span class="hljs-params"></span>) {
      <span class="hljs-keyword">return</span> <span class="hljs-string">`<span class="hljs-subst">${manufacturer}</span> <span class="hljs-subst">${model}</span> (<span class="hljs-subst">${year}</span>, <span class="hljs-subst">${color}</span>)`</span>
    }
  }
}

<span class="hljs-keyword">const</span> car = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Car</span>(<span class="hljs-string">'Aston Martin'</span>, <span class="hljs-string">'V8 Vantage'</span>, <span class="hljs-string">'2012'</span>, <span class="hljs-string">'Quantum Silver'</span>)
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(car.<span class="hljs-title function_">toString</span>())</code></pre>
<div class="snippet-result"><div class="snippet-ctas"><button type="button" class="s-btn s-btn__primary"><span class="icon-play-white _hover"></span><span> Run code snippet</span></button><input class="copySnippet s-btn s-btn__filled" type="button" value="Copy snippet to answer" style="display: none;"><button type="button" class="s-btn hideResults" style="display: none;">Hide results</button><div class="popout-code"><a class="snippet-expand-link">Expand snippet</a></div></div><div class="snippet-result-code" style="display: none;"><iframe name="sif2" sandbox="allow-forms allow-modals allow-scripts" class="snippet-box-edit snippet-box-result" frameborder="0"></iframe></div></div></div>
</div>
<p></p>
<h3>Functional Programming</h3>
<p>In the following code, the function <code>inner</code> closes over both <code>fn</code> and <code>args</code>.</p>
<p></p><div class="snippet" data-lang="js" data-hide="false" data-console="true" data-babel="false">
<div class="snippet-code">
<pre class="snippet-code-js lang-js s-code-block"><code class="hljs language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">curry</span>(<span class="hljs-params">fn</span>) {
  <span class="hljs-keyword">const</span> args = []
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">inner</span>(<span class="hljs-params">arg</span>) {
    <span class="hljs-keyword">if</span>(args.<span class="hljs-property">length</span> === fn.<span class="hljs-property">length</span>) <span class="hljs-keyword">return</span> <span class="hljs-title function_">fn</span>(...args)
    args.<span class="hljs-title function_">push</span>(arg)
    <span class="hljs-keyword">return</span> inner
  }
}

<span class="hljs-keyword">function</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">a, b</span>) {
  <span class="hljs-keyword">return</span> a + b
}

<span class="hljs-keyword">const</span> curriedAdd = <span class="hljs-title function_">curry</span>(add)
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">curriedAdd</span>(<span class="hljs-number">2</span>)(<span class="hljs-number">3</span>)()) <span class="hljs-comment">// 5</span></code></pre>
<div class="snippet-result"><div class="snippet-ctas"><button type="button" class="s-btn s-btn__primary"><span class="icon-play-white _hover"></span><span> Run code snippet</span></button><input class="copySnippet s-btn s-btn__filled" type="button" value="Copy snippet to answer" style="display: none;"><button type="button" class="s-btn hideResults" style="display: none;">Hide results</button><div class="popout-code"><a class="snippet-expand-link">Expand snippet</a></div></div><div class="snippet-result-code" style="display: none;"><iframe name="sif3" sandbox="allow-forms allow-modals allow-scripts" class="snippet-box-edit snippet-box-result" frameborder="0"></iframe></div></div></div>
</div>
<p></p>
<h3>Event-Oriented Programming</h3>
<p>In the following code, function <code>onClick</code> closes over variable <code>BACKGROUND_COLOR</code>.</p>
<p></p><div class="snippet" data-lang="js" data-hide="false" data-console="true" data-babel="false">
<div class="snippet-code">
<pre class="snippet-code-js lang-js s-code-block"><code class="hljs language-javascript"><span class="hljs-keyword">const</span> $ = <span class="hljs-variable language_">document</span>.<span class="hljs-property">querySelector</span>.<span class="hljs-title function_">bind</span>(<span class="hljs-variable language_">document</span>)
<span class="hljs-keyword">const</span> <span class="hljs-variable constant_">BACKGROUND_COLOR</span> = <span class="hljs-string">'rgba(200, 200, 242, 1)'</span>

<span class="hljs-keyword">function</span> <span class="hljs-title function_">onClick</span>(<span class="hljs-params"></span>) {
  $(<span class="hljs-string">'body'</span>).<span class="hljs-property">style</span>.<span class="hljs-property">background</span> = <span class="hljs-variable constant_">BACKGROUND_COLOR</span>
}

$(<span class="hljs-string">'button'</span>).<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">'click'</span>, onClick)</code></pre>
<pre class="snippet-code-html lang-html s-code-block"><code class="hljs language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span>&gt;</span>Set background color<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></code></pre>
<div class="snippet-result"><div class="snippet-ctas"><button type="button" class="s-btn s-btn__primary"><span class="icon-play-white _hover"></span><span> Run code snippet</span></button><input class="copySnippet s-btn s-btn__filled" type="button" value="Copy snippet to answer" style="display: none;"><button type="button" class="s-btn hideResults" style="display: none;">Hide results</button><div class="popout-code"><a class="snippet-expand-link">Expand snippet</a></div></div><div class="snippet-result-code" style="display: none;"><iframe name="sif4" sandbox="allow-forms allow-modals allow-scripts" class="snippet-box-edit snippet-box-result" frameborder="0"></iframe></div></div></div>
</div>
<p></p>
<h3>Modularization</h3>
<p>In the following example, all the implementation details are hidden inside an immediately executed function expression. The functions <code>tick</code> and <code>toString</code> close over the private state and functions they need to complete their work. Closures have enabled us to modularize and encapsulate our code.</p>
<p></p><div class="snippet" data-lang="js" data-hide="false" data-console="true" data-babel="false">
<div class="snippet-code">
<pre class="snippet-code-js lang-js s-code-block"><code class="hljs language-javascript"><span class="hljs-keyword">let</span> namespace = {};

(<span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">n</span>) {
  <span class="hljs-keyword">let</span> numbers = []

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">format</span>(<span class="hljs-params">n</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">trunc</span>(n)
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">tick</span>(<span class="hljs-params"></span>) {
    numbers.<span class="hljs-title function_">push</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>() * <span class="hljs-number">100</span>)
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">toString</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">return</span> numbers.<span class="hljs-title function_">map</span>(format)
  }

  n.<span class="hljs-property">counter</span> = {
    tick,
    toString
  }
}(namespace))

<span class="hljs-keyword">const</span> counter = namespace.<span class="hljs-property">counter</span>
counter.<span class="hljs-title function_">tick</span>()
counter.<span class="hljs-title function_">tick</span>()
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(counter.<span class="hljs-title function_">toString</span>())</code></pre>
<div class="snippet-result"><div class="snippet-ctas"><button type="button" class="s-btn s-btn__primary"><span class="icon-play-white _hover"></span><span> Run code snippet</span></button><input class="copySnippet s-btn s-btn__filled" type="button" value="Copy snippet to answer" style="display: none;"><button type="button" class="s-btn hideResults" style="display: none;">Hide results</button><div class="popout-code"><a class="snippet-expand-link">Expand snippet</a></div></div><div class="snippet-result-code" style="display: none;"><iframe name="sif5" sandbox="allow-forms allow-modals allow-scripts" class="snippet-box-edit snippet-box-result" frameborder="0"></iframe></div></div></div>
</div>
<p></p>
<h2>Examples</h2>
<h3>Example 1</h3>
<p>This example shows that the local variables are not copied in the closure: the closure maintains a reference to the original variables <em>themselves</em>. It is as though the stack-frame stays alive in memory even after the outer function exits.</p>
<p></p><div class="snippet" data-lang="js" data-hide="false" data-console="true" data-babel="false">
<div class="snippet-code">
<pre class="snippet-code-js lang-js s-code-block"><code class="hljs language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">let</span> x = <span class="hljs-number">42</span>
  <span class="hljs-keyword">let</span> <span class="hljs-title function_">inner</span> = (<span class="hljs-params"></span>) =&gt; <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(x)
  x = x + <span class="hljs-number">1</span>
  <span class="hljs-keyword">return</span> inner
}

<span class="hljs-title function_">foo</span>()() <span class="hljs-comment">// logs 43</span></code></pre>
<div class="snippet-result"><div class="snippet-ctas"><button type="button" class="s-btn s-btn__primary"><span class="icon-play-white _hover"></span><span> Run code snippet</span></button><input class="copySnippet s-btn s-btn__filled" type="button" value="Copy snippet to answer" style="display: none;"><button type="button" class="s-btn hideResults" style="display: none;">Hide results</button><div class="popout-code"><a class="snippet-expand-link">Expand snippet</a></div></div><div class="snippet-result-code" style="display: none;"><iframe name="sif6" sandbox="allow-forms allow-modals allow-scripts" class="snippet-box-edit snippet-box-result" frameborder="0"></iframe></div></div></div>
</div>
<p></p>
<h3>Example 2</h3>
<p>In the following code, three methods <code>log</code>, <code>increment</code>, and <code>update</code> all close over the same lexical environment.</p>
<p>And every time <code>createObject</code> is called, a new execution context (stack frame) is created and a completely new variable <code>x</code>, and a new set of functions (<code>log</code> etc.) are created, that close over this new variable.</p>
<p></p><div class="snippet" data-lang="js" data-hide="false" data-console="true" data-babel="false">
<div class="snippet-code">
<pre class="snippet-code-js lang-js s-code-block"><code class="hljs language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">createObject</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">let</span> x = <span class="hljs-number">42</span>;
  <span class="hljs-keyword">return</span> {
    <span class="hljs-title function_">log</span>(<span class="hljs-params"></span>) { <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(x) },
    <span class="hljs-title function_">increment</span>(<span class="hljs-params"></span>) { x++ },
    <span class="hljs-title function_">update</span>(<span class="hljs-params">value</span>) { x = value }
  }
}

<span class="hljs-keyword">const</span> o = <span class="hljs-title function_">createObject</span>()
o.<span class="hljs-title function_">increment</span>()
o.<span class="hljs-title function_">log</span>() <span class="hljs-comment">// 43</span>
o.<span class="hljs-title function_">update</span>(<span class="hljs-number">5</span>)
o.<span class="hljs-title function_">log</span>() <span class="hljs-comment">// 5</span>
<span class="hljs-keyword">const</span> p = <span class="hljs-title function_">createObject</span>()
p.<span class="hljs-title function_">log</span>() <span class="hljs-comment">// 42</span></code></pre>
<div class="snippet-result"><div class="snippet-ctas"><button type="button" class="s-btn s-btn__primary"><span class="icon-play-white _hover"></span><span> Run code snippet</span></button><input class="copySnippet s-btn s-btn__filled" type="button" value="Copy snippet to answer" style="display: none;"><button type="button" class="s-btn hideResults" style="display: none;">Hide results</button><div class="popout-code"><a class="snippet-expand-link">Expand snippet</a></div></div><div class="snippet-result-code" style="display: none;"><iframe name="sif7" sandbox="allow-forms allow-modals allow-scripts" class="snippet-box-edit snippet-box-result" frameborder="0"></iframe></div></div></div>
</div>
<p></p>
<h3>Example 3</h3>
<p>If you are using variables declared using <code>var</code>, be careful you understand which variable you are closing over. Variables declared using <code>var</code> are hoisted. This is much less of a problem in modern JavaScript due to the introduction of <code>let</code> and <code>const</code>.</p>
<p>In the following code, each time around the loop, a new function <code>inner</code> is created, which closes over <code>i</code>. But because <code>var i</code> is hoisted outside the loop, all of these inner functions close over the same variable, meaning that the final value of <code>i</code> (3) is printed, three times.</p>
<p></p><div class="snippet" data-lang="js" data-hide="false" data-console="true" data-babel="false">
<div class="snippet-code">
<pre class="snippet-code-js lang-js s-code-block"><code class="hljs language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">var</span> result = []
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++) {
    result.<span class="hljs-title function_">push</span>(<span class="hljs-keyword">function</span> <span class="hljs-title function_">inner</span>(<span class="hljs-params"></span>) { <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(i) } )
  }

  <span class="hljs-keyword">return</span> result
}

<span class="hljs-keyword">const</span> result = <span class="hljs-title function_">foo</span>()
<span class="hljs-comment">// The following will print `3`, three times...</span>
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++) {
  result[i]() 
}</code></pre>
<div class="snippet-result"><div class="snippet-ctas"><button type="button" class="s-btn s-btn__primary"><span class="icon-play-white _hover"></span><span> Run code snippet</span></button><input class="copySnippet s-btn s-btn__filled" type="button" value="Copy snippet to answer" style="display: none;"><button type="button" class="s-btn hideResults" style="display: none;">Hide results</button><div class="popout-code"><a class="snippet-expand-link">Expand snippet</a></div></div><div class="snippet-result-code" style="display: none;"><iframe name="sif8" sandbox="allow-forms allow-modals allow-scripts" class="snippet-box-edit snippet-box-result" frameborder="0"></iframe></div></div></div>
</div>
<p></p>
<h2>Final points:</h2>
<ul>
<li>Whenever a function is declared in JavaScript closure is created.</li>
<li>Returning a <code>function</code> from inside another function is the classic example of closure, because the state inside the outer function is implicitly available to the returned inner function, even after the outer function has completed execution.</li>
<li>Whenever you use <code>eval()</code> inside a function, a closure is used. The text you <code>eval</code> can reference local variables of the function, and in the non-strict mode, you can even create new local variables by using <code>eval('var foo = ')</code>.</li>
<li>When you use <code>new Function()</code> (the <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function" rel="noreferrer">Function constructor</a>) inside a function, it does not close over its lexical environment: it closes over the global context instead. The new function cannot reference the local variables of the outer function.</li>
<li>A closure in JavaScript is like keeping a reference (<strong>NOT</strong> a copy) to the scope at the point of function declaration, which in turn keeps a reference to its outer scope, and so on, all the way to the global object at the top of the scope chain.</li>
<li>A closure is created when a function is declared; this closure is used to configure the execution context when the function is invoked.</li>
<li>A new set of local variables is created every time a function is called.</li>
</ul>
<h2>Links</h2>
<ul>
<li>Douglas Crockford's simulated <a href="http://www.crockford.com/javascript/private.html" rel="noreferrer">private attributes and private methods</a> for an object, using closures.</li>
<li>A great explanation of how closures can <a href="https://www.codeproject.com/Articles/12231/Memory-Leakage-in-Internet-Explorer-revisited" rel="noreferrer">cause memory leaks in IE</a> if you are not careful.</li>
<li>MDN documentation on <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures" rel="noreferrer">JavaScript Closures</a>.</li>
</ul>
    </div></div></div></div><div id="solution2" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 2</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/scope">scope</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Every function in JavaScript maintains a link to its outer lexical environment. A lexical environment is a map of all the names (eg. variables, parameters) within a scope, with their values.</p>

<p>So, whenever you see the <code>function</code> keyword, code inside that function has access to variables declared outside the function.</p>

<p></p><div class="snippet" data-lang="js" data-hide="false" data-console="true" data-babel="false">
<div class="snippet-code">
<pre class="snippet-code-js lang-js s-code-block"><code class="hljs language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">x</span>) {
  <span class="hljs-keyword">var</span> tmp = <span class="hljs-number">3</span>;

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">bar</span>(<span class="hljs-params">y</span>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(x + y + (++tmp)); <span class="hljs-comment">// will log 16</span>
  }

  <span class="hljs-title function_">bar</span>(<span class="hljs-number">10</span>);
}

<span class="hljs-title function_">foo</span>(<span class="hljs-number">2</span>);</code></pre>
<div class="snippet-result"><div class="snippet-ctas"><button type="button" class="s-btn s-btn__primary"><span class="icon-play-white _hover"></span><span> Run code snippet</span></button><input class="copySnippet s-btn s-btn__filled" type="button" value="Copy snippet to answer" style="display: none;"><button type="button" class="s-btn hideResults" style="display: none;">Hide results</button><div class="popout-code"><a class="snippet-expand-link">Expand snippet</a></div></div><div class="snippet-result-code" style="display: none;"><iframe name="sif9" sandbox="allow-forms allow-modals allow-scripts" class="snippet-box-edit snippet-box-result" frameborder="0"></iframe></div></div></div>
</div>
<p></p>

<p>This will log <code>16</code> because function <code>bar</code> closes over the parameter <code>x</code> and the variable <code>tmp</code>, both of which exist in the lexical environment of outer function <code>foo</code>.</p>

<p>Function <code>bar</code>, together with its link with the lexical environment of function <code>foo</code> is a closure. </p>

<p>A function doesn't have to <em>return</em> in order to create a closure. Simply by virtue of its declaration, every function closes over its enclosing lexical environment, forming a closure.</p>

<p></p><div class="snippet" data-lang="js" data-hide="false" data-console="true" data-babel="false">
<div class="snippet-code">
<pre class="snippet-code-js lang-js s-code-block"><code class="hljs language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">x</span>) {
  <span class="hljs-keyword">var</span> tmp = <span class="hljs-number">3</span>;

  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params">y</span>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(x + y + (++tmp)); <span class="hljs-comment">// will also log 16</span>
  }
}

<span class="hljs-keyword">var</span> bar = <span class="hljs-title function_">foo</span>(<span class="hljs-number">2</span>);
<span class="hljs-title function_">bar</span>(<span class="hljs-number">10</span>); <span class="hljs-comment">// 16</span>
<span class="hljs-title function_">bar</span>(<span class="hljs-number">10</span>); <span class="hljs-comment">// 17</span></code></pre>
<div class="snippet-result"><div class="snippet-ctas"><button type="button" class="s-btn s-btn__primary"><span class="icon-play-white _hover"></span><span> Run code snippet</span></button><input class="copySnippet s-btn s-btn__filled" type="button" value="Copy snippet to answer" style="display: none;"><button type="button" class="s-btn hideResults" style="display: none;">Hide results</button><div class="popout-code"><a class="snippet-expand-link">Expand snippet</a></div></div><div class="snippet-result-code" style="display: none;"><iframe name="sif10" sandbox="allow-forms allow-modals allow-scripts" class="snippet-box-edit snippet-box-result" frameborder="0"></iframe></div></div></div>
</div>
<p></p>

<p>The above function will also log 16, because the code inside <code>bar</code> can still refer to argument <code>x</code> and variable <code>tmp</code>, even though they are no longer directly in scope.</p>

<p>However, since <code>tmp</code> is still hanging around inside <code>bar</code>'s closure, it is available to be incremented. It will be incremented each time you call <code>bar</code>.</p>

<p>The simplest example of a closure is this:</p>

<p></p><div class="snippet" data-lang="js" data-hide="false" data-console="true" data-babel="false">
<div class="snippet-code">
<pre class="snippet-code-js lang-js s-code-block"><code class="hljs language-javascript"><span class="hljs-keyword">var</span> a = <span class="hljs-number">10</span>;

<span class="hljs-keyword">function</span> <span class="hljs-title function_">test</span>(<span class="hljs-params"></span>) {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a); <span class="hljs-comment">// will output 10</span>
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(b); <span class="hljs-comment">// will output 6</span>
}
<span class="hljs-keyword">var</span> b = <span class="hljs-number">6</span>;
<span class="hljs-title function_">test</span>();</code></pre>
<div class="snippet-result"><div class="snippet-ctas"><button type="button" class="s-btn s-btn__primary"><span class="icon-play-white _hover"></span><span> Run code snippet</span></button><input class="copySnippet s-btn s-btn__filled" type="button" value="Copy snippet to answer" style="display: none;"><button type="button" class="s-btn hideResults" style="display: none;">Hide results</button><div class="popout-code"><a class="snippet-expand-link">Expand snippet</a></div></div><div class="snippet-result-code" style="display: none;"><iframe name="sif11" sandbox="allow-forms allow-modals allow-scripts" class="snippet-box-edit snippet-box-result" frameborder="0"></iframe></div></div></div>
</div>
<p></p>

<p>When a JavaScript function is invoked, a new execution context <code>ec</code> is created. Together with the function arguments and the target object, this execution context also receives a link to the lexical environment of the calling execution context, meaning the variables declared in the outer lexical environment (in the above example, both <code>a</code> and <code>b</code>) are available from <code>ec</code>.</p>

<p>Every function creates a closure because every function has a link to its outer lexical environment. </p>

<p>Note that variables <em>themselves</em> are visible from within a closure, <em>not</em> copies.</p>
    </div></div></div></div><div id="solution3" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 3</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/scope">scope</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>FOREWORD: this answer was written when the question was:</p>

<blockquote>
  <p>Like the old Albert said : "If you can't explain it to a six-year old, you really don't understand it yourself.. Well I tried to explain JS closures to a 27 years old friend and completely failed.</p>
  
  <p>Can anybody consider that I am 6 and strangely interested in that subject ?</p>
</blockquote>

<p>I'm pretty sure I was one of the only people that attempted to take the initial question literally. Since then, the question has mutated several times, so my answer may now seem incredibly silly &amp; out of place. Hopefully the general idea of the story remains fun for some.</p>

<hr>

<p>I'm a big fan of analogy and metaphor when explaining difficult concepts, so let me try my hand with a story.</p>

<p><strong>Once upon a time:</strong></p>

<p>There was a princess...</p>

<pre class="lang-js s-code-block"><code class="hljs language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">princess</span>(<span class="hljs-params"></span>) {
</code></pre>

<p>She lived in a wonderful world full of adventures. She met her Prince Charming, rode around her world on a unicorn, battled dragons, encountered talking animals, and many other fantastical things.</p>

<pre class="lang-js s-code-block"><code class="hljs language-javascript">    <span class="hljs-keyword">var</span> adventures = [];

    <span class="hljs-keyword">function</span> <span class="hljs-title function_">princeCharming</span>(<span class="hljs-params"></span>) { <span class="hljs-comment">/* ... */</span> }

    <span class="hljs-keyword">var</span> unicorn = { <span class="hljs-comment">/* ... */</span> },
        dragons = [ <span class="hljs-comment">/* ... */</span> ],
        squirrel = <span class="hljs-string">"Hello!"</span>;

    <span class="hljs-comment">/* ... */</span>
</code></pre>

<p>But she would always have to return back to her dull world of chores and grown-ups.</p>

<pre class="lang-js s-code-block"><code class="hljs language-javascript">    <span class="hljs-keyword">return</span> {
</code></pre>

<p>And she would often tell them of her latest amazing adventure as a princess.</p>

<pre class="lang-js s-code-block"><code class="hljs language-javascript">        <span class="hljs-attr">story</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) {
            <span class="hljs-keyword">return</span> adventures[adventures.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>];
        }
    };
}
</code></pre>

<p>But all they would see is a little girl...</p>

<pre class="lang-js s-code-block"><code class="hljs language-javascript"><span class="hljs-keyword">var</span> littleGirl = <span class="hljs-title function_">princess</span>();
</code></pre>

<p>...telling stories about magic and fantasy.</p>

<pre class="lang-js s-code-block"><code class="hljs language-javascript">littleGirl.<span class="hljs-title function_">story</span>();
</code></pre>

<p>And even though the grown-ups knew of real princesses, they would never believe in the unicorns or dragons because they could never see them. The grown-ups said that they only existed inside the little girl's imagination.</p>

<p>But we know the real truth; that the little girl with the princess inside...</p>

<p>...is really a princess with a little girl inside.</p>
    </div></div></div></div><div id="solution4" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 4</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/scope">scope</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Taking the question seriously, we should find out what a typical 6-year-old is capable of cognitively, though admittedly, one who is interested in JavaScript is not so typical.  </p>

<p>On  <a href="http://www.howkidsdevelop.com/5-7years.html" rel="noreferrer">Childhood Development: 5 to 7 Years </a> it says:</p>

<blockquote>
  <p>Your child will be able to follow two-step directions. For example, if you say to your child, "Go to the kitchen and get me a trash bag" they will be able to remember that direction.</p>
</blockquote>

<p>We can use this example to explain closures, as follows:</p>

<blockquote>
  <p>The kitchen is a closure that has a local variable, called <code>trashBags</code>.  There is a function inside the kitchen called <code>getTrashBag</code> that gets one trash bag and returns it.</p>
</blockquote>

<p>We can code this in JavaScript like this:</p>

<p></p><div class="snippet" data-lang="js" data-hide="false" data-console="true" data-babel="false">
<div class="snippet-code">
<pre class="snippet-code-js lang-js s-code-block"><code class="hljs language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">makeKitchen</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">var</span> trashBags = [<span class="hljs-string">'A'</span>, <span class="hljs-string">'B'</span>, <span class="hljs-string">'C'</span>]; <span class="hljs-comment">// only 3 at first</span>

  <span class="hljs-keyword">return</span> {
    <span class="hljs-attr">getTrashBag</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) {
      <span class="hljs-keyword">return</span> trashBags.<span class="hljs-title function_">pop</span>();
    }
  };
}

<span class="hljs-keyword">var</span> kitchen = <span class="hljs-title function_">makeKitchen</span>();

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(kitchen.<span class="hljs-title function_">getTrashBag</span>()); <span class="hljs-comment">// returns trash bag C</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(kitchen.<span class="hljs-title function_">getTrashBag</span>()); <span class="hljs-comment">// returns trash bag B</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(kitchen.<span class="hljs-title function_">getTrashBag</span>()); <span class="hljs-comment">// returns trash bag A</span></code></pre>
<div class="snippet-result"><div class="snippet-ctas"><button type="button" class="s-btn s-btn__primary"><span class="icon-play-white _hover"></span><span> Run code snippet</span></button><input class="copySnippet s-btn s-btn__filled" type="button" value="Copy snippet to answer" style="display: none;"><button type="button" class="s-btn hideResults" style="display: none;">Hide results</button><div class="popout-code"><a class="snippet-expand-link">Expand snippet</a></div></div><div class="snippet-result-code" style="display: none;"><iframe name="sif12" sandbox="allow-forms allow-modals allow-scripts" class="snippet-box-edit snippet-box-result" frameborder="0"></iframe></div></div></div>
</div>
<p></p>

<p>Further points that explain why closures are interesting:</p>

<ul>
<li>Each time <code>makeKitchen()</code> is called, a new closure is created with its own separate <code>trashBags</code>.</li>
<li>The <code>trashBags</code> variable is local to the inside of each kitchen and is not accessible outside, but the inner function on the <code>getTrashBag</code> property does have access to it.  </li>
<li>Every function call creates a closure, but there would be no need to keep the closure around unless an inner function, which has access to the inside of the closure, can be called from outside the closure.  Returning the object with the <code>getTrashBag</code> function does that here.</li>
</ul>
    </div></div></div></div><div id="solution5" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 5</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/scope">scope</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<h1>The Straw Man</h1>
<p>I need to know how many times a button has been clicked and do something on every third click...</p>
<h2>Fairly Obvious Solution</h2>
<p></p><div class="snippet" data-lang="js" data-hide="false" data-console="true" data-babel="false">
<div class="snippet-code">
<pre class="snippet-code-js lang-js s-code-block"><code class="hljs language-javascript"><span class="hljs-comment">// Declare counter outside event handler's scope</span>
<span class="hljs-keyword">var</span> counter = <span class="hljs-number">0</span>;
<span class="hljs-keyword">var</span> element = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">'button'</span>);

element.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">"click"</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) {
  <span class="hljs-comment">// Increment outside counter</span>
  counter++;

  <span class="hljs-keyword">if</span> (counter === <span class="hljs-number">3</span>) {
    <span class="hljs-comment">// Do something every third time</span>
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"Third time's the charm!"</span>);

    <span class="hljs-comment">// Reset counter</span>
    counter = <span class="hljs-number">0</span>;
  }
});</code></pre>
<pre class="snippet-code-html lang-html s-code-block"><code class="hljs language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"button"</span>&gt;</span>Click Me!<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></code></pre>
<div class="snippet-result"><div class="snippet-ctas"><button type="button" class="s-btn s-btn__primary"><span class="icon-play-white _hover"></span><span> Run code snippet</span></button><input class="copySnippet s-btn s-btn__filled" type="button" value="Copy snippet to answer" style="display: none;"><button type="button" class="s-btn hideResults" style="display: none;">Hide results</button><div class="popout-code"><a class="snippet-expand-link">Expand snippet</a></div></div><div class="snippet-result-code" style="display: none;"><iframe name="sif13" sandbox="allow-forms allow-modals allow-scripts" class="snippet-box-edit snippet-box-result" frameborder="0"></iframe></div></div></div>
</div>
<p></p>
<p>Now this will work, but it does encroach into the outer scope by adding a variable, whose sole purpose is to keep track of the count. In some situations, this would be preferable as your outer application might need access to this information. But in this case, we are only changing every third click's behavior, so it is preferable to <strong>enclose this functionality inside the event handler</strong>.</p>
<h2>Consider this option</h2>
<p></p><div class="snippet" data-lang="js" data-hide="false" data-console="true" data-babel="false">
<div class="snippet-code">
<pre class="snippet-code-js lang-js s-code-block"><code class="hljs language-javascript"><span class="hljs-keyword">var</span> element = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">'button'</span>);

element.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">"click"</span>, (<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) {
  <span class="hljs-comment">// init the count to 0</span>
  <span class="hljs-keyword">var</span> count = <span class="hljs-number">0</span>;

  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) { <span class="hljs-comment">// &lt;- This function becomes the click handler</span>
    count++; <span class="hljs-comment">//    and will retain access to the above `count`</span>

    <span class="hljs-keyword">if</span> (count === <span class="hljs-number">3</span>) {
      <span class="hljs-comment">// Do something every third time</span>
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"Third time's the charm!"</span>);

      <span class="hljs-comment">//Reset counter</span>
      count = <span class="hljs-number">0</span>;
    }
  };
})());</code></pre>
<pre class="snippet-code-html lang-html s-code-block"><code class="hljs language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"button"</span>&gt;</span>Click Me!<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></code></pre>
<div class="snippet-result"><div class="snippet-ctas"><button type="button" class="s-btn s-btn__primary"><span class="icon-play-white _hover"></span><span> Run code snippet</span></button><input class="copySnippet s-btn s-btn__filled" type="button" value="Copy snippet to answer" style="display: none;"><button type="button" class="s-btn hideResults" style="display: none;">Hide results</button><div class="popout-code"><a class="snippet-expand-link">Expand snippet</a></div></div><div class="snippet-result-code" style="display: none;"><iframe name="sif14" sandbox="allow-forms allow-modals allow-scripts" class="snippet-box-edit snippet-box-result" frameborder="0"></iframe></div></div></div>
</div>
<p></p>
<p>Notice a few things here.</p>
<p>In the above example, I am using the closure behavior of JavaScript. <strong>This behavior allows any function to have access to the scope in which it was created, indefinitely.</strong> To practically apply this, I immediately invoke a function that returns another function, and because the function I'm returning has access to the internal count variable (because of the closure behavior explained above) this results in a private scope for usage by the resulting function... Not so simple? Let's dilute it down...</p>
<p><strong>A simple one-line closure</strong></p>
<pre class="lang-js s-code-block"><code class="hljs language-javascript"><span class="hljs-comment">//          _______________________Immediately invoked______________________</span>
<span class="hljs-comment">//         |                                                                |</span>
<span class="hljs-comment">//         |        Scope retained for use      ___Returned as the____      |</span>
<span class="hljs-comment">//         |       only by returned function   |    value of func     |     |</span>
<span class="hljs-comment">//         |             |            |        |                      |     |</span>
<span class="hljs-comment">//         v             v            v        v                      v     v</span>
<span class="hljs-keyword">var</span> func = (<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) { <span class="hljs-keyword">var</span> a = <span class="hljs-string">'val'</span>; <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) { <span class="hljs-title function_">alert</span>(a); }; })();
</code></pre>
<p>All variables outside the returned function are available to the returned function, but they are not directly available to the returned function object...</p>
<pre class="lang-js s-code-block"><code class="hljs language-javascript"><span class="hljs-title function_">func</span>();  <span class="hljs-comment">// Alerts "val"</span>
func.<span class="hljs-property">a</span>;  <span class="hljs-comment">// Undefined</span>
</code></pre>
<p>Get it? So in our primary example, the count variable is contained within the closure and always available to the event handler, so it retains its state from click to click.</p>
<p>Also, this private variable state is <strong>fully</strong> accessible, for both readings and assigning to its private scoped variables.</p>
<p>There you go; you're now fully encapsulating this behavior.</p>
<p><strong><a href="http://jondavidjohn.com/javascript-closure-explained-using-events/" rel="noreferrer">Full Blog Post</a></strong> (including jQuery considerations)</p>
    </div></div></div></div><div id="solution6" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 6</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/scope">scope</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Closures are hard to explain because they are used to make some behaviour work that everybody intuitively expects to work anyway. I find the best way to explain them (and the way that <em>I</em> learned what they do) is to imagine the situation without them:</p>
<p></p><div class="snippet" data-lang="js" data-hide="false" data-console="true" data-babel="false">
<div class="snippet-code">
<pre class="snippet-code-js lang-js s-code-block"><code class="hljs language-javascript"><span class="hljs-keyword">const</span> makePlus = <span class="hljs-keyword">function</span>(<span class="hljs-params">x</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params">y</span>) { <span class="hljs-keyword">return</span> x + y; };
}

<span class="hljs-keyword">const</span> plus5 = <span class="hljs-title function_">makePlus</span>(<span class="hljs-number">5</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">plus5</span>(<span class="hljs-number">3</span>));</code></pre>
<div class="snippet-result"><div class="snippet-ctas"><button type="button" class="s-btn s-btn__primary"><span class="icon-play-white _hover"></span><span> Run code snippet</span></button><input class="copySnippet s-btn s-btn__filled" type="button" value="Copy snippet to answer" style="display: none;"><button type="button" class="s-btn hideResults" style="display: none;">Hide results</button><div class="popout-code"><a class="snippet-expand-link">Expand snippet</a></div></div><div class="snippet-result-code" style="display: none;"><iframe name="sif15" sandbox="allow-forms allow-modals allow-scripts" class="snippet-box-edit snippet-box-result" frameborder="0"></iframe></div></div></div>
</div>
<p></p>
<p>What would happen here if JavaScript <em>didn't</em> know closures? Just replace the call in the last line by its method body (which is basically what function calls do) and you get:</p>
<pre class="lang-js s-code-block"><code class="hljs language-javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(x + <span class="hljs-number">3</span>);
</code></pre>
<p>Now, where's the definition of <code>x</code>? We didn't define it in the current scope. The only solution is to let <code>plus5</code> <em>carry</em> its scope (or rather, its parent's scope) around. This way, <code>x</code> is well-defined and it is bound to the value 5.</p>
    </div></div></div></div><div id="solution7" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 7</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/scope">scope</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p><strong>TLDR</strong></p>

<p>A closure is a link between a function and its outer lexical (ie. as-written) environment, such that the identifiers (variables, parameters, function declarations etc) defined within that environment are visible from within the function, regardless of when or from where the function is invoked.</p>

<p><strong>Details</strong></p>

<p>In the terminology of the ECMAScript specification, a closure can be said to be implemented by the <a href="https://www.ecma-international.org/ecma-262/10.0/index.html#sec-functioninitialize" rel="noreferrer"><code>[[Environment]]</code></a> reference of every function-object, which points to the <a href="https://www.ecma-international.org/ecma-262/10.0/index.html#sec-lexical-environments" rel="noreferrer">lexical environment</a> within which the function is defined.</p>

<p>When a function is invoked via the internal <a href="https://www.ecma-international.org/ecma-262/10.0/index.html#sec-ecmascript-function-objects-call-thisargument-argumentslist" rel="noreferrer"><code>[[Call]]</code></a> method, the <a href="https://www.ecma-international.org/ecma-262/10.0/index.html#sec-functioninitialize" rel="noreferrer"><code>[[Environment]]</code></a> reference on the function-object is copied into the <em>outer environment reference</em> of the <a href="https://www.ecma-international.org/ecma-262/10.0/index.html#sec-environment-records" rel="noreferrer">environment record</a> of the newly-created <a href="https://www.ecma-international.org/ecma-262/10.0/index.html#sec-execution-contexts" rel="noreferrer">execution context</a> (stack frame).</p>

<p>In the following example, function <code>f</code> closes over the lexical environment of the global execution context:</p>

<pre class="lang-js s-code-block"><code class="hljs language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">f</span>(<span class="hljs-params"></span>) {}
</code></pre>

<p>In the following example, function <code>h</code> closes over the lexical environment of function <code>g</code>, which, in turn, closes over the lexical environment of the global execution context.</p>

<pre class="lang-js s-code-block"><code class="hljs language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">g</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">function</span> <span class="hljs-title function_">h</span>(<span class="hljs-params"></span>) {}
}
</code></pre>

<p>If an inner function is returned by an outer, then the outer lexical environment will persist after the outer function has returned. This is because the outer lexical environment needs to be available if the inner function is eventually invoked.</p>

<p>In the following example, function <code>j</code> closes over the lexical environment of function <code>i</code>, meaning that variable <code>x</code> is visible from inside function <code>j</code>, long after function <code>i</code> has completed execution:</p>

<p></p><div class="snippet" data-lang="js" data-hide="false" data-console="true" data-babel="false">
<div class="snippet-code">
<pre class="snippet-code-js lang-js s-code-block"><code class="hljs language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">i</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">var</span> x = <span class="hljs-string">'mochacchino'</span>
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">j</span>(<span class="hljs-params"></span>) {
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'Printing the value of x, from within function j: '</span>, x)
    }
} 

<span class="hljs-keyword">const</span> k = <span class="hljs-title function_">i</span>()
<span class="hljs-built_in">setTimeout</span>(k, <span class="hljs-number">500</span>) <span class="hljs-comment">// invoke k (which is j) after 500ms</span></code></pre>
<div class="snippet-result"><div class="snippet-ctas"><button type="button" class="s-btn s-btn__primary"><span class="icon-play-white _hover"></span><span> Run code snippet</span></button><input class="copySnippet s-btn s-btn__filled" type="button" value="Copy snippet to answer" style="display: none;"><button type="button" class="s-btn hideResults" style="display: none;">Hide results</button><div class="popout-code"><a class="snippet-expand-link">Expand snippet</a></div></div><div class="snippet-result-code" style="display: none;"><iframe name="sif16" sandbox="allow-forms allow-modals allow-scripts" class="snippet-box-edit snippet-box-result" frameborder="0"></iframe></div></div></div>
</div>
<p></p>

<p>In a closure, the variables in the outer lexical environment <em>themselves</em> are available, <em>not</em> copies.</p>

<p></p><div class="snippet" data-lang="js" data-hide="false" data-console="true" data-babel="false">
<div class="snippet-code">
<pre class="snippet-code-js lang-js s-code-block"><code class="hljs language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">l</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">var</span> y = <span class="hljs-string">'vanilla'</span>;

  <span class="hljs-keyword">return</span> {
    <span class="hljs-attr">setY</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">value</span>) {
      y = value;
    },
    <span class="hljs-attr">logY</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">value</span>) {
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'The value of y is: '</span>, y);
    }
  }
}

<span class="hljs-keyword">const</span> o = <span class="hljs-title function_">l</span>()
o.<span class="hljs-title function_">logY</span>() <span class="hljs-comment">// The value of y is: vanilla</span>
o.<span class="hljs-title function_">setY</span>(<span class="hljs-string">'chocolate'</span>)
o.<span class="hljs-title function_">logY</span>() <span class="hljs-comment">// The value of y is: chocolate</span></code></pre>
<div class="snippet-result"><div class="snippet-ctas"><button type="button" class="s-btn s-btn__primary"><span class="icon-play-white _hover"></span><span> Run code snippet</span></button><input class="copySnippet s-btn s-btn__filled" type="button" value="Copy snippet to answer" style="display: none;"><button type="button" class="s-btn hideResults" style="display: none;">Hide results</button><div class="popout-code"><a class="snippet-expand-link">Expand snippet</a></div></div><div class="snippet-result-code" style="display: none;"><iframe name="sif17" sandbox="allow-forms allow-modals allow-scripts" class="snippet-box-edit snippet-box-result" frameborder="0"></iframe></div></div></div>
</div>
<p></p>

<p>The chain of lexical environments, linked between execution contexts via outer environment references, forms a <em>scope chain</em> and defines the identifiers visible from any given function.</p>

<p><strong>Please note that in an attempt to improve clarity and accuracy, this answer has been substantially changed from the original.</strong></p>
    </div></div></div></div><div id="solution8" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 8</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/scope">scope</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>OK, 6-year-old closures fan. Do you want to hear the simplest example of closure?</p>

<p>Let's imagine the next situation: a driver is sitting in a car. That car is inside a plane. Plane is in the airport. The ability of driver to access things outside his car, but inside the plane, even if that plane leaves an airport, is a closure. That's it. When you turn 27, look at the <a href="https://stackoverflow.com/a/111200/1393791">more detailed explanation</a> or at the example below.</p>

<p>Here is how I can convert my plane story into the code.</p>

<p></p><div class="snippet" data-lang="js" data-hide="false" data-console="true" data-babel="false">
<div class="snippet-code">
<pre class="snippet-code-js lang-js s-code-block"><code class="hljs language-javascript"><span class="hljs-keyword">var</span> plane = <span class="hljs-keyword">function</span>(<span class="hljs-params">defaultAirport</span>) {

  <span class="hljs-keyword">var</span> lastAirportLeft = defaultAirport;

  <span class="hljs-keyword">var</span> car = {
    <span class="hljs-attr">driver</span>: {
      <span class="hljs-attr">startAccessPlaneInfo</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) {
        <span class="hljs-built_in">setInterval</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) {
          <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"Last airport was "</span> + lastAirportLeft);
        }, <span class="hljs-number">2000</span>);
      }
    }
  };
  car.<span class="hljs-property">driver</span>.<span class="hljs-title function_">startAccessPlaneInfo</span>();

  <span class="hljs-keyword">return</span> {
    <span class="hljs-attr">leaveTheAirport</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">airPortName</span>) {
      lastAirportLeft = airPortName;
    }
  }
}(<span class="hljs-string">"Boryspil International Airport"</span>);

plane.<span class="hljs-title function_">leaveTheAirport</span>(<span class="hljs-string">"John F. Kennedy"</span>);</code></pre>
<div class="snippet-result"><div class="snippet-ctas"><button type="button" class="s-btn s-btn__primary"><span class="icon-play-white _hover"></span><span> Run code snippet</span></button><input class="copySnippet s-btn s-btn__filled" type="button" value="Copy snippet to answer" style="display: none;"><button type="button" class="s-btn hideResults" style="display: none;">Hide results</button><div class="popout-code"><a class="snippet-expand-link">Expand snippet</a></div></div><div class="snippet-result-code" style="display: none;"><iframe name="sif18" sandbox="allow-forms allow-modals allow-scripts" class="snippet-box-edit snippet-box-result" frameborder="0"></iframe></div></div></div>
</div>
<p></p>
    </div></div></div></div><div id="solution9" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 9</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/scope">scope</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>This is an attempt to clear up several (possible) misunderstandings about closures that appear in some of the other answers.</p>

<ul>
<li><strong>A closure is not only created when you return an inner function.</strong> In fact, the enclosing function <em>does not need to return at all</em> in order for its closure to be created. You might instead assign your inner function to a variable in an outer scope, or pass it as an argument to another function where it could be called immediately or any time later. Therefore, the closure of the enclosing function is probably created <em>as soon as the enclosing function is called</em> since any inner function has access to that closure whenever the inner function is called, before or after the enclosing function returns. </li>
<li><strong>A closure does not reference a copy of the <em>old values</em> of variables in its scope.</strong> The variables themselves are part of the closure, and so the value seen when accessing one of those variables is the latest value at the time it is accessed. This is why inner functions created inside of loops can be tricky, since each one has access to the same outer variables rather than grabbing a copy of the variables at the time the function is created or called.</li>
<li><strong>The "variables" in a closure include any named functions</strong> declared within the function. They also include arguments of the function. A closure also has access to its containing closure's variables, all the way up to the global scope.</li>
<li><strong>Closures use memory, but they don't cause memory leaks</strong> since JavaScript by itself cleans up its own circular structures that are not referenced. Internet&nbsp;Explorer memory leaks involving closures are created when it fails to disconnect DOM attribute values that reference closures, thus maintaining references to possibly circular structures.</li>
</ul>
    </div></div></div></div><div id="solution10" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 10</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/scope">scope</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>I wrote a blog post a while back explaining closures. Here's what I said about closures in terms of <strong>why</strong> you'd want one.</p>

<blockquote>
  <p>Closures are a way to let a function
  have <strong>persistent, private variables</strong> -
  that is, variables that only one
  function knows about, where it can
  keep track of info from previous times
  that it was run.</p>
</blockquote>

<p>In that sense, they let a function act a bit like an object with private attributes.</p>

<p>Full post:</p>

<p><a href="http://sleeplessgeek.blogspot.com/2009/12/so-what-are-these-closure-thingys.html" rel="noreferrer">So what are these closure thingys?</a></p>
    </div></div></div></div><div id="solution11" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 11</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/scope">scope</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>The original question had a quote:</p>
<blockquote>
<p>If you can't explain it to a six-year old, you really don't understand it yourself.</p>
</blockquote>
<p>This is how I'd try to explain it to an actual six-year-old:</p>
<p>You know how grown-ups can own a house, and they call it home? When a mom has a child, the child doesn't really own anything, right? But its parents own a house, so whenever someone asks the child "Where's your home?", he/she can answer "that house!", and point to the house of its parents. A "Closure" is the ability of the child to always (even if abroad) be able to say it has a home, even though it's really the parent's who own the house.</p>
    </div></div></div></div><div id="solution12" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 12</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/scope">scope</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<h2><strong>Closures are simple:</strong></h2>

<p>The following simple example covers all the main points of JavaScript closures.<sup>*</sup>
&nbsp;</p>

<p>Here is a factory that produces calculators that can add and multiply:</p>

<pre class="lang-js s-code-block"><code class="hljs language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">make_calculator</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">var</span> n = <span class="hljs-number">0</span>; <span class="hljs-comment">// this calculator stores a single number n</span>
  <span class="hljs-keyword">return</span> {
    <span class="hljs-attr">add</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">a</span>) {
      n += a;
      <span class="hljs-keyword">return</span> n;
    },
    <span class="hljs-attr">multiply</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">a</span>) {
      n *= a;
      <span class="hljs-keyword">return</span> n;
    }
  };
}

first_calculator = <span class="hljs-title function_">make_calculator</span>();
second_calculator = <span class="hljs-title function_">make_calculator</span>();

first_calculator.<span class="hljs-title function_">add</span>(<span class="hljs-number">3</span>); <span class="hljs-comment">// returns 3</span>
second_calculator.<span class="hljs-title function_">add</span>(<span class="hljs-number">400</span>); <span class="hljs-comment">// returns 400</span>

first_calculator.<span class="hljs-title function_">multiply</span>(<span class="hljs-number">11</span>); <span class="hljs-comment">// returns 33</span>
second_calculator.<span class="hljs-title function_">multiply</span>(<span class="hljs-number">10</span>); <span class="hljs-comment">// returns 4000</span>
</code></pre>

<p><strong>The key point:</strong> Each call to <code>make_calculator</code> creates a new local variable <code>n</code>, which continues to be usable by that calculator's <code>add</code> and <code>multiply</code> functions long after <code>make_calculator</code> returns.</p>

<p><em>If you are familiar with stack frames, these calculators seem strange: How can they keep accessing <code>n</code> after <code>make_calculator</code> returns?  The answer is to imagine that JavaScript doesn't use "stack frames", but instead uses "heap frames", which can persist after the function call that made them returns.</em></p>

<p>Inner functions like <code>add</code> and <code>multiply</code>, which access variables declared in an outer function<sup>**</sup>, are called <em>closures</em>.</p>

<p><strong>That is pretty much all there is to closures.</strong></p>

<p><br></p>

<hr>

<p><sup><sup>*</sup> For example, it covers all the points in the "Closures for Dummies" article given in <a href="https://stackoverflow.com/a/111111/706054">another answer</a>, except example 6, which simply shows that variables can be used before they are declared, a nice fact to know but completely unrelated to closures. It also covers all the points in <a href="https://stackoverflow.com/a/111200/706054">the accepted answer</a>, except for the points (1) that functions copy their arguments into local variables (the named function arguments), and (2) that copying numbers creates a new number, but copying an object reference gives you another reference to the same object. These are also good to know but again completely unrelated to closures. It is also very similar to the example in <a href="https://stackoverflow.com/a/111114/706054">this answer</a> but a bit shorter and less abstract. It does not cover the point of <a href="https://stackoverflow.com/a/17200991/706054">this answer</a> or <a href="https://stackoverflow.com/questions/111102/how-do-javascript-closures-work/17308587?noredirect=1#comment26377355_111111">this comment</a>, which is that JavaScript makes it difficult to plug the <em>current</em> value of a loop variable into your inner function: The "plugging in" step can only be done with a helper function that encloses your inner function and is invoked on each loop iteration. (Strictly speaking, the inner function accesses the helper function's copy of the variable, rather than having anything plugged in.) Again, very useful when creating closures, but not part of what a closure is or how it works. There is additional confusion due to closures working differently in functional languages like ML, where variables are bound to values rather than to storage space, providing a constant stream of people who understand closures in a way (namely the "plugging in" way) that is simply incorrect for JavaScript, where variables are always bound to storage space, and never to values. </sup></p>

<p><sup><sup>**</sup> Any outer function, if several are nested, or even in the global context, as <a href="https://stackoverflow.com/a/5099447/706054">this answer</a> points out clearly.</sup></p>
    </div></div></div></div><div id="solution13" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 13</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/scope">scope</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<h2><a href="https://stackoverflow.com/questions/1700514/how-do-you-explain-closure-to-a-5-year-old/1700627#1700627">Can you explain closures to a 5-year-old?*</a></h2>
<p>I still think <a href="http://code.google.com/apis/ajax/playground/?exp=maps#closure_simple" rel="noreferrer">Google's explanation</a> works very well and is concise:</p>
<pre class="lang-js s-code-block"><code class="hljs language-javascript"><span class="hljs-comment">/*
*    When a function is defined in another function and it
*    has access to the outer function's context even after
*    the outer function returns.
*
* An important concept to learn in JavaScript.
*/</span>

<span class="hljs-keyword">function</span> <span class="hljs-title function_">outerFunction</span>(<span class="hljs-params">someNum</span>) {
    <span class="hljs-keyword">var</span> someString = <span class="hljs-string">'Hey!'</span>;
    <span class="hljs-keyword">var</span> content = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">'content'</span>);
    <span class="hljs-keyword">function</span> <span class="hljs-title function_">innerFunction</span>(<span class="hljs-params"></span>) {
        content.<span class="hljs-property">innerHTML</span> = someNum + <span class="hljs-string">': '</span> + someString;
        content = <span class="hljs-literal">null</span>; <span class="hljs-comment">// Internet Explorer memory leak for DOM reference</span>
    }
    <span class="hljs-title function_">innerFunction</span>();
}

<span class="hljs-title function_">outerFunction</span>(<span class="hljs-number">1</span>);
</code></pre>
<p><img src="https://i.stack.imgur.com/N0mn0.png" alt="Proof that this example creates a closure even if the inner function doesn't return"></p>
<p><sub>*A C# question</sub></p>
    </div></div></div></div><div id="solution14" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 14</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/scope">scope</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>I tend to learn better by GOOD/BAD comparisons. I like to see working code followed by non-working code that someone is likely to encounter. I put together <a href="http://jsfiddle.net/KMQZK/" rel="noreferrer">a jsFiddle</a> that does a comparison and tries to boil down the differences to the simplest explanations I could come up with.</p>
<h2>Closures done right:</h2>
<pre class="lang-js s-code-block"><code class="hljs language-javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'CLOSURES DONE RIGHT'</span>);

<span class="hljs-keyword">var</span> arr = [];

<span class="hljs-keyword">function</span> <span class="hljs-title function_">createClosure</span>(<span class="hljs-params">n</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
        <span class="hljs-keyword">return</span> <span class="hljs-string">'n = '</span> + n;
    }
}

<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> index = <span class="hljs-number">0</span>; index &lt; <span class="hljs-number">10</span>; index++) {
    arr[index] = <span class="hljs-title function_">createClosure</span>(index);
}

<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> index <span class="hljs-keyword">in</span> arr) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr[index]());
}
</code></pre>
<ul>
<li><p>In the above code <code>createClosure(n)</code> is invoked in every iteration of the loop. Note that I named the variable <code>n</code> to highlight that it is a <strong>new</strong> variable created in a new function scope and is not the same variable as <code>index</code> which is bound to the outer scope.</p>
</li>
<li><p>This creates a new scope and <code>n</code> is bound to that scope; this means we have 10 separate scopes, one for each iteration.</p>
</li>
<li><p><code>createClosure(n)</code> returns a function that returns the n within that scope.</p>
</li>
<li><p>Within each scope <code>n</code> is bound to whatever value it had when <code>createClosure(n)</code> was invoked so the nested function that gets returned will always return the value of <code>n</code> that it had when <code>createClosure(n)</code> was invoked.</p>
</li>
</ul>
<h2>Closures done wrong:</h2>
<pre class="lang-js s-code-block"><code class="hljs language-javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'CLOSURES DONE WRONG'</span>);

<span class="hljs-keyword">function</span> <span class="hljs-title function_">createClosureArray</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">var</span> badArr = [];

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> index = <span class="hljs-number">0</span>; index &lt; <span class="hljs-number">10</span>; index++) {
        badArr[index] = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
            <span class="hljs-keyword">return</span> <span class="hljs-string">'n = '</span> + index;
        };
    }
    <span class="hljs-keyword">return</span> badArr;
}

<span class="hljs-keyword">var</span> badArr = <span class="hljs-title function_">createClosureArray</span>();

<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> index <span class="hljs-keyword">in</span> badArr) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(badArr[index]());
}
</code></pre>
<ul>
<li><p>In the above code the loop was moved within the <code>createClosureArray()</code> function and the function now just returns the completed array, which at first glance seems more intuitive.</p>
</li>
<li><p>What might not be obvious is that since <code>createClosureArray()</code> is only invoked once only one scope is created for this function instead of one for every iteration of the loop.</p>
</li>
<li><p>Within this function a variable named <code>index</code> is defined. The loop runs and adds functions to the array that return <code>index</code>. Note that <code>index</code> is defined within the <code>createClosureArray</code> function which only ever gets invoked one time.</p>
</li>
<li><p>Because there was only one scope within the <code>createClosureArray()</code> function, <code>index</code> is only bound to a value within that scope. In other words, each time the loop changes the value of <code>index</code>, it changes it for everything that references it within that scope.</p>
</li>
<li><p>All of the functions added to the array return the SAME <code>index</code> variable from the parent scope where it was defined instead of 10 different ones from 10 different scopes like the first example. The end result is that all 10 functions return the same variable from the same scope.</p>
</li>
<li><p>After the loop finished and <code>index</code> was done being modified the end value was 10, therefore every function added to the array returns the value of the single <code>index</code> variable which is now set to 10.</p>
</li>
</ul>
<h2>Result</h2>
<blockquote>
<p>CLOSURES DONE RIGHT<br>
n = 0<br>
n = 1<br>
n = 2<br>
n = 3<br>
n = 4<br>
n = 5<br>
n = 6<br>
n = 7<br>
n = 8<br>
n = 9</p>
<p>CLOSURES DONE WRONG<br>
n = 10<br>
n = 10<br>
n = 10<br>
n = 10<br>
n = 10<br>
n = 10<br>
n = 10<br>
n = 10<br>
n = 10<br>
n = 10</p>
</blockquote>
    </div></div></div></div><div id="solution15" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 15</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/scope">scope</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p><a href="http://en.wikipedia.org/wiki/Closure_(computer_science)" rel="noreferrer">Wikipedia on closures</a>:</p>

<blockquote>
  <p>In computer science, a closure is a function together with a referencing environment for the nonlocal names (free variables) of that function.</p>
</blockquote>

<p>Technically, in <a href="http://en.wikipedia.org/wiki/JavaScript" rel="noreferrer">JavaScript</a>, <strong>every function is a closure</strong>. It always has an access to variables defined in the surrounding scope.</p>

<p>Since <strong>scope-defining construction in JavaScript is a function</strong>, not a code block like in many other languages, <strong>what we usually mean by <em>closure</em> in JavaScript</strong> is a <strong>function working with nonlocal variables defined in already executed surrounding function</strong>.</p>

<p>Closures are often used for creating functions with some hidden private data (but it's not always the case).</p>

<pre class="lang-js s-code-block"><code class="hljs language-javascript"><span class="hljs-keyword">var</span> db = (<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) {
    <span class="hljs-comment">// Create a hidden object, which will hold the data</span>
    <span class="hljs-comment">// it's inaccessible from the outside.</span>
    <span class="hljs-keyword">var</span> data = {};

    <span class="hljs-comment">// Make a function, which will provide some access to the data.</span>
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params">key, val</span>) {
        <span class="hljs-keyword">if</span> (val === <span class="hljs-literal">undefined</span>) { <span class="hljs-keyword">return</span> data[key] } <span class="hljs-comment">// Get</span>
        <span class="hljs-keyword">else</span> { <span class="hljs-keyword">return</span> data[key] = val } <span class="hljs-comment">// Set</span>
    }
    <span class="hljs-comment">// We are calling the anonymous surrounding function,</span>
    <span class="hljs-comment">// returning the above inner function, which is a closure.</span>
})();

<span class="hljs-title function_">db</span>(<span class="hljs-string">'x'</span>)    <span class="hljs-comment">// -&gt; undefined</span>
<span class="hljs-title function_">db</span>(<span class="hljs-string">'x'</span>, <span class="hljs-number">1</span>) <span class="hljs-comment">// Set x to 1</span>
<span class="hljs-title function_">db</span>(<span class="hljs-string">'x'</span>)    <span class="hljs-comment">// -&gt; 1</span>
<span class="hljs-comment">// It's impossible to access the data object itself.</span>
<span class="hljs-comment">// We are able to get or set individual it.</span>
</code></pre>

<p>ems</p>

<p>The example above is using an anonymous function, which was executed once. But it does not have to be. It can be named (e.g. <code>mkdb</code>) and executed later, generating a database function each time it is invoked. Every generated function will have its own hidden database object. Another usage example of closures is when we don't return a function, but an object containing multiple functions for different purposes, each of those function having access to the same data.</p>
    </div></div></div></div><div id="solution16" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 16</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/scope">scope</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>I put together an interactive JavaScript tutorial to explain how closures work.
<a href="http://nathansjslessons.appspot.com" rel="noreferrer">What's a Closure?</a></p>

<p>Here's one of the examples:</p>

<pre class="lang-js s-code-block"><code class="hljs language-javascript"><span class="hljs-keyword">var</span> create = <span class="hljs-keyword">function</span> (<span class="hljs-params">x</span>) {
    <span class="hljs-keyword">var</span> f = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
        <span class="hljs-keyword">return</span> x; <span class="hljs-comment">// We can refer to x here!</span>
    };
    <span class="hljs-keyword">return</span> f;
};
<span class="hljs-comment">// 'create' takes one argument, creates a function</span>

<span class="hljs-keyword">var</span> g = <span class="hljs-title function_">create</span>(<span class="hljs-number">42</span>);
<span class="hljs-comment">// g is a function that takes no arguments now</span>

<span class="hljs-keyword">var</span> y = <span class="hljs-title function_">g</span>();
<span class="hljs-comment">// y is 42 here</span>
</code></pre>
    </div></div></div></div><div id="solution17" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 17</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/scope">scope</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<blockquote>
  <p>The children will always remember the secrets they have shared with their parents, even after their parents are
  gone. This is what closures are for functions.</p>
</blockquote>

<p>The secrets for JavaScript functions are the private variables</p>

<pre class="lang-js s-code-block"><code class="hljs language-javascript"><span class="hljs-keyword">var</span> parent = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) {
 <span class="hljs-keyword">var</span> name = <span class="hljs-string">"Mary"</span>; <span class="hljs-comment">// secret</span>
}
</code></pre>

<p>Every time you call it, local variable "name" is created and given name "Mary". And every time the function exits the variable is lost and the name is forgotten.</p>

<p>As you may guess, because the variables are re-created every time the function is called, and nobody else will know them, there must be a secret place where they are stored. It could be called <strong>Chamber of Secrets</strong> or <strong>stack</strong> or <strong>local scope</strong> but it doesn't really matter. We know they are there, somewhere, hidden in the memory.</p>

<p>But, in JavaScript there is this very special thing that functions which are created inside other functions, can also know the local variables of their parents and keep them as long as they live.</p>

<pre class="lang-js s-code-block"><code class="hljs language-javascript"><span class="hljs-keyword">var</span> parent = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">var</span> name = <span class="hljs-string">"Mary"</span>;
  <span class="hljs-keyword">var</span> child = <span class="hljs-keyword">function</span>(<span class="hljs-params">childName</span>) {
    <span class="hljs-comment">// I can also see that "name" is "Mary"</span>
  }
}
</code></pre>

<p>So, as long as we are in the parent -function, it can create one or more child functions which do share the secret variables from the secret place.</p>

<p>But the sad thing is, if the child is also a private variable of its parent function, it would also die when the parent ends, and the secrets would die with them.</p>

<p>So to live, the child has to leave before it's too late</p>

<pre class="lang-js s-code-block"><code class="hljs language-javascript"><span class="hljs-keyword">var</span> parent = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">var</span> name = <span class="hljs-string">"Mary"</span>;
  <span class="hljs-keyword">var</span> child = <span class="hljs-keyword">function</span>(<span class="hljs-params">childName</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-string">"My name is "</span> + childName  +<span class="hljs-string">", child of "</span> + name; 
  }
  <span class="hljs-keyword">return</span> child; <span class="hljs-comment">// child leaves the parent -&gt;</span>
}
<span class="hljs-keyword">var</span> child = <span class="hljs-title function_">parent</span>(); <span class="hljs-comment">// &lt; - and here it is outside </span>
</code></pre>

<p>And now, even though Mary is "no longer running", the memory of her is not lost and her child will always remember her name and other secrets they shared during their time together.</p>

<p>So, if you call the child "Alice", she will respond</p>

<pre class="lang-js s-code-block"><code class="hljs language-javascript"><span class="hljs-title function_">child</span>(<span class="hljs-string">"Alice"</span>) =&gt; <span class="hljs-string">"My name is Alice, child of Mary"</span>
</code></pre>

<p>That's all there is to tell.</p>
    </div></div></div></div><div id="solution18" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 18</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/scope">scope</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p><strong>I do not understand why the answers are so complex here.</strong></p>
<p>Here is a closure:</p>
<pre class="lang-js s-code-block"><code class="hljs language-javascript"><span class="hljs-keyword">var</span> a = <span class="hljs-number">42</span>;

<span class="hljs-keyword">function</span> <span class="hljs-title function_">b</span>(<span class="hljs-params"></span>) { <span class="hljs-keyword">return</span> a; }
</code></pre>
<p>Yes. You probably use that many times a day.</p>
<br>
<blockquote>
<p>There is no reason to believe closures are a complex design hack to address specific problems. No, closures are just about using a variable that comes from a higher scope <strong>from the perspective of where the function was declared (not run)</strong>.</p>
<p>Now what it <em>allows</em> you to do can be more spectacular, see other answers.</p>
</blockquote>
    </div></div></div></div><div id="solution19" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 19</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/scope">scope</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Example for the first point by dlaliberte:</p>

<blockquote>
  <p>A closure is not only created when you return an inner function. In fact, the enclosing function does not need to return at all. You might instead assign your inner function to a variable in an outer scope, or pass it as an argument to another function where it could be used immediately. Therefore, the closure of the enclosing function probably already exists at the time that enclosing function was called since any inner function has access to it as soon as it is called.</p>
</blockquote>

<pre class="lang-js s-code-block"><code class="hljs language-javascript"><span class="hljs-keyword">var</span> i;
<span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">x</span>) {
    <span class="hljs-keyword">var</span> tmp = <span class="hljs-number">3</span>;
    i = <span class="hljs-keyword">function</span> (<span class="hljs-params">y</span>) {
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(x + y + (++tmp));
    }
}
<span class="hljs-title function_">foo</span>(<span class="hljs-number">2</span>);
<span class="hljs-title function_">i</span>(<span class="hljs-number">3</span>);
</code></pre>
    </div></div></div></div><div id="solution20" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 20</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/scope">scope</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>A closure is where an inner function has access to variables in its outer function. That's probably the simplest one-line explanation you can get for closures.</p>
    </div></div></div></div><div id="solution21" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 21</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/scope">scope</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>I know there are plenty of solutions already, but I guess that this small and simple script can be useful to demonstrate the concept:</p>

<pre class="lang-js s-code-block"><code class="hljs language-javascript"><span class="hljs-comment">// makeSequencer will return a "sequencer" function</span>
<span class="hljs-keyword">var</span> makeSequencer = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">var</span> _count = <span class="hljs-number">0</span>; <span class="hljs-comment">// not accessible outside this function</span>
    <span class="hljs-keyword">var</span> sequencer = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
        <span class="hljs-keyword">return</span> _count++;
    }
    <span class="hljs-keyword">return</span> sequencer;
}

<span class="hljs-keyword">var</span> fnext = <span class="hljs-title function_">makeSequencer</span>();
<span class="hljs-keyword">var</span> v0 = <span class="hljs-title function_">fnext</span>();     <span class="hljs-comment">// v0 = 0;</span>
<span class="hljs-keyword">var</span> v1 = <span class="hljs-title function_">fnext</span>();     <span class="hljs-comment">// v1 = 1;</span>
<span class="hljs-keyword">var</span> vz = fnext.<span class="hljs-property">_count</span> <span class="hljs-comment">// vz = undefined</span>
</code></pre>
    </div></div></div></div><div id="solution22" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 22</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/scope">scope</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>You're having a sleep over and you invite Dan.
You tell Dan to bring one XBox controller.</p>

<p>Dan invites Paul.
Dan asks Paul to bring one controller. How many controllers were brought to the party?</p>

<pre class="lang-js s-code-block"><code class="hljs language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">sleepOver</span>(<span class="hljs-params">howManyControllersToBring</span>) {

    <span class="hljs-keyword">var</span> numberOfDansControllers = howManyControllersToBring;

    <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">danInvitedPaul</span>(<span class="hljs-params">numberOfPaulsControllers</span>) {
        <span class="hljs-keyword">var</span> totalControllers = numberOfDansControllers + numberOfPaulsControllers;
        <span class="hljs-keyword">return</span> totalControllers;
    }
}

<span class="hljs-keyword">var</span> howManyControllersToBring = <span class="hljs-number">1</span>;

<span class="hljs-keyword">var</span> inviteDan = <span class="hljs-title function_">sleepOver</span>(howManyControllersToBring);

<span class="hljs-comment">// The only reason Paul was invited is because Dan was invited. </span>
<span class="hljs-comment">// So we set Paul's invitation = Dan's invitation.</span>

<span class="hljs-keyword">var</span> danInvitedPaul = <span class="hljs-title function_">inviteDan</span>(howManyControllersToBring);

<span class="hljs-title function_">alert</span>(<span class="hljs-string">"There were "</span> + danInvitedPaul + <span class="hljs-string">" controllers brought to the party."</span>);
</code></pre>
    </div></div></div></div><div id="solution23" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 23</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/scope">scope</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>The author of <em><a href="http://javascript.info/tutorial/closures" rel="noreferrer">Closures</a></em> has explained closures pretty well, explaining the reason why we need them and also explaining LexicalEnvironment which is necessary to understanding closures. <br>
Here is the summary:</p>

<p>What if a variable is accessed, but it isnt local? Like here:</p>

<p><a href="https://i.stack.imgur.com/SLlVB.png" rel="noreferrer"><img src="https://i.stack.imgur.com/SLlVB.png" alt="Enter image description here"></a></p>

<p>In this case, the interpreter finds the variable in the
outer <a href="http://javascript.info/tutorial/initialization" rel="noreferrer"><code>LexicalEnvironment</code></a> object.</p>

<p>The process consists of two steps:</p>

<ol>
<li>First, when a function f is created, it is not created in an empty
space. There is a current LexicalEnvironment object. In the case
above, its window (a is undefined at the time of function
creation).</li>
</ol>

<p><a href="https://i.stack.imgur.com/0KBin.png" rel="noreferrer"><img src="https://i.stack.imgur.com/0KBin.png" alt="Enter image description here"></a></p>

<p>When a function is created, it gets a hidden property, named [[Scope]], which references the current LexicalEnvironment.</p>

<p><a href="https://i.stack.imgur.com/U3yt7.png" rel="noreferrer"><img src="https://i.stack.imgur.com/U3yt7.png" alt="Enter image description here"></a></p>

<p>If a variable is read, but can not be found anywhere, an error is generated.</p>

<p><strong>Nested functions</strong></p>

<p>Functions can be nested one inside another, forming a chain of LexicalEnvironments which can also be called a scope chain.</p>

<p><a href="https://i.stack.imgur.com/2hUwr.png" rel="noreferrer"><img src="https://i.stack.imgur.com/2hUwr.png" alt="Enter image description here"></a></p>

<p>So, function g has access to g, a and f.</p>

<p><strong>Closures</strong></p>

<p>A nested function may continue to live after the outer function has finished:</p>

<p><a href="https://i.stack.imgur.com/S1mlB.png" rel="noreferrer"><img src="https://i.stack.imgur.com/S1mlB.png" alt="Enter image description here"></a></p>

<p>Marking up LexicalEnvironments:</p>

<p><a href="https://i.stack.imgur.com/BzUNi.png" rel="noreferrer"><img src="https://i.stack.imgur.com/BzUNi.png" alt="Enter image description here"></a></p>

<p>As we see, <code>this.say</code> is a property in the user object, so it continues to live after User completed.</p>

<p>And if you remember, when <code>this.say</code> is created, it (as every function) gets an internal reference <code>this.say.[[Scope]]</code> to the current LexicalEnvironment. So, the LexicalEnvironment of the current User execution stays in memory. All variables of User also are its properties, so they are also carefully kept, not junked as usually.</p>

<p><strong>The whole point is to ensure that if the inner function wants to access an outer variable in the future, it is able to do so.</strong></p>

<p>To summarize:</p>

<ol>
<li>The inner function keeps a reference to the outer
LexicalEnvironment.</li>
<li>The inner function may access variables from it
any time even if the outer function is finished.</li>
<li>The browser keeps the LexicalEnvironment and all its properties (variables) in memory until there is an inner function which references it.</li>
</ol>

<p>This is called a closure.</p>
    </div></div></div></div><div id="solution24" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 24</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/scope">scope</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>JavaScript functions can access their:</p>

<ol>
<li>Arguments</li>
<li>Locals (that is, their local variables and local functions)</li>
<li>Environment, which includes:

<ul>
<li>globals, including the DOM</li>
<li>anything in outer functions</li>
</ul></li>
</ol>

<p>If a function accesses its environment, then the function is a closure.</p>

<p>Note that outer functions are not required, though they do offer benefits I don't discuss here. By accessing data in its environment, a closure keeps that data alive. In the subcase of outer/inner functions, an outer function can create local data and eventually exit, and yet, if any inner function(s) survive after the outer function exits, then the inner function(s) keep the outer function's local data alive.</p>

<p>Example of a closure that uses the global environment:</p>

<p>Imagine that the Stack Overflow Vote-Up and Vote-Down button events are implemented as closures, voteUp_click and voteDown_click, that have access to external variables isVotedUp and isVotedDown, which are defined globally. (For simplicity's sake, I am referring to StackOverflow's Question Vote buttons, not the array of Answer Vote buttons.)</p>

<p>When the user clicks the VoteUp button, the voteUp_click function checks whether isVotedDown == true to determine whether to vote up or merely cancel a down vote. Function voteUp_click is a closure because it is accessing its environment.</p>

<pre class="lang-js s-code-block"><code class="hljs language-javascript"><span class="hljs-keyword">var</span> isVotedUp = <span class="hljs-literal">false</span>;
<span class="hljs-keyword">var</span> isVotedDown = <span class="hljs-literal">false</span>;

<span class="hljs-keyword">function</span> <span class="hljs-title function_">voteUp_click</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">if</span> (isVotedUp)
    <span class="hljs-keyword">return</span>;
  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (isVotedDown)
    <span class="hljs-title class_">SetDownVote</span>(<span class="hljs-literal">false</span>);
  <span class="hljs-keyword">else</span>
    <span class="hljs-title class_">SetUpVote</span>(<span class="hljs-literal">true</span>);
}

<span class="hljs-keyword">function</span> <span class="hljs-title function_">voteDown_click</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">if</span> (isVotedDown)
    <span class="hljs-keyword">return</span>;
  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (isVotedUp)
    <span class="hljs-title class_">SetUpVote</span>(<span class="hljs-literal">false</span>);
  <span class="hljs-keyword">else</span>
    <span class="hljs-title class_">SetDownVote</span>(<span class="hljs-literal">true</span>);
}

<span class="hljs-keyword">function</span> <span class="hljs-title function_">SetUpVote</span>(<span class="hljs-params">status</span>) {
  isVotedUp = status;
  <span class="hljs-comment">// Do some CSS stuff to Vote-Up button</span>
}

<span class="hljs-keyword">function</span> <span class="hljs-title function_">SetDownVote</span>(<span class="hljs-params">status</span>) {
  isVotedDown = status;
  <span class="hljs-comment">// Do some CSS stuff to Vote-Down button</span>
}
</code></pre>

<p>All four of these functions are closures as they all access their environment.</p>
    </div></div></div></div><div id="solution25" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 25</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/scope">scope</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>As a father of a 6-year-old, currently teaching young children (and a relative novice to coding with no formal education so corrections will be required), I think the lesson would stick best through hands-on play. If the 6-year-old is ready to understand what a closure is, then they are old enough to have a go themselves. I'd suggest pasting the code into jsfiddle.net, explaining a bit, and leaving them alone to concoct a unique song. The explanatory text below is probably more appropriate for a 10 year old.</p>

<pre class="lang-js s-code-block"><code class="hljs language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">sing</span>(<span class="hljs-params">person</span>) {

    <span class="hljs-keyword">var</span> firstPart = <span class="hljs-string">"There was "</span> + person + <span class="hljs-string">" who swallowed "</span>;

    <span class="hljs-keyword">var</span> fly = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) {
        <span class="hljs-keyword">var</span> creature = <span class="hljs-string">"a fly"</span>;
        <span class="hljs-keyword">var</span> result = <span class="hljs-string">"Perhaps she'll die"</span>;
        <span class="hljs-title function_">alert</span>(firstPart + creature + <span class="hljs-string">"\n"</span> + result);
    };

    <span class="hljs-keyword">var</span> spider = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) {
        <span class="hljs-keyword">var</span> creature = <span class="hljs-string">"a spider"</span>;
        <span class="hljs-keyword">var</span> result = <span class="hljs-string">"that wiggled and jiggled and tickled inside her"</span>;
        <span class="hljs-title function_">alert</span>(firstPart + creature + <span class="hljs-string">"\n"</span> + result);
    };

    <span class="hljs-keyword">var</span> bird = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) {
        <span class="hljs-keyword">var</span> creature = <span class="hljs-string">"a bird"</span>;
        <span class="hljs-keyword">var</span> result = <span class="hljs-string">"How absurd!"</span>;
        <span class="hljs-title function_">alert</span>(firstPart + creature + <span class="hljs-string">"\n"</span> + result);
    };

    <span class="hljs-keyword">var</span> cat = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) {
        <span class="hljs-keyword">var</span> creature = <span class="hljs-string">"a cat"</span>;
        <span class="hljs-keyword">var</span> result = <span class="hljs-string">"Imagine That!"</span>;
        <span class="hljs-title function_">alert</span>(firstPart + creature + <span class="hljs-string">"\n"</span> + result);
    };

    <span class="hljs-title function_">fly</span>();
    <span class="hljs-title function_">spider</span>();
    <span class="hljs-title function_">bird</span>();
    <span class="hljs-title function_">cat</span>();
}

<span class="hljs-keyword">var</span> person=<span class="hljs-string">"an old lady"</span>;

<span class="hljs-title function_">sing</span>(person);
</code></pre>

<p><strong>INSTRUCTIONS</strong></p>

<p>DATA: Data is a collection of facts. It can be numbers, words, measurements, observations or even just descriptions of things. You can't touch it, smell it or taste it. You can write it down, speak it and hear it. You could use it to <em>create</em> touch smell and taste using a computer. It can be made useful by a computer using code.</p>

<p>CODE: All the writing above is called <em>code</em>. It is written in JavaScript.</p>

<p>JAVASCRIPT: JavaScript is a language. Like English or French or Chinese are languages. There are lots of languages that are understood by computers and other electronic processors. For JavaScript to be understood by a computer it needs an interpreter. Imagine if a teacher who only speaks Russian comes to teach your class at school. When the teacher says "все садятся", the class would not understand. But luckily you have a Russian pupil in your class who tells everyone this means "everybody sit down" - so you all do. The class is like a computer and the Russian pupil is the interpreter. For JavaScript the most common interpreter is called a browser.</p>

<p>BROWSER: When you connect to the Internet on a computer, tablet or phone to visit a website, you use a browser. Examples you may know are Internet Explorer, Chrome, Firefox and Safari. The browser can understand JavaScript and tell the computer what it needs to do. The JavaScript instructions are called functions.</p>

<p>FUNCTION: A function in JavaScript is like a factory. It might be a little factory with only one machine inside. Or it might contain many other little factories, each with many machines doing different jobs. In a real life clothes factory you might have reams of cloth and bobbins of thread going in and T-shirts and jeans coming out. Our JavaScript factory only processes data, it can't sew, drill a hole or melt metal. In our JavaScript factory data goes in and data comes out.</p>

<p>All this data stuff sounds a bit boring, but it is really very cool; we might have a function that tells a robot what to make for dinner. Let's say I invite you and your friend to my house. You like chicken legs best, I like sausages, your friend always wants what you want and my friend does not eat meat.</p>

<p>I haven't got time to go shopping, so the function needs to know what we have in the fridge to make decisions. Each ingredient has a different cooking time and we want everything to be served hot by the robot at the same time. We need to provide the function with the data about what we like, the function could 'talk' to the fridge, and the function could control the robot.</p>

<p>A function normally has a name, parentheses and braces. Like this:</p>

<pre class="lang-js s-code-block"><code class="hljs language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">cookMeal</span>(<span class="hljs-params"></span>) {  <span class="hljs-comment">/*  STUFF INSIDE THE FUNCTION  */</span>  }
</code></pre>

<p><em>Note that <code>/*...*/</code> and <code>//</code> stop code being read by the browser.</em></p>

<p>NAME: You can call a function just about whatever word you want. The example "cookMeal" is typical in joining two words together and giving the second one a capital letter at the beginning - but this is not necessary. It can't have a space in it, and it can't be a number on its own.</p>

<p>PARENTHESES: "Parentheses" or <code>()</code> are the letter box on the JavaScript function factory's door or a post box in the street for sending packets of information to the factory. Sometimes the postbox might be marked <em>for example</em> <code>cookMeal(you, me, yourFriend, myFriend, fridge, dinnerTime)</code>, in which case you know what data you have to give it.</p>

<p>BRACES: "Braces" which look like this <code>{}</code> are the tinted windows of our factory. From inside the factory you can see out, but from the outside you can't see in.</p>

<p><strong>THE LONG CODE EXAMPLE ABOVE</strong></p>

<p>Our code begins with the word <em>function</em>, so we know that it is one! Then the name of the function <em>sing</em> - that's my own description of what the function is about. Then parentheses <em>()</em>. The parentheses are always there for a function. Sometimes they are empty, and sometimes they have something in. This one has a word in: <code>(person)</code>. After this there is a brace like this <code>{</code> . This marks the start of the function <em>sing()</em>. It has a partner which marks the end of <em>sing()</em> like this <code>}</code></p>

<pre class="lang-js s-code-block"><code class="hljs language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">sing</span>(<span class="hljs-params">person</span>) {  <span class="hljs-comment">/* STUFF INSIDE THE FUNCTION */</span>  }
</code></pre>

<p>So this function might have something to do with singing, and might need some data about a person. It has instructions inside to do something with that data.</p>

<p>Now, after the function <em>sing()</em>, near the end of the code is the line</p>

<pre class="lang-js s-code-block"><code class="hljs language-javascript"><span class="hljs-keyword">var</span> person=<span class="hljs-string">"an old lady"</span>;
</code></pre>

<p>VARIABLE: The letters <em>var</em> stand for "variable". A variable is like an envelope. On the outside this envelope is marked "person". On the inside it contains a slip of paper with the information our function needs, some letters and spaces joined together like a piece of string (it's called a string) that make a phrase reading "an old lady". Our envelope could contain other kinds of things like numbers (called integers), instructions (called functions), lists (called <em>arrays</em>). Because this variable is written outside of all the braces <code>{}</code>, and because you can see out through the tinted windows when you are inside the braces, this variable can be seen from anywhere in the code. We call this a 'global variable'.</p>

<p>GLOBAL VARIABLE: <em>person</em> is a global variable, meaning that if you change its value from "an old lady" to "a young man", the <em>person</em> will keep being a young man until you decide to change it again and that any other function in the code can see that it's a young man. Press the <kbd>F12</kbd> button or look at the Options settings to open the developer console of a browser and type "person" to see what this value is. Type <code>person="a young man"</code> to change it and then type "person" again to see that it has changed.</p>

<p>After this we have the line</p>

<pre class="lang-js s-code-block"><code class="hljs language-javascript"><span class="hljs-title function_">sing</span>(person);
</code></pre>

<p>This line is calling the function, as if it were calling a dog</p>

<blockquote>
  <p>"Come on <em>sing</em>, Come and get <em>person</em>!"</p>
</blockquote>

<p>When the browser has loaded the JavaScript code an reached this line, it will start the function. I put the line at the end to make sure that the browser has all the information it needs to run it.</p>

<p>Functions define actions  - the main function is about singing. It contains a variable called <em>firstPart</em> which applies to the singing about the person that applies to each of the verses of the song: "There was " + person + " who swallowed". If you type <em>firstPart</em> into the console, you won't get an answer because the variable is locked up in a function - the browser can't see inside the tinted windows of the braces.</p>

<p>CLOSURES: The closures are the smaller functions that are inside the big <em>sing()</em> function. The little factories inside the big factory. They each have their own braces which mean that the variables inside them can't be seen from the outside. That's why the names of the variables (<em>creature</em> and <em>result</em>) can be repeated in the closures but with different values. If you type these variable names in the console window, you won't get its value because it's hidden by two layers of tinted windows.</p>

<p>The closures all know what the <em>sing()</em> function's variable called <em>firstPart</em> is, because they can see out from their tinted windows.</p>

<p>After the closures come the lines</p>

<pre class="lang-js s-code-block"><code class="hljs language-javascript"><span class="hljs-title function_">fly</span>();
<span class="hljs-title function_">spider</span>();
<span class="hljs-title function_">bird</span>();
<span class="hljs-title function_">cat</span>();
</code></pre>

<p>The sing() function will call each of these functions in the order they are given. Then the sing() function's work will be done.</p>
    </div></div></div></div><div id="solution26" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 26</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/scope">scope</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Okay, talking with a 6-year old child, I would possibly use following associations.</p>

<blockquote>
  <p>Imagine - you are playing with your little brothers and sisters in the entire house, and you are moving around with your toys and brought some of them into your older brother's room. After a while your brother returned from the school and went to his room, and he locked inside it, so now you could not access toys left there anymore in a direct way. But you could knock the door and ask your brother for that toys. This is called toy's <em>closure</em>; your brother made it up for you, and he is now into outer <em>scope</em>.</p>
</blockquote>

<p>Compare with a situation when a door was locked by draft and nobody inside (general function execution), and then some local fire occur and burn down the room (garbage collector:D), and then a new room was build and now you may leave another toys there (new function instance), but never get the same toys which were left in the first room instance.</p>

<p>For an advanced child I would put something like the following. It is not perfect, but it makes you feel about what it is:</p>

<pre class="lang-js s-code-block"><code class="hljs language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">playingInBrothersRoom</span> (withToys) {
  <span class="hljs-comment">// We closure toys which we played in the brother's room. When he come back and lock the door</span>
  <span class="hljs-comment">// your brother is supposed to be into the outer [[scope]] object now. Thanks god you could communicate with him.</span>
  <span class="hljs-keyword">var</span> closureToys = withToys || [],
      returnToy, countIt, toy; <span class="hljs-comment">// Just another closure helpers, for brother's inner use.</span>

  <span class="hljs-keyword">var</span> brotherGivesToyBack = <span class="hljs-keyword">function</span> (<span class="hljs-params">toy</span>) {
    <span class="hljs-comment">// New request. There is not yet closureToys on brother's hand yet. Give him a time.</span>
    returnToy = <span class="hljs-literal">null</span>;
    <span class="hljs-keyword">if</span> (toy &amp;&amp; closureToys.<span class="hljs-property">length</span> &gt; <span class="hljs-number">0</span>) { <span class="hljs-comment">// If we ask for a specific toy, the brother is going to search for it.</span>

      <span class="hljs-keyword">for</span> ( countIt = closureToys.<span class="hljs-property">length</span>; countIt; countIt--) {
        <span class="hljs-keyword">if</span> (closureToys[countIt - <span class="hljs-number">1</span>] == toy) {
          returnToy = <span class="hljs-string">'Take your '</span> + closureToys.<span class="hljs-title function_">splice</span>(countIt - <span class="hljs-number">1</span>, <span class="hljs-number">1</span>) + <span class="hljs-string">', little boy!'</span>;
          <span class="hljs-keyword">break</span>;
        }
      }
      returnToy = returnToy || <span class="hljs-string">'Hey, I could not find any '</span> + toy + <span class="hljs-string">' here. Look for it in another room.'</span>;
    }
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (closureToys.<span class="hljs-property">length</span> &gt; <span class="hljs-number">0</span>) { <span class="hljs-comment">// Otherwise, just give back everything he has in the room.</span>
      returnToy = <span class="hljs-string">'Behold! '</span> + closureToys.<span class="hljs-title function_">join</span>(<span class="hljs-string">', '</span>) + <span class="hljs-string">'.'</span>;
      closureToys = [];
    }
    <span class="hljs-keyword">else</span> {
      returnToy = <span class="hljs-string">'Hey, lil shrimp, I gave you everything!'</span>;
    }
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(returnToy);
  }
  <span class="hljs-keyword">return</span> brotherGivesToyBack;
}
<span class="hljs-comment">// You are playing in the house, including the brother's room.</span>
<span class="hljs-keyword">var</span> toys = [<span class="hljs-string">'teddybear'</span>, <span class="hljs-string">'car'</span>, <span class="hljs-string">'jumpingrope'</span>],
    askBrotherForClosuredToy = <span class="hljs-title function_">playingInBrothersRoom</span>(toys);

<span class="hljs-comment">// The door is locked, and the brother came from the school. You could not cheat and take it out directly.</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(askBrotherForClosuredToy.<span class="hljs-property">closureToys</span>); <span class="hljs-comment">// Undefined</span>

<span class="hljs-comment">// But you could ask your brother politely, to give it back.</span>
<span class="hljs-title function_">askBrotherForClosuredToy</span>(<span class="hljs-string">'teddybear'</span>); <span class="hljs-comment">// Hooray, here it is, teddybear</span>
<span class="hljs-title function_">askBrotherForClosuredToy</span>(<span class="hljs-string">'ball'</span>); <span class="hljs-comment">// The brother would not be able to find it.</span>
<span class="hljs-title function_">askBrotherForClosuredToy</span>(); <span class="hljs-comment">// The brother gives you all the rest</span>
<span class="hljs-title function_">askBrotherForClosuredToy</span>(); <span class="hljs-comment">// Nothing left in there</span>
</code></pre>

<p>As you can see, the toys left in the room are still accessible via the brother and no matter if the room is locked. Here is <a href="http://jsbin.com/ubakor/9/edit" rel="noreferrer">a jsbin</a> to play around with it.</p>
    </div></div></div></div><div id="solution27" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 27</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/scope">scope</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>A function in JavaScript is not just a reference to a set of instructions (as in C language), but it also includes a hidden data structure which is composed of references to all nonlocal variables it uses (captured variables). Such two-piece functions are called closures. Every function in JavaScript can be considered a closure.</p>

<p>Closures are functions with a state. It is somewhat similar to "this" in the sense that "this" also provides state for a function but function and "this" are separate objects ("this" is just a fancy parameter, and the only way to bind it permanently to a function is to create a closure). While "this" and function always live separately, a function cannot be separated from its closure and the language provides no means to access captured variables.</p>

<p>Because all these external variables referenced by a lexically nested function are actually local variables in the chain of its lexically enclosing functions (global variables can be assumed to be local variables of some root function), and every single execution of a function creates new instances of its local variables, it follows that every execution of a function returning (or otherwise transferring it out, such as registering it as a callback) a nested function creates a new closure (with its own potentially unique set of referenced nonlocal variables which represent its execution context).</p>

<p>Also, it must be understood that local variables in JavaScript are created not on the stack frame, but on the heap and destroyed only when no one is referencing them. When a function returns, references to its local variables are decremented, but they can still be non-null if during the current execution they became part of a closure and are still referenced by its lexically nested functions (which can happen only if the references to these nested functions were returned or otherwise transferred to some external code).</p>

<p>An example:</p>

<pre class="lang-js s-code-block"><code class="hljs language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span> (initValue) {
   <span class="hljs-comment">//This variable is not destroyed when the foo function exits.</span>
   <span class="hljs-comment">//It is 'captured' by the two nested functions returned below.</span>
   <span class="hljs-keyword">var</span> value = initValue;

   <span class="hljs-comment">//Note that the two returned functions are created right now.</span>
   <span class="hljs-comment">//If the foo function is called again, it will return</span>
   <span class="hljs-comment">//new functions referencing a different 'value' variable.</span>
   <span class="hljs-keyword">return</span> {
       <span class="hljs-attr">getValue</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) { <span class="hljs-keyword">return</span> value; },
       <span class="hljs-attr">setValue</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">newValue</span>) { value = newValue; }
   }
}

<span class="hljs-keyword">function</span> <span class="hljs-title function_">bar</span> () {
    <span class="hljs-comment">//foo sets its local variable 'value' to 5 and returns an object with</span>
    <span class="hljs-comment">//two functions still referencing that local variable</span>
    <span class="hljs-keyword">var</span> obj = <span class="hljs-title function_">foo</span>(<span class="hljs-number">5</span>);

    <span class="hljs-comment">//Extracting functions just to show that no 'this' is involved here</span>
    <span class="hljs-keyword">var</span> getValue = obj.<span class="hljs-property">getValue</span>;
    <span class="hljs-keyword">var</span> setValue = obj.<span class="hljs-property">setValue</span>;

    <span class="hljs-title function_">alert</span>(<span class="hljs-title function_">getValue</span>()); <span class="hljs-comment">//Displays 5</span>
    <span class="hljs-title function_">setValue</span>(<span class="hljs-number">10</span>);
    <span class="hljs-title function_">alert</span>(<span class="hljs-title function_">getValue</span>()); <span class="hljs-comment">//Displays 10</span>

    <span class="hljs-comment">//At this point getValue and setValue functions are destroyed</span>
    <span class="hljs-comment">//(in reality they are destroyed at the next iteration of the garbage collector).</span>
    <span class="hljs-comment">//The local variable 'value' in the foo is no longer referenced by</span>
    <span class="hljs-comment">//anything and is destroyed too.</span>
}

<span class="hljs-title function_">bar</span>();
</code></pre>
    </div></div></div></div><div id="solution28" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 28</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/scope">scope</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>An answer for a six-year-old (assuming he knows what a function is and what a variable is, and what data is):</p>

<p>Functions can return data. One kind of data you can return from a function is another function. When that new function gets returned, all the variables and arguments used in the function that created it don't go away. Instead, that parent function "closes." In other words, nothing can look inside of it and see the variables it used except for the function it returned. That new function has a special ability to look back inside the function that created it and see the data inside of it.</p>

<pre class="lang-js s-code-block"><code class="hljs language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">the_closure</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">var</span> x = <span class="hljs-number">4</span>;
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
    <span class="hljs-keyword">return</span> x; <span class="hljs-comment">// Here, we look back inside the_closure for the value of x</span>
  }
}

<span class="hljs-keyword">var</span> myFn = <span class="hljs-title function_">the_closure</span>();
<span class="hljs-title function_">myFn</span>(); <span class="hljs-comment">//=&gt; 4</span>
</code></pre>

<p>Another really simple way to explain it is in terms of scope:</p>

<p>Any time you create a smaller scope inside of a larger scope, the smaller scope will always be able to see what is in the larger scope.</p>
    </div></div></div></div><div id="solution29" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 29</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/scope">scope</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Perhaps a little beyond all but the most precocious of six-year-olds, but a few examples that helped make the concept of closure in JavaScript click for me.</p>

<p>A closure is a function that has access to another function's scope (its variables and functions). The easiest way to create a closure is with a function within a function; the reason being that in JavaScript a function always has access to its containing functions scope.</p>

<p></p><div class="snippet" data-lang="js" data-hide="false">
<div class="snippet-code">
<pre class="snippet-code-js lang-js s-code-block"><code class="hljs language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">outerFunction</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">var</span> outerVar = <span class="hljs-string">"monkey"</span>;
    
    <span class="hljs-keyword">function</span> <span class="hljs-title function_">innerFunction</span>(<span class="hljs-params"></span>) {
        <span class="hljs-title function_">alert</span>(outerVar);
    }
    
    <span class="hljs-title function_">innerFunction</span>();
}

<span class="hljs-title function_">outerFunction</span>();</code></pre>
<div class="snippet-result"><div class="snippet-ctas"><button type="button" class="s-btn s-btn__primary"><span class="icon-play-white _hover"></span><span> Run code snippet</span></button><input class="copySnippet s-btn s-btn__filled" type="button" value="Copy snippet to answer" style="display: none;"><button type="button" class="s-btn hideResults" style="display: none;">Hide results</button><div class="popout-code"><a class="snippet-expand-link">Expand snippet</a></div></div><div class="snippet-result-code" style="display: none;"><iframe name="sif19" sandbox="allow-forms allow-modals allow-scripts" class="snippet-box-edit snippet-box-result" frameborder="0"></iframe></div></div></div>
</div>
<p></p>

<p>ALERT: monkey</p>

<p>In the above example, outerFunction is called which in turn calls innerFunction. Note how outerVar is available to innerFunction, evidenced by its correctly alerting the value of outerVar.</p>

<p>Now consider the following:</p>

<p></p><div class="snippet" data-lang="js" data-hide="false">
<div class="snippet-code">
<pre class="snippet-code-js lang-js s-code-block"><code class="hljs language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">outerFunction</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">var</span> outerVar = <span class="hljs-string">"monkey"</span>;
    
    <span class="hljs-keyword">function</span> <span class="hljs-title function_">innerFunction</span>(<span class="hljs-params"></span>) {
        <span class="hljs-keyword">return</span> outerVar;
    }
    
    <span class="hljs-keyword">return</span> innerFunction;
}

<span class="hljs-keyword">var</span> referenceToInnerFunction = <span class="hljs-title function_">outerFunction</span>();
<span class="hljs-title function_">alert</span>(<span class="hljs-title function_">referenceToInnerFunction</span>());</code></pre>
<div class="snippet-result"><div class="snippet-ctas"><button type="button" class="s-btn s-btn__primary"><span class="icon-play-white _hover"></span><span> Run code snippet</span></button><input class="copySnippet s-btn s-btn__filled" type="button" value="Copy snippet to answer" style="display: none;"><button type="button" class="s-btn hideResults" style="display: none;">Hide results</button><div class="popout-code"><a class="snippet-expand-link">Expand snippet</a></div></div><div class="snippet-result-code" style="display: none;"><iframe name="sif20" sandbox="allow-forms allow-modals allow-scripts" class="snippet-box-edit snippet-box-result" frameborder="0"></iframe></div></div></div>
</div>
<p></p>

<p>ALERT: monkey</p>

<p>referenceToInnerFunction is set to outerFunction(), which simply returns a reference to innerFunction. When referenceToInnerFunction is called, it returns outerVar. Again, as above, this demonstrates that innerFunction has access to outerVar, a variable of outerFunction. Furthermore, it is interesting to note that it retains this access even after outerFunction has finished executing.</p>

<p>And here is where things get really interesting. If we were to get rid of outerFunction, say set it to null, you might think that referenceToInnerFunction would loose its access to the value of outerVar. But this is not the case. </p>

<p></p><div class="snippet" data-lang="js" data-hide="false">
<div class="snippet-code">
<pre class="snippet-code-js lang-js s-code-block"><code class="hljs language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">outerFunction</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">var</span> outerVar = <span class="hljs-string">"monkey"</span>;
    
    <span class="hljs-keyword">function</span> <span class="hljs-title function_">innerFunction</span>(<span class="hljs-params"></span>) {
        <span class="hljs-keyword">return</span> outerVar;
    }
    
    <span class="hljs-keyword">return</span> innerFunction;
}

<span class="hljs-keyword">var</span> referenceToInnerFunction = <span class="hljs-title function_">outerFunction</span>();
<span class="hljs-title function_">alert</span>(<span class="hljs-title function_">referenceToInnerFunction</span>());

outerFunction = <span class="hljs-literal">null</span>;
<span class="hljs-title function_">alert</span>(<span class="hljs-title function_">referenceToInnerFunction</span>());</code></pre>
<div class="snippet-result"><div class="snippet-ctas"><button type="button" class="s-btn s-btn__primary"><span class="icon-play-white _hover"></span><span> Run code snippet</span></button><input class="copySnippet s-btn s-btn__filled" type="button" value="Copy snippet to answer" style="display: none;"><button type="button" class="s-btn hideResults" style="display: none;">Hide results</button><div class="popout-code"><a class="snippet-expand-link">Expand snippet</a></div></div><div class="snippet-result-code" style="display: none;"><iframe name="sif21" sandbox="allow-forms allow-modals allow-scripts" class="snippet-box-edit snippet-box-result" frameborder="0"></iframe></div></div></div>
</div>
<p></p>

<p>ALERT: monkey
ALERT: monkey</p>

<p>But how is this so? How can referenceToInnerFunction still know the value of outerVar now that outerFunction has been set to null?</p>

<p>The reason that referenceToInnerFunction can still access the value of outerVar is because when the closure was first created by placing innerFunction inside of outerFunction, innerFunction added a reference to outerFunctions scope (its variables and functions) to its scope chain. What this means is that innerFunction has a pointer or reference to all of outerFunctions variables, including outerVar. So even when outerFunction has finished executing, or even if it is deleted or set to null, the variables in its scope, like outerVar, stick around in memory because of the outstanding reference to them on the part of the innerFunction that has been returned to referenceToInnerFunction. To truly release outerVar and the rest of outerFunctions variables from memory you would have to get rid of this outstanding reference to them, say by setting referenceToInnerFunction to null as well.</p>

<p>//////////</p>

<p>Two other things about closures to note. First, the closure will always have access to the last values of its containing function.</p>

<p></p><div class="snippet" data-lang="js" data-hide="false">
<div class="snippet-code">
<pre class="snippet-code-js lang-js s-code-block"><code class="hljs language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">outerFunction</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">var</span> outerVar = <span class="hljs-string">"monkey"</span>;
    
    <span class="hljs-keyword">function</span> <span class="hljs-title function_">innerFunction</span>(<span class="hljs-params"></span>) {
        <span class="hljs-title function_">alert</span>(outerVar);
    }
    
    outerVar = <span class="hljs-string">"gorilla"</span>;

    <span class="hljs-title function_">innerFunction</span>();
}

<span class="hljs-title function_">outerFunction</span>();</code></pre>
<div class="snippet-result"><div class="snippet-ctas"><button type="button" class="s-btn s-btn__primary"><span class="icon-play-white _hover"></span><span> Run code snippet</span></button><input class="copySnippet s-btn s-btn__filled" type="button" value="Copy snippet to answer" style="display: none;"><button type="button" class="s-btn hideResults" style="display: none;">Hide results</button><div class="popout-code"><a class="snippet-expand-link">Expand snippet</a></div></div><div class="snippet-result-code" style="display: none;"><iframe name="sif22" sandbox="allow-forms allow-modals allow-scripts" class="snippet-box-edit snippet-box-result" frameborder="0"></iframe></div></div></div>
</div>
<p></p>

<p>ALERT: gorilla</p>

<p>Second, when a closure is created, it retains a reference to all of its enclosing functions variables and functions; it doesnt get to pick and choose. And but so, closures should be used sparingly, or at least carefully, as they can be memory intensive; a lot of variables can be kept in memory long after a containing function has finished executing.</p>
    </div></div></div></div><div id="solution30" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 30</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/scope">scope</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>I'd simply point them to the <a href="https://developer.mozilla.org/en-US/docs/JavaScript/Guide/Closures">Mozilla Closures page</a>. It's the best, most <strong>concise and simple explanation</strong> of closure basics and practical usage that I've found. It is highly recommended to anyone learning JavaScript.</p>

<p>And yes, I'd even recommend it to a 6-year old -- if the 6-year old is learning about closures, then it's logical they're ready to comprehend the <em>concise and simple explanation</em> provided in the article.</p>
    </div></div></div></div></div></div><div class="widget"><a href="/questions/how-do-i-detect-a-click-outside-an-element-1657387505351">How do I detect a click outside an element?</a><a href="/questions/trouble-with-utf-8-characters-what-i-see-is-not-what-i-stored-1657384817490">Trouble with UTF-8 characters; what I see is not what I stored</a><a href="/questions/http-get-with-request-body-1657387379038">HTTP GET with request body</a><a href="/questions/how-do-i-sort-a-dictionary-by-value-1657385485049">How do I sort a dictionary by value?</a><a href="/questions/how-do-i-compare-strings-in-java-1657384243187">How do I compare strings in Java?</a><a href="/questions/why-is-my-spring-@autowired-field-null-1657384705291">Why is my Spring @Autowired field null?</a><a href="/questions/simulating-group_concat-mysql-function-in-microsoft-sql-server-2005-1657384832169">Simulating group_concat MySQL function in Microsoft SQL Server 2005?</a><a href="/questions/center-one-and-rightleft-align-other-flexbox-element-1657387899083">Center one and right/left align other flexbox element</a><a href="/questions/flexbox:-center-horizontally-and-vertically-1657384587888">Flexbox: center horizontally and vertically</a><a href="/questions/what-to-do-regular-expression-pattern-doesn&#x27;t-match-anywhere-in-string-1657388095896">What to do Regular expression pattern doesn&#x27;t match anywhere in string?</a><a href="/questions/when-to-use-single-quotes-double-quotes-and-backticks-in-mysql-1657384337981">When to use single quotes, double quotes, and backticks in MySQL</a><a href="/questions/how-to-remove-all-duplicates-from-an-array-of-objects-1657388256190">How to remove all duplicates from an array of objects?</a><a href="/questions/sort-(order)-data-frame-rows-by-multiple-columns-1657388355671">Sort (order) data frame rows by multiple columns</a><a href="/questions/swing-gui-listeners-without-awt-1657387522426">Swing GUI listeners without AWT</a><a href="/questions/gui-not-working-after-rewriting-to-mvc-1657388388035">GUI not working after rewriting to MVC</a><a href="/questions/convert-form-data-to-javascript-object-with-jquery-1657388036834">Convert form data to JavaScript object with jQuery</a><a href="/questions/how-to-deal-with-mysqli-problems-mysqli_fetch_array():-argument-1-must-be-of-type-mysqli_result-1657384360922">How to deal with mysqli problems? mysqli_fetch_array(): Argument #1 must be of type mysqli_result</a><a href="/questions/how-do-i-get-php-errors-to-display-1657384570095">How do I get PHP errors to display?</a><a href="/questions/using-auto-layout-in-uitableview-for-dynamic-cell-layouts-and-variable-row-heights-1657387722263">Using Auto Layout in UITableView for dynamic cell layouts &amp; variable row heights</a><a href="/questions/how-to-extract-and-access-data-from-json-with-php-1657384483259">How to extract and access data from JSON with PHP?</a></div></div><span class="cursor-pointer text-lg p-2" style="position:fixed;bottom:20px;left:20px;background:#000;z-index:2000;color:white">Go go top</span></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"data":{"answer":["\n\u0026lt;p\u0026gt;A closure is a pairing of:\u0026lt;/p\u0026gt;\n\u0026lt;ol\u0026gt;\n\u0026lt;li\u0026gt;A function and\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;A reference to that function\u0026apos;s outer scope (lexical environment)\u0026lt;/li\u0026gt;\n\u0026lt;/ol\u0026gt;\n\u0026lt;p\u0026gt;A lexical environment is part of every execution context (stack frame) and is a map between identifiers (i.e. local variable names) and values.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Every function in JavaScript maintains a reference to its outer lexical environment. This reference is used to configure the execution context created when a function is invoked. This reference enables code inside the function to \u0026quot;see\u0026quot; variables declared outside the function, regardless of when and where the function is called.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;If a function was called by a function, which in turn was called by another function, then a chain of references to outer lexical environments is created. This chain is called the scope chain.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;In the following code, \u0026lt;code\u0026gt;inner\u0026lt;/code\u0026gt; forms a closure with the lexical environment of the execution context created when \u0026lt;code\u0026gt;foo\u0026lt;/code\u0026gt; is invoked, \u0026lt;em\u0026gt;closing over\u0026lt;/em\u0026gt; variable \u0026lt;code\u0026gt;secret\u0026lt;/code\u0026gt;:\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;/p\u0026gt;\u0026lt;div class=\u0026quot;snippet\u0026quot; data-lang=\u0026quot;js\u0026quot; data-hide=\u0026quot;false\u0026quot; data-console=\u0026quot;true\u0026quot; data-babel=\u0026quot;false\u0026quot;\u0026gt;\n\u0026lt;div class=\u0026quot;snippet-code\u0026quot;\u0026gt;\n\u0026lt;pre class=\u0026quot;snippet-code-js lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;foo\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;) {\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; secret = \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Math\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;trunc\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Math\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;random\u0026lt;/span\u0026gt;() * \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;100\u0026lt;/span\u0026gt;)\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;inner\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;) {\n    \u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;console\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;log\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;`The secret number is \u0026lt;span class=\u0026quot;hljs-subst\u0026quot;\u0026gt;${secret}\u0026lt;/span\u0026gt;.`\u0026lt;/span\u0026gt;)\n  }\n}\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; f = \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;foo\u0026lt;/span\u0026gt;() \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// `secret` is not directly accessible from outside `foo`\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;f\u0026lt;/span\u0026gt;() \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// The only way to retrieve `secret`, is to invoke `f`\u0026lt;/span\u0026gt;\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;div class=\u0026quot;snippet-result\u0026quot;\u0026gt;\u0026lt;div class=\u0026quot;snippet-ctas\u0026quot;\u0026gt;\u0026lt;button type=\u0026quot;button\u0026quot; class=\u0026quot;s-btn s-btn__primary\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;icon-play-white _hover\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;\u0026lt;span\u0026gt; Run code snippet\u0026lt;/span\u0026gt;\u0026lt;/button\u0026gt;\u0026lt;input class=\u0026quot;copySnippet s-btn s-btn__filled\u0026quot; type=\u0026quot;button\u0026quot; value=\u0026quot;Copy snippet to answer\u0026quot; style=\u0026quot;display: none;\u0026quot;\u0026gt;\u0026lt;button type=\u0026quot;button\u0026quot; class=\u0026quot;s-btn hideResults\u0026quot; style=\u0026quot;display: none;\u0026quot;\u0026gt;Hide results\u0026lt;/button\u0026gt;\u0026lt;div class=\u0026quot;popout-code\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;snippet-expand-link\u0026quot;\u0026gt;Expand snippet\u0026lt;/a\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;div class=\u0026quot;snippet-result-code\u0026quot; style=\u0026quot;display: none;\u0026quot;\u0026gt;\u0026lt;iframe name=\u0026quot;sif1\u0026quot; sandbox=\u0026quot;allow-forms allow-modals allow-scripts\u0026quot; class=\u0026quot;snippet-box-edit snippet-box-result\u0026quot; frameborder=\u0026quot;0\u0026quot;\u0026gt;\u0026lt;/iframe\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;/div\u0026gt;\n\u0026lt;/div\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;In other words: in JavaScript, functions carry a reference to a private \u0026quot;box of state\u0026quot;, to which only they (and any other functions declared within the same lexical environment) have access. This box of the state is invisible to the caller of the function, delivering an excellent mechanism for data-hiding and encapsulation.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;And remember: functions in JavaScript can be passed around like variables (first-class functions), meaning these pairings of functionality and state can be passed around your program: similar to how you might pass an instance of a class around in C++.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;If JavaScript did not have closures, then more states would have to be passed between functions \u0026lt;em\u0026gt;explicitly\u0026lt;/em\u0026gt;, making parameter lists longer and code noisier.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;So, if you want a function to always have access to a private piece of state, you can use a closure.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;...and frequently we \u0026lt;em\u0026gt;do\u0026lt;/em\u0026gt; want to associate the state with a function. For example, in Java or C++, when you add a private instance variable and a method to a class, you are associating the state with functionality.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;In C and most other common languages, after a function returns, all the local variables are no longer accessible because the stack-frame is destroyed. In JavaScript, if you declare a function within another function, then the local variables of the outer function can remain accessible after returning from it. In this way, in the code above, \u0026lt;code\u0026gt;secret\u0026lt;/code\u0026gt; remains available to the function object \u0026lt;code\u0026gt;inner\u0026lt;/code\u0026gt;, \u0026lt;em\u0026gt;after\u0026lt;/em\u0026gt; it has been returned from \u0026lt;code\u0026gt;foo\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n\u0026lt;h2\u0026gt;Uses of Closures\u0026lt;/h2\u0026gt;\n\u0026lt;p\u0026gt;Closures are useful whenever you need a private state associated with a function. This is a very common scenario - and remember: JavaScript did not have a class syntax until 2015, and it still does not have a private field syntax. Closures meet this need.\u0026lt;/p\u0026gt;\n\u0026lt;h3\u0026gt;Private Instance Variables\u0026lt;/h3\u0026gt;\n\u0026lt;p\u0026gt;In the following code, the function \u0026lt;code\u0026gt;toString\u0026lt;/code\u0026gt; closes over the details of the car.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;/p\u0026gt;\u0026lt;div class=\u0026quot;snippet\u0026quot; data-lang=\u0026quot;js\u0026quot; data-hide=\u0026quot;false\u0026quot; data-console=\u0026quot;true\u0026quot; data-babel=\u0026quot;false\u0026quot;\u0026gt;\n\u0026lt;div class=\u0026quot;snippet-code\u0026quot;\u0026gt;\n\u0026lt;pre class=\u0026quot;snippet-code-js lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;Car\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;manufacturer, model, year, color\u0026lt;/span\u0026gt;) {\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; {\n    \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;toString\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;) {\n      \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;`\u0026lt;span class=\u0026quot;hljs-subst\u0026quot;\u0026gt;${manufacturer}\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-subst\u0026quot;\u0026gt;${model}\u0026lt;/span\u0026gt; (\u0026lt;span class=\u0026quot;hljs-subst\u0026quot;\u0026gt;${year}\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-subst\u0026quot;\u0026gt;${color}\u0026lt;/span\u0026gt;)`\u0026lt;/span\u0026gt;\n    }\n  }\n}\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; car = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Car\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;Aston Martin\u0026apos;\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;V8 Vantage\u0026apos;\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;2012\u0026apos;\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;Quantum Silver\u0026apos;\u0026lt;/span\u0026gt;)\n\u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;console\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;log\u0026lt;/span\u0026gt;(car.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;toString\u0026lt;/span\u0026gt;())\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;div class=\u0026quot;snippet-result\u0026quot;\u0026gt;\u0026lt;div class=\u0026quot;snippet-ctas\u0026quot;\u0026gt;\u0026lt;button type=\u0026quot;button\u0026quot; class=\u0026quot;s-btn s-btn__primary\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;icon-play-white _hover\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;\u0026lt;span\u0026gt; Run code snippet\u0026lt;/span\u0026gt;\u0026lt;/button\u0026gt;\u0026lt;input class=\u0026quot;copySnippet s-btn s-btn__filled\u0026quot; type=\u0026quot;button\u0026quot; value=\u0026quot;Copy snippet to answer\u0026quot; style=\u0026quot;display: none;\u0026quot;\u0026gt;\u0026lt;button type=\u0026quot;button\u0026quot; class=\u0026quot;s-btn hideResults\u0026quot; style=\u0026quot;display: none;\u0026quot;\u0026gt;Hide results\u0026lt;/button\u0026gt;\u0026lt;div class=\u0026quot;popout-code\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;snippet-expand-link\u0026quot;\u0026gt;Expand snippet\u0026lt;/a\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;div class=\u0026quot;snippet-result-code\u0026quot; style=\u0026quot;display: none;\u0026quot;\u0026gt;\u0026lt;iframe name=\u0026quot;sif2\u0026quot; sandbox=\u0026quot;allow-forms allow-modals allow-scripts\u0026quot; class=\u0026quot;snippet-box-edit snippet-box-result\u0026quot; frameborder=\u0026quot;0\u0026quot;\u0026gt;\u0026lt;/iframe\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;/div\u0026gt;\n\u0026lt;/div\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;h3\u0026gt;Functional Programming\u0026lt;/h3\u0026gt;\n\u0026lt;p\u0026gt;In the following code, the function \u0026lt;code\u0026gt;inner\u0026lt;/code\u0026gt; closes over both \u0026lt;code\u0026gt;fn\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;args\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;/p\u0026gt;\u0026lt;div class=\u0026quot;snippet\u0026quot; data-lang=\u0026quot;js\u0026quot; data-hide=\u0026quot;false\u0026quot; data-console=\u0026quot;true\u0026quot; data-babel=\u0026quot;false\u0026quot;\u0026gt;\n\u0026lt;div class=\u0026quot;snippet-code\u0026quot;\u0026gt;\n\u0026lt;pre class=\u0026quot;snippet-code-js lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;curry\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;fn\u0026lt;/span\u0026gt;) {\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; args = []\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;inner\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;arg\u0026lt;/span\u0026gt;) {\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt;(args.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;length\u0026lt;/span\u0026gt; === fn.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;length\u0026lt;/span\u0026gt;) \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;fn\u0026lt;/span\u0026gt;(...args)\n    args.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;push\u0026lt;/span\u0026gt;(arg)\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; inner\n  }\n}\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;add\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;a, b\u0026lt;/span\u0026gt;) {\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; a + b\n}\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; curriedAdd = \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;curry\u0026lt;/span\u0026gt;(add)\n\u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;console\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;log\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;curriedAdd\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;)(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3\u0026lt;/span\u0026gt;)()) \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// 5\u0026lt;/span\u0026gt;\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;div class=\u0026quot;snippet-result\u0026quot;\u0026gt;\u0026lt;div class=\u0026quot;snippet-ctas\u0026quot;\u0026gt;\u0026lt;button type=\u0026quot;button\u0026quot; class=\u0026quot;s-btn s-btn__primary\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;icon-play-white _hover\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;\u0026lt;span\u0026gt; Run code snippet\u0026lt;/span\u0026gt;\u0026lt;/button\u0026gt;\u0026lt;input class=\u0026quot;copySnippet s-btn s-btn__filled\u0026quot; type=\u0026quot;button\u0026quot; value=\u0026quot;Copy snippet to answer\u0026quot; style=\u0026quot;display: none;\u0026quot;\u0026gt;\u0026lt;button type=\u0026quot;button\u0026quot; class=\u0026quot;s-btn hideResults\u0026quot; style=\u0026quot;display: none;\u0026quot;\u0026gt;Hide results\u0026lt;/button\u0026gt;\u0026lt;div class=\u0026quot;popout-code\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;snippet-expand-link\u0026quot;\u0026gt;Expand snippet\u0026lt;/a\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;div class=\u0026quot;snippet-result-code\u0026quot; style=\u0026quot;display: none;\u0026quot;\u0026gt;\u0026lt;iframe name=\u0026quot;sif3\u0026quot; sandbox=\u0026quot;allow-forms allow-modals allow-scripts\u0026quot; class=\u0026quot;snippet-box-edit snippet-box-result\u0026quot; frameborder=\u0026quot;0\u0026quot;\u0026gt;\u0026lt;/iframe\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;/div\u0026gt;\n\u0026lt;/div\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;h3\u0026gt;Event-Oriented Programming\u0026lt;/h3\u0026gt;\n\u0026lt;p\u0026gt;In the following code, function \u0026lt;code\u0026gt;onClick\u0026lt;/code\u0026gt; closes over variable \u0026lt;code\u0026gt;BACKGROUND_COLOR\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;/p\u0026gt;\u0026lt;div class=\u0026quot;snippet\u0026quot; data-lang=\u0026quot;js\u0026quot; data-hide=\u0026quot;false\u0026quot; data-console=\u0026quot;true\u0026quot; data-babel=\u0026quot;false\u0026quot;\u0026gt;\n\u0026lt;div class=\u0026quot;snippet-code\u0026quot;\u0026gt;\n\u0026lt;pre class=\u0026quot;snippet-code-js lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; $ = \u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;document\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;querySelector\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;bind\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;document\u0026lt;/span\u0026gt;)\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-variable constant_\u0026quot;\u0026gt;BACKGROUND_COLOR\u0026lt;/span\u0026gt; = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;rgba(200, 200, 242, 1)\u0026apos;\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;onClick\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;) {\n  $(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;body\u0026apos;\u0026lt;/span\u0026gt;).\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;style\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;background\u0026lt;/span\u0026gt; = \u0026lt;span class=\u0026quot;hljs-variable constant_\u0026quot;\u0026gt;BACKGROUND_COLOR\u0026lt;/span\u0026gt;\n}\n\n$(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;button\u0026apos;\u0026lt;/span\u0026gt;).\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;addEventListener\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;click\u0026apos;\u0026lt;/span\u0026gt;, onClick)\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;pre class=\u0026quot;snippet-code-html lang-html s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-xml\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-tag\u0026quot;\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;button\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026lt;/span\u0026gt;Set background color\u0026lt;span class=\u0026quot;hljs-tag\u0026quot;\u0026gt;\u0026amp;lt;/\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;button\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;div class=\u0026quot;snippet-result\u0026quot;\u0026gt;\u0026lt;div class=\u0026quot;snippet-ctas\u0026quot;\u0026gt;\u0026lt;button type=\u0026quot;button\u0026quot; class=\u0026quot;s-btn s-btn__primary\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;icon-play-white _hover\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;\u0026lt;span\u0026gt; Run code snippet\u0026lt;/span\u0026gt;\u0026lt;/button\u0026gt;\u0026lt;input class=\u0026quot;copySnippet s-btn s-btn__filled\u0026quot; type=\u0026quot;button\u0026quot; value=\u0026quot;Copy snippet to answer\u0026quot; style=\u0026quot;display: none;\u0026quot;\u0026gt;\u0026lt;button type=\u0026quot;button\u0026quot; class=\u0026quot;s-btn hideResults\u0026quot; style=\u0026quot;display: none;\u0026quot;\u0026gt;Hide results\u0026lt;/button\u0026gt;\u0026lt;div class=\u0026quot;popout-code\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;snippet-expand-link\u0026quot;\u0026gt;Expand snippet\u0026lt;/a\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;div class=\u0026quot;snippet-result-code\u0026quot; style=\u0026quot;display: none;\u0026quot;\u0026gt;\u0026lt;iframe name=\u0026quot;sif4\u0026quot; sandbox=\u0026quot;allow-forms allow-modals allow-scripts\u0026quot; class=\u0026quot;snippet-box-edit snippet-box-result\u0026quot; frameborder=\u0026quot;0\u0026quot;\u0026gt;\u0026lt;/iframe\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;/div\u0026gt;\n\u0026lt;/div\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;h3\u0026gt;Modularization\u0026lt;/h3\u0026gt;\n\u0026lt;p\u0026gt;In the following example, all the implementation details are hidden inside an immediately executed function expression. The functions \u0026lt;code\u0026gt;tick\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;toString\u0026lt;/code\u0026gt; close over the private state and functions they need to complete their work. Closures have enabled us to modularize and encapsulate our code.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;/p\u0026gt;\u0026lt;div class=\u0026quot;snippet\u0026quot; data-lang=\u0026quot;js\u0026quot; data-hide=\u0026quot;false\u0026quot; data-console=\u0026quot;true\u0026quot; data-babel=\u0026quot;false\u0026quot;\u0026gt;\n\u0026lt;div class=\u0026quot;snippet-code\u0026quot;\u0026gt;\n\u0026lt;pre class=\u0026quot;snippet-code-js lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;let\u0026lt;/span\u0026gt; namespace = {};\n\n(\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;foo\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;n\u0026lt;/span\u0026gt;) {\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;let\u0026lt;/span\u0026gt; numbers = []\n\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;format\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;n\u0026lt;/span\u0026gt;) {\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Math\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;trunc\u0026lt;/span\u0026gt;(n)\n  }\n\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;tick\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;) {\n    numbers.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;push\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Math\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;random\u0026lt;/span\u0026gt;() * \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;100\u0026lt;/span\u0026gt;)\n  }\n\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;toString\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;) {\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; numbers.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;map\u0026lt;/span\u0026gt;(format)\n  }\n\n  n.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;counter\u0026lt;/span\u0026gt; = {\n    tick,\n    toString\n  }\n}(namespace))\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; counter = namespace.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;counter\u0026lt;/span\u0026gt;\ncounter.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;tick\u0026lt;/span\u0026gt;()\ncounter.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;tick\u0026lt;/span\u0026gt;()\n\u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;console\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;log\u0026lt;/span\u0026gt;(counter.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;toString\u0026lt;/span\u0026gt;())\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;div class=\u0026quot;snippet-result\u0026quot;\u0026gt;\u0026lt;div class=\u0026quot;snippet-ctas\u0026quot;\u0026gt;\u0026lt;button type=\u0026quot;button\u0026quot; class=\u0026quot;s-btn s-btn__primary\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;icon-play-white _hover\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;\u0026lt;span\u0026gt; Run code snippet\u0026lt;/span\u0026gt;\u0026lt;/button\u0026gt;\u0026lt;input class=\u0026quot;copySnippet s-btn s-btn__filled\u0026quot; type=\u0026quot;button\u0026quot; value=\u0026quot;Copy snippet to answer\u0026quot; style=\u0026quot;display: none;\u0026quot;\u0026gt;\u0026lt;button type=\u0026quot;button\u0026quot; class=\u0026quot;s-btn hideResults\u0026quot; style=\u0026quot;display: none;\u0026quot;\u0026gt;Hide results\u0026lt;/button\u0026gt;\u0026lt;div class=\u0026quot;popout-code\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;snippet-expand-link\u0026quot;\u0026gt;Expand snippet\u0026lt;/a\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;div class=\u0026quot;snippet-result-code\u0026quot; style=\u0026quot;display: none;\u0026quot;\u0026gt;\u0026lt;iframe name=\u0026quot;sif5\u0026quot; sandbox=\u0026quot;allow-forms allow-modals allow-scripts\u0026quot; class=\u0026quot;snippet-box-edit snippet-box-result\u0026quot; frameborder=\u0026quot;0\u0026quot;\u0026gt;\u0026lt;/iframe\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;/div\u0026gt;\n\u0026lt;/div\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;h2\u0026gt;Examples\u0026lt;/h2\u0026gt;\n\u0026lt;h3\u0026gt;Example 1\u0026lt;/h3\u0026gt;\n\u0026lt;p\u0026gt;This example shows that the local variables are not copied in the closure: the closure maintains a reference to the original variables \u0026lt;em\u0026gt;themselves\u0026lt;/em\u0026gt;. It is as though the stack-frame stays alive in memory even after the outer function exits.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;/p\u0026gt;\u0026lt;div class=\u0026quot;snippet\u0026quot; data-lang=\u0026quot;js\u0026quot; data-hide=\u0026quot;false\u0026quot; data-console=\u0026quot;true\u0026quot; data-babel=\u0026quot;false\u0026quot;\u0026gt;\n\u0026lt;div class=\u0026quot;snippet-code\u0026quot;\u0026gt;\n\u0026lt;pre class=\u0026quot;snippet-code-js lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;foo\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;) {\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;let\u0026lt;/span\u0026gt; x = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;42\u0026lt;/span\u0026gt;\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;let\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;inner\u0026lt;/span\u0026gt; = (\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;) =\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;console\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;log\u0026lt;/span\u0026gt;(x)\n  x = x + \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; inner\n}\n\n\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;foo\u0026lt;/span\u0026gt;()() \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// logs 43\u0026lt;/span\u0026gt;\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;div class=\u0026quot;snippet-result\u0026quot;\u0026gt;\u0026lt;div class=\u0026quot;snippet-ctas\u0026quot;\u0026gt;\u0026lt;button type=\u0026quot;button\u0026quot; class=\u0026quot;s-btn s-btn__primary\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;icon-play-white _hover\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;\u0026lt;span\u0026gt; Run code snippet\u0026lt;/span\u0026gt;\u0026lt;/button\u0026gt;\u0026lt;input class=\u0026quot;copySnippet s-btn s-btn__filled\u0026quot; type=\u0026quot;button\u0026quot; value=\u0026quot;Copy snippet to answer\u0026quot; style=\u0026quot;display: none;\u0026quot;\u0026gt;\u0026lt;button type=\u0026quot;button\u0026quot; class=\u0026quot;s-btn hideResults\u0026quot; style=\u0026quot;display: none;\u0026quot;\u0026gt;Hide results\u0026lt;/button\u0026gt;\u0026lt;div class=\u0026quot;popout-code\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;snippet-expand-link\u0026quot;\u0026gt;Expand snippet\u0026lt;/a\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;div class=\u0026quot;snippet-result-code\u0026quot; style=\u0026quot;display: none;\u0026quot;\u0026gt;\u0026lt;iframe name=\u0026quot;sif6\u0026quot; sandbox=\u0026quot;allow-forms allow-modals allow-scripts\u0026quot; class=\u0026quot;snippet-box-edit snippet-box-result\u0026quot; frameborder=\u0026quot;0\u0026quot;\u0026gt;\u0026lt;/iframe\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;/div\u0026gt;\n\u0026lt;/div\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;h3\u0026gt;Example 2\u0026lt;/h3\u0026gt;\n\u0026lt;p\u0026gt;In the following code, three methods \u0026lt;code\u0026gt;log\u0026lt;/code\u0026gt;, \u0026lt;code\u0026gt;increment\u0026lt;/code\u0026gt;, and \u0026lt;code\u0026gt;update\u0026lt;/code\u0026gt; all close over the same lexical environment.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;And every time \u0026lt;code\u0026gt;createObject\u0026lt;/code\u0026gt; is called, a new execution context (stack frame) is created and a completely new variable \u0026lt;code\u0026gt;x\u0026lt;/code\u0026gt;, and a new set of functions (\u0026lt;code\u0026gt;log\u0026lt;/code\u0026gt; etc.) are created, that close over this new variable.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;/p\u0026gt;\u0026lt;div class=\u0026quot;snippet\u0026quot; data-lang=\u0026quot;js\u0026quot; data-hide=\u0026quot;false\u0026quot; data-console=\u0026quot;true\u0026quot; data-babel=\u0026quot;false\u0026quot;\u0026gt;\n\u0026lt;div class=\u0026quot;snippet-code\u0026quot;\u0026gt;\n\u0026lt;pre class=\u0026quot;snippet-code-js lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;createObject\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;) {\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;let\u0026lt;/span\u0026gt; x = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;42\u0026lt;/span\u0026gt;;\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; {\n    \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;log\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;) { \u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;console\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;log\u0026lt;/span\u0026gt;(x) },\n    \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;increment\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;) { x++ },\n    \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;update\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;value\u0026lt;/span\u0026gt;) { x = value }\n  }\n}\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; o = \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;createObject\u0026lt;/span\u0026gt;()\no.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;increment\u0026lt;/span\u0026gt;()\no.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;log\u0026lt;/span\u0026gt;() \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// 43\u0026lt;/span\u0026gt;\no.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;update\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;5\u0026lt;/span\u0026gt;)\no.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;log\u0026lt;/span\u0026gt;() \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// 5\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; p = \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;createObject\u0026lt;/span\u0026gt;()\np.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;log\u0026lt;/span\u0026gt;() \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// 42\u0026lt;/span\u0026gt;\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;div class=\u0026quot;snippet-result\u0026quot;\u0026gt;\u0026lt;div class=\u0026quot;snippet-ctas\u0026quot;\u0026gt;\u0026lt;button type=\u0026quot;button\u0026quot; class=\u0026quot;s-btn s-btn__primary\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;icon-play-white _hover\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;\u0026lt;span\u0026gt; Run code snippet\u0026lt;/span\u0026gt;\u0026lt;/button\u0026gt;\u0026lt;input class=\u0026quot;copySnippet s-btn s-btn__filled\u0026quot; type=\u0026quot;button\u0026quot; value=\u0026quot;Copy snippet to answer\u0026quot; style=\u0026quot;display: none;\u0026quot;\u0026gt;\u0026lt;button type=\u0026quot;button\u0026quot; class=\u0026quot;s-btn hideResults\u0026quot; style=\u0026quot;display: none;\u0026quot;\u0026gt;Hide results\u0026lt;/button\u0026gt;\u0026lt;div class=\u0026quot;popout-code\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;snippet-expand-link\u0026quot;\u0026gt;Expand snippet\u0026lt;/a\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;div class=\u0026quot;snippet-result-code\u0026quot; style=\u0026quot;display: none;\u0026quot;\u0026gt;\u0026lt;iframe name=\u0026quot;sif7\u0026quot; sandbox=\u0026quot;allow-forms allow-modals allow-scripts\u0026quot; class=\u0026quot;snippet-box-edit snippet-box-result\u0026quot; frameborder=\u0026quot;0\u0026quot;\u0026gt;\u0026lt;/iframe\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;/div\u0026gt;\n\u0026lt;/div\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;h3\u0026gt;Example 3\u0026lt;/h3\u0026gt;\n\u0026lt;p\u0026gt;If you are using variables declared using \u0026lt;code\u0026gt;var\u0026lt;/code\u0026gt;, be careful you understand which variable you are closing over. Variables declared using \u0026lt;code\u0026gt;var\u0026lt;/code\u0026gt; are hoisted. This is much less of a problem in modern JavaScript due to the introduction of \u0026lt;code\u0026gt;let\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;const\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;In the following code, each time around the loop, a new function \u0026lt;code\u0026gt;inner\u0026lt;/code\u0026gt; is created, which closes over \u0026lt;code\u0026gt;i\u0026lt;/code\u0026gt;. But because \u0026lt;code\u0026gt;var i\u0026lt;/code\u0026gt; is hoisted outside the loop, all of these inner functions close over the same variable, meaning that the final value of \u0026lt;code\u0026gt;i\u0026lt;/code\u0026gt; (3) is printed, three times.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;/p\u0026gt;\u0026lt;div class=\u0026quot;snippet\u0026quot; data-lang=\u0026quot;js\u0026quot; data-hide=\u0026quot;false\u0026quot; data-console=\u0026quot;true\u0026quot; data-babel=\u0026quot;false\u0026quot;\u0026gt;\n\u0026lt;div class=\u0026quot;snippet-code\u0026quot;\u0026gt;\n\u0026lt;pre class=\u0026quot;snippet-code-js lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;foo\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;) {\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; result = []\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt; (\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; i = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;; i \u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3\u0026lt;/span\u0026gt;; i++) {\n    result.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;push\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;inner\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;) { \u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;console\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;log\u0026lt;/span\u0026gt;(i) } )\n  }\n\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; result\n}\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; result = \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;foo\u0026lt;/span\u0026gt;()\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// The following will print `3`, three times...\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt; (\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; i = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;; i \u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3\u0026lt;/span\u0026gt;; i++) {\n  result[i]() \n}\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;div class=\u0026quot;snippet-result\u0026quot;\u0026gt;\u0026lt;div class=\u0026quot;snippet-ctas\u0026quot;\u0026gt;\u0026lt;button type=\u0026quot;button\u0026quot; class=\u0026quot;s-btn s-btn__primary\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;icon-play-white _hover\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;\u0026lt;span\u0026gt; Run code snippet\u0026lt;/span\u0026gt;\u0026lt;/button\u0026gt;\u0026lt;input class=\u0026quot;copySnippet s-btn s-btn__filled\u0026quot; type=\u0026quot;button\u0026quot; value=\u0026quot;Copy snippet to answer\u0026quot; style=\u0026quot;display: none;\u0026quot;\u0026gt;\u0026lt;button type=\u0026quot;button\u0026quot; class=\u0026quot;s-btn hideResults\u0026quot; style=\u0026quot;display: none;\u0026quot;\u0026gt;Hide results\u0026lt;/button\u0026gt;\u0026lt;div class=\u0026quot;popout-code\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;snippet-expand-link\u0026quot;\u0026gt;Expand snippet\u0026lt;/a\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;div class=\u0026quot;snippet-result-code\u0026quot; style=\u0026quot;display: none;\u0026quot;\u0026gt;\u0026lt;iframe name=\u0026quot;sif8\u0026quot; sandbox=\u0026quot;allow-forms allow-modals allow-scripts\u0026quot; class=\u0026quot;snippet-box-edit snippet-box-result\u0026quot; frameborder=\u0026quot;0\u0026quot;\u0026gt;\u0026lt;/iframe\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;/div\u0026gt;\n\u0026lt;/div\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;h2\u0026gt;Final points:\u0026lt;/h2\u0026gt;\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;Whenever a function is declared in JavaScript closure is created.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Returning a \u0026lt;code\u0026gt;function\u0026lt;/code\u0026gt; from inside another function is the classic example of closure, because the state inside the outer function is implicitly available to the returned inner function, even after the outer function has completed execution.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Whenever you use \u0026lt;code\u0026gt;eval()\u0026lt;/code\u0026gt; inside a function, a closure is used. The text you \u0026lt;code\u0026gt;eval\u0026lt;/code\u0026gt; can reference local variables of the function, and in the non-strict mode, you can even create new local variables by using \u0026lt;code\u0026gt;eval(\u0026apos;var foo = \u0026apos;)\u0026lt;/code\u0026gt;.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;When you use \u0026lt;code\u0026gt;new Function()\u0026lt;/code\u0026gt; (the \u0026lt;a href=\u0026quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;Function constructor\u0026lt;/a\u0026gt;) inside a function, it does not close over its lexical environment: it closes over the global context instead. The new function cannot reference the local variables of the outer function.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;A closure in JavaScript is like keeping a reference (\u0026lt;strong\u0026gt;NOT\u0026lt;/strong\u0026gt; a copy) to the scope at the point of function declaration, which in turn keeps a reference to its outer scope, and so on, all the way to the global object at the top of the scope chain.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;A closure is created when a function is declared; this closure is used to configure the execution context when the function is invoked.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;A new set of local variables is created every time a function is called.\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;h2\u0026gt;Links\u0026lt;/h2\u0026gt;\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;Douglas Crockford\u0026apos;s simulated \u0026lt;a href=\u0026quot;http://www.crockford.com/javascript/private.html\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;private attributes and private methods\u0026lt;/a\u0026gt; for an object, using closures.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;A great explanation of how closures can \u0026lt;a href=\u0026quot;https://www.codeproject.com/Articles/12231/Memory-Leakage-in-Internet-Explorer-revisited\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;cause memory leaks in IE\u0026lt;/a\u0026gt; if you are not careful.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;MDN documentation on \u0026lt;a href=\u0026quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;JavaScript Closures\u0026lt;/a\u0026gt;.\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Every function in JavaScript maintains a link to its outer lexical environment. A lexical environment is a map of all the names (eg. variables, parameters) within a scope, with their values.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;So, whenever you see the \u0026lt;code\u0026gt;function\u0026lt;/code\u0026gt; keyword, code inside that function has access to variables declared outside the function.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;/p\u0026gt;\u0026lt;div class=\u0026quot;snippet\u0026quot; data-lang=\u0026quot;js\u0026quot; data-hide=\u0026quot;false\u0026quot; data-console=\u0026quot;true\u0026quot; data-babel=\u0026quot;false\u0026quot;\u0026gt;\n\u0026lt;div class=\u0026quot;snippet-code\u0026quot;\u0026gt;\n\u0026lt;pre class=\u0026quot;snippet-code-js lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;foo\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;x\u0026lt;/span\u0026gt;) {\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; tmp = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3\u0026lt;/span\u0026gt;;\n\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;bar\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;y\u0026lt;/span\u0026gt;) {\n    \u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;console\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;log\u0026lt;/span\u0026gt;(x + y + (++tmp)); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// will log 16\u0026lt;/span\u0026gt;\n  }\n\n  \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;bar\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;10\u0026lt;/span\u0026gt;);\n}\n\n\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;foo\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;);\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;div class=\u0026quot;snippet-result\u0026quot;\u0026gt;\u0026lt;div class=\u0026quot;snippet-ctas\u0026quot;\u0026gt;\u0026lt;button type=\u0026quot;button\u0026quot; class=\u0026quot;s-btn s-btn__primary\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;icon-play-white _hover\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;\u0026lt;span\u0026gt; Run code snippet\u0026lt;/span\u0026gt;\u0026lt;/button\u0026gt;\u0026lt;input class=\u0026quot;copySnippet s-btn s-btn__filled\u0026quot; type=\u0026quot;button\u0026quot; value=\u0026quot;Copy snippet to answer\u0026quot; style=\u0026quot;display: none;\u0026quot;\u0026gt;\u0026lt;button type=\u0026quot;button\u0026quot; class=\u0026quot;s-btn hideResults\u0026quot; style=\u0026quot;display: none;\u0026quot;\u0026gt;Hide results\u0026lt;/button\u0026gt;\u0026lt;div class=\u0026quot;popout-code\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;snippet-expand-link\u0026quot;\u0026gt;Expand snippet\u0026lt;/a\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;div class=\u0026quot;snippet-result-code\u0026quot; style=\u0026quot;display: none;\u0026quot;\u0026gt;\u0026lt;iframe name=\u0026quot;sif9\u0026quot; sandbox=\u0026quot;allow-forms allow-modals allow-scripts\u0026quot; class=\u0026quot;snippet-box-edit snippet-box-result\u0026quot; frameborder=\u0026quot;0\u0026quot;\u0026gt;\u0026lt;/iframe\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;/div\u0026gt;\n\u0026lt;/div\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;This will log \u0026lt;code\u0026gt;16\u0026lt;/code\u0026gt; because function \u0026lt;code\u0026gt;bar\u0026lt;/code\u0026gt; closes over the parameter \u0026lt;code\u0026gt;x\u0026lt;/code\u0026gt; and the variable \u0026lt;code\u0026gt;tmp\u0026lt;/code\u0026gt;, both of which exist in the lexical environment of outer function \u0026lt;code\u0026gt;foo\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Function \u0026lt;code\u0026gt;bar\u0026lt;/code\u0026gt;, together with its link with the lexical environment of function \u0026lt;code\u0026gt;foo\u0026lt;/code\u0026gt; is a closure. \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;A function doesn\u0026apos;t have to \u0026lt;em\u0026gt;return\u0026lt;/em\u0026gt; in order to create a closure. Simply by virtue of its declaration, every function closes over its enclosing lexical environment, forming a closure.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;/p\u0026gt;\u0026lt;div class=\u0026quot;snippet\u0026quot; data-lang=\u0026quot;js\u0026quot; data-hide=\u0026quot;false\u0026quot; data-console=\u0026quot;true\u0026quot; data-babel=\u0026quot;false\u0026quot;\u0026gt;\n\u0026lt;div class=\u0026quot;snippet-code\u0026quot;\u0026gt;\n\u0026lt;pre class=\u0026quot;snippet-code-js lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;foo\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;x\u0026lt;/span\u0026gt;) {\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; tmp = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3\u0026lt;/span\u0026gt;;\n\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt; (\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;y\u0026lt;/span\u0026gt;) {\n    \u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;console\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;log\u0026lt;/span\u0026gt;(x + y + (++tmp)); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// will also log 16\u0026lt;/span\u0026gt;\n  }\n}\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; bar = \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;foo\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;);\n\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;bar\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;10\u0026lt;/span\u0026gt;); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// 16\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;bar\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;10\u0026lt;/span\u0026gt;); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// 17\u0026lt;/span\u0026gt;\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;div class=\u0026quot;snippet-result\u0026quot;\u0026gt;\u0026lt;div class=\u0026quot;snippet-ctas\u0026quot;\u0026gt;\u0026lt;button type=\u0026quot;button\u0026quot; class=\u0026quot;s-btn s-btn__primary\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;icon-play-white _hover\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;\u0026lt;span\u0026gt; Run code snippet\u0026lt;/span\u0026gt;\u0026lt;/button\u0026gt;\u0026lt;input class=\u0026quot;copySnippet s-btn s-btn__filled\u0026quot; type=\u0026quot;button\u0026quot; value=\u0026quot;Copy snippet to answer\u0026quot; style=\u0026quot;display: none;\u0026quot;\u0026gt;\u0026lt;button type=\u0026quot;button\u0026quot; class=\u0026quot;s-btn hideResults\u0026quot; style=\u0026quot;display: none;\u0026quot;\u0026gt;Hide results\u0026lt;/button\u0026gt;\u0026lt;div class=\u0026quot;popout-code\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;snippet-expand-link\u0026quot;\u0026gt;Expand snippet\u0026lt;/a\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;div class=\u0026quot;snippet-result-code\u0026quot; style=\u0026quot;display: none;\u0026quot;\u0026gt;\u0026lt;iframe name=\u0026quot;sif10\u0026quot; sandbox=\u0026quot;allow-forms allow-modals allow-scripts\u0026quot; class=\u0026quot;snippet-box-edit snippet-box-result\u0026quot; frameborder=\u0026quot;0\u0026quot;\u0026gt;\u0026lt;/iframe\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;/div\u0026gt;\n\u0026lt;/div\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;The above function will also log 16, because the code inside \u0026lt;code\u0026gt;bar\u0026lt;/code\u0026gt; can still refer to argument \u0026lt;code\u0026gt;x\u0026lt;/code\u0026gt; and variable \u0026lt;code\u0026gt;tmp\u0026lt;/code\u0026gt;, even though they are no longer directly in scope.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;However, since \u0026lt;code\u0026gt;tmp\u0026lt;/code\u0026gt; is still hanging around inside \u0026lt;code\u0026gt;bar\u0026lt;/code\u0026gt;\u0026apos;s closure, it is available to be incremented. It will be incremented each time you call \u0026lt;code\u0026gt;bar\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;The simplest example of a closure is this:\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;/p\u0026gt;\u0026lt;div class=\u0026quot;snippet\u0026quot; data-lang=\u0026quot;js\u0026quot; data-hide=\u0026quot;false\u0026quot; data-console=\u0026quot;true\u0026quot; data-babel=\u0026quot;false\u0026quot;\u0026gt;\n\u0026lt;div class=\u0026quot;snippet-code\u0026quot;\u0026gt;\n\u0026lt;pre class=\u0026quot;snippet-code-js lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; a = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;10\u0026lt;/span\u0026gt;;\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;test\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;) {\n  \u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;console\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;log\u0026lt;/span\u0026gt;(a); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// will output 10\u0026lt;/span\u0026gt;\n  \u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;console\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;log\u0026lt;/span\u0026gt;(b); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// will output 6\u0026lt;/span\u0026gt;\n}\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; b = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;6\u0026lt;/span\u0026gt;;\n\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;test\u0026lt;/span\u0026gt;();\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;div class=\u0026quot;snippet-result\u0026quot;\u0026gt;\u0026lt;div class=\u0026quot;snippet-ctas\u0026quot;\u0026gt;\u0026lt;button type=\u0026quot;button\u0026quot; class=\u0026quot;s-btn s-btn__primary\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;icon-play-white _hover\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;\u0026lt;span\u0026gt; Run code snippet\u0026lt;/span\u0026gt;\u0026lt;/button\u0026gt;\u0026lt;input class=\u0026quot;copySnippet s-btn s-btn__filled\u0026quot; type=\u0026quot;button\u0026quot; value=\u0026quot;Copy snippet to answer\u0026quot; style=\u0026quot;display: none;\u0026quot;\u0026gt;\u0026lt;button type=\u0026quot;button\u0026quot; class=\u0026quot;s-btn hideResults\u0026quot; style=\u0026quot;display: none;\u0026quot;\u0026gt;Hide results\u0026lt;/button\u0026gt;\u0026lt;div class=\u0026quot;popout-code\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;snippet-expand-link\u0026quot;\u0026gt;Expand snippet\u0026lt;/a\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;div class=\u0026quot;snippet-result-code\u0026quot; style=\u0026quot;display: none;\u0026quot;\u0026gt;\u0026lt;iframe name=\u0026quot;sif11\u0026quot; sandbox=\u0026quot;allow-forms allow-modals allow-scripts\u0026quot; class=\u0026quot;snippet-box-edit snippet-box-result\u0026quot; frameborder=\u0026quot;0\u0026quot;\u0026gt;\u0026lt;/iframe\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;/div\u0026gt;\n\u0026lt;/div\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;When a JavaScript function is invoked, a new execution context \u0026lt;code\u0026gt;ec\u0026lt;/code\u0026gt; is created. Together with the function arguments and the target object, this execution context also receives a link to the lexical environment of the calling execution context, meaning the variables declared in the outer lexical environment (in the above example, both \u0026lt;code\u0026gt;a\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;b\u0026lt;/code\u0026gt;) are available from \u0026lt;code\u0026gt;ec\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Every function creates a closure because every function has a link to its outer lexical environment. \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Note that variables \u0026lt;em\u0026gt;themselves\u0026lt;/em\u0026gt; are visible from within a closure, \u0026lt;em\u0026gt;not\u0026lt;/em\u0026gt; copies.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;FOREWORD: this answer was written when the question was:\u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;Like the old Albert said : \u0026quot;If you can\u0026apos;t explain it to a six-year old, you really don\u0026apos;t understand it yourself.. Well I tried to explain JS closures to a 27 years old friend and completely failed.\u0026lt;/p\u0026gt;\n  \n  \u0026lt;p\u0026gt;Can anybody consider that I am 6 and strangely interested in that subject ?\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;p\u0026gt;I\u0026apos;m pretty sure I was one of the only people that attempted to take the initial question literally. Since then, the question has mutated several times, so my answer may now seem incredibly silly \u0026amp;amp; out of place. Hopefully the general idea of the story remains fun for some.\u0026lt;/p\u0026gt;\n\n\u0026lt;hr\u0026gt;\n\n\u0026lt;p\u0026gt;I\u0026apos;m a big fan of analogy and metaphor when explaining difficult concepts, so let me try my hand with a story.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Once upon a time:\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;There was a princess...\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;princess\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;) {\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;She lived in a wonderful world full of adventures. She met her Prince Charming, rode around her world on a unicorn, battled dragons, encountered talking animals, and many other fantastical things.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; adventures = [];\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;princeCharming\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;) { \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;/* ... */\u0026lt;/span\u0026gt; }\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; unicorn = { \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;/* ... */\u0026lt;/span\u0026gt; },\n        dragons = [ \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;/* ... */\u0026lt;/span\u0026gt; ],\n        squirrel = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Hello!\u0026quot;\u0026lt;/span\u0026gt;;\n\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;/* ... */\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;But she would always have to return back to her dull world of chores and grown-ups.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; {\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;And she would often tell them of her latest amazing adventure as a princess.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;        \u0026lt;span class=\u0026quot;hljs-attr\u0026quot;\u0026gt;story\u0026lt;/span\u0026gt;: \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;) {\n            \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; adventures[adventures.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;length\u0026lt;/span\u0026gt; - \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;];\n        }\n    };\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;But all they would see is a little girl...\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; littleGirl = \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;princess\u0026lt;/span\u0026gt;();\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;...telling stories about magic and fantasy.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;littleGirl.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;story\u0026lt;/span\u0026gt;();\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;And even though the grown-ups knew of real princesses, they would never believe in the unicorns or dragons because they could never see them. The grown-ups said that they only existed inside the little girl\u0026apos;s imagination.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;But we know the real truth; that the little girl with the princess inside...\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;...is really a princess with a little girl inside.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Taking the question seriously, we should find out what a typical 6-year-old is capable of cognitively, though admittedly, one who is interested in JavaScript is not so typical.  \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;On  \u0026lt;a href=\u0026quot;http://www.howkidsdevelop.com/5-7years.html\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;Childhood Development: 5 to 7 Years \u0026lt;/a\u0026gt; it says:\u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;Your child will be able to follow two-step directions. For example, if you say to your child, \u0026quot;Go to the kitchen and get me a trash bag\u0026quot; they will be able to remember that direction.\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;p\u0026gt;We can use this example to explain closures, as follows:\u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;The kitchen is a closure that has a local variable, called \u0026lt;code\u0026gt;trashBags\u0026lt;/code\u0026gt;.  There is a function inside the kitchen called \u0026lt;code\u0026gt;getTrashBag\u0026lt;/code\u0026gt; that gets one trash bag and returns it.\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;p\u0026gt;We can code this in JavaScript like this:\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;/p\u0026gt;\u0026lt;div class=\u0026quot;snippet\u0026quot; data-lang=\u0026quot;js\u0026quot; data-hide=\u0026quot;false\u0026quot; data-console=\u0026quot;true\u0026quot; data-babel=\u0026quot;false\u0026quot;\u0026gt;\n\u0026lt;div class=\u0026quot;snippet-code\u0026quot;\u0026gt;\n\u0026lt;pre class=\u0026quot;snippet-code-js lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;makeKitchen\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;) {\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; trashBags = [\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;A\u0026apos;\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;B\u0026apos;\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;C\u0026apos;\u0026lt;/span\u0026gt;]; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// only 3 at first\u0026lt;/span\u0026gt;\n\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; {\n    \u0026lt;span class=\u0026quot;hljs-attr\u0026quot;\u0026gt;getTrashBag\u0026lt;/span\u0026gt;: \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;) {\n      \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; trashBags.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;pop\u0026lt;/span\u0026gt;();\n    }\n  };\n}\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; kitchen = \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;makeKitchen\u0026lt;/span\u0026gt;();\n\n\u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;console\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;log\u0026lt;/span\u0026gt;(kitchen.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;getTrashBag\u0026lt;/span\u0026gt;()); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// returns trash bag C\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;console\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;log\u0026lt;/span\u0026gt;(kitchen.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;getTrashBag\u0026lt;/span\u0026gt;()); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// returns trash bag B\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;console\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;log\u0026lt;/span\u0026gt;(kitchen.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;getTrashBag\u0026lt;/span\u0026gt;()); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// returns trash bag A\u0026lt;/span\u0026gt;\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;div class=\u0026quot;snippet-result\u0026quot;\u0026gt;\u0026lt;div class=\u0026quot;snippet-ctas\u0026quot;\u0026gt;\u0026lt;button type=\u0026quot;button\u0026quot; class=\u0026quot;s-btn s-btn__primary\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;icon-play-white _hover\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;\u0026lt;span\u0026gt; Run code snippet\u0026lt;/span\u0026gt;\u0026lt;/button\u0026gt;\u0026lt;input class=\u0026quot;copySnippet s-btn s-btn__filled\u0026quot; type=\u0026quot;button\u0026quot; value=\u0026quot;Copy snippet to answer\u0026quot; style=\u0026quot;display: none;\u0026quot;\u0026gt;\u0026lt;button type=\u0026quot;button\u0026quot; class=\u0026quot;s-btn hideResults\u0026quot; style=\u0026quot;display: none;\u0026quot;\u0026gt;Hide results\u0026lt;/button\u0026gt;\u0026lt;div class=\u0026quot;popout-code\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;snippet-expand-link\u0026quot;\u0026gt;Expand snippet\u0026lt;/a\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;div class=\u0026quot;snippet-result-code\u0026quot; style=\u0026quot;display: none;\u0026quot;\u0026gt;\u0026lt;iframe name=\u0026quot;sif12\u0026quot; sandbox=\u0026quot;allow-forms allow-modals allow-scripts\u0026quot; class=\u0026quot;snippet-box-edit snippet-box-result\u0026quot; frameborder=\u0026quot;0\u0026quot;\u0026gt;\u0026lt;/iframe\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;/div\u0026gt;\n\u0026lt;/div\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Further points that explain why closures are interesting:\u0026lt;/p\u0026gt;\n\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;Each time \u0026lt;code\u0026gt;makeKitchen()\u0026lt;/code\u0026gt; is called, a new closure is created with its own separate \u0026lt;code\u0026gt;trashBags\u0026lt;/code\u0026gt;.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;The \u0026lt;code\u0026gt;trashBags\u0026lt;/code\u0026gt; variable is local to the inside of each kitchen and is not accessible outside, but the inner function on the \u0026lt;code\u0026gt;getTrashBag\u0026lt;/code\u0026gt; property does have access to it.  \u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Every function call creates a closure, but there would be no need to keep the closure around unless an inner function, which has access to the inside of the closure, can be called from outside the closure.  Returning the object with the \u0026lt;code\u0026gt;getTrashBag\u0026lt;/code\u0026gt; function does that here.\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n    ","\n\u0026lt;h1\u0026gt;The Straw Man\u0026lt;/h1\u0026gt;\n\u0026lt;p\u0026gt;I need to know how many times a button has been clicked and do something on every third click...\u0026lt;/p\u0026gt;\n\u0026lt;h2\u0026gt;Fairly Obvious Solution\u0026lt;/h2\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;/p\u0026gt;\u0026lt;div class=\u0026quot;snippet\u0026quot; data-lang=\u0026quot;js\u0026quot; data-hide=\u0026quot;false\u0026quot; data-console=\u0026quot;true\u0026quot; data-babel=\u0026quot;false\u0026quot;\u0026gt;\n\u0026lt;div class=\u0026quot;snippet-code\u0026quot;\u0026gt;\n\u0026lt;pre class=\u0026quot;snippet-code-js lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Declare counter outside event handler\u0026apos;s scope\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; counter = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; element = \u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;document\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;getElementById\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;button\u0026apos;\u0026lt;/span\u0026gt;);\n\nelement.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;addEventListener\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;click\u0026quot;\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;) {\n  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Increment outside counter\u0026lt;/span\u0026gt;\n  counter++;\n\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (counter === \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3\u0026lt;/span\u0026gt;) {\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Do something every third time\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;console\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;log\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Third time\u0026apos;s the charm!\u0026quot;\u0026lt;/span\u0026gt;);\n\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Reset counter\u0026lt;/span\u0026gt;\n    counter = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;;\n  }\n});\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;pre class=\u0026quot;snippet-code-html lang-html s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-xml\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-tag\u0026quot;\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;button\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-attr\u0026quot;\u0026gt;id\u0026lt;/span\u0026gt;=\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;button\u0026quot;\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026lt;/span\u0026gt;Click Me!\u0026lt;span class=\u0026quot;hljs-tag\u0026quot;\u0026gt;\u0026amp;lt;/\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;button\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;div class=\u0026quot;snippet-result\u0026quot;\u0026gt;\u0026lt;div class=\u0026quot;snippet-ctas\u0026quot;\u0026gt;\u0026lt;button type=\u0026quot;button\u0026quot; class=\u0026quot;s-btn s-btn__primary\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;icon-play-white _hover\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;\u0026lt;span\u0026gt; Run code snippet\u0026lt;/span\u0026gt;\u0026lt;/button\u0026gt;\u0026lt;input class=\u0026quot;copySnippet s-btn s-btn__filled\u0026quot; type=\u0026quot;button\u0026quot; value=\u0026quot;Copy snippet to answer\u0026quot; style=\u0026quot;display: none;\u0026quot;\u0026gt;\u0026lt;button type=\u0026quot;button\u0026quot; class=\u0026quot;s-btn hideResults\u0026quot; style=\u0026quot;display: none;\u0026quot;\u0026gt;Hide results\u0026lt;/button\u0026gt;\u0026lt;div class=\u0026quot;popout-code\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;snippet-expand-link\u0026quot;\u0026gt;Expand snippet\u0026lt;/a\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;div class=\u0026quot;snippet-result-code\u0026quot; style=\u0026quot;display: none;\u0026quot;\u0026gt;\u0026lt;iframe name=\u0026quot;sif13\u0026quot; sandbox=\u0026quot;allow-forms allow-modals allow-scripts\u0026quot; class=\u0026quot;snippet-box-edit snippet-box-result\u0026quot; frameborder=\u0026quot;0\u0026quot;\u0026gt;\u0026lt;/iframe\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;/div\u0026gt;\n\u0026lt;/div\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Now this will work, but it does encroach into the outer scope by adding a variable, whose sole purpose is to keep track of the count. In some situations, this would be preferable as your outer application might need access to this information. But in this case, we are only changing every third click\u0026apos;s behavior, so it is preferable to \u0026lt;strong\u0026gt;enclose this functionality inside the event handler\u0026lt;/strong\u0026gt;.\u0026lt;/p\u0026gt;\n\u0026lt;h2\u0026gt;Consider this option\u0026lt;/h2\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;/p\u0026gt;\u0026lt;div class=\u0026quot;snippet\u0026quot; data-lang=\u0026quot;js\u0026quot; data-hide=\u0026quot;false\u0026quot; data-console=\u0026quot;true\u0026quot; data-babel=\u0026quot;false\u0026quot;\u0026gt;\n\u0026lt;div class=\u0026quot;snippet-code\u0026quot;\u0026gt;\n\u0026lt;pre class=\u0026quot;snippet-code-js lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; element = \u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;document\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;getElementById\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;button\u0026apos;\u0026lt;/span\u0026gt;);\n\nelement.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;addEventListener\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;click\u0026quot;\u0026lt;/span\u0026gt;, (\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;) {\n  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// init the count to 0\u0026lt;/span\u0026gt;\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; count = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;;\n\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;e\u0026lt;/span\u0026gt;) { \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// \u0026amp;lt;- This function becomes the click handler\u0026lt;/span\u0026gt;\n    count++; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//    and will retain access to the above `count`\u0026lt;/span\u0026gt;\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (count === \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3\u0026lt;/span\u0026gt;) {\n      \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Do something every third time\u0026lt;/span\u0026gt;\n      \u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;console\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;log\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Third time\u0026apos;s the charm!\u0026quot;\u0026lt;/span\u0026gt;);\n\n      \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//Reset counter\u0026lt;/span\u0026gt;\n      count = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;;\n    }\n  };\n})());\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;pre class=\u0026quot;snippet-code-html lang-html s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-xml\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-tag\u0026quot;\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;button\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-attr\u0026quot;\u0026gt;id\u0026lt;/span\u0026gt;=\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;button\u0026quot;\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026lt;/span\u0026gt;Click Me!\u0026lt;span class=\u0026quot;hljs-tag\u0026quot;\u0026gt;\u0026amp;lt;/\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;button\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;div class=\u0026quot;snippet-result\u0026quot;\u0026gt;\u0026lt;div class=\u0026quot;snippet-ctas\u0026quot;\u0026gt;\u0026lt;button type=\u0026quot;button\u0026quot; class=\u0026quot;s-btn s-btn__primary\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;icon-play-white _hover\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;\u0026lt;span\u0026gt; Run code snippet\u0026lt;/span\u0026gt;\u0026lt;/button\u0026gt;\u0026lt;input class=\u0026quot;copySnippet s-btn s-btn__filled\u0026quot; type=\u0026quot;button\u0026quot; value=\u0026quot;Copy snippet to answer\u0026quot; style=\u0026quot;display: none;\u0026quot;\u0026gt;\u0026lt;button type=\u0026quot;button\u0026quot; class=\u0026quot;s-btn hideResults\u0026quot; style=\u0026quot;display: none;\u0026quot;\u0026gt;Hide results\u0026lt;/button\u0026gt;\u0026lt;div class=\u0026quot;popout-code\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;snippet-expand-link\u0026quot;\u0026gt;Expand snippet\u0026lt;/a\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;div class=\u0026quot;snippet-result-code\u0026quot; style=\u0026quot;display: none;\u0026quot;\u0026gt;\u0026lt;iframe name=\u0026quot;sif14\u0026quot; sandbox=\u0026quot;allow-forms allow-modals allow-scripts\u0026quot; class=\u0026quot;snippet-box-edit snippet-box-result\u0026quot; frameborder=\u0026quot;0\u0026quot;\u0026gt;\u0026lt;/iframe\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;/div\u0026gt;\n\u0026lt;/div\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Notice a few things here.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;In the above example, I am using the closure behavior of JavaScript. \u0026lt;strong\u0026gt;This behavior allows any function to have access to the scope in which it was created, indefinitely.\u0026lt;/strong\u0026gt; To practically apply this, I immediately invoke a function that returns another function, and because the function I\u0026apos;m returning has access to the internal count variable (because of the closure behavior explained above) this results in a private scope for usage by the resulting function... Not so simple? Let\u0026apos;s dilute it down...\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;A simple one-line closure\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//          _______________________Immediately invoked______________________\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//         |                                                                |\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//         |        Scope retained for use      ___Returned as the____      |\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//         |       only by returned function   |    value of func     |     |\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//         |             |            |        |                      |     |\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//         v             v            v        v                      v     v\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; func = (\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;) { \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; a = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;val\u0026apos;\u0026lt;/span\u0026gt;; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;) { \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;alert\u0026lt;/span\u0026gt;(a); }; })();\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;All variables outside the returned function are available to the returned function, but they are not directly available to the returned function object...\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;func\u0026lt;/span\u0026gt;();  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Alerts \u0026quot;val\u0026quot;\u0026lt;/span\u0026gt;\nfunc.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;a\u0026lt;/span\u0026gt;;  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Undefined\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;Get it? So in our primary example, the count variable is contained within the closure and always available to the event handler, so it retains its state from click to click.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Also, this private variable state is \u0026lt;strong\u0026gt;fully\u0026lt;/strong\u0026gt; accessible, for both readings and assigning to its private scoped variables.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;There you go; you\u0026apos;re now fully encapsulating this behavior.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;\u0026lt;a href=\u0026quot;http://jondavidjohn.com/javascript-closure-explained-using-events/\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;Full Blog Post\u0026lt;/a\u0026gt;\u0026lt;/strong\u0026gt; (including jQuery considerations)\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Closures are hard to explain because they are used to make some behaviour work that everybody intuitively expects to work anyway. I find the best way to explain them (and the way that \u0026lt;em\u0026gt;I\u0026lt;/em\u0026gt; learned what they do) is to imagine the situation without them:\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;/p\u0026gt;\u0026lt;div class=\u0026quot;snippet\u0026quot; data-lang=\u0026quot;js\u0026quot; data-hide=\u0026quot;false\u0026quot; data-console=\u0026quot;true\u0026quot; data-babel=\u0026quot;false\u0026quot;\u0026gt;\n\u0026lt;div class=\u0026quot;snippet-code\u0026quot;\u0026gt;\n\u0026lt;pre class=\u0026quot;snippet-code-js lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; makePlus = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;x\u0026lt;/span\u0026gt;) {\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;y\u0026lt;/span\u0026gt;) { \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; x + y; };\n}\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; plus5 = \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;makePlus\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;5\u0026lt;/span\u0026gt;);\n\u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;console\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;log\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;plus5\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3\u0026lt;/span\u0026gt;));\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;div class=\u0026quot;snippet-result\u0026quot;\u0026gt;\u0026lt;div class=\u0026quot;snippet-ctas\u0026quot;\u0026gt;\u0026lt;button type=\u0026quot;button\u0026quot; class=\u0026quot;s-btn s-btn__primary\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;icon-play-white _hover\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;\u0026lt;span\u0026gt; Run code snippet\u0026lt;/span\u0026gt;\u0026lt;/button\u0026gt;\u0026lt;input class=\u0026quot;copySnippet s-btn s-btn__filled\u0026quot; type=\u0026quot;button\u0026quot; value=\u0026quot;Copy snippet to answer\u0026quot; style=\u0026quot;display: none;\u0026quot;\u0026gt;\u0026lt;button type=\u0026quot;button\u0026quot; class=\u0026quot;s-btn hideResults\u0026quot; style=\u0026quot;display: none;\u0026quot;\u0026gt;Hide results\u0026lt;/button\u0026gt;\u0026lt;div class=\u0026quot;popout-code\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;snippet-expand-link\u0026quot;\u0026gt;Expand snippet\u0026lt;/a\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;div class=\u0026quot;snippet-result-code\u0026quot; style=\u0026quot;display: none;\u0026quot;\u0026gt;\u0026lt;iframe name=\u0026quot;sif15\u0026quot; sandbox=\u0026quot;allow-forms allow-modals allow-scripts\u0026quot; class=\u0026quot;snippet-box-edit snippet-box-result\u0026quot; frameborder=\u0026quot;0\u0026quot;\u0026gt;\u0026lt;/iframe\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;/div\u0026gt;\n\u0026lt;/div\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;What would happen here if JavaScript \u0026lt;em\u0026gt;didn\u0026apos;t\u0026lt;/em\u0026gt; know closures? Just replace the call in the last line by its method body (which is basically what function calls do) and you get:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;console\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;log\u0026lt;/span\u0026gt;(x + \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3\u0026lt;/span\u0026gt;);\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;Now, where\u0026apos;s the definition of \u0026lt;code\u0026gt;x\u0026lt;/code\u0026gt;? We didn\u0026apos;t define it in the current scope. The only solution is to let \u0026lt;code\u0026gt;plus5\u0026lt;/code\u0026gt; \u0026lt;em\u0026gt;carry\u0026lt;/em\u0026gt; its scope (or rather, its parent\u0026apos;s scope) around. This way, \u0026lt;code\u0026gt;x\u0026lt;/code\u0026gt; is well-defined and it is bound to the value 5.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;TLDR\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;A closure is a link between a function and its outer lexical (ie. as-written) environment, such that the identifiers (variables, parameters, function declarations etc) defined within that environment are visible from within the function, regardless of when or from where the function is invoked.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Details\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;In the terminology of the ECMAScript specification, a closure can be said to be implemented by the \u0026lt;a href=\u0026quot;https://www.ecma-international.org/ecma-262/10.0/index.html#sec-functioninitialize\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;\u0026lt;code\u0026gt;[[Environment]]\u0026lt;/code\u0026gt;\u0026lt;/a\u0026gt; reference of every function-object, which points to the \u0026lt;a href=\u0026quot;https://www.ecma-international.org/ecma-262/10.0/index.html#sec-lexical-environments\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;lexical environment\u0026lt;/a\u0026gt; within which the function is defined.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;When a function is invoked via the internal \u0026lt;a href=\u0026quot;https://www.ecma-international.org/ecma-262/10.0/index.html#sec-ecmascript-function-objects-call-thisargument-argumentslist\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;\u0026lt;code\u0026gt;[[Call]]\u0026lt;/code\u0026gt;\u0026lt;/a\u0026gt; method, the \u0026lt;a href=\u0026quot;https://www.ecma-international.org/ecma-262/10.0/index.html#sec-functioninitialize\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;\u0026lt;code\u0026gt;[[Environment]]\u0026lt;/code\u0026gt;\u0026lt;/a\u0026gt; reference on the function-object is copied into the \u0026lt;em\u0026gt;outer environment reference\u0026lt;/em\u0026gt; of the \u0026lt;a href=\u0026quot;https://www.ecma-international.org/ecma-262/10.0/index.html#sec-environment-records\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;environment record\u0026lt;/a\u0026gt; of the newly-created \u0026lt;a href=\u0026quot;https://www.ecma-international.org/ecma-262/10.0/index.html#sec-execution-contexts\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;execution context\u0026lt;/a\u0026gt; (stack frame).\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;In the following example, function \u0026lt;code\u0026gt;f\u0026lt;/code\u0026gt; closes over the lexical environment of the global execution context:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;f\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;) {}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;In the following example, function \u0026lt;code\u0026gt;h\u0026lt;/code\u0026gt; closes over the lexical environment of function \u0026lt;code\u0026gt;g\u0026lt;/code\u0026gt;, which, in turn, closes over the lexical environment of the global execution context.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;g\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;) {\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;h\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;) {}\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;If an inner function is returned by an outer, then the outer lexical environment will persist after the outer function has returned. This is because the outer lexical environment needs to be available if the inner function is eventually invoked.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;In the following example, function \u0026lt;code\u0026gt;j\u0026lt;/code\u0026gt; closes over the lexical environment of function \u0026lt;code\u0026gt;i\u0026lt;/code\u0026gt;, meaning that variable \u0026lt;code\u0026gt;x\u0026lt;/code\u0026gt; is visible from inside function \u0026lt;code\u0026gt;j\u0026lt;/code\u0026gt;, long after function \u0026lt;code\u0026gt;i\u0026lt;/code\u0026gt; has completed execution:\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;/p\u0026gt;\u0026lt;div class=\u0026quot;snippet\u0026quot; data-lang=\u0026quot;js\u0026quot; data-hide=\u0026quot;false\u0026quot; data-console=\u0026quot;true\u0026quot; data-babel=\u0026quot;false\u0026quot;\u0026gt;\n\u0026lt;div class=\u0026quot;snippet-code\u0026quot;\u0026gt;\n\u0026lt;pre class=\u0026quot;snippet-code-js lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;i\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;) {\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; x = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;mochacchino\u0026apos;\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;j\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;) {\n        \u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;console\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;log\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;Printing the value of x, from within function j: \u0026apos;\u0026lt;/span\u0026gt;, x)\n    }\n} \n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; k = \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;i\u0026lt;/span\u0026gt;()\n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;setTimeout\u0026lt;/span\u0026gt;(k, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;500\u0026lt;/span\u0026gt;) \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// invoke k (which is j) after 500ms\u0026lt;/span\u0026gt;\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;div class=\u0026quot;snippet-result\u0026quot;\u0026gt;\u0026lt;div class=\u0026quot;snippet-ctas\u0026quot;\u0026gt;\u0026lt;button type=\u0026quot;button\u0026quot; class=\u0026quot;s-btn s-btn__primary\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;icon-play-white _hover\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;\u0026lt;span\u0026gt; Run code snippet\u0026lt;/span\u0026gt;\u0026lt;/button\u0026gt;\u0026lt;input class=\u0026quot;copySnippet s-btn s-btn__filled\u0026quot; type=\u0026quot;button\u0026quot; value=\u0026quot;Copy snippet to answer\u0026quot; style=\u0026quot;display: none;\u0026quot;\u0026gt;\u0026lt;button type=\u0026quot;button\u0026quot; class=\u0026quot;s-btn hideResults\u0026quot; style=\u0026quot;display: none;\u0026quot;\u0026gt;Hide results\u0026lt;/button\u0026gt;\u0026lt;div class=\u0026quot;popout-code\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;snippet-expand-link\u0026quot;\u0026gt;Expand snippet\u0026lt;/a\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;div class=\u0026quot;snippet-result-code\u0026quot; style=\u0026quot;display: none;\u0026quot;\u0026gt;\u0026lt;iframe name=\u0026quot;sif16\u0026quot; sandbox=\u0026quot;allow-forms allow-modals allow-scripts\u0026quot; class=\u0026quot;snippet-box-edit snippet-box-result\u0026quot; frameborder=\u0026quot;0\u0026quot;\u0026gt;\u0026lt;/iframe\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;/div\u0026gt;\n\u0026lt;/div\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;In a closure, the variables in the outer lexical environment \u0026lt;em\u0026gt;themselves\u0026lt;/em\u0026gt; are available, \u0026lt;em\u0026gt;not\u0026lt;/em\u0026gt; copies.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;/p\u0026gt;\u0026lt;div class=\u0026quot;snippet\u0026quot; data-lang=\u0026quot;js\u0026quot; data-hide=\u0026quot;false\u0026quot; data-console=\u0026quot;true\u0026quot; data-babel=\u0026quot;false\u0026quot;\u0026gt;\n\u0026lt;div class=\u0026quot;snippet-code\u0026quot;\u0026gt;\n\u0026lt;pre class=\u0026quot;snippet-code-js lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;l\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;) {\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; y = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;vanilla\u0026apos;\u0026lt;/span\u0026gt;;\n\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; {\n    \u0026lt;span class=\u0026quot;hljs-attr\u0026quot;\u0026gt;setY\u0026lt;/span\u0026gt;: \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;value\u0026lt;/span\u0026gt;) {\n      y = value;\n    },\n    \u0026lt;span class=\u0026quot;hljs-attr\u0026quot;\u0026gt;logY\u0026lt;/span\u0026gt;: \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;value\u0026lt;/span\u0026gt;) {\n      \u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;console\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;log\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;The value of y is: \u0026apos;\u0026lt;/span\u0026gt;, y);\n    }\n  }\n}\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; o = \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;l\u0026lt;/span\u0026gt;()\no.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;logY\u0026lt;/span\u0026gt;() \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// The value of y is: vanilla\u0026lt;/span\u0026gt;\no.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;setY\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;chocolate\u0026apos;\u0026lt;/span\u0026gt;)\no.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;logY\u0026lt;/span\u0026gt;() \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// The value of y is: chocolate\u0026lt;/span\u0026gt;\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;div class=\u0026quot;snippet-result\u0026quot;\u0026gt;\u0026lt;div class=\u0026quot;snippet-ctas\u0026quot;\u0026gt;\u0026lt;button type=\u0026quot;button\u0026quot; class=\u0026quot;s-btn s-btn__primary\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;icon-play-white _hover\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;\u0026lt;span\u0026gt; Run code snippet\u0026lt;/span\u0026gt;\u0026lt;/button\u0026gt;\u0026lt;input class=\u0026quot;copySnippet s-btn s-btn__filled\u0026quot; type=\u0026quot;button\u0026quot; value=\u0026quot;Copy snippet to answer\u0026quot; style=\u0026quot;display: none;\u0026quot;\u0026gt;\u0026lt;button type=\u0026quot;button\u0026quot; class=\u0026quot;s-btn hideResults\u0026quot; style=\u0026quot;display: none;\u0026quot;\u0026gt;Hide results\u0026lt;/button\u0026gt;\u0026lt;div class=\u0026quot;popout-code\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;snippet-expand-link\u0026quot;\u0026gt;Expand snippet\u0026lt;/a\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;div class=\u0026quot;snippet-result-code\u0026quot; style=\u0026quot;display: none;\u0026quot;\u0026gt;\u0026lt;iframe name=\u0026quot;sif17\u0026quot; sandbox=\u0026quot;allow-forms allow-modals allow-scripts\u0026quot; class=\u0026quot;snippet-box-edit snippet-box-result\u0026quot; frameborder=\u0026quot;0\u0026quot;\u0026gt;\u0026lt;/iframe\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;/div\u0026gt;\n\u0026lt;/div\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;The chain of lexical environments, linked between execution contexts via outer environment references, forms a \u0026lt;em\u0026gt;scope chain\u0026lt;/em\u0026gt; and defines the identifiers visible from any given function.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Please note that in an attempt to improve clarity and accuracy, this answer has been substantially changed from the original.\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;OK, 6-year-old closures fan. Do you want to hear the simplest example of closure?\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Let\u0026apos;s imagine the next situation: a driver is sitting in a car. That car is inside a plane. Plane is in the airport. The ability of driver to access things outside his car, but inside the plane, even if that plane leaves an airport, is a closure. That\u0026apos;s it. When you turn 27, look at the \u0026lt;a href=\u0026quot;https://stackoverflow.com/a/111200/1393791\u0026quot;\u0026gt;more detailed explanation\u0026lt;/a\u0026gt; or at the example below.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Here is how I can convert my plane story into the code.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;/p\u0026gt;\u0026lt;div class=\u0026quot;snippet\u0026quot; data-lang=\u0026quot;js\u0026quot; data-hide=\u0026quot;false\u0026quot; data-console=\u0026quot;true\u0026quot; data-babel=\u0026quot;false\u0026quot;\u0026gt;\n\u0026lt;div class=\u0026quot;snippet-code\u0026quot;\u0026gt;\n\u0026lt;pre class=\u0026quot;snippet-code-js lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; plane = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;defaultAirport\u0026lt;/span\u0026gt;) {\n\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; lastAirportLeft = defaultAirport;\n\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; car = {\n    \u0026lt;span class=\u0026quot;hljs-attr\u0026quot;\u0026gt;driver\u0026lt;/span\u0026gt;: {\n      \u0026lt;span class=\u0026quot;hljs-attr\u0026quot;\u0026gt;startAccessPlaneInfo\u0026lt;/span\u0026gt;: \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;) {\n        \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;setInterval\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;) {\n          \u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;console\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;log\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Last airport was \u0026quot;\u0026lt;/span\u0026gt; + lastAirportLeft);\n        }, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2000\u0026lt;/span\u0026gt;);\n      }\n    }\n  };\n  car.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;driver\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;startAccessPlaneInfo\u0026lt;/span\u0026gt;();\n\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; {\n    \u0026lt;span class=\u0026quot;hljs-attr\u0026quot;\u0026gt;leaveTheAirport\u0026lt;/span\u0026gt;: \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;airPortName\u0026lt;/span\u0026gt;) {\n      lastAirportLeft = airPortName;\n    }\n  }\n}(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Boryspil International Airport\u0026quot;\u0026lt;/span\u0026gt;);\n\nplane.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;leaveTheAirport\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;John F. Kennedy\u0026quot;\u0026lt;/span\u0026gt;);\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;div class=\u0026quot;snippet-result\u0026quot;\u0026gt;\u0026lt;div class=\u0026quot;snippet-ctas\u0026quot;\u0026gt;\u0026lt;button type=\u0026quot;button\u0026quot; class=\u0026quot;s-btn s-btn__primary\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;icon-play-white _hover\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;\u0026lt;span\u0026gt; Run code snippet\u0026lt;/span\u0026gt;\u0026lt;/button\u0026gt;\u0026lt;input class=\u0026quot;copySnippet s-btn s-btn__filled\u0026quot; type=\u0026quot;button\u0026quot; value=\u0026quot;Copy snippet to answer\u0026quot; style=\u0026quot;display: none;\u0026quot;\u0026gt;\u0026lt;button type=\u0026quot;button\u0026quot; class=\u0026quot;s-btn hideResults\u0026quot; style=\u0026quot;display: none;\u0026quot;\u0026gt;Hide results\u0026lt;/button\u0026gt;\u0026lt;div class=\u0026quot;popout-code\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;snippet-expand-link\u0026quot;\u0026gt;Expand snippet\u0026lt;/a\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;div class=\u0026quot;snippet-result-code\u0026quot; style=\u0026quot;display: none;\u0026quot;\u0026gt;\u0026lt;iframe name=\u0026quot;sif18\u0026quot; sandbox=\u0026quot;allow-forms allow-modals allow-scripts\u0026quot; class=\u0026quot;snippet-box-edit snippet-box-result\u0026quot; frameborder=\u0026quot;0\u0026quot;\u0026gt;\u0026lt;/iframe\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;/div\u0026gt;\n\u0026lt;/div\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;This is an attempt to clear up several (possible) misunderstandings about closures that appear in some of the other answers.\u0026lt;/p\u0026gt;\n\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;strong\u0026gt;A closure is not only created when you return an inner function.\u0026lt;/strong\u0026gt; In fact, the enclosing function \u0026lt;em\u0026gt;does not need to return at all\u0026lt;/em\u0026gt; in order for its closure to be created. You might instead assign your inner function to a variable in an outer scope, or pass it as an argument to another function where it could be called immediately or any time later. Therefore, the closure of the enclosing function is probably created \u0026lt;em\u0026gt;as soon as the enclosing function is called\u0026lt;/em\u0026gt; since any inner function has access to that closure whenever the inner function is called, before or after the enclosing function returns. \u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;strong\u0026gt;A closure does not reference a copy of the \u0026lt;em\u0026gt;old values\u0026lt;/em\u0026gt; of variables in its scope.\u0026lt;/strong\u0026gt; The variables themselves are part of the closure, and so the value seen when accessing one of those variables is the latest value at the time it is accessed. This is why inner functions created inside of loops can be tricky, since each one has access to the same outer variables rather than grabbing a copy of the variables at the time the function is created or called.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;strong\u0026gt;The \u0026quot;variables\u0026quot; in a closure include any named functions\u0026lt;/strong\u0026gt; declared within the function. They also include arguments of the function. A closure also has access to its containing closure\u0026apos;s variables, all the way up to the global scope.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;strong\u0026gt;Closures use memory, but they don\u0026apos;t cause memory leaks\u0026lt;/strong\u0026gt; since JavaScript by itself cleans up its own circular structures that are not referenced. Internet\u0026amp;nbsp;Explorer memory leaks involving closures are created when it fails to disconnect DOM attribute values that reference closures, thus maintaining references to possibly circular structures.\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n    ","\n\u0026lt;p\u0026gt;I wrote a blog post a while back explaining closures. Here\u0026apos;s what I said about closures in terms of \u0026lt;strong\u0026gt;why\u0026lt;/strong\u0026gt; you\u0026apos;d want one.\u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;Closures are a way to let a function\n  have \u0026lt;strong\u0026gt;persistent, private variables\u0026lt;/strong\u0026gt; -\n  that is, variables that only one\n  function knows about, where it can\n  keep track of info from previous times\n  that it was run.\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;p\u0026gt;In that sense, they let a function act a bit like an object with private attributes.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Full post:\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;a href=\u0026quot;http://sleeplessgeek.blogspot.com/2009/12/so-what-are-these-closure-thingys.html\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;So what are these closure thingys?\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;The original question had a quote:\u0026lt;/p\u0026gt;\n\u0026lt;blockquote\u0026gt;\n\u0026lt;p\u0026gt;If you can\u0026apos;t explain it to a six-year old, you really don\u0026apos;t understand it yourself.\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\u0026lt;p\u0026gt;This is how I\u0026apos;d try to explain it to an actual six-year-old:\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;You know how grown-ups can own a house, and they call it home? When a mom has a child, the child doesn\u0026apos;t really own anything, right? But its parents own a house, so whenever someone asks the child \u0026quot;Where\u0026apos;s your home?\u0026quot;, he/she can answer \u0026quot;that house!\u0026quot;, and point to the house of its parents. A \u0026quot;Closure\u0026quot; is the ability of the child to always (even if abroad) be able to say it has a home, even though it\u0026apos;s really the parent\u0026apos;s who own the house.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;h2\u0026gt;\u0026lt;strong\u0026gt;Closures are simple:\u0026lt;/strong\u0026gt;\u0026lt;/h2\u0026gt;\n\n\u0026lt;p\u0026gt;The following simple example covers all the main points of JavaScript closures.\u0026lt;sup\u0026gt;*\u0026lt;/sup\u0026gt;\n\u0026amp;nbsp;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Here is a factory that produces calculators that can add and multiply:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;make_calculator\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;) {\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; n = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// this calculator stores a single number n\u0026lt;/span\u0026gt;\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; {\n    \u0026lt;span class=\u0026quot;hljs-attr\u0026quot;\u0026gt;add\u0026lt;/span\u0026gt;: \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;a\u0026lt;/span\u0026gt;) {\n      n += a;\n      \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; n;\n    },\n    \u0026lt;span class=\u0026quot;hljs-attr\u0026quot;\u0026gt;multiply\u0026lt;/span\u0026gt;: \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;a\u0026lt;/span\u0026gt;) {\n      n *= a;\n      \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; n;\n    }\n  };\n}\n\nfirst_calculator = \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;make_calculator\u0026lt;/span\u0026gt;();\nsecond_calculator = \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;make_calculator\u0026lt;/span\u0026gt;();\n\nfirst_calculator.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;add\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3\u0026lt;/span\u0026gt;); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// returns 3\u0026lt;/span\u0026gt;\nsecond_calculator.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;add\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;400\u0026lt;/span\u0026gt;); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// returns 400\u0026lt;/span\u0026gt;\n\nfirst_calculator.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;multiply\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;11\u0026lt;/span\u0026gt;); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// returns 33\u0026lt;/span\u0026gt;\nsecond_calculator.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;multiply\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;10\u0026lt;/span\u0026gt;); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// returns 4000\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;The key point:\u0026lt;/strong\u0026gt; Each call to \u0026lt;code\u0026gt;make_calculator\u0026lt;/code\u0026gt; creates a new local variable \u0026lt;code\u0026gt;n\u0026lt;/code\u0026gt;, which continues to be usable by that calculator\u0026apos;s \u0026lt;code\u0026gt;add\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;multiply\u0026lt;/code\u0026gt; functions long after \u0026lt;code\u0026gt;make_calculator\u0026lt;/code\u0026gt; returns.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;em\u0026gt;If you are familiar with stack frames, these calculators seem strange: How can they keep accessing \u0026lt;code\u0026gt;n\u0026lt;/code\u0026gt; after \u0026lt;code\u0026gt;make_calculator\u0026lt;/code\u0026gt; returns?  The answer is to imagine that JavaScript doesn\u0026apos;t use \u0026quot;stack frames\u0026quot;, but instead uses \u0026quot;heap frames\u0026quot;, which can persist after the function call that made them returns.\u0026lt;/em\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Inner functions like \u0026lt;code\u0026gt;add\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;multiply\u0026lt;/code\u0026gt;, which access variables declared in an outer function\u0026lt;sup\u0026gt;**\u0026lt;/sup\u0026gt;, are called \u0026lt;em\u0026gt;closures\u0026lt;/em\u0026gt;.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;That is pretty much all there is to closures.\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;br\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;hr\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;sup\u0026gt;\u0026lt;sup\u0026gt;*\u0026lt;/sup\u0026gt; For example, it covers all the points in the \u0026quot;Closures for Dummies\u0026quot; article given in \u0026lt;a href=\u0026quot;https://stackoverflow.com/a/111111/706054\u0026quot;\u0026gt;another answer\u0026lt;/a\u0026gt;, except example 6, which simply shows that variables can be used before they are declared, a nice fact to know but completely unrelated to closures. It also covers all the points in \u0026lt;a href=\u0026quot;https://stackoverflow.com/a/111200/706054\u0026quot;\u0026gt;the accepted answer\u0026lt;/a\u0026gt;, except for the points (1) that functions copy their arguments into local variables (the named function arguments), and (2) that copying numbers creates a new number, but copying an object reference gives you another reference to the same object. These are also good to know but again completely unrelated to closures. It is also very similar to the example in \u0026lt;a href=\u0026quot;https://stackoverflow.com/a/111114/706054\u0026quot;\u0026gt;this answer\u0026lt;/a\u0026gt; but a bit shorter and less abstract. It does not cover the point of \u0026lt;a href=\u0026quot;https://stackoverflow.com/a/17200991/706054\u0026quot;\u0026gt;this answer\u0026lt;/a\u0026gt; or \u0026lt;a href=\u0026quot;https://stackoverflow.com/questions/111102/how-do-javascript-closures-work/17308587?noredirect=1#comment26377355_111111\u0026quot;\u0026gt;this comment\u0026lt;/a\u0026gt;, which is that JavaScript makes it difficult to plug the \u0026lt;em\u0026gt;current\u0026lt;/em\u0026gt; value of a loop variable into your inner function: The \u0026quot;plugging in\u0026quot; step can only be done with a helper function that encloses your inner function and is invoked on each loop iteration. (Strictly speaking, the inner function accesses the helper function\u0026apos;s copy of the variable, rather than having anything plugged in.) Again, very useful when creating closures, but not part of what a closure is or how it works. There is additional confusion due to closures working differently in functional languages like ML, where variables are bound to values rather than to storage space, providing a constant stream of people who understand closures in a way (namely the \u0026quot;plugging in\u0026quot; way) that is simply incorrect for JavaScript, where variables are always bound to storage space, and never to values. \u0026lt;/sup\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;sup\u0026gt;\u0026lt;sup\u0026gt;**\u0026lt;/sup\u0026gt; Any outer function, if several are nested, or even in the global context, as \u0026lt;a href=\u0026quot;https://stackoverflow.com/a/5099447/706054\u0026quot;\u0026gt;this answer\u0026lt;/a\u0026gt; points out clearly.\u0026lt;/sup\u0026gt;\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;h2\u0026gt;\u0026lt;a href=\u0026quot;https://stackoverflow.com/questions/1700514/how-do-you-explain-closure-to-a-5-year-old/1700627#1700627\u0026quot;\u0026gt;Can you explain closures to a 5-year-old?*\u0026lt;/a\u0026gt;\u0026lt;/h2\u0026gt;\n\u0026lt;p\u0026gt;I still think \u0026lt;a href=\u0026quot;http://code.google.com/apis/ajax/playground/?exp=maps#closure_simple\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;Google\u0026apos;s explanation\u0026lt;/a\u0026gt; works very well and is concise:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;/*\n*    When a function is defined in another function and it\n*    has access to the outer function\u0026apos;s context even after\n*    the outer function returns.\n*\n* An important concept to learn in JavaScript.\n*/\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;outerFunction\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;someNum\u0026lt;/span\u0026gt;) {\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; someString = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;Hey!\u0026apos;\u0026lt;/span\u0026gt;;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; content = \u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;document\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;getElementById\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;content\u0026apos;\u0026lt;/span\u0026gt;);\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;innerFunction\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;) {\n        content.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;innerHTML\u0026lt;/span\u0026gt; = someNum + \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;: \u0026apos;\u0026lt;/span\u0026gt; + someString;\n        content = \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;null\u0026lt;/span\u0026gt;; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Internet Explorer memory leak for DOM reference\u0026lt;/span\u0026gt;\n    }\n    \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;innerFunction\u0026lt;/span\u0026gt;();\n}\n\n\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;outerFunction\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;);\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;img src=\u0026quot;https://i.stack.imgur.com/N0mn0.png\u0026quot; alt=\u0026quot;Proof that this example creates a closure even if the inner function doesn\u0026apos;t return\u0026quot;\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;sub\u0026gt;*A C# question\u0026lt;/sub\u0026gt;\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;I tend to learn better by GOOD/BAD comparisons. I like to see working code followed by non-working code that someone is likely to encounter. I put together \u0026lt;a href=\u0026quot;http://jsfiddle.net/KMQZK/\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;a jsFiddle\u0026lt;/a\u0026gt; that does a comparison and tries to boil down the differences to the simplest explanations I could come up with.\u0026lt;/p\u0026gt;\n\u0026lt;h2\u0026gt;Closures done right:\u0026lt;/h2\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;console\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;log\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;CLOSURES DONE RIGHT\u0026apos;\u0026lt;/span\u0026gt;);\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; arr = [];\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;createClosure\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;n\u0026lt;/span\u0026gt;) {\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt; (\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;) {\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;n = \u0026apos;\u0026lt;/span\u0026gt; + n;\n    }\n}\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt; (\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; index = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;; index \u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;10\u0026lt;/span\u0026gt;; index++) {\n    arr[index] = \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;createClosure\u0026lt;/span\u0026gt;(index);\n}\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt; (\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; index \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;in\u0026lt;/span\u0026gt; arr) {\n    \u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;console\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;log\u0026lt;/span\u0026gt;(arr[index]());\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;In the above code \u0026lt;code\u0026gt;createClosure(n)\u0026lt;/code\u0026gt; is invoked in every iteration of the loop. Note that I named the variable \u0026lt;code\u0026gt;n\u0026lt;/code\u0026gt; to highlight that it is a \u0026lt;strong\u0026gt;new\u0026lt;/strong\u0026gt; variable created in a new function scope and is not the same variable as \u0026lt;code\u0026gt;index\u0026lt;/code\u0026gt; which is bound to the outer scope.\u0026lt;/p\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;This creates a new scope and \u0026lt;code\u0026gt;n\u0026lt;/code\u0026gt; is bound to that scope; this means we have 10 separate scopes, one for each iteration.\u0026lt;/p\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;\u0026lt;code\u0026gt;createClosure(n)\u0026lt;/code\u0026gt; returns a function that returns the n within that scope.\u0026lt;/p\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;Within each scope \u0026lt;code\u0026gt;n\u0026lt;/code\u0026gt; is bound to whatever value it had when \u0026lt;code\u0026gt;createClosure(n)\u0026lt;/code\u0026gt; was invoked so the nested function that gets returned will always return the value of \u0026lt;code\u0026gt;n\u0026lt;/code\u0026gt; that it had when \u0026lt;code\u0026gt;createClosure(n)\u0026lt;/code\u0026gt; was invoked.\u0026lt;/p\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;h2\u0026gt;Closures done wrong:\u0026lt;/h2\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;console\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;log\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;CLOSURES DONE WRONG\u0026apos;\u0026lt;/span\u0026gt;);\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;createClosureArray\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;) {\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; badArr = [];\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt; (\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; index = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;; index \u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;10\u0026lt;/span\u0026gt;; index++) {\n        badArr[index] = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt; (\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;) {\n            \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;n = \u0026apos;\u0026lt;/span\u0026gt; + index;\n        };\n    }\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; badArr;\n}\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; badArr = \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;createClosureArray\u0026lt;/span\u0026gt;();\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt; (\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; index \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;in\u0026lt;/span\u0026gt; badArr) {\n    \u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;console\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;log\u0026lt;/span\u0026gt;(badArr[index]());\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;In the above code the loop was moved within the \u0026lt;code\u0026gt;createClosureArray()\u0026lt;/code\u0026gt; function and the function now just returns the completed array, which at first glance seems more intuitive.\u0026lt;/p\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;What might not be obvious is that since \u0026lt;code\u0026gt;createClosureArray()\u0026lt;/code\u0026gt; is only invoked once only one scope is created for this function instead of one for every iteration of the loop.\u0026lt;/p\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;Within this function a variable named \u0026lt;code\u0026gt;index\u0026lt;/code\u0026gt; is defined. The loop runs and adds functions to the array that return \u0026lt;code\u0026gt;index\u0026lt;/code\u0026gt;. Note that \u0026lt;code\u0026gt;index\u0026lt;/code\u0026gt; is defined within the \u0026lt;code\u0026gt;createClosureArray\u0026lt;/code\u0026gt; function which only ever gets invoked one time.\u0026lt;/p\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;Because there was only one scope within the \u0026lt;code\u0026gt;createClosureArray()\u0026lt;/code\u0026gt; function, \u0026lt;code\u0026gt;index\u0026lt;/code\u0026gt; is only bound to a value within that scope. In other words, each time the loop changes the value of \u0026lt;code\u0026gt;index\u0026lt;/code\u0026gt;, it changes it for everything that references it within that scope.\u0026lt;/p\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;All of the functions added to the array return the SAME \u0026lt;code\u0026gt;index\u0026lt;/code\u0026gt; variable from the parent scope where it was defined instead of 10 different ones from 10 different scopes like the first example. The end result is that all 10 functions return the same variable from the same scope.\u0026lt;/p\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;After the loop finished and \u0026lt;code\u0026gt;index\u0026lt;/code\u0026gt; was done being modified the end value was 10, therefore every function added to the array returns the value of the single \u0026lt;code\u0026gt;index\u0026lt;/code\u0026gt; variable which is now set to 10.\u0026lt;/p\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;h2\u0026gt;Result\u0026lt;/h2\u0026gt;\n\u0026lt;blockquote\u0026gt;\n\u0026lt;p\u0026gt;CLOSURES DONE RIGHT\u0026lt;br\u0026gt;\nn = 0\u0026lt;br\u0026gt;\nn = 1\u0026lt;br\u0026gt;\nn = 2\u0026lt;br\u0026gt;\nn = 3\u0026lt;br\u0026gt;\nn = 4\u0026lt;br\u0026gt;\nn = 5\u0026lt;br\u0026gt;\nn = 6\u0026lt;br\u0026gt;\nn = 7\u0026lt;br\u0026gt;\nn = 8\u0026lt;br\u0026gt;\nn = 9\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;CLOSURES DONE WRONG\u0026lt;br\u0026gt;\nn = 10\u0026lt;br\u0026gt;\nn = 10\u0026lt;br\u0026gt;\nn = 10\u0026lt;br\u0026gt;\nn = 10\u0026lt;br\u0026gt;\nn = 10\u0026lt;br\u0026gt;\nn = 10\u0026lt;br\u0026gt;\nn = 10\u0026lt;br\u0026gt;\nn = 10\u0026lt;br\u0026gt;\nn = 10\u0026lt;br\u0026gt;\nn = 10\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n    ","\n\u0026lt;p\u0026gt;\u0026lt;a href=\u0026quot;http://en.wikipedia.org/wiki/Closure_(computer_science)\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;Wikipedia on closures\u0026lt;/a\u0026gt;:\u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;In computer science, a closure is a function together with a referencing environment for the nonlocal names (free variables) of that function.\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;p\u0026gt;Technically, in \u0026lt;a href=\u0026quot;http://en.wikipedia.org/wiki/JavaScript\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;JavaScript\u0026lt;/a\u0026gt;, \u0026lt;strong\u0026gt;every function is a closure\u0026lt;/strong\u0026gt;. It always has an access to variables defined in the surrounding scope.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Since \u0026lt;strong\u0026gt;scope-defining construction in JavaScript is a function\u0026lt;/strong\u0026gt;, not a code block like in many other languages, \u0026lt;strong\u0026gt;what we usually mean by \u0026lt;em\u0026gt;closure\u0026lt;/em\u0026gt; in JavaScript\u0026lt;/strong\u0026gt; is a \u0026lt;strong\u0026gt;function working with nonlocal variables defined in already executed surrounding function\u0026lt;/strong\u0026gt;.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Closures are often used for creating functions with some hidden private data (but it\u0026apos;s not always the case).\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; db = (\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;) {\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Create a hidden object, which will hold the data\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// it\u0026apos;s inaccessible from the outside.\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; data = {};\n\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Make a function, which will provide some access to the data.\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;key, val\u0026lt;/span\u0026gt;) {\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (val === \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;undefined\u0026lt;/span\u0026gt;) { \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; data[key] } \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Get\u0026lt;/span\u0026gt;\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;else\u0026lt;/span\u0026gt; { \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; data[key] = val } \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Set\u0026lt;/span\u0026gt;\n    }\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// We are calling the anonymous surrounding function,\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// returning the above inner function, which is a closure.\u0026lt;/span\u0026gt;\n})();\n\n\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;db\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;x\u0026apos;\u0026lt;/span\u0026gt;)    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// -\u0026amp;gt; undefined\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;db\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;x\u0026apos;\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;) \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Set x to 1\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;db\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;x\u0026apos;\u0026lt;/span\u0026gt;)    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// -\u0026amp;gt; 1\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// It\u0026apos;s impossible to access the data object itself.\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// We are able to get or set individual it.\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;ems\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;The example above is using an anonymous function, which was executed once. But it does not have to be. It can be named (e.g. \u0026lt;code\u0026gt;mkdb\u0026lt;/code\u0026gt;) and executed later, generating a database function each time it is invoked. Every generated function will have its own hidden database object. Another usage example of closures is when we don\u0026apos;t return a function, but an object containing multiple functions for different purposes, each of those function having access to the same data.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;I put together an interactive JavaScript tutorial to explain how closures work.\n\u0026lt;a href=\u0026quot;http://nathansjslessons.appspot.com\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;What\u0026apos;s a Closure?\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Here\u0026apos;s one of the examples:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; create = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt; (\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;x\u0026lt;/span\u0026gt;) {\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; f = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt; (\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;) {\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; x; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// We can refer to x here!\u0026lt;/span\u0026gt;\n    };\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; f;\n};\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// \u0026apos;create\u0026apos; takes one argument, creates a function\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; g = \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;create\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;42\u0026lt;/span\u0026gt;);\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// g is a function that takes no arguments now\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; y = \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;g\u0026lt;/span\u0026gt;();\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// y is 42 here\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;The children will always remember the secrets they have shared with their parents, even after their parents are\n  gone. This is what closures are for functions.\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;p\u0026gt;The secrets for JavaScript functions are the private variables\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; parent = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;) {\n \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; name = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Mary\u0026quot;\u0026lt;/span\u0026gt;; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// secret\u0026lt;/span\u0026gt;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Every time you call it, local variable \u0026quot;name\u0026quot; is created and given name \u0026quot;Mary\u0026quot;. And every time the function exits the variable is lost and the name is forgotten.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;As you may guess, because the variables are re-created every time the function is called, and nobody else will know them, there must be a secret place where they are stored. It could be called \u0026lt;strong\u0026gt;Chamber of Secrets\u0026lt;/strong\u0026gt; or \u0026lt;strong\u0026gt;stack\u0026lt;/strong\u0026gt; or \u0026lt;strong\u0026gt;local scope\u0026lt;/strong\u0026gt; but it doesn\u0026apos;t really matter. We know they are there, somewhere, hidden in the memory.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;But, in JavaScript there is this very special thing that functions which are created inside other functions, can also know the local variables of their parents and keep them as long as they live.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; parent = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;) {\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; name = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Mary\u0026quot;\u0026lt;/span\u0026gt;;\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; child = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;childName\u0026lt;/span\u0026gt;) {\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// I can also see that \u0026quot;name\u0026quot; is \u0026quot;Mary\u0026quot;\u0026lt;/span\u0026gt;\n  }\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;So, as long as we are in the parent -function, it can create one or more child functions which do share the secret variables from the secret place.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;But the sad thing is, if the child is also a private variable of its parent function, it would also die when the parent ends, and the secrets would die with them.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;So to live, the child has to leave before it\u0026apos;s too late\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; parent = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;) {\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; name = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Mary\u0026quot;\u0026lt;/span\u0026gt;;\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; child = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;childName\u0026lt;/span\u0026gt;) {\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;My name is \u0026quot;\u0026lt;/span\u0026gt; + childName  +\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;, child of \u0026quot;\u0026lt;/span\u0026gt; + name; \n  }\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; child; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// child leaves the parent -\u0026amp;gt;\u0026lt;/span\u0026gt;\n}\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; child = \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;parent\u0026lt;/span\u0026gt;(); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// \u0026amp;lt; - and here it is outside \u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;And now, even though Mary is \u0026quot;no longer running\u0026quot;, the memory of her is not lost and her child will always remember her name and other secrets they shared during their time together.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;So, if you call the child \u0026quot;Alice\u0026quot;, she will respond\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;child\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Alice\u0026quot;\u0026lt;/span\u0026gt;) =\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;My name is Alice, child of Mary\u0026quot;\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;That\u0026apos;s all there is to tell.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;I do not understand why the answers are so complex here.\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Here is a closure:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; a = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;42\u0026lt;/span\u0026gt;;\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;b\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;) { \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; a; }\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;Yes. You probably use that many times a day.\u0026lt;/p\u0026gt;\n\u0026lt;br\u0026gt;\n\u0026lt;blockquote\u0026gt;\n\u0026lt;p\u0026gt;There is no reason to believe closures are a complex design hack to address specific problems. No, closures are just about using a variable that comes from a higher scope \u0026lt;strong\u0026gt;from the perspective of where the function was declared (not run)\u0026lt;/strong\u0026gt;.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Now what it \u0026lt;em\u0026gt;allows\u0026lt;/em\u0026gt; you to do can be more spectacular, see other answers.\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Example for the first point by dlaliberte:\u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;A closure is not only created when you return an inner function. In fact, the enclosing function does not need to return at all. You might instead assign your inner function to a variable in an outer scope, or pass it as an argument to another function where it could be used immediately. Therefore, the closure of the enclosing function probably already exists at the time that enclosing function was called since any inner function has access to it as soon as it is called.\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; i;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;foo\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;x\u0026lt;/span\u0026gt;) {\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; tmp = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3\u0026lt;/span\u0026gt;;\n    i = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt; (\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;y\u0026lt;/span\u0026gt;) {\n        \u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;console\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;log\u0026lt;/span\u0026gt;(x + y + (++tmp));\n    }\n}\n\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;foo\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;);\n\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;i\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3\u0026lt;/span\u0026gt;);\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;A closure is where an inner function has access to variables in its outer function. That\u0026apos;s probably the simplest one-line explanation you can get for closures.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;I know there are plenty of solutions already, but I guess that this small and simple script can be useful to demonstrate the concept:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// makeSequencer will return a \u0026quot;sequencer\u0026quot; function\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; makeSequencer = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;) {\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; _count = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// not accessible outside this function\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; sequencer = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt; (\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;) {\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; _count++;\n    }\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; sequencer;\n}\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; fnext = \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;makeSequencer\u0026lt;/span\u0026gt;();\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; v0 = \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;fnext\u0026lt;/span\u0026gt;();     \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// v0 = 0;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; v1 = \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;fnext\u0026lt;/span\u0026gt;();     \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// v1 = 1;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; vz = fnext.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;_count\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// vz = undefined\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;You\u0026apos;re having a sleep over and you invite Dan.\nYou tell Dan to bring one XBox controller.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Dan invites Paul.\nDan asks Paul to bring one controller. How many controllers were brought to the party?\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;sleepOver\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;howManyControllersToBring\u0026lt;/span\u0026gt;) {\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; numberOfDansControllers = howManyControllersToBring;\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;danInvitedPaul\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;numberOfPaulsControllers\u0026lt;/span\u0026gt;) {\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; totalControllers = numberOfDansControllers + numberOfPaulsControllers;\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; totalControllers;\n    }\n}\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; howManyControllersToBring = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;;\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; inviteDan = \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;sleepOver\u0026lt;/span\u0026gt;(howManyControllersToBring);\n\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// The only reason Paul was invited is because Dan was invited. \u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// So we set Paul\u0026apos;s invitation = Dan\u0026apos;s invitation.\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; danInvitedPaul = \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;inviteDan\u0026lt;/span\u0026gt;(howManyControllersToBring);\n\n\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;alert\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;There were \u0026quot;\u0026lt;/span\u0026gt; + danInvitedPaul + \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot; controllers brought to the party.\u0026quot;\u0026lt;/span\u0026gt;);\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;The author of \u0026lt;em\u0026gt;\u0026lt;a href=\u0026quot;http://javascript.info/tutorial/closures\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;Closures\u0026lt;/a\u0026gt;\u0026lt;/em\u0026gt; has explained closures pretty well, explaining the reason why we need them and also explaining LexicalEnvironment which is necessary to understanding closures. \u0026lt;br\u0026gt;\nHere is the summary:\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;What if a variable is accessed, but it isnt local? Like here:\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;a href=\u0026quot;https://i.stack.imgur.com/SLlVB.png\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;\u0026lt;img src=\u0026quot;https://i.stack.imgur.com/SLlVB.png\u0026quot; alt=\u0026quot;Enter image description here\u0026quot;\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;In this case, the interpreter finds the variable in the\nouter \u0026lt;a href=\u0026quot;http://javascript.info/tutorial/initialization\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;\u0026lt;code\u0026gt;LexicalEnvironment\u0026lt;/code\u0026gt;\u0026lt;/a\u0026gt; object.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;The process consists of two steps:\u0026lt;/p\u0026gt;\n\n\u0026lt;ol\u0026gt;\n\u0026lt;li\u0026gt;First, when a function f is created, it is not created in an empty\nspace. There is a current LexicalEnvironment object. In the case\nabove, its window (a is undefined at the time of function\ncreation).\u0026lt;/li\u0026gt;\n\u0026lt;/ol\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;a href=\u0026quot;https://i.stack.imgur.com/0KBin.png\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;\u0026lt;img src=\u0026quot;https://i.stack.imgur.com/0KBin.png\u0026quot; alt=\u0026quot;Enter image description here\u0026quot;\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;When a function is created, it gets a hidden property, named [[Scope]], which references the current LexicalEnvironment.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;a href=\u0026quot;https://i.stack.imgur.com/U3yt7.png\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;\u0026lt;img src=\u0026quot;https://i.stack.imgur.com/U3yt7.png\u0026quot; alt=\u0026quot;Enter image description here\u0026quot;\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;If a variable is read, but can not be found anywhere, an error is generated.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Nested functions\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Functions can be nested one inside another, forming a chain of LexicalEnvironments which can also be called a scope chain.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;a href=\u0026quot;https://i.stack.imgur.com/2hUwr.png\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;\u0026lt;img src=\u0026quot;https://i.stack.imgur.com/2hUwr.png\u0026quot; alt=\u0026quot;Enter image description here\u0026quot;\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;So, function g has access to g, a and f.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Closures\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;A nested function may continue to live after the outer function has finished:\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;a href=\u0026quot;https://i.stack.imgur.com/S1mlB.png\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;\u0026lt;img src=\u0026quot;https://i.stack.imgur.com/S1mlB.png\u0026quot; alt=\u0026quot;Enter image description here\u0026quot;\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Marking up LexicalEnvironments:\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;a href=\u0026quot;https://i.stack.imgur.com/BzUNi.png\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;\u0026lt;img src=\u0026quot;https://i.stack.imgur.com/BzUNi.png\u0026quot; alt=\u0026quot;Enter image description here\u0026quot;\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;As we see, \u0026lt;code\u0026gt;this.say\u0026lt;/code\u0026gt; is a property in the user object, so it continues to live after User completed.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;And if you remember, when \u0026lt;code\u0026gt;this.say\u0026lt;/code\u0026gt; is created, it (as every function) gets an internal reference \u0026lt;code\u0026gt;this.say.[[Scope]]\u0026lt;/code\u0026gt; to the current LexicalEnvironment. So, the LexicalEnvironment of the current User execution stays in memory. All variables of User also are its properties, so they are also carefully kept, not junked as usually.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;The whole point is to ensure that if the inner function wants to access an outer variable in the future, it is able to do so.\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;To summarize:\u0026lt;/p\u0026gt;\n\n\u0026lt;ol\u0026gt;\n\u0026lt;li\u0026gt;The inner function keeps a reference to the outer\nLexicalEnvironment.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;The inner function may access variables from it\nany time even if the outer function is finished.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;The browser keeps the LexicalEnvironment and all its properties (variables) in memory until there is an inner function which references it.\u0026lt;/li\u0026gt;\n\u0026lt;/ol\u0026gt;\n\n\u0026lt;p\u0026gt;This is called a closure.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;JavaScript functions can access their:\u0026lt;/p\u0026gt;\n\n\u0026lt;ol\u0026gt;\n\u0026lt;li\u0026gt;Arguments\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Locals (that is, their local variables and local functions)\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Environment, which includes:\n\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;globals, including the DOM\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;anything in outer functions\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;/ol\u0026gt;\n\n\u0026lt;p\u0026gt;If a function accesses its environment, then the function is a closure.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Note that outer functions are not required, though they do offer benefits I don\u0026apos;t discuss here. By accessing data in its environment, a closure keeps that data alive. In the subcase of outer/inner functions, an outer function can create local data and eventually exit, and yet, if any inner function(s) survive after the outer function exits, then the inner function(s) keep the outer function\u0026apos;s local data alive.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Example of a closure that uses the global environment:\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Imagine that the Stack Overflow Vote-Up and Vote-Down button events are implemented as closures, voteUp_click and voteDown_click, that have access to external variables isVotedUp and isVotedDown, which are defined globally. (For simplicity\u0026apos;s sake, I am referring to StackOverflow\u0026apos;s Question Vote buttons, not the array of Answer Vote buttons.)\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;When the user clicks the VoteUp button, the voteUp_click function checks whether isVotedDown == true to determine whether to vote up or merely cancel a down vote. Function voteUp_click is a closure because it is accessing its environment.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; isVotedUp = \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;false\u0026lt;/span\u0026gt;;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; isVotedDown = \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;false\u0026lt;/span\u0026gt;;\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;voteUp_click\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;) {\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (isVotedUp)\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt;;\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;else\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (isVotedDown)\n    \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;SetDownVote\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;false\u0026lt;/span\u0026gt;);\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;else\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;SetUpVote\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;true\u0026lt;/span\u0026gt;);\n}\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;voteDown_click\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;) {\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (isVotedDown)\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt;;\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;else\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (isVotedUp)\n    \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;SetUpVote\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;false\u0026lt;/span\u0026gt;);\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;else\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;SetDownVote\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;true\u0026lt;/span\u0026gt;);\n}\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;SetUpVote\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;status\u0026lt;/span\u0026gt;) {\n  isVotedUp = status;\n  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Do some CSS stuff to Vote-Up button\u0026lt;/span\u0026gt;\n}\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;SetDownVote\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;status\u0026lt;/span\u0026gt;) {\n  isVotedDown = status;\n  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Do some CSS stuff to Vote-Down button\u0026lt;/span\u0026gt;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;All four of these functions are closures as they all access their environment.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;As a father of a 6-year-old, currently teaching young children (and a relative novice to coding with no formal education so corrections will be required), I think the lesson would stick best through hands-on play. If the 6-year-old is ready to understand what a closure is, then they are old enough to have a go themselves. I\u0026apos;d suggest pasting the code into jsfiddle.net, explaining a bit, and leaving them alone to concoct a unique song. The explanatory text below is probably more appropriate for a 10 year old.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;sing\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;person\u0026lt;/span\u0026gt;) {\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; firstPart = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;There was \u0026quot;\u0026lt;/span\u0026gt; + person + \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot; who swallowed \u0026quot;\u0026lt;/span\u0026gt;;\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; fly = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;) {\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; creature = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;a fly\u0026quot;\u0026lt;/span\u0026gt;;\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; result = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Perhaps she\u0026apos;ll die\u0026quot;\u0026lt;/span\u0026gt;;\n        \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;alert\u0026lt;/span\u0026gt;(firstPart + creature + \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;\\n\u0026quot;\u0026lt;/span\u0026gt; + result);\n    };\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; spider = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;) {\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; creature = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;a spider\u0026quot;\u0026lt;/span\u0026gt;;\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; result = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;that wiggled and jiggled and tickled inside her\u0026quot;\u0026lt;/span\u0026gt;;\n        \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;alert\u0026lt;/span\u0026gt;(firstPart + creature + \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;\\n\u0026quot;\u0026lt;/span\u0026gt; + result);\n    };\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; bird = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;) {\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; creature = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;a bird\u0026quot;\u0026lt;/span\u0026gt;;\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; result = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;How absurd!\u0026quot;\u0026lt;/span\u0026gt;;\n        \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;alert\u0026lt;/span\u0026gt;(firstPart + creature + \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;\\n\u0026quot;\u0026lt;/span\u0026gt; + result);\n    };\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; cat = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;) {\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; creature = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;a cat\u0026quot;\u0026lt;/span\u0026gt;;\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; result = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Imagine That!\u0026quot;\u0026lt;/span\u0026gt;;\n        \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;alert\u0026lt;/span\u0026gt;(firstPart + creature + \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;\\n\u0026quot;\u0026lt;/span\u0026gt; + result);\n    };\n\n    \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;fly\u0026lt;/span\u0026gt;();\n    \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;spider\u0026lt;/span\u0026gt;();\n    \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;bird\u0026lt;/span\u0026gt;();\n    \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;cat\u0026lt;/span\u0026gt;();\n}\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; person=\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;an old lady\u0026quot;\u0026lt;/span\u0026gt;;\n\n\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;sing\u0026lt;/span\u0026gt;(person);\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;INSTRUCTIONS\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;DATA: Data is a collection of facts. It can be numbers, words, measurements, observations or even just descriptions of things. You can\u0026apos;t touch it, smell it or taste it. You can write it down, speak it and hear it. You could use it to \u0026lt;em\u0026gt;create\u0026lt;/em\u0026gt; touch smell and taste using a computer. It can be made useful by a computer using code.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;CODE: All the writing above is called \u0026lt;em\u0026gt;code\u0026lt;/em\u0026gt;. It is written in JavaScript.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;JAVASCRIPT: JavaScript is a language. Like English or French or Chinese are languages. There are lots of languages that are understood by computers and other electronic processors. For JavaScript to be understood by a computer it needs an interpreter. Imagine if a teacher who only speaks Russian comes to teach your class at school. When the teacher says \u0026quot;все садятся\u0026quot;, the class would not understand. But luckily you have a Russian pupil in your class who tells everyone this means \u0026quot;everybody sit down\u0026quot; - so you all do. The class is like a computer and the Russian pupil is the interpreter. For JavaScript the most common interpreter is called a browser.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;BROWSER: When you connect to the Internet on a computer, tablet or phone to visit a website, you use a browser. Examples you may know are Internet Explorer, Chrome, Firefox and Safari. The browser can understand JavaScript and tell the computer what it needs to do. The JavaScript instructions are called functions.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;FUNCTION: A function in JavaScript is like a factory. It might be a little factory with only one machine inside. Or it might contain many other little factories, each with many machines doing different jobs. In a real life clothes factory you might have reams of cloth and bobbins of thread going in and T-shirts and jeans coming out. Our JavaScript factory only processes data, it can\u0026apos;t sew, drill a hole or melt metal. In our JavaScript factory data goes in and data comes out.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;All this data stuff sounds a bit boring, but it is really very cool; we might have a function that tells a robot what to make for dinner. Let\u0026apos;s say I invite you and your friend to my house. You like chicken legs best, I like sausages, your friend always wants what you want and my friend does not eat meat.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;I haven\u0026apos;t got time to go shopping, so the function needs to know what we have in the fridge to make decisions. Each ingredient has a different cooking time and we want everything to be served hot by the robot at the same time. We need to provide the function with the data about what we like, the function could \u0026apos;talk\u0026apos; to the fridge, and the function could control the robot.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;A function normally has a name, parentheses and braces. Like this:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;cookMeal\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;) {  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;/*  STUFF INSIDE THE FUNCTION  */\u0026lt;/span\u0026gt;  }\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;em\u0026gt;Note that \u0026lt;code\u0026gt;/*...*/\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;//\u0026lt;/code\u0026gt; stop code being read by the browser.\u0026lt;/em\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;NAME: You can call a function just about whatever word you want. The example \u0026quot;cookMeal\u0026quot; is typical in joining two words together and giving the second one a capital letter at the beginning - but this is not necessary. It can\u0026apos;t have a space in it, and it can\u0026apos;t be a number on its own.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;PARENTHESES: \u0026quot;Parentheses\u0026quot; or \u0026lt;code\u0026gt;()\u0026lt;/code\u0026gt; are the letter box on the JavaScript function factory\u0026apos;s door or a post box in the street for sending packets of information to the factory. Sometimes the postbox might be marked \u0026lt;em\u0026gt;for example\u0026lt;/em\u0026gt; \u0026lt;code\u0026gt;cookMeal(you, me, yourFriend, myFriend, fridge, dinnerTime)\u0026lt;/code\u0026gt;, in which case you know what data you have to give it.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;BRACES: \u0026quot;Braces\u0026quot; which look like this \u0026lt;code\u0026gt;{}\u0026lt;/code\u0026gt; are the tinted windows of our factory. From inside the factory you can see out, but from the outside you can\u0026apos;t see in.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;THE LONG CODE EXAMPLE ABOVE\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Our code begins with the word \u0026lt;em\u0026gt;function\u0026lt;/em\u0026gt;, so we know that it is one! Then the name of the function \u0026lt;em\u0026gt;sing\u0026lt;/em\u0026gt; - that\u0026apos;s my own description of what the function is about. Then parentheses \u0026lt;em\u0026gt;()\u0026lt;/em\u0026gt;. The parentheses are always there for a function. Sometimes they are empty, and sometimes they have something in. This one has a word in: \u0026lt;code\u0026gt;(person)\u0026lt;/code\u0026gt;. After this there is a brace like this \u0026lt;code\u0026gt;{\u0026lt;/code\u0026gt; . This marks the start of the function \u0026lt;em\u0026gt;sing()\u0026lt;/em\u0026gt;. It has a partner which marks the end of \u0026lt;em\u0026gt;sing()\u0026lt;/em\u0026gt; like this \u0026lt;code\u0026gt;}\u0026lt;/code\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;sing\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;person\u0026lt;/span\u0026gt;) {  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;/* STUFF INSIDE THE FUNCTION */\u0026lt;/span\u0026gt;  }\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;So this function might have something to do with singing, and might need some data about a person. It has instructions inside to do something with that data.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Now, after the function \u0026lt;em\u0026gt;sing()\u0026lt;/em\u0026gt;, near the end of the code is the line\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; person=\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;an old lady\u0026quot;\u0026lt;/span\u0026gt;;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;VARIABLE: The letters \u0026lt;em\u0026gt;var\u0026lt;/em\u0026gt; stand for \u0026quot;variable\u0026quot;. A variable is like an envelope. On the outside this envelope is marked \u0026quot;person\u0026quot;. On the inside it contains a slip of paper with the information our function needs, some letters and spaces joined together like a piece of string (it\u0026apos;s called a string) that make a phrase reading \u0026quot;an old lady\u0026quot;. Our envelope could contain other kinds of things like numbers (called integers), instructions (called functions), lists (called \u0026lt;em\u0026gt;arrays\u0026lt;/em\u0026gt;). Because this variable is written outside of all the braces \u0026lt;code\u0026gt;{}\u0026lt;/code\u0026gt;, and because you can see out through the tinted windows when you are inside the braces, this variable can be seen from anywhere in the code. We call this a \u0026apos;global variable\u0026apos;.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;GLOBAL VARIABLE: \u0026lt;em\u0026gt;person\u0026lt;/em\u0026gt; is a global variable, meaning that if you change its value from \u0026quot;an old lady\u0026quot; to \u0026quot;a young man\u0026quot;, the \u0026lt;em\u0026gt;person\u0026lt;/em\u0026gt; will keep being a young man until you decide to change it again and that any other function in the code can see that it\u0026apos;s a young man. Press the \u0026lt;kbd\u0026gt;F12\u0026lt;/kbd\u0026gt; button or look at the Options settings to open the developer console of a browser and type \u0026quot;person\u0026quot; to see what this value is. Type \u0026lt;code\u0026gt;person=\u0026quot;a young man\u0026quot;\u0026lt;/code\u0026gt; to change it and then type \u0026quot;person\u0026quot; again to see that it has changed.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;After this we have the line\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;sing\u0026lt;/span\u0026gt;(person);\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;This line is calling the function, as if it were calling a dog\u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;\u0026quot;Come on \u0026lt;em\u0026gt;sing\u0026lt;/em\u0026gt;, Come and get \u0026lt;em\u0026gt;person\u0026lt;/em\u0026gt;!\u0026quot;\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;p\u0026gt;When the browser has loaded the JavaScript code an reached this line, it will start the function. I put the line at the end to make sure that the browser has all the information it needs to run it.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Functions define actions  - the main function is about singing. It contains a variable called \u0026lt;em\u0026gt;firstPart\u0026lt;/em\u0026gt; which applies to the singing about the person that applies to each of the verses of the song: \u0026quot;There was \u0026quot; + person + \u0026quot; who swallowed\u0026quot;. If you type \u0026lt;em\u0026gt;firstPart\u0026lt;/em\u0026gt; into the console, you won\u0026apos;t get an answer because the variable is locked up in a function - the browser can\u0026apos;t see inside the tinted windows of the braces.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;CLOSURES: The closures are the smaller functions that are inside the big \u0026lt;em\u0026gt;sing()\u0026lt;/em\u0026gt; function. The little factories inside the big factory. They each have their own braces which mean that the variables inside them can\u0026apos;t be seen from the outside. That\u0026apos;s why the names of the variables (\u0026lt;em\u0026gt;creature\u0026lt;/em\u0026gt; and \u0026lt;em\u0026gt;result\u0026lt;/em\u0026gt;) can be repeated in the closures but with different values. If you type these variable names in the console window, you won\u0026apos;t get its value because it\u0026apos;s hidden by two layers of tinted windows.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;The closures all know what the \u0026lt;em\u0026gt;sing()\u0026lt;/em\u0026gt; function\u0026apos;s variable called \u0026lt;em\u0026gt;firstPart\u0026lt;/em\u0026gt; is, because they can see out from their tinted windows.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;After the closures come the lines\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;fly\u0026lt;/span\u0026gt;();\n\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;spider\u0026lt;/span\u0026gt;();\n\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;bird\u0026lt;/span\u0026gt;();\n\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;cat\u0026lt;/span\u0026gt;();\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;The sing() function will call each of these functions in the order they are given. Then the sing() function\u0026apos;s work will be done.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Okay, talking with a 6-year old child, I would possibly use following associations.\u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;Imagine - you are playing with your little brothers and sisters in the entire house, and you are moving around with your toys and brought some of them into your older brother\u0026apos;s room. After a while your brother returned from the school and went to his room, and he locked inside it, so now you could not access toys left there anymore in a direct way. But you could knock the door and ask your brother for that toys. This is called toy\u0026apos;s \u0026lt;em\u0026gt;closure\u0026lt;/em\u0026gt;; your brother made it up for you, and he is now into outer \u0026lt;em\u0026gt;scope\u0026lt;/em\u0026gt;.\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;p\u0026gt;Compare with a situation when a door was locked by draft and nobody inside (general function execution), and then some local fire occur and burn down the room (garbage collector:D), and then a new room was build and now you may leave another toys there (new function instance), but never get the same toys which were left in the first room instance.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;For an advanced child I would put something like the following. It is not perfect, but it makes you feel about what it is:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;playingInBrothersRoom\u0026lt;/span\u0026gt; (withToys) {\n  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// We closure toys which we played in the brother\u0026apos;s room. When he come back and lock the door\u0026lt;/span\u0026gt;\n  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// your brother is supposed to be into the outer [[scope]] object now. Thanks god you could communicate with him.\u0026lt;/span\u0026gt;\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; closureToys = withToys || [],\n      returnToy, countIt, toy; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Just another closure helpers, for brother\u0026apos;s inner use.\u0026lt;/span\u0026gt;\n\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; brotherGivesToyBack = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt; (\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;toy\u0026lt;/span\u0026gt;) {\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// New request. There is not yet closureToys on brother\u0026apos;s hand yet. Give him a time.\u0026lt;/span\u0026gt;\n    returnToy = \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;null\u0026lt;/span\u0026gt;;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (toy \u0026amp;amp;\u0026amp;amp; closureToys.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;length\u0026lt;/span\u0026gt; \u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;) { \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// If we ask for a specific toy, the brother is going to search for it.\u0026lt;/span\u0026gt;\n\n      \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt; ( countIt = closureToys.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;length\u0026lt;/span\u0026gt;; countIt; countIt--) {\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (closureToys[countIt - \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;] == toy) {\n          returnToy = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;Take your \u0026apos;\u0026lt;/span\u0026gt; + closureToys.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;splice\u0026lt;/span\u0026gt;(countIt - \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;) + \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;, little boy!\u0026apos;\u0026lt;/span\u0026gt;;\n          \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;break\u0026lt;/span\u0026gt;;\n        }\n      }\n      returnToy = returnToy || \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;Hey, I could not find any \u0026apos;\u0026lt;/span\u0026gt; + toy + \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos; here. Look for it in another room.\u0026apos;\u0026lt;/span\u0026gt;;\n    }\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;else\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (closureToys.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;length\u0026lt;/span\u0026gt; \u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;) { \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Otherwise, just give back everything he has in the room.\u0026lt;/span\u0026gt;\n      returnToy = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;Behold! \u0026apos;\u0026lt;/span\u0026gt; + closureToys.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;join\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;, \u0026apos;\u0026lt;/span\u0026gt;) + \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;.\u0026apos;\u0026lt;/span\u0026gt;;\n      closureToys = [];\n    }\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;else\u0026lt;/span\u0026gt; {\n      returnToy = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;Hey, lil shrimp, I gave you everything!\u0026apos;\u0026lt;/span\u0026gt;;\n    }\n    \u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;console\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;log\u0026lt;/span\u0026gt;(returnToy);\n  }\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; brotherGivesToyBack;\n}\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// You are playing in the house, including the brother\u0026apos;s room.\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; toys = [\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;teddybear\u0026apos;\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;car\u0026apos;\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;jumpingrope\u0026apos;\u0026lt;/span\u0026gt;],\n    askBrotherForClosuredToy = \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;playingInBrothersRoom\u0026lt;/span\u0026gt;(toys);\n\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// The door is locked, and the brother came from the school. You could not cheat and take it out directly.\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;console\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;log\u0026lt;/span\u0026gt;(askBrotherForClosuredToy.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;closureToys\u0026lt;/span\u0026gt;); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Undefined\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// But you could ask your brother politely, to give it back.\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;askBrotherForClosuredToy\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;teddybear\u0026apos;\u0026lt;/span\u0026gt;); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Hooray, here it is, teddybear\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;askBrotherForClosuredToy\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;ball\u0026apos;\u0026lt;/span\u0026gt;); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// The brother would not be able to find it.\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;askBrotherForClosuredToy\u0026lt;/span\u0026gt;(); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// The brother gives you all the rest\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;askBrotherForClosuredToy\u0026lt;/span\u0026gt;(); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Nothing left in there\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;As you can see, the toys left in the room are still accessible via the brother and no matter if the room is locked. Here is \u0026lt;a href=\u0026quot;http://jsbin.com/ubakor/9/edit\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;a jsbin\u0026lt;/a\u0026gt; to play around with it.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;A function in JavaScript is not just a reference to a set of instructions (as in C language), but it also includes a hidden data structure which is composed of references to all nonlocal variables it uses (captured variables). Such two-piece functions are called closures. Every function in JavaScript can be considered a closure.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Closures are functions with a state. It is somewhat similar to \u0026quot;this\u0026quot; in the sense that \u0026quot;this\u0026quot; also provides state for a function but function and \u0026quot;this\u0026quot; are separate objects (\u0026quot;this\u0026quot; is just a fancy parameter, and the only way to bind it permanently to a function is to create a closure). While \u0026quot;this\u0026quot; and function always live separately, a function cannot be separated from its closure and the language provides no means to access captured variables.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Because all these external variables referenced by a lexically nested function are actually local variables in the chain of its lexically enclosing functions (global variables can be assumed to be local variables of some root function), and every single execution of a function creates new instances of its local variables, it follows that every execution of a function returning (or otherwise transferring it out, such as registering it as a callback) a nested function creates a new closure (with its own potentially unique set of referenced nonlocal variables which represent its execution context).\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Also, it must be understood that local variables in JavaScript are created not on the stack frame, but on the heap and destroyed only when no one is referencing them. When a function returns, references to its local variables are decremented, but they can still be non-null if during the current execution they became part of a closure and are still referenced by its lexically nested functions (which can happen only if the references to these nested functions were returned or otherwise transferred to some external code).\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;An example:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;foo\u0026lt;/span\u0026gt; (initValue) {\n   \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//This variable is not destroyed when the foo function exits.\u0026lt;/span\u0026gt;\n   \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//It is \u0026apos;captured\u0026apos; by the two nested functions returned below.\u0026lt;/span\u0026gt;\n   \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; value = initValue;\n\n   \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//Note that the two returned functions are created right now.\u0026lt;/span\u0026gt;\n   \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//If the foo function is called again, it will return\u0026lt;/span\u0026gt;\n   \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//new functions referencing a different \u0026apos;value\u0026apos; variable.\u0026lt;/span\u0026gt;\n   \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; {\n       \u0026lt;span class=\u0026quot;hljs-attr\u0026quot;\u0026gt;getValue\u0026lt;/span\u0026gt;: \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt; (\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;) { \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; value; },\n       \u0026lt;span class=\u0026quot;hljs-attr\u0026quot;\u0026gt;setValue\u0026lt;/span\u0026gt;: \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt; (\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;newValue\u0026lt;/span\u0026gt;) { value = newValue; }\n   }\n}\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;bar\u0026lt;/span\u0026gt; () {\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//foo sets its local variable \u0026apos;value\u0026apos; to 5 and returns an object with\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//two functions still referencing that local variable\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; obj = \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;foo\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;5\u0026lt;/span\u0026gt;);\n\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//Extracting functions just to show that no \u0026apos;this\u0026apos; is involved here\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; getValue = obj.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;getValue\u0026lt;/span\u0026gt;;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; setValue = obj.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;setValue\u0026lt;/span\u0026gt;;\n\n    \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;alert\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;getValue\u0026lt;/span\u0026gt;()); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//Displays 5\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;setValue\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;10\u0026lt;/span\u0026gt;);\n    \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;alert\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;getValue\u0026lt;/span\u0026gt;()); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//Displays 10\u0026lt;/span\u0026gt;\n\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//At this point getValue and setValue functions are destroyed\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//(in reality they are destroyed at the next iteration of the garbage collector).\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//The local variable \u0026apos;value\u0026apos; in the foo is no longer referenced by\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//anything and is destroyed too.\u0026lt;/span\u0026gt;\n}\n\n\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;bar\u0026lt;/span\u0026gt;();\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;An answer for a six-year-old (assuming he knows what a function is and what a variable is, and what data is):\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Functions can return data. One kind of data you can return from a function is another function. When that new function gets returned, all the variables and arguments used in the function that created it don\u0026apos;t go away. Instead, that parent function \u0026quot;closes.\u0026quot; In other words, nothing can look inside of it and see the variables it used except for the function it returned. That new function has a special ability to look back inside the function that created it and see the data inside of it.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;the_closure\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;) {\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; x = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;4\u0026lt;/span\u0026gt;;\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt; (\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;) {\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; x; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Here, we look back inside the_closure for the value of x\u0026lt;/span\u0026gt;\n  }\n}\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; myFn = \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;the_closure\u0026lt;/span\u0026gt;();\n\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;myFn\u0026lt;/span\u0026gt;(); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//=\u0026amp;gt; 4\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Another really simple way to explain it is in terms of scope:\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Any time you create a smaller scope inside of a larger scope, the smaller scope will always be able to see what is in the larger scope.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Perhaps a little beyond all but the most precocious of six-year-olds, but a few examples that helped make the concept of closure in JavaScript click for me.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;A closure is a function that has access to another function\u0026apos;s scope (its variables and functions). The easiest way to create a closure is with a function within a function; the reason being that in JavaScript a function always has access to its containing functions scope.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;/p\u0026gt;\u0026lt;div class=\u0026quot;snippet\u0026quot; data-lang=\u0026quot;js\u0026quot; data-hide=\u0026quot;false\u0026quot;\u0026gt;\n\u0026lt;div class=\u0026quot;snippet-code\u0026quot;\u0026gt;\n\u0026lt;pre class=\u0026quot;snippet-code-js lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;outerFunction\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;) {\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; outerVar = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;monkey\u0026quot;\u0026lt;/span\u0026gt;;\n    \n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;innerFunction\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;) {\n        \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;alert\u0026lt;/span\u0026gt;(outerVar);\n    }\n    \n    \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;innerFunction\u0026lt;/span\u0026gt;();\n}\n\n\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;outerFunction\u0026lt;/span\u0026gt;();\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;div class=\u0026quot;snippet-result\u0026quot;\u0026gt;\u0026lt;div class=\u0026quot;snippet-ctas\u0026quot;\u0026gt;\u0026lt;button type=\u0026quot;button\u0026quot; class=\u0026quot;s-btn s-btn__primary\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;icon-play-white _hover\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;\u0026lt;span\u0026gt; Run code snippet\u0026lt;/span\u0026gt;\u0026lt;/button\u0026gt;\u0026lt;input class=\u0026quot;copySnippet s-btn s-btn__filled\u0026quot; type=\u0026quot;button\u0026quot; value=\u0026quot;Copy snippet to answer\u0026quot; style=\u0026quot;display: none;\u0026quot;\u0026gt;\u0026lt;button type=\u0026quot;button\u0026quot; class=\u0026quot;s-btn hideResults\u0026quot; style=\u0026quot;display: none;\u0026quot;\u0026gt;Hide results\u0026lt;/button\u0026gt;\u0026lt;div class=\u0026quot;popout-code\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;snippet-expand-link\u0026quot;\u0026gt;Expand snippet\u0026lt;/a\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;div class=\u0026quot;snippet-result-code\u0026quot; style=\u0026quot;display: none;\u0026quot;\u0026gt;\u0026lt;iframe name=\u0026quot;sif19\u0026quot; sandbox=\u0026quot;allow-forms allow-modals allow-scripts\u0026quot; class=\u0026quot;snippet-box-edit snippet-box-result\u0026quot; frameborder=\u0026quot;0\u0026quot;\u0026gt;\u0026lt;/iframe\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;/div\u0026gt;\n\u0026lt;/div\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;ALERT: monkey\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;In the above example, outerFunction is called which in turn calls innerFunction. Note how outerVar is available to innerFunction, evidenced by its correctly alerting the value of outerVar.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Now consider the following:\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;/p\u0026gt;\u0026lt;div class=\u0026quot;snippet\u0026quot; data-lang=\u0026quot;js\u0026quot; data-hide=\u0026quot;false\u0026quot;\u0026gt;\n\u0026lt;div class=\u0026quot;snippet-code\u0026quot;\u0026gt;\n\u0026lt;pre class=\u0026quot;snippet-code-js lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;outerFunction\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;) {\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; outerVar = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;monkey\u0026quot;\u0026lt;/span\u0026gt;;\n    \n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;innerFunction\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;) {\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; outerVar;\n    }\n    \n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; innerFunction;\n}\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; referenceToInnerFunction = \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;outerFunction\u0026lt;/span\u0026gt;();\n\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;alert\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;referenceToInnerFunction\u0026lt;/span\u0026gt;());\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;div class=\u0026quot;snippet-result\u0026quot;\u0026gt;\u0026lt;div class=\u0026quot;snippet-ctas\u0026quot;\u0026gt;\u0026lt;button type=\u0026quot;button\u0026quot; class=\u0026quot;s-btn s-btn__primary\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;icon-play-white _hover\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;\u0026lt;span\u0026gt; Run code snippet\u0026lt;/span\u0026gt;\u0026lt;/button\u0026gt;\u0026lt;input class=\u0026quot;copySnippet s-btn s-btn__filled\u0026quot; type=\u0026quot;button\u0026quot; value=\u0026quot;Copy snippet to answer\u0026quot; style=\u0026quot;display: none;\u0026quot;\u0026gt;\u0026lt;button type=\u0026quot;button\u0026quot; class=\u0026quot;s-btn hideResults\u0026quot; style=\u0026quot;display: none;\u0026quot;\u0026gt;Hide results\u0026lt;/button\u0026gt;\u0026lt;div class=\u0026quot;popout-code\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;snippet-expand-link\u0026quot;\u0026gt;Expand snippet\u0026lt;/a\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;div class=\u0026quot;snippet-result-code\u0026quot; style=\u0026quot;display: none;\u0026quot;\u0026gt;\u0026lt;iframe name=\u0026quot;sif20\u0026quot; sandbox=\u0026quot;allow-forms allow-modals allow-scripts\u0026quot; class=\u0026quot;snippet-box-edit snippet-box-result\u0026quot; frameborder=\u0026quot;0\u0026quot;\u0026gt;\u0026lt;/iframe\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;/div\u0026gt;\n\u0026lt;/div\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;ALERT: monkey\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;referenceToInnerFunction is set to outerFunction(), which simply returns a reference to innerFunction. When referenceToInnerFunction is called, it returns outerVar. Again, as above, this demonstrates that innerFunction has access to outerVar, a variable of outerFunction. Furthermore, it is interesting to note that it retains this access even after outerFunction has finished executing.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;And here is where things get really interesting. If we were to get rid of outerFunction, say set it to null, you might think that referenceToInnerFunction would loose its access to the value of outerVar. But this is not the case. \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;/p\u0026gt;\u0026lt;div class=\u0026quot;snippet\u0026quot; data-lang=\u0026quot;js\u0026quot; data-hide=\u0026quot;false\u0026quot;\u0026gt;\n\u0026lt;div class=\u0026quot;snippet-code\u0026quot;\u0026gt;\n\u0026lt;pre class=\u0026quot;snippet-code-js lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;outerFunction\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;) {\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; outerVar = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;monkey\u0026quot;\u0026lt;/span\u0026gt;;\n    \n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;innerFunction\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;) {\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; outerVar;\n    }\n    \n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; innerFunction;\n}\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; referenceToInnerFunction = \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;outerFunction\u0026lt;/span\u0026gt;();\n\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;alert\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;referenceToInnerFunction\u0026lt;/span\u0026gt;());\n\nouterFunction = \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;null\u0026lt;/span\u0026gt;;\n\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;alert\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;referenceToInnerFunction\u0026lt;/span\u0026gt;());\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;div class=\u0026quot;snippet-result\u0026quot;\u0026gt;\u0026lt;div class=\u0026quot;snippet-ctas\u0026quot;\u0026gt;\u0026lt;button type=\u0026quot;button\u0026quot; class=\u0026quot;s-btn s-btn__primary\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;icon-play-white _hover\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;\u0026lt;span\u0026gt; Run code snippet\u0026lt;/span\u0026gt;\u0026lt;/button\u0026gt;\u0026lt;input class=\u0026quot;copySnippet s-btn s-btn__filled\u0026quot; type=\u0026quot;button\u0026quot; value=\u0026quot;Copy snippet to answer\u0026quot; style=\u0026quot;display: none;\u0026quot;\u0026gt;\u0026lt;button type=\u0026quot;button\u0026quot; class=\u0026quot;s-btn hideResults\u0026quot; style=\u0026quot;display: none;\u0026quot;\u0026gt;Hide results\u0026lt;/button\u0026gt;\u0026lt;div class=\u0026quot;popout-code\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;snippet-expand-link\u0026quot;\u0026gt;Expand snippet\u0026lt;/a\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;div class=\u0026quot;snippet-result-code\u0026quot; style=\u0026quot;display: none;\u0026quot;\u0026gt;\u0026lt;iframe name=\u0026quot;sif21\u0026quot; sandbox=\u0026quot;allow-forms allow-modals allow-scripts\u0026quot; class=\u0026quot;snippet-box-edit snippet-box-result\u0026quot; frameborder=\u0026quot;0\u0026quot;\u0026gt;\u0026lt;/iframe\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;/div\u0026gt;\n\u0026lt;/div\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;ALERT: monkey\nALERT: monkey\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;But how is this so? How can referenceToInnerFunction still know the value of outerVar now that outerFunction has been set to null?\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;The reason that referenceToInnerFunction can still access the value of outerVar is because when the closure was first created by placing innerFunction inside of outerFunction, innerFunction added a reference to outerFunctions scope (its variables and functions) to its scope chain. What this means is that innerFunction has a pointer or reference to all of outerFunctions variables, including outerVar. So even when outerFunction has finished executing, or even if it is deleted or set to null, the variables in its scope, like outerVar, stick around in memory because of the outstanding reference to them on the part of the innerFunction that has been returned to referenceToInnerFunction. To truly release outerVar and the rest of outerFunctions variables from memory you would have to get rid of this outstanding reference to them, say by setting referenceToInnerFunction to null as well.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;//////////\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Two other things about closures to note. First, the closure will always have access to the last values of its containing function.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;/p\u0026gt;\u0026lt;div class=\u0026quot;snippet\u0026quot; data-lang=\u0026quot;js\u0026quot; data-hide=\u0026quot;false\u0026quot;\u0026gt;\n\u0026lt;div class=\u0026quot;snippet-code\u0026quot;\u0026gt;\n\u0026lt;pre class=\u0026quot;snippet-code-js lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;outerFunction\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;) {\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; outerVar = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;monkey\u0026quot;\u0026lt;/span\u0026gt;;\n    \n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;innerFunction\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;) {\n        \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;alert\u0026lt;/span\u0026gt;(outerVar);\n    }\n    \n    outerVar = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;gorilla\u0026quot;\u0026lt;/span\u0026gt;;\n\n    \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;innerFunction\u0026lt;/span\u0026gt;();\n}\n\n\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;outerFunction\u0026lt;/span\u0026gt;();\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;div class=\u0026quot;snippet-result\u0026quot;\u0026gt;\u0026lt;div class=\u0026quot;snippet-ctas\u0026quot;\u0026gt;\u0026lt;button type=\u0026quot;button\u0026quot; class=\u0026quot;s-btn s-btn__primary\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;icon-play-white _hover\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;\u0026lt;span\u0026gt; Run code snippet\u0026lt;/span\u0026gt;\u0026lt;/button\u0026gt;\u0026lt;input class=\u0026quot;copySnippet s-btn s-btn__filled\u0026quot; type=\u0026quot;button\u0026quot; value=\u0026quot;Copy snippet to answer\u0026quot; style=\u0026quot;display: none;\u0026quot;\u0026gt;\u0026lt;button type=\u0026quot;button\u0026quot; class=\u0026quot;s-btn hideResults\u0026quot; style=\u0026quot;display: none;\u0026quot;\u0026gt;Hide results\u0026lt;/button\u0026gt;\u0026lt;div class=\u0026quot;popout-code\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;snippet-expand-link\u0026quot;\u0026gt;Expand snippet\u0026lt;/a\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;div class=\u0026quot;snippet-result-code\u0026quot; style=\u0026quot;display: none;\u0026quot;\u0026gt;\u0026lt;iframe name=\u0026quot;sif22\u0026quot; sandbox=\u0026quot;allow-forms allow-modals allow-scripts\u0026quot; class=\u0026quot;snippet-box-edit snippet-box-result\u0026quot; frameborder=\u0026quot;0\u0026quot;\u0026gt;\u0026lt;/iframe\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;/div\u0026gt;\n\u0026lt;/div\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;ALERT: gorilla\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Second, when a closure is created, it retains a reference to all of its enclosing functions variables and functions; it doesnt get to pick and choose. And but so, closures should be used sparingly, or at least carefully, as they can be memory intensive; a lot of variables can be kept in memory long after a containing function has finished executing.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;I\u0026apos;d simply point them to the \u0026lt;a href=\u0026quot;https://developer.mozilla.org/en-US/docs/JavaScript/Guide/Closures\u0026quot;\u0026gt;Mozilla Closures page\u0026lt;/a\u0026gt;. It\u0026apos;s the best, most \u0026lt;strong\u0026gt;concise and simple explanation\u0026lt;/strong\u0026gt; of closure basics and practical usage that I\u0026apos;ve found. It is highly recommended to anyone learning JavaScript.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;And yes, I\u0026apos;d even recommend it to a 6-year old -- if the 6-year old is learning about closures, then it\u0026apos;s logical they\u0026apos;re ready to comprehend the \u0026lt;em\u0026gt;concise and simple explanation\u0026lt;/em\u0026gt; provided in the article.\u0026lt;/p\u0026gt;\n    "],"id":52,"title":"How do JavaScript closures work?","content":"\n                    \u0026lt;div\u0026gt;\n            \u0026lt;aside class=\u0026quot;s-notice s-notice__info post-notice js-post-notice mb16\u0026quot; role=\u0026quot;status\u0026quot;\u0026gt;\n        \u0026lt;div class=\u0026quot;d-flex fd-column fw-nowrap\u0026quot;\u0026gt;\n            \u0026lt;div class=\u0026quot;d-flex fw-nowrap\u0026quot;\u0026gt;\n                    \u0026lt;div class=\u0026quot;flex--item mr8\u0026quot;\u0026gt;\n                        \u0026lt;svg aria-hidden=\u0026quot;true\u0026quot; class=\u0026quot;svg-icon iconLock\u0026quot; width=\u0026quot;18\u0026quot; height=\u0026quot;18\u0026quot; viewBox=\u0026quot;0 0 18 18\u0026quot;\u0026gt;\u0026lt;path d=\u0026quot;M16 9a2 2 0 0 0-2-2V6A5 5 0 0 0 4 6v1a2 2 0 0 0-2 2v6c0 1.1.9 2 2 2h10a2 2 0 0 0 2-2V9Zm-7 5a2 2 0 1 1 0-4 2 2 0 0 1 0 4Zm3.1-7H5.9V6a3.1 3.1 0 0 1 6.2 0v1Z\u0026quot;\u0026gt;\u0026lt;/path\u0026gt;\u0026lt;/svg\u0026gt;\n                    \u0026lt;/div\u0026gt;\n                \u0026lt;div class=\u0026quot;flex--item wmn0 fl1 lh-lg\u0026quot;\u0026gt;\n                    \u0026lt;div class=\u0026quot;flex--item fl1 lh-lg\u0026quot;\u0026gt;\n                        \u0026lt;b\u0026gt;This question\u0026apos;s answers are a \u0026lt;a href=\u0026quot;/help/privileges/edit-community-wiki\u0026quot;\u0026gt;community effort\u0026lt;/a\u0026gt;\u0026lt;/b\u0026gt;. Edit existing answers to improve this post. It is not currently accepting new answers or interactions.\n                        \n                    \u0026lt;/div\u0026gt;\n                \u0026lt;/div\u0026gt;\n            \u0026lt;/div\u0026gt;\n        \u0026lt;/div\u0026gt;\n\u0026lt;/aside\u0026gt;\n\n    \u0026lt;/div\u0026gt;\n\n\u0026lt;p\u0026gt;How would you explain JavaScript closures to someone with a knowledge of the concepts they consist of (for example functions, variables and the like), but does not understand closures themselves?\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;I have seen \u0026lt;a href=\u0026quot;http://en.wikipedia.org/wiki/Scheme_%28programming_language%29\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;the Scheme example\u0026lt;/a\u0026gt; given on Wikipedia, but unfortunately it did not help.\u0026lt;/p\u0026gt;\n    ","slug":"how-do-javascript-closures-work-1657384418555","postType":"QUESTION","createdAt":"2022-07-09T16:33:38.000Z","updatedAt":"2022-07-09T16:33:38.000Z","tags":[{"id":186,"name":"scope","slug":"scope","createdAt":"2022-07-09T16:33:38.000Z","updatedAt":"2022-07-09T16:33:38.000Z","Questions_Tags":{"questionId":52,"tagId":186}}],"relatedQuestions":[{"title":"How do JavaScript closures work?","slug":"how-do-javascript-closures-work-1657384418555","tags":[{"name":"scope","Questions_Tags":{"questionId":52,"tagId":186}}]}]},"randomQuestions":[{"title":"How do I detect a click outside an element?","slug":"how-do-i-detect-a-click-outside-an-element-1657387505351"},{"title":"Trouble with UTF-8 characters; what I see is not what I stored","slug":"trouble-with-utf-8-characters-what-i-see-is-not-what-i-stored-1657384817490"},{"title":"HTTP GET with request body","slug":"http-get-with-request-body-1657387379038"},{"title":"How do I sort a dictionary by value?","slug":"how-do-i-sort-a-dictionary-by-value-1657385485049"},{"title":"How do I compare strings in Java?","slug":"how-do-i-compare-strings-in-java-1657384243187"},{"title":"Why is my Spring @Autowired field null?","slug":"why-is-my-spring-@autowired-field-null-1657384705291"},{"title":"Simulating group_concat MySQL function in Microsoft SQL Server 2005?","slug":"simulating-group_concat-mysql-function-in-microsoft-sql-server-2005-1657384832169"},{"title":"Center one and right/left align other flexbox element","slug":"center-one-and-rightleft-align-other-flexbox-element-1657387899083"},{"title":"Flexbox: center horizontally and vertically","slug":"flexbox:-center-horizontally-and-vertically-1657384587888"},{"title":"What to do Regular expression pattern doesn't match anywhere in string?","slug":"what-to-do-regular-expression-pattern-doesn't-match-anywhere-in-string-1657388095896"},{"title":"When to use single quotes, double quotes, and backticks in MySQL","slug":"when-to-use-single-quotes-double-quotes-and-backticks-in-mysql-1657384337981"},{"title":"How to remove all duplicates from an array of objects?","slug":"how-to-remove-all-duplicates-from-an-array-of-objects-1657388256190"},{"title":"Sort (order) data frame rows by multiple columns","slug":"sort-(order)-data-frame-rows-by-multiple-columns-1657388355671"},{"title":"Swing GUI listeners without AWT","slug":"swing-gui-listeners-without-awt-1657387522426"},{"title":"GUI not working after rewriting to MVC","slug":"gui-not-working-after-rewriting-to-mvc-1657388388035"},{"title":"Convert form data to JavaScript object with jQuery","slug":"convert-form-data-to-javascript-object-with-jquery-1657388036834"},{"title":"How to deal with mysqli problems? mysqli_fetch_array(): Argument #1 must be of type mysqli_result","slug":"how-to-deal-with-mysqli-problems-mysqli_fetch_array():-argument-1-must-be-of-type-mysqli_result-1657384360922"},{"title":"How do I get PHP errors to display?","slug":"how-do-i-get-php-errors-to-display-1657384570095"},{"title":"Using Auto Layout in UITableView for dynamic cell layouts \u0026 variable row heights","slug":"using-auto-layout-in-uitableview-for-dynamic-cell-layouts-and-variable-row-heights-1657387722263"},{"title":"How to extract and access data from JSON with PHP?","slug":"how-to-extract-and-access-data-from-json-with-php-1657384483259"}]},"__N_SSG":true},"page":"/questions/[slug]","query":{"slug":"how-do-javascript-closures-work-1657384418555"},"buildId":"xZs8haGjOP63QuDE0kxeX","isFallback":false,"gsp":true,"locale":"en","locales":["en"],"defaultLocale":"en","scriptLoader":[]}</script></body></html>