<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><meta name="twitter:card" content="summary_large_image"/><meta name="twitter:site" content="@solutionschecker.com"/><meta name="twitter:creator" content="@solutionschecker.com"/><meta property="og:url" content="https://solutionschecker.com"/><meta property="og:type" content="website"/><meta property="og:image" content="https://solutionschecker.com/solutions-checker-banner.png"/><meta property="og:image:alt" content="Find solution for coding, HTML, CSS, JAVASCRIPT, MYSQL, PHP, PYTHON,... quickly. - solutionschecker.com"/><script type="application/ld+json">{"@context":"https://schema.org","@type":"Organization","logo":"/logo.svg","url":"https://solutionschecker.com"}</script><title>How do I merge two dictionaries in a single expression? | Solutions Checker</title><meta name="robots" content="index,follow"/><meta name="description" content="I want to merge two dictionaries into a new dictionary.
x = {&#x27;a&#x27;: 1, &#x27;b&#x27;: 2}
y = {&#x27;b&#x27;: 3, &#x27;c&#x27;: 4}
z = merge(x, y)

&gt;&gt;&gt; z
{&#x27;a&#x27;: 1, &#x27;b&#x27;: 3, &#x27;c&#x27;: 4}

Whenever a key k is present in both dictionaries, only the value y[k] should be kept.
    "/><meta property="og:title" content="How do I merge two dictionaries in a single expression? | Solutions Checker"/><meta property="og:description" content="I want to merge two dictionaries into a new dictionary.
x = {&#x27;a&#x27;: 1, &#x27;b&#x27;: 2}
y = {&#x27;b&#x27;: 3, &#x27;c&#x27;: 4}
z = merge(x, y)

&gt;&gt;&gt; z
{&#x27;a&#x27;: 1, &#x27;b&#x27;: 3, &#x27;c&#x27;: 4}

Whenever a key k is present in both dictionaries, only the value y[k] should be kept.
    "/><script type="application/ld+json">{"@context":"https://schema.org","@type":"QAPage","mainEntity":{"name":"How do I merge two dictionaries in a single expression?","text":"I want to merge two dictionaries into a new dictionary.\nx = {&apos;a&apos;: 1, &apos;b&apos;: 2}\ny = {&apos;b&apos;: 3, &apos;c&apos;: 4}\nz = merge(x, y)\n\n&gt;&gt;&gt; z\n{&apos;a&apos;: 1, &apos;b&apos;: 3, &apos;c&apos;: 4}\n\nWhenever a key k is present in both dictionaries, only the value y[k] should be kept.\n    ","answerCount":30,"upVoteCount":500,"suggestedAnswer":[{"text":"How can I merge two Python dictionaries in a single expression?\nFor dictionaries x and y, their shallowly-merged dictionary z takes values from y, replacing those from x.\n\nIn Python 3.9.0 or greater (released 17 October 2020, PEP-584, discussed here):\nz = x | y\n\n\nIn Python 3.5 or greater:\nz = {**x, **y}\n\n\nIn Python 2, (or 3.4 or lower) write a function:\ndef merge_two_dicts(x, y):\n    z = x.copy()   # start with keys and values of x\n    z.update(y)    # modifies z with keys and values of y\n    return z\n\nand now:\nz = merge_two_dicts(x, y)\n\n\n\nExplanation\nSay you have two dictionaries and you want to merge them into a new dictionary without altering the original dictionaries:\nx = {&apos;a&apos;: 1, &apos;b&apos;: 2}\ny = {&apos;b&apos;: 3, &apos;c&apos;: 4}\n\nThe desired result is to get a new dictionary (z) with the values merged, and the second dictionary&apos;s values overwriting those from the first.\n&gt;&gt;&gt; z\n{&apos;a&apos;: 1, &apos;b&apos;: 3, &apos;c&apos;: 4}\n\nA new syntax for this, proposed in PEP 448 and available as of Python 3.5, is\nz = {**x, **y}\n\nAnd it is indeed a single expression.\nNote that we can merge in with literal notation as well:\nz = {**x, &apos;foo&apos;: 1, &apos;bar&apos;: 2, **y}\n\nand now:\n&gt;&gt;&gt; z\n{&apos;a&apos;: 1, &apos;b&apos;: 3, &apos;foo&apos;: 1, &apos;bar&apos;: 2, &apos;c&apos;: 4}\n\nIt is now showing as implemented in the release schedule for 3.5, PEP 478, and it has now made its way into the What&apos;s New in Python 3.5 document.\nHowever, since many organizations are still on Python 2, you may wish to do this in a backward-compatible way. The classically Pythonic way, available in Python 2 and Python 3.0-3.4, is to do this as a two-step process:\nz = x.copy()\nz.update(y) # which returns None since it mutates z\n\nIn both approaches, y will come second and its values will replace x&apos;s values, thus b will point to 3 in our final result.\nNot yet on Python 3.5, but want a single expression\nIf you are not yet on Python 3.5 or need to write backward-compatible code, and you want this in a single expression, the most performant while the correct approach is to put it in a function:\ndef merge_two_dicts(x, y):\n    &quot;&quot;&quot;Given two dictionaries, merge them into a new dict as a shallow copy.&quot;&quot;&quot;\n    z = x.copy()\n    z.update(y)\n    return z\n\nand then you have a single expression:\nz = merge_two_dicts(x, y)\n\nYou can also make a function to merge an arbitrary number of dictionaries, from zero to a very large number:\ndef merge_dicts(*dict_args):\n    &quot;&quot;&quot;\n    Given any number of dictionaries, shallow copy and merge into a new dict,\n    precedence goes to key-value pairs in latter dictionaries.\n    &quot;&quot;&quot;\n    result = {}\n    for dictionary in dict_args:\n        result.update(dictionary)\n    return result\n\nThis function will work in Python 2 and 3 for all dictionaries. e.g. given dictionaries a to g:\nz = merge_dicts(a, b, c, d, e, f, g) \n\nand key-value pairs in g will take precedence over dictionaries a to f, and so on.\nCritiques of Other Answers\nDon&apos;t use what you see in the formerly accepted answer:\nz = dict(x.items() + y.items())\n\nIn Python 2, you create two lists in memory for each dict, create a third list in memory with length equal to the length of the first two put together, and then discard all three lists to create the dict. In Python 3, this will fail because you&apos;re adding two dict_items objects together, not two lists -\n&gt;&gt;&gt; c = dict(a.items() + b.items())\nTraceback (most recent call last):\n  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;\nTypeError: unsupported operand type(s) for +: &apos;dict_items&apos; and &apos;dict_items&apos;\n\nand you would have to explicitly create them as lists, e.g. z = dict(list(x.items()) + list(y.items())). This is a waste of resources and computation power.\nSimilarly, taking the union of items() in Python 3 (viewitems() in Python 2.7) will also fail when values are unhashable objects (like lists, for example). Even if your values are hashable, since sets are semantically unordered, the behavior is undefined in regards to precedence. So don&apos;t do this:\n&gt;&gt;&gt; c = dict(a.items() | b.items())\n\nThis example demonstrates what happens when values are unhashable:\n&gt;&gt;&gt; x = {&apos;a&apos;: []}\n&gt;&gt;&gt; y = {&apos;b&apos;: []}\n&gt;&gt;&gt; dict(x.items() | y.items())\nTraceback (most recent call last):\n  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;\nTypeError: unhashable type: &apos;list&apos;\n\nHere&apos;s an example where y should have precedence, but instead the value from x is retained due to the arbitrary order of sets:\n&gt;&gt;&gt; x = {&apos;a&apos;: 2}\n&gt;&gt;&gt; y = {&apos;a&apos;: 1}\n&gt;&gt;&gt; dict(x.items() | y.items())\n{&apos;a&apos;: 2}\n\nAnother hack you should not use:\nz = dict(x, **y)\n\nThis uses the dict constructor and is very fast and memory-efficient (even slightly more so than our two-step process) but unless you know precisely what is happening here (that is, the second dict is being passed as keyword arguments to the dict constructor), it&apos;s difficult to read, it&apos;s not the intended usage, and so it is not Pythonic.\nHere&apos;s an example of the usage being remediated in django.\nDictionaries are intended to take hashable keys (e.g. frozensets or tuples), but this method fails in Python 3 when keys are not strings.\n&gt;&gt;&gt; c = dict(a, **b)\nTraceback (most recent call last):\n  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;\nTypeError: keyword arguments must be strings\n\nFrom the mailing list, Guido van Rossum, the creator of the language, wrote:\n\nI am fine with\ndeclaring dict({}, **{1:3}) illegal, since after all it is abuse of\nthe ** mechanism.\n\nand\n\nApparently dict(x, **y) is going around as &quot;cool hack&quot; for &quot;call\nx.update(y) and return x&quot;. Personally, I find it more despicable than\ncool.\n\nIt is my understanding (as well as the understanding of the creator of the language) that the intended usage for dict(**y) is for creating dictionaries for readability purposes, e.g.:\ndict(a=1, b=10, c=11)\n\ninstead of\n{&apos;a&apos;: 1, &apos;b&apos;: 10, &apos;c&apos;: 11}\n\nResponse to comments\n\nDespite what Guido says, dict(x, **y) is in line with the dict specification, which btw. works for both Python 2 and 3. The fact that this only works for string keys is a direct consequence of how keyword parameters work and not a short-coming of dict. Nor is using the ** operator in this place an abuse of the mechanism, in fact, ** was designed precisely to pass dictionaries as keywords.\n\nAgain, it doesn&apos;t work for 3 when keys are not strings. The implicit calling contract is that namespaces take ordinary dictionaries, while users must only pass keyword arguments that are strings. All other callables enforced it. dict broke this consistency in Python 2:\n&gt;&gt;&gt; foo(**{(&apos;a&apos;, &apos;b&apos;): None})\nTraceback (most recent call last):\n  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;\nTypeError: foo() keywords must be strings\n&gt;&gt;&gt; dict(**{(&apos;a&apos;, &apos;b&apos;): None})\n{(&apos;a&apos;, &apos;b&apos;): None}\n\nThis inconsistency was bad given other implementations of Python (PyPy, Jython, IronPython). Thus it was fixed in Python 3, as this usage could be a breaking change.\nI submit to you that it is malicious incompetence to intentionally write code that only works in one version of a language or that only works given certain arbitrary constraints.\nMore comments:\n\ndict(x.items() + y.items()) is still the most readable solution for Python 2. Readability counts.\n\nMy response: merge_two_dicts(x, y) actually seems much clearer to me, if we&apos;re actually concerned about readability. And it is not forward compatible, as Python 2 is increasingly deprecated.\n\n{**x, **y} does not seem to handle nested dictionaries. the contents of nested keys are simply overwritten, not merged [...] I ended up being burnt by these answers that do not merge recursively and I was surprised no one mentioned it. In my interpretation of the word &quot;merging&quot; these answers describe &quot;updating one dict with another&quot;, and not merging.\n\nYes. I must refer you back to the question, which is asking for a shallow merge of two dictionaries, with the first&apos;s values being overwritten by the second&apos;s - in a single expression.\nAssuming two dictionaries of dictionaries, one might recursively merge them in a single function, but you should be careful not to modify the dictionaries from either source, and the surest way to avoid that is to make a copy when assigning values. As keys must be hashable and are usually therefore immutable, it is pointless to copy them:\nfrom copy import deepcopy\n\ndef dict_of_dicts_merge(x, y):\n    z = {}\n    overlapping_keys = x.keys() &amp; y.keys()\n    for key in overlapping_keys:\n        z[key] = dict_of_dicts_merge(x[key], y[key])\n    for key in x.keys() - overlapping_keys:\n        z[key] = deepcopy(x[key])\n    for key in y.keys() - overlapping_keys:\n        z[key] = deepcopy(y[key])\n    return z\n\nUsage:\n&gt;&gt;&gt; x = {&apos;a&apos;:{1:{}}, &apos;b&apos;: {2:{}}}\n&gt;&gt;&gt; y = {&apos;b&apos;:{10:{}}, &apos;c&apos;: {11:{}}}\n&gt;&gt;&gt; dict_of_dicts_merge(x, y)\n{&apos;b&apos;: {2: {}, 10: {}}, &apos;a&apos;: {1: {}}, &apos;c&apos;: {11: {}}}\n\nComing up with contingencies for other value types is far beyond the scope of this question, so I will point you at my answer to the canonical question on a &quot;Dictionaries of dictionaries merge&quot;.\nLess Performant But Correct Ad-hocs\nThese approaches are less performant, but they will provide correct behavior.\nThey will be much less performant than copy and update or the new unpacking because they iterate through each key-value pair at a higher level of abstraction, but they do respect the order of precedence (latter dictionaries have precedence)\nYou can also chain the dictionaries manually inside a dict comprehension:\n{k: v for d in dicts for k, v in d.items()} # iteritems in Python 2.7\n\nor in Python 2.6 (and perhaps as early as 2.4 when generator expressions were introduced):\ndict((k, v) for d in dicts for k, v in d.items()) # iteritems in Python 2\n\nitertools.chain will chain the iterators over the key-value pairs in the correct order:\nfrom itertools import chain\nz = dict(chain(x.items(), y.items())) # iteritems in Python 2\n\nPerformance Analysis\nI&apos;m only going to do the performance analysis of the usages known to behave correctly. (Self-contained so you can copy and paste yourself.)\nfrom timeit import repeat\nfrom itertools import chain\n\nx = dict.fromkeys(&apos;abcdefg&apos;)\ny = dict.fromkeys(&apos;efghijk&apos;)\n\ndef merge_two_dicts(x, y):\n    z = x.copy()\n    z.update(y)\n    return z\n\nmin(repeat(lambda: {**x, **y}))\nmin(repeat(lambda: merge_two_dicts(x, y)))\nmin(repeat(lambda: {k: v for d in (x, y) for k, v in d.items()}))\nmin(repeat(lambda: dict(chain(x.items(), y.items()))))\nmin(repeat(lambda: dict(item for d in (x, y) for item in d.items())))\n\nIn Python 3.8.1, NixOS:\n&gt;&gt;&gt; min(repeat(lambda: {**x, **y}))\n1.0804965235292912\n&gt;&gt;&gt; min(repeat(lambda: merge_two_dicts(x, y)))\n1.636518670246005\n&gt;&gt;&gt; min(repeat(lambda: {k: v for d in (x, y) for k, v in d.items()}))\n3.1779992282390594\n&gt;&gt;&gt; min(repeat(lambda: dict(chain(x.items(), y.items()))))\n2.740647904574871\n&gt;&gt;&gt; min(repeat(lambda: dict(item for d in (x, y) for item in d.items())))\n4.266070580109954\n\n$ uname -a\nLinux nixos 4.19.113 #1-NixOS SMP Wed Mar 25 07:06:15 UTC 2020 x86_64 GNU/Linux\n\nResources on Dictionaries\n\nMy explanation of Python&apos;s dictionary implementation, updated for 3.6.\nAnswer on how to add new keys to a dictionary\nMapping two lists into a dictionary\nThe official Python docs on dictionaries\nThe Dictionary Even Mightier - talk by Brandon Rhodes at Pycon 2017\nModern Python Dictionaries, A Confluence of Great Ideas - talk by Raymond Hettinger at Pycon 2017\n\n    ","url":"/questions/[slug]#solution1","@type":"Answer","upvoteCount":0},{"text":"In your case, what you can do is:\nz = dict(list(x.items()) + list(y.items()))\n\nThis will, as you want it, put the final dict in z, and make the value for key b be properly overridden by the second (y) dict&apos;s value:\n&gt;&gt;&gt; x = {&apos;a&apos;:1, &apos;b&apos;: 2}\n&gt;&gt;&gt; y = {&apos;b&apos;:10, &apos;c&apos;: 11}\n&gt;&gt;&gt; z = dict(list(x.items()) + list(y.items()))\n&gt;&gt;&gt; z\n{&apos;a&apos;: 1, &apos;c&apos;: 11, &apos;b&apos;: 10}\n\n\nIf you use Python 2, you can even remove the list() calls. To create z:\n&gt;&gt;&gt; z = dict(x.items() + y.items())\n&gt;&gt;&gt; z\n{&apos;a&apos;: 1, &apos;c&apos;: 11, &apos;b&apos;: 10}\n\nIf you use Python version 3.9.0a4 or greater, then you can directly use:\nx = {&apos;a&apos;:1, &apos;b&apos;: 2}\ny = {&apos;b&apos;:10, &apos;c&apos;: 11}\nz = x | y\nprint(z)\n\n{&apos;a&apos;: 1, &apos;c&apos;: 11, &apos;b&apos;: 10}\n\n    ","url":"/questions/[slug]#solution2","@type":"Answer","upvoteCount":0},{"text":"An alternative:\n\nz = x.copy()\nz.update(y)\n\n    ","url":"/questions/[slug]#solution3","@type":"Answer","upvoteCount":0},{"text":"Another, more concise, option:\n\nz = dict(x, **y)\n\n\nNote: this has become a popular answer, but it is important to point out that if y has any non-string keys, the fact that this works at all is an abuse of a CPython implementation detail, and it does not work in Python 3, or in PyPy, IronPython, or Jython. Also, Guido is not a fan. So I can&apos;t recommend this technique for forward-compatible or cross-implementation portable code, which really means it should be avoided entirely.\n    ","url":"/questions/[slug]#solution4","@type":"Answer","upvoteCount":0},{"text":"This probably won&apos;t be a popular answer, but you almost certainly do not want to do this.  If you want a copy that&apos;s a merge, then use copy (or deepcopy, depending on what you want) and then update.  The two lines of code are much more readable - more Pythonic - than the single line creation with .items() + .items().  Explicit is better than implicit.\n\nIn addition, when you use .items() (pre Python 3.0), you&apos;re creating a new list that contains the items from the dict.  If your dictionaries are large, then that is quite a lot of overhead (two large lists that will be thrown away as soon as the merged dict is created).  update() can work more efficiently, because it can run through the second dict item-by-item.\n\nIn terms of time:\n\n&gt;&gt;&gt; timeit.Timer(&quot;dict(x, **y)&quot;, &quot;x = dict(zip(range(1000), range(1000)))\\ny=dict(zip(range(1000,2000), range(1000,2000)))&quot;).timeit(100000)\n15.52571702003479\n&gt;&gt;&gt; timeit.Timer(&quot;temp = x.copy()\\ntemp.update(y)&quot;, &quot;x = dict(zip(range(1000), range(1000)))\\ny=dict(zip(range(1000,2000), range(1000,2000)))&quot;).timeit(100000)\n15.694622993469238\n&gt;&gt;&gt; timeit.Timer(&quot;dict(x.items() + y.items())&quot;, &quot;x = dict(zip(range(1000), range(1000)))\\ny=dict(zip(range(1000,2000), range(1000,2000)))&quot;).timeit(100000)\n41.484580039978027\n\n\nIMO the tiny slowdown between the first two is worth it for the readability.  In addition, keyword arguments for dictionary creation was only added in Python 2.3, whereas copy() and update() will work in older versions.\n    ","url":"/questions/[slug]#solution5","@type":"Answer","upvoteCount":0},{"text":"In a follow-up answer, you asked about the relative performance of these two alternatives:\n\nz1 = dict(x.items() + y.items())\nz2 = dict(x, **y)\n\n\nOn my machine, at least (a fairly ordinary x86_64 running Python 2.5.2), alternative z2 is not only shorter and simpler but also significantly faster.  You can verify this for yourself using the timeit module that comes with Python.\n\nExample 1: identical dictionaries mapping 20 consecutive integers to themselves:\n\n% python -m timeit -s &apos;x=y=dict((i,i) for i in range(20))&apos; &apos;z1=dict(x.items() + y.items())&apos;\n100000 loops, best of 3: 5.67 usec per loop\n% python -m timeit -s &apos;x=y=dict((i,i) for i in range(20))&apos; &apos;z2=dict(x, **y)&apos; \n100000 loops, best of 3: 1.53 usec per loop\n\n\nz2 wins by a factor of 3.5 or so.  Different dictionaries seem to yield quite different results, but z2 always seems to come out ahead.  (If you get inconsistent results for the same test, try passing in -r with a number larger than the default 3.)\n\nExample 2: non-overlapping dictionaries mapping 252 short strings to integers and vice versa:\n\n% python -m timeit -s &apos;from htmlentitydefs import codepoint2name as x, name2codepoint as y&apos; &apos;z1=dict(x.items() + y.items())&apos;\n1000 loops, best of 3: 260 usec per loop\n% python -m timeit -s &apos;from htmlentitydefs import codepoint2name as x, name2codepoint as y&apos; &apos;z2=dict(x, **y)&apos;               \n10000 loops, best of 3: 26.9 usec per loop\n\n\nz2 wins by about a factor of 10.  That&apos;s a pretty big win in my book!\n\nAfter comparing those two, I wondered if z1&apos;s poor performance could be attributed to the overhead of constructing the two item lists, which in turn led me to wonder if this variation might work better:\n\nfrom itertools import chain\nz3 = dict(chain(x.iteritems(), y.iteritems()))\n\n\nA few quick tests, e.g.\n\n% python -m timeit -s &apos;from itertools import chain; from htmlentitydefs import codepoint2name as x, name2codepoint as y&apos; &apos;z3=dict(chain(x.iteritems(), y.iteritems()))&apos;\n10000 loops, best of 3: 66 usec per loop\n\n\nlead me to conclude that z3 is somewhat faster than z1, but not nearly as fast as z2.  Definitely not worth all the extra typing.\n\nThis discussion is still missing something important, which is a performance comparison of these alternatives with the &quot;obvious&quot; way of merging two lists: using the update method.  To try to keep things on an equal footing with the expressions, none of which modify x or y, I&apos;m going to make a copy of x instead of modifying it in-place, as follows:\n\nz0 = dict(x)\nz0.update(y)\n\n\nA typical result:\n\n% python -m timeit -s &apos;from htmlentitydefs import codepoint2name as x, name2codepoint as y&apos; &apos;z0=dict(x); z0.update(y)&apos;\n10000 loops, best of 3: 26.9 usec per loop\n\n\nIn other words, z0 and z2 seem to have essentially identical performance.  Do you think this might be a coincidence?  I don&apos;t....\n\nIn fact, I&apos;d go so far as to claim that it&apos;s impossible for pure Python code to do any better than this.  And if you can do significantly better in a C extension module, I imagine the Python folks might well be interested in incorporating your code (or a variation on your approach) into the Python core.  Python uses dict in lots of places; optimizing its operations is a big deal.\n\nYou could also write this as\n\nz0 = x.copy()\nz0.update(y)\n\n\nas Tony does, but (not surprisingly) the difference in notation turns out not to have any measurable effect on performance.  Use whichever looks right to you.  Of course, he&apos;s absolutely correct to point out that the two-statement version is much easier to understand.\n    ","url":"/questions/[slug]#solution6","@type":"Answer","upvoteCount":0},{"text":"In Python 3.0 and later, you can use collections.ChainMap which groups multiple dicts or other mappings together to create a single, updateable view:\n&gt;&gt;&gt; from collections import ChainMap\n&gt;&gt;&gt; x = {&apos;a&apos;:1, &apos;b&apos;: 2}\n&gt;&gt;&gt; y = {&apos;b&apos;:10, &apos;c&apos;: 11}\n&gt;&gt;&gt; z = dict(ChainMap({}, y, x))\n&gt;&gt;&gt; for k, v in z.items():\n        print(k, &apos;--&gt;&apos;, v)\n    \na --&gt; 1\nb --&gt; 10\nc --&gt; 11\n\nUpdate for Python 3.5 and later: You can use PEP 448 extended dictionary packing and unpacking.  This is fast and easy:\n&gt;&gt;&gt; x = {&apos;a&apos;:1, &apos;b&apos;: 2}\n&gt;&gt;&gt; y = {&apos;b&apos;:10, &apos;c&apos;: 11}\n&gt;&gt;&gt; {**x, **y}\n{&apos;a&apos;: 1, &apos;b&apos;: 10, &apos;c&apos;: 11}\n\nUpdate for Python 3.9 and later:  You can use the PEP 584 union operator:\n&gt;&gt;&gt; x = {&apos;a&apos;:1, &apos;b&apos;: 2}\n&gt;&gt;&gt; y = {&apos;b&apos;:10, &apos;c&apos;: 11}\n&gt;&gt;&gt; x | y\n{&apos;a&apos;: 1, &apos;b&apos;: 10, &apos;c&apos;: 11}\n\n    ","url":"/questions/[slug]#solution7","@type":"Answer","upvoteCount":0},{"text":"I wanted something similar, but with the ability to specify how the values on duplicate keys were merged, so I hacked this out (but did not heavily test it).  Obviously this is not a single expression, but it is a single function call.\n\ndef merge(d1, d2, merge_fn=lambda x,y:y):\n    &quot;&quot;&quot;\n    Merges two dictionaries, non-destructively, combining \n    values on duplicate keys as defined by the optional merge\n    function.  The default behavior replaces the values in d1\n    with corresponding values in d2.  (There is no other generally\n    applicable merge strategy, but often you&apos;ll have homogeneous \n    types in your dicts, so specifying a merge technique can be \n    valuable.)\n\n    Examples:\n\n    &gt;&gt;&gt; d1\n    {&apos;a&apos;: 1, &apos;c&apos;: 3, &apos;b&apos;: 2}\n    &gt;&gt;&gt; merge(d1, d1)\n    {&apos;a&apos;: 1, &apos;c&apos;: 3, &apos;b&apos;: 2}\n    &gt;&gt;&gt; merge(d1, d1, lambda x,y: x+y)\n    {&apos;a&apos;: 2, &apos;c&apos;: 6, &apos;b&apos;: 4}\n\n    &quot;&quot;&quot;\n    result = dict(d1)\n    for k,v in d2.iteritems():\n        if k in result:\n            result[k] = merge_fn(result[k], v)\n        else:\n            result[k] = v\n    return result\n\n    ","url":"/questions/[slug]#solution8","@type":"Answer","upvoteCount":0},{"text":"Recursively/deep update a dict\n\ndef deepupdate(original, update):\n    &quot;&quot;&quot;\n    Recursively update a dict.\n    Subdict&apos;s won&apos;t be overwritten but also updated.\n    &quot;&quot;&quot;\n    for key, value in original.iteritems(): \n        if key not in update:\n            update[key] = value\n        elif isinstance(value, dict):\n            deepupdate(value, update[key]) \n    return update\n\nDemonstration:\n\npluto_original = {\n    &apos;name&apos;: &apos;Pluto&apos;,\n    &apos;details&apos;: {\n        &apos;tail&apos;: True,\n        &apos;color&apos;: &apos;orange&apos;\n    }\n}\n\npluto_update = {\n    &apos;name&apos;: &apos;Pluutoo&apos;,\n    &apos;details&apos;: {\n        &apos;color&apos;: &apos;blue&apos;\n    }\n}\n\nprint deepupdate(pluto_original, pluto_update)\n\nOutputs:\n\n{\n    &apos;name&apos;: &apos;Pluutoo&apos;,\n    &apos;details&apos;: {\n        &apos;color&apos;: &apos;blue&apos;,\n        &apos;tail&apos;: True\n    }\n}\n\nThanks rednaw for edits.\n    ","url":"/questions/[slug]#solution9","@type":"Answer","upvoteCount":0},{"text":"Python 3.5 (PEP 448) allows a nicer syntax option:\n\nx = {&apos;a&apos;: 1, &apos;b&apos;: 1}\ny = {&apos;a&apos;: 2, &apos;c&apos;: 2}\nfinal = {**x, **y} \nfinal\n# {&apos;a&apos;: 2, &apos;b&apos;: 1, &apos;c&apos;: 2}\n\n\nOr even \n\nfinal = {&apos;a&apos;: 1, &apos;b&apos;: 1, **x, **y}\n\n\nIn Python 3.9 you also use | and |= with the below example from PEP 584\n\nd = {&apos;spam&apos;: 1, &apos;eggs&apos;: 2, &apos;cheese&apos;: 3}\ne = {&apos;cheese&apos;: &apos;cheddar&apos;, &apos;aardvark&apos;: &apos;Ethel&apos;}\nd | e\n# {&apos;spam&apos;: 1, &apos;eggs&apos;: 2, &apos;cheese&apos;: &apos;cheddar&apos;, &apos;aardvark&apos;: &apos;Ethel&apos;}\n\n    ","url":"/questions/[slug]#solution10","@type":"Answer","upvoteCount":0},{"text":"The best version I could think while not using copy would be:\n\nfrom itertools import chain\nx = {&apos;a&apos;:1, &apos;b&apos;: 2}\ny = {&apos;b&apos;:10, &apos;c&apos;: 11}\ndict(chain(x.iteritems(), y.iteritems()))\n\n\nIt&apos;s faster than dict(x.items() + y.items()) but not as fast as n = copy(a); n.update(b), at least on CPython. This version also works in Python 3 if you change iteritems() to items(), which is automatically done by the 2to3 tool.\n\nPersonally I like this version best because it describes fairly good what I want in a single  functional syntax. The only minor problem is that it doesn&apos;t make completely obvious that values from y takes precedence over values from x, but I don&apos;t believe it&apos;s difficult to figure that out.\n    ","url":"/questions/[slug]#solution11","@type":"Answer","upvoteCount":0},{"text":"x = {&apos;a&apos;:1, &apos;b&apos;: 2}\ny = {&apos;b&apos;:10, &apos;c&apos;: 11}\nz = dict(x.items() + y.items())\nprint z\n\n\nFor items with keys in both dictionaries (&apos;b&apos;), you can control which one ends up in the output by putting that one last.\n    ","url":"/questions/[slug]#solution12","@type":"Answer","upvoteCount":0},{"text":"While the question has already been answered several times,\nthis simple solution to the problem has not been listed yet.\n\nx = {&apos;a&apos;:1, &apos;b&apos;: 2}\ny = {&apos;b&apos;:10, &apos;c&apos;: 11}\nz4 = {}\nz4.update(x)\nz4.update(y)\n\n\nIt is as fast as z0 and the evil z2 mentioned above, but easy to understand and change.\n    ","url":"/questions/[slug]#solution13","@type":"Answer","upvoteCount":0},{"text":"def dict_merge(a, b):\n  c = a.copy()\n  c.update(b)\n  return c\n\nnew = dict_merge(old, extras)\n\n\nAmong such shady and dubious answers, this shining example is the one and only good way to merge dicts in Python, endorsed by dictator for life Guido van Rossum himself!  Someone else suggested half of this, but did not put it in a function.\n\nprint dict_merge(\n      {&apos;color&apos;:&apos;red&apos;, &apos;model&apos;:&apos;Mini&apos;},\n      {&apos;model&apos;:&apos;Ferrari&apos;, &apos;owner&apos;:&apos;Carl&apos;})\n\n\ngives:\n\n{&apos;color&apos;: &apos;red&apos;, &apos;owner&apos;: &apos;Carl&apos;, &apos;model&apos;: &apos;Ferrari&apos;}\n\n    ","url":"/questions/[slug]#solution14","@type":"Answer","upvoteCount":0},{"text":"If you think lambdas are evil then read no further.\nAs requested, you can write the fast and memory-efficient solution with one expression:\n\nx = {&apos;a&apos;:1, &apos;b&apos;:2}\ny = {&apos;b&apos;:10, &apos;c&apos;:11}\nz = (lambda a, b: (lambda a_copy: a_copy.update(b) or a_copy)(a.copy()))(x, y)\nprint z\n{&apos;a&apos;: 1, &apos;c&apos;: 11, &apos;b&apos;: 10}\nprint x\n{&apos;a&apos;: 1, &apos;b&apos;: 2}\n\n\nAs suggested above, using two lines or writing a function is probably a better way to go.\n    ","url":"/questions/[slug]#solution15","@type":"Answer","upvoteCount":0},{"text":"Be pythonic. Use a comprehension:\nz={k: v for d in [x,y] for k, v in d.items()}\n\n&gt;&gt;&gt; print z\n{&apos;a&apos;: 1, &apos;c&apos;: 11, &apos;b&apos;: 10}\n\n    ","url":"/questions/[slug]#solution16","@type":"Answer","upvoteCount":0},{"text":"In python3, the items method no longer returns a list, but rather a view, which acts like a set. In this case you&apos;ll need to take the set union since concatenating with + won&apos;t work:\n\ndict(x.items() | y.items())\n\n\nFor python3-like behavior in version 2.7, the viewitems method should work in place of items:\n\ndict(x.viewitems() | y.viewitems())\n\n\nI prefer this notation anyways since it seems more natural to think of it as a set union operation rather than concatenation (as the title shows).\n\nEdit:\n\nA couple more points for python 3. First, note that the dict(x, **y) trick won&apos;t work in python 3 unless the keys in y are strings.\n\nAlso, Raymond Hettinger&apos;s Chainmap answer is pretty elegant, since it can take an arbitrary number of dicts as arguments, but from the docs it looks like it sequentially looks through a list of all the dicts for each lookup:\n\n\n  Lookups search the underlying mappings successively until a key is found.\n\n\nThis can slow you down if you have a lot of lookups in your application:\n\nIn [1]: from collections import ChainMap\nIn [2]: from string import ascii_uppercase as up, ascii_lowercase as lo; x = dict(zip(lo, up)); y = dict(zip(up, lo))\nIn [3]: chainmap_dict = ChainMap(y, x)\nIn [4]: union_dict = dict(x.items() | y.items())\nIn [5]: timeit for k in union_dict: union_dict[k]\n100000 loops, best of 3: 2.15 µs per loop\nIn [6]: timeit for k in chainmap_dict: chainmap_dict[k]\n10000 loops, best of 3: 27.1 µs per loop\n\n\nSo about an order of magnitude slower for lookups. I&apos;m a fan of Chainmap, but looks less practical where there may be many lookups.\n    ","url":"/questions/[slug]#solution17","@type":"Answer","upvoteCount":0},{"text":"I benchmarked the suggested with perfplot and found that the good old\ntemp = x.copy()\ntemp.update(y)\n\nis the fastest solution together with the new (Python 3.9+)\nx | y\n\n\n\nCode to reproduce the plot:\nfrom collections import ChainMap\nfrom itertools import chain\nimport perfplot\n\n\ndef setup(n):\n    x = dict(zip(range(n), range(n)))\n    y = dict(zip(range(n, 2 * n), range(n, 2 * n)))\n    return x, y\n\n\ndef copy_update(data):\n    x, y = data\n    temp = x.copy()\n    temp.update(y)\n    return temp\n\n\ndef add_items(data):\n    x, y = data\n    return dict(list(x.items()) + list(y.items()))\n\n\ndef curly_star(data):\n    x, y = data\n    return {**x, **y}\n\n\ndef chain_map(data):\n    x, y = data\n    return dict(ChainMap({}, y, x))\n\n\ndef itertools_chain(data):\n    x, y = data\n    return dict(chain(x.items(), y.items()))\n\n\ndef python39_concat(data):\n    x, y = data\n    return x | y\n\n\nb = perfplot.bench(\n    setup=setup,\n    kernels=[\n        copy_update,\n        add_items,\n        curly_star,\n        chain_map,\n        itertools_chain,\n        python39_concat,\n    ],\n    labels=[\n        &quot;copy_update&quot;,\n        &quot;dict(list(x.items()) + list(y.items()))&quot;,\n        &quot;{**x, **y}&quot;,\n        &quot;chain_map&quot;,\n        &quot;itertools.chain&quot;,\n        &quot;x | y&quot;,\n    ],\n    n_range=[2 ** k for k in range(18)],\n    xlabel=&quot;len(x), len(y)&quot;,\n    equality_check=None,\n)\nb.save(&quot;out.png&quot;)\nb.show()\n\n    ","url":"/questions/[slug]#solution18","@type":"Answer","upvoteCount":0},{"text":"Two dictionaries\n\ndef union2(dict1, dict2):\n    return dict(list(dict1.items()) + list(dict2.items()))\n\n\nn dictionaries\n\ndef union(*dicts):\n    return dict(itertools.chain.from_iterable(dct.items() for dct in dicts))\n\n\nsum has bad performance. See https://mathieularose.com/how-not-to-flatten-a-list-of-lists-in-python/\n    ","url":"/questions/[slug]#solution19","@type":"Answer","upvoteCount":0},{"text":"Simple solution using itertools that preserves order (latter dicts have precedence)\n# py2\nfrom itertools import chain, imap\nmerge = lambda *args: dict(chain.from_iterable(imap(dict.iteritems, args)))\n\n# py3\nfrom itertools import chain\nmerge = lambda *args: dict(chain.from_iterable(map(dict.items, args)))\n\nAnd it&apos;s usage:\n&gt;&gt;&gt; x = {&apos;a&apos;:1, &apos;b&apos;: 2}\n&gt;&gt;&gt; y = {&apos;b&apos;:10, &apos;c&apos;: 11}\n&gt;&gt;&gt; merge(x, y)\n{&apos;a&apos;: 1, &apos;b&apos;: 10, &apos;c&apos;: 11}\n\n&gt;&gt;&gt; z = {&apos;c&apos;: 3, &apos;d&apos;: 4}\n&gt;&gt;&gt; merge(x, y, z)\n{&apos;a&apos;: 1, &apos;b&apos;: 10, &apos;c&apos;: 3, &apos;d&apos;: 4}\n\n    ","url":"/questions/[slug]#solution20","@type":"Answer","upvoteCount":0},{"text":"Abuse leading to a one-expression solution for Matthew&apos;s answer:\n\n&gt;&gt;&gt; x = {&apos;a&apos;:1, &apos;b&apos;: 2}\n&gt;&gt;&gt; y = {&apos;b&apos;:10, &apos;c&apos;: 11}\n&gt;&gt;&gt; z = (lambda f=x.copy(): (f.update(y), f)[1])()\n&gt;&gt;&gt; z\n{&apos;a&apos;: 1, &apos;c&apos;: 11, &apos;b&apos;: 10}\n\n\nYou said you wanted one expression, so I abused lambda to bind a name, and tuples to override lambda&apos;s one-expression limit. Feel free to cringe.\n\nYou could also do this of course if you don&apos;t care about copying it:\n\n&gt;&gt;&gt; x = {&apos;a&apos;:1, &apos;b&apos;: 2}\n&gt;&gt;&gt; y = {&apos;b&apos;:10, &apos;c&apos;: 11}\n&gt;&gt;&gt; z = (x.update(y), x)[1]\n&gt;&gt;&gt; z\n{&apos;a&apos;: 1, &apos;b&apos;: 10, &apos;c&apos;: 11}\n\n    ","url":"/questions/[slug]#solution21","@type":"Answer","upvoteCount":0},{"text":"If you don&apos;t mind mutating x,\nx.update(y) or x\n\nSimple, readable, performant. You know update() always returns None, which is a false value. So the above expression will always evaluate to x, after updating it.\nMost mutating methods in the standard library (like .update()) return None by convention, so this kind of pattern will work on those too. However, if you&apos;re using a dict subclass or some other method that doesn&apos;t follow this convention, then or may return its left operand, which may not be what you want. Instead, you can use a tuple display and index, which works regardless of what the first element evaluates to (although it&apos;s not quite as pretty):\n(x.update(y), x)[-1]\n\nIf you don&apos;t have x in a variable yet, you can use lambda to make a local without using an assignment statement. This amounts to using lambda as a let expression, which is a common technique in functional languages, but is maybe unpythonic.\n(lambda x: x.update(y) or x)({&apos;a&apos;: 1, &apos;b&apos;: 2})\n\nAlthough it&apos;s not that different from the following use of the new walrus operator (Python 3.8+ only),\n(x := {&apos;a&apos;: 1, &apos;b&apos;: 2}).update(y) or x\n\nespecially if you use a default argument:\n(lambda x={&apos;a&apos;: 1, &apos;b&apos;: 2}: x.update(y) or x)()\n\nIf you do want a copy, PEP 584 style x | y is the most Pythonic on 3.9+. If you must support older versions, PEP 448 style {**x, **y} is easiest for 3.5+. But if that&apos;s not available in your (even older) Python version, the let expression pattern works here too.\n(lambda z=x.copy(): z.update(y) or z)()\n\n(That is, of course, nearly equivalent to (z := x.copy()).update(y) or z, but if your Python version is new enough for that, then the PEP 448 style will be available.)\n    ","url":"/questions/[slug]#solution22","@type":"Answer","upvoteCount":0},{"text":"New in Python 3.9: Use the union operator (|) to merge dicts similar to sets:\n&gt;&gt;&gt; d = {&apos;a&apos;: 1, &apos;b&apos;: 2}\n&gt;&gt;&gt; e = {&apos;a&apos;: 9, &apos;c&apos;: 3}\n&gt;&gt;&gt; d | e\n{&apos;a&apos;: 9, &apos;b&apos;: 2, &apos;c&apos;: 3}\n\nFor matching keys, the right dict takes precedence.\nThis also works for |= to modify a dict in-place:\n&gt;&gt;&gt; e |= d    # e = e | d\n&gt;&gt;&gt; e\n{&apos;a&apos;: 1, &apos;c&apos;: 3, &apos;b&apos;: 2}\n\n    ","url":"/questions/[slug]#solution23","@type":"Answer","upvoteCount":0},{"text":"Drawing on ideas here and elsewhere I&apos;ve comprehended a function:\n\ndef merge(*dicts, **kv): \n      return { k:v for d in list(dicts) + [kv] for k,v in d.items() }\n\n\nUsage (tested in python 3):\n\nassert (merge({1:11,&apos;a&apos;:&apos;aaa&apos;},{1:99, &apos;b&apos;:&apos;bbb&apos;},foo=&apos;bar&apos;)==\\\n    {1: 99, &apos;foo&apos;: &apos;bar&apos;, &apos;b&apos;: &apos;bbb&apos;, &apos;a&apos;: &apos;aaa&apos;})\n\nassert (merge(foo=&apos;bar&apos;)=={&apos;foo&apos;: &apos;bar&apos;})\n\nassert (merge({1:11},{1:99},foo=&apos;bar&apos;,baz=&apos;quux&apos;)==\\\n    {1: 99, &apos;foo&apos;: &apos;bar&apos;, &apos;baz&apos;:&apos;quux&apos;})\n\nassert (merge({1:11},{1:99})=={1: 99})\n\n\nYou could use a lambda instead.\n    ","url":"/questions/[slug]#solution24","@type":"Answer","upvoteCount":0},{"text":"It&apos;s so silly that .update returns nothing.\nI just use a simple helper function to solve the problem:\n\ndef merge(dict1,*dicts):\n    for dict2 in dicts:\n        dict1.update(dict2)\n    return dict1\n\n\nExamples:\n\nmerge(dict1,dict2)\nmerge(dict1,dict2,dict3)\nmerge(dict1,dict2,dict3,dict4)\nmerge({},dict1,dict2)  # this one returns a new copy\n\n    ","url":"/questions/[slug]#solution25","@type":"Answer","upvoteCount":0},{"text":"(For Python2.7* only; there are simpler solutions for Python3*.)\n\nIf you&apos;re not averse to importing a standard library module, you can do\n\nfrom functools import reduce\n\ndef merge_dicts(*dicts):\n    return reduce(lambda a, d: a.update(d) or a, dicts, {})\n\n\n(The or a bit in the lambda is necessary because dict.update always returns None on success.)\n    ","url":"/questions/[slug]#solution26","@type":"Answer","upvoteCount":0},{"text":"The problem I have with solutions listed to date is that, in the merged dictionary, the value for key &quot;b&quot; is 10 but, to my way of thinking, it should be 12.\nIn that light, I present the following:\n\nimport timeit\n\nn=100000\nsu = &quot;&quot;&quot;\nx = {&apos;a&apos;:1, &apos;b&apos;: 2}\ny = {&apos;b&apos;:10, &apos;c&apos;: 11}\n&quot;&quot;&quot;\n\ndef timeMerge(f,su,niter):\n    print &quot;{:4f} sec for: {:30s}&quot;.format(timeit.Timer(f,setup=su).timeit(n),f)\n\ntimeMerge(&quot;dict(x, **y)&quot;,su,n)\ntimeMerge(&quot;x.update(y)&quot;,su,n)\ntimeMerge(&quot;dict(x.items() + y.items())&quot;,su,n)\ntimeMerge(&quot;for k in y.keys(): x[k] = k in x and x[k]+y[k] or y[k] &quot;,su,n)\n\n#confirm for loop adds b entries together\nx = {&apos;a&apos;:1, &apos;b&apos;: 2}\ny = {&apos;b&apos;:10, &apos;c&apos;: 11}\nfor k in y.keys(): x[k] = k in x and x[k]+y[k] or y[k]\nprint &quot;confirm b elements are added:&quot;,x\n\n\nResults:\n\n0.049465 sec for: dict(x, **y)\n0.033729 sec for: x.update(y)                   \n0.150380 sec for: dict(x.items() + y.items())   \n0.083120 sec for: for k in y.keys(): x[k] = k in x and x[k]+y[k] or y[k]\n\nconfirm b elements are added: {&apos;a&apos;: 1, &apos;c&apos;: 11, &apos;b&apos;: 12}\n\n    ","url":"/questions/[slug]#solution27","@type":"Answer","upvoteCount":0},{"text":"There will be a new option when Python 3.8 releases (scheduled for 20 October, 2019), thanks to PEP 572: Assignment Expressions. The new assignment expression operator := allows you to assign the result of the copy and still use it to call update, leaving the combined code a single expression, rather than two statements, changing:\n\nnewdict = dict1.copy()\nnewdict.update(dict2)\n\n\nto:\n\n(newdict := dict1.copy()).update(dict2)\n\n\nwhile behaving identically in every way. If you must also return the resulting dict (you asked for an expression returning the dict; the above creates and assigns to newdict, but doesn&apos;t return it, so you couldn&apos;t use it to pass an argument to a function as is, a la myfunc((newdict := dict1.copy()).update(dict2))), then just add or newdict to the end (since update returns None, which is falsy, it will then evaluate and return newdict as the result of the expression):\n\n(newdict := dict1.copy()).update(dict2) or newdict\n\n\nImportant caveat: In general, I&apos;d discourage this approach in favor of:\n\nnewdict = {**dict1, **dict2}\n\n\nThe unpacking approach is clearer (to anyone who knows about generalized unpacking in the first place, which you should), doesn&apos;t require a name for the result at all (so it&apos;s much more concise when constructing a temporary that is immediately passed to a function or included in a list/tuple literal or the like), and is almost certainly faster as well, being (on CPython) roughly equivalent to:\n\nnewdict = {}\nnewdict.update(dict1)\nnewdict.update(dict2)\n\n\nbut done at the C layer, using the concrete dict API, so no dynamic method lookup/binding or function call dispatch overhead is involved (where (newdict := dict1.copy()).update(dict2) is unavoidably identical to the original two-liner in behavior, performing the work in discrete steps, with dynamic lookup/binding/invocation of methods.\n\nIt&apos;s also more extensible, as merging three dicts is obvious:\n\n newdict = {**dict1, **dict2, **dict3}\n\n\nwhere using assignment expressions won&apos;t scale like that; the closest you could get would be:\n\n (newdict := dict1.copy()).update(dict2), newdict.update(dict3)\n\n\nor without the temporary tuple of Nones, but with truthiness testing of each None result:\n\n (newdict := dict1.copy()).update(dict2) or newdict.update(dict3)\n\n\neither of which is obviously much uglier, and includes further inefficiencies (either a wasted temporary tuple of Nones for comma separation, or pointless truthiness testing of each update&apos;s None return for or separation).\n\nThe only real advantage to the assignment expression approach occurs if:\n\n\nYou have generic code that needs handle both sets and dicts (both of them support copy and update, so the code works roughly as you&apos;d expect it to)\nYou expect to receive arbitrary dict-like objects, not just dict itself, and must preserve the type and semantics of the left hand side (rather than ending up with a plain dict). While myspecialdict({**speciala, **specialb}) might work, it would involve an extra temporary dict, and if myspecialdict has features plain dict can&apos;t preserve (e.g. regular dicts now preserve order based on the first appearance of a key, and value based on the last appearance of a key; you might want one that preserves order based on the last appearance of a key so updating a value also moves it to the end), then the semantics would be wrong. Since the assignment expression version uses the named methods (which are presumably overloaded to behave appropriately), it never creates a dict at all (unless dict1 was already a dict), preserving the original type (and original type&apos;s semantics), all while avoiding any temporaries.\n\n    ","url":"/questions/[slug]#solution28","@type":"Answer","upvoteCount":0},{"text":"from collections import Counter\ndict1 = {&apos;a&apos;:1, &apos;b&apos;: 2}\ndict2 = {&apos;b&apos;:10, &apos;c&apos;: 11}\nresult = dict(Counter(dict1) + Counter(dict2))\n\n\nThis should solve your problem.\n    ","url":"/questions/[slug]#solution29","@type":"Answer","upvoteCount":0},{"text":"This can be done with a single dict comprehension:\n\n&gt;&gt;&gt; x = {&apos;a&apos;:1, &apos;b&apos;: 2}\n&gt;&gt;&gt; y = {&apos;b&apos;:10, &apos;c&apos;: 11}\n&gt;&gt;&gt; { key: y[key] if key in y else x[key]\n      for key in set(x) + set(y)\n    }\n\n\nIn my view the best answer for the &apos;single expression&apos; part as no extra functions are needed, and it is short.\n    ","url":"/questions/[slug]#solution30","@type":"Answer","upvoteCount":0}],"@type":"Question"}}</script><meta name="next-head-count" content="16"/><link rel="preload" href="/_next/static/css/08bcc42a26fe5c92.css" as="style"/><link rel="stylesheet" href="/_next/static/css/08bcc42a26fe5c92.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-0d1b80a048d4787e.js"></script><script src="/_next/static/chunks/webpack-42cdea76c8170223.js" defer=""></script><script src="/_next/static/chunks/framework-4556c45dd113b893.js" defer=""></script><script src="/_next/static/chunks/main-ccfab947c79712f4.js" defer=""></script><script src="/_next/static/chunks/pages/_app-08d1a634dea6705e.js" defer=""></script><script src="/_next/static/chunks/29107295-fbcfe2172188e46f.js" defer=""></script><script src="/_next/static/chunks/150-b06815e21c943e0d.js" defer=""></script><script src="/_next/static/chunks/490-7f0418bb4354ac73.js" defer=""></script><script src="/_next/static/chunks/108-87de33c23337ff53.js" defer=""></script><script src="/_next/static/chunks/pages/questions/%5Bslug%5D-79a1437acf654019.js" defer=""></script><script src="/_next/static/TQ2eYlCSdocSK-hq6gkM0/_buildManifest.js" defer=""></script><script src="/_next/static/TQ2eYlCSdocSK-hq6gkM0/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="wrapper"><header><nav class="bg-white border-gray-200 px-4 lg:px-6 py-2.5 dark:bg-gray-800"><div class="flex flex-wrap justify-between items-center mx-auto max-w-screen-xl"><a class="flex items-center" href="/"><img src="/logo-second.png" class="mr-3 h-6 sm:h-9" alt="Solution Checker Logo"/><h4 class="self-center text-xl font-semibold whitespace-nowrap dark:text-white">Solution Checker</h4></a><div class="flex items-center lg:order-2"><button data-collapse-toggle="mobile-menu-2" type="button" class="inline-flex items-center p-2 ml-1 text-sm text-gray-500 rounded-lg lg:hidden hover:bg-gray-100 focus:outline-none focus:ring-2 focus:ring-gray-200 dark:text-gray-400 dark:hover:bg-gray-700 dark:focus:ring-gray-600" aria-controls="mobile-menu-2" aria-expanded="false"><span class="sr-only">Open main menu</span><svg class="w-6 h-6" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M3 5a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM3 10a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM3 15a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1z" clip-rule="evenodd"></path></svg><svg class="hidden w-6 h-6" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z" clip-rule="evenodd"></path></svg></button></div><div class="hidden justify-between items-center w-full lg:flex lg:w-auto lg:order-1" id="mobile-menu-2"><ul class="flex flex-col mt-4 font-medium lg:flex-row lg:space-x-8 lg:mt-0"><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" aria-current="page" href="/">Home</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/questions?tab=news">Questions</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/post?tab=news">Post</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/questions/how-do-i-merge-two-dictionaries-in-a-single-expression-1657387593160#">Coding</a></li></ul></div></div></nav></header><div class="main-content"><div class="question my-5"><div class="flex question-header items-center m-auto justify-center"><div class="rounded-xl w-full border p-5 shadow-md bg-white"><div class="flex w-full items-center justify-between border-b pb-3"><div class="flex items-center space-x-3"><div class="text-lg font-bold text-slate-700"><a href="/questions/how-do-i-merge-two-dictionaries-in-a-single-expression-1657387593160"><h1>How do I merge two dictionaries in a single expression?</h1></a></div></div><div class="flex flex-wrap h-auto justify-end items-center space-x-8"></div></div><div class="question-content mt-5">
                
<p>I want to merge two dictionaries into a new dictionary.</p>
<pre class="lang-py s-code-block"><code class="hljs language-python">x = {<span class="hljs-string">'a'</span>: <span class="hljs-number">1</span>, <span class="hljs-string">'b'</span>: <span class="hljs-number">2</span>}
y = {<span class="hljs-string">'b'</span>: <span class="hljs-number">3</span>, <span class="hljs-string">'c'</span>: <span class="hljs-number">4</span>}
z = merge(x, y)

<span class="hljs-meta">&gt;&gt;&gt; </span>z
{<span class="hljs-string">'a'</span>: <span class="hljs-number">1</span>, <span class="hljs-string">'b'</span>: <span class="hljs-number">3</span>, <span class="hljs-string">'c'</span>: <span class="hljs-number">4</span>}
</code></pre>
<p>Whenever a key <code>k</code> is present in both dictionaries, only the value <code>y[k]</code> should be kept.</p>
    </div></div></div><div class="solution-section"><nav class="flex pagination-solution flex-col justify-end"><ul class="inline-flex -space-x-px overflow-auto"><li class="pagination-solution-item"><span data-id="#solution1" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">1</span></li><li class="pagination-solution-item"><span data-id="#solution2" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">2</span></li><li class="pagination-solution-item"><span data-id="#solution3" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">3</span></li><li class="pagination-solution-item"><span data-id="#solution4" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">4</span></li><li class="pagination-solution-item"><span data-id="#solution5" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">5</span></li><li class="pagination-solution-item"><span data-id="#solution6" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">6</span></li><li class="pagination-solution-item"><span data-id="#solution7" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">7</span></li><li class="pagination-solution-item"><span data-id="#solution8" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">8</span></li><li class="pagination-solution-item"><span data-id="#solution9" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">9</span></li><li class="pagination-solution-item"><span data-id="#solution10" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">10</span></li><li class="pagination-solution-item"><span data-id="#solution11" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">11</span></li><li class="pagination-solution-item"><span data-id="#solution12" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">12</span></li><li class="pagination-solution-item"><span data-id="#solution13" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">13</span></li><li class="pagination-solution-item"><span data-id="#solution14" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">14</span></li><li class="pagination-solution-item"><span data-id="#solution15" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">15</span></li><li class="pagination-solution-item"><span data-id="#solution16" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">16</span></li><li class="pagination-solution-item"><span data-id="#solution17" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">17</span></li><li class="pagination-solution-item"><span data-id="#solution18" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">18</span></li><li class="pagination-solution-item"><span data-id="#solution19" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">19</span></li><li class="pagination-solution-item"><span data-id="#solution20" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">20</span></li><li class="pagination-solution-item"><span data-id="#solution21" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">21</span></li><li class="pagination-solution-item"><span data-id="#solution22" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">22</span></li><li class="pagination-solution-item"><span data-id="#solution23" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">23</span></li><li class="pagination-solution-item"><span data-id="#solution24" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">24</span></li><li class="pagination-solution-item"><span data-id="#solution25" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">25</span></li><li class="pagination-solution-item"><span data-id="#solution26" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">26</span></li><li class="pagination-solution-item"><span data-id="#solution27" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">27</span></li><li class="pagination-solution-item"><span data-id="#solution28" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">28</span></li><li class="pagination-solution-item"><span data-id="#solution29" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">29</span></li><li class="pagination-solution-item"><span data-id="#solution30" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">30</span></li></ul></nav><div id="solution1" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 1</h4><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<h2>How can I merge two Python dictionaries in a single expression?</h2>
<p>For dictionaries <code>x</code> and <code>y</code>, their shallowly-merged dictionary <code>z</code> takes values from <code>y</code>, replacing those from <code>x</code>.</p>
<ul>
<li><p>In Python 3.9.0 or greater (released 17 October 2020, <a href="https://www.python.org/dev/peps/pep-0584/" rel="noreferrer"><code>PEP-584</code></a>, <a href="https://bugs.python.org/issue36144" rel="noreferrer">discussed here</a>):</p>
<pre class="lang-py s-code-block"><code class="hljs language-python">z = x | y
</code></pre>
</li>
<li><p>In Python 3.5 or greater:</p>
<pre class="lang-py s-code-block"><code class="hljs language-python">z = {**x, **y}
</code></pre>
</li>
<li><p>In Python 2, (or 3.4 or lower) write a function:</p>
<pre class="lang-py s-code-block"><code class="hljs language-python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">merge_two_dicts</span>(<span class="hljs-params">x, y</span>):
    z = x.copy()   <span class="hljs-comment"># start with keys and values of x</span>
    z.update(y)    <span class="hljs-comment"># modifies z with keys and values of y</span>
    <span class="hljs-keyword">return</span> z
</code></pre>
<p>and now:</p>
<pre class="lang-py s-code-block"><code class="hljs language-python">z = merge_two_dicts(x, y)
</code></pre>
</li>
</ul>
<h3>Explanation</h3>
<p>Say you have two dictionaries and you want to merge them into a new dictionary without altering the original dictionaries:</p>
<pre class="lang-py s-code-block"><code class="hljs language-python">x = {<span class="hljs-string">'a'</span>: <span class="hljs-number">1</span>, <span class="hljs-string">'b'</span>: <span class="hljs-number">2</span>}
y = {<span class="hljs-string">'b'</span>: <span class="hljs-number">3</span>, <span class="hljs-string">'c'</span>: <span class="hljs-number">4</span>}
</code></pre>
<p>The desired result is to get a new dictionary (<code>z</code>) with the values merged, and the second dictionary's values overwriting those from the first.</p>
<pre class="lang-py s-code-block"><code class="hljs language-python"><span class="hljs-meta">&gt;&gt;&gt; </span>z
{<span class="hljs-string">'a'</span>: <span class="hljs-number">1</span>, <span class="hljs-string">'b'</span>: <span class="hljs-number">3</span>, <span class="hljs-string">'c'</span>: <span class="hljs-number">4</span>}
</code></pre>
<p>A new syntax for this, proposed in <a href="https://www.python.org/dev/peps/pep-0448" rel="noreferrer">PEP 448</a> and <a href="https://mail.python.org/pipermail/python-dev/2015-February/138564.html" rel="noreferrer">available as of Python 3.5</a>, is</p>
<pre class="lang-py s-code-block"><code class="hljs language-python">z = {**x, **y}
</code></pre>
<p>And it is indeed a single expression.</p>
<p>Note that we can merge in with literal notation as well:</p>
<pre class="lang-py s-code-block"><code class="hljs language-python">z = {**x, <span class="hljs-string">'foo'</span>: <span class="hljs-number">1</span>, <span class="hljs-string">'bar'</span>: <span class="hljs-number">2</span>, **y}
</code></pre>
<p>and now:</p>
<pre class="lang-py s-code-block"><code class="hljs language-python"><span class="hljs-meta">&gt;&gt;&gt; </span>z
{<span class="hljs-string">'a'</span>: <span class="hljs-number">1</span>, <span class="hljs-string">'b'</span>: <span class="hljs-number">3</span>, <span class="hljs-string">'foo'</span>: <span class="hljs-number">1</span>, <span class="hljs-string">'bar'</span>: <span class="hljs-number">2</span>, <span class="hljs-string">'c'</span>: <span class="hljs-number">4</span>}
</code></pre>
<p>It is now showing as implemented in the <a href="https://www.python.org/dev/peps/pep-0478/#features-for-3-5" rel="noreferrer">release schedule for 3.5, PEP 478</a>, and it has now made its way into the <a href="https://docs.python.org/dev/whatsnew/3.5.html#pep-448-additional-unpacking-generalizations" rel="noreferrer">What's New in Python 3.5</a> document.</p>
<p>However, since many organizations are still on Python 2, you may wish to do this in a backward-compatible way. The classically Pythonic way, available in Python 2 and Python 3.0-3.4, is to do this as a two-step process:</p>
<pre class="lang-py s-code-block"><code class="hljs language-python">z = x.copy()
z.update(y) <span class="hljs-comment"># which returns None since it mutates z</span>
</code></pre>
<p>In both approaches, <code>y</code> will come second and its values will replace <code>x</code>'s values, thus <code>b</code> will point to <code>3</code> in our final result.</p>
<h2>Not yet on Python 3.5, but want a <em>single expression</em></h2>
<p>If you are not yet on Python 3.5 or need to write backward-compatible code, and you want this in a <em>single expression</em>, the most performant while the correct approach is to put it in a function:</p>
<pre class="lang-py s-code-block"><code class="hljs language-python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">merge_two_dicts</span>(<span class="hljs-params">x, y</span>):
    <span class="hljs-string">"""Given two dictionaries, merge them into a new dict as a shallow copy."""</span>
    z = x.copy()
    z.update(y)
    <span class="hljs-keyword">return</span> z
</code></pre>
<p>and then you have a single expression:</p>
<pre class="lang-py s-code-block"><code class="hljs language-python">z = merge_two_dicts(x, y)
</code></pre>
<p>You can also make a function to merge an arbitrary number of dictionaries, from zero to a very large number:</p>
<pre class="lang-py s-code-block"><code class="hljs language-python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">merge_dicts</span>(<span class="hljs-params">*dict_args</span>):
    <span class="hljs-string">"""
    Given any number of dictionaries, shallow copy and merge into a new dict,
    precedence goes to key-value pairs in latter dictionaries.
    """</span>
    result = {}
    <span class="hljs-keyword">for</span> dictionary <span class="hljs-keyword">in</span> dict_args:
        result.update(dictionary)
    <span class="hljs-keyword">return</span> result
</code></pre>
<p>This function will work in Python 2 and 3 for all dictionaries. e.g. given dictionaries <code>a</code> to <code>g</code>:</p>
<pre class="lang-py s-code-block"><code class="hljs language-python">z = merge_dicts(a, b, c, d, e, f, g) 
</code></pre>
<p>and key-value pairs in <code>g</code> will take precedence over dictionaries <code>a</code> to <code>f</code>, and so on.</p>
<h2>Critiques of Other Answers</h2>
<p>Don't use what you see in the formerly accepted answer:</p>
<pre class="lang-py s-code-block"><code class="hljs language-python">z = <span class="hljs-built_in">dict</span>(x.items() + y.items())
</code></pre>
<p>In Python 2, you create two lists in memory for each dict, create a third list in memory with length equal to the length of the first two put together, and then discard all three lists to create the dict. <strong>In Python 3, this will fail</strong> because you're adding two <code>dict_items</code> objects together, not two lists -</p>
<pre class="lang-py s-code-block"><code class="hljs language-python"><span class="hljs-meta">&gt;&gt;&gt; </span>c = <span class="hljs-built_in">dict</span>(a.items() + b.items())
Traceback (most recent call last):
  File <span class="hljs-string">"&lt;stdin&gt;"</span>, line <span class="hljs-number">1</span>, <span class="hljs-keyword">in</span> &lt;module&gt;
TypeError: unsupported operand <span class="hljs-built_in">type</span>(s) <span class="hljs-keyword">for</span> +: <span class="hljs-string">'dict_items'</span> <span class="hljs-keyword">and</span> <span class="hljs-string">'dict_items'</span>
</code></pre>
<p>and you would have to explicitly create them as lists, e.g. <code>z = dict(list(x.items()) + list(y.items()))</code>. This is a waste of resources and computation power.</p>
<p>Similarly, taking the union of <code>items()</code> in Python 3 (<code>viewitems()</code> in Python 2.7) will also fail when values are unhashable objects (like lists, for example). Even if your values are hashable, <strong>since sets are semantically unordered, the behavior is undefined in regards to precedence. So don't do this:</strong></p>
<pre class="lang-py s-code-block"><code class="hljs language-python"><span class="hljs-meta">&gt;&gt;&gt; </span>c = <span class="hljs-built_in">dict</span>(a.items() | b.items())
</code></pre>
<p>This example demonstrates what happens when values are unhashable:</p>
<pre class="lang-py s-code-block"><code class="hljs language-python"><span class="hljs-meta">&gt;&gt;&gt; </span>x = {<span class="hljs-string">'a'</span>: []}
<span class="hljs-meta">&gt;&gt;&gt; </span>y = {<span class="hljs-string">'b'</span>: []}
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">dict</span>(x.items() | y.items())
Traceback (most recent call last):
  File <span class="hljs-string">"&lt;stdin&gt;"</span>, line <span class="hljs-number">1</span>, <span class="hljs-keyword">in</span> &lt;module&gt;
TypeError: unhashable <span class="hljs-built_in">type</span>: <span class="hljs-string">'list'</span>
</code></pre>
<p>Here's an example where <code>y</code> should have precedence, but instead the value from <code>x</code> is retained due to the arbitrary order of sets:</p>
<pre class="lang-py s-code-block"><code class="hljs language-python"><span class="hljs-meta">&gt;&gt;&gt; </span>x = {<span class="hljs-string">'a'</span>: <span class="hljs-number">2</span>}
<span class="hljs-meta">&gt;&gt;&gt; </span>y = {<span class="hljs-string">'a'</span>: <span class="hljs-number">1</span>}
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">dict</span>(x.items() | y.items())
{<span class="hljs-string">'a'</span>: <span class="hljs-number">2</span>}
</code></pre>
<p>Another hack you should not use:</p>
<pre class="lang-py s-code-block"><code class="hljs language-python">z = <span class="hljs-built_in">dict</span>(x, **y)
</code></pre>
<p>This uses the <code>dict</code> constructor and is very fast and memory-efficient (even slightly more so than our two-step process) but unless you know precisely what is happening here (that is, the second dict is being passed as keyword arguments to the dict constructor), it's difficult to read, it's not the intended usage, and so it is not Pythonic.</p>
<p>Here's an example of the usage being <a href="https://code.djangoproject.com/attachment/ticket/13357/django-pypy.2.diff" rel="noreferrer">remediated in django</a>.</p>
<p>Dictionaries are intended to take hashable keys (e.g. <code>frozenset</code>s or tuples), but <strong>this method fails in Python 3 when keys are not strings.</strong></p>
<pre class="lang-py s-code-block"><code class="hljs language-python"><span class="hljs-meta">&gt;&gt;&gt; </span>c = <span class="hljs-built_in">dict</span>(a, **b)
Traceback (most recent call last):
  File <span class="hljs-string">"&lt;stdin&gt;"</span>, line <span class="hljs-number">1</span>, <span class="hljs-keyword">in</span> &lt;module&gt;
TypeError: keyword arguments must be strings
</code></pre>
<p>From the <a href="https://mail.python.org/pipermail/python-dev/2010-April/099459.html" rel="noreferrer">mailing list</a>, Guido van Rossum, the creator of the language, wrote:</p>
<blockquote>
<p>I am fine with
declaring dict({}, **{1:3}) illegal, since after all it is abuse of
the ** mechanism.</p>
</blockquote>
<p>and</p>
<blockquote>
<p>Apparently dict(x, **y) is going around as "cool hack" for "call
x.update(y) and return x". Personally, I find it more despicable than
cool.</p>
</blockquote>
<p>It is my understanding (as well as the understanding of the <a href="https://mail.python.org/pipermail/python-dev/2010-April/099485.html" rel="noreferrer">creator of the language</a>) that the intended usage for <code>dict(**y)</code> is for creating dictionaries for readability purposes, e.g.:</p>
<pre class="lang-py s-code-block"><code class="hljs language-python"><span class="hljs-built_in">dict</span>(a=<span class="hljs-number">1</span>, b=<span class="hljs-number">10</span>, c=<span class="hljs-number">11</span>)
</code></pre>
<p>instead of</p>
<pre class="lang-py s-code-block"><code class="hljs language-python">{<span class="hljs-string">'a'</span>: <span class="hljs-number">1</span>, <span class="hljs-string">'b'</span>: <span class="hljs-number">10</span>, <span class="hljs-string">'c'</span>: <span class="hljs-number">11</span>}
</code></pre>
<h2>Response to comments</h2>
<blockquote>
<p>Despite what Guido says, <code>dict(x, **y)</code> is in line with the dict specification, which btw. works for both Python 2 and 3. The fact that this only works for string keys is a direct consequence of how keyword parameters work and not a short-coming of dict. Nor is using the ** operator in this place an abuse of the mechanism, in fact, ** was designed precisely to pass dictionaries as keywords.</p>
</blockquote>
<p>Again, it doesn't work for 3 when keys are not strings. The implicit calling contract is that namespaces take ordinary dictionaries, while users must only pass keyword arguments that are strings. All other callables enforced it. <code>dict</code> broke this consistency in Python 2:</p>
<pre class="lang-py s-code-block"><code class="hljs language-python"><span class="hljs-meta">&gt;&gt;&gt; </span>foo(**{(<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>): <span class="hljs-literal">None</span>})
Traceback (most recent call last):
  File <span class="hljs-string">"&lt;stdin&gt;"</span>, line <span class="hljs-number">1</span>, <span class="hljs-keyword">in</span> &lt;module&gt;
TypeError: foo() keywords must be strings
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">dict</span>(**{(<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>): <span class="hljs-literal">None</span>})
{(<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>): <span class="hljs-literal">None</span>}
</code></pre>
<p>This inconsistency was bad given other implementations of Python (PyPy, Jython, IronPython). Thus it was fixed in Python 3, as this usage could be a breaking change.</p>
<p>I submit to you that it is malicious incompetence to intentionally write code that only works in one version of a language or that only works given certain arbitrary constraints.</p>
<p>More comments:</p>
<blockquote>
<p><code>dict(x.items() + y.items())</code> is still the most readable solution for Python 2. Readability counts.</p>
</blockquote>
<p>My response: <code>merge_two_dicts(x, y)</code> actually seems much clearer to me, if we're actually concerned about readability. And it is not forward compatible, as Python 2 is increasingly deprecated.</p>
<blockquote>
<p><code>{**x, **y}</code> does not seem to handle nested dictionaries. the contents of nested keys are simply overwritten, not merged [...] I ended up being burnt by these answers that do not merge recursively and I was surprised no one mentioned it. In my interpretation of the word "merging" these answers describe "updating one dict with another", and not merging.</p>
</blockquote>
<p>Yes. I must refer you back to the question, which is asking for a <em>shallow</em> merge of <em><strong>two</strong></em> dictionaries, with the first's values being overwritten by the second's - in a single expression.</p>
<p>Assuming two dictionaries of dictionaries, one might recursively merge them in a single function, but you should be careful not to modify the dictionaries from either source, and the surest way to avoid that is to make a copy when assigning values. As keys must be hashable and are usually therefore immutable, it is pointless to copy them:</p>
<pre class="lang-py s-code-block"><code class="hljs language-python"><span class="hljs-keyword">from</span> copy <span class="hljs-keyword">import</span> deepcopy

<span class="hljs-keyword">def</span> <span class="hljs-title function_">dict_of_dicts_merge</span>(<span class="hljs-params">x, y</span>):
    z = {}
    overlapping_keys = x.keys() &amp; y.keys()
    <span class="hljs-keyword">for</span> key <span class="hljs-keyword">in</span> overlapping_keys:
        z[key] = dict_of_dicts_merge(x[key], y[key])
    <span class="hljs-keyword">for</span> key <span class="hljs-keyword">in</span> x.keys() - overlapping_keys:
        z[key] = deepcopy(x[key])
    <span class="hljs-keyword">for</span> key <span class="hljs-keyword">in</span> y.keys() - overlapping_keys:
        z[key] = deepcopy(y[key])
    <span class="hljs-keyword">return</span> z
</code></pre>
<p>Usage:</p>
<pre class="lang-py s-code-block"><code class="hljs language-python"><span class="hljs-meta">&gt;&gt;&gt; </span>x = {<span class="hljs-string">'a'</span>:{<span class="hljs-number">1</span>:{}}, <span class="hljs-string">'b'</span>: {<span class="hljs-number">2</span>:{}}}
<span class="hljs-meta">&gt;&gt;&gt; </span>y = {<span class="hljs-string">'b'</span>:{<span class="hljs-number">10</span>:{}}, <span class="hljs-string">'c'</span>: {<span class="hljs-number">11</span>:{}}}
<span class="hljs-meta">&gt;&gt;&gt; </span>dict_of_dicts_merge(x, y)
{<span class="hljs-string">'b'</span>: {<span class="hljs-number">2</span>: {}, <span class="hljs-number">10</span>: {}}, <span class="hljs-string">'a'</span>: {<span class="hljs-number">1</span>: {}}, <span class="hljs-string">'c'</span>: {<span class="hljs-number">11</span>: {}}}
</code></pre>
<p>Coming up with contingencies for other value types is far beyond the scope of this question, so I will point you at <a href="https://stackoverflow.com/a/24088493/541136">my answer to the canonical question on a "Dictionaries of dictionaries merge"</a>.</p>
<h2>Less Performant But Correct Ad-hocs</h2>
<p>These approaches are less performant, but they will provide correct behavior.
They will be <em>much less</em> performant than <code>copy</code> and <code>update</code> or the new unpacking because they iterate through each key-value pair at a higher level of abstraction, but they <em>do</em> respect the order of precedence (latter dictionaries have precedence)</p>
<p>You can also chain the dictionaries manually inside a <a href="https://www.python.org/dev/peps/pep-0274/" rel="noreferrer">dict comprehension</a>:</p>
<pre class="lang-py s-code-block"><code class="hljs language-python">{k: v <span class="hljs-keyword">for</span> d <span class="hljs-keyword">in</span> dicts <span class="hljs-keyword">for</span> k, v <span class="hljs-keyword">in</span> d.items()} <span class="hljs-comment"># iteritems in Python 2.7</span>
</code></pre>
<p>or in Python 2.6 (and perhaps as early as 2.4 when generator expressions were introduced):</p>
<pre class="lang-py s-code-block"><code class="hljs language-python"><span class="hljs-built_in">dict</span>((k, v) <span class="hljs-keyword">for</span> d <span class="hljs-keyword">in</span> dicts <span class="hljs-keyword">for</span> k, v <span class="hljs-keyword">in</span> d.items()) <span class="hljs-comment"># iteritems in Python 2</span>
</code></pre>
<p><code>itertools.chain</code> will chain the iterators over the key-value pairs in the correct order:</p>
<pre class="lang-py s-code-block"><code class="hljs language-python"><span class="hljs-keyword">from</span> itertools <span class="hljs-keyword">import</span> chain
z = <span class="hljs-built_in">dict</span>(chain(x.items(), y.items())) <span class="hljs-comment"># iteritems in Python 2</span>
</code></pre>
<h2>Performance Analysis</h2>
<p>I'm only going to do the performance analysis of the usages known to behave correctly. (Self-contained so you can copy and paste yourself.)</p>
<pre class="lang-py s-code-block"><code class="hljs language-python"><span class="hljs-keyword">from</span> timeit <span class="hljs-keyword">import</span> repeat
<span class="hljs-keyword">from</span> itertools <span class="hljs-keyword">import</span> chain

x = <span class="hljs-built_in">dict</span>.fromkeys(<span class="hljs-string">'abcdefg'</span>)
y = <span class="hljs-built_in">dict</span>.fromkeys(<span class="hljs-string">'efghijk'</span>)

<span class="hljs-keyword">def</span> <span class="hljs-title function_">merge_two_dicts</span>(<span class="hljs-params">x, y</span>):
    z = x.copy()
    z.update(y)
    <span class="hljs-keyword">return</span> z

<span class="hljs-built_in">min</span>(repeat(<span class="hljs-keyword">lambda</span>: {**x, **y}))
<span class="hljs-built_in">min</span>(repeat(<span class="hljs-keyword">lambda</span>: merge_two_dicts(x, y)))
<span class="hljs-built_in">min</span>(repeat(<span class="hljs-keyword">lambda</span>: {k: v <span class="hljs-keyword">for</span> d <span class="hljs-keyword">in</span> (x, y) <span class="hljs-keyword">for</span> k, v <span class="hljs-keyword">in</span> d.items()}))
<span class="hljs-built_in">min</span>(repeat(<span class="hljs-keyword">lambda</span>: <span class="hljs-built_in">dict</span>(chain(x.items(), y.items()))))
<span class="hljs-built_in">min</span>(repeat(<span class="hljs-keyword">lambda</span>: <span class="hljs-built_in">dict</span>(item <span class="hljs-keyword">for</span> d <span class="hljs-keyword">in</span> (x, y) <span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> d.items())))
</code></pre>
<p>In Python 3.8.1, NixOS:</p>
<pre class="lang-py s-code-block"><code class="hljs language-python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">min</span>(repeat(<span class="hljs-keyword">lambda</span>: {**x, **y}))
<span class="hljs-number">1.0804965235292912</span>
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">min</span>(repeat(<span class="hljs-keyword">lambda</span>: merge_two_dicts(x, y)))
<span class="hljs-number">1.636518670246005</span>
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">min</span>(repeat(<span class="hljs-keyword">lambda</span>: {k: v <span class="hljs-keyword">for</span> d <span class="hljs-keyword">in</span> (x, y) <span class="hljs-keyword">for</span> k, v <span class="hljs-keyword">in</span> d.items()}))
<span class="hljs-number">3.1779992282390594</span>
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">min</span>(repeat(<span class="hljs-keyword">lambda</span>: <span class="hljs-built_in">dict</span>(chain(x.items(), y.items()))))
<span class="hljs-number">2.740647904574871</span>
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">min</span>(repeat(<span class="hljs-keyword">lambda</span>: <span class="hljs-built_in">dict</span>(item <span class="hljs-keyword">for</span> d <span class="hljs-keyword">in</span> (x, y) <span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> d.items())))
<span class="hljs-number">4.266070580109954</span>
</code></pre>
<pre class="lang-sh s-code-block"><code class="hljs language-bash">$ <span class="hljs-built_in">uname</span> -a
Linux nixos 4.19.113 <span class="hljs-comment">#1-NixOS SMP Wed Mar 25 07:06:15 UTC 2020 x86_64 GNU/Linux</span>
</code></pre>
<h2>Resources on Dictionaries</h2>
<ul>
<li><a href="https://stackoverflow.com/questions/327311/how-are-pythons-built-in-dictionaries-implemented/44509302#44509302">My explanation of Python's <strong>dictionary implementation</strong>, updated for 3.6.</a></li>
<li><a href="https://stackoverflow.com/questions/1024847/add-new-keys-to-a-dictionary/27208535#27208535">Answer on how to add new keys to a dictionary</a></li>
<li><a href="https://stackoverflow.com/questions/209840/map-two-lists-into-a-dictionary-in-python/33737067#33737067">Mapping two lists into a dictionary</a></li>
<li><a href="https://docs.python.org/3/tutorial/datastructures.html#dictionaries" rel="noreferrer">The official Python docs on dictionaries</a></li>
<li><a href="https://www.youtube.com/watch?v=66P5FMkWoVU" rel="noreferrer">The Dictionary Even Mightier</a> - talk by Brandon Rhodes at Pycon 2017</li>
<li><a href="https://www.youtube.com/watch?v=npw4s1QTmPg" rel="noreferrer">Modern Python Dictionaries, A Confluence of Great Ideas</a> - talk by Raymond Hettinger at Pycon 2017</li>
</ul>
    </div></div></div></div><div id="solution2" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 2</h4><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>In your case, what you can do is:</p>
<pre class="lang-py s-code-block"><code class="hljs language-python">z = <span class="hljs-built_in">dict</span>(<span class="hljs-built_in">list</span>(x.items()) + <span class="hljs-built_in">list</span>(y.items()))
</code></pre>
<p>This will, as you want it, put the final dict in <code>z</code>, and make the value for key <code>b</code> be properly overridden by the second (<code>y</code>) dict's value:</p>
<pre class="lang-py s-code-block"><code class="hljs language-python"><span class="hljs-meta">&gt;&gt;&gt; </span>x = {<span class="hljs-string">'a'</span>:<span class="hljs-number">1</span>, <span class="hljs-string">'b'</span>: <span class="hljs-number">2</span>}
<span class="hljs-meta">&gt;&gt;&gt; </span>y = {<span class="hljs-string">'b'</span>:<span class="hljs-number">10</span>, <span class="hljs-string">'c'</span>: <span class="hljs-number">11</span>}
<span class="hljs-meta">&gt;&gt;&gt; </span>z = <span class="hljs-built_in">dict</span>(<span class="hljs-built_in">list</span>(x.items()) + <span class="hljs-built_in">list</span>(y.items()))
<span class="hljs-meta">&gt;&gt;&gt; </span>z
{<span class="hljs-string">'a'</span>: <span class="hljs-number">1</span>, <span class="hljs-string">'c'</span>: <span class="hljs-number">11</span>, <span class="hljs-string">'b'</span>: <span class="hljs-number">10</span>}

</code></pre>
<p>If you use Python 2, you can even remove the <code>list()</code> calls. To create z:</p>
<pre class="lang-py s-code-block"><code class="hljs language-python"><span class="hljs-meta">&gt;&gt;&gt; </span>z = <span class="hljs-built_in">dict</span>(x.items() + y.items())
<span class="hljs-meta">&gt;&gt;&gt; </span>z
{<span class="hljs-string">'a'</span>: <span class="hljs-number">1</span>, <span class="hljs-string">'c'</span>: <span class="hljs-number">11</span>, <span class="hljs-string">'b'</span>: <span class="hljs-number">10</span>}
</code></pre>
<p>If you use Python version 3.9.0a4 or greater, then you can directly use:</p>
<pre class="lang-py s-code-block"><code class="hljs language-python">x = {<span class="hljs-string">'a'</span>:<span class="hljs-number">1</span>, <span class="hljs-string">'b'</span>: <span class="hljs-number">2</span>}
y = {<span class="hljs-string">'b'</span>:<span class="hljs-number">10</span>, <span class="hljs-string">'c'</span>: <span class="hljs-number">11</span>}
z = x | y
<span class="hljs-built_in">print</span>(z)
</code></pre>
<pre class="lang-py s-code-block"><code class="hljs language-python">{<span class="hljs-string">'a'</span>: <span class="hljs-number">1</span>, <span class="hljs-string">'c'</span>: <span class="hljs-number">11</span>, <span class="hljs-string">'b'</span>: <span class="hljs-number">10</span>}
</code></pre>
    </div></div></div></div><div id="solution3" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 3</h4><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>An alternative:</p>

<pre class="lang-py s-code-block"><code class="hljs language-python">z = x.copy()
z.update(y)
</code></pre>
    </div></div></div></div><div id="solution4" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 4</h4><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Another, more concise, option:</p>

<pre class="lang-py s-code-block"><code class="hljs language-python">z = <span class="hljs-built_in">dict</span>(x, **y)
</code></pre>

<p><strong>Note</strong>: this has become a popular answer, but it is important to point out that if <code>y</code> has any non-string keys, the fact that this works at all is an abuse of a CPython implementation detail, and it does not work in Python 3, or in PyPy, IronPython, or Jython. Also, <a href="http://mail.python.org/pipermail/python-dev/2010-April/099459.html" rel="noreferrer">Guido is not a fan</a>. So I can't recommend this technique for forward-compatible or cross-implementation portable code, which really means it should be avoided entirely.</p>
    </div></div></div></div><div id="solution5" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 5</h4><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>This probably won't be a popular answer, but you almost certainly do not want to do this.  If you want a copy that's a merge, then use copy (or <a href="https://docs.python.org/2/library/copy.html" rel="noreferrer">deepcopy</a>, depending on what you want) and then update.  The two lines of code are much more readable - more Pythonic - than the single line creation with .items() + .items().  Explicit is better than implicit.</p>

<p>In addition, when you use .items() (pre Python 3.0), you're creating a new list that contains the items from the dict.  If your dictionaries are large, then that is quite a lot of overhead (two large lists that will be thrown away as soon as the merged dict is created).  update() can work more efficiently, because it can run through the second dict item-by-item.</p>

<p>In terms of <a href="https://docs.python.org/2/library/timeit.html" rel="noreferrer">time</a>:</p>

<pre class="lang-py s-code-block"><code class="hljs language-python"><span class="hljs-meta">&gt;&gt;&gt; </span>timeit.Timer(<span class="hljs-string">"dict(x, **y)"</span>, <span class="hljs-string">"x = dict(zip(range(1000), range(1000)))\ny=dict(zip(range(1000,2000), range(1000,2000)))"</span>).timeit(<span class="hljs-number">100000</span>)
<span class="hljs-number">15.52571702003479</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>timeit.Timer(<span class="hljs-string">"temp = x.copy()\ntemp.update(y)"</span>, <span class="hljs-string">"x = dict(zip(range(1000), range(1000)))\ny=dict(zip(range(1000,2000), range(1000,2000)))"</span>).timeit(<span class="hljs-number">100000</span>)
<span class="hljs-number">15.694622993469238</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>timeit.Timer(<span class="hljs-string">"dict(x.items() + y.items())"</span>, <span class="hljs-string">"x = dict(zip(range(1000), range(1000)))\ny=dict(zip(range(1000,2000), range(1000,2000)))"</span>).timeit(<span class="hljs-number">100000</span>)
<span class="hljs-number">41.484580039978027</span>
</code></pre>

<p>IMO the tiny slowdown between the first two is worth it for the readability.  In addition, keyword arguments for dictionary creation was only added in Python 2.3, whereas copy() and update() will work in older versions.</p>
    </div></div></div></div><div id="solution6" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 6</h4><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>In a follow-up answer, you asked about the relative performance of these two alternatives:</p>

<pre class="lang-py s-code-block"><code class="hljs language-python">z1 = <span class="hljs-built_in">dict</span>(x.items() + y.items())
z2 = <span class="hljs-built_in">dict</span>(x, **y)
</code></pre>

<p>On my machine, at least (a fairly ordinary x86_64 running Python 2.5.2), alternative <code>z2</code> is not only shorter and simpler but also significantly faster.  You can verify this for yourself using the <code>timeit</code> module that comes with Python.</p>

<p>Example 1: identical dictionaries mapping 20 consecutive integers to themselves:</p>

<pre class="lang-py s-code-block"><code class="hljs language-python">% python -m timeit -s <span class="hljs-string">'x=y=dict((i,i) for i in range(20))'</span> <span class="hljs-string">'z1=dict(x.items() + y.items())'</span>
<span class="hljs-number">100000</span> loops, best of <span class="hljs-number">3</span>: <span class="hljs-number">5.67</span> usec per loop
% python -m timeit -s <span class="hljs-string">'x=y=dict((i,i) for i in range(20))'</span> <span class="hljs-string">'z2=dict(x, **y)'</span> 
<span class="hljs-number">100000</span> loops, best of <span class="hljs-number">3</span>: <span class="hljs-number">1.53</span> usec per loop
</code></pre>

<p><code>z2</code> wins by a factor of 3.5 or so.  Different dictionaries seem to yield quite different results, but <code>z2</code> always seems to come out ahead.  (If you get inconsistent results for the <em>same</em> test, try passing in <code>-r</code> with a number larger than the default 3.)</p>

<p>Example 2: non-overlapping dictionaries mapping 252 short strings to integers and vice versa:</p>

<pre class="lang-py s-code-block"><code class="hljs language-python">% python -m timeit -s <span class="hljs-string">'from htmlentitydefs import codepoint2name as x, name2codepoint as y'</span> <span class="hljs-string">'z1=dict(x.items() + y.items())'</span>
<span class="hljs-number">1000</span> loops, best of <span class="hljs-number">3</span>: <span class="hljs-number">260</span> usec per loop
% python -m timeit -s <span class="hljs-string">'from htmlentitydefs import codepoint2name as x, name2codepoint as y'</span> <span class="hljs-string">'z2=dict(x, **y)'</span>               
<span class="hljs-number">10000</span> loops, best of <span class="hljs-number">3</span>: <span class="hljs-number">26.9</span> usec per loop
</code></pre>

<p><code>z2</code> wins by about a factor of 10.  That's a pretty big win in my book!</p>

<p>After comparing those two, I wondered if <code>z1</code>'s poor performance could be attributed to the overhead of constructing the two item lists, which in turn led me to wonder if this variation might work better:</p>

<pre class="lang-py s-code-block"><code class="hljs language-python"><span class="hljs-keyword">from</span> itertools <span class="hljs-keyword">import</span> chain
z3 = <span class="hljs-built_in">dict</span>(chain(x.iteritems(), y.iteritems()))
</code></pre>

<p>A few quick tests, e.g.</p>

<pre class="lang-py s-code-block"><code class="hljs language-python">% python -m timeit -s <span class="hljs-string">'from itertools import chain; from htmlentitydefs import codepoint2name as x, name2codepoint as y'</span> <span class="hljs-string">'z3=dict(chain(x.iteritems(), y.iteritems()))'</span>
<span class="hljs-number">10000</span> loops, best of <span class="hljs-number">3</span>: <span class="hljs-number">66</span> usec per loop
</code></pre>

<p>lead me to conclude that <code>z3</code> is somewhat faster than <code>z1</code>, but not nearly as fast as <code>z2</code>.  Definitely not worth all the extra typing.</p>

<p>This discussion is still missing something important, which is a performance comparison of these alternatives with the "obvious" way of merging two lists: using the <code>update</code> method.  To try to keep things on an equal footing with the expressions, none of which modify x or y, I'm going to make a copy of x instead of modifying it in-place, as follows:</p>

<pre class="lang-py s-code-block"><code class="hljs language-python">z0 = <span class="hljs-built_in">dict</span>(x)
z0.update(y)
</code></pre>

<p>A typical result:</p>

<pre class="lang-py s-code-block"><code class="hljs language-python">% python -m timeit -s <span class="hljs-string">'from htmlentitydefs import codepoint2name as x, name2codepoint as y'</span> <span class="hljs-string">'z0=dict(x); z0.update(y)'</span>
<span class="hljs-number">10000</span> loops, best of <span class="hljs-number">3</span>: <span class="hljs-number">26.9</span> usec per loop
</code></pre>

<p>In other words, <code>z0</code> and <code>z2</code> seem to have essentially identical performance.  Do you think this might be a coincidence?  I don't....</p>

<p>In fact, I'd go so far as to claim that it's impossible for pure Python code to do any better than this.  And if you can do significantly better in a C extension module, I imagine the Python folks might well be interested in incorporating your code (or a variation on your approach) into the Python core.  Python uses <code>dict</code> in lots of places; optimizing its operations is a big deal.</p>

<p>You could also write this as</p>

<pre class="lang-py s-code-block"><code class="hljs language-python">z0 = x.copy()
z0.update(y)
</code></pre>

<p>as Tony does, but (not surprisingly) the difference in notation turns out not to have any measurable effect on performance.  Use whichever looks right to you.  Of course, he's absolutely correct to point out that the two-statement version is much easier to understand.</p>
    </div></div></div></div><div id="solution7" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 7</h4><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p><strong>In Python 3.0 and later</strong>, you can use <a href="http://docs.python.org/3/library/collections.html#collections.ChainMap" rel="noreferrer"><code>collections.ChainMap</code></a> which groups multiple dicts or other mappings together to create a single, updateable view:</p>
<pre class="lang-py s-code-block"><code class="hljs language-python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> ChainMap
<span class="hljs-meta">&gt;&gt;&gt; </span>x = {<span class="hljs-string">'a'</span>:<span class="hljs-number">1</span>, <span class="hljs-string">'b'</span>: <span class="hljs-number">2</span>}
<span class="hljs-meta">&gt;&gt;&gt; </span>y = {<span class="hljs-string">'b'</span>:<span class="hljs-number">10</span>, <span class="hljs-string">'c'</span>: <span class="hljs-number">11</span>}
<span class="hljs-meta">&gt;&gt;&gt; </span>z = <span class="hljs-built_in">dict</span>(ChainMap({}, y, x))
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">for</span> k, v <span class="hljs-keyword">in</span> z.items():
        <span class="hljs-built_in">print</span>(k, <span class="hljs-string">'--&gt;'</span>, v)
    
a --&gt; <span class="hljs-number">1</span>
b --&gt; <span class="hljs-number">10</span>
c --&gt; <span class="hljs-number">11</span>
</code></pre>
<p><strong>Update for Python 3.5 and later</strong>: You can use <a href="https://www.python.org/dev/peps/pep-0448/" rel="noreferrer">PEP 448</a> extended dictionary packing and unpacking.  This is fast and easy:</p>
<pre class="lang-py s-code-block"><code class="hljs language-python"><span class="hljs-meta">&gt;&gt;&gt; </span>x = {<span class="hljs-string">'a'</span>:<span class="hljs-number">1</span>, <span class="hljs-string">'b'</span>: <span class="hljs-number">2</span>}
<span class="hljs-meta">&gt;&gt;&gt; </span>y = {<span class="hljs-string">'b'</span>:<span class="hljs-number">10</span>, <span class="hljs-string">'c'</span>: <span class="hljs-number">11</span>}
<span class="hljs-meta">&gt;&gt;&gt; </span>{**x, **y}
{<span class="hljs-string">'a'</span>: <span class="hljs-number">1</span>, <span class="hljs-string">'b'</span>: <span class="hljs-number">10</span>, <span class="hljs-string">'c'</span>: <span class="hljs-number">11</span>}
</code></pre>
<p><strong>Update for Python 3.9 and later</strong>:  You can use the <a href="https://www.python.org/dev/peps/pep-0584/" rel="noreferrer">PEP 584</a> union operator:</p>
<pre class="lang-py s-code-block"><code class="hljs language-python"><span class="hljs-meta">&gt;&gt;&gt; </span>x = {<span class="hljs-string">'a'</span>:<span class="hljs-number">1</span>, <span class="hljs-string">'b'</span>: <span class="hljs-number">2</span>}
<span class="hljs-meta">&gt;&gt;&gt; </span>y = {<span class="hljs-string">'b'</span>:<span class="hljs-number">10</span>, <span class="hljs-string">'c'</span>: <span class="hljs-number">11</span>}
<span class="hljs-meta">&gt;&gt;&gt; </span>x | y
{<span class="hljs-string">'a'</span>: <span class="hljs-number">1</span>, <span class="hljs-string">'b'</span>: <span class="hljs-number">10</span>, <span class="hljs-string">'c'</span>: <span class="hljs-number">11</span>}
</code></pre>
    </div></div></div></div><div id="solution8" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 8</h4><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>I wanted something similar, but with the ability to specify how the values on duplicate keys were merged, so I hacked this out (but did not heavily test it).  Obviously this is not a single expression, but it is a single function call.</p>

<pre class="lang-py s-code-block"><code class="hljs language-python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">merge</span>(<span class="hljs-params">d1, d2, merge_fn=<span class="hljs-keyword">lambda</span> x,y:y</span>):
    <span class="hljs-string">"""
    Merges two dictionaries, non-destructively, combining 
    values on duplicate keys as defined by the optional merge
    function.  The default behavior replaces the values in d1
    with corresponding values in d2.  (There is no other generally
    applicable merge strategy, but often you'll have homogeneous 
    types in your dicts, so specifying a merge technique can be 
    valuable.)

    Examples:

    &gt;&gt;&gt; d1
    {'a': 1, 'c': 3, 'b': 2}
    &gt;&gt;&gt; merge(d1, d1)
    {'a': 1, 'c': 3, 'b': 2}
    &gt;&gt;&gt; merge(d1, d1, lambda x,y: x+y)
    {'a': 2, 'c': 6, 'b': 4}

    """</span>
    result = <span class="hljs-built_in">dict</span>(d1)
    <span class="hljs-keyword">for</span> k,v <span class="hljs-keyword">in</span> d2.iteritems():
        <span class="hljs-keyword">if</span> k <span class="hljs-keyword">in</span> result:
            result[k] = merge_fn(result[k], v)
        <span class="hljs-keyword">else</span>:
            result[k] = v
    <span class="hljs-keyword">return</span> result
</code></pre>
    </div></div></div></div><div id="solution9" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 9</h4><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<h1>Recursively/deep update a dict</h1>

<pre class="lang-py s-code-block"><code class="hljs language-python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">deepupdate</span>(<span class="hljs-params">original, update</span>):
    <span class="hljs-string">"""
    Recursively update a dict.
    Subdict's won't be overwritten but also updated.
    """</span>
    <span class="hljs-keyword">for</span> key, value <span class="hljs-keyword">in</span> original.iteritems(): 
        <span class="hljs-keyword">if</span> key <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> update:
            update[key] = value
        <span class="hljs-keyword">elif</span> <span class="hljs-built_in">isinstance</span>(value, <span class="hljs-built_in">dict</span>):
            deepupdate(value, update[key]) 
    <span class="hljs-keyword">return</span> update</code></pre>

<p>Demonstration:</p>

<pre class="lang-py s-code-block"><code class="hljs language-python">pluto_original = {
    <span class="hljs-string">'name'</span>: <span class="hljs-string">'Pluto'</span>,
    <span class="hljs-string">'details'</span>: {
        <span class="hljs-string">'tail'</span>: <span class="hljs-literal">True</span>,
        <span class="hljs-string">'color'</span>: <span class="hljs-string">'orange'</span>
    }
}

pluto_update = {
    <span class="hljs-string">'name'</span>: <span class="hljs-string">'Pluutoo'</span>,
    <span class="hljs-string">'details'</span>: {
        <span class="hljs-string">'color'</span>: <span class="hljs-string">'blue'</span>
    }
}

<span class="hljs-built_in">print</span> deepupdate(pluto_original, pluto_update)</code></pre>

<p>Outputs:</p>

<pre class="lang-py s-code-block"><code class="hljs language-python">{
    <span class="hljs-string">'name'</span>: <span class="hljs-string">'Pluutoo'</span>,
    <span class="hljs-string">'details'</span>: {
        <span class="hljs-string">'color'</span>: <span class="hljs-string">'blue'</span>,
        <span class="hljs-string">'tail'</span>: <span class="hljs-literal">True</span>
    }
}</code></pre>

<p>Thanks rednaw for edits.</p>
    </div></div></div></div><div id="solution10" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 10</h4><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Python 3.5 (PEP 448) allows a nicer syntax option:</p>

<pre class="lang-py s-code-block"><code class="hljs language-python">x = {<span class="hljs-string">'a'</span>: <span class="hljs-number">1</span>, <span class="hljs-string">'b'</span>: <span class="hljs-number">1</span>}
y = {<span class="hljs-string">'a'</span>: <span class="hljs-number">2</span>, <span class="hljs-string">'c'</span>: <span class="hljs-number">2</span>}
final = {**x, **y} 
final
<span class="hljs-comment"># {'a': 2, 'b': 1, 'c': 2}</span>
</code></pre>

<p>Or even </p>

<pre class="lang-py s-code-block"><code class="hljs language-python">final = {<span class="hljs-string">'a'</span>: <span class="hljs-number">1</span>, <span class="hljs-string">'b'</span>: <span class="hljs-number">1</span>, **x, **y}
</code></pre>

<p>In Python 3.9 you also use | and |= with the below example from PEP 584</p>

<pre class="lang-py s-code-block"><code class="hljs language-python">d = {<span class="hljs-string">'spam'</span>: <span class="hljs-number">1</span>, <span class="hljs-string">'eggs'</span>: <span class="hljs-number">2</span>, <span class="hljs-string">'cheese'</span>: <span class="hljs-number">3</span>}
e = {<span class="hljs-string">'cheese'</span>: <span class="hljs-string">'cheddar'</span>, <span class="hljs-string">'aardvark'</span>: <span class="hljs-string">'Ethel'</span>}
d | e
<span class="hljs-comment"># {'spam': 1, 'eggs': 2, 'cheese': 'cheddar', 'aardvark': 'Ethel'}</span>
</code></pre>
    </div></div></div></div><div id="solution11" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 11</h4><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>The best version I could think while not using copy would be:</p>

<pre class="lang-py s-code-block"><code class="hljs language-python"><span class="hljs-keyword">from</span> itertools <span class="hljs-keyword">import</span> chain
x = {<span class="hljs-string">'a'</span>:<span class="hljs-number">1</span>, <span class="hljs-string">'b'</span>: <span class="hljs-number">2</span>}
y = {<span class="hljs-string">'b'</span>:<span class="hljs-number">10</span>, <span class="hljs-string">'c'</span>: <span class="hljs-number">11</span>}
<span class="hljs-built_in">dict</span>(chain(x.iteritems(), y.iteritems()))
</code></pre>

<p>It's faster than <code>dict(x.items() + y.items())</code> but not as fast as <code>n = copy(a); n.update(b)</code>, at least on CPython. This version also works in Python 3 if you change <code>iteritems()</code> to <code>items()</code>, which is automatically done by the 2to3 tool.</p>

<p>Personally I like this version best because it describes fairly good what I want in a single  functional syntax. The only minor problem is that it doesn't make completely obvious that values from y takes precedence over values from x, but I don't believe it's difficult to figure that out.</p>
    </div></div></div></div><div id="solution12" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 12</h4><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<pre class="lang-py s-code-block"><code class="hljs language-python">x = {<span class="hljs-string">'a'</span>:<span class="hljs-number">1</span>, <span class="hljs-string">'b'</span>: <span class="hljs-number">2</span>}
y = {<span class="hljs-string">'b'</span>:<span class="hljs-number">10</span>, <span class="hljs-string">'c'</span>: <span class="hljs-number">11</span>}
z = <span class="hljs-built_in">dict</span>(x.items() + y.items())
<span class="hljs-built_in">print</span> z
</code></pre>

<p>For items with keys in both dictionaries ('b'), you can control which one ends up in the output by putting that one last.</p>
    </div></div></div></div><div id="solution13" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 13</h4><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>While the question has already been answered several times,
this simple solution to the problem has not been listed yet.</p>

<pre class="lang-py s-code-block"><code class="hljs language-python">x = {<span class="hljs-string">'a'</span>:<span class="hljs-number">1</span>, <span class="hljs-string">'b'</span>: <span class="hljs-number">2</span>}
y = {<span class="hljs-string">'b'</span>:<span class="hljs-number">10</span>, <span class="hljs-string">'c'</span>: <span class="hljs-number">11</span>}
z4 = {}
z4.update(x)
z4.update(y)
</code></pre>

<p>It is as fast as z0 and the evil z2 mentioned above, but easy to understand and change.</p>
    </div></div></div></div><div id="solution14" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 14</h4><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<pre class="lang-py s-code-block"><code class="hljs language-python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">dict_merge</span>(<span class="hljs-params">a, b</span>):
  c = a.copy()
  c.update(b)
  <span class="hljs-keyword">return</span> c

new = dict_merge(old, extras)
</code></pre>

<p>Among such shady and dubious answers, this shining example is the one and only good way to merge dicts in Python, endorsed by dictator for life <em>Guido van Rossum</em> himself!  Someone else suggested half of this, but did not put it in a function.</p>

<pre class="lang-py s-code-block"><code class="hljs language-python"><span class="hljs-built_in">print</span> dict_merge(
      {<span class="hljs-string">'color'</span>:<span class="hljs-string">'red'</span>, <span class="hljs-string">'model'</span>:<span class="hljs-string">'Mini'</span>},
      {<span class="hljs-string">'model'</span>:<span class="hljs-string">'Ferrari'</span>, <span class="hljs-string">'owner'</span>:<span class="hljs-string">'Carl'</span>})
</code></pre>

<p>gives:</p>

<pre class="lang-py s-code-block"><code class="hljs language-python">{<span class="hljs-string">'color'</span>: <span class="hljs-string">'red'</span>, <span class="hljs-string">'owner'</span>: <span class="hljs-string">'Carl'</span>, <span class="hljs-string">'model'</span>: <span class="hljs-string">'Ferrari'</span>}
</code></pre>
    </div></div></div></div><div id="solution15" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 15</h4><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>If you think lambdas are evil then read no further.
As requested, you can write the fast and memory-efficient solution with one expression:</p>

<pre class="lang-py s-code-block"><code class="hljs language-python">x = {<span class="hljs-string">'a'</span>:<span class="hljs-number">1</span>, <span class="hljs-string">'b'</span>:<span class="hljs-number">2</span>}
y = {<span class="hljs-string">'b'</span>:<span class="hljs-number">10</span>, <span class="hljs-string">'c'</span>:<span class="hljs-number">11</span>}
z = (<span class="hljs-keyword">lambda</span> a, b: (<span class="hljs-keyword">lambda</span> a_copy: a_copy.update(b) <span class="hljs-keyword">or</span> a_copy)(a.copy()))(x, y)
<span class="hljs-built_in">print</span> z
{<span class="hljs-string">'a'</span>: <span class="hljs-number">1</span>, <span class="hljs-string">'c'</span>: <span class="hljs-number">11</span>, <span class="hljs-string">'b'</span>: <span class="hljs-number">10</span>}
<span class="hljs-built_in">print</span> x
{<span class="hljs-string">'a'</span>: <span class="hljs-number">1</span>, <span class="hljs-string">'b'</span>: <span class="hljs-number">2</span>}
</code></pre>

<p>As suggested above, using two lines or writing a function is probably a better way to go.</p>
    </div></div></div></div><div id="solution16" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 16</h4><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Be pythonic. Use a <a href="https://docs.python.org/2/tutorial/datastructures.html#dictionaries" rel="nofollow noreferrer">comprehension</a>:</p>
<pre class="lang-py s-code-block"><code class="hljs language-python">z={k: v <span class="hljs-keyword">for</span> d <span class="hljs-keyword">in</span> [x,y] <span class="hljs-keyword">for</span> k, v <span class="hljs-keyword">in</span> d.items()}

<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">print</span> z
{<span class="hljs-string">'a'</span>: <span class="hljs-number">1</span>, <span class="hljs-string">'c'</span>: <span class="hljs-number">11</span>, <span class="hljs-string">'b'</span>: <span class="hljs-number">10</span>}
</code></pre>
    </div></div></div></div><div id="solution17" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 17</h4><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>In python3, the <code>items</code> method <a href="http://docs.python.org/dev/whatsnew/3.0.html#views-and-iterators-instead-of-lists" rel="noreferrer">no longer returns a list</a>, but rather a <em>view</em>, which acts like a set. In this case you'll need to take the set union since concatenating with <code>+</code> won't work:</p>

<pre class="lang-py s-code-block"><code class="hljs language-python"><span class="hljs-built_in">dict</span>(x.items() | y.items())
</code></pre>

<p>For python3-like behavior in version 2.7, the <code>viewitems</code> method should work in place of <code>items</code>:</p>

<pre class="lang-py s-code-block"><code class="hljs language-python"><span class="hljs-built_in">dict</span>(x.viewitems() | y.viewitems())
</code></pre>

<p>I prefer this notation anyways since it seems more natural to think of it as a set union operation rather than concatenation (as the title shows).</p>

<p><strong>Edit:</strong></p>

<p>A couple more points for python 3. First, note that the <code>dict(x, **y)</code> trick won't work in python 3 unless the keys in <code>y</code> are strings.</p>

<p>Also, Raymond Hettinger's Chainmap <a href="https://stackoverflow.com/a/16259217/386279">answer</a> is pretty elegant, since it can take an arbitrary number of dicts as arguments, but <a href="http://docs.python.org/dev/library/collections" rel="noreferrer">from the docs</a> it looks like it sequentially looks through a list of all the dicts for each lookup:</p>

<blockquote>
  <p>Lookups search the underlying mappings successively until a key is found.</p>
</blockquote>

<p>This can slow you down if you have a lot of lookups in your application:</p>

<pre class="lang-py s-code-block"><code class="hljs language-python">In [<span class="hljs-number">1</span>]: <span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> ChainMap
In [<span class="hljs-number">2</span>]: <span class="hljs-keyword">from</span> string <span class="hljs-keyword">import</span> ascii_uppercase <span class="hljs-keyword">as</span> up, ascii_lowercase <span class="hljs-keyword">as</span> lo; x = <span class="hljs-built_in">dict</span>(<span class="hljs-built_in">zip</span>(lo, up)); y = <span class="hljs-built_in">dict</span>(<span class="hljs-built_in">zip</span>(up, lo))
In [<span class="hljs-number">3</span>]: chainmap_dict = ChainMap(y, x)
In [<span class="hljs-number">4</span>]: union_dict = <span class="hljs-built_in">dict</span>(x.items() | y.items())
In [<span class="hljs-number">5</span>]: timeit <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> union_dict: union_dict[k]
<span class="hljs-number">100000</span> loops, best of <span class="hljs-number">3</span>: <span class="hljs-number">2.15</span> µs per loop
In [<span class="hljs-number">6</span>]: timeit <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> chainmap_dict: chainmap_dict[k]
<span class="hljs-number">10000</span> loops, best of <span class="hljs-number">3</span>: <span class="hljs-number">27.1</span> µs per loop
</code></pre>

<p>So about an order of magnitude slower for lookups. I'm a fan of Chainmap, but looks less practical where there may be many lookups.</p>
    </div></div></div></div><div id="solution18" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 18</h4><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>I benchmarked the suggested with <a href="https://github.com/nschloe/perfplot" rel="noreferrer">perfplot</a> and found that the good old</p>
<pre class="lang-py s-code-block"><code class="hljs language-python">temp = x.copy()
temp.update(y)
</code></pre>
<p>is the fastest solution together with the new (Python 3.9+)</p>
<pre class="lang-py s-code-block"><code class="hljs language-python">x | y
</code></pre>
<p><a href="https://i.stack.imgur.com/z8pG1.png" rel="noreferrer"><img src="https://i.stack.imgur.com/z8pG1.png" alt="enter image description here"></a></p>
<hr>
<p>Code to reproduce the plot:</p>
<pre class="lang-py s-code-block"><code class="hljs language-python"><span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> ChainMap
<span class="hljs-keyword">from</span> itertools <span class="hljs-keyword">import</span> chain
<span class="hljs-keyword">import</span> perfplot


<span class="hljs-keyword">def</span> <span class="hljs-title function_">setup</span>(<span class="hljs-params">n</span>):
    x = <span class="hljs-built_in">dict</span>(<span class="hljs-built_in">zip</span>(<span class="hljs-built_in">range</span>(n), <span class="hljs-built_in">range</span>(n)))
    y = <span class="hljs-built_in">dict</span>(<span class="hljs-built_in">zip</span>(<span class="hljs-built_in">range</span>(n, <span class="hljs-number">2</span> * n), <span class="hljs-built_in">range</span>(n, <span class="hljs-number">2</span> * n)))
    <span class="hljs-keyword">return</span> x, y


<span class="hljs-keyword">def</span> <span class="hljs-title function_">copy_update</span>(<span class="hljs-params">data</span>):
    x, y = data
    temp = x.copy()
    temp.update(y)
    <span class="hljs-keyword">return</span> temp


<span class="hljs-keyword">def</span> <span class="hljs-title function_">add_items</span>(<span class="hljs-params">data</span>):
    x, y = data
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">dict</span>(<span class="hljs-built_in">list</span>(x.items()) + <span class="hljs-built_in">list</span>(y.items()))


<span class="hljs-keyword">def</span> <span class="hljs-title function_">curly_star</span>(<span class="hljs-params">data</span>):
    x, y = data
    <span class="hljs-keyword">return</span> {**x, **y}


<span class="hljs-keyword">def</span> <span class="hljs-title function_">chain_map</span>(<span class="hljs-params">data</span>):
    x, y = data
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">dict</span>(ChainMap({}, y, x))


<span class="hljs-keyword">def</span> <span class="hljs-title function_">itertools_chain</span>(<span class="hljs-params">data</span>):
    x, y = data
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">dict</span>(chain(x.items(), y.items()))


<span class="hljs-keyword">def</span> <span class="hljs-title function_">python39_concat</span>(<span class="hljs-params">data</span>):
    x, y = data
    <span class="hljs-keyword">return</span> x | y


b = perfplot.bench(
    setup=setup,
    kernels=[
        copy_update,
        add_items,
        curly_star,
        chain_map,
        itertools_chain,
        python39_concat,
    ],
    labels=[
        <span class="hljs-string">"copy_update"</span>,
        <span class="hljs-string">"dict(list(x.items()) + list(y.items()))"</span>,
        <span class="hljs-string">"{**x, **y}"</span>,
        <span class="hljs-string">"chain_map"</span>,
        <span class="hljs-string">"itertools.chain"</span>,
        <span class="hljs-string">"x | y"</span>,
    ],
    n_range=[<span class="hljs-number">2</span> ** k <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">18</span>)],
    xlabel=<span class="hljs-string">"len(x), len(y)"</span>,
    equality_check=<span class="hljs-literal">None</span>,
)
b.save(<span class="hljs-string">"out.png"</span>)
b.show()
</code></pre>
    </div></div></div></div><div id="solution19" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 19</h4><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p><strong>Two dictionaries</strong></p>

<pre class="lang-py s-code-block"><code class="hljs language-python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">union2</span>(<span class="hljs-params">dict1, dict2</span>):
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">dict</span>(<span class="hljs-built_in">list</span>(dict1.items()) + <span class="hljs-built_in">list</span>(dict2.items()))
</code></pre>

<p><strong><em>n</em> dictionaries</strong></p>

<pre class="lang-py s-code-block"><code class="hljs language-python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">union</span>(<span class="hljs-params">*dicts</span>):
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">dict</span>(itertools.chain.from_iterable(dct.items() <span class="hljs-keyword">for</span> dct <span class="hljs-keyword">in</span> dicts))
</code></pre>

<p><code>sum</code> has bad performance. See <a href="https://mathieularose.com/how-not-to-flatten-a-list-of-lists-in-python/" rel="noreferrer">https://mathieularose.com/how-not-to-flatten-a-list-of-lists-in-python/</a></p>
    </div></div></div></div><div id="solution20" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 20</h4><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Simple solution using itertools that preserves order (latter dicts have precedence)</p>
<pre class="lang-py s-code-block"><code class="hljs language-python"><span class="hljs-comment"># py2</span>
<span class="hljs-keyword">from</span> itertools <span class="hljs-keyword">import</span> chain, imap
merge = <span class="hljs-keyword">lambda</span> *args: <span class="hljs-built_in">dict</span>(chain.from_iterable(imap(<span class="hljs-built_in">dict</span>.iteritems, args)))

<span class="hljs-comment"># py3</span>
<span class="hljs-keyword">from</span> itertools <span class="hljs-keyword">import</span> chain
merge = <span class="hljs-keyword">lambda</span> *args: <span class="hljs-built_in">dict</span>(chain.from_iterable(<span class="hljs-built_in">map</span>(<span class="hljs-built_in">dict</span>.items, args)))
</code></pre>
<p>And it's usage:</p>
<pre class="lang-py s-code-block"><code class="hljs language-python"><span class="hljs-meta">&gt;&gt;&gt; </span>x = {<span class="hljs-string">'a'</span>:<span class="hljs-number">1</span>, <span class="hljs-string">'b'</span>: <span class="hljs-number">2</span>}
<span class="hljs-meta">&gt;&gt;&gt; </span>y = {<span class="hljs-string">'b'</span>:<span class="hljs-number">10</span>, <span class="hljs-string">'c'</span>: <span class="hljs-number">11</span>}
<span class="hljs-meta">&gt;&gt;&gt; </span>merge(x, y)
{<span class="hljs-string">'a'</span>: <span class="hljs-number">1</span>, <span class="hljs-string">'b'</span>: <span class="hljs-number">10</span>, <span class="hljs-string">'c'</span>: <span class="hljs-number">11</span>}

<span class="hljs-meta">&gt;&gt;&gt; </span>z = {<span class="hljs-string">'c'</span>: <span class="hljs-number">3</span>, <span class="hljs-string">'d'</span>: <span class="hljs-number">4</span>}
<span class="hljs-meta">&gt;&gt;&gt; </span>merge(x, y, z)
{<span class="hljs-string">'a'</span>: <span class="hljs-number">1</span>, <span class="hljs-string">'b'</span>: <span class="hljs-number">10</span>, <span class="hljs-string">'c'</span>: <span class="hljs-number">3</span>, <span class="hljs-string">'d'</span>: <span class="hljs-number">4</span>}
</code></pre>
    </div></div></div></div><div id="solution21" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 21</h4><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Abuse leading to a one-expression solution for <a href="https://stackoverflow.com/a/39437/15055">Matthew's answer</a>:</p>

<pre class="lang-py s-code-block"><code class="hljs language-python"><span class="hljs-meta">&gt;&gt;&gt; </span>x = {<span class="hljs-string">'a'</span>:<span class="hljs-number">1</span>, <span class="hljs-string">'b'</span>: <span class="hljs-number">2</span>}
<span class="hljs-meta">&gt;&gt;&gt; </span>y = {<span class="hljs-string">'b'</span>:<span class="hljs-number">10</span>, <span class="hljs-string">'c'</span>: <span class="hljs-number">11</span>}
<span class="hljs-meta">&gt;&gt;&gt; </span>z = (<span class="hljs-keyword">lambda</span> f=x.copy(): (f.update(y), f)[<span class="hljs-number">1</span>])()
<span class="hljs-meta">&gt;&gt;&gt; </span>z
{<span class="hljs-string">'a'</span>: <span class="hljs-number">1</span>, <span class="hljs-string">'c'</span>: <span class="hljs-number">11</span>, <span class="hljs-string">'b'</span>: <span class="hljs-number">10</span>}
</code></pre>

<p>You said you wanted one expression, so I abused <code>lambda</code> to bind a name, and tuples to override lambda's one-expression limit. Feel free to cringe.</p>

<p>You could also do this of course if you don't care about copying it:</p>

<pre class="lang-py s-code-block"><code class="hljs language-python"><span class="hljs-meta">&gt;&gt;&gt; </span>x = {<span class="hljs-string">'a'</span>:<span class="hljs-number">1</span>, <span class="hljs-string">'b'</span>: <span class="hljs-number">2</span>}
<span class="hljs-meta">&gt;&gt;&gt; </span>y = {<span class="hljs-string">'b'</span>:<span class="hljs-number">10</span>, <span class="hljs-string">'c'</span>: <span class="hljs-number">11</span>}
<span class="hljs-meta">&gt;&gt;&gt; </span>z = (x.update(y), x)[<span class="hljs-number">1</span>]
<span class="hljs-meta">&gt;&gt;&gt; </span>z
{<span class="hljs-string">'a'</span>: <span class="hljs-number">1</span>, <span class="hljs-string">'b'</span>: <span class="hljs-number">10</span>, <span class="hljs-string">'c'</span>: <span class="hljs-number">11</span>}
</code></pre>
    </div></div></div></div><div id="solution22" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 22</h4><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>If you don't mind mutating <code>x</code>,</p>
<pre class="lang-py s-code-block"><code class="hljs language-python">x.update(y) <span class="hljs-keyword">or</span> x
</code></pre>
<p>Simple, readable, performant. You <em>know</em> <code>update()</code> always returns <code>None</code>, which is a false value. So the above expression will always evaluate to <code>x</code>, after updating it.</p>
<p>Most mutating methods in the standard library (like <code>.update()</code>) return <code>None</code> by convention, so this kind of pattern will work on those too. However, if you're using a dict subclass or some other method that doesn't follow this convention, then <code>or</code> may return its left operand, which may not be what you want. Instead, you can use a tuple display and index, which works regardless of what the first element evaluates to (although it's not quite as pretty):</p>
<pre class="lang-py s-code-block"><code class="hljs language-python">(x.update(y), x)[-<span class="hljs-number">1</span>]
</code></pre>
<p>If you don't have <code>x</code> in a variable yet, you can use <code>lambda</code> to make a local without using an assignment statement. This amounts to using <code>lambda</code> as a <em>let expression</em>, which is a common technique in functional languages, but is maybe unpythonic.</p>
<pre class="lang-py s-code-block"><code class="hljs language-python">(<span class="hljs-keyword">lambda</span> x: x.update(y) <span class="hljs-keyword">or</span> x)({<span class="hljs-string">'a'</span>: <span class="hljs-number">1</span>, <span class="hljs-string">'b'</span>: <span class="hljs-number">2</span>})
</code></pre>
<p>Although it's not that different from the following use of the new walrus operator (Python 3.8+ only),</p>
<pre class="lang-py s-code-block"><code class="hljs language-python">(x := {<span class="hljs-string">'a'</span>: <span class="hljs-number">1</span>, <span class="hljs-string">'b'</span>: <span class="hljs-number">2</span>}).update(y) <span class="hljs-keyword">or</span> x
</code></pre>
<p>especially if you use a default argument:</p>
<pre class="lang-py s-code-block"><code class="hljs language-python">(<span class="hljs-keyword">lambda</span> x={<span class="hljs-string">'a'</span>: <span class="hljs-number">1</span>, <span class="hljs-string">'b'</span>: <span class="hljs-number">2</span>}: x.update(y) <span class="hljs-keyword">or</span> x)()
</code></pre>
<p>If you do want a copy, <a href="https://www.python.org/dev/peps/pep-0584/" rel="noreferrer">PEP 584</a> style <code>x | y</code> is the most Pythonic on 3.9+. If you must support older versions, <a href="https://www.python.org/dev/peps/pep-0448/" rel="noreferrer">PEP 448</a> style <code>{**x, **y}</code> is easiest for 3.5+. But if that's not available in your (even older) Python version, the <em>let expression</em> pattern works here too.</p>
<pre class="lang-py s-code-block"><code class="hljs language-python">(<span class="hljs-keyword">lambda</span> z=x.copy(): z.update(y) <span class="hljs-keyword">or</span> z)()
</code></pre>
<p>(That is, of course, nearly equivalent to <code>(z := x.copy()).update(y) or z</code>, but if your Python version is new enough for that, then the PEP 448 style will be available.)</p>
    </div></div></div></div><div id="solution23" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 23</h4><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p><strong><a href="https://www.python.org/dev/peps/pep-0584/#specification" rel="noreferrer">New</a> in Python 3.9:</strong> Use the union operator (<code>|</code>) to merge <code>dict</code>s similar to <code>set</code>s:</p>
<pre class="lang-py s-code-block"><code class="hljs language-python"><span class="hljs-meta">&gt;&gt;&gt; </span>d = {<span class="hljs-string">'a'</span>: <span class="hljs-number">1</span>, <span class="hljs-string">'b'</span>: <span class="hljs-number">2</span>}
<span class="hljs-meta">&gt;&gt;&gt; </span>e = {<span class="hljs-string">'a'</span>: <span class="hljs-number">9</span>, <span class="hljs-string">'c'</span>: <span class="hljs-number">3</span>}
<span class="hljs-meta">&gt;&gt;&gt; </span>d | e
{<span class="hljs-string">'a'</span>: <span class="hljs-number">9</span>, <span class="hljs-string">'b'</span>: <span class="hljs-number">2</span>, <span class="hljs-string">'c'</span>: <span class="hljs-number">3</span>}
</code></pre>
<p>For matching keys, the <strong>right <code>dict</code> takes precedence</strong>.</p>
<p>This also works for <code>|=</code> to modify a <code>dict</code> in-place:</p>
<pre class="lang-py s-code-block"><code class="hljs language-python"><span class="hljs-meta">&gt;&gt;&gt; </span>e |= d    <span class="hljs-comment"># e = e | d</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>e
{<span class="hljs-string">'a'</span>: <span class="hljs-number">1</span>, <span class="hljs-string">'c'</span>: <span class="hljs-number">3</span>, <span class="hljs-string">'b'</span>: <span class="hljs-number">2</span>}
</code></pre>
    </div></div></div></div><div id="solution24" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 24</h4><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Drawing on ideas here and elsewhere I've comprehended a function:</p>

<pre class="lang-py s-code-block"><code class="hljs language-python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">merge</span>(<span class="hljs-params">*dicts, **kv</span>): 
      <span class="hljs-keyword">return</span> { k:v <span class="hljs-keyword">for</span> d <span class="hljs-keyword">in</span> <span class="hljs-built_in">list</span>(dicts) + [kv] <span class="hljs-keyword">for</span> k,v <span class="hljs-keyword">in</span> d.items() }
</code></pre>

<p>Usage (tested in python 3):</p>

<pre class="lang-py s-code-block"><code class="hljs language-python"><span class="hljs-keyword">assert</span> (merge({<span class="hljs-number">1</span>:<span class="hljs-number">11</span>,<span class="hljs-string">'a'</span>:<span class="hljs-string">'aaa'</span>},{<span class="hljs-number">1</span>:<span class="hljs-number">99</span>, <span class="hljs-string">'b'</span>:<span class="hljs-string">'bbb'</span>},foo=<span class="hljs-string">'bar'</span>)==\
    {<span class="hljs-number">1</span>: <span class="hljs-number">99</span>, <span class="hljs-string">'foo'</span>: <span class="hljs-string">'bar'</span>, <span class="hljs-string">'b'</span>: <span class="hljs-string">'bbb'</span>, <span class="hljs-string">'a'</span>: <span class="hljs-string">'aaa'</span>})

<span class="hljs-keyword">assert</span> (merge(foo=<span class="hljs-string">'bar'</span>)=={<span class="hljs-string">'foo'</span>: <span class="hljs-string">'bar'</span>})

<span class="hljs-keyword">assert</span> (merge({<span class="hljs-number">1</span>:<span class="hljs-number">11</span>},{<span class="hljs-number">1</span>:<span class="hljs-number">99</span>},foo=<span class="hljs-string">'bar'</span>,baz=<span class="hljs-string">'quux'</span>)==\
    {<span class="hljs-number">1</span>: <span class="hljs-number">99</span>, <span class="hljs-string">'foo'</span>: <span class="hljs-string">'bar'</span>, <span class="hljs-string">'baz'</span>:<span class="hljs-string">'quux'</span>})

<span class="hljs-keyword">assert</span> (merge({<span class="hljs-number">1</span>:<span class="hljs-number">11</span>},{<span class="hljs-number">1</span>:<span class="hljs-number">99</span>})=={<span class="hljs-number">1</span>: <span class="hljs-number">99</span>})
</code></pre>

<p>You could use a lambda instead.</p>
    </div></div></div></div><div id="solution25" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 25</h4><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>It's so silly that <code>.update</code> returns nothing.<br>
I just use a simple helper function to solve the problem:</p>

<pre class="lang-py s-code-block"><code class="hljs language-python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">merge</span>(<span class="hljs-params">dict1,*dicts</span>):
    <span class="hljs-keyword">for</span> dict2 <span class="hljs-keyword">in</span> dicts:
        dict1.update(dict2)
    <span class="hljs-keyword">return</span> dict1
</code></pre>

<p>Examples:</p>

<pre class="lang-py s-code-block"><code class="hljs language-python">merge(dict1,dict2)
merge(dict1,dict2,dict3)
merge(dict1,dict2,dict3,dict4)
merge({},dict1,dict2)  <span class="hljs-comment"># this one returns a new copy</span>
</code></pre>
    </div></div></div></div><div id="solution26" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 26</h4><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>(For Python2.7* only; there are simpler solutions for Python3*.)</p>

<p>If you're not averse to importing a standard library module, you can do</p>

<pre class="lang-py s-code-block"><code class="hljs language-python"><span class="hljs-keyword">from</span> functools <span class="hljs-keyword">import</span> reduce

<span class="hljs-keyword">def</span> <span class="hljs-title function_">merge_dicts</span>(<span class="hljs-params">*dicts</span>):
    <span class="hljs-keyword">return</span> reduce(<span class="hljs-keyword">lambda</span> a, d: a.update(d) <span class="hljs-keyword">or</span> a, dicts, {})
</code></pre>

<p>(The <code>or a</code> bit in the <code>lambda</code> is necessary because <code>dict.update</code> always returns <code>None</code> on success.)</p>
    </div></div></div></div><div id="solution27" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 27</h4><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>The problem I have with solutions listed to date is that, in the merged dictionary, the value for key "b" is 10 but, to my way of thinking, it should be 12.
In that light, I present the following:</p>

<pre class="lang-py s-code-block"><code class="hljs language-python"><span class="hljs-keyword">import</span> timeit

n=<span class="hljs-number">100000</span>
su = <span class="hljs-string">"""
x = {'a':1, 'b': 2}
y = {'b':10, 'c': 11}
"""</span>

<span class="hljs-keyword">def</span> <span class="hljs-title function_">timeMerge</span>(<span class="hljs-params">f,su,niter</span>):
    <span class="hljs-built_in">print</span> <span class="hljs-string">"{:4f} sec for: {:30s}"</span>.<span class="hljs-built_in">format</span>(timeit.Timer(f,setup=su).timeit(n),f)

timeMerge(<span class="hljs-string">"dict(x, **y)"</span>,su,n)
timeMerge(<span class="hljs-string">"x.update(y)"</span>,su,n)
timeMerge(<span class="hljs-string">"dict(x.items() + y.items())"</span>,su,n)
timeMerge(<span class="hljs-string">"for k in y.keys(): x[k] = k in x and x[k]+y[k] or y[k] "</span>,su,n)

<span class="hljs-comment">#confirm for loop adds b entries together</span>
x = {<span class="hljs-string">'a'</span>:<span class="hljs-number">1</span>, <span class="hljs-string">'b'</span>: <span class="hljs-number">2</span>}
y = {<span class="hljs-string">'b'</span>:<span class="hljs-number">10</span>, <span class="hljs-string">'c'</span>: <span class="hljs-number">11</span>}
<span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> y.keys(): x[k] = k <span class="hljs-keyword">in</span> x <span class="hljs-keyword">and</span> x[k]+y[k] <span class="hljs-keyword">or</span> y[k]
<span class="hljs-built_in">print</span> <span class="hljs-string">"confirm b elements are added:"</span>,x
</code></pre>

<h1>Results:</h1>

<pre class="lang-py s-code-block"><code class="hljs language-python"><span class="hljs-number">0.049465</span> sec <span class="hljs-keyword">for</span>: <span class="hljs-built_in">dict</span>(x, **y)
<span class="hljs-number">0.033729</span> sec <span class="hljs-keyword">for</span>: x.update(y)                   
<span class="hljs-number">0.150380</span> sec <span class="hljs-keyword">for</span>: <span class="hljs-built_in">dict</span>(x.items() + y.items())   
<span class="hljs-number">0.083120</span> sec <span class="hljs-keyword">for</span>: <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> y.keys(): x[k] = k <span class="hljs-keyword">in</span> x <span class="hljs-keyword">and</span> x[k]+y[k] <span class="hljs-keyword">or</span> y[k]

confirm b elements are added: {<span class="hljs-string">'a'</span>: <span class="hljs-number">1</span>, <span class="hljs-string">'c'</span>: <span class="hljs-number">11</span>, <span class="hljs-string">'b'</span>: <span class="hljs-number">12</span>}
</code></pre>
    </div></div></div></div><div id="solution28" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 28</h4><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>There will be a new option when Python 3.8 releases (<a href="https://www.python.org/dev/peps/pep-0569/#release-schedule" rel="noreferrer">scheduled for 20 October, 2019</a>), thanks to <a href="https://www.python.org/dev/peps/pep-0572/" rel="noreferrer">PEP 572: Assignment Expressions</a>. The new assignment expression operator <code>:=</code> allows you to assign the result of the <code>copy</code> and still use it to call <code>update</code>, leaving the combined code a single expression, rather than two statements, changing:</p>

<pre class="lang-py s-code-block"><code class="hljs language-python">newdict = dict1.copy()
newdict.update(dict2)
</code></pre>

<p>to:</p>

<pre class="lang-py s-code-block"><code class="hljs language-python">(newdict := dict1.copy()).update(dict2)
</code></pre>

<p>while behaving identically in every way. If you must also return the resulting <code>dict</code> (you asked for an expression returning the <code>dict</code>; the above creates and assigns to <code>newdict</code>, but doesn't return it, so you couldn't use it to pass an argument to a function as is, a la <code>myfunc((newdict := dict1.copy()).update(dict2))</code>), then just add <code>or newdict</code> to the end (since <code>update</code> returns <code>None</code>, which is falsy, it will then evaluate and return <code>newdict</code> as the result of the expression):</p>

<pre class="lang-py s-code-block"><code class="hljs language-python">(newdict := dict1.copy()).update(dict2) <span class="hljs-keyword">or</span> newdict
</code></pre>

<p><strong>Important caveat:</strong> In general, I'd discourage this approach in favor of:</p>

<pre class="lang-py s-code-block"><code class="hljs language-python">newdict = {**dict1, **dict2}
</code></pre>

<p>The unpacking approach is clearer (to anyone who knows about generalized unpacking in the first place, <a href="https://www.python.org/dev/peps/pep-0448/" rel="noreferrer">which you should</a>), doesn't require a name for the result at all (so it's much more concise when constructing a temporary that is immediately passed to a function or included in a <code>list</code>/<code>tuple</code> literal or the like), and is almost certainly faster as well, being (on CPython) roughly equivalent to:</p>

<pre class="lang-py s-code-block"><code class="hljs language-python">newdict = {}
newdict.update(dict1)
newdict.update(dict2)
</code></pre>

<p>but done at the C layer, using the concrete <code>dict</code> API, so no dynamic method lookup/binding or function call dispatch overhead is involved (where <code>(newdict := dict1.copy()).update(dict2)</code> is unavoidably identical to the original two-liner in behavior, performing the work in discrete steps, with dynamic lookup/binding/invocation of methods.</p>

<p>It's also more extensible, as merging three <code>dict</code>s is obvious:</p>

<pre class="lang-py s-code-block"><code class="hljs language-python"> newdict = {**dict1, **dict2, **dict3}
</code></pre>

<p>where using assignment expressions won't scale like that; the closest you could get would be:</p>

<pre class="lang-py s-code-block"><code class="hljs language-python"> (newdict := dict1.copy()).update(dict2), newdict.update(dict3)
</code></pre>

<p>or without the temporary tuple of <code>None</code>s, but with truthiness testing of each <code>None</code> result:</p>

<pre class="lang-py s-code-block"><code class="hljs language-python"> (newdict := dict1.copy()).update(dict2) <span class="hljs-keyword">or</span> newdict.update(dict3)
</code></pre>

<p>either of which is obviously much uglier, and includes further inefficiencies (either a wasted temporary <code>tuple</code> of <code>None</code>s for comma separation, or pointless truthiness testing of each <code>update</code>'s <code>None</code> return for <code>or</code> separation).</p>

<p><strong>The only real advantage to the assignment expression approach occurs if:</strong></p>

<ol>
<li><strong>You have generic code that needs handle both <code>set</code>s and <code>dict</code>s</strong> (both of them support <code>copy</code> and <code>update</code>, so the code works roughly as you'd expect it to)</li>
<li><strong>You expect to receive arbitrary dict-like objects</strong>, not just <code>dict</code> itself, <strong>and must preserve the type and semantics of the left hand side</strong> (rather than ending up with a plain <code>dict</code>). While <code>myspecialdict({**speciala, **specialb})</code> might work, it would involve an extra temporary <code>dict</code>, and if <code>myspecialdict</code> has features plain <code>dict</code> can't preserve (e.g. regular <code>dict</code>s now preserve order based on the first appearance of a key, and value based on the last appearance of a key; you might want one that preserves order based on the <em>last</em> appearance of a key so updating a value also moves it to the end), then the semantics would be wrong. Since the assignment expression version uses the named methods (which are presumably overloaded to behave appropriately), it never creates a <code>dict</code> at all (unless <code>dict1</code> was already a <code>dict</code>), preserving the original type (and original type's semantics), all while avoiding any temporaries.</li>
</ol>
    </div></div></div></div><div id="solution29" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 29</h4><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<pre class="lang-py s-code-block"><code class="hljs language-python"><span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> Counter
dict1 = {<span class="hljs-string">'a'</span>:<span class="hljs-number">1</span>, <span class="hljs-string">'b'</span>: <span class="hljs-number">2</span>}
dict2 = {<span class="hljs-string">'b'</span>:<span class="hljs-number">10</span>, <span class="hljs-string">'c'</span>: <span class="hljs-number">11</span>}
result = <span class="hljs-built_in">dict</span>(Counter(dict1) + Counter(dict2))
</code></pre>

<p>This should solve your problem.</p>
    </div></div></div></div><div id="solution30" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 30</h4><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>This can be done with a single dict comprehension:</p>

<pre class="lang-py s-code-block"><code class="hljs language-python"><span class="hljs-meta">&gt;&gt;&gt; </span>x = {<span class="hljs-string">'a'</span>:<span class="hljs-number">1</span>, <span class="hljs-string">'b'</span>: <span class="hljs-number">2</span>}
<span class="hljs-meta">&gt;&gt;&gt; </span>y = {<span class="hljs-string">'b'</span>:<span class="hljs-number">10</span>, <span class="hljs-string">'c'</span>: <span class="hljs-number">11</span>}
<span class="hljs-meta">&gt;&gt;&gt; </span>{ key: y[key] <span class="hljs-keyword">if</span> key <span class="hljs-keyword">in</span> y <span class="hljs-keyword">else</span> x[key]
      <span class="hljs-keyword">for</span> key <span class="hljs-keyword">in</span> <span class="hljs-built_in">set</span>(x) + <span class="hljs-built_in">set</span>(y)
    }
</code></pre>

<p>In my view the best answer for the 'single expression' part as no extra functions are needed, and it is short.</p>
    </div></div></div></div></div></div><div class="widget"><a href="/questions/when-should-static_cast-dynamic_cast-const_cast-and-reinterpret_cast-be-used-1657388406205">When should static_cast, dynamic_cast, const_cast, and reinterpret_cast be used?</a><a href="/questions/jquery-dollar-is-not-defined-1657388385731">JQuery - $ is not defined</a><a href="/questions/why-is-using-%22for...in%22-for-array-iteration-a-bad-idea-1657384653458">Why is using &quot;for...in&quot; for array iteration a bad idea?</a><a href="/questions/what-does-the-comma-operator-do-1657388258021">What does the comma operator , do?</a><a href="/questions/how-do-i-split-a-list-into-equally-sized-chunks-1657384580399">How do I split a list into equally-sized chunks?</a><a href="/questions/when-to-use-linkedlist-over-arraylist-in-java-1657388107480">When to use LinkedList over ArrayList in Java?</a><a href="/questions/how-do-i-pass-javascript-variables-to-php-1657388157033">How do I pass JavaScript variables to PHP?</a><a href="/questions/how-to-add-to-the-pythonpath-in-windows-so-it-finds-my-modulespackages-1657388540360">How to add to the PYTHONPATH in Windows, so it finds my modules/packages?</a><a href="/questions/why-not-use-double-or-float-to-represent-currency-1657387417964">Why not use Double or Float to represent currency?</a><a href="/questions/what-are-drawbacks-or-disadvantages-of-singleton-pattern-closed-1657387360749">What are drawbacks or disadvantages of singleton pattern? [closed]</a><a href="/questions/what-are-the-rules-about-using-an-underscore-in-a-c++-identifier-1657384557197">What are the rules about using an underscore in a C++ identifier?</a><a href="/questions/why-is-the-gets-function-so-dangerous-that-it-should-not-be-used-1657384544362">Why is the gets function so dangerous that it should not be used?</a><a href="/questions/what-is-the-difference-between-and-equals()-in-java-1657387729654">What is the difference between == and equals() in Java?</a><a href="/questions/retrieve-only-the-queried-element-in-an-object-array-in-mongodb-collection-1657384890457">Retrieve only the queried element in an object array in MongoDB collection</a><a href="/questions/php-failed-to-open-stream-:-no-such-file-or-directory-1657387872896">PHP - Failed to open stream : No such file or directory</a><a href="/questions/how-to-make-a-div-100percent-height-of-the-browser-window-1657388265955">How to make a div 100% height of the browser window</a><a href="/questions/parameterize-an-sql-in-clause-1657387536064">Parameterize an SQL IN clause</a><a href="/questions/tkinter:-attributeerror:-nonetype-object-has-no-attribute-lessattribute-namegreater-1657385472410">Tkinter: AttributeError: NoneType object has no attribute &lt;attribute name&gt;</a><a href="/questions/what-are-the-nuances-of-scope-prototypal-prototypical-inheritance-in-angularjs-1657387340067">What are the nuances of scope prototypal / prototypical inheritance in AngularJS?</a><a href="/questions/flexbox:-center-horizontally-and-vertically-1657384587888">Flexbox: center horizontally and vertically</a></div></div><span class="cursor-pointer text-lg p-2" style="position:fixed;bottom:20px;left:20px;background:#000;z-index:2000;color:white">Go go top</span></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"data":{"answer":["\n\u0026lt;h2\u0026gt;How can I merge two Python dictionaries in a single expression?\u0026lt;/h2\u0026gt;\n\u0026lt;p\u0026gt;For dictionaries \u0026lt;code\u0026gt;x\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;y\u0026lt;/code\u0026gt;, their shallowly-merged dictionary \u0026lt;code\u0026gt;z\u0026lt;/code\u0026gt; takes values from \u0026lt;code\u0026gt;y\u0026lt;/code\u0026gt;, replacing those from \u0026lt;code\u0026gt;x\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;In Python 3.9.0 or greater (released 17 October 2020, \u0026lt;a href=\u0026quot;https://www.python.org/dev/peps/pep-0584/\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;\u0026lt;code\u0026gt;PEP-584\u0026lt;/code\u0026gt;\u0026lt;/a\u0026gt;, \u0026lt;a href=\u0026quot;https://bugs.python.org/issue36144\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;discussed here\u0026lt;/a\u0026gt;):\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;z = x | y\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;In Python 3.5 or greater:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;z = {**x, **y}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;In Python 2, (or 3.4 or lower) write a function:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;def\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;merge_two_dicts\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;x, y\u0026lt;/span\u0026gt;):\n    z = x.copy()   \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;# start with keys and values of x\u0026lt;/span\u0026gt;\n    z.update(y)    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;# modifies z with keys and values of y\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; z\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;and now:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;z = merge_two_dicts(x, y)\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;h3\u0026gt;Explanation\u0026lt;/h3\u0026gt;\n\u0026lt;p\u0026gt;Say you have two dictionaries and you want to merge them into a new dictionary without altering the original dictionaries:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;x = {\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;a\u0026apos;\u0026lt;/span\u0026gt;: \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;b\u0026apos;\u0026lt;/span\u0026gt;: \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;}\ny = {\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;b\u0026apos;\u0026lt;/span\u0026gt;: \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;c\u0026apos;\u0026lt;/span\u0026gt;: \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;4\u0026lt;/span\u0026gt;}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;The desired result is to get a new dictionary (\u0026lt;code\u0026gt;z\u0026lt;/code\u0026gt;) with the values merged, and the second dictionary\u0026apos;s values overwriting those from the first.\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026amp;gt; \u0026lt;/span\u0026gt;z\n{\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;a\u0026apos;\u0026lt;/span\u0026gt;: \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;b\u0026apos;\u0026lt;/span\u0026gt;: \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;c\u0026apos;\u0026lt;/span\u0026gt;: \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;4\u0026lt;/span\u0026gt;}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;A new syntax for this, proposed in \u0026lt;a href=\u0026quot;https://www.python.org/dev/peps/pep-0448\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;PEP 448\u0026lt;/a\u0026gt; and \u0026lt;a href=\u0026quot;https://mail.python.org/pipermail/python-dev/2015-February/138564.html\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;available as of Python 3.5\u0026lt;/a\u0026gt;, is\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;z = {**x, **y}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;And it is indeed a single expression.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Note that we can merge in with literal notation as well:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;z = {**x, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;foo\u0026apos;\u0026lt;/span\u0026gt;: \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;bar\u0026apos;\u0026lt;/span\u0026gt;: \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;, **y}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;and now:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026amp;gt; \u0026lt;/span\u0026gt;z\n{\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;a\u0026apos;\u0026lt;/span\u0026gt;: \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;b\u0026apos;\u0026lt;/span\u0026gt;: \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;foo\u0026apos;\u0026lt;/span\u0026gt;: \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;bar\u0026apos;\u0026lt;/span\u0026gt;: \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;c\u0026apos;\u0026lt;/span\u0026gt;: \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;4\u0026lt;/span\u0026gt;}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;It is now showing as implemented in the \u0026lt;a href=\u0026quot;https://www.python.org/dev/peps/pep-0478/#features-for-3-5\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;release schedule for 3.5, PEP 478\u0026lt;/a\u0026gt;, and it has now made its way into the \u0026lt;a href=\u0026quot;https://docs.python.org/dev/whatsnew/3.5.html#pep-448-additional-unpacking-generalizations\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;What\u0026apos;s New in Python 3.5\u0026lt;/a\u0026gt; document.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;However, since many organizations are still on Python 2, you may wish to do this in a backward-compatible way. The classically Pythonic way, available in Python 2 and Python 3.0-3.4, is to do this as a two-step process:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;z = x.copy()\nz.update(y) \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;# which returns None since it mutates z\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;In both approaches, \u0026lt;code\u0026gt;y\u0026lt;/code\u0026gt; will come second and its values will replace \u0026lt;code\u0026gt;x\u0026lt;/code\u0026gt;\u0026apos;s values, thus \u0026lt;code\u0026gt;b\u0026lt;/code\u0026gt; will point to \u0026lt;code\u0026gt;3\u0026lt;/code\u0026gt; in our final result.\u0026lt;/p\u0026gt;\n\u0026lt;h2\u0026gt;Not yet on Python 3.5, but want a \u0026lt;em\u0026gt;single expression\u0026lt;/em\u0026gt;\u0026lt;/h2\u0026gt;\n\u0026lt;p\u0026gt;If you are not yet on Python 3.5 or need to write backward-compatible code, and you want this in a \u0026lt;em\u0026gt;single expression\u0026lt;/em\u0026gt;, the most performant while the correct approach is to put it in a function:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;def\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;merge_two_dicts\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;x, y\u0026lt;/span\u0026gt;):\n    \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;\u0026quot;\u0026quot;Given two dictionaries, merge them into a new dict as a shallow copy.\u0026quot;\u0026quot;\u0026quot;\u0026lt;/span\u0026gt;\n    z = x.copy()\n    z.update(y)\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; z\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;and then you have a single expression:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;z = merge_two_dicts(x, y)\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;You can also make a function to merge an arbitrary number of dictionaries, from zero to a very large number:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;def\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;merge_dicts\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;*dict_args\u0026lt;/span\u0026gt;):\n    \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;\u0026quot;\u0026quot;\n    Given any number of dictionaries, shallow copy and merge into a new dict,\n    precedence goes to key-value pairs in latter dictionaries.\n    \u0026quot;\u0026quot;\u0026quot;\u0026lt;/span\u0026gt;\n    result = {}\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt; dictionary \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;in\u0026lt;/span\u0026gt; dict_args:\n        result.update(dictionary)\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; result\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;This function will work in Python 2 and 3 for all dictionaries. e.g. given dictionaries \u0026lt;code\u0026gt;a\u0026lt;/code\u0026gt; to \u0026lt;code\u0026gt;g\u0026lt;/code\u0026gt;:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;z = merge_dicts(a, b, c, d, e, f, g) \n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;and key-value pairs in \u0026lt;code\u0026gt;g\u0026lt;/code\u0026gt; will take precedence over dictionaries \u0026lt;code\u0026gt;a\u0026lt;/code\u0026gt; to \u0026lt;code\u0026gt;f\u0026lt;/code\u0026gt;, and so on.\u0026lt;/p\u0026gt;\n\u0026lt;h2\u0026gt;Critiques of Other Answers\u0026lt;/h2\u0026gt;\n\u0026lt;p\u0026gt;Don\u0026apos;t use what you see in the formerly accepted answer:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;z = \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;dict\u0026lt;/span\u0026gt;(x.items() + y.items())\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;In Python 2, you create two lists in memory for each dict, create a third list in memory with length equal to the length of the first two put together, and then discard all three lists to create the dict. \u0026lt;strong\u0026gt;In Python 3, this will fail\u0026lt;/strong\u0026gt; because you\u0026apos;re adding two \u0026lt;code\u0026gt;dict_items\u0026lt;/code\u0026gt; objects together, not two lists -\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026amp;gt; \u0026lt;/span\u0026gt;c = \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;dict\u0026lt;/span\u0026gt;(a.items() + b.items())\nTraceback (most recent call last):\n  File \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;\u0026amp;lt;stdin\u0026amp;gt;\u0026quot;\u0026lt;/span\u0026gt;, line \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;in\u0026lt;/span\u0026gt; \u0026amp;lt;module\u0026amp;gt;\nTypeError: unsupported operand \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;type\u0026lt;/span\u0026gt;(s) \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt; +: \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;dict_items\u0026apos;\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;and\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;dict_items\u0026apos;\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;and you would have to explicitly create them as lists, e.g. \u0026lt;code\u0026gt;z = dict(list(x.items()) + list(y.items()))\u0026lt;/code\u0026gt;. This is a waste of resources and computation power.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Similarly, taking the union of \u0026lt;code\u0026gt;items()\u0026lt;/code\u0026gt; in Python 3 (\u0026lt;code\u0026gt;viewitems()\u0026lt;/code\u0026gt; in Python 2.7) will also fail when values are unhashable objects (like lists, for example). Even if your values are hashable, \u0026lt;strong\u0026gt;since sets are semantically unordered, the behavior is undefined in regards to precedence. So don\u0026apos;t do this:\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026amp;gt; \u0026lt;/span\u0026gt;c = \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;dict\u0026lt;/span\u0026gt;(a.items() | b.items())\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;This example demonstrates what happens when values are unhashable:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026amp;gt; \u0026lt;/span\u0026gt;x = {\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;a\u0026apos;\u0026lt;/span\u0026gt;: []}\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026amp;gt; \u0026lt;/span\u0026gt;y = {\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;b\u0026apos;\u0026lt;/span\u0026gt;: []}\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026amp;gt; \u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;dict\u0026lt;/span\u0026gt;(x.items() | y.items())\nTraceback (most recent call last):\n  File \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;\u0026amp;lt;stdin\u0026amp;gt;\u0026quot;\u0026lt;/span\u0026gt;, line \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;in\u0026lt;/span\u0026gt; \u0026amp;lt;module\u0026amp;gt;\nTypeError: unhashable \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;type\u0026lt;/span\u0026gt;: \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;list\u0026apos;\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;Here\u0026apos;s an example where \u0026lt;code\u0026gt;y\u0026lt;/code\u0026gt; should have precedence, but instead the value from \u0026lt;code\u0026gt;x\u0026lt;/code\u0026gt; is retained due to the arbitrary order of sets:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026amp;gt; \u0026lt;/span\u0026gt;x = {\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;a\u0026apos;\u0026lt;/span\u0026gt;: \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;}\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026amp;gt; \u0026lt;/span\u0026gt;y = {\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;a\u0026apos;\u0026lt;/span\u0026gt;: \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;}\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026amp;gt; \u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;dict\u0026lt;/span\u0026gt;(x.items() | y.items())\n{\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;a\u0026apos;\u0026lt;/span\u0026gt;: \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;Another hack you should not use:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;z = \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;dict\u0026lt;/span\u0026gt;(x, **y)\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;This uses the \u0026lt;code\u0026gt;dict\u0026lt;/code\u0026gt; constructor and is very fast and memory-efficient (even slightly more so than our two-step process) but unless you know precisely what is happening here (that is, the second dict is being passed as keyword arguments to the dict constructor), it\u0026apos;s difficult to read, it\u0026apos;s not the intended usage, and so it is not Pythonic.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Here\u0026apos;s an example of the usage being \u0026lt;a href=\u0026quot;https://code.djangoproject.com/attachment/ticket/13357/django-pypy.2.diff\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;remediated in django\u0026lt;/a\u0026gt;.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Dictionaries are intended to take hashable keys (e.g. \u0026lt;code\u0026gt;frozenset\u0026lt;/code\u0026gt;s or tuples), but \u0026lt;strong\u0026gt;this method fails in Python 3 when keys are not strings.\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026amp;gt; \u0026lt;/span\u0026gt;c = \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;dict\u0026lt;/span\u0026gt;(a, **b)\nTraceback (most recent call last):\n  File \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;\u0026amp;lt;stdin\u0026amp;gt;\u0026quot;\u0026lt;/span\u0026gt;, line \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;in\u0026lt;/span\u0026gt; \u0026amp;lt;module\u0026amp;gt;\nTypeError: keyword arguments must be strings\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;From the \u0026lt;a href=\u0026quot;https://mail.python.org/pipermail/python-dev/2010-April/099459.html\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;mailing list\u0026lt;/a\u0026gt;, Guido van Rossum, the creator of the language, wrote:\u0026lt;/p\u0026gt;\n\u0026lt;blockquote\u0026gt;\n\u0026lt;p\u0026gt;I am fine with\ndeclaring dict({}, **{1:3}) illegal, since after all it is abuse of\nthe ** mechanism.\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\u0026lt;p\u0026gt;and\u0026lt;/p\u0026gt;\n\u0026lt;blockquote\u0026gt;\n\u0026lt;p\u0026gt;Apparently dict(x, **y) is going around as \u0026quot;cool hack\u0026quot; for \u0026quot;call\nx.update(y) and return x\u0026quot;. Personally, I find it more despicable than\ncool.\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\u0026lt;p\u0026gt;It is my understanding (as well as the understanding of the \u0026lt;a href=\u0026quot;https://mail.python.org/pipermail/python-dev/2010-April/099485.html\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;creator of the language\u0026lt;/a\u0026gt;) that the intended usage for \u0026lt;code\u0026gt;dict(**y)\u0026lt;/code\u0026gt; is for creating dictionaries for readability purposes, e.g.:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;dict\u0026lt;/span\u0026gt;(a=\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;, b=\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;10\u0026lt;/span\u0026gt;, c=\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;11\u0026lt;/span\u0026gt;)\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;instead of\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;{\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;a\u0026apos;\u0026lt;/span\u0026gt;: \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;b\u0026apos;\u0026lt;/span\u0026gt;: \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;10\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;c\u0026apos;\u0026lt;/span\u0026gt;: \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;11\u0026lt;/span\u0026gt;}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;h2\u0026gt;Response to comments\u0026lt;/h2\u0026gt;\n\u0026lt;blockquote\u0026gt;\n\u0026lt;p\u0026gt;Despite what Guido says, \u0026lt;code\u0026gt;dict(x, **y)\u0026lt;/code\u0026gt; is in line with the dict specification, which btw. works for both Python 2 and 3. The fact that this only works for string keys is a direct consequence of how keyword parameters work and not a short-coming of dict. Nor is using the ** operator in this place an abuse of the mechanism, in fact, ** was designed precisely to pass dictionaries as keywords.\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\u0026lt;p\u0026gt;Again, it doesn\u0026apos;t work for 3 when keys are not strings. The implicit calling contract is that namespaces take ordinary dictionaries, while users must only pass keyword arguments that are strings. All other callables enforced it. \u0026lt;code\u0026gt;dict\u0026lt;/code\u0026gt; broke this consistency in Python 2:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026amp;gt; \u0026lt;/span\u0026gt;foo(**{(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;a\u0026apos;\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;b\u0026apos;\u0026lt;/span\u0026gt;): \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;None\u0026lt;/span\u0026gt;})\nTraceback (most recent call last):\n  File \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;\u0026amp;lt;stdin\u0026amp;gt;\u0026quot;\u0026lt;/span\u0026gt;, line \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;in\u0026lt;/span\u0026gt; \u0026amp;lt;module\u0026amp;gt;\nTypeError: foo() keywords must be strings\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026amp;gt; \u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;dict\u0026lt;/span\u0026gt;(**{(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;a\u0026apos;\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;b\u0026apos;\u0026lt;/span\u0026gt;): \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;None\u0026lt;/span\u0026gt;})\n{(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;a\u0026apos;\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;b\u0026apos;\u0026lt;/span\u0026gt;): \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;None\u0026lt;/span\u0026gt;}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;This inconsistency was bad given other implementations of Python (PyPy, Jython, IronPython). Thus it was fixed in Python 3, as this usage could be a breaking change.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;I submit to you that it is malicious incompetence to intentionally write code that only works in one version of a language or that only works given certain arbitrary constraints.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;More comments:\u0026lt;/p\u0026gt;\n\u0026lt;blockquote\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;code\u0026gt;dict(x.items() + y.items())\u0026lt;/code\u0026gt; is still the most readable solution for Python 2. Readability counts.\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\u0026lt;p\u0026gt;My response: \u0026lt;code\u0026gt;merge_two_dicts(x, y)\u0026lt;/code\u0026gt; actually seems much clearer to me, if we\u0026apos;re actually concerned about readability. And it is not forward compatible, as Python 2 is increasingly deprecated.\u0026lt;/p\u0026gt;\n\u0026lt;blockquote\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;code\u0026gt;{**x, **y}\u0026lt;/code\u0026gt; does not seem to handle nested dictionaries. the contents of nested keys are simply overwritten, not merged [...] I ended up being burnt by these answers that do not merge recursively and I was surprised no one mentioned it. In my interpretation of the word \u0026quot;merging\u0026quot; these answers describe \u0026quot;updating one dict with another\u0026quot;, and not merging.\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\u0026lt;p\u0026gt;Yes. I must refer you back to the question, which is asking for a \u0026lt;em\u0026gt;shallow\u0026lt;/em\u0026gt; merge of \u0026lt;em\u0026gt;\u0026lt;strong\u0026gt;two\u0026lt;/strong\u0026gt;\u0026lt;/em\u0026gt; dictionaries, with the first\u0026apos;s values being overwritten by the second\u0026apos;s - in a single expression.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Assuming two dictionaries of dictionaries, one might recursively merge them in a single function, but you should be careful not to modify the dictionaries from either source, and the surest way to avoid that is to make a copy when assigning values. As keys must be hashable and are usually therefore immutable, it is pointless to copy them:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;from\u0026lt;/span\u0026gt; copy \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;import\u0026lt;/span\u0026gt; deepcopy\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;def\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;dict_of_dicts_merge\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;x, y\u0026lt;/span\u0026gt;):\n    z = {}\n    overlapping_keys = x.keys() \u0026amp;amp; y.keys()\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt; key \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;in\u0026lt;/span\u0026gt; overlapping_keys:\n        z[key] = dict_of_dicts_merge(x[key], y[key])\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt; key \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;in\u0026lt;/span\u0026gt; x.keys() - overlapping_keys:\n        z[key] = deepcopy(x[key])\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt; key \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;in\u0026lt;/span\u0026gt; y.keys() - overlapping_keys:\n        z[key] = deepcopy(y[key])\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; z\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;Usage:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026amp;gt; \u0026lt;/span\u0026gt;x = {\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;a\u0026apos;\u0026lt;/span\u0026gt;:{\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;:{}}, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;b\u0026apos;\u0026lt;/span\u0026gt;: {\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;:{}}}\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026amp;gt; \u0026lt;/span\u0026gt;y = {\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;b\u0026apos;\u0026lt;/span\u0026gt;:{\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;10\u0026lt;/span\u0026gt;:{}}, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;c\u0026apos;\u0026lt;/span\u0026gt;: {\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;11\u0026lt;/span\u0026gt;:{}}}\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026amp;gt; \u0026lt;/span\u0026gt;dict_of_dicts_merge(x, y)\n{\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;b\u0026apos;\u0026lt;/span\u0026gt;: {\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;: {}, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;10\u0026lt;/span\u0026gt;: {}}, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;a\u0026apos;\u0026lt;/span\u0026gt;: {\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;: {}}, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;c\u0026apos;\u0026lt;/span\u0026gt;: {\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;11\u0026lt;/span\u0026gt;: {}}}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;Coming up with contingencies for other value types is far beyond the scope of this question, so I will point you at \u0026lt;a href=\u0026quot;https://stackoverflow.com/a/24088493/541136\u0026quot;\u0026gt;my answer to the canonical question on a \u0026quot;Dictionaries of dictionaries merge\u0026quot;\u0026lt;/a\u0026gt;.\u0026lt;/p\u0026gt;\n\u0026lt;h2\u0026gt;Less Performant But Correct Ad-hocs\u0026lt;/h2\u0026gt;\n\u0026lt;p\u0026gt;These approaches are less performant, but they will provide correct behavior.\nThey will be \u0026lt;em\u0026gt;much less\u0026lt;/em\u0026gt; performant than \u0026lt;code\u0026gt;copy\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;update\u0026lt;/code\u0026gt; or the new unpacking because they iterate through each key-value pair at a higher level of abstraction, but they \u0026lt;em\u0026gt;do\u0026lt;/em\u0026gt; respect the order of precedence (latter dictionaries have precedence)\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;You can also chain the dictionaries manually inside a \u0026lt;a href=\u0026quot;https://www.python.org/dev/peps/pep-0274/\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;dict comprehension\u0026lt;/a\u0026gt;:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;{k: v \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt; d \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;in\u0026lt;/span\u0026gt; dicts \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt; k, v \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;in\u0026lt;/span\u0026gt; d.items()} \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;# iteritems in Python 2.7\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;or in Python 2.6 (and perhaps as early as 2.4 when generator expressions were introduced):\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;dict\u0026lt;/span\u0026gt;((k, v) \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt; d \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;in\u0026lt;/span\u0026gt; dicts \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt; k, v \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;in\u0026lt;/span\u0026gt; d.items()) \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;# iteritems in Python 2\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;code\u0026gt;itertools.chain\u0026lt;/code\u0026gt; will chain the iterators over the key-value pairs in the correct order:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;from\u0026lt;/span\u0026gt; itertools \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;import\u0026lt;/span\u0026gt; chain\nz = \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;dict\u0026lt;/span\u0026gt;(chain(x.items(), y.items())) \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;# iteritems in Python 2\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;h2\u0026gt;Performance Analysis\u0026lt;/h2\u0026gt;\n\u0026lt;p\u0026gt;I\u0026apos;m only going to do the performance analysis of the usages known to behave correctly. (Self-contained so you can copy and paste yourself.)\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;from\u0026lt;/span\u0026gt; timeit \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;import\u0026lt;/span\u0026gt; repeat\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;from\u0026lt;/span\u0026gt; itertools \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;import\u0026lt;/span\u0026gt; chain\n\nx = \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;dict\u0026lt;/span\u0026gt;.fromkeys(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;abcdefg\u0026apos;\u0026lt;/span\u0026gt;)\ny = \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;dict\u0026lt;/span\u0026gt;.fromkeys(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;efghijk\u0026apos;\u0026lt;/span\u0026gt;)\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;def\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;merge_two_dicts\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;x, y\u0026lt;/span\u0026gt;):\n    z = x.copy()\n    z.update(y)\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; z\n\n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;min\u0026lt;/span\u0026gt;(repeat(\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;lambda\u0026lt;/span\u0026gt;: {**x, **y}))\n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;min\u0026lt;/span\u0026gt;(repeat(\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;lambda\u0026lt;/span\u0026gt;: merge_two_dicts(x, y)))\n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;min\u0026lt;/span\u0026gt;(repeat(\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;lambda\u0026lt;/span\u0026gt;: {k: v \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt; d \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;in\u0026lt;/span\u0026gt; (x, y) \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt; k, v \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;in\u0026lt;/span\u0026gt; d.items()}))\n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;min\u0026lt;/span\u0026gt;(repeat(\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;lambda\u0026lt;/span\u0026gt;: \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;dict\u0026lt;/span\u0026gt;(chain(x.items(), y.items()))))\n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;min\u0026lt;/span\u0026gt;(repeat(\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;lambda\u0026lt;/span\u0026gt;: \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;dict\u0026lt;/span\u0026gt;(item \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt; d \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;in\u0026lt;/span\u0026gt; (x, y) \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt; item \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;in\u0026lt;/span\u0026gt; d.items())))\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;In Python 3.8.1, NixOS:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026amp;gt; \u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;min\u0026lt;/span\u0026gt;(repeat(\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;lambda\u0026lt;/span\u0026gt;: {**x, **y}))\n\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1.0804965235292912\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026amp;gt; \u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;min\u0026lt;/span\u0026gt;(repeat(\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;lambda\u0026lt;/span\u0026gt;: merge_two_dicts(x, y)))\n\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1.636518670246005\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026amp;gt; \u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;min\u0026lt;/span\u0026gt;(repeat(\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;lambda\u0026lt;/span\u0026gt;: {k: v \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt; d \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;in\u0026lt;/span\u0026gt; (x, y) \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt; k, v \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;in\u0026lt;/span\u0026gt; d.items()}))\n\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3.1779992282390594\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026amp;gt; \u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;min\u0026lt;/span\u0026gt;(repeat(\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;lambda\u0026lt;/span\u0026gt;: \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;dict\u0026lt;/span\u0026gt;(chain(x.items(), y.items()))))\n\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2.740647904574871\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026amp;gt; \u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;min\u0026lt;/span\u0026gt;(repeat(\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;lambda\u0026lt;/span\u0026gt;: \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;dict\u0026lt;/span\u0026gt;(item \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt; d \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;in\u0026lt;/span\u0026gt; (x, y) \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt; item \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;in\u0026lt;/span\u0026gt; d.items())))\n\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;4.266070580109954\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-sh s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-bash\u0026quot;\u0026gt;$ \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;uname\u0026lt;/span\u0026gt; -a\nLinux nixos 4.19.113 \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;#1-NixOS SMP Wed Mar 25 07:06:15 UTC 2020 x86_64 GNU/Linux\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;h2\u0026gt;Resources on Dictionaries\u0026lt;/h2\u0026gt;\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;a href=\u0026quot;https://stackoverflow.com/questions/327311/how-are-pythons-built-in-dictionaries-implemented/44509302#44509302\u0026quot;\u0026gt;My explanation of Python\u0026apos;s \u0026lt;strong\u0026gt;dictionary implementation\u0026lt;/strong\u0026gt;, updated for 3.6.\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;a href=\u0026quot;https://stackoverflow.com/questions/1024847/add-new-keys-to-a-dictionary/27208535#27208535\u0026quot;\u0026gt;Answer on how to add new keys to a dictionary\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;a href=\u0026quot;https://stackoverflow.com/questions/209840/map-two-lists-into-a-dictionary-in-python/33737067#33737067\u0026quot;\u0026gt;Mapping two lists into a dictionary\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;a href=\u0026quot;https://docs.python.org/3/tutorial/datastructures.html#dictionaries\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;The official Python docs on dictionaries\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;a href=\u0026quot;https://www.youtube.com/watch?v=66P5FMkWoVU\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;The Dictionary Even Mightier\u0026lt;/a\u0026gt; - talk by Brandon Rhodes at Pycon 2017\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;a href=\u0026quot;https://www.youtube.com/watch?v=npw4s1QTmPg\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;Modern Python Dictionaries, A Confluence of Great Ideas\u0026lt;/a\u0026gt; - talk by Raymond Hettinger at Pycon 2017\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n    ","\n\u0026lt;p\u0026gt;In your case, what you can do is:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;z = \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;dict\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;list\u0026lt;/span\u0026gt;(x.items()) + \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;list\u0026lt;/span\u0026gt;(y.items()))\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;This will, as you want it, put the final dict in \u0026lt;code\u0026gt;z\u0026lt;/code\u0026gt;, and make the value for key \u0026lt;code\u0026gt;b\u0026lt;/code\u0026gt; be properly overridden by the second (\u0026lt;code\u0026gt;y\u0026lt;/code\u0026gt;) dict\u0026apos;s value:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026amp;gt; \u0026lt;/span\u0026gt;x = {\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;a\u0026apos;\u0026lt;/span\u0026gt;:\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;b\u0026apos;\u0026lt;/span\u0026gt;: \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;}\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026amp;gt; \u0026lt;/span\u0026gt;y = {\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;b\u0026apos;\u0026lt;/span\u0026gt;:\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;10\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;c\u0026apos;\u0026lt;/span\u0026gt;: \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;11\u0026lt;/span\u0026gt;}\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026amp;gt; \u0026lt;/span\u0026gt;z = \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;dict\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;list\u0026lt;/span\u0026gt;(x.items()) + \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;list\u0026lt;/span\u0026gt;(y.items()))\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026amp;gt; \u0026lt;/span\u0026gt;z\n{\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;a\u0026apos;\u0026lt;/span\u0026gt;: \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;c\u0026apos;\u0026lt;/span\u0026gt;: \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;11\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;b\u0026apos;\u0026lt;/span\u0026gt;: \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;10\u0026lt;/span\u0026gt;}\n\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;If you use Python 2, you can even remove the \u0026lt;code\u0026gt;list()\u0026lt;/code\u0026gt; calls. To create z:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026amp;gt; \u0026lt;/span\u0026gt;z = \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;dict\u0026lt;/span\u0026gt;(x.items() + y.items())\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026amp;gt; \u0026lt;/span\u0026gt;z\n{\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;a\u0026apos;\u0026lt;/span\u0026gt;: \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;c\u0026apos;\u0026lt;/span\u0026gt;: \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;11\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;b\u0026apos;\u0026lt;/span\u0026gt;: \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;10\u0026lt;/span\u0026gt;}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;If you use Python version 3.9.0a4 or greater, then you can directly use:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;x = {\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;a\u0026apos;\u0026lt;/span\u0026gt;:\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;b\u0026apos;\u0026lt;/span\u0026gt;: \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;}\ny = {\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;b\u0026apos;\u0026lt;/span\u0026gt;:\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;10\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;c\u0026apos;\u0026lt;/span\u0026gt;: \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;11\u0026lt;/span\u0026gt;}\nz = x | y\n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt;(z)\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;{\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;a\u0026apos;\u0026lt;/span\u0026gt;: \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;c\u0026apos;\u0026lt;/span\u0026gt;: \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;11\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;b\u0026apos;\u0026lt;/span\u0026gt;: \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;10\u0026lt;/span\u0026gt;}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;An alternative:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;z = x.copy()\nz.update(y)\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Another, more concise, option:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;z = \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;dict\u0026lt;/span\u0026gt;(x, **y)\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Note\u0026lt;/strong\u0026gt;: this has become a popular answer, but it is important to point out that if \u0026lt;code\u0026gt;y\u0026lt;/code\u0026gt; has any non-string keys, the fact that this works at all is an abuse of a CPython implementation detail, and it does not work in Python 3, or in PyPy, IronPython, or Jython. Also, \u0026lt;a href=\u0026quot;http://mail.python.org/pipermail/python-dev/2010-April/099459.html\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;Guido is not a fan\u0026lt;/a\u0026gt;. So I can\u0026apos;t recommend this technique for forward-compatible or cross-implementation portable code, which really means it should be avoided entirely.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;This probably won\u0026apos;t be a popular answer, but you almost certainly do not want to do this.  If you want a copy that\u0026apos;s a merge, then use copy (or \u0026lt;a href=\u0026quot;https://docs.python.org/2/library/copy.html\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;deepcopy\u0026lt;/a\u0026gt;, depending on what you want) and then update.  The two lines of code are much more readable - more Pythonic - than the single line creation with .items() + .items().  Explicit is better than implicit.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;In addition, when you use .items() (pre Python 3.0), you\u0026apos;re creating a new list that contains the items from the dict.  If your dictionaries are large, then that is quite a lot of overhead (two large lists that will be thrown away as soon as the merged dict is created).  update() can work more efficiently, because it can run through the second dict item-by-item.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;In terms of \u0026lt;a href=\u0026quot;https://docs.python.org/2/library/timeit.html\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;time\u0026lt;/a\u0026gt;:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026amp;gt; \u0026lt;/span\u0026gt;timeit.Timer(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;dict(x, **y)\u0026quot;\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;x = dict(zip(range(1000), range(1000)))\\ny=dict(zip(range(1000,2000), range(1000,2000)))\u0026quot;\u0026lt;/span\u0026gt;).timeit(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;100000\u0026lt;/span\u0026gt;)\n\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;15.52571702003479\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026amp;gt; \u0026lt;/span\u0026gt;timeit.Timer(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;temp = x.copy()\\ntemp.update(y)\u0026quot;\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;x = dict(zip(range(1000), range(1000)))\\ny=dict(zip(range(1000,2000), range(1000,2000)))\u0026quot;\u0026lt;/span\u0026gt;).timeit(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;100000\u0026lt;/span\u0026gt;)\n\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;15.694622993469238\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026amp;gt; \u0026lt;/span\u0026gt;timeit.Timer(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;dict(x.items() + y.items())\u0026quot;\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;x = dict(zip(range(1000), range(1000)))\\ny=dict(zip(range(1000,2000), range(1000,2000)))\u0026quot;\u0026lt;/span\u0026gt;).timeit(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;100000\u0026lt;/span\u0026gt;)\n\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;41.484580039978027\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;IMO the tiny slowdown between the first two is worth it for the readability.  In addition, keyword arguments for dictionary creation was only added in Python 2.3, whereas copy() and update() will work in older versions.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;In a follow-up answer, you asked about the relative performance of these two alternatives:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;z1 = \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;dict\u0026lt;/span\u0026gt;(x.items() + y.items())\nz2 = \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;dict\u0026lt;/span\u0026gt;(x, **y)\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;On my machine, at least (a fairly ordinary x86_64 running Python 2.5.2), alternative \u0026lt;code\u0026gt;z2\u0026lt;/code\u0026gt; is not only shorter and simpler but also significantly faster.  You can verify this for yourself using the \u0026lt;code\u0026gt;timeit\u0026lt;/code\u0026gt; module that comes with Python.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Example 1: identical dictionaries mapping 20 consecutive integers to themselves:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;% python -m timeit -s \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;x=y=dict((i,i) for i in range(20))\u0026apos;\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;z1=dict(x.items() + y.items())\u0026apos;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;100000\u0026lt;/span\u0026gt; loops, best of \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3\u0026lt;/span\u0026gt;: \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;5.67\u0026lt;/span\u0026gt; usec per loop\n% python -m timeit -s \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;x=y=dict((i,i) for i in range(20))\u0026apos;\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;z2=dict(x, **y)\u0026apos;\u0026lt;/span\u0026gt; \n\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;100000\u0026lt;/span\u0026gt; loops, best of \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3\u0026lt;/span\u0026gt;: \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1.53\u0026lt;/span\u0026gt; usec per loop\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;code\u0026gt;z2\u0026lt;/code\u0026gt; wins by a factor of 3.5 or so.  Different dictionaries seem to yield quite different results, but \u0026lt;code\u0026gt;z2\u0026lt;/code\u0026gt; always seems to come out ahead.  (If you get inconsistent results for the \u0026lt;em\u0026gt;same\u0026lt;/em\u0026gt; test, try passing in \u0026lt;code\u0026gt;-r\u0026lt;/code\u0026gt; with a number larger than the default 3.)\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Example 2: non-overlapping dictionaries mapping 252 short strings to integers and vice versa:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;% python -m timeit -s \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;from htmlentitydefs import codepoint2name as x, name2codepoint as y\u0026apos;\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;z1=dict(x.items() + y.items())\u0026apos;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1000\u0026lt;/span\u0026gt; loops, best of \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3\u0026lt;/span\u0026gt;: \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;260\u0026lt;/span\u0026gt; usec per loop\n% python -m timeit -s \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;from htmlentitydefs import codepoint2name as x, name2codepoint as y\u0026apos;\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;z2=dict(x, **y)\u0026apos;\u0026lt;/span\u0026gt;               \n\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;10000\u0026lt;/span\u0026gt; loops, best of \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3\u0026lt;/span\u0026gt;: \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;26.9\u0026lt;/span\u0026gt; usec per loop\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;code\u0026gt;z2\u0026lt;/code\u0026gt; wins by about a factor of 10.  That\u0026apos;s a pretty big win in my book!\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;After comparing those two, I wondered if \u0026lt;code\u0026gt;z1\u0026lt;/code\u0026gt;\u0026apos;s poor performance could be attributed to the overhead of constructing the two item lists, which in turn led me to wonder if this variation might work better:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;from\u0026lt;/span\u0026gt; itertools \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;import\u0026lt;/span\u0026gt; chain\nz3 = \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;dict\u0026lt;/span\u0026gt;(chain(x.iteritems(), y.iteritems()))\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;A few quick tests, e.g.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;% python -m timeit -s \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;from itertools import chain; from htmlentitydefs import codepoint2name as x, name2codepoint as y\u0026apos;\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;z3=dict(chain(x.iteritems(), y.iteritems()))\u0026apos;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;10000\u0026lt;/span\u0026gt; loops, best of \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3\u0026lt;/span\u0026gt;: \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;66\u0026lt;/span\u0026gt; usec per loop\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;lead me to conclude that \u0026lt;code\u0026gt;z3\u0026lt;/code\u0026gt; is somewhat faster than \u0026lt;code\u0026gt;z1\u0026lt;/code\u0026gt;, but not nearly as fast as \u0026lt;code\u0026gt;z2\u0026lt;/code\u0026gt;.  Definitely not worth all the extra typing.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;This discussion is still missing something important, which is a performance comparison of these alternatives with the \u0026quot;obvious\u0026quot; way of merging two lists: using the \u0026lt;code\u0026gt;update\u0026lt;/code\u0026gt; method.  To try to keep things on an equal footing with the expressions, none of which modify x or y, I\u0026apos;m going to make a copy of x instead of modifying it in-place, as follows:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;z0 = \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;dict\u0026lt;/span\u0026gt;(x)\nz0.update(y)\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;A typical result:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;% python -m timeit -s \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;from htmlentitydefs import codepoint2name as x, name2codepoint as y\u0026apos;\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;z0=dict(x); z0.update(y)\u0026apos;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;10000\u0026lt;/span\u0026gt; loops, best of \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3\u0026lt;/span\u0026gt;: \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;26.9\u0026lt;/span\u0026gt; usec per loop\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;In other words, \u0026lt;code\u0026gt;z0\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;z2\u0026lt;/code\u0026gt; seem to have essentially identical performance.  Do you think this might be a coincidence?  I don\u0026apos;t....\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;In fact, I\u0026apos;d go so far as to claim that it\u0026apos;s impossible for pure Python code to do any better than this.  And if you can do significantly better in a C extension module, I imagine the Python folks might well be interested in incorporating your code (or a variation on your approach) into the Python core.  Python uses \u0026lt;code\u0026gt;dict\u0026lt;/code\u0026gt; in lots of places; optimizing its operations is a big deal.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;You could also write this as\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;z0 = x.copy()\nz0.update(y)\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;as Tony does, but (not surprisingly) the difference in notation turns out not to have any measurable effect on performance.  Use whichever looks right to you.  Of course, he\u0026apos;s absolutely correct to point out that the two-statement version is much easier to understand.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;In Python 3.0 and later\u0026lt;/strong\u0026gt;, you can use \u0026lt;a href=\u0026quot;http://docs.python.org/3/library/collections.html#collections.ChainMap\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;\u0026lt;code\u0026gt;collections.ChainMap\u0026lt;/code\u0026gt;\u0026lt;/a\u0026gt; which groups multiple dicts or other mappings together to create a single, updateable view:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026amp;gt; \u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;from\u0026lt;/span\u0026gt; collections \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;import\u0026lt;/span\u0026gt; ChainMap\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026amp;gt; \u0026lt;/span\u0026gt;x = {\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;a\u0026apos;\u0026lt;/span\u0026gt;:\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;b\u0026apos;\u0026lt;/span\u0026gt;: \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;}\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026amp;gt; \u0026lt;/span\u0026gt;y = {\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;b\u0026apos;\u0026lt;/span\u0026gt;:\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;10\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;c\u0026apos;\u0026lt;/span\u0026gt;: \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;11\u0026lt;/span\u0026gt;}\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026amp;gt; \u0026lt;/span\u0026gt;z = \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;dict\u0026lt;/span\u0026gt;(ChainMap({}, y, x))\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026amp;gt; \u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt; k, v \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;in\u0026lt;/span\u0026gt; z.items():\n        \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt;(k, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;--\u0026amp;gt;\u0026apos;\u0026lt;/span\u0026gt;, v)\n    \na --\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;\nb --\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;10\u0026lt;/span\u0026gt;\nc --\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;11\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Update for Python 3.5 and later\u0026lt;/strong\u0026gt;: You can use \u0026lt;a href=\u0026quot;https://www.python.org/dev/peps/pep-0448/\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;PEP 448\u0026lt;/a\u0026gt; extended dictionary packing and unpacking.  This is fast and easy:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026amp;gt; \u0026lt;/span\u0026gt;x = {\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;a\u0026apos;\u0026lt;/span\u0026gt;:\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;b\u0026apos;\u0026lt;/span\u0026gt;: \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;}\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026amp;gt; \u0026lt;/span\u0026gt;y = {\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;b\u0026apos;\u0026lt;/span\u0026gt;:\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;10\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;c\u0026apos;\u0026lt;/span\u0026gt;: \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;11\u0026lt;/span\u0026gt;}\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026amp;gt; \u0026lt;/span\u0026gt;{**x, **y}\n{\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;a\u0026apos;\u0026lt;/span\u0026gt;: \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;b\u0026apos;\u0026lt;/span\u0026gt;: \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;10\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;c\u0026apos;\u0026lt;/span\u0026gt;: \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;11\u0026lt;/span\u0026gt;}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Update for Python 3.9 and later\u0026lt;/strong\u0026gt;:  You can use the \u0026lt;a href=\u0026quot;https://www.python.org/dev/peps/pep-0584/\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;PEP 584\u0026lt;/a\u0026gt; union operator:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026amp;gt; \u0026lt;/span\u0026gt;x = {\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;a\u0026apos;\u0026lt;/span\u0026gt;:\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;b\u0026apos;\u0026lt;/span\u0026gt;: \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;}\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026amp;gt; \u0026lt;/span\u0026gt;y = {\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;b\u0026apos;\u0026lt;/span\u0026gt;:\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;10\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;c\u0026apos;\u0026lt;/span\u0026gt;: \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;11\u0026lt;/span\u0026gt;}\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026amp;gt; \u0026lt;/span\u0026gt;x | y\n{\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;a\u0026apos;\u0026lt;/span\u0026gt;: \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;b\u0026apos;\u0026lt;/span\u0026gt;: \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;10\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;c\u0026apos;\u0026lt;/span\u0026gt;: \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;11\u0026lt;/span\u0026gt;}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;I wanted something similar, but with the ability to specify how the values on duplicate keys were merged, so I hacked this out (but did not heavily test it).  Obviously this is not a single expression, but it is a single function call.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;def\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;merge\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;d1, d2, merge_fn=\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;lambda\u0026lt;/span\u0026gt; x,y:y\u0026lt;/span\u0026gt;):\n    \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;\u0026quot;\u0026quot;\n    Merges two dictionaries, non-destructively, combining \n    values on duplicate keys as defined by the optional merge\n    function.  The default behavior replaces the values in d1\n    with corresponding values in d2.  (There is no other generally\n    applicable merge strategy, but often you\u0026apos;ll have homogeneous \n    types in your dicts, so specifying a merge technique can be \n    valuable.)\n\n    Examples:\n\n    \u0026amp;gt;\u0026amp;gt;\u0026amp;gt; d1\n    {\u0026apos;a\u0026apos;: 1, \u0026apos;c\u0026apos;: 3, \u0026apos;b\u0026apos;: 2}\n    \u0026amp;gt;\u0026amp;gt;\u0026amp;gt; merge(d1, d1)\n    {\u0026apos;a\u0026apos;: 1, \u0026apos;c\u0026apos;: 3, \u0026apos;b\u0026apos;: 2}\n    \u0026amp;gt;\u0026amp;gt;\u0026amp;gt; merge(d1, d1, lambda x,y: x+y)\n    {\u0026apos;a\u0026apos;: 2, \u0026apos;c\u0026apos;: 6, \u0026apos;b\u0026apos;: 4}\n\n    \u0026quot;\u0026quot;\u0026quot;\u0026lt;/span\u0026gt;\n    result = \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;dict\u0026lt;/span\u0026gt;(d1)\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt; k,v \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;in\u0026lt;/span\u0026gt; d2.iteritems():\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; k \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;in\u0026lt;/span\u0026gt; result:\n            result[k] = merge_fn(result[k], v)\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;else\u0026lt;/span\u0026gt;:\n            result[k] = v\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; result\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;h1\u0026gt;Recursively/deep update a dict\u0026lt;/h1\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;def\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;deepupdate\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;original, update\u0026lt;/span\u0026gt;):\n    \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;\u0026quot;\u0026quot;\n    Recursively update a dict.\n    Subdict\u0026apos;s won\u0026apos;t be overwritten but also updated.\n    \u0026quot;\u0026quot;\u0026quot;\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt; key, value \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;in\u0026lt;/span\u0026gt; original.iteritems(): \n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; key \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;not\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;in\u0026lt;/span\u0026gt; update:\n            update[key] = value\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;elif\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;isinstance\u0026lt;/span\u0026gt;(value, \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;dict\u0026lt;/span\u0026gt;):\n            deepupdate(value, update[key]) \n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; update\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Demonstration:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;pluto_original = {\n    \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;name\u0026apos;\u0026lt;/span\u0026gt;: \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;Pluto\u0026apos;\u0026lt;/span\u0026gt;,\n    \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;details\u0026apos;\u0026lt;/span\u0026gt;: {\n        \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;tail\u0026apos;\u0026lt;/span\u0026gt;: \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;True\u0026lt;/span\u0026gt;,\n        \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;color\u0026apos;\u0026lt;/span\u0026gt;: \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;orange\u0026apos;\u0026lt;/span\u0026gt;\n    }\n}\n\npluto_update = {\n    \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;name\u0026apos;\u0026lt;/span\u0026gt;: \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;Pluutoo\u0026apos;\u0026lt;/span\u0026gt;,\n    \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;details\u0026apos;\u0026lt;/span\u0026gt;: {\n        \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;color\u0026apos;\u0026lt;/span\u0026gt;: \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;blue\u0026apos;\u0026lt;/span\u0026gt;\n    }\n}\n\n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt; deepupdate(pluto_original, pluto_update)\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Outputs:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;{\n    \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;name\u0026apos;\u0026lt;/span\u0026gt;: \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;Pluutoo\u0026apos;\u0026lt;/span\u0026gt;,\n    \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;details\u0026apos;\u0026lt;/span\u0026gt;: {\n        \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;color\u0026apos;\u0026lt;/span\u0026gt;: \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;blue\u0026apos;\u0026lt;/span\u0026gt;,\n        \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;tail\u0026apos;\u0026lt;/span\u0026gt;: \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;True\u0026lt;/span\u0026gt;\n    }\n}\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Thanks rednaw for edits.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Python 3.5 (PEP 448) allows a nicer syntax option:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;x = {\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;a\u0026apos;\u0026lt;/span\u0026gt;: \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;b\u0026apos;\u0026lt;/span\u0026gt;: \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;}\ny = {\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;a\u0026apos;\u0026lt;/span\u0026gt;: \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;c\u0026apos;\u0026lt;/span\u0026gt;: \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;}\nfinal = {**x, **y} \nfinal\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;# {\u0026apos;a\u0026apos;: 2, \u0026apos;b\u0026apos;: 1, \u0026apos;c\u0026apos;: 2}\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Or even \u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;final = {\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;a\u0026apos;\u0026lt;/span\u0026gt;: \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;b\u0026apos;\u0026lt;/span\u0026gt;: \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;, **x, **y}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;In Python 3.9 you also use | and |= with the below example from PEP 584\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;d = {\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;spam\u0026apos;\u0026lt;/span\u0026gt;: \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;eggs\u0026apos;\u0026lt;/span\u0026gt;: \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;cheese\u0026apos;\u0026lt;/span\u0026gt;: \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3\u0026lt;/span\u0026gt;}\ne = {\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;cheese\u0026apos;\u0026lt;/span\u0026gt;: \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;cheddar\u0026apos;\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;aardvark\u0026apos;\u0026lt;/span\u0026gt;: \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;Ethel\u0026apos;\u0026lt;/span\u0026gt;}\nd | e\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;# {\u0026apos;spam\u0026apos;: 1, \u0026apos;eggs\u0026apos;: 2, \u0026apos;cheese\u0026apos;: \u0026apos;cheddar\u0026apos;, \u0026apos;aardvark\u0026apos;: \u0026apos;Ethel\u0026apos;}\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;The best version I could think while not using copy would be:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;from\u0026lt;/span\u0026gt; itertools \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;import\u0026lt;/span\u0026gt; chain\nx = {\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;a\u0026apos;\u0026lt;/span\u0026gt;:\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;b\u0026apos;\u0026lt;/span\u0026gt;: \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;}\ny = {\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;b\u0026apos;\u0026lt;/span\u0026gt;:\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;10\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;c\u0026apos;\u0026lt;/span\u0026gt;: \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;11\u0026lt;/span\u0026gt;}\n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;dict\u0026lt;/span\u0026gt;(chain(x.iteritems(), y.iteritems()))\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;It\u0026apos;s faster than \u0026lt;code\u0026gt;dict(x.items() + y.items())\u0026lt;/code\u0026gt; but not as fast as \u0026lt;code\u0026gt;n = copy(a); n.update(b)\u0026lt;/code\u0026gt;, at least on CPython. This version also works in Python 3 if you change \u0026lt;code\u0026gt;iteritems()\u0026lt;/code\u0026gt; to \u0026lt;code\u0026gt;items()\u0026lt;/code\u0026gt;, which is automatically done by the 2to3 tool.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Personally I like this version best because it describes fairly good what I want in a single  functional syntax. The only minor problem is that it doesn\u0026apos;t make completely obvious that values from y takes precedence over values from x, but I don\u0026apos;t believe it\u0026apos;s difficult to figure that out.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;x = {\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;a\u0026apos;\u0026lt;/span\u0026gt;:\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;b\u0026apos;\u0026lt;/span\u0026gt;: \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;}\ny = {\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;b\u0026apos;\u0026lt;/span\u0026gt;:\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;10\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;c\u0026apos;\u0026lt;/span\u0026gt;: \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;11\u0026lt;/span\u0026gt;}\nz = \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;dict\u0026lt;/span\u0026gt;(x.items() + y.items())\n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt; z\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;For items with keys in both dictionaries (\u0026apos;b\u0026apos;), you can control which one ends up in the output by putting that one last.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;While the question has already been answered several times,\nthis simple solution to the problem has not been listed yet.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;x = {\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;a\u0026apos;\u0026lt;/span\u0026gt;:\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;b\u0026apos;\u0026lt;/span\u0026gt;: \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;}\ny = {\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;b\u0026apos;\u0026lt;/span\u0026gt;:\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;10\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;c\u0026apos;\u0026lt;/span\u0026gt;: \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;11\u0026lt;/span\u0026gt;}\nz4 = {}\nz4.update(x)\nz4.update(y)\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;It is as fast as z0 and the evil z2 mentioned above, but easy to understand and change.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;def\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;dict_merge\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;a, b\u0026lt;/span\u0026gt;):\n  c = a.copy()\n  c.update(b)\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; c\n\nnew = dict_merge(old, extras)\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Among such shady and dubious answers, this shining example is the one and only good way to merge dicts in Python, endorsed by dictator for life \u0026lt;em\u0026gt;Guido van Rossum\u0026lt;/em\u0026gt; himself!  Someone else suggested half of this, but did not put it in a function.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt; dict_merge(\n      {\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;color\u0026apos;\u0026lt;/span\u0026gt;:\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;red\u0026apos;\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;model\u0026apos;\u0026lt;/span\u0026gt;:\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;Mini\u0026apos;\u0026lt;/span\u0026gt;},\n      {\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;model\u0026apos;\u0026lt;/span\u0026gt;:\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;Ferrari\u0026apos;\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;owner\u0026apos;\u0026lt;/span\u0026gt;:\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;Carl\u0026apos;\u0026lt;/span\u0026gt;})\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;gives:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;{\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;color\u0026apos;\u0026lt;/span\u0026gt;: \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;red\u0026apos;\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;owner\u0026apos;\u0026lt;/span\u0026gt;: \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;Carl\u0026apos;\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;model\u0026apos;\u0026lt;/span\u0026gt;: \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;Ferrari\u0026apos;\u0026lt;/span\u0026gt;}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;If you think lambdas are evil then read no further.\nAs requested, you can write the fast and memory-efficient solution with one expression:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;x = {\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;a\u0026apos;\u0026lt;/span\u0026gt;:\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;b\u0026apos;\u0026lt;/span\u0026gt;:\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;}\ny = {\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;b\u0026apos;\u0026lt;/span\u0026gt;:\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;10\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;c\u0026apos;\u0026lt;/span\u0026gt;:\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;11\u0026lt;/span\u0026gt;}\nz = (\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;lambda\u0026lt;/span\u0026gt; a, b: (\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;lambda\u0026lt;/span\u0026gt; a_copy: a_copy.update(b) \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;or\u0026lt;/span\u0026gt; a_copy)(a.copy()))(x, y)\n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt; z\n{\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;a\u0026apos;\u0026lt;/span\u0026gt;: \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;c\u0026apos;\u0026lt;/span\u0026gt;: \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;11\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;b\u0026apos;\u0026lt;/span\u0026gt;: \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;10\u0026lt;/span\u0026gt;}\n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt; x\n{\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;a\u0026apos;\u0026lt;/span\u0026gt;: \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;b\u0026apos;\u0026lt;/span\u0026gt;: \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;As suggested above, using two lines or writing a function is probably a better way to go.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Be pythonic. Use a \u0026lt;a href=\u0026quot;https://docs.python.org/2/tutorial/datastructures.html#dictionaries\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;comprehension\u0026lt;/a\u0026gt;:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;z={k: v \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt; d \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;in\u0026lt;/span\u0026gt; [x,y] \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt; k, v \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;in\u0026lt;/span\u0026gt; d.items()}\n\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026amp;gt; \u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt; z\n{\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;a\u0026apos;\u0026lt;/span\u0026gt;: \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;c\u0026apos;\u0026lt;/span\u0026gt;: \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;11\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;b\u0026apos;\u0026lt;/span\u0026gt;: \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;10\u0026lt;/span\u0026gt;}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;In python3, the \u0026lt;code\u0026gt;items\u0026lt;/code\u0026gt; method \u0026lt;a href=\u0026quot;http://docs.python.org/dev/whatsnew/3.0.html#views-and-iterators-instead-of-lists\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;no longer returns a list\u0026lt;/a\u0026gt;, but rather a \u0026lt;em\u0026gt;view\u0026lt;/em\u0026gt;, which acts like a set. In this case you\u0026apos;ll need to take the set union since concatenating with \u0026lt;code\u0026gt;+\u0026lt;/code\u0026gt; won\u0026apos;t work:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;dict\u0026lt;/span\u0026gt;(x.items() | y.items())\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;For python3-like behavior in version 2.7, the \u0026lt;code\u0026gt;viewitems\u0026lt;/code\u0026gt; method should work in place of \u0026lt;code\u0026gt;items\u0026lt;/code\u0026gt;:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;dict\u0026lt;/span\u0026gt;(x.viewitems() | y.viewitems())\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;I prefer this notation anyways since it seems more natural to think of it as a set union operation rather than concatenation (as the title shows).\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Edit:\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;A couple more points for python 3. First, note that the \u0026lt;code\u0026gt;dict(x, **y)\u0026lt;/code\u0026gt; trick won\u0026apos;t work in python 3 unless the keys in \u0026lt;code\u0026gt;y\u0026lt;/code\u0026gt; are strings.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Also, Raymond Hettinger\u0026apos;s Chainmap \u0026lt;a href=\u0026quot;https://stackoverflow.com/a/16259217/386279\u0026quot;\u0026gt;answer\u0026lt;/a\u0026gt; is pretty elegant, since it can take an arbitrary number of dicts as arguments, but \u0026lt;a href=\u0026quot;http://docs.python.org/dev/library/collections\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;from the docs\u0026lt;/a\u0026gt; it looks like it sequentially looks through a list of all the dicts for each lookup:\u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;Lookups search the underlying mappings successively until a key is found.\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;p\u0026gt;This can slow you down if you have a lot of lookups in your application:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;In [\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;]: \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;from\u0026lt;/span\u0026gt; collections \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;import\u0026lt;/span\u0026gt; ChainMap\nIn [\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;]: \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;from\u0026lt;/span\u0026gt; string \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;import\u0026lt;/span\u0026gt; ascii_uppercase \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;as\u0026lt;/span\u0026gt; up, ascii_lowercase \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;as\u0026lt;/span\u0026gt; lo; x = \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;dict\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;zip\u0026lt;/span\u0026gt;(lo, up)); y = \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;dict\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;zip\u0026lt;/span\u0026gt;(up, lo))\nIn [\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3\u0026lt;/span\u0026gt;]: chainmap_dict = ChainMap(y, x)\nIn [\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;4\u0026lt;/span\u0026gt;]: union_dict = \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;dict\u0026lt;/span\u0026gt;(x.items() | y.items())\nIn [\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;5\u0026lt;/span\u0026gt;]: timeit \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt; k \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;in\u0026lt;/span\u0026gt; union_dict: union_dict[k]\n\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;100000\u0026lt;/span\u0026gt; loops, best of \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3\u0026lt;/span\u0026gt;: \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2.15\u0026lt;/span\u0026gt; µs per loop\nIn [\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;6\u0026lt;/span\u0026gt;]: timeit \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt; k \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;in\u0026lt;/span\u0026gt; chainmap_dict: chainmap_dict[k]\n\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;10000\u0026lt;/span\u0026gt; loops, best of \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3\u0026lt;/span\u0026gt;: \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;27.1\u0026lt;/span\u0026gt; µs per loop\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;So about an order of magnitude slower for lookups. I\u0026apos;m a fan of Chainmap, but looks less practical where there may be many lookups.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;I benchmarked the suggested with \u0026lt;a href=\u0026quot;https://github.com/nschloe/perfplot\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;perfplot\u0026lt;/a\u0026gt; and found that the good old\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;temp = x.copy()\ntemp.update(y)\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;is the fastest solution together with the new (Python 3.9+)\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;x | y\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;a href=\u0026quot;https://i.stack.imgur.com/z8pG1.png\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;\u0026lt;img src=\u0026quot;https://i.stack.imgur.com/z8pG1.png\u0026quot; alt=\u0026quot;enter image description here\u0026quot;\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;hr\u0026gt;\n\u0026lt;p\u0026gt;Code to reproduce the plot:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;from\u0026lt;/span\u0026gt; collections \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;import\u0026lt;/span\u0026gt; ChainMap\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;from\u0026lt;/span\u0026gt; itertools \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;import\u0026lt;/span\u0026gt; chain\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;import\u0026lt;/span\u0026gt; perfplot\n\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;def\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;setup\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;n\u0026lt;/span\u0026gt;):\n    x = \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;dict\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;zip\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;range\u0026lt;/span\u0026gt;(n), \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;range\u0026lt;/span\u0026gt;(n)))\n    y = \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;dict\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;zip\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;range\u0026lt;/span\u0026gt;(n, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt; * n), \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;range\u0026lt;/span\u0026gt;(n, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt; * n)))\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; x, y\n\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;def\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;copy_update\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;data\u0026lt;/span\u0026gt;):\n    x, y = data\n    temp = x.copy()\n    temp.update(y)\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; temp\n\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;def\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;add_items\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;data\u0026lt;/span\u0026gt;):\n    x, y = data\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;dict\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;list\u0026lt;/span\u0026gt;(x.items()) + \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;list\u0026lt;/span\u0026gt;(y.items()))\n\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;def\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;curly_star\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;data\u0026lt;/span\u0026gt;):\n    x, y = data\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; {**x, **y}\n\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;def\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;chain_map\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;data\u0026lt;/span\u0026gt;):\n    x, y = data\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;dict\u0026lt;/span\u0026gt;(ChainMap({}, y, x))\n\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;def\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;itertools_chain\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;data\u0026lt;/span\u0026gt;):\n    x, y = data\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;dict\u0026lt;/span\u0026gt;(chain(x.items(), y.items()))\n\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;def\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;python39_concat\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;data\u0026lt;/span\u0026gt;):\n    x, y = data\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; x | y\n\n\nb = perfplot.bench(\n    setup=setup,\n    kernels=[\n        copy_update,\n        add_items,\n        curly_star,\n        chain_map,\n        itertools_chain,\n        python39_concat,\n    ],\n    labels=[\n        \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;copy_update\u0026quot;\u0026lt;/span\u0026gt;,\n        \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;dict(list(x.items()) + list(y.items()))\u0026quot;\u0026lt;/span\u0026gt;,\n        \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;{**x, **y}\u0026quot;\u0026lt;/span\u0026gt;,\n        \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;chain_map\u0026quot;\u0026lt;/span\u0026gt;,\n        \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;itertools.chain\u0026quot;\u0026lt;/span\u0026gt;,\n        \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;x | y\u0026quot;\u0026lt;/span\u0026gt;,\n    ],\n    n_range=[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt; ** k \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt; k \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;in\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;range\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;18\u0026lt;/span\u0026gt;)],\n    xlabel=\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;len(x), len(y)\u0026quot;\u0026lt;/span\u0026gt;,\n    equality_check=\u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;None\u0026lt;/span\u0026gt;,\n)\nb.save(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;out.png\u0026quot;\u0026lt;/span\u0026gt;)\nb.show()\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Two dictionaries\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;def\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;union2\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;dict1, dict2\u0026lt;/span\u0026gt;):\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;dict\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;list\u0026lt;/span\u0026gt;(dict1.items()) + \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;list\u0026lt;/span\u0026gt;(dict2.items()))\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;\u0026lt;em\u0026gt;n\u0026lt;/em\u0026gt; dictionaries\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;def\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;union\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;*dicts\u0026lt;/span\u0026gt;):\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;dict\u0026lt;/span\u0026gt;(itertools.chain.from_iterable(dct.items() \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt; dct \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;in\u0026lt;/span\u0026gt; dicts))\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;code\u0026gt;sum\u0026lt;/code\u0026gt; has bad performance. See \u0026lt;a href=\u0026quot;https://mathieularose.com/how-not-to-flatten-a-list-of-lists-in-python/\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;https://mathieularose.com/how-not-to-flatten-a-list-of-lists-in-python/\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Simple solution using itertools that preserves order (latter dicts have precedence)\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;# py2\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;from\u0026lt;/span\u0026gt; itertools \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;import\u0026lt;/span\u0026gt; chain, imap\nmerge = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;lambda\u0026lt;/span\u0026gt; *args: \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;dict\u0026lt;/span\u0026gt;(chain.from_iterable(imap(\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;dict\u0026lt;/span\u0026gt;.iteritems, args)))\n\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;# py3\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;from\u0026lt;/span\u0026gt; itertools \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;import\u0026lt;/span\u0026gt; chain\nmerge = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;lambda\u0026lt;/span\u0026gt; *args: \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;dict\u0026lt;/span\u0026gt;(chain.from_iterable(\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;map\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;dict\u0026lt;/span\u0026gt;.items, args)))\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;And it\u0026apos;s usage:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026amp;gt; \u0026lt;/span\u0026gt;x = {\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;a\u0026apos;\u0026lt;/span\u0026gt;:\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;b\u0026apos;\u0026lt;/span\u0026gt;: \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;}\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026amp;gt; \u0026lt;/span\u0026gt;y = {\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;b\u0026apos;\u0026lt;/span\u0026gt;:\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;10\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;c\u0026apos;\u0026lt;/span\u0026gt;: \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;11\u0026lt;/span\u0026gt;}\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026amp;gt; \u0026lt;/span\u0026gt;merge(x, y)\n{\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;a\u0026apos;\u0026lt;/span\u0026gt;: \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;b\u0026apos;\u0026lt;/span\u0026gt;: \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;10\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;c\u0026apos;\u0026lt;/span\u0026gt;: \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;11\u0026lt;/span\u0026gt;}\n\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026amp;gt; \u0026lt;/span\u0026gt;z = {\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;c\u0026apos;\u0026lt;/span\u0026gt;: \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;d\u0026apos;\u0026lt;/span\u0026gt;: \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;4\u0026lt;/span\u0026gt;}\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026amp;gt; \u0026lt;/span\u0026gt;merge(x, y, z)\n{\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;a\u0026apos;\u0026lt;/span\u0026gt;: \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;b\u0026apos;\u0026lt;/span\u0026gt;: \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;10\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;c\u0026apos;\u0026lt;/span\u0026gt;: \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;d\u0026apos;\u0026lt;/span\u0026gt;: \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;4\u0026lt;/span\u0026gt;}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Abuse leading to a one-expression solution for \u0026lt;a href=\u0026quot;https://stackoverflow.com/a/39437/15055\u0026quot;\u0026gt;Matthew\u0026apos;s answer\u0026lt;/a\u0026gt;:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026amp;gt; \u0026lt;/span\u0026gt;x = {\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;a\u0026apos;\u0026lt;/span\u0026gt;:\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;b\u0026apos;\u0026lt;/span\u0026gt;: \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;}\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026amp;gt; \u0026lt;/span\u0026gt;y = {\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;b\u0026apos;\u0026lt;/span\u0026gt;:\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;10\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;c\u0026apos;\u0026lt;/span\u0026gt;: \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;11\u0026lt;/span\u0026gt;}\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026amp;gt; \u0026lt;/span\u0026gt;z = (\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;lambda\u0026lt;/span\u0026gt; f=x.copy(): (f.update(y), f)[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;])()\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026amp;gt; \u0026lt;/span\u0026gt;z\n{\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;a\u0026apos;\u0026lt;/span\u0026gt;: \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;c\u0026apos;\u0026lt;/span\u0026gt;: \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;11\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;b\u0026apos;\u0026lt;/span\u0026gt;: \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;10\u0026lt;/span\u0026gt;}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;You said you wanted one expression, so I abused \u0026lt;code\u0026gt;lambda\u0026lt;/code\u0026gt; to bind a name, and tuples to override lambda\u0026apos;s one-expression limit. Feel free to cringe.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;You could also do this of course if you don\u0026apos;t care about copying it:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026amp;gt; \u0026lt;/span\u0026gt;x = {\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;a\u0026apos;\u0026lt;/span\u0026gt;:\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;b\u0026apos;\u0026lt;/span\u0026gt;: \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;}\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026amp;gt; \u0026lt;/span\u0026gt;y = {\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;b\u0026apos;\u0026lt;/span\u0026gt;:\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;10\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;c\u0026apos;\u0026lt;/span\u0026gt;: \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;11\u0026lt;/span\u0026gt;}\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026amp;gt; \u0026lt;/span\u0026gt;z = (x.update(y), x)[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;]\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026amp;gt; \u0026lt;/span\u0026gt;z\n{\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;a\u0026apos;\u0026lt;/span\u0026gt;: \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;b\u0026apos;\u0026lt;/span\u0026gt;: \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;10\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;c\u0026apos;\u0026lt;/span\u0026gt;: \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;11\u0026lt;/span\u0026gt;}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;If you don\u0026apos;t mind mutating \u0026lt;code\u0026gt;x\u0026lt;/code\u0026gt;,\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;x.update(y) \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;or\u0026lt;/span\u0026gt; x\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;Simple, readable, performant. You \u0026lt;em\u0026gt;know\u0026lt;/em\u0026gt; \u0026lt;code\u0026gt;update()\u0026lt;/code\u0026gt; always returns \u0026lt;code\u0026gt;None\u0026lt;/code\u0026gt;, which is a false value. So the above expression will always evaluate to \u0026lt;code\u0026gt;x\u0026lt;/code\u0026gt;, after updating it.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Most mutating methods in the standard library (like \u0026lt;code\u0026gt;.update()\u0026lt;/code\u0026gt;) return \u0026lt;code\u0026gt;None\u0026lt;/code\u0026gt; by convention, so this kind of pattern will work on those too. However, if you\u0026apos;re using a dict subclass or some other method that doesn\u0026apos;t follow this convention, then \u0026lt;code\u0026gt;or\u0026lt;/code\u0026gt; may return its left operand, which may not be what you want. Instead, you can use a tuple display and index, which works regardless of what the first element evaluates to (although it\u0026apos;s not quite as pretty):\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;(x.update(y), x)[-\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;]\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;If you don\u0026apos;t have \u0026lt;code\u0026gt;x\u0026lt;/code\u0026gt; in a variable yet, you can use \u0026lt;code\u0026gt;lambda\u0026lt;/code\u0026gt; to make a local without using an assignment statement. This amounts to using \u0026lt;code\u0026gt;lambda\u0026lt;/code\u0026gt; as a \u0026lt;em\u0026gt;let expression\u0026lt;/em\u0026gt;, which is a common technique in functional languages, but is maybe unpythonic.\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;lambda\u0026lt;/span\u0026gt; x: x.update(y) \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;or\u0026lt;/span\u0026gt; x)({\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;a\u0026apos;\u0026lt;/span\u0026gt;: \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;b\u0026apos;\u0026lt;/span\u0026gt;: \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;})\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;Although it\u0026apos;s not that different from the following use of the new walrus operator (Python 3.8+ only),\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;(x := {\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;a\u0026apos;\u0026lt;/span\u0026gt;: \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;b\u0026apos;\u0026lt;/span\u0026gt;: \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;}).update(y) \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;or\u0026lt;/span\u0026gt; x\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;especially if you use a default argument:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;lambda\u0026lt;/span\u0026gt; x={\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;a\u0026apos;\u0026lt;/span\u0026gt;: \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;b\u0026apos;\u0026lt;/span\u0026gt;: \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;}: x.update(y) \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;or\u0026lt;/span\u0026gt; x)()\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;If you do want a copy, \u0026lt;a href=\u0026quot;https://www.python.org/dev/peps/pep-0584/\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;PEP 584\u0026lt;/a\u0026gt; style \u0026lt;code\u0026gt;x | y\u0026lt;/code\u0026gt; is the most Pythonic on 3.9+. If you must support older versions, \u0026lt;a href=\u0026quot;https://www.python.org/dev/peps/pep-0448/\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;PEP 448\u0026lt;/a\u0026gt; style \u0026lt;code\u0026gt;{**x, **y}\u0026lt;/code\u0026gt; is easiest for 3.5+. But if that\u0026apos;s not available in your (even older) Python version, the \u0026lt;em\u0026gt;let expression\u0026lt;/em\u0026gt; pattern works here too.\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;lambda\u0026lt;/span\u0026gt; z=x.copy(): z.update(y) \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;or\u0026lt;/span\u0026gt; z)()\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;(That is, of course, nearly equivalent to \u0026lt;code\u0026gt;(z := x.copy()).update(y) or z\u0026lt;/code\u0026gt;, but if your Python version is new enough for that, then the PEP 448 style will be available.)\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;\u0026lt;a href=\u0026quot;https://www.python.org/dev/peps/pep-0584/#specification\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;New\u0026lt;/a\u0026gt; in Python 3.9:\u0026lt;/strong\u0026gt; Use the union operator (\u0026lt;code\u0026gt;|\u0026lt;/code\u0026gt;) to merge \u0026lt;code\u0026gt;dict\u0026lt;/code\u0026gt;s similar to \u0026lt;code\u0026gt;set\u0026lt;/code\u0026gt;s:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026amp;gt; \u0026lt;/span\u0026gt;d = {\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;a\u0026apos;\u0026lt;/span\u0026gt;: \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;b\u0026apos;\u0026lt;/span\u0026gt;: \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;}\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026amp;gt; \u0026lt;/span\u0026gt;e = {\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;a\u0026apos;\u0026lt;/span\u0026gt;: \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;9\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;c\u0026apos;\u0026lt;/span\u0026gt;: \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3\u0026lt;/span\u0026gt;}\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026amp;gt; \u0026lt;/span\u0026gt;d | e\n{\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;a\u0026apos;\u0026lt;/span\u0026gt;: \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;9\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;b\u0026apos;\u0026lt;/span\u0026gt;: \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;c\u0026apos;\u0026lt;/span\u0026gt;: \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3\u0026lt;/span\u0026gt;}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;For matching keys, the \u0026lt;strong\u0026gt;right \u0026lt;code\u0026gt;dict\u0026lt;/code\u0026gt; takes precedence\u0026lt;/strong\u0026gt;.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;This also works for \u0026lt;code\u0026gt;|=\u0026lt;/code\u0026gt; to modify a \u0026lt;code\u0026gt;dict\u0026lt;/code\u0026gt; in-place:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026amp;gt; \u0026lt;/span\u0026gt;e |= d    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;# e = e | d\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026amp;gt; \u0026lt;/span\u0026gt;e\n{\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;a\u0026apos;\u0026lt;/span\u0026gt;: \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;c\u0026apos;\u0026lt;/span\u0026gt;: \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;b\u0026apos;\u0026lt;/span\u0026gt;: \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Drawing on ideas here and elsewhere I\u0026apos;ve comprehended a function:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;def\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;merge\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;*dicts, **kv\u0026lt;/span\u0026gt;): \n      \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; { k:v \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt; d \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;in\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;list\u0026lt;/span\u0026gt;(dicts) + [kv] \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt; k,v \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;in\u0026lt;/span\u0026gt; d.items() }\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Usage (tested in python 3):\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;assert\u0026lt;/span\u0026gt; (merge({\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;:\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;11\u0026lt;/span\u0026gt;,\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;a\u0026apos;\u0026lt;/span\u0026gt;:\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;aaa\u0026apos;\u0026lt;/span\u0026gt;},{\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;:\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;99\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;b\u0026apos;\u0026lt;/span\u0026gt;:\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;bbb\u0026apos;\u0026lt;/span\u0026gt;},foo=\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;bar\u0026apos;\u0026lt;/span\u0026gt;)==\\\n    {\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;: \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;99\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;foo\u0026apos;\u0026lt;/span\u0026gt;: \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;bar\u0026apos;\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;b\u0026apos;\u0026lt;/span\u0026gt;: \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;bbb\u0026apos;\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;a\u0026apos;\u0026lt;/span\u0026gt;: \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;aaa\u0026apos;\u0026lt;/span\u0026gt;})\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;assert\u0026lt;/span\u0026gt; (merge(foo=\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;bar\u0026apos;\u0026lt;/span\u0026gt;)=={\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;foo\u0026apos;\u0026lt;/span\u0026gt;: \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;bar\u0026apos;\u0026lt;/span\u0026gt;})\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;assert\u0026lt;/span\u0026gt; (merge({\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;:\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;11\u0026lt;/span\u0026gt;},{\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;:\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;99\u0026lt;/span\u0026gt;},foo=\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;bar\u0026apos;\u0026lt;/span\u0026gt;,baz=\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;quux\u0026apos;\u0026lt;/span\u0026gt;)==\\\n    {\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;: \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;99\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;foo\u0026apos;\u0026lt;/span\u0026gt;: \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;bar\u0026apos;\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;baz\u0026apos;\u0026lt;/span\u0026gt;:\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;quux\u0026apos;\u0026lt;/span\u0026gt;})\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;assert\u0026lt;/span\u0026gt; (merge({\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;:\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;11\u0026lt;/span\u0026gt;},{\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;:\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;99\u0026lt;/span\u0026gt;})=={\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;: \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;99\u0026lt;/span\u0026gt;})\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;You could use a lambda instead.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;It\u0026apos;s so silly that \u0026lt;code\u0026gt;.update\u0026lt;/code\u0026gt; returns nothing.\u0026lt;br\u0026gt;\nI just use a simple helper function to solve the problem:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;def\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;merge\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;dict1,*dicts\u0026lt;/span\u0026gt;):\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt; dict2 \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;in\u0026lt;/span\u0026gt; dicts:\n        dict1.update(dict2)\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; dict1\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Examples:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;merge(dict1,dict2)\nmerge(dict1,dict2,dict3)\nmerge(dict1,dict2,dict3,dict4)\nmerge({},dict1,dict2)  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;# this one returns a new copy\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;(For Python2.7* only; there are simpler solutions for Python3*.)\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;If you\u0026apos;re not averse to importing a standard library module, you can do\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;from\u0026lt;/span\u0026gt; functools \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;import\u0026lt;/span\u0026gt; reduce\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;def\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;merge_dicts\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;*dicts\u0026lt;/span\u0026gt;):\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; reduce(\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;lambda\u0026lt;/span\u0026gt; a, d: a.update(d) \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;or\u0026lt;/span\u0026gt; a, dicts, {})\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;(The \u0026lt;code\u0026gt;or a\u0026lt;/code\u0026gt; bit in the \u0026lt;code\u0026gt;lambda\u0026lt;/code\u0026gt; is necessary because \u0026lt;code\u0026gt;dict.update\u0026lt;/code\u0026gt; always returns \u0026lt;code\u0026gt;None\u0026lt;/code\u0026gt; on success.)\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;The problem I have with solutions listed to date is that, in the merged dictionary, the value for key \u0026quot;b\u0026quot; is 10 but, to my way of thinking, it should be 12.\nIn that light, I present the following:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;import\u0026lt;/span\u0026gt; timeit\n\nn=\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;100000\u0026lt;/span\u0026gt;\nsu = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;\u0026quot;\u0026quot;\nx = {\u0026apos;a\u0026apos;:1, \u0026apos;b\u0026apos;: 2}\ny = {\u0026apos;b\u0026apos;:10, \u0026apos;c\u0026apos;: 11}\n\u0026quot;\u0026quot;\u0026quot;\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;def\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;timeMerge\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;f,su,niter\u0026lt;/span\u0026gt;):\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;{:4f} sec for: {:30s}\u0026quot;\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;format\u0026lt;/span\u0026gt;(timeit.Timer(f,setup=su).timeit(n),f)\n\ntimeMerge(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;dict(x, **y)\u0026quot;\u0026lt;/span\u0026gt;,su,n)\ntimeMerge(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;x.update(y)\u0026quot;\u0026lt;/span\u0026gt;,su,n)\ntimeMerge(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;dict(x.items() + y.items())\u0026quot;\u0026lt;/span\u0026gt;,su,n)\ntimeMerge(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;for k in y.keys(): x[k] = k in x and x[k]+y[k] or y[k] \u0026quot;\u0026lt;/span\u0026gt;,su,n)\n\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;#confirm for loop adds b entries together\u0026lt;/span\u0026gt;\nx = {\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;a\u0026apos;\u0026lt;/span\u0026gt;:\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;b\u0026apos;\u0026lt;/span\u0026gt;: \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;}\ny = {\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;b\u0026apos;\u0026lt;/span\u0026gt;:\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;10\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;c\u0026apos;\u0026lt;/span\u0026gt;: \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;11\u0026lt;/span\u0026gt;}\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt; k \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;in\u0026lt;/span\u0026gt; y.keys(): x[k] = k \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;in\u0026lt;/span\u0026gt; x \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;and\u0026lt;/span\u0026gt; x[k]+y[k] \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;or\u0026lt;/span\u0026gt; y[k]\n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;confirm b elements are added:\u0026quot;\u0026lt;/span\u0026gt;,x\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;h1\u0026gt;Results:\u0026lt;/h1\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0.049465\u0026lt;/span\u0026gt; sec \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt;: \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;dict\u0026lt;/span\u0026gt;(x, **y)\n\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0.033729\u0026lt;/span\u0026gt; sec \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt;: x.update(y)                   \n\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0.150380\u0026lt;/span\u0026gt; sec \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt;: \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;dict\u0026lt;/span\u0026gt;(x.items() + y.items())   \n\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0.083120\u0026lt;/span\u0026gt; sec \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt;: \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt; k \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;in\u0026lt;/span\u0026gt; y.keys(): x[k] = k \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;in\u0026lt;/span\u0026gt; x \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;and\u0026lt;/span\u0026gt; x[k]+y[k] \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;or\u0026lt;/span\u0026gt; y[k]\n\nconfirm b elements are added: {\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;a\u0026apos;\u0026lt;/span\u0026gt;: \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;c\u0026apos;\u0026lt;/span\u0026gt;: \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;11\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;b\u0026apos;\u0026lt;/span\u0026gt;: \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;12\u0026lt;/span\u0026gt;}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;There will be a new option when Python 3.8 releases (\u0026lt;a href=\u0026quot;https://www.python.org/dev/peps/pep-0569/#release-schedule\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;scheduled for 20 October, 2019\u0026lt;/a\u0026gt;), thanks to \u0026lt;a href=\u0026quot;https://www.python.org/dev/peps/pep-0572/\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;PEP 572: Assignment Expressions\u0026lt;/a\u0026gt;. The new assignment expression operator \u0026lt;code\u0026gt;:=\u0026lt;/code\u0026gt; allows you to assign the result of the \u0026lt;code\u0026gt;copy\u0026lt;/code\u0026gt; and still use it to call \u0026lt;code\u0026gt;update\u0026lt;/code\u0026gt;, leaving the combined code a single expression, rather than two statements, changing:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;newdict = dict1.copy()\nnewdict.update(dict2)\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;to:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;(newdict := dict1.copy()).update(dict2)\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;while behaving identically in every way. If you must also return the resulting \u0026lt;code\u0026gt;dict\u0026lt;/code\u0026gt; (you asked for an expression returning the \u0026lt;code\u0026gt;dict\u0026lt;/code\u0026gt;; the above creates and assigns to \u0026lt;code\u0026gt;newdict\u0026lt;/code\u0026gt;, but doesn\u0026apos;t return it, so you couldn\u0026apos;t use it to pass an argument to a function as is, a la \u0026lt;code\u0026gt;myfunc((newdict := dict1.copy()).update(dict2))\u0026lt;/code\u0026gt;), then just add \u0026lt;code\u0026gt;or newdict\u0026lt;/code\u0026gt; to the end (since \u0026lt;code\u0026gt;update\u0026lt;/code\u0026gt; returns \u0026lt;code\u0026gt;None\u0026lt;/code\u0026gt;, which is falsy, it will then evaluate and return \u0026lt;code\u0026gt;newdict\u0026lt;/code\u0026gt; as the result of the expression):\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;(newdict := dict1.copy()).update(dict2) \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;or\u0026lt;/span\u0026gt; newdict\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Important caveat:\u0026lt;/strong\u0026gt; In general, I\u0026apos;d discourage this approach in favor of:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;newdict = {**dict1, **dict2}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;The unpacking approach is clearer (to anyone who knows about generalized unpacking in the first place, \u0026lt;a href=\u0026quot;https://www.python.org/dev/peps/pep-0448/\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;which you should\u0026lt;/a\u0026gt;), doesn\u0026apos;t require a name for the result at all (so it\u0026apos;s much more concise when constructing a temporary that is immediately passed to a function or included in a \u0026lt;code\u0026gt;list\u0026lt;/code\u0026gt;/\u0026lt;code\u0026gt;tuple\u0026lt;/code\u0026gt; literal or the like), and is almost certainly faster as well, being (on CPython) roughly equivalent to:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;newdict = {}\nnewdict.update(dict1)\nnewdict.update(dict2)\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;but done at the C layer, using the concrete \u0026lt;code\u0026gt;dict\u0026lt;/code\u0026gt; API, so no dynamic method lookup/binding or function call dispatch overhead is involved (where \u0026lt;code\u0026gt;(newdict := dict1.copy()).update(dict2)\u0026lt;/code\u0026gt; is unavoidably identical to the original two-liner in behavior, performing the work in discrete steps, with dynamic lookup/binding/invocation of methods.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;It\u0026apos;s also more extensible, as merging three \u0026lt;code\u0026gt;dict\u0026lt;/code\u0026gt;s is obvious:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt; newdict = {**dict1, **dict2, **dict3}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;where using assignment expressions won\u0026apos;t scale like that; the closest you could get would be:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt; (newdict := dict1.copy()).update(dict2), newdict.update(dict3)\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;or without the temporary tuple of \u0026lt;code\u0026gt;None\u0026lt;/code\u0026gt;s, but with truthiness testing of each \u0026lt;code\u0026gt;None\u0026lt;/code\u0026gt; result:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt; (newdict := dict1.copy()).update(dict2) \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;or\u0026lt;/span\u0026gt; newdict.update(dict3)\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;either of which is obviously much uglier, and includes further inefficiencies (either a wasted temporary \u0026lt;code\u0026gt;tuple\u0026lt;/code\u0026gt; of \u0026lt;code\u0026gt;None\u0026lt;/code\u0026gt;s for comma separation, or pointless truthiness testing of each \u0026lt;code\u0026gt;update\u0026lt;/code\u0026gt;\u0026apos;s \u0026lt;code\u0026gt;None\u0026lt;/code\u0026gt; return for \u0026lt;code\u0026gt;or\u0026lt;/code\u0026gt; separation).\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;The only real advantage to the assignment expression approach occurs if:\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;ol\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;strong\u0026gt;You have generic code that needs handle both \u0026lt;code\u0026gt;set\u0026lt;/code\u0026gt;s and \u0026lt;code\u0026gt;dict\u0026lt;/code\u0026gt;s\u0026lt;/strong\u0026gt; (both of them support \u0026lt;code\u0026gt;copy\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;update\u0026lt;/code\u0026gt;, so the code works roughly as you\u0026apos;d expect it to)\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;strong\u0026gt;You expect to receive arbitrary dict-like objects\u0026lt;/strong\u0026gt;, not just \u0026lt;code\u0026gt;dict\u0026lt;/code\u0026gt; itself, \u0026lt;strong\u0026gt;and must preserve the type and semantics of the left hand side\u0026lt;/strong\u0026gt; (rather than ending up with a plain \u0026lt;code\u0026gt;dict\u0026lt;/code\u0026gt;). While \u0026lt;code\u0026gt;myspecialdict({**speciala, **specialb})\u0026lt;/code\u0026gt; might work, it would involve an extra temporary \u0026lt;code\u0026gt;dict\u0026lt;/code\u0026gt;, and if \u0026lt;code\u0026gt;myspecialdict\u0026lt;/code\u0026gt; has features plain \u0026lt;code\u0026gt;dict\u0026lt;/code\u0026gt; can\u0026apos;t preserve (e.g. regular \u0026lt;code\u0026gt;dict\u0026lt;/code\u0026gt;s now preserve order based on the first appearance of a key, and value based on the last appearance of a key; you might want one that preserves order based on the \u0026lt;em\u0026gt;last\u0026lt;/em\u0026gt; appearance of a key so updating a value also moves it to the end), then the semantics would be wrong. Since the assignment expression version uses the named methods (which are presumably overloaded to behave appropriately), it never creates a \u0026lt;code\u0026gt;dict\u0026lt;/code\u0026gt; at all (unless \u0026lt;code\u0026gt;dict1\u0026lt;/code\u0026gt; was already a \u0026lt;code\u0026gt;dict\u0026lt;/code\u0026gt;), preserving the original type (and original type\u0026apos;s semantics), all while avoiding any temporaries.\u0026lt;/li\u0026gt;\n\u0026lt;/ol\u0026gt;\n    ","\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;from\u0026lt;/span\u0026gt; collections \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;import\u0026lt;/span\u0026gt; Counter\ndict1 = {\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;a\u0026apos;\u0026lt;/span\u0026gt;:\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;b\u0026apos;\u0026lt;/span\u0026gt;: \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;}\ndict2 = {\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;b\u0026apos;\u0026lt;/span\u0026gt;:\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;10\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;c\u0026apos;\u0026lt;/span\u0026gt;: \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;11\u0026lt;/span\u0026gt;}\nresult = \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;dict\u0026lt;/span\u0026gt;(Counter(dict1) + Counter(dict2))\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;This should solve your problem.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;This can be done with a single dict comprehension:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026amp;gt; \u0026lt;/span\u0026gt;x = {\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;a\u0026apos;\u0026lt;/span\u0026gt;:\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;b\u0026apos;\u0026lt;/span\u0026gt;: \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;}\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026amp;gt; \u0026lt;/span\u0026gt;y = {\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;b\u0026apos;\u0026lt;/span\u0026gt;:\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;10\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;c\u0026apos;\u0026lt;/span\u0026gt;: \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;11\u0026lt;/span\u0026gt;}\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026amp;gt; \u0026lt;/span\u0026gt;{ key: y[key] \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; key \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;in\u0026lt;/span\u0026gt; y \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;else\u0026lt;/span\u0026gt; x[key]\n      \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt; key \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;in\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;set\u0026lt;/span\u0026gt;(x) + \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;set\u0026lt;/span\u0026gt;(y)\n    }\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;In my view the best answer for the \u0026apos;single expression\u0026apos; part as no extra functions are needed, and it is short.\u0026lt;/p\u0026gt;\n    "],"id":311,"title":"How do I merge two dictionaries in a single expression?","content":"\n                \n\u0026lt;p\u0026gt;I want to merge two dictionaries into a new dictionary.\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;x = {\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;a\u0026apos;\u0026lt;/span\u0026gt;: \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;b\u0026apos;\u0026lt;/span\u0026gt;: \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;}\ny = {\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;b\u0026apos;\u0026lt;/span\u0026gt;: \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;c\u0026apos;\u0026lt;/span\u0026gt;: \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;4\u0026lt;/span\u0026gt;}\nz = merge(x, y)\n\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026amp;gt; \u0026lt;/span\u0026gt;z\n{\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;a\u0026apos;\u0026lt;/span\u0026gt;: \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;b\u0026apos;\u0026lt;/span\u0026gt;: \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;c\u0026apos;\u0026lt;/span\u0026gt;: \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;4\u0026lt;/span\u0026gt;}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;Whenever a key \u0026lt;code\u0026gt;k\u0026lt;/code\u0026gt; is present in both dictionaries, only the value \u0026lt;code\u0026gt;y[k]\u0026lt;/code\u0026gt; should be kept.\u0026lt;/p\u0026gt;\n    ","slug":"how-do-i-merge-two-dictionaries-in-a-single-expression-1657387593160","postType":"QUESTION","createdAt":"2022-07-09T17:26:33.000Z","updatedAt":"2022-07-09T17:26:33.000Z","tags":[],"relatedQuestions":[]},"randomQuestions":[{"title":"When should static_cast, dynamic_cast, const_cast, and reinterpret_cast be used?","slug":"when-should-static_cast-dynamic_cast-const_cast-and-reinterpret_cast-be-used-1657388406205"},{"title":"JQuery - $ is not defined","slug":"jquery-dollar-is-not-defined-1657388385731"},{"title":"Why is using \"for...in\" for array iteration a bad idea?","slug":"why-is-using-\"for...in\"-for-array-iteration-a-bad-idea-1657384653458"},{"title":"What does the comma operator , do?","slug":"what-does-the-comma-operator-do-1657388258021"},{"title":"How do I split a list into equally-sized chunks?","slug":"how-do-i-split-a-list-into-equally-sized-chunks-1657384580399"},{"title":"When to use LinkedList over ArrayList in Java?","slug":"when-to-use-linkedlist-over-arraylist-in-java-1657388107480"},{"title":"How do I pass JavaScript variables to PHP?","slug":"how-do-i-pass-javascript-variables-to-php-1657388157033"},{"title":"How to add to the PYTHONPATH in Windows, so it finds my modules/packages?","slug":"how-to-add-to-the-pythonpath-in-windows-so-it-finds-my-modulespackages-1657388540360"},{"title":"Why not use Double or Float to represent currency?","slug":"why-not-use-double-or-float-to-represent-currency-1657387417964"},{"title":"What are drawbacks or disadvantages of singleton pattern? [closed]","slug":"what-are-drawbacks-or-disadvantages-of-singleton-pattern-closed-1657387360749"},{"title":"What are the rules about using an underscore in a C++ identifier?","slug":"what-are-the-rules-about-using-an-underscore-in-a-c++-identifier-1657384557197"},{"title":"Why is the gets function so dangerous that it should not be used?","slug":"why-is-the-gets-function-so-dangerous-that-it-should-not-be-used-1657384544362"},{"title":"What is the difference between == and equals() in Java?","slug":"what-is-the-difference-between-and-equals()-in-java-1657387729654"},{"title":"Retrieve only the queried element in an object array in MongoDB collection","slug":"retrieve-only-the-queried-element-in-an-object-array-in-mongodb-collection-1657384890457"},{"title":"PHP - Failed to open stream : No such file or directory","slug":"php-failed-to-open-stream-:-no-such-file-or-directory-1657387872896"},{"title":"How to make a div 100% height of the browser window","slug":"how-to-make-a-div-100percent-height-of-the-browser-window-1657388265955"},{"title":"Parameterize an SQL IN clause","slug":"parameterize-an-sql-in-clause-1657387536064"},{"title":"Tkinter: AttributeError: NoneType object has no attribute \u003cattribute name\u003e","slug":"tkinter:-attributeerror:-nonetype-object-has-no-attribute-lessattribute-namegreater-1657385472410"},{"title":"What are the nuances of scope prototypal / prototypical inheritance in AngularJS?","slug":"what-are-the-nuances-of-scope-prototypal-prototypical-inheritance-in-angularjs-1657387340067"},{"title":"Flexbox: center horizontally and vertically","slug":"flexbox:-center-horizontally-and-vertically-1657384587888"}]},"__N_SSG":true},"page":"/questions/[slug]","query":{"slug":"how-do-i-merge-two-dictionaries-in-a-single-expression-1657387593160"},"buildId":"TQ2eYlCSdocSK-hq6gkM0","isFallback":false,"gsp":true,"locale":"en","locales":["en"],"defaultLocale":"en","scriptLoader":[]}</script></body></html>