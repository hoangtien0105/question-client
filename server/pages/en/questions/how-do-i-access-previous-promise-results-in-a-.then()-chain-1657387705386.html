<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><meta name="twitter:card" content="summary_large_image"/><meta name="twitter:site" content="@solutionschecker.com"/><meta name="twitter:creator" content="@solutionschecker.com"/><meta property="og:url" content="https://solutionschecker.com"/><meta property="og:type" content="website"/><meta property="og:image" content="https://solutionschecker.com/solutions-checker-banner.png"/><meta property="og:image:alt" content="Find the solution to any question. We focus on finding the fastest possible solution for users. Main topics like coding, learning. - solutionschecker.com"/><link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png"/><link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png"/><link rel="manifest" href="/site.webmanifest"/><script type="application/ld+json">{"@context":"https://schema.org","@type":"Organization","logo":"/logo.svg","url":"https://solutionschecker.com"}</script><link name="keywords" content="solutions checker, solution checker, how to, solution for, check for solution, resolve question, what is, what solution for, find solution"/><script type="application/ld+json">{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"item":{"@id":"https://solutionschecker.com","name":"Home"}},{"@type":"ListItem","position":2,"item":{"@id":"https://solutionschecker.com/questions","name":"Questions"}},{"@type":"ListItem","position":3,"item":{"@id":"https://solutionschecker.com/questions/how-do-i-access-previous-promise-results-in-a-.then()-chain-1657387705386","name":"Questions"}}]}</script><title>How do I access previous promise results in a .then() chain? | Solution Checker</title><meta name="robots" content="index,follow"/><meta name="description" content="I have restructured my code to promises, and built a wonderful long flat promise chain, consisting of multiple .then() callbacks. In the end I want to return some composite value, and need to access multiple intermediate promise results. However the resolution values from the middle of the sequence are not in scope in the last callback, how do I access them?

function getExample() {
    return promiseA(…).then(function(resultA) {
        // Some processing
        return promiseB(…);
    }).then(function(resultB) {
        // More processing
        return // How do I gain access to resultA here?
    });
}

    "/><meta property="og:title" content="How do I access previous promise results in a .then() chain? | Solution Checker"/><meta property="og:description" content="I have restructured my code to promises, and built a wonderful long flat promise chain, consisting of multiple .then() callbacks. In the end I want to return some composite value, and need to access multiple intermediate promise results. However the resolution values from the middle of the sequence are not in scope in the last callback, how do I access them?

function getExample() {
    return promiseA(…).then(function(resultA) {
        // Some processing
        return promiseB(…);
    }).then(function(resultB) {
        // More processing
        return // How do I gain access to resultA here?
    });
}

    "/><script type="application/ld+json">{"@context":"https://schema.org","@type":"QAPage","mainEntity":{"name":"How do I access previous promise results in a .then() chain?","text":"I have restructured my code to promises, and built a wonderful long flat promise chain, consisting of multiple .then() callbacks. In the end I want to return some composite value, and need to access multiple intermediate promise results. However the resolution values from the middle of the sequence are not in scope in the last callback, how do I access them?\n\nfunction getExample() {\n    return promiseA(…).then(function(resultA) {\n        // Some processing\n        return promiseB(…);\n    }).then(function(resultB) {\n        // More processing\n        return // How do I gain access to resultA here?\n    });\n}\n\n    ","answerCount":17,"upVoteCount":500,"suggestedAnswer":[{"text":"Break the chain\n\nWhen you need to access the intermediate values in your chain, you should split your chain apart in those single pieces that you need. Instead of attaching one callback and somehow trying to use its parameter multiple times, attach multiple callbacks to the same promise - wherever you need the result value. Don&apos;t forget, a promise just represents (proxies) a future value! Next to deriving one promise from the other in a linear chain, use the promise combinators that are given to you by your library to build the result value.\n\nThis will result in a very straightforward control flow, clear composition of functionalities and therefore easy modularisation.\n\nfunction getExample() {\n    var a = promiseA();\n    var b = a.then(function(resultA) {\n        // some processing\n        return promiseB();\n    });\n    return Promise.all([a, b]).then(function([resultA, resultB]) {\n        // more processing\n        return // something using both resultA and resultB\n    });\n}\n\n\nInstead of the parameter destructuring in the callback after Promise.all that only became avail­able with ES6, in ES5 the then call would be replaced by a nifty helper method that was provided by many promise libraries (Q, Bluebird, when, ): .spread(function(resultA, resultB) { .\n\nBluebird also features a dedicated join function to replace that Promise.all+spread combination with a simpler (and more efficient) construct:\n\n\nreturn Promise.join(a, b, function(resultA, resultB) {  });\n\n    ","url":"https://solutionschecker.com/questions/how-do-i-access-previous-promise-results-in-a-.then()-chain-1657387705386#solution1","@type":"Answer","upvoteCount":0},{"text":"ECMAScript Harmony\nOf course, this problem was recognized by the language designers as well. They did a lot of work and the async functions proposal finally made it into\nECMAScript 8\nYou don&apos;t need a single then invocation or callback function anymore, as in an asynchronous function (that returns a promise when being called) you can simply wait for promises to resolve directly. It also features arbitrary control structures like conditions, loops and try-catch-clauses, but for the sake of convenience we don&apos;t need them here:\nasync function getExample() {\n    var resultA = await promiseA();\n    // some processing\n    var resultB = await promiseB();\n    // more processing\n    return // something using both resultA and resultB\n}\n\nECMAScript 6\nWhile we were waiting for ES8, we already did use a very similar kind of syntax. ES6 came with generator functions, which allow breaking the execution apart in pieces at arbitrarily placed yield keywords. Those slices can be run after each other, independently, even asynchronously - and that&apos;s just what we do when we want to wait for a promise resolution before running the next step.\nThere are dedicated libraries (like co or task.js), but also many promise libraries have helper functions (Q, Bluebird, when, ) that do this async step-by-step execution for you when you give them a generator function that yields promises.\nvar getExample = Promise.coroutine(function* () {\n//               ^^^^^^^^^^^^^^^^^ Bluebird syntax\n    var resultA = yield promiseA();\n    // some processing\n    var resultB = yield promiseB();\n    // more processing\n    return // something using both resultA and resultB\n});\n\nThis did work in Node.js since version 4.0, also a few browsers (or their dev editions) did support generator syntax relatively early.\nECMAScript 5\nHowever, if you want/need to be backward-compatible you cannot use those without a transpiler. Both generator functions and async functions are supported by the current tooling, see for example the documentation of Babel on generators and async functions.\nAnd then, there are also many other compile-to-JS languages\nthat are dedicated to easing asynchronous programming. They usually use a syntax similar to await, (e.g. Iced CoffeeScript), but there are also others that feature a Haskell-like do-notation (e.g. LatteJs, monadic, PureScript or LispyScript).\n    ","url":"https://solutionschecker.com/questions/how-do-i-access-previous-promise-results-in-a-.then()-chain-1657387705386#solution2","@type":"Answer","upvoteCount":0},{"text":"Synchronous inspection\n\nAssigning promises-for-later-needed-values to variables and then getting their value via synchronous inspection. The example uses bluebird&apos;s .value() method but many libraries provide similar method.\n\nfunction getExample() {\n    var a = promiseA();\n\n    return a.then(function() {\n        // some processing\n        return promiseB();\n    }).then(function(resultB) {\n        // a is guaranteed to be fulfilled here so we can just retrieve its\n        // value synchronously\n        var aValue = a.value();\n    });\n}\n\n\nThis can be used for as many values as you like:\n\nfunction getExample() {\n    var a = promiseA();\n\n    var b = a.then(function() {\n        return promiseB()\n    });\n\n    var c = b.then(function() {\n        return promiseC();\n    });\n\n    var d = c.then(function() {\n        return promiseD();\n    });\n\n    return d.then(function() {\n        return a.value() + b.value() + c.value() + d.value();\n    });\n}\n\n    ","url":"https://solutionschecker.com/questions/how-do-i-access-previous-promise-results-in-a-.then()-chain-1657387705386#solution3","@type":"Answer","upvoteCount":0},{"text":"Nesting (and) closures\n\nUsing closures for maintaining the scope of variables (in our case, the success callback function parameters) is the natural JavaScript solution. With promises, we can arbitrarily nest and flatten .then() callbacks - they are semantically equivalent, except for the scope of the inner one.\n\nfunction getExample() {\n    return promiseA().then(function(resultA) {\n        // some processing\n        return promiseB().then(function(resultB) {\n            // more processing\n            return // something using both resultA and resultB;\n        });\n    });\n}\n\n\nOf course, this is building an indentation pyramid. If indentation is getting too large, you still can apply the old tools to counter the pyramid of doom: modularize, use extra named functions, and flatten the promise chain as soon as you don&apos;t need a variable any more.\nIn theory, you can always avoid more than two levels of nesting (by making all closures explicit), in practise use as many as are reasonable.\n\nfunction getExample() {\n    // preprocessing\n    return promiseA().then(makeAhandler());\n}\nfunction makeAhandler()\n    return function(resultA) {\n        // some processing\n        return promiseB().then(makeBhandler(resultA, ));\n    };\n}\nfunction makeBhandler(resultA, ) {\n    return function(resultB) {\n        // more processing\n        return // anything that uses the variables in scope\n    };\n}\n\n\nYou can also use helper functions for this kind of partial application, like _.partial from Underscore/lodash or the native .bind() method, to further decrease indentation:\n\nfunction getExample() {\n    // preprocessing\n    return promiseA().then(handlerA);\n}\nfunction handlerA(resultA) {\n    // some processing\n    return promiseB().then(handlerB.bind(null, resultA));\n}\nfunction handlerB(resultA, resultB) {\n    // more processing\n    return // anything that uses resultA and resultB\n}\n\n    ","url":"https://solutionschecker.com/questions/how-do-i-access-previous-promise-results-in-a-.then()-chain-1657387705386#solution4","@type":"Answer","upvoteCount":0},{"text":"Explicit pass-through\n\nSimilar to nesting the callbacks, this technique relies on closures. Yet, the chain stays flat - instead of passing only the latest result, some state object is passed for every step. These state objects accumulate the results of the previous actions, handing down all values that will be needed later again plus the result of the current task.\n\nfunction getExample() {\n    return promiseA().then(function(resultA) {\n        // some processing\n        return promiseB().then(b =&gt; [resultA, b]); // function(b) { return [resultA, b] }\n    }).then(function([resultA, resultB]) {\n        // more processing\n        return // something using both resultA and resultB\n    });\n}\n\n\nHere, that little arrow b =&gt; [resultA, b] is the function that closes over resultA, and passes an array of both results to the next step. Which uses parameter destructuring syntax to break it up in single variables again.\n\nBefore destructuring became available with ES6, a nifty helper method called .spread() was pro­vi­ded by many promise libraries (Q, Bluebird, when, ). It takes a function with multiple parameters - one for each array element - to be used as .spread(function(resultA, resultB) { .\n\nOf course, that closure needed here can be further simplified by some helper functions, e.g.\n\nfunction addTo(x) {\n    // imagine complex `arguments` fiddling or anything that helps usability\n    // but you get the idea with this simple one:\n    return res =&gt; [x, res];\n}\n\n\nreturn promiseB().then(addTo(resultA));\n\n\nAlternatively, you can employ Promise.all to produce the promise for the array:\n\nfunction getExample() {\n    return promiseA().then(function(resultA) {\n        // some processing\n        return Promise.all([resultA, promiseB()]); // resultA will implicitly be wrapped\n                                                    // as if passed to Promise.resolve()\n    }).then(function([resultA, resultB]) {\n        // more processing\n        return // something using both resultA and resultB\n    });\n}\n\n\nAnd you might not only use arrays, but arbitrarily complex objects. For example, with _.extend or Object.assign in a different helper function:\n\nfunction augment(obj, name) {\n    return function (res) { var r = Object.assign({}, obj); r[name] = res; return r; };\n}\n\nfunction getExample() {\n    return promiseA().then(function(resultA) {\n        // some processing\n        return promiseB().then(augment({resultA}, &quot;resultB&quot;));\n    }).then(function(obj) {\n        // more processing\n        return // something using both obj.resultA and obj.resultB\n    });\n}\n\n\nWhile this pattern guarantees a flat chain and explicit state objects can improve clarity, it will become tedious for a long chain. Especially when you need the state only sporadically, you still have to pass it through every step. With this fixed interface, the single callbacks in the chain are rather tightly coupled and inflexible to change. It makes factoring out single steps harder, and callbacks cannot be supplied directly from other modules - they always need to be wrapped in boilerplate code that cares about the state. Abstract helper functions like the above can ease the pain a bit, but it will always be present.\n    ","url":"https://solutionschecker.com/questions/how-do-i-access-previous-promise-results-in-a-.then()-chain-1657387705386#solution5","@type":"Answer","upvoteCount":0},{"text":"Mutable contextual state\n\nThe trivial (but inelegant and rather errorprone) solution is to just use higher-scope variables (to which all callbacks in the chain have access) and write result values to them when you get them:\n\nfunction getExample() {\n    var resultA;\n    return promiseA().then(function(_resultA) {\n        resultA = _resultA;\n        // some processing\n        return promiseB();\n    }).then(function(resultB) {\n        // more processing\n        return // something using both resultA and resultB\n    });\n}\n\n\nInstead of many variables one might also use an (initially empty) object, on which the results are stored as dynamically created properties.\n\nThis solution has several drawbacks:\n\n\nMutable state is ugly, and global variables are evil.\nThis pattern doesn&apos;t work across function boundaries, modularising the functions is harder as their declarations must not leave the shared scope\nThe scope of the variables does not prevent to access them before they are initialized. This is especially likely for complex promise constructions (loops, branching, excptions) where race conditions might happen. Passing state explicitly, a declarative design that promises encourage, forces a cleaner coding style which can prevent this.\nOne must choose the scope for those shared variables correctly. It needs to be local to the executed function to prevent race conditions between multiple parallel invocations, as would be the case if, for example, state was stored on an instance.\n\n\nThe Bluebird library encourages the use of an object that is passed along, using their bind() method to assign a context object to a promise chain. It will be accessible from each callback function via the otherwise unusable this keyword. While object properties are more prone to undetected typos than variables, the pattern is quite clever:\n\nfunction getExample() {\n    return promiseA()\n    .bind({}) // Bluebird only!\n    .then(function(resultA) {\n        this.resultA = resultA;\n        // some processing\n        return promiseB();\n    }).then(function(resultB) {\n        // more processing\n        return // something using both this.resultA and resultB\n    }).bind(); // don&apos;t forget to unbind the object if you don&apos;t want the\n               // caller to access it\n}\n\n\nThis approach can be easily simulated in promise libraries that do not support .bind (although in a somewhat more verbose way and cannot be used in an expression):\n\nfunction getExample() {\n    var ctx = {};\n    return promiseA()\n    .then(function(resultA) {\n        this.resultA = resultA;\n        // some processing\n        return promiseB();\n    }.bind(ctx)).then(function(resultB) {\n        // more processing\n        return // something using both this.resultA and resultB\n    }.bind(ctx));\n}\n\n    ","url":"https://solutionschecker.com/questions/how-do-i-access-previous-promise-results-in-a-.then()-chain-1657387705386#solution6","@type":"Answer","upvoteCount":0},{"text":"A less harsh spin on &quot;Mutable contextual state&quot;\nUsing a locally scoped object to collect the intermediate results in a promise chain is a reasonable approach to the question you posed. Consider the following snippet:\nfunction getExample(){\n    //locally scoped\n    const results = {};\n    return promiseA(paramsA).then(function(resultA){\n        results.a = resultA;\n        return promiseB(paramsB);\n    }).then(function(resultB){\n        results.b = resultB;\n        return promiseC(paramsC);\n    }).then(function(resultC){\n        //Resolve with composite of all promises\n        return Promise.resolve(results.a + results.b + resultC);\n    }).catch(function(error){\n        return Promise.reject(error);\n    });\n}\n\n\nGlobal variables are bad, so this solution uses a locally scoped variable which causes no harm.  It is only accessible within the function.\nMutable state is ugly, but this does not mutate state in an ugly manner.  The ugly mutable state traditionally refers to modifying the state of function arguments or global variables, but this approach simply modifies the state of a locally scoped variable that exists for the sole purpose of aggregating promise results...a variable that will die a simple death once the promise resolves.\nIntermediate promises are not prevented from accessing the state of the results object, but this does not introduce some scary scenario where one of the promises in the chain will go rogue and sabotage your results.  The responsibility of setting the values in each step of the promise is confined to this function and the overall result will either be correct or incorrect...it will not be some bug that will crop up years later in production (unless you intend it to!)\nThis does not introduce a race condition scenario that would arise from parallel invocation because a new instance of the results variable is created for every invocation of the getExample function.\n\nExample is available on jsfiddle\n    ","url":"https://solutionschecker.com/questions/how-do-i-access-previous-promise-results-in-a-.then()-chain-1657387705386#solution7","@type":"Answer","upvoteCount":0},{"text":"Node 7.4 now supports async/await calls with the harmony flag.\n\nTry this: \n\nasync function getExample(){\n\n  let response = await returnPromise();\n\n  let response2 = await returnPromise2();\n\n  console.log(response, response2)\n\n}\n\ngetExample()\n\n\nand run the file with:\n\nnode --harmony-async-await getExample.js\n\nSimple as can be!\n    ","url":"https://solutionschecker.com/questions/how-do-i-access-previous-promise-results-in-a-.then()-chain-1657387705386#solution8","@type":"Answer","upvoteCount":0},{"text":"Another answer, using babel-node version &lt;6 \n\nUsing async - await \n\nnpm install -g babel@5.6.14\n\nexample.js:\n\nasync function getExample(){\n\n  let response = await returnPromise();\n\n  let response2 = await returnPromise2();\n\n  console.log(response, response2)\n\n}\n\ngetExample()\n\n\nThen, run babel-node example.js and voila!\n    ","url":"https://solutionschecker.com/questions/how-do-i-access-previous-promise-results-in-a-.then()-chain-1657387705386#solution9","@type":"Answer","upvoteCount":0},{"text":"This days, I also hava meet some questions like you. At last, I find a good solution with the quesition, it&apos;s simple and good to read. I hope this can help you.\n\nAccording to how-to-chain-javascript-promises\n\nok, let&apos;s look at the code:\n\nconst firstPromise = () =&gt; {\n    return new Promise((resolve, reject) =&gt; {\n        setTimeout(() =&gt; {\n            console.log(&apos;first promise is completed&apos;);\n            resolve({data: &apos;123&apos;});\n        }, 2000);\n    });\n};\n\nconst secondPromise = (someStuff) =&gt; {\n    return new Promise((resolve, reject) =&gt; {\n        setTimeout(() =&gt; {\n            console.log(&apos;second promise is completed&apos;);\n            resolve({newData: `${someStuff.data} some more data`});\n        }, 2000);\n    });\n};\n\nconst thirdPromise = (someStuff) =&gt; {\n    return new Promise((resolve, reject) =&gt; {\n        setTimeout(() =&gt; {\n            console.log(&apos;third promise is completed&apos;);\n            resolve({result: someStuff});\n        }, 2000);\n    });\n};\n\nfirstPromise()\n    .then(secondPromise)\n    .then(thirdPromise)\n    .then(data =&gt; {\n        console.log(data);\n    });\n\n    ","url":"https://solutionschecker.com/questions/how-do-i-access-previous-promise-results-in-a-.then()-chain-1657387705386#solution10","@type":"Answer","upvoteCount":0},{"text":"I am not going to use this pattern in my own code since I&apos;m not a big fan of using global variables. However, in a pinch it will work.\n\nUser is a promisified Mongoose model.\n\nvar globalVar = &apos;&apos;;\n\nUser.findAsync({}).then(function(users){\n  globalVar = users;\n}).then(function(){\n  console.log(globalVar);\n});\n\n    ","url":"https://solutionschecker.com/questions/how-do-i-access-previous-promise-results-in-a-.then()-chain-1657387705386#solution11","@type":"Answer","upvoteCount":0},{"text":"Another answer, using sequential executor nsynjs:\n\nfunction getExample(){\n\n  var response1 = returnPromise1().data;\n\n  // promise1 is resolved at this point, &apos;.data&apos; has the result from resolve(result)\n\n  var response2 = returnPromise2().data;\n\n  // promise2 is resolved at this point, &apos;.data&apos; has the result from resolve(result)\n\n  console.log(response, response2);\n\n}\n\nnynjs.run(getExample,{},function(){\n    console.log(&apos;all done&apos;);\n})\n\n\nUpdate: added working example\n\n\n\nfunction synchronousCode() {\n     var urls=[\n         &quot;https://ajax.googleapis.com/ajax/libs/jquery/1.7.0/jquery.min.js&quot;,\n         &quot;https://ajax.googleapis.com/ajax/libs/jquery/1.8.0/jquery.min.js&quot;,\n         &quot;https://ajax.googleapis.com/ajax/libs/jquery/1.9.0/jquery.min.js&quot;\n     ];\n     for(var i=0; i&lt;urls.length; i++) {\n         var len=window.fetch(urls[i]).data.text().data.length;\n         //             ^                   ^\n         //             |                   +- 2-nd promise result\n         //             |                      assigned to &apos;data&apos;\n         //             |\n         //             +-- 1-st promise result assigned to &apos;data&apos;\n         //\n         console.log(&apos;URL #&apos;+i+&apos; : &apos;+urls[i]+&quot;, length: &quot;+len);\n     }\n}\n\nnsynjs.run(synchronousCode,{},function(){\n    console.log(&apos;all done&apos;);\n})\n&lt;script src=&quot;https://rawgit.com/amaksr/nsynjs/master/nsynjs.js&quot;&gt;&lt;/script&gt;\n Run code snippetHide resultsExpand snippet\n\n\n    ","url":"https://solutionschecker.com/questions/how-do-i-access-previous-promise-results-in-a-.then()-chain-1657387705386#solution12","@type":"Answer","upvoteCount":0},{"text":"When using bluebird, you can use .bind method to share variables in promise chain:\n\nsomethingAsync().bind({})\n.spread(function (aValue, bValue) {\n    this.aValue = aValue;\n    this.bValue = bValue;\n    return somethingElseAsync(aValue, bValue);\n})\n.then(function (cValue) {\n    return this.aValue + this.bValue + cValue;\n});\n\n\nplease check this link for further information:\n\nhttp://bluebirdjs.com/docs/api/promise.bind.html\n    ","url":"https://solutionschecker.com/questions/how-do-i-access-previous-promise-results-in-a-.then()-chain-1657387705386#solution13","@type":"Answer","upvoteCount":0},{"text":"function getExample() {\n    var retA, retB;\n    return promiseA().then(function(resultA) {\n        retA = resultA;\n        // Some processing\n        return promiseB();\n    }).then(function(resultB) {\n        // More processing\n        //retA is value of promiseA\n        return // How do I gain access to resultA here?\n    });\n}\n\n\neasy way :D\n    ","url":"https://solutionschecker.com/questions/how-do-i-access-previous-promise-results-in-a-.then()-chain-1657387705386#solution14","@type":"Answer","upvoteCount":0},{"text":"I think you can use hash of RSVP.\n\nSomething like as below :\n\n    const mainPromise = () =&gt; {\n        const promise1 = new Promise((resolve, reject) =&gt; {\n            setTimeout(() =&gt; {\n                console.log(&apos;first promise is completed&apos;);\n                resolve({data: &apos;123&apos;});\n            }, 2000);\n        });\n\n        const promise2 = new Promise((resolve, reject) =&gt; {\n            setTimeout(() =&gt; {\n                console.log(&apos;second promise is completed&apos;);\n                resolve({data: &apos;456&apos;});\n            }, 2000);\n        });\n\n        return new RSVP.hash({\n              prom1: promise1,\n              prom2: promise2\n          });\n\n    };\n\n\n   mainPromise()\n    .then(data =&gt; {\n        console.log(data.prom1);\n        console.log(data.prom2);\n    });\n\n    ","url":"https://solutionschecker.com/questions/how-do-i-access-previous-promise-results-in-a-.then()-chain-1657387705386#solution15","@type":"Answer","upvoteCount":0},{"text":"Solution:\n\nYou can put intermediate values in scope in any later &apos;then&apos; function explicitly, by using &apos;bind&apos;. It is a nice solution that doesn&apos;t require changing how Promises work, and only requires a line or two of code to propagate the values just like errors are already propagated.\n\nHere is a complete example:\n\n// Get info asynchronously from a server\nfunction pGetServerInfo()\n    {\n    // then value: &quot;server info&quot;\n    } // pGetServerInfo\n\n// Write into a file asynchronously\nfunction pWriteFile(path,string)\n    {\n    // no then value\n    } // pWriteFile\n\n// The heart of the solution: Write formatted info into a log file asynchronously,\n// using the pGetServerInfo and pWriteFile operations\nfunction pLogInfo(localInfo)\n    {\n    var scope={localInfo:localInfo}; // Create an explicit scope object\n    var thenFunc=p2.bind(scope); // Create a temporary function with this scope\n    return (pGetServerInfo().then(thenFunc)); // Do the next &apos;then&apos; in the chain\n    } // pLogInfo\n\n// Scope of this &apos;then&apos; function is {localInfo:localInfo}\nfunction p2(serverInfo)\n    {\n    // Do the final &apos;then&apos; in the chain: Writes &quot;local info, server info&quot;\n    return pWriteFile(&apos;log&apos;,this.localInfo+&apos;,&apos;+serverInfo);\n    } // p2\n\n\nThis solution can be invoked as follows:\n\npLogInfo(&quot;local info&quot;).then().catch(err);\n\n\n(Note: a more complex and complete version of this solution has been tested, but not this example version, so it could have a bug.)\n    ","url":"https://solutionschecker.com/questions/how-do-i-access-previous-promise-results-in-a-.then()-chain-1657387705386#solution16","@type":"Answer","upvoteCount":0},{"text":"What I learn about promises is to use it only as return values avoid referencing them if possible. async/await syntax is particularly practical for that. Today all latest browsers and node support it: https://caniuse.com/#feat=async-functions , is a simple behavior and the code is like reading synchronous code, forget about callbacks...\n\nIn cases I do need to reference a promises is when creation and resolution happen at independent/not-related places. So instead an artificial association and probably an event listener just to resolve the &quot;distant&quot; promise, I prefer to expose the promise as a Deferred, which the following code implements it in valid es5\n\n/**\n * Promise like object that allows to resolve it promise from outside code. Example:\n *\n```\nclass Api {\n  fooReady = new Deferred&lt;Data&gt;()\n  private knower() {\n    inOtherMoment(data=&gt;{\n      this.fooReady.resolve(data)\n    })\n  }\n}\n```\n */\nvar Deferred = /** @class */ (function () {\n  function Deferred(callback) {\n    var instance = this;\n    this.resolve = null;\n    this.reject = null;\n    this.status = &apos;pending&apos;;\n    this.promise = new Promise(function (resolve, reject) {\n      instance.resolve = function () { this.status = &apos;resolved&apos;; resolve.apply(this, arguments); };\n      instance.reject = function () { this.status = &apos;rejected&apos;; reject.apply(this, arguments); };\n    });\n    if (typeof callback === &apos;function&apos;) {\n      callback.call(this, this.resolve, this.reject);\n    }\n  }\n  Deferred.prototype.then = function (resolve) {\n    return this.promise.then(resolve);\n  };\n  Deferred.prototype.catch = function (r) {\n    return this.promise.catch(r);\n  };\n  return Deferred;\n}());\n\n\ntranspiled form a typescript project of mine:\n\nhttps://github.com/cancerberoSgx/misc-utils-of-mine/blob/2927c2477839f7b36247d054e7e50abe8a41358b/misc-utils-of-mine-generic/src/promise.ts#L31\n\nFor more complex cases I often use these guy small promise utilities without dependencies tested and typed. p-map has been useful several times. I think he covered most use cases:\n\nhttps://github.com/sindresorhus?utf8=%E2%9C%93&amp;tab=repositories&amp;q=promise&amp;type=source&amp;language=\n    ","url":"https://solutionschecker.com/questions/how-do-i-access-previous-promise-results-in-a-.then()-chain-1657387705386#solution17","@type":"Answer","upvoteCount":0}],"@type":"Question"}}</script><meta name="next-head-count" content="22"/><script id="google-analytics" data-nscript="beforeInteractive">(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
})(window,document,'script','dataLayer','GTM-NXVLL8B');</script><link rel="preload" href="/_next/static/css/c116652e2d6f4ad0.css" as="style"/><link rel="stylesheet" href="/_next/static/css/c116652e2d6f4ad0.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-0d1b80a048d4787e.js"></script><script src="/_next/static/chunks/webpack-42cdea76c8170223.js" defer=""></script><script src="/_next/static/chunks/framework-4556c45dd113b893.js" defer=""></script><script src="/_next/static/chunks/main-ccfab947c79712f4.js" defer=""></script><script src="/_next/static/chunks/pages/_app-862498b6ec7885c3.js" defer=""></script><script src="/_next/static/chunks/294-106ef8570fa99deb.js" defer=""></script><script src="/_next/static/chunks/490-7f0418bb4354ac73.js" defer=""></script><script src="/_next/static/chunks/pages/questions/%5Bslug%5D-47289857226115f9.js" defer=""></script><script src="/_next/static/xZs8haGjOP63QuDE0kxeX/_buildManifest.js" defer=""></script><script src="/_next/static/xZs8haGjOP63QuDE0kxeX/_ssgManifest.js" defer=""></script></head><body><noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-NXVLL8B"
        height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript><div id="__next"><div class="wrapper"><header><nav class="bg-white border-gray-200 px-4 lg:px-6 py-2.5 dark:bg-gray-800"><div class="flex flex-wrap justify-between items-center mx-auto max-w-screen-xl"><a class="flex items-center" href="/"><img src="/logo-second.png" class="mr-3 h-6 sm:h-9" alt="Solution Checker Logo"/><h1 class="self-center text-xl font-semibold whitespace-nowrap dark:text-white">Solution Checker</h1></a><div class="flex items-center lg:order-2"><button data-collapse-toggle="mobile-menu-2" type="button" class="inline-flex items-center p-2 ml-1 text-sm text-gray-500 rounded-lg lg:hidden hover:bg-gray-100 focus:outline-none focus:ring-2 focus:ring-gray-200 dark:text-gray-400 dark:hover:bg-gray-700 dark:focus:ring-gray-600" aria-controls="mobile-menu-2" aria-expanded="false"><span class="sr-only">Open main menu</span><svg class="w-6 h-6" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M3 5a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM3 10a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM3 15a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1z" clip-rule="evenodd"></path></svg><svg class="hidden w-6 h-6" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z" clip-rule="evenodd"></path></svg></button></div><div class="hidden justify-between items-center w-full lg:flex lg:w-auto lg:order-1" id="mobile-menu-2"><ul class="flex flex-col mt-4 font-medium lg:flex-row lg:space-x-8 lg:mt-0"><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" aria-current="page" href="/">Home</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/questions?tab=news">Questions</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/post?tab=news">Post</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/questions/how-do-i-access-previous-promise-results-in-a-.then()-chain-1657387705386#">Coding</a></li></ul></div></div></nav></header><div class="main-content"><div class="question my-5"><div class="flex question-header items-center m-auto justify-center"><div class="rounded-xl w-full border p-5 shadow-md bg-white"><div class="flex w-full items-center justify-between border-b pb-3"><div class="flex items-center space-x-3"><div class="text-lg font-bold text-slate-700"><a href="/questions/how-do-i-access-previous-promise-results-in-a-.then()-chain-1657387705386"><h1>How do I access previous promise results in a .then() chain?</h1></a></div></div><div class="flex flex-wrap h-auto justify-end items-center space-x-8"></div></div><div class="question-content mt-5">
                
<p>I have restructured my code to <a href="https://en.wikipedia.org/wiki/Futures_and_promises">promises</a>, and built a wonderful long <strong>flat promise chain</strong>, consisting of multiple <code>.then()</code> callbacks. In the end I want to return some composite value, and need to access multiple <strong>intermediate promise results</strong>. However the resolution values from the middle of the sequence are not in scope in the last callback, how do I access them?</p>

<pre class="lang-js s-code-block"><code class="hljs language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">getExample</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-title function_">promiseA</span>(…).<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">resultA</span>) {
        <span class="hljs-comment">// Some processing</span>
        <span class="hljs-keyword">return</span> <span class="hljs-title function_">promiseB</span>(…);
    }).<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">resultB</span>) {
        <span class="hljs-comment">// More processing</span>
        <span class="hljs-keyword">return</span> <span class="hljs-comment">// How do I gain access to resultA here?</span>
    });
}
</code></pre>
    </div></div></div><div class="solution-section"><nav class="flex pagination-solution flex-col justify-end"><h1 class="text-lg font-semibold mb-5">Navigate to solutions: </h1><ul class="inline-flex -space-x-px overflow-auto"><li class="pagination-solution-item"><span data-id="#solution1" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">1</span></li><li class="pagination-solution-item"><span data-id="#solution2" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">2</span></li><li class="pagination-solution-item"><span data-id="#solution3" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">3</span></li><li class="pagination-solution-item"><span data-id="#solution4" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">4</span></li><li class="pagination-solution-item"><span data-id="#solution5" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">5</span></li><li class="pagination-solution-item"><span data-id="#solution6" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">6</span></li><li class="pagination-solution-item"><span data-id="#solution7" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">7</span></li><li class="pagination-solution-item"><span data-id="#solution8" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">8</span></li><li class="pagination-solution-item"><span data-id="#solution9" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">9</span></li><li class="pagination-solution-item"><span data-id="#solution10" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">10</span></li><li class="pagination-solution-item"><span data-id="#solution11" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">11</span></li><li class="pagination-solution-item"><span data-id="#solution12" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">12</span></li><li class="pagination-solution-item"><span data-id="#solution13" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">13</span></li><li class="pagination-solution-item"><span data-id="#solution14" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">14</span></li><li class="pagination-solution-item"><span data-id="#solution15" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">15</span></li><li class="pagination-solution-item"><span data-id="#solution16" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">16</span></li><li class="pagination-solution-item"><span data-id="#solution17" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">17</span></li></ul></nav><div id="solution1" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 1</h1><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<h1>Break the chain</h1>

<p>When you need to access the intermediate values in your chain, you should split your chain apart in those single pieces that you need. Instead of attaching one callback and somehow trying to use its parameter multiple times, attach multiple callbacks to the same promise - wherever you need the result value. Don't forget, a <a href="https://stackoverflow.com/a/22540276/1048572">promise just represents (proxies) a future value</a>! Next to deriving one promise from the other in a linear chain, use the promise combinators that are given to you by your library to build the result value.</p>

<p>This will result in a very straightforward control flow, clear composition of functionalities and therefore easy modularisation.</p>

<pre class="lang-js s-code-block"><code class="hljs language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">getExample</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">var</span> a = <span class="hljs-title function_">promiseA</span>();
    <span class="hljs-keyword">var</span> b = a.<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">resultA</span>) {
        <span class="hljs-comment">// some processing</span>
        <span class="hljs-keyword">return</span> <span class="hljs-title function_">promiseB</span>();
    });
    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">all</span>([a, b]).<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">[resultA, resultB]</span>) {
        <span class="hljs-comment">// more processing</span>
        <span class="hljs-keyword">return</span> <span class="hljs-comment">// something using both resultA and resultB</span>
    });
}
</code></pre>

<p>Instead of the parameter destructuring in the callback after <code>Promise.all</code> that only became avail­able with ES6, in ES5 the <code>then</code> call would be replaced by a nifty helper method that was provided by many promise libraries (<a href="https://github.com/kriskowal/q/wiki/API-Reference#promisespreadonfulfilled-onrejected" rel="noreferrer">Q</a>, <a href="http://bluebirdjs.com/docs/api/spread.html" rel="noreferrer">Bluebird</a>, <a href="https://github.com/cujojs/when/blob/master/docs/api.md#promisespread" rel="noreferrer">when</a>, ): <code>.spread(function(resultA, resultB) { </code>.</p>

<p>Bluebird also features a dedicated <a href="http://bluebirdjs.com/docs/api/promise.join.html" rel="noreferrer"><code>join</code> function</a> to replace that <code>Promise.all</code>+<code>spread</code> combination with a simpler (and more efficient) construct:</p>

<pre class="lang-js s-code-block"><code class="hljs language-javascript">
<span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">join</span>(a, b, <span class="hljs-keyword">function</span>(<span class="hljs-params">resultA, resultB</span>) {  });
</code></pre>
    </div></div></div></div><div id="solution2" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 2</h1><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<h1>ECMAScript Harmony</h1>
<p>Of course, this problem was recognized by the language designers as well. They did a lot of work and the <a href="http://tc39.github.io/ecmascript-asyncawait/" rel="noreferrer">async functions proposal</a> finally made it into</p>
<h2>ECMAScript 8</h2>
<p>You don't need a single <code>then</code> invocation or callback function anymore, as in an asynchronous function (that returns a promise when being called) you can simply wait for promises to resolve directly. It also features arbitrary control structures like conditions, loops and try-catch-clauses, but for the sake of convenience we don't need them here:</p>
<pre class="lang-js s-code-block"><code class="hljs language-javascript"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">getExample</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">var</span> resultA = <span class="hljs-keyword">await</span> <span class="hljs-title function_">promiseA</span>();
    <span class="hljs-comment">// some processing</span>
    <span class="hljs-keyword">var</span> resultB = <span class="hljs-keyword">await</span> <span class="hljs-title function_">promiseB</span>();
    <span class="hljs-comment">// more processing</span>
    <span class="hljs-keyword">return</span> <span class="hljs-comment">// something using both resultA and resultB</span>
}
</code></pre>
<h2>ECMAScript 6</h2>
<p>While we were waiting for ES8, we already did use a very similar kind of syntax. ES6 came with <a href="http://davidwalsh.name/es6-generators" rel="noreferrer">generator functions</a>, which allow breaking the execution apart in pieces at arbitrarily placed <code>yield</code> keywords. Those slices can be run after each other, independently, even asynchronously - and that's just what we do when we want to wait for a promise resolution before running the next step.</p>
<p>There are dedicated libraries (like <a href="https://github.com/tj/co" rel="noreferrer">co</a> or <a href="http://taskjs.org/" rel="noreferrer">task.js</a>), but also many promise libraries have helper functions (<a href="https://github.com/kriskowal/q/wiki/API-Reference#generators" rel="noreferrer">Q</a>, <a href="http://bluebirdjs.com/docs/api/generators.html" rel="noreferrer">Bluebird</a>, <a href="https://github.com/cujojs/when/blob/master/docs/api.md#es6-generators" rel="noreferrer">when</a>, ) that do <a href="https://stackoverflow.com/a/23554399/1048572">this async step-by-step execution</a> for you when you give them a generator function that yields promises.</p>
<pre class="lang-js s-code-block"><code class="hljs language-javascript"><span class="hljs-keyword">var</span> getExample = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">coroutine</span>(<span class="hljs-keyword">function</span>* () {
<span class="hljs-comment">//               ^^^^^^^^^^^^^^^^^ Bluebird syntax</span>
    <span class="hljs-keyword">var</span> resultA = <span class="hljs-keyword">yield</span> <span class="hljs-title function_">promiseA</span>();
    <span class="hljs-comment">// some processing</span>
    <span class="hljs-keyword">var</span> resultB = <span class="hljs-keyword">yield</span> <span class="hljs-title function_">promiseB</span>();
    <span class="hljs-comment">// more processing</span>
    <span class="hljs-keyword">return</span> <span class="hljs-comment">// something using both resultA and resultB</span>
});
</code></pre>
<p>This did work in Node.js since version 4.0, also a few browsers (or their dev editions) did support generator syntax relatively early.</p>
<h2>ECMAScript 5</h2>
<p>However, if you want/need to be backward-compatible you cannot use those without a transpiler. Both generator functions and async functions are supported by the current tooling, see for example the documentation of Babel on <a href="http://babeljs.io/learn-es2015/#ecmascript-2015-features-generators" rel="noreferrer">generators</a> and <a href="http://babeljs.io/docs/plugins/syntax-async-functions" rel="noreferrer">async functions</a>.</p>
<p>And then, there are also many other <a href="https://github.com/jashkenas/coffeescript/wiki/List-of-languages-that-compile-to-JS#synchronous-to-asynchronous-javascript-compilers-cps" rel="noreferrer">compile-to-JS languages</a>
that are dedicated to easing asynchronous programming. They usually use a syntax similar to <code>await</code>, (e.g. <a href="http://maxtaco.github.io/coffee-script/" rel="noreferrer">Iced CoffeeScript</a>), but there are also others that feature a Haskell-like <code>do</code>-notation (e.g. <a href="http://lattejs.com/" rel="noreferrer">LatteJs</a>, <a href="https://www.npmjs.com/package/monadic" rel="noreferrer">monadic</a>, <a href="http://www.purescript.org/" rel="noreferrer">PureScript</a> or <a href="http://lispyscript.com/" rel="noreferrer">LispyScript</a>).</p>
    </div></div></div></div><div id="solution3" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 3</h1><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<h1>Synchronous inspection</h1>

<p>Assigning promises-for-later-needed-values to variables and then getting their value via synchronous inspection. The example uses bluebird's <code>.value()</code> method but many libraries provide similar method.</p>

<pre class="lang-js s-code-block"><code class="hljs language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">getExample</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">var</span> a = <span class="hljs-title function_">promiseA</span>();

    <span class="hljs-keyword">return</span> a.<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) {
        <span class="hljs-comment">// some processing</span>
        <span class="hljs-keyword">return</span> <span class="hljs-title function_">promiseB</span>();
    }).<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">resultB</span>) {
        <span class="hljs-comment">// a is guaranteed to be fulfilled here so we can just retrieve its</span>
        <span class="hljs-comment">// value synchronously</span>
        <span class="hljs-keyword">var</span> aValue = a.<span class="hljs-title function_">value</span>();
    });
}
</code></pre>

<p>This can be used for as many values as you like:</p>

<pre class="lang-js s-code-block"><code class="hljs language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">getExample</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">var</span> a = <span class="hljs-title function_">promiseA</span>();

    <span class="hljs-keyword">var</span> b = a.<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) {
        <span class="hljs-keyword">return</span> <span class="hljs-title function_">promiseB</span>()
    });

    <span class="hljs-keyword">var</span> c = b.<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) {
        <span class="hljs-keyword">return</span> <span class="hljs-title function_">promiseC</span>();
    });

    <span class="hljs-keyword">var</span> d = c.<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) {
        <span class="hljs-keyword">return</span> <span class="hljs-title function_">promiseD</span>();
    });

    <span class="hljs-keyword">return</span> d.<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) {
        <span class="hljs-keyword">return</span> a.<span class="hljs-title function_">value</span>() + b.<span class="hljs-title function_">value</span>() + c.<span class="hljs-title function_">value</span>() + d.<span class="hljs-title function_">value</span>();
    });
}
</code></pre>
    </div></div></div></div><div id="solution4" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 4</h1><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<h1>Nesting (and) closures</h1>

<p>Using closures for maintaining the scope of variables (in our case, the success callback function parameters) is the natural JavaScript solution. With promises, we can arbitrarily <a href="https://stackoverflow.com/a/22000931/1048572">nest and flatten</a> <code>.then()</code> callbacks - they are semantically equivalent, except for the scope of the inner one.</p>

<pre class="lang-js s-code-block"><code class="hljs language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">getExample</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-title function_">promiseA</span>().<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">resultA</span>) {
        <span class="hljs-comment">// some processing</span>
        <span class="hljs-keyword">return</span> <span class="hljs-title function_">promiseB</span>().<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">resultB</span>) {
            <span class="hljs-comment">// more processing</span>
            <span class="hljs-keyword">return</span> <span class="hljs-comment">// something using both resultA and resultB;</span>
        });
    });
}
</code></pre>

<p>Of course, this is building an indentation pyramid. If indentation is getting too large, you still can apply the old tools to counter the <a href="http://callbackhell.com/" rel="noreferrer">pyramid of doom</a>: modularize, use extra named functions, and flatten the promise chain as soon as you don't need a variable any more.<br>
In theory, you can always avoid more than two levels of nesting (by making all closures explicit), in practise use as many as are reasonable.</p>

<pre class="lang-js s-code-block"><code class="hljs language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">getExample</span>(<span class="hljs-params"></span>) {
    <span class="hljs-comment">// preprocessing</span>
    <span class="hljs-keyword">return</span> <span class="hljs-title function_">promiseA</span>().<span class="hljs-title function_">then</span>(<span class="hljs-title function_">makeAhandler</span>());
}
<span class="hljs-keyword">function</span> <span class="hljs-title function_">makeAhandler</span>(<span class="hljs-params"></span>)
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params">resultA</span>) {
        <span class="hljs-comment">// some processing</span>
        <span class="hljs-keyword">return</span> <span class="hljs-title function_">promiseB</span>().<span class="hljs-title function_">then</span>(<span class="hljs-title function_">makeBhandler</span>(resultA, ));
    };
}
<span class="hljs-keyword">function</span> <span class="hljs-title function_">makeBhandler</span>(<span class="hljs-params">resultA, </span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params">resultB</span>) {
        <span class="hljs-comment">// more processing</span>
        <span class="hljs-keyword">return</span> <span class="hljs-comment">// anything that uses the variables in scope</span>
    };
}
</code></pre>

<p>You can also use helper functions for this kind of <a href="https://en.wikipedia.org/wiki/Partial_application" rel="noreferrer">partial application</a>, like <code>_.partial</code> from <a href="http://underscorejs.org/#partial" rel="noreferrer">Underscore</a>/<a href="https://lodash.com/docs#partial" rel="noreferrer">lodash</a> or the <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/bind" rel="noreferrer">native <code>.bind()</code> method</a>, to further decrease indentation:</p>

<pre class="lang-js s-code-block"><code class="hljs language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">getExample</span>(<span class="hljs-params"></span>) {
    <span class="hljs-comment">// preprocessing</span>
    <span class="hljs-keyword">return</span> <span class="hljs-title function_">promiseA</span>().<span class="hljs-title function_">then</span>(handlerA);
}
<span class="hljs-keyword">function</span> <span class="hljs-title function_">handlerA</span>(<span class="hljs-params">resultA</span>) {
    <span class="hljs-comment">// some processing</span>
    <span class="hljs-keyword">return</span> <span class="hljs-title function_">promiseB</span>().<span class="hljs-title function_">then</span>(handlerB.<span class="hljs-title function_">bind</span>(<span class="hljs-literal">null</span>, resultA));
}
<span class="hljs-keyword">function</span> <span class="hljs-title function_">handlerB</span>(<span class="hljs-params">resultA, resultB</span>) {
    <span class="hljs-comment">// more processing</span>
    <span class="hljs-keyword">return</span> <span class="hljs-comment">// anything that uses resultA and resultB</span>
}
</code></pre>
    </div></div></div></div><div id="solution5" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 5</h1><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<h1>Explicit pass-through</h1>

<p>Similar to nesting the callbacks, this technique relies on closures. Yet, the chain stays flat - instead of passing only the latest result, some state object is passed for every step. These state objects accumulate the results of the previous actions, handing down all values that will be needed later again plus the result of the current task.</p>

<pre class="lang-js s-code-block"><code class="hljs language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">getExample</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-title function_">promiseA</span>().<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">resultA</span>) {
        <span class="hljs-comment">// some processing</span>
        <span class="hljs-keyword">return</span> <span class="hljs-title function_">promiseB</span>().<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">b</span> =&gt;</span> [resultA, b]); <span class="hljs-comment">// function(b) { return [resultA, b] }</span>
    }).<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">[resultA, resultB]</span>) {
        <span class="hljs-comment">// more processing</span>
        <span class="hljs-keyword">return</span> <span class="hljs-comment">// something using both resultA and resultB</span>
    });
}
</code></pre>

<p>Here, that little arrow <code>b =&gt; [resultA, b]</code> is the function that closes over <code>resultA</code>, and passes an array of both results to the next step. Which uses parameter destructuring syntax to break it up in single variables again.</p>

<p>Before destructuring became available with ES6, a nifty helper method called <code>.spread()</code> was pro­vi­ded by many promise libraries (<a href="https://github.com/kriskowal/q/wiki/API-Reference#promisespreadonfulfilled-onrejected" rel="noreferrer">Q</a>, <a href="http://bluebirdjs.com/docs/api/spread.html" rel="noreferrer">Bluebird</a>, <a href="https://github.com/cujojs/when/blob/master/docs/api.md#promisespread" rel="noreferrer">when</a>, ). It takes a function with multiple parameters - one for each array element - to be used as <code>.spread(function(resultA, resultB) { </code>.</p>

<p>Of course, that closure needed here can be further simplified by some helper functions, e.g.</p>

<pre class="lang-js s-code-block"><code class="hljs language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">addTo</span>(<span class="hljs-params">x</span>) {
    <span class="hljs-comment">// imagine complex `arguments` fiddling or anything that helps usability</span>
    <span class="hljs-comment">// but you get the idea with this simple one:</span>
    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> [x, res];
}


<span class="hljs-keyword">return</span> <span class="hljs-title function_">promiseB</span>().<span class="hljs-title function_">then</span>(<span class="hljs-title function_">addTo</span>(resultA));
</code></pre>

<p>Alternatively, you can employ <code>Promise.all</code> to produce the promise for the array:</p>

<pre class="lang-js s-code-block"><code class="hljs language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">getExample</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-title function_">promiseA</span>().<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">resultA</span>) {
        <span class="hljs-comment">// some processing</span>
        <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">all</span>([resultA, <span class="hljs-title function_">promiseB</span>()]); <span class="hljs-comment">// resultA will implicitly be wrapped</span>
                                                    <span class="hljs-comment">// as if passed to Promise.resolve()</span>
    }).<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">[resultA, resultB]</span>) {
        <span class="hljs-comment">// more processing</span>
        <span class="hljs-keyword">return</span> <span class="hljs-comment">// something using both resultA and resultB</span>
    });
}
</code></pre>

<p>And you might not only use arrays, but arbitrarily complex objects. For example, with <a href="http://underscorejs.org/#extend" rel="noreferrer"><code>_.extend</code></a> or <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign" rel="noreferrer"><code>Object.assign</code></a> in a different helper function:</p>

<pre class="lang-js s-code-block"><code class="hljs language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">augment</span>(<span class="hljs-params">obj, name</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params">res</span>) { <span class="hljs-keyword">var</span> r = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">assign</span>({}, obj); r[name] = res; <span class="hljs-keyword">return</span> r; };
}

<span class="hljs-keyword">function</span> <span class="hljs-title function_">getExample</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-title function_">promiseA</span>().<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">resultA</span>) {
        <span class="hljs-comment">// some processing</span>
        <span class="hljs-keyword">return</span> <span class="hljs-title function_">promiseB</span>().<span class="hljs-title function_">then</span>(<span class="hljs-title function_">augment</span>({resultA}, <span class="hljs-string">"resultB"</span>));
    }).<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">obj</span>) {
        <span class="hljs-comment">// more processing</span>
        <span class="hljs-keyword">return</span> <span class="hljs-comment">// something using both obj.resultA and obj.resultB</span>
    });
}
</code></pre>

<p>While this pattern guarantees a flat chain and explicit state objects can improve clarity, it will become tedious for a long chain. Especially when you need the state only sporadically, you still have to pass it through every step. With this fixed interface, the single callbacks in the chain are rather tightly coupled and inflexible to change. It makes factoring out single steps harder, and callbacks cannot be supplied directly from other modules - they always need to be wrapped in boilerplate code that cares about the state. Abstract helper functions like the above can ease the pain a bit, but it will always be present.</p>
    </div></div></div></div><div id="solution6" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 6</h1><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<h1>Mutable contextual state</h1>

<p>The trivial (but inelegant and rather errorprone) solution is to just use higher-scope variables (to which all callbacks in the chain have access) and write result values to them when you get them:</p>

<pre class="lang-js s-code-block"><code class="hljs language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">getExample</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">var</span> resultA;
    <span class="hljs-keyword">return</span> <span class="hljs-title function_">promiseA</span>().<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">_resultA</span>) {
        resultA = _resultA;
        <span class="hljs-comment">// some processing</span>
        <span class="hljs-keyword">return</span> <span class="hljs-title function_">promiseB</span>();
    }).<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">resultB</span>) {
        <span class="hljs-comment">// more processing</span>
        <span class="hljs-keyword">return</span> <span class="hljs-comment">// something using both resultA and resultB</span>
    });
}
</code></pre>

<p>Instead of many variables one might also use an (initially empty) object, on which the results are stored as dynamically created properties.</p>

<p>This solution has several drawbacks:</p>

<ul>
<li><a href="https://stackoverflow.com/q/844536/1048572">Mutable state is ugly</a>, and <a href="https://softwareengineering.stackexchange.com/questions/148108/why-is-global-state-so-evil">global variables are evil</a>.</li>
<li>This pattern doesn't work across function boundaries, modularising the functions is harder as their declarations must not leave the shared scope</li>
<li>The scope of the variables does not prevent to access them before they are initialized. This is especially likely for complex promise constructions (loops, branching, excptions) where race conditions might happen. Passing state explicitly, a <a href="http://en.wikipedia.org/wiki/Declarative_programming" rel="noreferrer">declarative design</a> that promises encourage, forces a cleaner coding style which can prevent this.</li>
<li>One must choose the scope for those shared variables correctly. It needs to be local to the executed function to prevent race conditions between multiple parallel invocations, as would be the case if, for example, state was stored on an instance.</li>
</ul>

<p>The Bluebird library encourages the use of an object that is passed along, using <a href="http://bluebirdjs.com/docs/api/bind.html" rel="noreferrer">their <code>bind()</code> method</a> to assign a context object to a promise chain. It will be accessible from each callback function via the otherwise unusable <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/this" rel="noreferrer"><code>this</code> keyword</a>. While object properties are more prone to undetected typos than variables, the pattern is quite clever:</p>

<pre class="lang-js s-code-block"><code class="hljs language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">getExample</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-title function_">promiseA</span>()
    .<span class="hljs-title function_">bind</span>({}) <span class="hljs-comment">// Bluebird only!</span>
    .<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">resultA</span>) {
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">resultA</span> = resultA;
        <span class="hljs-comment">// some processing</span>
        <span class="hljs-keyword">return</span> <span class="hljs-title function_">promiseB</span>();
    }).<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">resultB</span>) {
        <span class="hljs-comment">// more processing</span>
        <span class="hljs-keyword">return</span> <span class="hljs-comment">// something using both this.resultA and resultB</span>
    }).<span class="hljs-title function_">bind</span>(); <span class="hljs-comment">// don't forget to unbind the object if you don't want the</span>
               <span class="hljs-comment">// caller to access it</span>
}
</code></pre>

<p>This approach can be easily simulated in promise libraries that do not support .bind (although in a somewhat more verbose way and cannot be used in an expression):</p>

<pre class="lang-js s-code-block"><code class="hljs language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">getExample</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">var</span> ctx = {};
    <span class="hljs-keyword">return</span> <span class="hljs-title function_">promiseA</span>()
    .<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">resultA</span>) {
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">resultA</span> = resultA;
        <span class="hljs-comment">// some processing</span>
        <span class="hljs-keyword">return</span> <span class="hljs-title function_">promiseB</span>();
    }.<span class="hljs-title function_">bind</span>(ctx)).<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">resultB</span>) {
        <span class="hljs-comment">// more processing</span>
        <span class="hljs-keyword">return</span> <span class="hljs-comment">// something using both this.resultA and resultB</span>
    }.<span class="hljs-title function_">bind</span>(ctx));
}
</code></pre>
    </div></div></div></div><div id="solution7" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 7</h1><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<h1>A less harsh spin on "Mutable contextual state"</h1>
<p>Using a locally scoped object to collect the intermediate results in a promise chain is a reasonable approach to the question you posed. Consider the following snippet:</p>
<pre class="lang-js s-code-block"><code class="hljs language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">getExample</span>(<span class="hljs-params"></span>){
    <span class="hljs-comment">//locally scoped</span>
    <span class="hljs-keyword">const</span> results = {};
    <span class="hljs-keyword">return</span> <span class="hljs-title function_">promiseA</span>(paramsA).<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">resultA</span>){
        results.<span class="hljs-property">a</span> = resultA;
        <span class="hljs-keyword">return</span> <span class="hljs-title function_">promiseB</span>(paramsB);
    }).<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">resultB</span>){
        results.<span class="hljs-property">b</span> = resultB;
        <span class="hljs-keyword">return</span> <span class="hljs-title function_">promiseC</span>(paramsC);
    }).<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">resultC</span>){
        <span class="hljs-comment">//Resolve with composite of all promises</span>
        <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(results.<span class="hljs-property">a</span> + results.<span class="hljs-property">b</span> + resultC);
    }).<span class="hljs-title function_">catch</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">error</span>){
        <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(error);
    });
}
</code></pre>
<ul>
<li>Global variables are bad, so this solution uses a locally scoped variable which causes no harm.  It is only accessible within the function.</li>
<li>Mutable state is ugly, but this does not mutate state in an ugly manner.  The ugly mutable state traditionally refers to modifying the state of function arguments or global variables, but this approach simply modifies the state of a locally scoped variable that exists for the sole purpose of aggregating promise results...a variable that will die a simple death once the promise resolves.</li>
<li>Intermediate promises are not prevented from accessing the state of the results object, but this does not introduce some scary scenario where one of the promises in the chain will go rogue and sabotage your results.  The responsibility of setting the values in each step of the promise is confined to this function and the overall result will either be correct or incorrect...it will not be some bug that will crop up years later in production (unless you intend it to!)</li>
<li>This does not introduce a race condition scenario that would arise from parallel invocation because a new instance of the results variable is created for every invocation of the getExample function.</li>
</ul>
<p>Example is available on <a href="https://jsfiddle.net/w50zqgyr/2/" rel="nofollow noreferrer">jsfiddle</a></p>
    </div></div></div></div><div id="solution8" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 8</h1><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Node 7.4 now supports async/await calls with the harmony flag.</p>

<p>Try this: </p>

<pre class="lang-js s-code-block"><code class="hljs language-javascript"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">getExample</span>(<span class="hljs-params"></span>){

  <span class="hljs-keyword">let</span> response = <span class="hljs-keyword">await</span> <span class="hljs-title function_">returnPromise</span>();

  <span class="hljs-keyword">let</span> response2 = <span class="hljs-keyword">await</span> <span class="hljs-title function_">returnPromise2</span>();

  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(response, response2)

}

<span class="hljs-title function_">getExample</span>()
</code></pre>

<p>and run the file with:</p>

<p><code>node --harmony-async-await getExample.js</code></p>

<p>Simple as can be!</p>
    </div></div></div></div><div id="solution9" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 9</h1><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Another answer, using <code>babel-node</code> version &lt;6 </p>

<p>Using <code>async - await</code> </p>

<p><code>npm install -g babel@5.6.14</code></p>

<p><code>example.js:</code></p>

<pre class="lang-js s-code-block"><code class="hljs language-javascript"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">getExample</span>(<span class="hljs-params"></span>){

  <span class="hljs-keyword">let</span> response = <span class="hljs-keyword">await</span> <span class="hljs-title function_">returnPromise</span>();

  <span class="hljs-keyword">let</span> response2 = <span class="hljs-keyword">await</span> <span class="hljs-title function_">returnPromise2</span>();

  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(response, response2)

}

<span class="hljs-title function_">getExample</span>()
</code></pre>

<p>Then, run <code>babel-node example.js</code> and voila!</p>
    </div></div></div></div><div id="solution10" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 10</h1><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>This days, I also hava meet some questions like you. At last, I find a good solution with the quesition, it's simple and good to read. I hope this can help you.</p>

<p>According to <a href="https://html5hive.org/how-to-chain-javascript-promises/" rel="nofollow noreferrer">how-to-chain-javascript-promises</a></p>

<p>ok, let's look at the code:</p>

<pre class="lang-js s-code-block"><code class="hljs language-javascript"><span class="hljs-keyword">const</span> <span class="hljs-title function_">firstPromise</span> = (<span class="hljs-params"></span>) =&gt; {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {
        <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {
            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'first promise is completed'</span>);
            <span class="hljs-title function_">resolve</span>({<span class="hljs-attr">data</span>: <span class="hljs-string">'123'</span>});
        }, <span class="hljs-number">2000</span>);
    });
};

<span class="hljs-keyword">const</span> <span class="hljs-title function_">secondPromise</span> = (<span class="hljs-params">someStuff</span>) =&gt; {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {
        <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {
            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'second promise is completed'</span>);
            <span class="hljs-title function_">resolve</span>({<span class="hljs-attr">newData</span>: <span class="hljs-string">`<span class="hljs-subst">${someStuff.data}</span> some more data`</span>});
        }, <span class="hljs-number">2000</span>);
    });
};

<span class="hljs-keyword">const</span> <span class="hljs-title function_">thirdPromise</span> = (<span class="hljs-params">someStuff</span>) =&gt; {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {
        <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {
            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'third promise is completed'</span>);
            <span class="hljs-title function_">resolve</span>({<span class="hljs-attr">result</span>: someStuff});
        }, <span class="hljs-number">2000</span>);
    });
};

<span class="hljs-title function_">firstPromise</span>()
    .<span class="hljs-title function_">then</span>(secondPromise)
    .<span class="hljs-title function_">then</span>(thirdPromise)
    .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> {
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data);
    });
</code></pre>
    </div></div></div></div><div id="solution11" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 11</h1><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>I am not going to use this pattern in my own code since I'm not a big fan of using global variables. However, in a pinch it will work.</p>

<p>User is a promisified Mongoose model.</p>

<pre class="lang-js s-code-block"><code class="hljs language-javascript"><span class="hljs-keyword">var</span> globalVar = <span class="hljs-string">''</span>;

<span class="hljs-title class_">User</span>.<span class="hljs-title function_">findAsync</span>({}).<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">users</span>){
  globalVar = users;
}).<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>){
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(globalVar);
});
</code></pre>
    </div></div></div></div><div id="solution12" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 12</h1><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Another answer, using sequential executor <a href="https://github.com/amaksr/nsynjs" rel="nofollow noreferrer">nsynjs</a>:</p>

<pre class="lang-js s-code-block"><code class="hljs language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">getExample</span>(<span class="hljs-params"></span>){

  <span class="hljs-keyword">var</span> response1 = <span class="hljs-title function_">returnPromise1</span>().<span class="hljs-property">data</span>;

  <span class="hljs-comment">// promise1 is resolved at this point, '.data' has the result from resolve(result)</span>

  <span class="hljs-keyword">var</span> response2 = <span class="hljs-title function_">returnPromise2</span>().<span class="hljs-property">data</span>;

  <span class="hljs-comment">// promise2 is resolved at this point, '.data' has the result from resolve(result)</span>

  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(response, response2);

}

nynjs.<span class="hljs-title function_">run</span>(getExample,{},<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>){
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'all done'</span>);
})
</code></pre>

<h2>Update: added working example</h2>

<p></p><div class="snippet" data-lang="js" data-hide="false" data-console="true" data-babel="false">
<div class="snippet-code">
<pre class="snippet-code-js lang-js s-code-block"><code class="hljs language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">synchronousCode</span>(<span class="hljs-params"></span>) {
     <span class="hljs-keyword">var</span> urls=[
         <span class="hljs-string">"https://ajax.googleapis.com/ajax/libs/jquery/1.7.0/jquery.min.js"</span>,
         <span class="hljs-string">"https://ajax.googleapis.com/ajax/libs/jquery/1.8.0/jquery.min.js"</span>,
         <span class="hljs-string">"https://ajax.googleapis.com/ajax/libs/jquery/1.9.0/jquery.min.js"</span>
     ];
     <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i=<span class="hljs-number">0</span>; i&lt;urls.<span class="hljs-property">length</span>; i++) {
         <span class="hljs-keyword">var</span> len=<span class="hljs-variable language_">window</span>.<span class="hljs-title function_">fetch</span>(urls[i]).<span class="hljs-property">data</span>.<span class="hljs-title function_">text</span>().<span class="hljs-property">data</span>.<span class="hljs-property">length</span>;
         <span class="hljs-comment">//             ^                   ^</span>
         <span class="hljs-comment">//             |                   +- 2-nd promise result</span>
         <span class="hljs-comment">//             |                      assigned to 'data'</span>
         <span class="hljs-comment">//             |</span>
         <span class="hljs-comment">//             +-- 1-st promise result assigned to 'data'</span>
         <span class="hljs-comment">//</span>
         <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'URL #'</span>+i+<span class="hljs-string">' : '</span>+urls[i]+<span class="hljs-string">", length: "</span>+len);
     }
}

nsynjs.<span class="hljs-title function_">run</span>(synchronousCode,{},<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>){
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'all done'</span>);
})</code></pre>
<pre class="snippet-code-html lang-html s-code-block"><code class="hljs language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"https://rawgit.com/amaksr/nsynjs/master/nsynjs.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre>
<div class="snippet-result"><div class="snippet-ctas"><button type="button" class="s-btn s-btn__primary"><span class="icon-play-white _hover"></span><span> Run code snippet</span></button><input class="copySnippet s-btn s-btn__filled" type="button" value="Copy snippet to answer" style="display: none;"><button type="button" class="s-btn hideResults" style="display: none;">Hide results</button><div class="popout-code"><a class="snippet-expand-link">Expand snippet</a></div></div><div class="snippet-result-code" style="display: none;"><iframe name="sif1" sandbox="allow-forms allow-modals allow-scripts" class="snippet-box-edit snippet-box-result" frameborder="0"></iframe></div></div></div>
</div>
<p></p>
    </div></div></div></div><div id="solution13" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 13</h1><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>When using bluebird, you can use <code>.bind</code> method to share variables in promise chain:</p>

<pre class="lang-js s-code-block"><code class="hljs language-javascript"><span class="hljs-title function_">somethingAsync</span>().<span class="hljs-title function_">bind</span>({})
.<span class="hljs-title function_">spread</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">aValue, bValue</span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">aValue</span> = aValue;
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">bValue</span> = bValue;
    <span class="hljs-keyword">return</span> <span class="hljs-title function_">somethingElseAsync</span>(aValue, bValue);
})
.<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">cValue</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">aValue</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">bValue</span> + cValue;
});
</code></pre>

<p>please check this link for further information:</p>

<p><a href="http://bluebirdjs.com/docs/api/promise.bind.html" rel="nofollow">http://bluebirdjs.com/docs/api/promise.bind.html</a></p>
    </div></div></div></div><div id="solution14" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 14</h1><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<pre class="lang-js s-code-block"><code class="hljs language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">getExample</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">var</span> retA, retB;
    <span class="hljs-keyword">return</span> <span class="hljs-title function_">promiseA</span>().<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">resultA</span>) {
        retA = resultA;
        <span class="hljs-comment">// Some processing</span>
        <span class="hljs-keyword">return</span> <span class="hljs-title function_">promiseB</span>();
    }).<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">resultB</span>) {
        <span class="hljs-comment">// More processing</span>
        <span class="hljs-comment">//retA is value of promiseA</span>
        <span class="hljs-keyword">return</span> <span class="hljs-comment">// How do I gain access to resultA here?</span>
    });
}
</code></pre>

<p>easy way :D</p>
    </div></div></div></div><div id="solution15" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 15</h1><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>I think you can use hash of RSVP.</p>

<p>Something like as below :</p>

<pre class="lang-js s-code-block"><code class="hljs language-javascript">    <span class="hljs-keyword">const</span> <span class="hljs-title function_">mainPromise</span> = (<span class="hljs-params"></span>) =&gt; {
        <span class="hljs-keyword">const</span> promise1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {
            <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {
                <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'first promise is completed'</span>);
                <span class="hljs-title function_">resolve</span>({<span class="hljs-attr">data</span>: <span class="hljs-string">'123'</span>});
            }, <span class="hljs-number">2000</span>);
        });

        <span class="hljs-keyword">const</span> promise2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {
            <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {
                <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'second promise is completed'</span>);
                <span class="hljs-title function_">resolve</span>({<span class="hljs-attr">data</span>: <span class="hljs-string">'456'</span>});
            }, <span class="hljs-number">2000</span>);
        });

        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">RSVP</span>.<span class="hljs-title function_">hash</span>({
              <span class="hljs-attr">prom1</span>: promise1,
              <span class="hljs-attr">prom2</span>: promise2
          });

    };


   <span class="hljs-title function_">mainPromise</span>()
    .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> {
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data.<span class="hljs-property">prom1</span>);
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data.<span class="hljs-property">prom2</span>);
    });
</code></pre>
    </div></div></div></div><div id="solution16" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 16</h1><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Solution:</p>

<p>You can put intermediate values in scope in any later 'then' function explicitly, by using 'bind'. It is a nice solution that doesn't require changing how Promises work, and only requires a line or two of code to propagate the values just like errors are already propagated.</p>

<p>Here is a complete example:</p>

<pre class="lang-js s-code-block"><code class="hljs language-javascript"><span class="hljs-comment">// Get info asynchronously from a server</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">pGetServerInfo</span>(<span class="hljs-params"></span>)
    {
    <span class="hljs-comment">// then value: "server info"</span>
    } <span class="hljs-comment">// pGetServerInfo</span>

<span class="hljs-comment">// Write into a file asynchronously</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">pWriteFile</span>(<span class="hljs-params">path,string</span>)
    {
    <span class="hljs-comment">// no then value</span>
    } <span class="hljs-comment">// pWriteFile</span>

<span class="hljs-comment">// The heart of the solution: Write formatted info into a log file asynchronously,</span>
<span class="hljs-comment">// using the pGetServerInfo and pWriteFile operations</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">pLogInfo</span>(<span class="hljs-params">localInfo</span>)
    {
    <span class="hljs-keyword">var</span> scope={<span class="hljs-attr">localInfo</span>:localInfo}; <span class="hljs-comment">// Create an explicit scope object</span>
    <span class="hljs-keyword">var</span> thenFunc=p2.<span class="hljs-title function_">bind</span>(scope); <span class="hljs-comment">// Create a temporary function with this scope</span>
    <span class="hljs-keyword">return</span> (<span class="hljs-title function_">pGetServerInfo</span>().<span class="hljs-title function_">then</span>(thenFunc)); <span class="hljs-comment">// Do the next 'then' in the chain</span>
    } <span class="hljs-comment">// pLogInfo</span>

<span class="hljs-comment">// Scope of this 'then' function is {localInfo:localInfo}</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">p2</span>(<span class="hljs-params">serverInfo</span>)
    {
    <span class="hljs-comment">// Do the final 'then' in the chain: Writes "local info, server info"</span>
    <span class="hljs-keyword">return</span> <span class="hljs-title function_">pWriteFile</span>(<span class="hljs-string">'log'</span>,<span class="hljs-variable language_">this</span>.<span class="hljs-property">localInfo</span>+<span class="hljs-string">','</span>+serverInfo);
    } <span class="hljs-comment">// p2</span>
</code></pre>

<p>This solution can be invoked as follows:</p>

<pre class="lang-js s-code-block"><code class="hljs language-javascript"><span class="hljs-title function_">pLogInfo</span>(<span class="hljs-string">"local info"</span>).<span class="hljs-title function_">then</span>().<span class="hljs-title function_">catch</span>(err);
</code></pre>

<p>(Note: a more complex and complete version of this solution has been tested, but not this example version, so it could have a bug.)</p>
    </div></div></div></div><div id="solution17" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 17</h1><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>What I learn about promises is to use it only as return values <strong>avoid referencing them</strong> if possible. async/await syntax is particularly practical for that. Today all latest browsers and node support it: <a href="https://caniuse.com/#feat=async-functions" rel="nofollow noreferrer">https://caniuse.com/#feat=async-functions</a> , is a simple behavior and the code is like reading synchronous code, forget about callbacks...</p>

<p>In cases I do need to reference a promises is when creation and resolution happen at independent/not-related places. So instead an artificial association and probably an event listener just to resolve the "distant" promise, I prefer to expose the promise as a Deferred, which the following code implements it in valid es5</p>

<pre class="lang-js s-code-block"><code class="hljs language-javascript"><span class="hljs-comment">/**
 * Promise like object that allows to resolve it promise from outside code. Example:
 *
```
class Api {
  fooReady = new Deferred&lt;Data&gt;()
  private knower() {
    inOtherMoment(data=&gt;{
      this.fooReady.resolve(data)
    })
  }
}
```
 */</span>
<span class="hljs-keyword">var</span> <span class="hljs-title class_">Deferred</span> = <span class="hljs-comment">/** <span class="hljs-doctag">@class</span> */</span> (<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">Deferred</span>(<span class="hljs-params">callback</span>) {
    <span class="hljs-keyword">var</span> instance = <span class="hljs-variable language_">this</span>;
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">resolve</span> = <span class="hljs-literal">null</span>;
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">reject</span> = <span class="hljs-literal">null</span>;
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> = <span class="hljs-string">'pending'</span>;
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">promise</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">resolve, reject</span>) {
      instance.<span class="hljs-property">resolve</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) { <span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> = <span class="hljs-string">'resolved'</span>; resolve.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, <span class="hljs-variable language_">arguments</span>); };
      instance.<span class="hljs-property">reject</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) { <span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> = <span class="hljs-string">'rejected'</span>; reject.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, <span class="hljs-variable language_">arguments</span>); };
    });
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> callback === <span class="hljs-string">'function'</span>) {
      callback.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">resolve</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">reject</span>);
    }
  }
  <span class="hljs-title class_">Deferred</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">then</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">resolve</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">promise</span>.<span class="hljs-title function_">then</span>(resolve);
  };
  <span class="hljs-title class_">Deferred</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">catch</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">r</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">promise</span>.<span class="hljs-title function_">catch</span>(r);
  };
  <span class="hljs-keyword">return</span> <span class="hljs-title class_">Deferred</span>;
}());
</code></pre>

<p>transpiled form a typescript project of mine:</p>

<p><a href="https://github.com/cancerberoSgx/misc-utils-of-mine/blob/2927c2477839f7b36247d054e7e50abe8a41358b/misc-utils-of-mine-generic/src/promise.ts#L31" rel="nofollow noreferrer">https://github.com/cancerberoSgx/misc-utils-of-mine/blob/2927c2477839f7b36247d054e7e50abe8a41358b/misc-utils-of-mine-generic/src/promise.ts#L31</a></p>

<p>For more complex cases I often use these guy small promise utilities without dependencies tested and typed. p-map has been useful several times. I think he covered most use cases:</p>

<p><a href="https://github.com/sindresorhus?utf8=%E2%9C%93&amp;tab=repositories&amp;q=promise&amp;type=source&amp;language=" rel="nofollow noreferrer">https://github.com/sindresorhus?utf8=%E2%9C%93&amp;tab=repositories&amp;q=promise&amp;type=source&amp;language=</a></p>
    </div></div></div></div></div></div><div class="widget"><a href="/questions/%22cross-origin-requests-are-only-supported-for-http.%22-error-when-loading-a-local-file-1657387942403">&quot;Cross origin requests are only supported for HTTP.&quot; error when loading a local file</a><a href="/questions/calling-a-function-of-a-module-by-using-its-name-(a-string)-1657388565656">Calling a function of a module by using its name (a string)</a><a href="/questions/deep-cloning-objects-1657387930865">Deep cloning objects</a><a href="/questions/how-to-unnest-(explode)-a-column-in-a-pandas-dataframe-into-multiple-rows-1657387806735">How to unnest (explode) a column in a pandas DataFrame, into multiple rows</a><a href="/questions/why-is-the-gets-function-so-dangerous-that-it-should-not-be-used-1657384544362">Why is the gets function so dangerous that it should not be used?</a><a href="/questions/how-to-manage-startactivityforresult-on-android-1657387967393">How to manage startActivityForResult on Android</a><a href="/questions/official-locator-strategies-for-the-webdriver-1657384353174">Official locator strategies for the webdriver</a><a href="/questions/why-does-jquery-or-a-dom-method-such-as-getelementbyid-not-find-the-element-1657384326458">Why does jQuery or a DOM method such as getElementById not find the element?</a><a href="/questions/how-can-i-make-an-ajax-call-without-jquery-1657388448955">How can I make an AJAX call without jQuery?</a><a href="/questions/how-do-i-format-a-date-in-javascript-1657384649498">How do I format a date in JavaScript?</a><a href="/questions/why-does-a-regexp-with-global-flag-give-wrong-results-1657387788550">Why does a RegExp with global flag give wrong results?</a><a href="/questions/numbering-rows-within-groups-in-a-data-frame-1657388556436">Numbering rows within groups in a data frame</a><a href="/questions/dynamic-tabs-with-user-click-chosen-components-1657388465232">Dynamic tabs with user-click chosen components</a><a href="/questions/make-container-shrink-to-fit-child-elements-as-they-wrap-1657388134549">Make container shrink-to-fit child elements as they wrap</a><a href="/questions/how-can-i-deserialize-json-with-c-1657388102941">How can I deserialize JSON with C#?</a><a href="/questions/short-description-of-the-scoping-rules-1657384853121">Short description of the scoping rules?</a><a href="/questions/sort-arraylist-of-custom-objects-by-property-1657387678339">Sort ArrayList of custom Objects by property</a><a href="/questions/what-does-if-__name__-%22__main__%22:-do-1657384825815">What does if __name__ == &quot;__main__&quot;: do?</a><a href="/questions/prefer-composition-over-inheritance-1657387399409">Prefer composition over inheritance?</a><a href="/questions/what-is-a-nullreferenceexception-and-how-do-i-fix-it-1657384234873">What is a NullReferenceException, and how do I fix it?</a></div></div><span class="cursor-pointer text-lg p-2" style="position:fixed;bottom:20px;left:20px;background:#000;z-index:2000;color:white">Go go top</span></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"data":{"answer":["\n\u0026lt;h1\u0026gt;Break the chain\u0026lt;/h1\u0026gt;\n\n\u0026lt;p\u0026gt;When you need to access the intermediate values in your chain, you should split your chain apart in those single pieces that you need. Instead of attaching one callback and somehow trying to use its parameter multiple times, attach multiple callbacks to the same promise - wherever you need the result value. Don\u0026apos;t forget, a \u0026lt;a href=\u0026quot;https://stackoverflow.com/a/22540276/1048572\u0026quot;\u0026gt;promise just represents (proxies) a future value\u0026lt;/a\u0026gt;! Next to deriving one promise from the other in a linear chain, use the promise combinators that are given to you by your library to build the result value.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;This will result in a very straightforward control flow, clear composition of functionalities and therefore easy modularisation.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;getExample\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;) {\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; a = \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;promiseA\u0026lt;/span\u0026gt;();\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; b = a.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;then\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;resultA\u0026lt;/span\u0026gt;) {\n        \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// some processing\u0026lt;/span\u0026gt;\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;promiseB\u0026lt;/span\u0026gt;();\n    });\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Promise\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;all\u0026lt;/span\u0026gt;([a, b]).\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;then\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;[resultA, resultB]\u0026lt;/span\u0026gt;) {\n        \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// more processing\u0026lt;/span\u0026gt;\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// something using both resultA and resultB\u0026lt;/span\u0026gt;\n    });\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Instead of the parameter destructuring in the callback after \u0026lt;code\u0026gt;Promise.all\u0026lt;/code\u0026gt; that only became avail­able with ES6, in ES5 the \u0026lt;code\u0026gt;then\u0026lt;/code\u0026gt; call would be replaced by a nifty helper method that was provided by many promise libraries (\u0026lt;a href=\u0026quot;https://github.com/kriskowal/q/wiki/API-Reference#promisespreadonfulfilled-onrejected\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;Q\u0026lt;/a\u0026gt;, \u0026lt;a href=\u0026quot;http://bluebirdjs.com/docs/api/spread.html\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;Bluebird\u0026lt;/a\u0026gt;, \u0026lt;a href=\u0026quot;https://github.com/cujojs/when/blob/master/docs/api.md#promisespread\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;when\u0026lt;/a\u0026gt;, ): \u0026lt;code\u0026gt;.spread(function(resultA, resultB) { \u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Bluebird also features a dedicated \u0026lt;a href=\u0026quot;http://bluebirdjs.com/docs/api/promise.join.html\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;\u0026lt;code\u0026gt;join\u0026lt;/code\u0026gt; function\u0026lt;/a\u0026gt; to replace that \u0026lt;code\u0026gt;Promise.all\u0026lt;/code\u0026gt;+\u0026lt;code\u0026gt;spread\u0026lt;/code\u0026gt; combination with a simpler (and more efficient) construct:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Promise\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;join\u0026lt;/span\u0026gt;(a, b, \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;resultA, resultB\u0026lt;/span\u0026gt;) {  });\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;h1\u0026gt;ECMAScript Harmony\u0026lt;/h1\u0026gt;\n\u0026lt;p\u0026gt;Of course, this problem was recognized by the language designers as well. They did a lot of work and the \u0026lt;a href=\u0026quot;http://tc39.github.io/ecmascript-asyncawait/\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;async functions proposal\u0026lt;/a\u0026gt; finally made it into\u0026lt;/p\u0026gt;\n\u0026lt;h2\u0026gt;ECMAScript 8\u0026lt;/h2\u0026gt;\n\u0026lt;p\u0026gt;You don\u0026apos;t need a single \u0026lt;code\u0026gt;then\u0026lt;/code\u0026gt; invocation or callback function anymore, as in an asynchronous function (that returns a promise when being called) you can simply wait for promises to resolve directly. It also features arbitrary control structures like conditions, loops and try-catch-clauses, but for the sake of convenience we don\u0026apos;t need them here:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;async\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;getExample\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;) {\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; resultA = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;await\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;promiseA\u0026lt;/span\u0026gt;();\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// some processing\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; resultB = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;await\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;promiseB\u0026lt;/span\u0026gt;();\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// more processing\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// something using both resultA and resultB\u0026lt;/span\u0026gt;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;h2\u0026gt;ECMAScript 6\u0026lt;/h2\u0026gt;\n\u0026lt;p\u0026gt;While we were waiting for ES8, we already did use a very similar kind of syntax. ES6 came with \u0026lt;a href=\u0026quot;http://davidwalsh.name/es6-generators\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;generator functions\u0026lt;/a\u0026gt;, which allow breaking the execution apart in pieces at arbitrarily placed \u0026lt;code\u0026gt;yield\u0026lt;/code\u0026gt; keywords. Those slices can be run after each other, independently, even asynchronously - and that\u0026apos;s just what we do when we want to wait for a promise resolution before running the next step.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;There are dedicated libraries (like \u0026lt;a href=\u0026quot;https://github.com/tj/co\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;co\u0026lt;/a\u0026gt; or \u0026lt;a href=\u0026quot;http://taskjs.org/\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;task.js\u0026lt;/a\u0026gt;), but also many promise libraries have helper functions (\u0026lt;a href=\u0026quot;https://github.com/kriskowal/q/wiki/API-Reference#generators\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;Q\u0026lt;/a\u0026gt;, \u0026lt;a href=\u0026quot;http://bluebirdjs.com/docs/api/generators.html\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;Bluebird\u0026lt;/a\u0026gt;, \u0026lt;a href=\u0026quot;https://github.com/cujojs/when/blob/master/docs/api.md#es6-generators\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;when\u0026lt;/a\u0026gt;, ) that do \u0026lt;a href=\u0026quot;https://stackoverflow.com/a/23554399/1048572\u0026quot;\u0026gt;this async step-by-step execution\u0026lt;/a\u0026gt; for you when you give them a generator function that yields promises.\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; getExample = \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Promise\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;coroutine\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt;* () {\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//               ^^^^^^^^^^^^^^^^^ Bluebird syntax\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; resultA = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;yield\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;promiseA\u0026lt;/span\u0026gt;();\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// some processing\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; resultB = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;yield\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;promiseB\u0026lt;/span\u0026gt;();\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// more processing\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// something using both resultA and resultB\u0026lt;/span\u0026gt;\n});\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;This did work in Node.js since version 4.0, also a few browsers (or their dev editions) did support generator syntax relatively early.\u0026lt;/p\u0026gt;\n\u0026lt;h2\u0026gt;ECMAScript 5\u0026lt;/h2\u0026gt;\n\u0026lt;p\u0026gt;However, if you want/need to be backward-compatible you cannot use those without a transpiler. Both generator functions and async functions are supported by the current tooling, see for example the documentation of Babel on \u0026lt;a href=\u0026quot;http://babeljs.io/learn-es2015/#ecmascript-2015-features-generators\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;generators\u0026lt;/a\u0026gt; and \u0026lt;a href=\u0026quot;http://babeljs.io/docs/plugins/syntax-async-functions\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;async functions\u0026lt;/a\u0026gt;.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;And then, there are also many other \u0026lt;a href=\u0026quot;https://github.com/jashkenas/coffeescript/wiki/List-of-languages-that-compile-to-JS#synchronous-to-asynchronous-javascript-compilers-cps\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;compile-to-JS languages\u0026lt;/a\u0026gt;\nthat are dedicated to easing asynchronous programming. They usually use a syntax similar to \u0026lt;code\u0026gt;await\u0026lt;/code\u0026gt;, (e.g. \u0026lt;a href=\u0026quot;http://maxtaco.github.io/coffee-script/\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;Iced CoffeeScript\u0026lt;/a\u0026gt;), but there are also others that feature a Haskell-like \u0026lt;code\u0026gt;do\u0026lt;/code\u0026gt;-notation (e.g. \u0026lt;a href=\u0026quot;http://lattejs.com/\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;LatteJs\u0026lt;/a\u0026gt;, \u0026lt;a href=\u0026quot;https://www.npmjs.com/package/monadic\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;monadic\u0026lt;/a\u0026gt;, \u0026lt;a href=\u0026quot;http://www.purescript.org/\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;PureScript\u0026lt;/a\u0026gt; or \u0026lt;a href=\u0026quot;http://lispyscript.com/\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;LispyScript\u0026lt;/a\u0026gt;).\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;h1\u0026gt;Synchronous inspection\u0026lt;/h1\u0026gt;\n\n\u0026lt;p\u0026gt;Assigning promises-for-later-needed-values to variables and then getting their value via synchronous inspection. The example uses bluebird\u0026apos;s \u0026lt;code\u0026gt;.value()\u0026lt;/code\u0026gt; method but many libraries provide similar method.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;getExample\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;) {\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; a = \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;promiseA\u0026lt;/span\u0026gt;();\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; a.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;then\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;) {\n        \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// some processing\u0026lt;/span\u0026gt;\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;promiseB\u0026lt;/span\u0026gt;();\n    }).\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;then\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;resultB\u0026lt;/span\u0026gt;) {\n        \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// a is guaranteed to be fulfilled here so we can just retrieve its\u0026lt;/span\u0026gt;\n        \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// value synchronously\u0026lt;/span\u0026gt;\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; aValue = a.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;value\u0026lt;/span\u0026gt;();\n    });\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;This can be used for as many values as you like:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;getExample\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;) {\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; a = \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;promiseA\u0026lt;/span\u0026gt;();\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; b = a.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;then\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;) {\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;promiseB\u0026lt;/span\u0026gt;()\n    });\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; c = b.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;then\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;) {\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;promiseC\u0026lt;/span\u0026gt;();\n    });\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; d = c.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;then\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;) {\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;promiseD\u0026lt;/span\u0026gt;();\n    });\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; d.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;then\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;) {\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; a.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;value\u0026lt;/span\u0026gt;() + b.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;value\u0026lt;/span\u0026gt;() + c.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;value\u0026lt;/span\u0026gt;() + d.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;value\u0026lt;/span\u0026gt;();\n    });\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;h1\u0026gt;Nesting (and) closures\u0026lt;/h1\u0026gt;\n\n\u0026lt;p\u0026gt;Using closures for maintaining the scope of variables (in our case, the success callback function parameters) is the natural JavaScript solution. With promises, we can arbitrarily \u0026lt;a href=\u0026quot;https://stackoverflow.com/a/22000931/1048572\u0026quot;\u0026gt;nest and flatten\u0026lt;/a\u0026gt; \u0026lt;code\u0026gt;.then()\u0026lt;/code\u0026gt; callbacks - they are semantically equivalent, except for the scope of the inner one.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;getExample\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;) {\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;promiseA\u0026lt;/span\u0026gt;().\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;then\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;resultA\u0026lt;/span\u0026gt;) {\n        \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// some processing\u0026lt;/span\u0026gt;\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;promiseB\u0026lt;/span\u0026gt;().\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;then\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;resultB\u0026lt;/span\u0026gt;) {\n            \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// more processing\u0026lt;/span\u0026gt;\n            \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// something using both resultA and resultB;\u0026lt;/span\u0026gt;\n        });\n    });\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Of course, this is building an indentation pyramid. If indentation is getting too large, you still can apply the old tools to counter the \u0026lt;a href=\u0026quot;http://callbackhell.com/\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;pyramid of doom\u0026lt;/a\u0026gt;: modularize, use extra named functions, and flatten the promise chain as soon as you don\u0026apos;t need a variable any more.\u0026lt;br\u0026gt;\nIn theory, you can always avoid more than two levels of nesting (by making all closures explicit), in practise use as many as are reasonable.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;getExample\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;) {\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// preprocessing\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;promiseA\u0026lt;/span\u0026gt;().\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;then\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;makeAhandler\u0026lt;/span\u0026gt;());\n}\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;makeAhandler\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;)\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;resultA\u0026lt;/span\u0026gt;) {\n        \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// some processing\u0026lt;/span\u0026gt;\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;promiseB\u0026lt;/span\u0026gt;().\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;then\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;makeBhandler\u0026lt;/span\u0026gt;(resultA, ));\n    };\n}\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;makeBhandler\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;resultA, \u0026lt;/span\u0026gt;) {\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;resultB\u0026lt;/span\u0026gt;) {\n        \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// more processing\u0026lt;/span\u0026gt;\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// anything that uses the variables in scope\u0026lt;/span\u0026gt;\n    };\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;You can also use helper functions for this kind of \u0026lt;a href=\u0026quot;https://en.wikipedia.org/wiki/Partial_application\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;partial application\u0026lt;/a\u0026gt;, like \u0026lt;code\u0026gt;_.partial\u0026lt;/code\u0026gt; from \u0026lt;a href=\u0026quot;http://underscorejs.org/#partial\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;Underscore\u0026lt;/a\u0026gt;/\u0026lt;a href=\u0026quot;https://lodash.com/docs#partial\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;lodash\u0026lt;/a\u0026gt; or the \u0026lt;a href=\u0026quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/bind\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;native \u0026lt;code\u0026gt;.bind()\u0026lt;/code\u0026gt; method\u0026lt;/a\u0026gt;, to further decrease indentation:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;getExample\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;) {\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// preprocessing\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;promiseA\u0026lt;/span\u0026gt;().\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;then\u0026lt;/span\u0026gt;(handlerA);\n}\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;handlerA\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;resultA\u0026lt;/span\u0026gt;) {\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// some processing\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;promiseB\u0026lt;/span\u0026gt;().\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;then\u0026lt;/span\u0026gt;(handlerB.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;bind\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;null\u0026lt;/span\u0026gt;, resultA));\n}\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;handlerB\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;resultA, resultB\u0026lt;/span\u0026gt;) {\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// more processing\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// anything that uses resultA and resultB\u0026lt;/span\u0026gt;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;h1\u0026gt;Explicit pass-through\u0026lt;/h1\u0026gt;\n\n\u0026lt;p\u0026gt;Similar to nesting the callbacks, this technique relies on closures. Yet, the chain stays flat - instead of passing only the latest result, some state object is passed for every step. These state objects accumulate the results of the previous actions, handing down all values that will be needed later again plus the result of the current task.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;getExample\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;) {\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;promiseA\u0026lt;/span\u0026gt;().\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;then\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;resultA\u0026lt;/span\u0026gt;) {\n        \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// some processing\u0026lt;/span\u0026gt;\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;promiseB\u0026lt;/span\u0026gt;().\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;then\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;b\u0026lt;/span\u0026gt; =\u0026amp;gt;\u0026lt;/span\u0026gt; [resultA, b]); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// function(b) { return [resultA, b] }\u0026lt;/span\u0026gt;\n    }).\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;then\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;[resultA, resultB]\u0026lt;/span\u0026gt;) {\n        \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// more processing\u0026lt;/span\u0026gt;\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// something using both resultA and resultB\u0026lt;/span\u0026gt;\n    });\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Here, that little arrow \u0026lt;code\u0026gt;b =\u0026amp;gt; [resultA, b]\u0026lt;/code\u0026gt; is the function that closes over \u0026lt;code\u0026gt;resultA\u0026lt;/code\u0026gt;, and passes an array of both results to the next step. Which uses parameter destructuring syntax to break it up in single variables again.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Before destructuring became available with ES6, a nifty helper method called \u0026lt;code\u0026gt;.spread()\u0026lt;/code\u0026gt; was pro­vi­ded by many promise libraries (\u0026lt;a href=\u0026quot;https://github.com/kriskowal/q/wiki/API-Reference#promisespreadonfulfilled-onrejected\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;Q\u0026lt;/a\u0026gt;, \u0026lt;a href=\u0026quot;http://bluebirdjs.com/docs/api/spread.html\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;Bluebird\u0026lt;/a\u0026gt;, \u0026lt;a href=\u0026quot;https://github.com/cujojs/when/blob/master/docs/api.md#promisespread\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;when\u0026lt;/a\u0026gt;, ). It takes a function with multiple parameters - one for each array element - to be used as \u0026lt;code\u0026gt;.spread(function(resultA, resultB) { \u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Of course, that closure needed here can be further simplified by some helper functions, e.g.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;addTo\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;x\u0026lt;/span\u0026gt;) {\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// imagine complex `arguments` fiddling or anything that helps usability\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// but you get the idea with this simple one:\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;res\u0026lt;/span\u0026gt; =\u0026amp;gt;\u0026lt;/span\u0026gt; [x, res];\n}\n\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;promiseB\u0026lt;/span\u0026gt;().\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;then\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;addTo\u0026lt;/span\u0026gt;(resultA));\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Alternatively, you can employ \u0026lt;code\u0026gt;Promise.all\u0026lt;/code\u0026gt; to produce the promise for the array:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;getExample\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;) {\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;promiseA\u0026lt;/span\u0026gt;().\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;then\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;resultA\u0026lt;/span\u0026gt;) {\n        \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// some processing\u0026lt;/span\u0026gt;\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Promise\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;all\u0026lt;/span\u0026gt;([resultA, \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;promiseB\u0026lt;/span\u0026gt;()]); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// resultA will implicitly be wrapped\u0026lt;/span\u0026gt;\n                                                    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// as if passed to Promise.resolve()\u0026lt;/span\u0026gt;\n    }).\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;then\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;[resultA, resultB]\u0026lt;/span\u0026gt;) {\n        \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// more processing\u0026lt;/span\u0026gt;\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// something using both resultA and resultB\u0026lt;/span\u0026gt;\n    });\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;And you might not only use arrays, but arbitrarily complex objects. For example, with \u0026lt;a href=\u0026quot;http://underscorejs.org/#extend\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;\u0026lt;code\u0026gt;_.extend\u0026lt;/code\u0026gt;\u0026lt;/a\u0026gt; or \u0026lt;a href=\u0026quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;\u0026lt;code\u0026gt;Object.assign\u0026lt;/code\u0026gt;\u0026lt;/a\u0026gt; in a different helper function:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;augment\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;obj, name\u0026lt;/span\u0026gt;) {\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt; (\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;res\u0026lt;/span\u0026gt;) { \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; r = \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Object\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;assign\u0026lt;/span\u0026gt;({}, obj); r[name] = res; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; r; };\n}\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;getExample\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;) {\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;promiseA\u0026lt;/span\u0026gt;().\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;then\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;resultA\u0026lt;/span\u0026gt;) {\n        \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// some processing\u0026lt;/span\u0026gt;\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;promiseB\u0026lt;/span\u0026gt;().\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;then\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;augment\u0026lt;/span\u0026gt;({resultA}, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;resultB\u0026quot;\u0026lt;/span\u0026gt;));\n    }).\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;then\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;obj\u0026lt;/span\u0026gt;) {\n        \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// more processing\u0026lt;/span\u0026gt;\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// something using both obj.resultA and obj.resultB\u0026lt;/span\u0026gt;\n    });\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;While this pattern guarantees a flat chain and explicit state objects can improve clarity, it will become tedious for a long chain. Especially when you need the state only sporadically, you still have to pass it through every step. With this fixed interface, the single callbacks in the chain are rather tightly coupled and inflexible to change. It makes factoring out single steps harder, and callbacks cannot be supplied directly from other modules - they always need to be wrapped in boilerplate code that cares about the state. Abstract helper functions like the above can ease the pain a bit, but it will always be present.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;h1\u0026gt;Mutable contextual state\u0026lt;/h1\u0026gt;\n\n\u0026lt;p\u0026gt;The trivial (but inelegant and rather errorprone) solution is to just use higher-scope variables (to which all callbacks in the chain have access) and write result values to them when you get them:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;getExample\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;) {\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; resultA;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;promiseA\u0026lt;/span\u0026gt;().\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;then\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;_resultA\u0026lt;/span\u0026gt;) {\n        resultA = _resultA;\n        \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// some processing\u0026lt;/span\u0026gt;\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;promiseB\u0026lt;/span\u0026gt;();\n    }).\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;then\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;resultB\u0026lt;/span\u0026gt;) {\n        \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// more processing\u0026lt;/span\u0026gt;\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// something using both resultA and resultB\u0026lt;/span\u0026gt;\n    });\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Instead of many variables one might also use an (initially empty) object, on which the results are stored as dynamically created properties.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;This solution has several drawbacks:\u0026lt;/p\u0026gt;\n\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;a href=\u0026quot;https://stackoverflow.com/q/844536/1048572\u0026quot;\u0026gt;Mutable state is ugly\u0026lt;/a\u0026gt;, and \u0026lt;a href=\u0026quot;https://softwareengineering.stackexchange.com/questions/148108/why-is-global-state-so-evil\u0026quot;\u0026gt;global variables are evil\u0026lt;/a\u0026gt;.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;This pattern doesn\u0026apos;t work across function boundaries, modularising the functions is harder as their declarations must not leave the shared scope\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;The scope of the variables does not prevent to access them before they are initialized. This is especially likely for complex promise constructions (loops, branching, excptions) where race conditions might happen. Passing state explicitly, a \u0026lt;a href=\u0026quot;http://en.wikipedia.org/wiki/Declarative_programming\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;declarative design\u0026lt;/a\u0026gt; that promises encourage, forces a cleaner coding style which can prevent this.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;One must choose the scope for those shared variables correctly. It needs to be local to the executed function to prevent race conditions between multiple parallel invocations, as would be the case if, for example, state was stored on an instance.\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\n\u0026lt;p\u0026gt;The Bluebird library encourages the use of an object that is passed along, using \u0026lt;a href=\u0026quot;http://bluebirdjs.com/docs/api/bind.html\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;their \u0026lt;code\u0026gt;bind()\u0026lt;/code\u0026gt; method\u0026lt;/a\u0026gt; to assign a context object to a promise chain. It will be accessible from each callback function via the otherwise unusable \u0026lt;a href=\u0026quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/this\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;\u0026lt;code\u0026gt;this\u0026lt;/code\u0026gt; keyword\u0026lt;/a\u0026gt;. While object properties are more prone to undetected typos than variables, the pattern is quite clever:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;getExample\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;) {\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;promiseA\u0026lt;/span\u0026gt;()\n    .\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;bind\u0026lt;/span\u0026gt;({}) \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Bluebird only!\u0026lt;/span\u0026gt;\n    .\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;then\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;resultA\u0026lt;/span\u0026gt;) {\n        \u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;this\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;resultA\u0026lt;/span\u0026gt; = resultA;\n        \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// some processing\u0026lt;/span\u0026gt;\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;promiseB\u0026lt;/span\u0026gt;();\n    }).\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;then\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;resultB\u0026lt;/span\u0026gt;) {\n        \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// more processing\u0026lt;/span\u0026gt;\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// something using both this.resultA and resultB\u0026lt;/span\u0026gt;\n    }).\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;bind\u0026lt;/span\u0026gt;(); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// don\u0026apos;t forget to unbind the object if you don\u0026apos;t want the\u0026lt;/span\u0026gt;\n               \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// caller to access it\u0026lt;/span\u0026gt;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;This approach can be easily simulated in promise libraries that do not support .bind (although in a somewhat more verbose way and cannot be used in an expression):\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;getExample\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;) {\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; ctx = {};\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;promiseA\u0026lt;/span\u0026gt;()\n    .\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;then\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;resultA\u0026lt;/span\u0026gt;) {\n        \u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;this\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;resultA\u0026lt;/span\u0026gt; = resultA;\n        \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// some processing\u0026lt;/span\u0026gt;\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;promiseB\u0026lt;/span\u0026gt;();\n    }.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;bind\u0026lt;/span\u0026gt;(ctx)).\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;then\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;resultB\u0026lt;/span\u0026gt;) {\n        \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// more processing\u0026lt;/span\u0026gt;\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// something using both this.resultA and resultB\u0026lt;/span\u0026gt;\n    }.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;bind\u0026lt;/span\u0026gt;(ctx));\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;h1\u0026gt;A less harsh spin on \u0026quot;Mutable contextual state\u0026quot;\u0026lt;/h1\u0026gt;\n\u0026lt;p\u0026gt;Using a locally scoped object to collect the intermediate results in a promise chain is a reasonable approach to the question you posed. Consider the following snippet:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;getExample\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;){\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//locally scoped\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; results = {};\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;promiseA\u0026lt;/span\u0026gt;(paramsA).\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;then\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;resultA\u0026lt;/span\u0026gt;){\n        results.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;a\u0026lt;/span\u0026gt; = resultA;\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;promiseB\u0026lt;/span\u0026gt;(paramsB);\n    }).\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;then\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;resultB\u0026lt;/span\u0026gt;){\n        results.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;b\u0026lt;/span\u0026gt; = resultB;\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;promiseC\u0026lt;/span\u0026gt;(paramsC);\n    }).\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;then\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;resultC\u0026lt;/span\u0026gt;){\n        \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//Resolve with composite of all promises\u0026lt;/span\u0026gt;\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Promise\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;resolve\u0026lt;/span\u0026gt;(results.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;a\u0026lt;/span\u0026gt; + results.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;b\u0026lt;/span\u0026gt; + resultC);\n    }).\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;catch\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;error\u0026lt;/span\u0026gt;){\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Promise\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;reject\u0026lt;/span\u0026gt;(error);\n    });\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;Global variables are bad, so this solution uses a locally scoped variable which causes no harm.  It is only accessible within the function.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Mutable state is ugly, but this does not mutate state in an ugly manner.  The ugly mutable state traditionally refers to modifying the state of function arguments or global variables, but this approach simply modifies the state of a locally scoped variable that exists for the sole purpose of aggregating promise results...a variable that will die a simple death once the promise resolves.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Intermediate promises are not prevented from accessing the state of the results object, but this does not introduce some scary scenario where one of the promises in the chain will go rogue and sabotage your results.  The responsibility of setting the values in each step of the promise is confined to this function and the overall result will either be correct or incorrect...it will not be some bug that will crop up years later in production (unless you intend it to!)\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;This does not introduce a race condition scenario that would arise from parallel invocation because a new instance of the results variable is created for every invocation of the getExample function.\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;p\u0026gt;Example is available on \u0026lt;a href=\u0026quot;https://jsfiddle.net/w50zqgyr/2/\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;jsfiddle\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Node 7.4 now supports async/await calls with the harmony flag.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Try this: \u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;async\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;getExample\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;){\n\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;let\u0026lt;/span\u0026gt; response = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;await\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;returnPromise\u0026lt;/span\u0026gt;();\n\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;let\u0026lt;/span\u0026gt; response2 = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;await\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;returnPromise2\u0026lt;/span\u0026gt;();\n\n  \u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;console\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;log\u0026lt;/span\u0026gt;(response, response2)\n\n}\n\n\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;getExample\u0026lt;/span\u0026gt;()\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;and run the file with:\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;code\u0026gt;node --harmony-async-await getExample.js\u0026lt;/code\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Simple as can be!\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Another answer, using \u0026lt;code\u0026gt;babel-node\u0026lt;/code\u0026gt; version \u0026amp;lt;6 \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Using \u0026lt;code\u0026gt;async - await\u0026lt;/code\u0026gt; \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;code\u0026gt;npm install -g babel@5.6.14\u0026lt;/code\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;code\u0026gt;example.js:\u0026lt;/code\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;async\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;getExample\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;){\n\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;let\u0026lt;/span\u0026gt; response = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;await\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;returnPromise\u0026lt;/span\u0026gt;();\n\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;let\u0026lt;/span\u0026gt; response2 = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;await\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;returnPromise2\u0026lt;/span\u0026gt;();\n\n  \u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;console\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;log\u0026lt;/span\u0026gt;(response, response2)\n\n}\n\n\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;getExample\u0026lt;/span\u0026gt;()\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Then, run \u0026lt;code\u0026gt;babel-node example.js\u0026lt;/code\u0026gt; and voila!\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;This days, I also hava meet some questions like you. At last, I find a good solution with the quesition, it\u0026apos;s simple and good to read. I hope this can help you.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;According to \u0026lt;a href=\u0026quot;https://html5hive.org/how-to-chain-javascript-promises/\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;how-to-chain-javascript-promises\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;ok, let\u0026apos;s look at the code:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;firstPromise\u0026lt;/span\u0026gt; = (\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;) =\u0026amp;gt; {\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Promise\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;resolve, reject\u0026lt;/span\u0026gt;) =\u0026amp;gt;\u0026lt;/span\u0026gt; {\n        \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;setTimeout\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;() =\u0026amp;gt;\u0026lt;/span\u0026gt; {\n            \u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;console\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;log\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;first promise is completed\u0026apos;\u0026lt;/span\u0026gt;);\n            \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;resolve\u0026lt;/span\u0026gt;({\u0026lt;span class=\u0026quot;hljs-attr\u0026quot;\u0026gt;data\u0026lt;/span\u0026gt;: \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;123\u0026apos;\u0026lt;/span\u0026gt;});\n        }, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2000\u0026lt;/span\u0026gt;);\n    });\n};\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;secondPromise\u0026lt;/span\u0026gt; = (\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;someStuff\u0026lt;/span\u0026gt;) =\u0026amp;gt; {\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Promise\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;resolve, reject\u0026lt;/span\u0026gt;) =\u0026amp;gt;\u0026lt;/span\u0026gt; {\n        \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;setTimeout\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;() =\u0026amp;gt;\u0026lt;/span\u0026gt; {\n            \u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;console\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;log\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;second promise is completed\u0026apos;\u0026lt;/span\u0026gt;);\n            \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;resolve\u0026lt;/span\u0026gt;({\u0026lt;span class=\u0026quot;hljs-attr\u0026quot;\u0026gt;newData\u0026lt;/span\u0026gt;: \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;`\u0026lt;span class=\u0026quot;hljs-subst\u0026quot;\u0026gt;${someStuff.data}\u0026lt;/span\u0026gt; some more data`\u0026lt;/span\u0026gt;});\n        }, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2000\u0026lt;/span\u0026gt;);\n    });\n};\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;thirdPromise\u0026lt;/span\u0026gt; = (\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;someStuff\u0026lt;/span\u0026gt;) =\u0026amp;gt; {\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Promise\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;resolve, reject\u0026lt;/span\u0026gt;) =\u0026amp;gt;\u0026lt;/span\u0026gt; {\n        \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;setTimeout\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;() =\u0026amp;gt;\u0026lt;/span\u0026gt; {\n            \u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;console\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;log\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;third promise is completed\u0026apos;\u0026lt;/span\u0026gt;);\n            \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;resolve\u0026lt;/span\u0026gt;({\u0026lt;span class=\u0026quot;hljs-attr\u0026quot;\u0026gt;result\u0026lt;/span\u0026gt;: someStuff});\n        }, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2000\u0026lt;/span\u0026gt;);\n    });\n};\n\n\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;firstPromise\u0026lt;/span\u0026gt;()\n    .\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;then\u0026lt;/span\u0026gt;(secondPromise)\n    .\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;then\u0026lt;/span\u0026gt;(thirdPromise)\n    .\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;then\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;data\u0026lt;/span\u0026gt; =\u0026amp;gt;\u0026lt;/span\u0026gt; {\n        \u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;console\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;log\u0026lt;/span\u0026gt;(data);\n    });\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;I am not going to use this pattern in my own code since I\u0026apos;m not a big fan of using global variables. However, in a pinch it will work.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;User is a promisified Mongoose model.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; globalVar = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;\u0026apos;\u0026lt;/span\u0026gt;;\n\n\u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;User\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;findAsync\u0026lt;/span\u0026gt;({}).\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;then\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;users\u0026lt;/span\u0026gt;){\n  globalVar = users;\n}).\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;then\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;){\n  \u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;console\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;log\u0026lt;/span\u0026gt;(globalVar);\n});\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Another answer, using sequential executor \u0026lt;a href=\u0026quot;https://github.com/amaksr/nsynjs\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;nsynjs\u0026lt;/a\u0026gt;:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;getExample\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;){\n\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; response1 = \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;returnPromise1\u0026lt;/span\u0026gt;().\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;data\u0026lt;/span\u0026gt;;\n\n  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// promise1 is resolved at this point, \u0026apos;.data\u0026apos; has the result from resolve(result)\u0026lt;/span\u0026gt;\n\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; response2 = \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;returnPromise2\u0026lt;/span\u0026gt;().\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;data\u0026lt;/span\u0026gt;;\n\n  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// promise2 is resolved at this point, \u0026apos;.data\u0026apos; has the result from resolve(result)\u0026lt;/span\u0026gt;\n\n  \u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;console\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;log\u0026lt;/span\u0026gt;(response, response2);\n\n}\n\nnynjs.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;run\u0026lt;/span\u0026gt;(getExample,{},\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;){\n    \u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;console\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;log\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;all done\u0026apos;\u0026lt;/span\u0026gt;);\n})\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;h2\u0026gt;Update: added working example\u0026lt;/h2\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;/p\u0026gt;\u0026lt;div class=\u0026quot;snippet\u0026quot; data-lang=\u0026quot;js\u0026quot; data-hide=\u0026quot;false\u0026quot; data-console=\u0026quot;true\u0026quot; data-babel=\u0026quot;false\u0026quot;\u0026gt;\n\u0026lt;div class=\u0026quot;snippet-code\u0026quot;\u0026gt;\n\u0026lt;pre class=\u0026quot;snippet-code-js lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;synchronousCode\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;) {\n     \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; urls=[\n         \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;https://ajax.googleapis.com/ajax/libs/jquery/1.7.0/jquery.min.js\u0026quot;\u0026lt;/span\u0026gt;,\n         \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;https://ajax.googleapis.com/ajax/libs/jquery/1.8.0/jquery.min.js\u0026quot;\u0026lt;/span\u0026gt;,\n         \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;https://ajax.googleapis.com/ajax/libs/jquery/1.9.0/jquery.min.js\u0026quot;\u0026lt;/span\u0026gt;\n     ];\n     \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; i=\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;; i\u0026amp;lt;urls.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;length\u0026lt;/span\u0026gt;; i++) {\n         \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; len=\u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;window\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;fetch\u0026lt;/span\u0026gt;(urls[i]).\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;data\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;text\u0026lt;/span\u0026gt;().\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;data\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;length\u0026lt;/span\u0026gt;;\n         \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//             ^                   ^\u0026lt;/span\u0026gt;\n         \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//             |                   +- 2-nd promise result\u0026lt;/span\u0026gt;\n         \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//             |                      assigned to \u0026apos;data\u0026apos;\u0026lt;/span\u0026gt;\n         \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//             |\u0026lt;/span\u0026gt;\n         \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//             +-- 1-st promise result assigned to \u0026apos;data\u0026apos;\u0026lt;/span\u0026gt;\n         \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//\u0026lt;/span\u0026gt;\n         \u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;console\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;log\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;URL #\u0026apos;\u0026lt;/span\u0026gt;+i+\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos; : \u0026apos;\u0026lt;/span\u0026gt;+urls[i]+\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;, length: \u0026quot;\u0026lt;/span\u0026gt;+len);\n     }\n}\n\nnsynjs.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;run\u0026lt;/span\u0026gt;(synchronousCode,{},\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;){\n    \u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;console\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;log\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;all done\u0026apos;\u0026lt;/span\u0026gt;);\n})\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;pre class=\u0026quot;snippet-code-html lang-html s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-xml\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-tag\u0026quot;\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;script\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-attr\u0026quot;\u0026gt;src\u0026lt;/span\u0026gt;=\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;https://rawgit.com/amaksr/nsynjs/master/nsynjs.js\u0026quot;\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-tag\u0026quot;\u0026gt;\u0026amp;lt;/\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;script\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;div class=\u0026quot;snippet-result\u0026quot;\u0026gt;\u0026lt;div class=\u0026quot;snippet-ctas\u0026quot;\u0026gt;\u0026lt;button type=\u0026quot;button\u0026quot; class=\u0026quot;s-btn s-btn__primary\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;icon-play-white _hover\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;\u0026lt;span\u0026gt; Run code snippet\u0026lt;/span\u0026gt;\u0026lt;/button\u0026gt;\u0026lt;input class=\u0026quot;copySnippet s-btn s-btn__filled\u0026quot; type=\u0026quot;button\u0026quot; value=\u0026quot;Copy snippet to answer\u0026quot; style=\u0026quot;display: none;\u0026quot;\u0026gt;\u0026lt;button type=\u0026quot;button\u0026quot; class=\u0026quot;s-btn hideResults\u0026quot; style=\u0026quot;display: none;\u0026quot;\u0026gt;Hide results\u0026lt;/button\u0026gt;\u0026lt;div class=\u0026quot;popout-code\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;snippet-expand-link\u0026quot;\u0026gt;Expand snippet\u0026lt;/a\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;div class=\u0026quot;snippet-result-code\u0026quot; style=\u0026quot;display: none;\u0026quot;\u0026gt;\u0026lt;iframe name=\u0026quot;sif1\u0026quot; sandbox=\u0026quot;allow-forms allow-modals allow-scripts\u0026quot; class=\u0026quot;snippet-box-edit snippet-box-result\u0026quot; frameborder=\u0026quot;0\u0026quot;\u0026gt;\u0026lt;/iframe\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;/div\u0026gt;\n\u0026lt;/div\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;When using bluebird, you can use \u0026lt;code\u0026gt;.bind\u0026lt;/code\u0026gt; method to share variables in promise chain:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;somethingAsync\u0026lt;/span\u0026gt;().\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;bind\u0026lt;/span\u0026gt;({})\n.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;spread\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt; (\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;aValue, bValue\u0026lt;/span\u0026gt;) {\n    \u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;this\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;aValue\u0026lt;/span\u0026gt; = aValue;\n    \u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;this\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;bValue\u0026lt;/span\u0026gt; = bValue;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;somethingElseAsync\u0026lt;/span\u0026gt;(aValue, bValue);\n})\n.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;then\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt; (\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;cValue\u0026lt;/span\u0026gt;) {\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;this\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;aValue\u0026lt;/span\u0026gt; + \u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;this\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;bValue\u0026lt;/span\u0026gt; + cValue;\n});\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;please check this link for further information:\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;a href=\u0026quot;http://bluebirdjs.com/docs/api/promise.bind.html\u0026quot; rel=\u0026quot;nofollow\u0026quot;\u0026gt;http://bluebirdjs.com/docs/api/promise.bind.html\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;getExample\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;) {\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; retA, retB;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;promiseA\u0026lt;/span\u0026gt;().\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;then\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;resultA\u0026lt;/span\u0026gt;) {\n        retA = resultA;\n        \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Some processing\u0026lt;/span\u0026gt;\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;promiseB\u0026lt;/span\u0026gt;();\n    }).\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;then\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;resultB\u0026lt;/span\u0026gt;) {\n        \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// More processing\u0026lt;/span\u0026gt;\n        \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//retA is value of promiseA\u0026lt;/span\u0026gt;\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// How do I gain access to resultA here?\u0026lt;/span\u0026gt;\n    });\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;easy way :D\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;I think you can use hash of RSVP.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Something like as below :\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;mainPromise\u0026lt;/span\u0026gt; = (\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;) =\u0026amp;gt; {\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; promise1 = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Promise\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;resolve, reject\u0026lt;/span\u0026gt;) =\u0026amp;gt;\u0026lt;/span\u0026gt; {\n            \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;setTimeout\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;() =\u0026amp;gt;\u0026lt;/span\u0026gt; {\n                \u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;console\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;log\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;first promise is completed\u0026apos;\u0026lt;/span\u0026gt;);\n                \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;resolve\u0026lt;/span\u0026gt;({\u0026lt;span class=\u0026quot;hljs-attr\u0026quot;\u0026gt;data\u0026lt;/span\u0026gt;: \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;123\u0026apos;\u0026lt;/span\u0026gt;});\n            }, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2000\u0026lt;/span\u0026gt;);\n        });\n\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; promise2 = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Promise\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;resolve, reject\u0026lt;/span\u0026gt;) =\u0026amp;gt;\u0026lt;/span\u0026gt; {\n            \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;setTimeout\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;() =\u0026amp;gt;\u0026lt;/span\u0026gt; {\n                \u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;console\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;log\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;second promise is completed\u0026apos;\u0026lt;/span\u0026gt;);\n                \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;resolve\u0026lt;/span\u0026gt;({\u0026lt;span class=\u0026quot;hljs-attr\u0026quot;\u0026gt;data\u0026lt;/span\u0026gt;: \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;456\u0026apos;\u0026lt;/span\u0026gt;});\n            }, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2000\u0026lt;/span\u0026gt;);\n        });\n\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-variable constant_\u0026quot;\u0026gt;RSVP\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;hash\u0026lt;/span\u0026gt;({\n              \u0026lt;span class=\u0026quot;hljs-attr\u0026quot;\u0026gt;prom1\u0026lt;/span\u0026gt;: promise1,\n              \u0026lt;span class=\u0026quot;hljs-attr\u0026quot;\u0026gt;prom2\u0026lt;/span\u0026gt;: promise2\n          });\n\n    };\n\n\n   \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;mainPromise\u0026lt;/span\u0026gt;()\n    .\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;then\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;data\u0026lt;/span\u0026gt; =\u0026amp;gt;\u0026lt;/span\u0026gt; {\n        \u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;console\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;log\u0026lt;/span\u0026gt;(data.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;prom1\u0026lt;/span\u0026gt;);\n        \u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;console\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;log\u0026lt;/span\u0026gt;(data.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;prom2\u0026lt;/span\u0026gt;);\n    });\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Solution:\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;You can put intermediate values in scope in any later \u0026apos;then\u0026apos; function explicitly, by using \u0026apos;bind\u0026apos;. It is a nice solution that doesn\u0026apos;t require changing how Promises work, and only requires a line or two of code to propagate the values just like errors are already propagated.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Here is a complete example:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Get info asynchronously from a server\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;pGetServerInfo\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;)\n    {\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// then value: \u0026quot;server info\u0026quot;\u0026lt;/span\u0026gt;\n    } \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// pGetServerInfo\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Write into a file asynchronously\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;pWriteFile\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;path,string\u0026lt;/span\u0026gt;)\n    {\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// no then value\u0026lt;/span\u0026gt;\n    } \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// pWriteFile\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// The heart of the solution: Write formatted info into a log file asynchronously,\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// using the pGetServerInfo and pWriteFile operations\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;pLogInfo\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;localInfo\u0026lt;/span\u0026gt;)\n    {\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; scope={\u0026lt;span class=\u0026quot;hljs-attr\u0026quot;\u0026gt;localInfo\u0026lt;/span\u0026gt;:localInfo}; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Create an explicit scope object\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; thenFunc=p2.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;bind\u0026lt;/span\u0026gt;(scope); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Create a temporary function with this scope\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; (\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;pGetServerInfo\u0026lt;/span\u0026gt;().\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;then\u0026lt;/span\u0026gt;(thenFunc)); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Do the next \u0026apos;then\u0026apos; in the chain\u0026lt;/span\u0026gt;\n    } \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// pLogInfo\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Scope of this \u0026apos;then\u0026apos; function is {localInfo:localInfo}\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;p2\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;serverInfo\u0026lt;/span\u0026gt;)\n    {\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Do the final \u0026apos;then\u0026apos; in the chain: Writes \u0026quot;local info, server info\u0026quot;\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;pWriteFile\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;log\u0026apos;\u0026lt;/span\u0026gt;,\u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;this\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;localInfo\u0026lt;/span\u0026gt;+\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;,\u0026apos;\u0026lt;/span\u0026gt;+serverInfo);\n    } \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// p2\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;This solution can be invoked as follows:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;pLogInfo\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;local info\u0026quot;\u0026lt;/span\u0026gt;).\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;then\u0026lt;/span\u0026gt;().\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;catch\u0026lt;/span\u0026gt;(err);\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;(Note: a more complex and complete version of this solution has been tested, but not this example version, so it could have a bug.)\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;What I learn about promises is to use it only as return values \u0026lt;strong\u0026gt;avoid referencing them\u0026lt;/strong\u0026gt; if possible. async/await syntax is particularly practical for that. Today all latest browsers and node support it: \u0026lt;a href=\u0026quot;https://caniuse.com/#feat=async-functions\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;https://caniuse.com/#feat=async-functions\u0026lt;/a\u0026gt; , is a simple behavior and the code is like reading synchronous code, forget about callbacks...\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;In cases I do need to reference a promises is when creation and resolution happen at independent/not-related places. So instead an artificial association and probably an event listener just to resolve the \u0026quot;distant\u0026quot; promise, I prefer to expose the promise as a Deferred, which the following code implements it in valid es5\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;/**\n * Promise like object that allows to resolve it promise from outside code. Example:\n *\n```\nclass Api {\n  fooReady = new Deferred\u0026amp;lt;Data\u0026amp;gt;()\n  private knower() {\n    inOtherMoment(data=\u0026amp;gt;{\n      this.fooReady.resolve(data)\n    })\n  }\n}\n```\n */\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Deferred\u0026lt;/span\u0026gt; = \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;/** \u0026lt;span class=\u0026quot;hljs-doctag\u0026quot;\u0026gt;@class\u0026lt;/span\u0026gt; */\u0026lt;/span\u0026gt; (\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt; (\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;) {\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;Deferred\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;callback\u0026lt;/span\u0026gt;) {\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; instance = \u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;this\u0026lt;/span\u0026gt;;\n    \u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;this\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;resolve\u0026lt;/span\u0026gt; = \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;null\u0026lt;/span\u0026gt;;\n    \u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;this\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;reject\u0026lt;/span\u0026gt; = \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;null\u0026lt;/span\u0026gt;;\n    \u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;this\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;status\u0026lt;/span\u0026gt; = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;pending\u0026apos;\u0026lt;/span\u0026gt;;\n    \u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;this\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;promise\u0026lt;/span\u0026gt; = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Promise\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt; (\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;resolve, reject\u0026lt;/span\u0026gt;) {\n      instance.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;resolve\u0026lt;/span\u0026gt; = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt; (\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;) { \u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;this\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;status\u0026lt;/span\u0026gt; = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;resolved\u0026apos;\u0026lt;/span\u0026gt;; resolve.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;apply\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;this\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;arguments\u0026lt;/span\u0026gt;); };\n      instance.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;reject\u0026lt;/span\u0026gt; = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt; (\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;) { \u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;this\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;status\u0026lt;/span\u0026gt; = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;rejected\u0026apos;\u0026lt;/span\u0026gt;; reject.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;apply\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;this\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;arguments\u0026lt;/span\u0026gt;); };\n    });\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typeof\u0026lt;/span\u0026gt; callback === \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;function\u0026apos;\u0026lt;/span\u0026gt;) {\n      callback.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;call\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;this\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;this\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;resolve\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;this\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;reject\u0026lt;/span\u0026gt;);\n    }\n  }\n  \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Deferred\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;prototype\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;then\u0026lt;/span\u0026gt; = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt; (\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;resolve\u0026lt;/span\u0026gt;) {\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;this\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;promise\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;then\u0026lt;/span\u0026gt;(resolve);\n  };\n  \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Deferred\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;prototype\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;catch\u0026lt;/span\u0026gt; = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt; (\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;r\u0026lt;/span\u0026gt;) {\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;this\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;promise\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;catch\u0026lt;/span\u0026gt;(r);\n  };\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Deferred\u0026lt;/span\u0026gt;;\n}());\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;transpiled form a typescript project of mine:\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;a href=\u0026quot;https://github.com/cancerberoSgx/misc-utils-of-mine/blob/2927c2477839f7b36247d054e7e50abe8a41358b/misc-utils-of-mine-generic/src/promise.ts#L31\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;https://github.com/cancerberoSgx/misc-utils-of-mine/blob/2927c2477839f7b36247d054e7e50abe8a41358b/misc-utils-of-mine-generic/src/promise.ts#L31\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;For more complex cases I often use these guy small promise utilities without dependencies tested and typed. p-map has been useful several times. I think he covered most use cases:\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;a href=\u0026quot;https://github.com/sindresorhus?utf8=%E2%9C%93\u0026amp;amp;tab=repositories\u0026amp;amp;q=promise\u0026amp;amp;type=source\u0026amp;amp;language=\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;https://github.com/sindresorhus?utf8=%E2%9C%93\u0026amp;amp;tab=repositories\u0026amp;amp;q=promise\u0026amp;amp;type=source\u0026amp;amp;language=\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n    "],"id":346,"title":"How do I access previous promise results in a .then() chain?","content":"\n                \n\u0026lt;p\u0026gt;I have restructured my code to \u0026lt;a href=\u0026quot;https://en.wikipedia.org/wiki/Futures_and_promises\u0026quot;\u0026gt;promises\u0026lt;/a\u0026gt;, and built a wonderful long \u0026lt;strong\u0026gt;flat promise chain\u0026lt;/strong\u0026gt;, consisting of multiple \u0026lt;code\u0026gt;.then()\u0026lt;/code\u0026gt; callbacks. In the end I want to return some composite value, and need to access multiple \u0026lt;strong\u0026gt;intermediate promise results\u0026lt;/strong\u0026gt;. However the resolution values from the middle of the sequence are not in scope in the last callback, how do I access them?\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;getExample\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;) {\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;promiseA\u0026lt;/span\u0026gt;(…).\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;then\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;resultA\u0026lt;/span\u0026gt;) {\n        \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Some processing\u0026lt;/span\u0026gt;\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;promiseB\u0026lt;/span\u0026gt;(…);\n    }).\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;then\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;resultB\u0026lt;/span\u0026gt;) {\n        \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// More processing\u0026lt;/span\u0026gt;\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// How do I gain access to resultA here?\u0026lt;/span\u0026gt;\n    });\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","slug":"how-do-i-access-previous-promise-results-in-a-.then()-chain-1657387705386","postType":"QUESTION","createdAt":"2022-07-09T17:28:25.000Z","updatedAt":"2022-07-09T17:28:25.000Z","tags":[],"relatedQuestions":[]},"randomQuestions":[{"title":"\"Cross origin requests are only supported for HTTP.\" error when loading a local file","slug":"\"cross-origin-requests-are-only-supported-for-http.\"-error-when-loading-a-local-file-1657387942403"},{"title":"Calling a function of a module by using its name (a string)","slug":"calling-a-function-of-a-module-by-using-its-name-(a-string)-1657388565656"},{"title":"Deep cloning objects","slug":"deep-cloning-objects-1657387930865"},{"title":"How to unnest (explode) a column in a pandas DataFrame, into multiple rows","slug":"how-to-unnest-(explode)-a-column-in-a-pandas-dataframe-into-multiple-rows-1657387806735"},{"title":"Why is the gets function so dangerous that it should not be used?","slug":"why-is-the-gets-function-so-dangerous-that-it-should-not-be-used-1657384544362"},{"title":"How to manage startActivityForResult on Android","slug":"how-to-manage-startactivityforresult-on-android-1657387967393"},{"title":"Official locator strategies for the webdriver","slug":"official-locator-strategies-for-the-webdriver-1657384353174"},{"title":"Why does jQuery or a DOM method such as getElementById not find the element?","slug":"why-does-jquery-or-a-dom-method-such-as-getelementbyid-not-find-the-element-1657384326458"},{"title":"How can I make an AJAX call without jQuery?","slug":"how-can-i-make-an-ajax-call-without-jquery-1657388448955"},{"title":"How do I format a date in JavaScript?","slug":"how-do-i-format-a-date-in-javascript-1657384649498"},{"title":"Why does a RegExp with global flag give wrong results?","slug":"why-does-a-regexp-with-global-flag-give-wrong-results-1657387788550"},{"title":"Numbering rows within groups in a data frame","slug":"numbering-rows-within-groups-in-a-data-frame-1657388556436"},{"title":"Dynamic tabs with user-click chosen components","slug":"dynamic-tabs-with-user-click-chosen-components-1657388465232"},{"title":"Make container shrink-to-fit child elements as they wrap","slug":"make-container-shrink-to-fit-child-elements-as-they-wrap-1657388134549"},{"title":"How can I deserialize JSON with C#?","slug":"how-can-i-deserialize-json-with-c-1657388102941"},{"title":"Short description of the scoping rules?","slug":"short-description-of-the-scoping-rules-1657384853121"},{"title":"Sort ArrayList of custom Objects by property","slug":"sort-arraylist-of-custom-objects-by-property-1657387678339"},{"title":"What does if __name__ == \"__main__\": do?","slug":"what-does-if-__name__-\"__main__\":-do-1657384825815"},{"title":"Prefer composition over inheritance?","slug":"prefer-composition-over-inheritance-1657387399409"},{"title":"What is a NullReferenceException, and how do I fix it?","slug":"what-is-a-nullreferenceexception-and-how-do-i-fix-it-1657384234873"}]},"__N_SSG":true},"page":"/questions/[slug]","query":{"slug":"how-do-i-access-previous-promise-results-in-a-.then()-chain-1657387705386"},"buildId":"xZs8haGjOP63QuDE0kxeX","isFallback":false,"gsp":true,"locale":"en","locales":["en"],"defaultLocale":"en","scriptLoader":[]}</script></body></html>