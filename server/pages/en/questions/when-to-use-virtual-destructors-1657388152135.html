<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><meta name="twitter:card" content="summary_large_image"/><meta name="twitter:site" content="@solutionschecker.com"/><meta name="twitter:creator" content="@solutionschecker.com"/><meta property="og:url" content="https://solutionschecker.com"/><meta property="og:type" content="website"/><meta property="og:image" content="https://solutionschecker.com/solutions-checker-banner.png"/><meta property="og:image:alt" content="Find the solution to any question. We focus on finding the fastest possible solution for users. Main topics like coding, learning. - solutionschecker.com"/><link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png"/><link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png"/><link rel="manifest" href="/site.webmanifest"/><script type="application/ld+json">{"@context":"https://schema.org","@type":"Organization","logo":"/logo.svg","url":"https://solutionschecker.com"}</script><link name="keywords" content="virtual-destructor,shared-ptr,solutions checker, solution checker, how to, solution for, check for solution, resolve question, what is, what solution for, find solution"/><script type="application/ld+json">{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"item":{"@id":"https://solutionschecker.com","name":"Home"}},{"@type":"ListItem","position":2,"item":{"@id":"https://solutionschecker.com/questions","name":"Questions"}},{"@type":"ListItem","position":3,"item":{"@id":"https://solutionschecker.com/questions/when-to-use-virtual-destructors-1657388152135","name":"Questions"}}]}</script><title>When to use virtual destructors? | Solution Checker</title><meta name="robots" content="index,follow"/><meta name="description" content="I have a solid understanding of most OOP theory but the one thing that confuses me a lot is virtual destructors.
I thought that the destructor always gets called no matter what and for every object in the chain.
When are you meant to make them virtual and why?
    "/><meta property="og:title" content="When to use virtual destructors? | Solution Checker"/><meta property="og:description" content="I have a solid understanding of most OOP theory but the one thing that confuses me a lot is virtual destructors.
I thought that the destructor always gets called no matter what and for every object in the chain.
When are you meant to make them virtual and why?
    "/><script type="application/ld+json">{"@context":"https://schema.org","@type":"QAPage","mainEntity":{"name":"When to use virtual destructors?","text":"I have a solid understanding of most OOP theory but the one thing that confuses me a lot is virtual destructors.\nI thought that the destructor always gets called no matter what and for every object in the chain.\nWhen are you meant to make them virtual and why?\n    ","answerCount":19,"upVoteCount":500,"suggestedAnswer":[{"text":"Virtual destructors are useful when you might potentially delete an instance of a derived class through a pointer to base class:\n\nclass Base \n{\n    // some virtual methods\n};\n\nclass Derived : public Base\n{\n    ~Derived()\n    {\n        // Do some important cleanup\n    }\n};\n\n\nHere, you&apos;ll notice that I didn&apos;t declare Base&apos;s destructor to be virtual. Now, let&apos;s have a look at the following snippet:\n\nBase *b = new Derived();\n// use b\ndelete b; // Here&apos;s the problem!\n\n\nSince Base&apos;s destructor is not virtual and b is a Base* pointing to a Derived object, delete b has undefined behaviour:\n\n\n  [In delete b], if the static type of the\n  object to be deleted is different from its dynamic type, the static\n  type shall be a base class of the dynamic type of the object to be\n  deleted and the static type shall have a virtual destructor or the\n  behavior is undefined.\n\n\nIn most implementations, the call to the destructor will be resolved like any non-virtual code, meaning that the destructor of the base class will be called but not the one of the derived class, resulting in a resources leak.\n\nTo sum up, always make base classes&apos; destructors virtual when they&apos;re meant to be manipulated polymorphically.\n\nIf you want to prevent the deletion of an instance through a base class pointer, you can make the base class destructor protected and nonvirtual; by doing so, the compiler won&apos;t let you call delete on a base class pointer.\n\nYou can learn more about virtuality and virtual base class destructor in this article from Herb Sutter.\n    ","url":"/questions/[slug]#solution1","@type":"Answer","upvoteCount":0},{"text":"A virtual constructor is not possible but virtual destructor is possible.\nLet us experiment.......\n\n#include &lt;iostream&gt;\n\nusing namespace std;\n\nclass Base\n{\npublic:\n    Base(){\n        cout &lt;&lt; &quot;Base Constructor Called\\n&quot;;\n    }\n    ~Base(){\n        cout &lt;&lt; &quot;Base Destructor called\\n&quot;;\n    }\n};\n\nclass Derived1: public Base\n{\npublic:\n    Derived1(){\n        cout &lt;&lt; &quot;Derived constructor called\\n&quot;;\n    }\n    ~Derived1(){\n        cout &lt;&lt; &quot;Derived destructor called\\n&quot;;\n    }\n};\n\nint main()\n{\n    Base *b = new Derived1();\n    delete b;\n}\n\n\nThe above code output the following:\n\nBase Constructor Called\nDerived constructor called\nBase Destructor called\n\n\nThe construction of derived object follow the construction rule but when we delete the &quot;b&quot; pointer(base pointer) we have found that only the base destructor is called. But this must not happen. To do the appropriate thing, we have to make the base destructor virtual.\nNow let see what happens in the following:\n\n#include &lt;iostream&gt;\n\nusing namespace std;\n\nclass Base\n{ \npublic:\n    Base(){\n        cout &lt;&lt; &quot;Base Constructor Called\\n&quot;;\n    }\n    virtual ~Base(){\n        cout &lt;&lt; &quot;Base Destructor called\\n&quot;;\n    }\n};\n\nclass Derived1: public Base\n{\npublic:\n    Derived1(){\n        cout &lt;&lt; &quot;Derived constructor called\\n&quot;;\n    }\n    ~Derived1(){\n        cout &lt;&lt; &quot;Derived destructor called\\n&quot;;\n    }\n};\n\nint main()\n{\n    Base *b = new Derived1();\n    delete b;\n}\n\n\nThe output changed as following:\n\nBase Constructor Called\nDerived Constructor called\nDerived destructor called\nBase destructor called\n\n\nSo the destruction of the base pointer (which takes an allocation on derived object!) follows the destruction rule, i.e first the Derived, then the Base.\nOn the other hand, there is nothing like a virtual constructor.       \n    ","url":"/questions/[slug]#solution2","@type":"Answer","upvoteCount":0},{"text":"Declare destructors virtual in polymorphic base classes.  This is Item 7 in Scott Meyers&apos; Effective C++.  Meyers goes on to summarize that if a class has any virtual function, it should have a virtual destructor, and that classes not designed to be base classes or not designed to be used polymorphically should not declare virtual destructors.\n    ","url":"/questions/[slug]#solution3","@type":"Answer","upvoteCount":0},{"text":"Also be aware that deleting a base class pointer when there is no virtual destructor will result in undefined behavior.  Something that I learned just recently:\n\nHow should overriding delete in C++ behave?\n\nI&apos;ve been using C++ for years and I still manage to hang myself.\n    ","url":"/questions/[slug]#solution4","@type":"Answer","upvoteCount":0},{"text":"Make the destructor virtual whenever your class is polymorphic.\n    ","url":"/questions/[slug]#solution5","@type":"Answer","upvoteCount":0},{"text":"Calling destructor via a pointer to a base class\n\nstruct Base {\n  virtual void f() {}\n  virtual ~Base() {}\n};\n\nstruct Derived : Base {\n  void f() override {}\n  ~Derived() override {}\n};\n\nBase* base = new Derived;\nbase-&gt;f(); // calls Derived::f\nbase-&gt;~Base(); // calls Derived::~Derived\n\n\nVirtual destructor call is no different from any other virtual function call.\n\nFor base-&gt;f(), the call will be dispatched to Derived::f(), and it&apos;s the same for base-&gt;~Base() - its overriding function - the Derived::~Derived() will be called.\n\nSame happens when destructor is being called indirectly, e.g. delete base;. The delete statement will call base-&gt;~Base() which will be dispatched to Derived::~Derived().\n\nAbstract class with non-virtual destructor\n\nIf you are not going to delete object through a pointer to its base class - then there is no need to have a virtual destructor. Just make it protected so that it won&apos;t be called accidentally:\n\n// library.hpp\n\nstruct Base {\n  virtual void f() = 0;\n\nprotected:\n  ~Base() = default;\n};\n\nvoid CallsF(Base&amp; base);\n// CallsF is not going to own &quot;base&quot; (i.e. call &quot;delete &amp;base;&quot;).\n// It will only call Base::f() so it doesn&apos;t need to access Base::~Base.\n\n//-------------------\n// application.cpp\n\nstruct Derived : Base {\n  void f() override { ... }\n};\n\nint main() {\n  Derived derived;\n  CallsF(derived);\n  // No need for virtual destructor here as well.\n}\n\n    ","url":"/questions/[slug]#solution6","@type":"Answer","upvoteCount":0},{"text":"To be simple,\nVirtual destructor is to destruct the resources in a proper order, when you delete a base class pointer pointing to derived class object.\n\n #include&lt;iostream&gt;\n using namespace std;\n class B{\n    public:\n       B(){\n          cout&lt;&lt;&quot;B()\\n&quot;;\n       }\n       virtual ~B(){ \n          cout&lt;&lt;&quot;~B()\\n&quot;;\n       }\n };\n class D: public B{\n    public:\n       D(){\n          cout&lt;&lt;&quot;D()\\n&quot;;\n       }\n       ~D(){\n          cout&lt;&lt;&quot;~D()\\n&quot;;\n       }\n };\n int main(){\n    B *b = new D();\n    delete b;\n    return 0;\n }\n\nOUTPUT:\nB()\nD()\n~D()\n~B()\n\n==============\nIf you don&apos;t give ~B()  as virtual. then output would be \nB()\nD()\n~B()\nwhere destruction of ~D() is not done which leads to leak\n\n\n\n    ","url":"/questions/[slug]#solution7","@type":"Answer","upvoteCount":0},{"text":"Virtual keyword for destructor is necessary when you want different destructors should follow proper order while objects is being deleted through base class pointer. \nfor example:\n\nBase *myObj = new Derived();\n// Some code which is using myObj object\nmyObj-&gt;fun();\n//Now delete the object\ndelete myObj ; \n\n\nIf your base class destructor is virtual then objects will be destructed in a order(firstly derived object then base ). If your base class destructor is NOT virtual then only base class object will get deleted(because pointer is of base class &quot;Base *myObj&quot;). So there will be memory leak for derived object.\n    ","url":"/questions/[slug]#solution8","@type":"Answer","upvoteCount":0},{"text":"I like to think about interfaces and implementations of interfaces. In C++ speak interface is pure virtual class. Destructor is part of the interface and expected to implemented. Therefore destructor should be pure virtual. How about constructor? Constructor is actually not part of the interface because object is always instantiated explicitly. \n    ","url":"/questions/[slug]#solution9","@type":"Answer","upvoteCount":0},{"text":"Virtual base class destructors are &quot;best practice&quot; - you should always use them to avoid (hard to detect) memory leaks. Using them, you can be sure all destructors in the inheritance chain of your classes are beeing called (in proper order). Inheriting from a base class using virtual destructor makes the destructor of the inheriting class automatically virtual, too (so you do not have to retype &apos;virtual&apos; in the inheriting class destructor declaration).\n    ","url":"/questions/[slug]#solution10","@type":"Answer","upvoteCount":0},{"text":"I think the core of this question is about virtual methods and polymorphism, not the destructor specifically. Here is a clearer example:\n\nclass A\n{\npublic:\n    A() {}\n    virtual void foo()\n    {\n        cout &lt;&lt; &quot;This is A.&quot; &lt;&lt; endl;\n    }\n};\n\nclass B : public A\n{\npublic:\n    B() {}\n    void foo()\n    {\n        cout &lt;&lt; &quot;This is B.&quot; &lt;&lt; endl;\n    }\n};\n\nint main(int argc, char* argv[])\n{\n    A *a = new B();\n    a-&gt;foo();\n    if(a != NULL)\n    delete a;\n    return 0;\n}\n\n\nWill print out:\n\nThis is B.\n\n\nWithout virtual it will print out:\n\nThis is A.\n\n\nAnd now you should understand when to use virtual destructors.\n    ","url":"/questions/[slug]#solution11","@type":"Answer","upvoteCount":0},{"text":"If you use shared_ptr(only shared_ptr, not unique_ptr), you don&apos;t have to have the base class destructor virtual:\n\n#include &lt;iostream&gt;\n#include &lt;memory&gt;\n\nusing namespace std;\n\nclass Base\n{\npublic:\n    Base(){\n        cout &lt;&lt; &quot;Base Constructor Called\\n&quot;;\n    }\n    ~Base(){ // not virtual\n        cout &lt;&lt; &quot;Base Destructor called\\n&quot;;\n    }\n};\n\nclass Derived: public Base\n{\npublic:\n    Derived(){\n        cout &lt;&lt; &quot;Derived constructor called\\n&quot;;\n    }\n    ~Derived(){\n        cout &lt;&lt; &quot;Derived destructor called\\n&quot;;\n    }\n};\n\nint main()\n{\n    shared_ptr&lt;Base&gt; b(new Derived());\n}\n\n\noutput:\n\nBase Constructor Called\nDerived constructor called\nDerived destructor called\nBase Destructor called\n\n    ","url":"/questions/[slug]#solution12","@type":"Answer","upvoteCount":0},{"text":"What is a virtual destructor or how to use virtual destructor\n\nA class destructor is a function with same name of the class preceding with ~ that will reallocate the memory that is allocated by the class. Why we need a virtual destructor\n\nSee  the  following  sample with some virtual functions\n\nThe sample also tell how you can convert a letter to upper or lower\n\n#include &quot;stdafx.h&quot;\n#include&lt;iostream&gt;\nusing namespace std;\n// program to convert the lower to upper orlower\nclass convertch\n{\npublic:\n  //void convertch(){};\n  virtual char* convertChar() = 0;\n  ~convertch(){};\n};\n\nclass MakeLower :public convertch\n{\npublic:\n  MakeLower(char *passLetter)\n  {\n    tolower = true;\n    Letter = new char[30];\n    strcpy(Letter, passLetter);\n  }\n\n  virtual ~MakeLower()\n  {\n    cout&lt;&lt; &quot;called ~MakeLower()&quot;&lt;&lt;&quot;\\n&quot;;\n    delete[] Letter;\n  }\n\n  char* convertChar()\n  {\n    size_t len = strlen(Letter);\n    for(int i= 0;i&lt;len;i++)\n      Letter[i] = Letter[i] + 32;\n    return Letter;\n  }\n\nprivate:\n  char *Letter;\n  bool tolower;\n};\n\nclass MakeUpper : public convertch\n{\npublic:\n  MakeUpper(char *passLetter)\n  {\n    Letter = new char[30];\n    toupper = true;\n    strcpy(Letter, passLetter);\n  }\n\n  char* convertChar()\n  {   \n    size_t len = strlen(Letter);\n    for(int i= 0;i&lt;len;i++)\n      Letter[i] = Letter[i] - 32;\n    return Letter;\n  }\n\n  virtual ~MakeUpper()\n  {\n    cout&lt;&lt; &quot;called ~MakeUpper()&quot;&lt;&lt;&quot;\\n&quot;;\n    delete Letter;\n  }\n\nprivate:\n  char *Letter;\n  bool toupper;\n};\n\n\nint _tmain(int argc, _TCHAR* argv[])\n{\n  convertch *makeupper = new MakeUpper(&quot;hai&quot;); \n  cout&lt;&lt; &quot;Eneterd : hai = &quot; &lt;&lt;makeupper-&gt;convertChar()&lt;&lt;&quot; &quot;;     \n  delete makeupper;\n  convertch *makelower = new MakeLower(&quot;HAI&quot;);;\n  cout&lt;&lt;&quot;Eneterd : HAI = &quot; &lt;&lt;makelower-&gt;convertChar()&lt;&lt;&quot; &quot;; \n  delete makelower;\n  return 0;\n}\n\n\nFrom the above sample you can see that the destructor for both MakeUpper and MakeLower class is not called.\n\nSee the next sample with the virtual destructor\n\n#include &quot;stdafx.h&quot;\n#include&lt;iostream&gt;\n\nusing namespace std;\n// program to convert the lower to upper orlower\nclass convertch\n{\npublic:\n//void convertch(){};\nvirtual char* convertChar() = 0;\nvirtual ~convertch(){}; // defined the virtual destructor\n\n};\nclass MakeLower :public convertch\n{\npublic:\nMakeLower(char *passLetter)\n{\ntolower = true;\nLetter = new char[30];\nstrcpy(Letter, passLetter);\n}\nvirtual ~MakeLower()\n{\ncout&lt;&lt; &quot;called ~MakeLower()&quot;&lt;&lt;&quot;\\n&quot;;\n      delete[] Letter;\n}\nchar* convertChar()\n{\nsize_t len = strlen(Letter);\nfor(int i= 0;i&lt;len;i++)\n{\nLetter[i] = Letter[i] + 32;\n\n}\n\nreturn Letter;\n}\n\nprivate:\nchar *Letter;\nbool tolower;\n\n};\nclass MakeUpper : public convertch\n{\npublic:\nMakeUpper(char *passLetter)\n{\nLetter = new char[30];\ntoupper = true;\nstrcpy(Letter, passLetter);\n}\nchar* convertChar()\n{\n\nsize_t len = strlen(Letter);\nfor(int i= 0;i&lt;len;i++)\n{\nLetter[i] = Letter[i] - 32;\n}\nreturn Letter;\n}\nvirtual ~MakeUpper()\n{\n      cout&lt;&lt; &quot;called ~MakeUpper()&quot;&lt;&lt;&quot;\\n&quot;;\ndelete Letter;\n}\nprivate:\nchar *Letter;\nbool toupper;\n};\n\n\nint _tmain(int argc, _TCHAR* argv[])\n{\n\nconvertch *makeupper = new MakeUpper(&quot;hai&quot;);\n\ncout&lt;&lt; &quot;Eneterd : hai = &quot; &lt;&lt;makeupper-&gt;convertChar()&lt;&lt;&quot; \\n&quot;;\n\ndelete makeupper;\nconvertch *makelower = new MakeLower(&quot;HAI&quot;);;\ncout&lt;&lt;&quot;Eneterd : HAI = &quot; &lt;&lt;makelower-&gt;convertChar()&lt;&lt;&quot;\\n &quot;;\n\n\ndelete makelower;\nreturn 0;\n}\n\n\nThe virtual destructor will call explicitly the most derived run time destructor of class so that it will be able to clear the object in a proper way.\n\nOr visit the link\n\nhttps://web.archive.org/web/20130822173509/http://www.programminggallery.com/article_details.php?article_id=138\n    ","url":"/questions/[slug]#solution13","@type":"Answer","upvoteCount":0},{"text":"I thought it would be beneficial to discuss the &quot;undefined&quot; behavior, or at least the &quot;crash&quot; undefined behavior that may occur when deleting through a base class(/struct) without a virtual destructor, or more precisely no vtable.  The code below list a few simple structs (the same would be true for classes).\n\n#include &lt;iostream&gt;\nusing namespace std;\n\nstruct a\n{\n    ~a() {}\n\n    unsigned long long i;\n};\n\nstruct b : a\n{\n    ~b() {}\n\n    unsigned long long j;\n};\n\nstruct c : b\n{\n    ~c() {}\n\n    virtual void m3() {}\n\n    unsigned long long k;\n};\n\nstruct d : c\n{\n    ~d() {}\n\n    virtual void m4() {}\n\n    unsigned long long l;\n};\n\nint main()\n{\n    cout &lt;&lt; &quot;sizeof(a): &quot; &lt;&lt; sizeof(a) &lt;&lt; endl;\n    cout &lt;&lt; &quot;sizeof(b): &quot; &lt;&lt; sizeof(b) &lt;&lt; endl;\n    cout &lt;&lt; &quot;sizeof(c): &quot; &lt;&lt; sizeof(c) &lt;&lt; endl;\n    cout &lt;&lt; &quot;sizeof(d): &quot; &lt;&lt; sizeof(d) &lt;&lt; endl;\n\n    // No issue.\n\n    a* a1 = new a();\n    cout &lt;&lt; &quot;a1: &quot; &lt;&lt; a1 &lt;&lt; endl;\n    delete a1;\n\n    // No issue.\n\n    b* b1 = new b();\n    cout &lt;&lt; &quot;b1: &quot; &lt;&lt; b1 &lt;&lt; endl;\n    cout &lt;&lt; &quot;(a*) b1: &quot; &lt;&lt; (a*) b1 &lt;&lt; endl;\n    delete b1;\n\n    // No issue.\n\n    c* c1 = new c();\n    cout &lt;&lt; &quot;c1: &quot; &lt;&lt; c1 &lt;&lt; endl;\n    cout &lt;&lt; &quot;(b*) c1: &quot; &lt;&lt; (b*) c1 &lt;&lt; endl;\n    cout &lt;&lt; &quot;(a*) c1: &quot; &lt;&lt; (a*) c1 &lt;&lt; endl;\n    delete c1;\n\n    // No issue.\n\n    d* d1 = new d();\n    cout &lt;&lt; &quot;d1: &quot; &lt;&lt; d1 &lt;&lt; endl;\n    cout &lt;&lt; &quot;(c*) d1: &quot; &lt;&lt; (c*) d1 &lt;&lt; endl;\n    cout &lt;&lt; &quot;(b*) d1: &quot; &lt;&lt; (b*) d1 &lt;&lt; endl;\n    cout &lt;&lt; &quot;(a*) d1: &quot; &lt;&lt; (a*) d1 &lt;&lt; endl;\n    delete d1;\n\n    // Doesn&apos;t crash, but may not produce the results you want.\n\n    c1 = (c*) new d();\n    delete c1;\n\n    // Crashes due to passing an invalid address to the method which\n    // frees the memory.\n\n    d1 = new d();\n    b1 = (b*) d1;\n    cout &lt;&lt; &quot;d1: &quot; &lt;&lt; d1 &lt;&lt; endl;\n    cout &lt;&lt; &quot;b1: &quot; &lt;&lt; b1 &lt;&lt; endl;\n    delete b1;  \n\n/*\n\n    // This is similar to what&apos;s happening above in the &quot;crash&quot; case.\n\n    char* buf = new char[32];\n    cout &lt;&lt; &quot;buf: &quot; &lt;&lt; (void*) buf &lt;&lt; endl;\n    buf += 8;\n    cout &lt;&lt; &quot;buf after adding 8: &quot; &lt;&lt; (void*) buf &lt;&lt; endl;\n    delete buf;\n*/\n}\n\n\nI&apos;m not suggesting whether you need virtual destructors or not, though I think in general it&apos;s a good practice to have them.  I&apos;m just pointing out the reason you may end up with a crash if your base class(/struct) does not have a vtable and your derived class(/struct) does and you delete an object via a base class(/struct) pointer.  In this case, the address you pass to the heap&apos;s free routine is invalid and thus the reason for the crash.\n\nIf you run the above code you&apos;ll see clearly when the issue occurs.  When the this pointer of the base class(/struct) is different from the this pointer of the derived class(/struct) you&apos;re going to run into this problem.  In the sample above, struct a and b don&apos;t have vtables.  structs c and d do have vtables.  Thus an a or b pointer to a c or d object instance will be fixed up to account for the vtable.  If you pass this a or b pointer to delete it will crash due to the address being invalid to the heap&apos;s free routine.\n\nIf you plan to delete derived instances which have vtables from base class pointers, you need to ensure the base class has a vtable.  One way to do that is to add a virtual destructor, which you might want anyway to properly clean up resources.\n    ","url":"/questions/[slug]#solution14","@type":"Answer","upvoteCount":0},{"text":"when you need to call derived class destructor from base class. you need to declare virtual base class destructor in base class.\n    ","url":"/questions/[slug]#solution15","@type":"Answer","upvoteCount":0},{"text":"I think most answers here miss the point, with the exception of the accepted one, which is a good thing. However, let me add one more with a different view on the issue: You need a virtual destructor if you want to polymorphically delete instances of this class.\nThis kind-of sidesteps the question, so let me elaborate: As many pointed out, you get undesired behaviour if you invoke delete base_ptr and the destructor is not virtual. However, there are several assumptions there that need to be make explicit:\n\nIf your class is not a baseclass, you will hopefully not write code like this. In this case I don&apos;t mean the manual memory management, which is bad in and of itself, but deriving publicly from this class. A class not designed as baseclass should not be inherited from, like e.g. std::string. C++ allows you to shoot yourself in the foot. This is your fault though, not that of the baseclass not having a virtual destructor.\nIf the destructor is not accessible (protected or private), this code won&apos;t compile, so the undesired behaviour can not occur. Having a protected destructor is useful, especially for mixins but also (to a lesser extent) for interfaces. You don&apos;t want to incur the overhead of virtual functions unless you actually make use of them. Making the destructor protected instead prevents undesired behaviour but doesn&apos;t restrict you otherwise.\nIf you actually write a class that is supposed to be derived from, you will typically have virtual functions anyways. As a user of them, you will typically only use them via a pointer to the baseclass. When this use includes disposing of them, it then needs to be polymorphic as well. This is then the case when you should make the destructor virtual.\n\nFor a similarly different view on the subject, also read When should you not use virtual destructors?\n    ","url":"/questions/[slug]#solution16","@type":"Answer","upvoteCount":0},{"text":"A basic definition about virtual is it determines if a member function of a class can be over-ridden in its derived classes. \n\nA class&apos;s D-tor is called basically at the end of the scope, but there is a problem, for example when we define an instance on the Heap (dynamic allocation), we should delete it manually.\n\nAs soon as the instruction get executed, the base class destructor get called, but not for the derived one.\n\nA Pratical example is when, in control field, you have to manipulate effectors, actuators.\n\nAt the end of the scope, if the destructor of one of the power elements (Actuator), isn&apos;t called, there will be fatal consequences.\n\n#include &lt;iostream&gt;\n\nclass Mother{\n\npublic:\n\n    Mother(){\n\n          std::cout&lt;&lt;&quot;Mother Ctor&quot;&lt;&lt;std::endl;\n    }\n\n    virtual~Mother(){\n\n        std::cout&lt;&lt;&quot;Mother D-tor&quot;&lt;&lt;std::endl;\n    }\n\n\n};\n\nclass Child: public Mother{\n\n    public:\n\n    Child(){\n\n        std::cout&lt;&lt;&quot;Child C-tor&quot;&lt;&lt;std::endl;\n    }\n\n    ~Child(){\n\n         std::cout&lt;&lt;&quot;Child D-tor&quot;&lt;&lt;std::endl;\n    }\n};\n\nint main()\n{\n\n    Mother *c = new Child();\n    delete c;\n\n    return 0;\n}\n\n    ","url":"/questions/[slug]#solution17","@type":"Answer","upvoteCount":0},{"text":"Make all destructors virtual unless you have good reason not to.\nOtherwise evil like this happens:\nSuppose you have an array of Fruit pointers with both Apple and Orange objects.\nWhen you delete from the collection of Fruit objects,\n~Apple() and ~Orange() fail to be called unless ~Fruit() is virtual.\nExample done right:\n#include &lt;iostream&gt;\nusing namespace std;\nstruct Fruit { // good\n  virtual ~Fruit() { cout &lt;&lt; &quot;peel or core should have been tossed&quot; &lt;&lt; endl; } \n};\nstruct Apple:  Fruit { virtual ~Apple()  {cout &lt;&lt; &quot;toss core&quot; &lt;&lt; endl; } };\nstruct Orange: Fruit { virtual ~Orange() {cout &lt;&lt; &quot;toss peel&quot; &lt;&lt; endl; } };\n\nint main() { \n  Fruit *basket[]={ new Apple(), new Orange() };\n  for (auto fruit: basket) delete fruit;\n};\n\ngood output\ntoss core\npeel or core should have been tossed\ntoss peel\npeel or core should have been tossed\n\nExample done wrong:\n#include &lt;iostream&gt;\nusing namespace std;\nstruct Fruit { // bad \n  ~Fruit() { cout &lt;&lt; &quot;peel or core should have been tossed&quot; &lt;&lt; endl; } \n};\nstruct Apple:  Fruit { virtual ~Apple()  {cout &lt;&lt; &quot;toss core&quot; &lt;&lt; endl; } };\nstruct Orange: Fruit { virtual ~Orange() {cout &lt;&lt; &quot;toss peel&quot; &lt;&lt; endl; } };\n\nint main() { \n  Fruit *basket[]={ new Apple(), new Orange() };\n  for (auto fruit: basket) delete fruit;\n};\n\n\nbad output\npeel or core should have been tossed\npeel or core should have been tossed\n\n(Note: Where I used struct for brevity, normally use class and specify public)\n    ","url":"/questions/[slug]#solution18","@type":"Answer","upvoteCount":0},{"text":"Any class that is inherited publicly, polymorphic or not, should have a virtual destructor. To put another way, if it can be pointed to by a base class pointer, its base class should have a virtual destructor.\nIf virtual, the derived class destructor gets called and then the base class destructor. If not virtual, only the base class destructor gets called.\n    ","url":"/questions/[slug]#solution19","@type":"Answer","upvoteCount":0}],"@type":"Question"}}</script><meta name="next-head-count" content="22"/><link rel="preload" href="/_next/static/css/c116652e2d6f4ad0.css" as="style"/><link rel="stylesheet" href="/_next/static/css/c116652e2d6f4ad0.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-0d1b80a048d4787e.js"></script><script src="/_next/static/chunks/webpack-42cdea76c8170223.js" defer=""></script><script src="/_next/static/chunks/framework-4556c45dd113b893.js" defer=""></script><script src="/_next/static/chunks/main-ccfab947c79712f4.js" defer=""></script><script src="/_next/static/chunks/pages/_app-43d1c35cd6eb9b8f.js" defer=""></script><script src="/_next/static/chunks/294-106ef8570fa99deb.js" defer=""></script><script src="/_next/static/chunks/490-7f0418bb4354ac73.js" defer=""></script><script src="/_next/static/chunks/pages/questions/%5Bslug%5D-50e201fdaa1e0fd1.js" defer=""></script><script src="/_next/static/00bsHgHZki2FteshOatnd/_buildManifest.js" defer=""></script><script src="/_next/static/00bsHgHZki2FteshOatnd/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="wrapper"><header><nav class="bg-white border-gray-200 px-4 lg:px-6 py-2.5 dark:bg-gray-800"><div class="flex flex-wrap justify-between items-center mx-auto max-w-screen-xl"><a class="flex items-center" href="/"><img src="/logo-second.png" class="mr-3 h-6 sm:h-9" alt="Solution Checker Logo"/><h1 class="self-center text-xl font-semibold whitespace-nowrap dark:text-white">Solution Checker</h1></a><div class="flex items-center lg:order-2"><button data-collapse-toggle="mobile-menu-2" type="button" class="inline-flex items-center p-2 ml-1 text-sm text-gray-500 rounded-lg lg:hidden hover:bg-gray-100 focus:outline-none focus:ring-2 focus:ring-gray-200 dark:text-gray-400 dark:hover:bg-gray-700 dark:focus:ring-gray-600" aria-controls="mobile-menu-2" aria-expanded="false"><span class="sr-only">Open main menu</span><svg class="w-6 h-6" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M3 5a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM3 10a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM3 15a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1z" clip-rule="evenodd"></path></svg><svg class="hidden w-6 h-6" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z" clip-rule="evenodd"></path></svg></button></div><div class="hidden justify-between items-center w-full lg:flex lg:w-auto lg:order-1" id="mobile-menu-2"><ul class="flex flex-col mt-4 font-medium lg:flex-row lg:space-x-8 lg:mt-0"><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" aria-current="page" href="/">Home</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/questions?tab=news">Questions</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/post?tab=news">Post</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/questions/when-to-use-virtual-destructors-1657388152135#">Coding</a></li></ul></div></div></nav></header><div class="main-content"><div class="question my-5"><div class="flex question-header items-center m-auto justify-center"><div class="rounded-xl w-full border p-5 shadow-md bg-white"><div class="flex w-full items-center justify-between border-b pb-3"><div class="flex items-center space-x-3"><div class="text-lg font-bold text-slate-700"><a href="/questions/when-to-use-virtual-destructors-1657388152135"><h1>When to use virtual destructors?</h1></a></div></div><div class="flex flex-wrap h-auto justify-end items-center space-x-8"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold" href="/questions/tag/virtual-destructor">virtual-destructor</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold" href="/questions/tag/shared-ptr">shared-ptr</a></div></div><div class="question-content mt-5">
                
<p>I have a solid understanding of most <code>OOP</code> theory but the one thing that confuses me a lot is virtual destructors.</p>
<p>I thought that the destructor always gets called no matter what and for every object in the chain.</p>
<p>When are you meant to make them virtual and why?</p>
    </div></div></div><div class="solution-section"><nav class="flex pagination-solution flex-col justify-end"><h1 class="text-lg font-semibold mb-5">Navigate to solutions: </h1><ul class="inline-flex -space-x-px overflow-auto"><li class="pagination-solution-item"><span data-id="#solution1" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">1</span></li><li class="pagination-solution-item"><span data-id="#solution2" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">2</span></li><li class="pagination-solution-item"><span data-id="#solution3" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">3</span></li><li class="pagination-solution-item"><span data-id="#solution4" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">4</span></li><li class="pagination-solution-item"><span data-id="#solution5" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">5</span></li><li class="pagination-solution-item"><span data-id="#solution6" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">6</span></li><li class="pagination-solution-item"><span data-id="#solution7" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">7</span></li><li class="pagination-solution-item"><span data-id="#solution8" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">8</span></li><li class="pagination-solution-item"><span data-id="#solution9" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">9</span></li><li class="pagination-solution-item"><span data-id="#solution10" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">10</span></li><li class="pagination-solution-item"><span data-id="#solution11" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">11</span></li><li class="pagination-solution-item"><span data-id="#solution12" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">12</span></li><li class="pagination-solution-item"><span data-id="#solution13" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">13</span></li><li class="pagination-solution-item"><span data-id="#solution14" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">14</span></li><li class="pagination-solution-item"><span data-id="#solution15" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">15</span></li><li class="pagination-solution-item"><span data-id="#solution16" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">16</span></li><li class="pagination-solution-item"><span data-id="#solution17" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">17</span></li><li class="pagination-solution-item"><span data-id="#solution18" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">18</span></li><li class="pagination-solution-item"><span data-id="#solution19" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">19</span></li></ul></nav><div id="solution1" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 1</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/virtual-destructor">virtual-destructor</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/shared-ptr">shared-ptr</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Virtual destructors are useful when you might potentially delete an instance of a derived class through a pointer to base class:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span> 
{
    <span class="hljs-comment">// some virtual methods</span>
};

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Derived</span> : <span class="hljs-keyword">public</span> Base
{
    ~<span class="hljs-built_in">Derived</span>()
    {
        <span class="hljs-comment">// Do some important cleanup</span>
    }
};
</code></pre>

<p>Here, you'll notice that I didn't declare Base's destructor to be <code>virtual</code>. Now, let's have a look at the following snippet:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp">Base *b = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Derived</span>();
<span class="hljs-comment">// use b</span>
<span class="hljs-keyword">delete</span> b; <span class="hljs-comment">// Here's the problem!</span>
</code></pre>

<p>Since Base's destructor is not <code>virtual</code> and <code>b</code> is a <code>Base*</code> pointing to a <code>Derived</code> object, <code>delete b</code> has <a href="https://stackoverflow.com/q/2397984/20984">undefined behaviour</a>:</p>

<blockquote>
  <p>[In <code>delete b</code>], if the static type of the
  object to be deleted is different from its dynamic type, the static
  type shall be a base class of the dynamic type of the object to be
  deleted and <strong>the static type shall have a virtual destructor or the
  behavior is undefined</strong>.</p>
</blockquote>

<p>In most implementations, the call to the destructor will be resolved like any non-virtual code, meaning that the destructor of the base class will be called but not the one of the derived class, resulting in a resources leak.</p>

<p>To sum up, always make base classes' destructors <code>virtual</code> when they're meant to be manipulated polymorphically.</p>

<p>If you want to prevent the deletion of an instance through a base class pointer, you can make the base class destructor protected and nonvirtual; by doing so, the compiler won't let you call <code>delete</code> on a base class pointer.</p>

<p>You can learn more about virtuality and virtual base class destructor in <a href="http://www.gotw.ca/publications/mill18.htm" rel="noreferrer">this article from Herb Sutter</a>.</p>
    </div></div></div></div><div id="solution2" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 2</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/virtual-destructor">virtual-destructor</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/shared-ptr">shared-ptr</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>A virtual constructor is not possible but virtual destructor is possible.
Let us experiment.......</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>

<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span>
{
<span class="hljs-keyword">public</span>:
    <span class="hljs-built_in">Base</span>(){
        cout &lt;&lt; <span class="hljs-string">"Base Constructor Called\n"</span>;
    }
    ~<span class="hljs-built_in">Base</span>(){
        cout &lt;&lt; <span class="hljs-string">"Base Destructor called\n"</span>;
    }
};

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Derived1</span>: <span class="hljs-keyword">public</span> Base
{
<span class="hljs-keyword">public</span>:
    <span class="hljs-built_in">Derived1</span>(){
        cout &lt;&lt; <span class="hljs-string">"Derived constructor called\n"</span>;
    }
    ~<span class="hljs-built_in">Derived1</span>(){
        cout &lt;&lt; <span class="hljs-string">"Derived destructor called\n"</span>;
    }
};

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    Base *b = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Derived1</span>();
    <span class="hljs-keyword">delete</span> b;
}
</code></pre>

<p>The above code output the following:</p>

<pre class="lang-none s-code-block"><code>Base Constructor Called
Derived constructor called
Base Destructor called
</code></pre>

<p>The construction of derived object follow the construction rule but when we delete the "b" pointer(base pointer) we have found that only the base destructor is called. But this must not happen. To do the appropriate thing, we have to make the base destructor virtual.
Now let see what happens in the following:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>

<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span>
{ 
<span class="hljs-keyword">public</span>:
    <span class="hljs-built_in">Base</span>(){
        cout &lt;&lt; <span class="hljs-string">"Base Constructor Called\n"</span>;
    }
    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Base</span>(){
        cout &lt;&lt; <span class="hljs-string">"Base Destructor called\n"</span>;
    }
};

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Derived1</span>: <span class="hljs-keyword">public</span> Base
{
<span class="hljs-keyword">public</span>:
    <span class="hljs-built_in">Derived1</span>(){
        cout &lt;&lt; <span class="hljs-string">"Derived constructor called\n"</span>;
    }
    ~<span class="hljs-built_in">Derived1</span>(){
        cout &lt;&lt; <span class="hljs-string">"Derived destructor called\n"</span>;
    }
};

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    Base *b = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Derived1</span>();
    <span class="hljs-keyword">delete</span> b;
}
</code></pre>

<p>The output changed as following:</p>

<pre class="lang-none s-code-block"><code>Base Constructor Called
Derived Constructor called
Derived destructor called
Base destructor called
</code></pre>

<p>So the destruction of the base pointer (which takes an allocation on derived object!) follows the destruction rule, i.e first the Derived, then the Base.
On the other hand, there is nothing like a virtual constructor.       </p>
    </div></div></div></div><div id="solution3" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 3</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/virtual-destructor">virtual-destructor</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/shared-ptr">shared-ptr</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Declare destructors virtual in polymorphic base classes.  This is Item 7 in Scott Meyers' <a href="https://rads.stackoverflow.com/amzn/click/com/0201924889" rel="noreferrer">Effective C++</a>.  Meyers goes on to summarize that if a class has <em>any</em> virtual function, it should have a virtual destructor, and that classes not designed to be base classes or not designed to be used polymorphically should <em>not</em> declare virtual destructors.</p>
    </div></div></div></div><div id="solution4" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 4</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/virtual-destructor">virtual-destructor</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/shared-ptr">shared-ptr</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Also be aware that deleting a base class pointer when there is no virtual destructor will result in <strong><em>undefined behavior</em></strong>.  Something that I learned just recently:</p>

<p><a href="https://stackoverflow.com/questions/408196/how-should-overriding-delete-in-c-behave">How should overriding delete in C++ behave?</a></p>

<p>I've been using C++ for years and I still manage to hang myself.</p>
    </div></div></div></div><div id="solution5" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 5</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/virtual-destructor">virtual-destructor</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/shared-ptr">shared-ptr</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Make the destructor virtual whenever your class is polymorphic.</p>
    </div></div></div></div><div id="solution6" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 6</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/virtual-destructor">virtual-destructor</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/shared-ptr">shared-ptr</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<h3>Calling destructor via a pointer to a base class</h3>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Base</span> {
  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span> </span>{}
  <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Base</span>() {}
};

<span class="hljs-keyword">struct</span> <span class="hljs-title class_">Derived</span> : Base {
  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> </span>{}
  ~<span class="hljs-built_in">Derived</span>() <span class="hljs-keyword">override</span> {}
};

Base* base = <span class="hljs-keyword">new</span> Derived;
base-&gt;<span class="hljs-built_in">f</span>(); <span class="hljs-comment">// calls Derived::f</span>
base-&gt;~<span class="hljs-built_in">Base</span>(); <span class="hljs-comment">// calls Derived::~Derived</span>
</code></pre>

<p>Virtual destructor call is no different from any other virtual function call.</p>

<p>For <code>base-&gt;f()</code>, the call will be dispatched to <code>Derived::f()</code>, and it's the same for <code>base-&gt;~Base()</code> - its overriding function - the <code>Derived::~Derived()</code> will be called.</p>

<p>Same happens when destructor is being called indirectly, e.g. <code>delete base;</code>. The <code>delete</code> statement will call <code>base-&gt;~Base()</code> which will be dispatched to <code>Derived::~Derived()</code>.</p>

<h3>Abstract class with non-virtual destructor</h3>

<p>If you are not going to delete object through a pointer to its base class - then there is no need to have a virtual destructor. Just make it <code>protected</code> so that it won't be called accidentally:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-comment">// library.hpp</span>

<span class="hljs-keyword">struct</span> <span class="hljs-title class_">Base</span> {
  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;

<span class="hljs-keyword">protected</span>:
  ~<span class="hljs-built_in">Base</span>() = <span class="hljs-keyword">default</span>;
};

<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">CallsF</span><span class="hljs-params">(Base&amp; base)</span></span>;
<span class="hljs-comment">// CallsF is not going to own "base" (i.e. call "delete &amp;base;").</span>
<span class="hljs-comment">// It will only call Base::f() so it doesn't need to access Base::~Base.</span>

<span class="hljs-comment">//-------------------</span>
<span class="hljs-comment">// application.cpp</span>

<span class="hljs-keyword">struct</span> <span class="hljs-title class_">Derived</span> : Base {
  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> </span>{ ... }
};

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
  Derived derived;
  <span class="hljs-built_in">CallsF</span>(derived);
  <span class="hljs-comment">// No need for virtual destructor here as well.</span>
}
</code></pre>
    </div></div></div></div><div id="solution7" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 7</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/virtual-destructor">virtual-destructor</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/shared-ptr">shared-ptr</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>To be simple,
Virtual destructor is to destruct the resources in a proper order, when you delete a base class pointer pointing to derived class object.</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"> <span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span>
 <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;
 <span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span>{
    <span class="hljs-keyword">public</span>:
       <span class="hljs-built_in">B</span>(){
          cout&lt;&lt;<span class="hljs-string">"B()\n"</span>;
       }
       <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">B</span>(){ 
          cout&lt;&lt;<span class="hljs-string">"~B()\n"</span>;
       }
 };
 <span class="hljs-keyword">class</span> <span class="hljs-title class_">D</span>: <span class="hljs-keyword">public</span> B{
    <span class="hljs-keyword">public</span>:
       <span class="hljs-built_in">D</span>(){
          cout&lt;&lt;<span class="hljs-string">"D()\n"</span>;
       }
       ~<span class="hljs-built_in">D</span>(){
          cout&lt;&lt;<span class="hljs-string">"~D()\n"</span>;
       }
 };
 <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>{
    B *b = <span class="hljs-keyword">new</span> <span class="hljs-built_in">D</span>();
    <span class="hljs-keyword">delete</span> b;
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
 }

OUTPUT:
<span class="hljs-built_in">B</span>()
<span class="hljs-built_in">D</span>()
~<span class="hljs-built_in">D</span>()
~<span class="hljs-built_in">B</span>()

==============
If you don<span class="hljs-number">'</span>t give ~<span class="hljs-built_in">B</span>()  as <span class="hljs-keyword">virtual</span>. then output would be 
<span class="hljs-built_in">B</span>()
<span class="hljs-built_in">D</span>()
~<span class="hljs-built_in">B</span>()
where destruction of ~<span class="hljs-built_in">D</span>() is <span class="hljs-keyword">not</span> done which leads to leak
</code></pre>

<hr>
    </div></div></div></div><div id="solution8" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 8</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/virtual-destructor">virtual-destructor</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/shared-ptr">shared-ptr</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Virtual keyword for destructor is necessary when you want different destructors should follow proper order while objects is being deleted through base class pointer. 
for example:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp">Base *myObj = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Derived</span>();
<span class="hljs-comment">// Some code which is using myObj object</span>
myObj-&gt;<span class="hljs-built_in">fun</span>();
<span class="hljs-comment">//Now delete the object</span>
<span class="hljs-keyword">delete</span> myObj ; 
</code></pre>

<p>If your base class destructor is virtual then objects will be destructed in a order(firstly derived object then base ). If your base class destructor is NOT virtual then only base class object will get deleted(because pointer is of base class "Base *myObj"). So there will be memory leak for derived object.</p>
    </div></div></div></div><div id="solution9" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 9</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/virtual-destructor">virtual-destructor</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/shared-ptr">shared-ptr</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>I like to think about interfaces and implementations of interfaces. In C++ speak interface is pure virtual class. Destructor is part of the interface and expected to implemented. Therefore destructor should be pure virtual. How about constructor? Constructor is actually not part of the interface because object is always instantiated explicitly. </p>
    </div></div></div></div><div id="solution10" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 10</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/virtual-destructor">virtual-destructor</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/shared-ptr">shared-ptr</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Virtual base class destructors are "best practice" - you should always use them to avoid (hard to detect) memory leaks. Using them, you can be sure all destructors in the inheritance chain of your classes are beeing called (in proper order). Inheriting from a base class using virtual destructor makes the destructor of the inheriting class automatically virtual, too (so you do not have to retype 'virtual' in the inheriting class destructor declaration).</p>
    </div></div></div></div><div id="solution11" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 11</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/virtual-destructor">virtual-destructor</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/shared-ptr">shared-ptr</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>I think the core of this question is about virtual methods and polymorphism, not the destructor specifically. Here is a clearer example:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>
{
<span class="hljs-keyword">public</span>:
    <span class="hljs-built_in">A</span>() {}
    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span>
    </span>{
        cout &lt;&lt; <span class="hljs-string">"This is A."</span> &lt;&lt; endl;
    }
};

<span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> : <span class="hljs-keyword">public</span> A
{
<span class="hljs-keyword">public</span>:
    <span class="hljs-built_in">B</span>() {}
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span>
    </span>{
        cout &lt;&lt; <span class="hljs-string">"This is B."</span> &lt;&lt; endl;
    }
};

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>* argv[])</span>
</span>{
    A *a = <span class="hljs-keyword">new</span> <span class="hljs-built_in">B</span>();
    a-&gt;<span class="hljs-built_in">foo</span>();
    <span class="hljs-keyword">if</span>(a != <span class="hljs-literal">NULL</span>)
    <span class="hljs-keyword">delete</span> a;
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>

<p>Will print out:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp">This is B.
</code></pre>

<p>Without <code>virtual</code> it will print out:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp">This is A.
</code></pre>

<p>And now you should understand when to use virtual destructors.</p>
    </div></div></div></div><div id="solution12" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 12</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/virtual-destructor">virtual-destructor</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/shared-ptr">shared-ptr</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>If you use <code>shared_ptr</code>(only shared_ptr, not unique_ptr), you don't have to have the base class destructor virtual:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span>

<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span>
{
<span class="hljs-keyword">public</span>:
    <span class="hljs-built_in">Base</span>(){
        cout &lt;&lt; <span class="hljs-string">"Base Constructor Called\n"</span>;
    }
    ~<span class="hljs-built_in">Base</span>(){ <span class="hljs-comment">// not virtual</span>
        cout &lt;&lt; <span class="hljs-string">"Base Destructor called\n"</span>;
    }
};

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Derived</span>: <span class="hljs-keyword">public</span> Base
{
<span class="hljs-keyword">public</span>:
    <span class="hljs-built_in">Derived</span>(){
        cout &lt;&lt; <span class="hljs-string">"Derived constructor called\n"</span>;
    }
    ~<span class="hljs-built_in">Derived</span>(){
        cout &lt;&lt; <span class="hljs-string">"Derived destructor called\n"</span>;
    }
};

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-function">shared_ptr&lt;Base&gt; <span class="hljs-title">b</span><span class="hljs-params">(<span class="hljs-keyword">new</span> Derived())</span></span>;
}
</code></pre>

<p>output:</p>

<pre class="lang-none s-code-block"><code>Base Constructor Called
Derived constructor called
Derived destructor called
Base Destructor called
</code></pre>
    </div></div></div></div><div id="solution13" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 13</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/virtual-destructor">virtual-destructor</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/shared-ptr">shared-ptr</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>What is a virtual destructor or how to use virtual destructor</p>

<p>A class destructor is a function with same name of the class preceding with ~ that will reallocate the memory that is allocated by the class. Why we need a virtual destructor</p>

<p>See  the  following  sample with some virtual functions</p>

<p>The sample also tell how you can convert a letter to upper or lower</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"stdafx.h"</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;
<span class="hljs-comment">// program to convert the lower to upper orlower</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">convertch</span>
{
<span class="hljs-keyword">public</span>:
  <span class="hljs-comment">//void convertch(){};</span>
  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">char</span>* <span class="hljs-title">convertChar</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;
  ~<span class="hljs-built_in">convertch</span>(){};
};

<span class="hljs-keyword">class</span> <span class="hljs-title class_">MakeLower</span> :<span class="hljs-keyword">public</span> convertch
{
<span class="hljs-keyword">public</span>:
  <span class="hljs-built_in">MakeLower</span>(<span class="hljs-type">char</span> *passLetter)
  {
    tolower = <span class="hljs-literal">true</span>;
    Letter = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[<span class="hljs-number">30</span>];
    <span class="hljs-built_in">strcpy</span>(Letter, passLetter);
  }

  <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">MakeLower</span>()
  {
    cout&lt;&lt; <span class="hljs-string">"called ~MakeLower()"</span>&lt;&lt;<span class="hljs-string">"\n"</span>;
    <span class="hljs-keyword">delete</span>[] Letter;
  }

  <span class="hljs-function"><span class="hljs-type">char</span>* <span class="hljs-title">convertChar</span><span class="hljs-params">()</span>
  </span>{
    <span class="hljs-type">size_t</span> len = <span class="hljs-built_in">strlen</span>(Letter);
    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i= <span class="hljs-number">0</span>;i&lt;len;i++)
      Letter[i] = Letter[i] + <span class="hljs-number">32</span>;
    <span class="hljs-keyword">return</span> Letter;
  }

<span class="hljs-keyword">private</span>:
  <span class="hljs-type">char</span> *Letter;
  <span class="hljs-type">bool</span> tolower;
};

<span class="hljs-keyword">class</span> <span class="hljs-title class_">MakeUpper</span> : <span class="hljs-keyword">public</span> convertch
{
<span class="hljs-keyword">public</span>:
  <span class="hljs-built_in">MakeUpper</span>(<span class="hljs-type">char</span> *passLetter)
  {
    Letter = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[<span class="hljs-number">30</span>];
    toupper = <span class="hljs-literal">true</span>;
    <span class="hljs-built_in">strcpy</span>(Letter, passLetter);
  }

  <span class="hljs-function"><span class="hljs-type">char</span>* <span class="hljs-title">convertChar</span><span class="hljs-params">()</span>
  </span>{   
    <span class="hljs-type">size_t</span> len = <span class="hljs-built_in">strlen</span>(Letter);
    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i= <span class="hljs-number">0</span>;i&lt;len;i++)
      Letter[i] = Letter[i] - <span class="hljs-number">32</span>;
    <span class="hljs-keyword">return</span> Letter;
  }

  <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">MakeUpper</span>()
  {
    cout&lt;&lt; <span class="hljs-string">"called ~MakeUpper()"</span>&lt;&lt;<span class="hljs-string">"\n"</span>;
    <span class="hljs-keyword">delete</span> Letter;
  }

<span class="hljs-keyword">private</span>:
  <span class="hljs-type">char</span> *Letter;
  <span class="hljs-type">bool</span> toupper;
};


<span class="hljs-type">int</span> _tmain(<span class="hljs-type">int</span> argc, _TCHAR* argv[])
{
  convertch *makeupper = <span class="hljs-keyword">new</span> <span class="hljs-built_in">MakeUpper</span>(<span class="hljs-string">"hai"</span>); 
  cout&lt;&lt; <span class="hljs-string">"Eneterd : hai = "</span> &lt;&lt;makeupper-&gt;<span class="hljs-built_in">convertChar</span>()&lt;&lt;<span class="hljs-string">" "</span>;     
  <span class="hljs-keyword">delete</span> makeupper;
  convertch *makelower = <span class="hljs-keyword">new</span> <span class="hljs-built_in">MakeLower</span>(<span class="hljs-string">"HAI"</span>);;
  cout&lt;&lt;<span class="hljs-string">"Eneterd : HAI = "</span> &lt;&lt;makelower-&gt;<span class="hljs-built_in">convertChar</span>()&lt;&lt;<span class="hljs-string">" "</span>; 
  <span class="hljs-keyword">delete</span> makelower;
  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>

<p>From the above sample you can see that the destructor for both MakeUpper and MakeLower class is not called.</p>

<p>See the next sample with the virtual destructor</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"stdafx.h"</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span>

<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;
<span class="hljs-comment">// program to convert the lower to upper orlower</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">convertch</span>
{
<span class="hljs-keyword">public</span>:
<span class="hljs-comment">//void convertch(){};</span>
<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">char</span>* <span class="hljs-title">convertChar</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;
<span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">convertch</span>(){}; <span class="hljs-comment">// defined the virtual destructor</span>

};
<span class="hljs-keyword">class</span> <span class="hljs-title class_">MakeLower</span> :<span class="hljs-keyword">public</span> convertch
{
<span class="hljs-keyword">public</span>:
<span class="hljs-built_in">MakeLower</span>(<span class="hljs-type">char</span> *passLetter)
{
tolower = <span class="hljs-literal">true</span>;
Letter = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[<span class="hljs-number">30</span>];
<span class="hljs-built_in">strcpy</span>(Letter, passLetter);
}
<span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">MakeLower</span>()
{
cout&lt;&lt; <span class="hljs-string">"called ~MakeLower()"</span>&lt;&lt;<span class="hljs-string">"\n"</span>;
      <span class="hljs-keyword">delete</span>[] Letter;
}
<span class="hljs-function"><span class="hljs-type">char</span>* <span class="hljs-title">convertChar</span><span class="hljs-params">()</span>
</span>{
<span class="hljs-type">size_t</span> len = <span class="hljs-built_in">strlen</span>(Letter);
<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i= <span class="hljs-number">0</span>;i&lt;len;i++)
{
Letter[i] = Letter[i] + <span class="hljs-number">32</span>;

}

<span class="hljs-keyword">return</span> Letter;
}

<span class="hljs-keyword">private</span>:
<span class="hljs-type">char</span> *Letter;
<span class="hljs-type">bool</span> tolower;

};
<span class="hljs-keyword">class</span> <span class="hljs-title class_">MakeUpper</span> : <span class="hljs-keyword">public</span> convertch
{
<span class="hljs-keyword">public</span>:
<span class="hljs-built_in">MakeUpper</span>(<span class="hljs-type">char</span> *passLetter)
{
Letter = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[<span class="hljs-number">30</span>];
toupper = <span class="hljs-literal">true</span>;
<span class="hljs-built_in">strcpy</span>(Letter, passLetter);
}
<span class="hljs-function"><span class="hljs-type">char</span>* <span class="hljs-title">convertChar</span><span class="hljs-params">()</span>
</span>{

<span class="hljs-type">size_t</span> len = <span class="hljs-built_in">strlen</span>(Letter);
<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i= <span class="hljs-number">0</span>;i&lt;len;i++)
{
Letter[i] = Letter[i] - <span class="hljs-number">32</span>;
}
<span class="hljs-keyword">return</span> Letter;
}
<span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">MakeUpper</span>()
{
      cout&lt;&lt; <span class="hljs-string">"called ~MakeUpper()"</span>&lt;&lt;<span class="hljs-string">"\n"</span>;
<span class="hljs-keyword">delete</span> Letter;
}
<span class="hljs-keyword">private</span>:
<span class="hljs-type">char</span> *Letter;
<span class="hljs-type">bool</span> toupper;
};


<span class="hljs-type">int</span> _tmain(<span class="hljs-type">int</span> argc, _TCHAR* argv[])
{

convertch *makeupper = <span class="hljs-keyword">new</span> <span class="hljs-built_in">MakeUpper</span>(<span class="hljs-string">"hai"</span>);

cout&lt;&lt; <span class="hljs-string">"Eneterd : hai = "</span> &lt;&lt;makeupper-&gt;<span class="hljs-built_in">convertChar</span>()&lt;&lt;<span class="hljs-string">" \n"</span>;

<span class="hljs-keyword">delete</span> makeupper;
convertch *makelower = <span class="hljs-keyword">new</span> <span class="hljs-built_in">MakeLower</span>(<span class="hljs-string">"HAI"</span>);;
cout&lt;&lt;<span class="hljs-string">"Eneterd : HAI = "</span> &lt;&lt;makelower-&gt;<span class="hljs-built_in">convertChar</span>()&lt;&lt;<span class="hljs-string">"\n "</span>;


<span class="hljs-keyword">delete</span> makelower;
<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>

<p>The virtual destructor will call explicitly the most derived run time destructor of class so that it will be able to clear the object in a proper way.</p>

<p>Or visit the link</p>

<p><a href="https://web.archive.org/web/20130822173509/http://www.programminggallery.com/article_details.php?article_id=138" rel="nofollow">https://web.archive.org/web/20130822173509/http://www.programminggallery.com/article_details.php?article_id=138</a></p>
    </div></div></div></div><div id="solution14" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 14</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/virtual-destructor">virtual-destructor</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/shared-ptr">shared-ptr</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>I thought it would be beneficial to discuss the "undefined" behavior, or at least the "crash" undefined behavior that may occur when deleting through a base class(/struct) without a virtual destructor, or more precisely no vtable.  The code below list a few simple structs (the same would be true for classes).</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;

<span class="hljs-keyword">struct</span> <span class="hljs-title class_">a</span>
{
    ~<span class="hljs-built_in">a</span>() {}

    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> i;
};

<span class="hljs-keyword">struct</span> <span class="hljs-title class_">b</span> : a
{
    ~<span class="hljs-built_in">b</span>() {}

    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> j;
};

<span class="hljs-keyword">struct</span> <span class="hljs-title class_">c</span> : b
{
    ~<span class="hljs-built_in">c</span>() {}

    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">m3</span><span class="hljs-params">()</span> </span>{}

    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> k;
};

<span class="hljs-keyword">struct</span> <span class="hljs-title class_">d</span> : c
{
    ~<span class="hljs-built_in">d</span>() {}

    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">m4</span><span class="hljs-params">()</span> </span>{}

    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> l;
};

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    cout &lt;&lt; <span class="hljs-string">"sizeof(a): "</span> &lt;&lt; <span class="hljs-built_in">sizeof</span>(a) &lt;&lt; endl;
    cout &lt;&lt; <span class="hljs-string">"sizeof(b): "</span> &lt;&lt; <span class="hljs-built_in">sizeof</span>(b) &lt;&lt; endl;
    cout &lt;&lt; <span class="hljs-string">"sizeof(c): "</span> &lt;&lt; <span class="hljs-built_in">sizeof</span>(c) &lt;&lt; endl;
    cout &lt;&lt; <span class="hljs-string">"sizeof(d): "</span> &lt;&lt; <span class="hljs-built_in">sizeof</span>(d) &lt;&lt; endl;

    <span class="hljs-comment">// No issue.</span>

    a* a1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">a</span>();
    cout &lt;&lt; <span class="hljs-string">"a1: "</span> &lt;&lt; a1 &lt;&lt; endl;
    <span class="hljs-keyword">delete</span> a1;

    <span class="hljs-comment">// No issue.</span>

    b* b1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">b</span>();
    cout &lt;&lt; <span class="hljs-string">"b1: "</span> &lt;&lt; b1 &lt;&lt; endl;
    cout &lt;&lt; <span class="hljs-string">"(a*) b1: "</span> &lt;&lt; (a*) b1 &lt;&lt; endl;
    <span class="hljs-keyword">delete</span> b1;

    <span class="hljs-comment">// No issue.</span>

    c* c1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">c</span>();
    cout &lt;&lt; <span class="hljs-string">"c1: "</span> &lt;&lt; c1 &lt;&lt; endl;
    cout &lt;&lt; <span class="hljs-string">"(b*) c1: "</span> &lt;&lt; (b*) c1 &lt;&lt; endl;
    cout &lt;&lt; <span class="hljs-string">"(a*) c1: "</span> &lt;&lt; (a*) c1 &lt;&lt; endl;
    <span class="hljs-keyword">delete</span> c1;

    <span class="hljs-comment">// No issue.</span>

    d* d1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">d</span>();
    cout &lt;&lt; <span class="hljs-string">"d1: "</span> &lt;&lt; d1 &lt;&lt; endl;
    cout &lt;&lt; <span class="hljs-string">"(c*) d1: "</span> &lt;&lt; (c*) d1 &lt;&lt; endl;
    cout &lt;&lt; <span class="hljs-string">"(b*) d1: "</span> &lt;&lt; (b*) d1 &lt;&lt; endl;
    cout &lt;&lt; <span class="hljs-string">"(a*) d1: "</span> &lt;&lt; (a*) d1 &lt;&lt; endl;
    <span class="hljs-keyword">delete</span> d1;

    <span class="hljs-comment">// Doesn't crash, but may not produce the results you want.</span>

    c1 = (c*) <span class="hljs-keyword">new</span> <span class="hljs-built_in">d</span>();
    <span class="hljs-keyword">delete</span> c1;

    <span class="hljs-comment">// Crashes due to passing an invalid address to the method which</span>
    <span class="hljs-comment">// frees the memory.</span>

    d1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">d</span>();
    b1 = (b*) d1;
    cout &lt;&lt; <span class="hljs-string">"d1: "</span> &lt;&lt; d1 &lt;&lt; endl;
    cout &lt;&lt; <span class="hljs-string">"b1: "</span> &lt;&lt; b1 &lt;&lt; endl;
    <span class="hljs-keyword">delete</span> b1;  

<span class="hljs-comment">/*

    // This is similar to what's happening above in the "crash" case.

    char* buf = new char[32];
    cout &lt;&lt; "buf: " &lt;&lt; (void*) buf &lt;&lt; endl;
    buf += 8;
    cout &lt;&lt; "buf after adding 8: " &lt;&lt; (void*) buf &lt;&lt; endl;
    delete buf;
*/</span>
}
</code></pre>

<p>I'm not suggesting whether you need virtual destructors or not, though I think in general it's a good practice to have them.  I'm just pointing out the reason you may end up with a crash if your base class(/struct) does not have a vtable and your derived class(/struct) does and you delete an object via a base class(/struct) pointer.  In this case, the address you pass to the heap's free routine is invalid and thus the reason for the crash.</p>

<p>If you run the above code you'll see clearly when the issue occurs.  When the this pointer of the base class(/struct) is different from the this pointer of the derived class(/struct) you're going to run into this problem.  In the sample above, struct a and b don't have vtables.  structs c and d do have vtables.  Thus an a or b pointer to a c or d object instance will be fixed up to account for the vtable.  If you pass this a or b pointer to delete it will crash due to the address being invalid to the heap's free routine.</p>

<p>If you plan to delete derived instances which have vtables from base class pointers, you need to ensure the base class has a vtable.  One way to do that is to add a virtual destructor, which you might want anyway to properly clean up resources.</p>
    </div></div></div></div><div id="solution15" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 15</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/virtual-destructor">virtual-destructor</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/shared-ptr">shared-ptr</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>when you need to call derived class destructor from base class. you need to declare virtual base class destructor in base class.</p>
    </div></div></div></div><div id="solution16" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 16</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/virtual-destructor">virtual-destructor</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/shared-ptr">shared-ptr</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>I think most answers here miss the point, with the exception of the accepted one, which is a good thing. However, let me add one more with a different view on the issue: You need a virtual destructor if you want to polymorphically delete instances of this class.</p>
<p>This kind-of sidesteps the question, so let me elaborate: As many pointed out, you get undesired behaviour if you invoke <code>delete base_ptr</code> and the destructor is not virtual. However, there are several assumptions there that need to be make explicit:</p>
<ul>
<li>If your class is not a baseclass, you will hopefully not write code like this. In this case I don't mean the manual memory management, which is bad in and of itself, but deriving publicly from this class. A class not designed as baseclass should not be inherited from, like e.g. <code>std::string</code>. C++ allows you to shoot yourself in the foot. This is your fault though, not that of the baseclass not having a virtual destructor.</li>
<li>If the destructor is not accessible (protected or private), this code won't compile, so the undesired behaviour can not occur. Having a protected destructor is useful, especially for mixins but also (to a lesser extent) for interfaces. You don't want to incur the overhead of virtual functions unless you actually make use of them. Making the destructor protected instead prevents undesired behaviour but doesn't restrict you otherwise.</li>
<li>If you actually write a class that is supposed to be derived from, you will typically have virtual functions anyways. As a user of them, you will typically only use them via a pointer to the baseclass. When this use includes disposing of them, it then needs to be polymorphic as well. This is then the case when you should make the destructor virtual.</li>
</ul>
<p>For a similarly different view on the subject, also read <a href="https://stackoverflow.com/questions/300986/when-should-you-not-use-virtual-destructors">When should you not use virtual destructors?</a></p>
    </div></div></div></div><div id="solution17" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 17</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/virtual-destructor">virtual-destructor</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/shared-ptr">shared-ptr</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>A basic definition about <code>virtual</code> is it determines if a member function of a class can be over-ridden in its derived classes. </p>

<p>A class's D-tor is called basically at the end of the scope, but there is a problem, for example when we define an instance on the Heap (dynamic allocation), we should delete it manually.</p>

<p>As soon as the instruction get executed, the base class destructor get called, but not for the derived one.</p>

<p>A Pratical example is when, in control field, you have to manipulate effectors, actuators.</p>

<p>At the end of the scope, if the destructor of one of the power elements (Actuator), isn't called, there will be fatal consequences.</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Mother</span>{

<span class="hljs-keyword">public</span>:

    <span class="hljs-built_in">Mother</span>(){

          std::cout&lt;&lt;<span class="hljs-string">"Mother Ctor"</span>&lt;&lt;std::endl;
    }

    <span class="hljs-keyword">virtual</span>~<span class="hljs-built_in">Mother</span>(){

        std::cout&lt;&lt;<span class="hljs-string">"Mother D-tor"</span>&lt;&lt;std::endl;
    }


};

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Child</span>: <span class="hljs-keyword">public</span> Mother{

    <span class="hljs-keyword">public</span>:

    <span class="hljs-built_in">Child</span>(){

        std::cout&lt;&lt;<span class="hljs-string">"Child C-tor"</span>&lt;&lt;std::endl;
    }

    ~<span class="hljs-built_in">Child</span>(){

         std::cout&lt;&lt;<span class="hljs-string">"Child D-tor"</span>&lt;&lt;std::endl;
    }
};

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{

    Mother *c = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Child</span>();
    <span class="hljs-keyword">delete</span> c;

    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>
    </div></div></div></div><div id="solution18" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 18</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/virtual-destructor">virtual-destructor</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/shared-ptr">shared-ptr</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Make all destructors virtual unless you have good reason not to.</p>
<p>Otherwise evil like this happens:</p>
<p>Suppose you have an array of Fruit pointers with both Apple and Orange objects.</p>
<p>When you delete from the collection of Fruit objects,
~Apple() and ~Orange() fail to be called unless ~Fruit() is virtual.</p>
<p>Example done right:</p>
<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">Fruit</span> { <span class="hljs-comment">// good</span>
  <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Fruit</span>() { cout &lt;&lt; <span class="hljs-string">"peel or core should have been tossed"</span> &lt;&lt; endl; } 
};
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">Apple</span>:  Fruit { <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Apple</span>()  {cout &lt;&lt; <span class="hljs-string">"toss core"</span> &lt;&lt; endl; } };
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">Orange</span>: Fruit { <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Orange</span>() {cout &lt;&lt; <span class="hljs-string">"toss peel"</span> &lt;&lt; endl; } };

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{ 
  Fruit *basket[]={ <span class="hljs-keyword">new</span> <span class="hljs-built_in">Apple</span>(), <span class="hljs-keyword">new</span> <span class="hljs-built_in">Orange</span>() };
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> fruit: basket) <span class="hljs-keyword">delete</span> fruit;
};
</code></pre>
<p>good output</p>
<pre class="lang-cpp s-code-block"><code class="hljs language-cpp">toss core
peel <span class="hljs-keyword">or</span> core should have been tossed
toss peel
peel <span class="hljs-keyword">or</span> core should have been tossed
</code></pre>
<p>Example done wrong:</p>
<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">Fruit</span> { <span class="hljs-comment">// bad </span>
  ~<span class="hljs-built_in">Fruit</span>() { cout &lt;&lt; <span class="hljs-string">"peel or core should have been tossed"</span> &lt;&lt; endl; } 
};
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">Apple</span>:  Fruit { <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Apple</span>()  {cout &lt;&lt; <span class="hljs-string">"toss core"</span> &lt;&lt; endl; } };
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">Orange</span>: Fruit { <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Orange</span>() {cout &lt;&lt; <span class="hljs-string">"toss peel"</span> &lt;&lt; endl; } };

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{ 
  Fruit *basket[]={ <span class="hljs-keyword">new</span> <span class="hljs-built_in">Apple</span>(), <span class="hljs-keyword">new</span> <span class="hljs-built_in">Orange</span>() };
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> fruit: basket) <span class="hljs-keyword">delete</span> fruit;
};

</code></pre>
<p>bad output</p>
<pre class="lang-cpp s-code-block"><code class="hljs language-cpp">peel <span class="hljs-keyword">or</span> core should have been tossed
peel <span class="hljs-keyword">or</span> core should have been tossed
</code></pre>
<p>(Note: Where I used struct for brevity, normally use class and specify public)</p>
    </div></div></div></div><div id="solution19" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 19</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/virtual-destructor">virtual-destructor</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/shared-ptr">shared-ptr</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Any class that is inherited publicly, polymorphic or not, should have a virtual destructor. To put another way, if it can be pointed to by a base class pointer, its base class should have a virtual destructor.</p>
<p>If virtual, the derived class destructor gets called and then the base class destructor. If not virtual, only the base class destructor gets called.</p>
    </div></div></div></div></div></div><div class="widget"><a href="/questions/strange-result-when-removing-item-from-a-list-while-iterating-over-it-duplicate-1657387735759">Strange result when removing item from a list while iterating over it [duplicate]</a><a href="/questions/transpose-reshape-dataframe-without-%22timevar%22-from-long-to-wide-format-1657388213347">Transpose / reshape dataframe without &quot;timevar&quot; from long to wide format</a><a href="/questions/what-is-javascript&#x27;s-highest-integer-value-that-a-number-can-go-to-without-losing-precision-1657387622983">What is JavaScript&#x27;s highest integer value that a number can go to without losing precision?</a><a href="/questions/mysql-pivot-row-into-dynamic-number-of-columns-1657387981930">MySQL pivot row into dynamic number of columns</a><a href="/questions/how-do-you-use-a-variable-in-a-regular-expression-1657387939007">How do you use a variable in a regular expression?</a><a href="/questions/numbering-rows-within-groups-in-a-data-frame-1657388556436">Numbering rows within groups in a data frame</a><a href="/questions/are-&#x27;arrow-functions&#x27;-and-&#x27;functions&#x27;-equivalent-interchangeable-1657384527873">Are &#x27;Arrow Functions&#x27; and &#x27;Functions&#x27; equivalent / interchangeable?</a><a href="/questions/reference-what-does-this-symbol-mean-in-php-1657384561666">Reference  What does this symbol mean in PHP?</a><a href="/questions/int-division:-why-is-the-result-of-13-0-1657387547814">Int division: Why is the result of 1/3 == 0?</a><a href="/questions/how-to-manage-startactivityforresult-on-android-1657387967393">How to manage startActivityForResult on Android</a><a href="/questions/how-do-i-pandas-group-by-to-get-sum-1657387908708">How do I Pandas group-by to get sum?</a><a href="/questions/what-is-the-%22n+1-selects-problem%22-in-orm-(object-relational-mapping)-1657388055597">What is the &quot;N+1 selects problem&quot; in ORM (Object-Relational Mapping)?</a><a href="/questions/passing-data-between-view-controllers-1657384540021">Passing data between view controllers</a><a href="/questions/how-to-add-jtable-in-jpanel-with-null-layout-1657384590912">How to add JTable in JPanel with null layout?</a><a href="/questions/efficiently-convert-rows-to-columns-in-sql-server-1657387919213">Efficiently convert rows to columns in sql server</a><a href="/questions/how-to-read-a-file-line-by-line-into-a-list-1657387865894">How to read a file line-by-line into a list?</a><a href="/questions/how-can-i-get-useful-error-messages-in-php-1657384609065">How can I get useful error messages in PHP?</a><a href="/questions/why-are-these-constructs-using-pre-and-post-increment-undefined-behavior-1657384520109">Why are these constructs using pre and post-increment undefined behavior?</a><a href="/questions/how-to-fix-%22headers-already-sent%22-error-in-php-1657384315553">How to fix &quot;Headers already sent&quot; error in PHP</a><a href="/questions/get-the-cartesian-product-of-a-series-of-lists-1657387709890">Get the cartesian product of a series of lists?</a></div></div><span class="cursor-pointer text-lg p-2" style="position:fixed;bottom:20px;left:20px;background:#000;z-index:2000;color:white">Go go top</span></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"data":{"answer":["\n\u0026lt;p\u0026gt;Virtual destructors are useful when you might potentially delete an instance of a derived class through a pointer to base class:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Base\u0026lt;/span\u0026gt; \n{\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// some virtual methods\u0026lt;/span\u0026gt;\n};\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Derived\u0026lt;/span\u0026gt; : \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; Base\n{\n    ~\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;Derived\u0026lt;/span\u0026gt;()\n    {\n        \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Do some important cleanup\u0026lt;/span\u0026gt;\n    }\n};\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Here, you\u0026apos;ll notice that I didn\u0026apos;t declare Base\u0026apos;s destructor to be \u0026lt;code\u0026gt;virtual\u0026lt;/code\u0026gt;. Now, let\u0026apos;s have a look at the following snippet:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;Base *b = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;Derived\u0026lt;/span\u0026gt;();\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// use b\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;delete\u0026lt;/span\u0026gt; b; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Here\u0026apos;s the problem!\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Since Base\u0026apos;s destructor is not \u0026lt;code\u0026gt;virtual\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;b\u0026lt;/code\u0026gt; is a \u0026lt;code\u0026gt;Base*\u0026lt;/code\u0026gt; pointing to a \u0026lt;code\u0026gt;Derived\u0026lt;/code\u0026gt; object, \u0026lt;code\u0026gt;delete b\u0026lt;/code\u0026gt; has \u0026lt;a href=\u0026quot;https://stackoverflow.com/q/2397984/20984\u0026quot;\u0026gt;undefined behaviour\u0026lt;/a\u0026gt;:\u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;[In \u0026lt;code\u0026gt;delete b\u0026lt;/code\u0026gt;], if the static type of the\n  object to be deleted is different from its dynamic type, the static\n  type shall be a base class of the dynamic type of the object to be\n  deleted and \u0026lt;strong\u0026gt;the static type shall have a virtual destructor or the\n  behavior is undefined\u0026lt;/strong\u0026gt;.\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;p\u0026gt;In most implementations, the call to the destructor will be resolved like any non-virtual code, meaning that the destructor of the base class will be called but not the one of the derived class, resulting in a resources leak.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;To sum up, always make base classes\u0026apos; destructors \u0026lt;code\u0026gt;virtual\u0026lt;/code\u0026gt; when they\u0026apos;re meant to be manipulated polymorphically.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;If you want to prevent the deletion of an instance through a base class pointer, you can make the base class destructor protected and nonvirtual; by doing so, the compiler won\u0026apos;t let you call \u0026lt;code\u0026gt;delete\u0026lt;/code\u0026gt; on a base class pointer.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;You can learn more about virtuality and virtual base class destructor in \u0026lt;a href=\u0026quot;http://www.gotw.ca/publications/mill18.htm\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;this article from Herb Sutter\u0026lt;/a\u0026gt;.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;A virtual constructor is not possible but virtual destructor is possible.\nLet us experiment.......\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;iostream\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;using\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;namespace\u0026lt;/span\u0026gt; std;\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Base\u0026lt;/span\u0026gt;\n{\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt;:\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;Base\u0026lt;/span\u0026gt;(){\n        cout \u0026amp;lt;\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Base Constructor Called\\n\u0026quot;\u0026lt;/span\u0026gt;;\n    }\n    ~\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;Base\u0026lt;/span\u0026gt;(){\n        cout \u0026amp;lt;\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Base Destructor called\\n\u0026quot;\u0026lt;/span\u0026gt;;\n    }\n};\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Derived1\u0026lt;/span\u0026gt;: \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; Base\n{\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt;:\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;Derived1\u0026lt;/span\u0026gt;(){\n        cout \u0026amp;lt;\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Derived constructor called\\n\u0026quot;\u0026lt;/span\u0026gt;;\n    }\n    ~\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;Derived1\u0026lt;/span\u0026gt;(){\n        cout \u0026amp;lt;\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Derived destructor called\\n\u0026quot;\u0026lt;/span\u0026gt;;\n    }\n};\n\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;main\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt;\n\u0026lt;/span\u0026gt;{\n    Base *b = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;Derived1\u0026lt;/span\u0026gt;();\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;delete\u0026lt;/span\u0026gt; b;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;The above code output the following:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-none s-code-block\u0026quot;\u0026gt;\u0026lt;code\u0026gt;Base Constructor Called\nDerived constructor called\nBase Destructor called\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;The construction of derived object follow the construction rule but when we delete the \u0026quot;b\u0026quot; pointer(base pointer) we have found that only the base destructor is called. But this must not happen. To do the appropriate thing, we have to make the base destructor virtual.\nNow let see what happens in the following:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;iostream\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;using\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;namespace\u0026lt;/span\u0026gt; std;\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Base\u0026lt;/span\u0026gt;\n{ \n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt;:\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;Base\u0026lt;/span\u0026gt;(){\n        cout \u0026amp;lt;\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Base Constructor Called\\n\u0026quot;\u0026lt;/span\u0026gt;;\n    }\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;virtual\u0026lt;/span\u0026gt; ~\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;Base\u0026lt;/span\u0026gt;(){\n        cout \u0026amp;lt;\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Base Destructor called\\n\u0026quot;\u0026lt;/span\u0026gt;;\n    }\n};\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Derived1\u0026lt;/span\u0026gt;: \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; Base\n{\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt;:\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;Derived1\u0026lt;/span\u0026gt;(){\n        cout \u0026amp;lt;\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Derived constructor called\\n\u0026quot;\u0026lt;/span\u0026gt;;\n    }\n    ~\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;Derived1\u0026lt;/span\u0026gt;(){\n        cout \u0026amp;lt;\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Derived destructor called\\n\u0026quot;\u0026lt;/span\u0026gt;;\n    }\n};\n\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;main\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt;\n\u0026lt;/span\u0026gt;{\n    Base *b = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;Derived1\u0026lt;/span\u0026gt;();\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;delete\u0026lt;/span\u0026gt; b;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;The output changed as following:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-none s-code-block\u0026quot;\u0026gt;\u0026lt;code\u0026gt;Base Constructor Called\nDerived Constructor called\nDerived destructor called\nBase destructor called\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;So the destruction of the base pointer (which takes an allocation on derived object!) follows the destruction rule, i.e first the Derived, then the Base.\nOn the other hand, there is nothing like a virtual constructor.       \u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Declare destructors virtual in polymorphic base classes.  This is Item 7 in Scott Meyers\u0026apos; \u0026lt;a href=\u0026quot;https://rads.stackoverflow.com/amzn/click/com/0201924889\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;Effective C++\u0026lt;/a\u0026gt;.  Meyers goes on to summarize that if a class has \u0026lt;em\u0026gt;any\u0026lt;/em\u0026gt; virtual function, it should have a virtual destructor, and that classes not designed to be base classes or not designed to be used polymorphically should \u0026lt;em\u0026gt;not\u0026lt;/em\u0026gt; declare virtual destructors.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Also be aware that deleting a base class pointer when there is no virtual destructor will result in \u0026lt;strong\u0026gt;\u0026lt;em\u0026gt;undefined behavior\u0026lt;/em\u0026gt;\u0026lt;/strong\u0026gt;.  Something that I learned just recently:\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;a href=\u0026quot;https://stackoverflow.com/questions/408196/how-should-overriding-delete-in-c-behave\u0026quot;\u0026gt;How should overriding delete in C++ behave?\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;I\u0026apos;ve been using C++ for years and I still manage to hang myself.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Make the destructor virtual whenever your class is polymorphic.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;h3\u0026gt;Calling destructor via a pointer to a base class\u0026lt;/h3\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Base\u0026lt;/span\u0026gt; {\n  \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;virtual\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;f\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt; \u0026lt;/span\u0026gt;{}\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;virtual\u0026lt;/span\u0026gt; ~\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;Base\u0026lt;/span\u0026gt;() {}\n};\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Derived\u0026lt;/span\u0026gt; : Base {\n  \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;f\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;override\u0026lt;/span\u0026gt; \u0026lt;/span\u0026gt;{}\n  ~\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;Derived\u0026lt;/span\u0026gt;() \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;override\u0026lt;/span\u0026gt; {}\n};\n\nBase* base = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; Derived;\nbase-\u0026amp;gt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;f\u0026lt;/span\u0026gt;(); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// calls Derived::f\u0026lt;/span\u0026gt;\nbase-\u0026amp;gt;~\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;Base\u0026lt;/span\u0026gt;(); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// calls Derived::~Derived\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Virtual destructor call is no different from any other virtual function call.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;For \u0026lt;code\u0026gt;base-\u0026amp;gt;f()\u0026lt;/code\u0026gt;, the call will be dispatched to \u0026lt;code\u0026gt;Derived::f()\u0026lt;/code\u0026gt;, and it\u0026apos;s the same for \u0026lt;code\u0026gt;base-\u0026amp;gt;~Base()\u0026lt;/code\u0026gt; - its overriding function - the \u0026lt;code\u0026gt;Derived::~Derived()\u0026lt;/code\u0026gt; will be called.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Same happens when destructor is being called indirectly, e.g. \u0026lt;code\u0026gt;delete base;\u0026lt;/code\u0026gt;. The \u0026lt;code\u0026gt;delete\u0026lt;/code\u0026gt; statement will call \u0026lt;code\u0026gt;base-\u0026amp;gt;~Base()\u0026lt;/code\u0026gt; which will be dispatched to \u0026lt;code\u0026gt;Derived::~Derived()\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n\n\u0026lt;h3\u0026gt;Abstract class with non-virtual destructor\u0026lt;/h3\u0026gt;\n\n\u0026lt;p\u0026gt;If you are not going to delete object through a pointer to its base class - then there is no need to have a virtual destructor. Just make it \u0026lt;code\u0026gt;protected\u0026lt;/code\u0026gt; so that it won\u0026apos;t be called accidentally:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// library.hpp\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Base\u0026lt;/span\u0026gt; {\n  \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;virtual\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;f\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt; \u0026lt;/span\u0026gt;= \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;;\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;protected\u0026lt;/span\u0026gt;:\n  ~\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;Base\u0026lt;/span\u0026gt;() = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;default\u0026lt;/span\u0026gt;;\n};\n\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;CallsF\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(Base\u0026amp;amp; base)\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;;\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// CallsF is not going to own \u0026quot;base\u0026quot; (i.e. call \u0026quot;delete \u0026amp;amp;base;\u0026quot;).\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// It will only call Base::f() so it doesn\u0026apos;t need to access Base::~Base.\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//-------------------\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// application.cpp\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Derived\u0026lt;/span\u0026gt; : Base {\n  \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;f\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;override\u0026lt;/span\u0026gt; \u0026lt;/span\u0026gt;{ ... }\n};\n\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;main\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt; \u0026lt;/span\u0026gt;{\n  Derived derived;\n  \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;CallsF\u0026lt;/span\u0026gt;(derived);\n  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// No need for virtual destructor here as well.\u0026lt;/span\u0026gt;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;To be simple,\nVirtual destructor is to destruct the resources in a proper order, when you delete a base class pointer pointing to derived class object.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt; \u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;iostream\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;using\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;namespace\u0026lt;/span\u0026gt; std;\n \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;B\u0026lt;/span\u0026gt;{\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt;:\n       \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;B\u0026lt;/span\u0026gt;(){\n          cout\u0026amp;lt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;B()\\n\u0026quot;\u0026lt;/span\u0026gt;;\n       }\n       \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;virtual\u0026lt;/span\u0026gt; ~\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;B\u0026lt;/span\u0026gt;(){ \n          cout\u0026amp;lt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;~B()\\n\u0026quot;\u0026lt;/span\u0026gt;;\n       }\n };\n \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;D\u0026lt;/span\u0026gt;: \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; B{\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt;:\n       \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;D\u0026lt;/span\u0026gt;(){\n          cout\u0026amp;lt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;D()\\n\u0026quot;\u0026lt;/span\u0026gt;;\n       }\n       ~\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;D\u0026lt;/span\u0026gt;(){\n          cout\u0026amp;lt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;~D()\\n\u0026quot;\u0026lt;/span\u0026gt;;\n       }\n };\n \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;main\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;{\n    B *b = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;D\u0026lt;/span\u0026gt;();\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;delete\u0026lt;/span\u0026gt; b;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;;\n }\n\nOUTPUT:\n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;B\u0026lt;/span\u0026gt;()\n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;D\u0026lt;/span\u0026gt;()\n~\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;D\u0026lt;/span\u0026gt;()\n~\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;B\u0026lt;/span\u0026gt;()\n\n==============\nIf you don\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;\u0026apos;\u0026lt;/span\u0026gt;t give ~\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;B\u0026lt;/span\u0026gt;()  as \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;virtual\u0026lt;/span\u0026gt;. then output would be \n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;B\u0026lt;/span\u0026gt;()\n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;D\u0026lt;/span\u0026gt;()\n~\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;B\u0026lt;/span\u0026gt;()\nwhere destruction of ~\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;D\u0026lt;/span\u0026gt;() is \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;not\u0026lt;/span\u0026gt; done which leads to leak\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;hr\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Virtual keyword for destructor is necessary when you want different destructors should follow proper order while objects is being deleted through base class pointer. \nfor example:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;Base *myObj = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;Derived\u0026lt;/span\u0026gt;();\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Some code which is using myObj object\u0026lt;/span\u0026gt;\nmyObj-\u0026amp;gt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;fun\u0026lt;/span\u0026gt;();\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//Now delete the object\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;delete\u0026lt;/span\u0026gt; myObj ; \n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;If your base class destructor is virtual then objects will be destructed in a order(firstly derived object then base ). If your base class destructor is NOT virtual then only base class object will get deleted(because pointer is of base class \u0026quot;Base *myObj\u0026quot;). So there will be memory leak for derived object.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;I like to think about interfaces and implementations of interfaces. In C++ speak interface is pure virtual class. Destructor is part of the interface and expected to implemented. Therefore destructor should be pure virtual. How about constructor? Constructor is actually not part of the interface because object is always instantiated explicitly. \u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Virtual base class destructors are \u0026quot;best practice\u0026quot; - you should always use them to avoid (hard to detect) memory leaks. Using them, you can be sure all destructors in the inheritance chain of your classes are beeing called (in proper order). Inheriting from a base class using virtual destructor makes the destructor of the inheriting class automatically virtual, too (so you do not have to retype \u0026apos;virtual\u0026apos; in the inheriting class destructor declaration).\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;I think the core of this question is about virtual methods and polymorphism, not the destructor specifically. Here is a clearer example:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;A\u0026lt;/span\u0026gt;\n{\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt;:\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;A\u0026lt;/span\u0026gt;() {}\n    \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;virtual\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;foo\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt;\n    \u0026lt;/span\u0026gt;{\n        cout \u0026amp;lt;\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;This is A.\u0026quot;\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026amp;lt; endl;\n    }\n};\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;B\u0026lt;/span\u0026gt; : \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; A\n{\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt;:\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;B\u0026lt;/span\u0026gt;() {}\n    \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;foo\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt;\n    \u0026lt;/span\u0026gt;{\n        cout \u0026amp;lt;\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;This is B.\u0026quot;\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026amp;lt; endl;\n    }\n};\n\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;main\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; argc, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt;* argv[])\u0026lt;/span\u0026gt;\n\u0026lt;/span\u0026gt;{\n    A *a = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;B\u0026lt;/span\u0026gt;();\n    a-\u0026amp;gt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;foo\u0026lt;/span\u0026gt;();\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt;(a != \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;NULL\u0026lt;/span\u0026gt;)\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;delete\u0026lt;/span\u0026gt; a;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Will print out:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;This is B.\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Without \u0026lt;code\u0026gt;virtual\u0026lt;/code\u0026gt; it will print out:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;This is A.\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;And now you should understand when to use virtual destructors.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;If you use \u0026lt;code\u0026gt;shared_ptr\u0026lt;/code\u0026gt;(only shared_ptr, not unique_ptr), you don\u0026apos;t have to have the base class destructor virtual:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;iostream\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;memory\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;using\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;namespace\u0026lt;/span\u0026gt; std;\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Base\u0026lt;/span\u0026gt;\n{\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt;:\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;Base\u0026lt;/span\u0026gt;(){\n        cout \u0026amp;lt;\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Base Constructor Called\\n\u0026quot;\u0026lt;/span\u0026gt;;\n    }\n    ~\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;Base\u0026lt;/span\u0026gt;(){ \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// not virtual\u0026lt;/span\u0026gt;\n        cout \u0026amp;lt;\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Base Destructor called\\n\u0026quot;\u0026lt;/span\u0026gt;;\n    }\n};\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Derived\u0026lt;/span\u0026gt;: \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; Base\n{\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt;:\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;Derived\u0026lt;/span\u0026gt;(){\n        cout \u0026amp;lt;\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Derived constructor called\\n\u0026quot;\u0026lt;/span\u0026gt;;\n    }\n    ~\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;Derived\u0026lt;/span\u0026gt;(){\n        cout \u0026amp;lt;\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Derived destructor called\\n\u0026quot;\u0026lt;/span\u0026gt;;\n    }\n};\n\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;main\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt;\n\u0026lt;/span\u0026gt;{\n    \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;shared_ptr\u0026amp;lt;Base\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;b\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; Derived())\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;output:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-none s-code-block\u0026quot;\u0026gt;\u0026lt;code\u0026gt;Base Constructor Called\nDerived constructor called\nDerived destructor called\nBase Destructor called\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;What is a virtual destructor or how to use virtual destructor\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;A class destructor is a function with same name of the class preceding with ~ that will reallocate the memory that is allocated by the class. Why we need a virtual destructor\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;See  the  following  sample with some virtual functions\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;The sample also tell how you can convert a letter to upper or lower\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;stdafx.h\u0026quot;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;iostream\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;using\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;namespace\u0026lt;/span\u0026gt; std;\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// program to convert the lower to upper orlower\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;convertch\u0026lt;/span\u0026gt;\n{\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt;:\n  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//void convertch(){};\u0026lt;/span\u0026gt;\n  \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;virtual\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt;* \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;convertChar\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt; \u0026lt;/span\u0026gt;= \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;;\n  ~\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;convertch\u0026lt;/span\u0026gt;(){};\n};\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;MakeLower\u0026lt;/span\u0026gt; :\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; convertch\n{\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt;:\n  \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;MakeLower\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; *passLetter)\n  {\n    tolower = \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;true\u0026lt;/span\u0026gt;;\n    Letter = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt;[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;30\u0026lt;/span\u0026gt;];\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;strcpy\u0026lt;/span\u0026gt;(Letter, passLetter);\n  }\n\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;virtual\u0026lt;/span\u0026gt; ~\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;MakeLower\u0026lt;/span\u0026gt;()\n  {\n    cout\u0026amp;lt;\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;called ~MakeLower()\u0026quot;\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;\\n\u0026quot;\u0026lt;/span\u0026gt;;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;delete\u0026lt;/span\u0026gt;[] Letter;\n  }\n\n  \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt;* \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;convertChar\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt;\n  \u0026lt;/span\u0026gt;{\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;size_t\u0026lt;/span\u0026gt; len = \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;strlen\u0026lt;/span\u0026gt;(Letter);\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; i= \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;;i\u0026amp;lt;len;i++)\n      Letter[i] = Letter[i] + \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;32\u0026lt;/span\u0026gt;;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; Letter;\n  }\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;private\u0026lt;/span\u0026gt;:\n  \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; *Letter;\n  \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;bool\u0026lt;/span\u0026gt; tolower;\n};\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;MakeUpper\u0026lt;/span\u0026gt; : \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; convertch\n{\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt;:\n  \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;MakeUpper\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; *passLetter)\n  {\n    Letter = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt;[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;30\u0026lt;/span\u0026gt;];\n    toupper = \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;true\u0026lt;/span\u0026gt;;\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;strcpy\u0026lt;/span\u0026gt;(Letter, passLetter);\n  }\n\n  \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt;* \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;convertChar\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt;\n  \u0026lt;/span\u0026gt;{   \n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;size_t\u0026lt;/span\u0026gt; len = \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;strlen\u0026lt;/span\u0026gt;(Letter);\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; i= \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;;i\u0026amp;lt;len;i++)\n      Letter[i] = Letter[i] - \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;32\u0026lt;/span\u0026gt;;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; Letter;\n  }\n\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;virtual\u0026lt;/span\u0026gt; ~\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;MakeUpper\u0026lt;/span\u0026gt;()\n  {\n    cout\u0026amp;lt;\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;called ~MakeUpper()\u0026quot;\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;\\n\u0026quot;\u0026lt;/span\u0026gt;;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;delete\u0026lt;/span\u0026gt; Letter;\n  }\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;private\u0026lt;/span\u0026gt;:\n  \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; *Letter;\n  \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;bool\u0026lt;/span\u0026gt; toupper;\n};\n\n\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; _tmain(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; argc, _TCHAR* argv[])\n{\n  convertch *makeupper = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;MakeUpper\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;hai\u0026quot;\u0026lt;/span\u0026gt;); \n  cout\u0026amp;lt;\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Eneterd : hai = \u0026quot;\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026amp;lt;makeupper-\u0026amp;gt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;convertChar\u0026lt;/span\u0026gt;()\u0026amp;lt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot; \u0026quot;\u0026lt;/span\u0026gt;;     \n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;delete\u0026lt;/span\u0026gt; makeupper;\n  convertch *makelower = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;MakeLower\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;HAI\u0026quot;\u0026lt;/span\u0026gt;);;\n  cout\u0026amp;lt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Eneterd : HAI = \u0026quot;\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026amp;lt;makelower-\u0026amp;gt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;convertChar\u0026lt;/span\u0026gt;()\u0026amp;lt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot; \u0026quot;\u0026lt;/span\u0026gt;; \n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;delete\u0026lt;/span\u0026gt; makelower;\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;From the above sample you can see that the destructor for both MakeUpper and MakeLower class is not called.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;See the next sample with the virtual destructor\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;stdafx.h\u0026quot;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;iostream\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;using\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;namespace\u0026lt;/span\u0026gt; std;\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// program to convert the lower to upper orlower\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;convertch\u0026lt;/span\u0026gt;\n{\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt;:\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//void convertch(){};\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;virtual\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt;* \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;convertChar\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt; \u0026lt;/span\u0026gt;= \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;virtual\u0026lt;/span\u0026gt; ~\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;convertch\u0026lt;/span\u0026gt;(){}; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// defined the virtual destructor\u0026lt;/span\u0026gt;\n\n};\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;MakeLower\u0026lt;/span\u0026gt; :\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; convertch\n{\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt;:\n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;MakeLower\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; *passLetter)\n{\ntolower = \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;true\u0026lt;/span\u0026gt;;\nLetter = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt;[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;30\u0026lt;/span\u0026gt;];\n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;strcpy\u0026lt;/span\u0026gt;(Letter, passLetter);\n}\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;virtual\u0026lt;/span\u0026gt; ~\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;MakeLower\u0026lt;/span\u0026gt;()\n{\ncout\u0026amp;lt;\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;called ~MakeLower()\u0026quot;\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;\\n\u0026quot;\u0026lt;/span\u0026gt;;\n      \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;delete\u0026lt;/span\u0026gt;[] Letter;\n}\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt;* \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;convertChar\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt;\n\u0026lt;/span\u0026gt;{\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;size_t\u0026lt;/span\u0026gt; len = \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;strlen\u0026lt;/span\u0026gt;(Letter);\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; i= \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;;i\u0026amp;lt;len;i++)\n{\nLetter[i] = Letter[i] + \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;32\u0026lt;/span\u0026gt;;\n\n}\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; Letter;\n}\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;private\u0026lt;/span\u0026gt;:\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; *Letter;\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;bool\u0026lt;/span\u0026gt; tolower;\n\n};\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;MakeUpper\u0026lt;/span\u0026gt; : \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; convertch\n{\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt;:\n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;MakeUpper\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; *passLetter)\n{\nLetter = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt;[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;30\u0026lt;/span\u0026gt;];\ntoupper = \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;true\u0026lt;/span\u0026gt;;\n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;strcpy\u0026lt;/span\u0026gt;(Letter, passLetter);\n}\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt;* \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;convertChar\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt;\n\u0026lt;/span\u0026gt;{\n\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;size_t\u0026lt;/span\u0026gt; len = \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;strlen\u0026lt;/span\u0026gt;(Letter);\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; i= \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;;i\u0026amp;lt;len;i++)\n{\nLetter[i] = Letter[i] - \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;32\u0026lt;/span\u0026gt;;\n}\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; Letter;\n}\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;virtual\u0026lt;/span\u0026gt; ~\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;MakeUpper\u0026lt;/span\u0026gt;()\n{\n      cout\u0026amp;lt;\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;called ~MakeUpper()\u0026quot;\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;\\n\u0026quot;\u0026lt;/span\u0026gt;;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;delete\u0026lt;/span\u0026gt; Letter;\n}\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;private\u0026lt;/span\u0026gt;:\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; *Letter;\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;bool\u0026lt;/span\u0026gt; toupper;\n};\n\n\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; _tmain(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; argc, _TCHAR* argv[])\n{\n\nconvertch *makeupper = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;MakeUpper\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;hai\u0026quot;\u0026lt;/span\u0026gt;);\n\ncout\u0026amp;lt;\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Eneterd : hai = \u0026quot;\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026amp;lt;makeupper-\u0026amp;gt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;convertChar\u0026lt;/span\u0026gt;()\u0026amp;lt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot; \\n\u0026quot;\u0026lt;/span\u0026gt;;\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;delete\u0026lt;/span\u0026gt; makeupper;\nconvertch *makelower = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;MakeLower\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;HAI\u0026quot;\u0026lt;/span\u0026gt;);;\ncout\u0026amp;lt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Eneterd : HAI = \u0026quot;\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026amp;lt;makelower-\u0026amp;gt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;convertChar\u0026lt;/span\u0026gt;()\u0026amp;lt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;\\n \u0026quot;\u0026lt;/span\u0026gt;;\n\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;delete\u0026lt;/span\u0026gt; makelower;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;The virtual destructor will call explicitly the most derived run time destructor of class so that it will be able to clear the object in a proper way.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Or visit the link\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;a href=\u0026quot;https://web.archive.org/web/20130822173509/http://www.programminggallery.com/article_details.php?article_id=138\u0026quot; rel=\u0026quot;nofollow\u0026quot;\u0026gt;https://web.archive.org/web/20130822173509/http://www.programminggallery.com/article_details.php?article_id=138\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;I thought it would be beneficial to discuss the \u0026quot;undefined\u0026quot; behavior, or at least the \u0026quot;crash\u0026quot; undefined behavior that may occur when deleting through a base class(/struct) without a virtual destructor, or more precisely no vtable.  The code below list a few simple structs (the same would be true for classes).\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;iostream\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;using\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;namespace\u0026lt;/span\u0026gt; std;\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;a\u0026lt;/span\u0026gt;\n{\n    ~\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;a\u0026lt;/span\u0026gt;() {}\n\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;unsigned\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;long\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;long\u0026lt;/span\u0026gt; i;\n};\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;b\u0026lt;/span\u0026gt; : a\n{\n    ~\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;b\u0026lt;/span\u0026gt;() {}\n\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;unsigned\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;long\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;long\u0026lt;/span\u0026gt; j;\n};\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;c\u0026lt;/span\u0026gt; : b\n{\n    ~\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;c\u0026lt;/span\u0026gt;() {}\n\n    \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;virtual\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;m3\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt; \u0026lt;/span\u0026gt;{}\n\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;unsigned\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;long\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;long\u0026lt;/span\u0026gt; k;\n};\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;d\u0026lt;/span\u0026gt; : c\n{\n    ~\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;d\u0026lt;/span\u0026gt;() {}\n\n    \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;virtual\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;m4\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt; \u0026lt;/span\u0026gt;{}\n\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;unsigned\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;long\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;long\u0026lt;/span\u0026gt; l;\n};\n\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;main\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt;\n\u0026lt;/span\u0026gt;{\n    cout \u0026amp;lt;\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;sizeof(a): \u0026quot;\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;sizeof\u0026lt;/span\u0026gt;(a) \u0026amp;lt;\u0026amp;lt; endl;\n    cout \u0026amp;lt;\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;sizeof(b): \u0026quot;\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;sizeof\u0026lt;/span\u0026gt;(b) \u0026amp;lt;\u0026amp;lt; endl;\n    cout \u0026amp;lt;\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;sizeof(c): \u0026quot;\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;sizeof\u0026lt;/span\u0026gt;(c) \u0026amp;lt;\u0026amp;lt; endl;\n    cout \u0026amp;lt;\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;sizeof(d): \u0026quot;\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;sizeof\u0026lt;/span\u0026gt;(d) \u0026amp;lt;\u0026amp;lt; endl;\n\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// No issue.\u0026lt;/span\u0026gt;\n\n    a* a1 = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;a\u0026lt;/span\u0026gt;();\n    cout \u0026amp;lt;\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;a1: \u0026quot;\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026amp;lt; a1 \u0026amp;lt;\u0026amp;lt; endl;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;delete\u0026lt;/span\u0026gt; a1;\n\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// No issue.\u0026lt;/span\u0026gt;\n\n    b* b1 = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;b\u0026lt;/span\u0026gt;();\n    cout \u0026amp;lt;\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;b1: \u0026quot;\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026amp;lt; b1 \u0026amp;lt;\u0026amp;lt; endl;\n    cout \u0026amp;lt;\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;(a*) b1: \u0026quot;\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026amp;lt; (a*) b1 \u0026amp;lt;\u0026amp;lt; endl;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;delete\u0026lt;/span\u0026gt; b1;\n\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// No issue.\u0026lt;/span\u0026gt;\n\n    c* c1 = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;c\u0026lt;/span\u0026gt;();\n    cout \u0026amp;lt;\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;c1: \u0026quot;\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026amp;lt; c1 \u0026amp;lt;\u0026amp;lt; endl;\n    cout \u0026amp;lt;\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;(b*) c1: \u0026quot;\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026amp;lt; (b*) c1 \u0026amp;lt;\u0026amp;lt; endl;\n    cout \u0026amp;lt;\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;(a*) c1: \u0026quot;\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026amp;lt; (a*) c1 \u0026amp;lt;\u0026amp;lt; endl;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;delete\u0026lt;/span\u0026gt; c1;\n\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// No issue.\u0026lt;/span\u0026gt;\n\n    d* d1 = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;d\u0026lt;/span\u0026gt;();\n    cout \u0026amp;lt;\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;d1: \u0026quot;\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026amp;lt; d1 \u0026amp;lt;\u0026amp;lt; endl;\n    cout \u0026amp;lt;\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;(c*) d1: \u0026quot;\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026amp;lt; (c*) d1 \u0026amp;lt;\u0026amp;lt; endl;\n    cout \u0026amp;lt;\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;(b*) d1: \u0026quot;\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026amp;lt; (b*) d1 \u0026amp;lt;\u0026amp;lt; endl;\n    cout \u0026amp;lt;\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;(a*) d1: \u0026quot;\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026amp;lt; (a*) d1 \u0026amp;lt;\u0026amp;lt; endl;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;delete\u0026lt;/span\u0026gt; d1;\n\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Doesn\u0026apos;t crash, but may not produce the results you want.\u0026lt;/span\u0026gt;\n\n    c1 = (c*) \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;d\u0026lt;/span\u0026gt;();\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;delete\u0026lt;/span\u0026gt; c1;\n\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Crashes due to passing an invalid address to the method which\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// frees the memory.\u0026lt;/span\u0026gt;\n\n    d1 = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;d\u0026lt;/span\u0026gt;();\n    b1 = (b*) d1;\n    cout \u0026amp;lt;\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;d1: \u0026quot;\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026amp;lt; d1 \u0026amp;lt;\u0026amp;lt; endl;\n    cout \u0026amp;lt;\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;b1: \u0026quot;\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026amp;lt; b1 \u0026amp;lt;\u0026amp;lt; endl;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;delete\u0026lt;/span\u0026gt; b1;  \n\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;/*\n\n    // This is similar to what\u0026apos;s happening above in the \u0026quot;crash\u0026quot; case.\n\n    char* buf = new char[32];\n    cout \u0026amp;lt;\u0026amp;lt; \u0026quot;buf: \u0026quot; \u0026amp;lt;\u0026amp;lt; (void*) buf \u0026amp;lt;\u0026amp;lt; endl;\n    buf += 8;\n    cout \u0026amp;lt;\u0026amp;lt; \u0026quot;buf after adding 8: \u0026quot; \u0026amp;lt;\u0026amp;lt; (void*) buf \u0026amp;lt;\u0026amp;lt; endl;\n    delete buf;\n*/\u0026lt;/span\u0026gt;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;I\u0026apos;m not suggesting whether you need virtual destructors or not, though I think in general it\u0026apos;s a good practice to have them.  I\u0026apos;m just pointing out the reason you may end up with a crash if your base class(/struct) does not have a vtable and your derived class(/struct) does and you delete an object via a base class(/struct) pointer.  In this case, the address you pass to the heap\u0026apos;s free routine is invalid and thus the reason for the crash.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;If you run the above code you\u0026apos;ll see clearly when the issue occurs.  When the this pointer of the base class(/struct) is different from the this pointer of the derived class(/struct) you\u0026apos;re going to run into this problem.  In the sample above, struct a and b don\u0026apos;t have vtables.  structs c and d do have vtables.  Thus an a or b pointer to a c or d object instance will be fixed up to account for the vtable.  If you pass this a or b pointer to delete it will crash due to the address being invalid to the heap\u0026apos;s free routine.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;If you plan to delete derived instances which have vtables from base class pointers, you need to ensure the base class has a vtable.  One way to do that is to add a virtual destructor, which you might want anyway to properly clean up resources.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;when you need to call derived class destructor from base class. you need to declare virtual base class destructor in base class.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;I think most answers here miss the point, with the exception of the accepted one, which is a good thing. However, let me add one more with a different view on the issue: You need a virtual destructor if you want to polymorphically delete instances of this class.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;This kind-of sidesteps the question, so let me elaborate: As many pointed out, you get undesired behaviour if you invoke \u0026lt;code\u0026gt;delete base_ptr\u0026lt;/code\u0026gt; and the destructor is not virtual. However, there are several assumptions there that need to be make explicit:\u0026lt;/p\u0026gt;\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;If your class is not a baseclass, you will hopefully not write code like this. In this case I don\u0026apos;t mean the manual memory management, which is bad in and of itself, but deriving publicly from this class. A class not designed as baseclass should not be inherited from, like e.g. \u0026lt;code\u0026gt;std::string\u0026lt;/code\u0026gt;. C++ allows you to shoot yourself in the foot. This is your fault though, not that of the baseclass not having a virtual destructor.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;If the destructor is not accessible (protected or private), this code won\u0026apos;t compile, so the undesired behaviour can not occur. Having a protected destructor is useful, especially for mixins but also (to a lesser extent) for interfaces. You don\u0026apos;t want to incur the overhead of virtual functions unless you actually make use of them. Making the destructor protected instead prevents undesired behaviour but doesn\u0026apos;t restrict you otherwise.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;If you actually write a class that is supposed to be derived from, you will typically have virtual functions anyways. As a user of them, you will typically only use them via a pointer to the baseclass. When this use includes disposing of them, it then needs to be polymorphic as well. This is then the case when you should make the destructor virtual.\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;p\u0026gt;For a similarly different view on the subject, also read \u0026lt;a href=\u0026quot;https://stackoverflow.com/questions/300986/when-should-you-not-use-virtual-destructors\u0026quot;\u0026gt;When should you not use virtual destructors?\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;A basic definition about \u0026lt;code\u0026gt;virtual\u0026lt;/code\u0026gt; is it determines if a member function of a class can be over-ridden in its derived classes. \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;A class\u0026apos;s D-tor is called basically at the end of the scope, but there is a problem, for example when we define an instance on the Heap (dynamic allocation), we should delete it manually.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;As soon as the instruction get executed, the base class destructor get called, but not for the derived one.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;A Pratical example is when, in control field, you have to manipulate effectors, actuators.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;At the end of the scope, if the destructor of one of the power elements (Actuator), isn\u0026apos;t called, there will be fatal consequences.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;iostream\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Mother\u0026lt;/span\u0026gt;{\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt;:\n\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;Mother\u0026lt;/span\u0026gt;(){\n\n          std::cout\u0026amp;lt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Mother Ctor\u0026quot;\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026amp;lt;std::endl;\n    }\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;virtual\u0026lt;/span\u0026gt;~\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;Mother\u0026lt;/span\u0026gt;(){\n\n        std::cout\u0026amp;lt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Mother D-tor\u0026quot;\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026amp;lt;std::endl;\n    }\n\n\n};\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Child\u0026lt;/span\u0026gt;: \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; Mother{\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt;:\n\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;Child\u0026lt;/span\u0026gt;(){\n\n        std::cout\u0026amp;lt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Child C-tor\u0026quot;\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026amp;lt;std::endl;\n    }\n\n    ~\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;Child\u0026lt;/span\u0026gt;(){\n\n         std::cout\u0026amp;lt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Child D-tor\u0026quot;\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026amp;lt;std::endl;\n    }\n};\n\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;main\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt;\n\u0026lt;/span\u0026gt;{\n\n    Mother *c = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;Child\u0026lt;/span\u0026gt;();\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;delete\u0026lt;/span\u0026gt; c;\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Make all destructors virtual unless you have good reason not to.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Otherwise evil like this happens:\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Suppose you have an array of Fruit pointers with both Apple and Orange objects.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;When you delete from the collection of Fruit objects,\n~Apple() and ~Orange() fail to be called unless ~Fruit() is virtual.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Example done right:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;iostream\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;using\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;namespace\u0026lt;/span\u0026gt; std;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Fruit\u0026lt;/span\u0026gt; { \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// good\u0026lt;/span\u0026gt;\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;virtual\u0026lt;/span\u0026gt; ~\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;Fruit\u0026lt;/span\u0026gt;() { cout \u0026amp;lt;\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;peel or core should have been tossed\u0026quot;\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026amp;lt; endl; } \n};\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Apple\u0026lt;/span\u0026gt;:  Fruit { \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;virtual\u0026lt;/span\u0026gt; ~\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;Apple\u0026lt;/span\u0026gt;()  {cout \u0026amp;lt;\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;toss core\u0026quot;\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026amp;lt; endl; } };\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Orange\u0026lt;/span\u0026gt;: Fruit { \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;virtual\u0026lt;/span\u0026gt; ~\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;Orange\u0026lt;/span\u0026gt;() {cout \u0026amp;lt;\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;toss peel\u0026quot;\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026amp;lt; endl; } };\n\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;main\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt; \u0026lt;/span\u0026gt;{ \n  Fruit *basket[]={ \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;Apple\u0026lt;/span\u0026gt;(), \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;Orange\u0026lt;/span\u0026gt;() };\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt; (\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;auto\u0026lt;/span\u0026gt; fruit: basket) \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;delete\u0026lt;/span\u0026gt; fruit;\n};\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;good output\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;toss core\npeel \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;or\u0026lt;/span\u0026gt; core should have been tossed\ntoss peel\npeel \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;or\u0026lt;/span\u0026gt; core should have been tossed\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;Example done wrong:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;iostream\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;using\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;namespace\u0026lt;/span\u0026gt; std;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Fruit\u0026lt;/span\u0026gt; { \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// bad \u0026lt;/span\u0026gt;\n  ~\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;Fruit\u0026lt;/span\u0026gt;() { cout \u0026amp;lt;\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;peel or core should have been tossed\u0026quot;\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026amp;lt; endl; } \n};\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Apple\u0026lt;/span\u0026gt;:  Fruit { \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;virtual\u0026lt;/span\u0026gt; ~\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;Apple\u0026lt;/span\u0026gt;()  {cout \u0026amp;lt;\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;toss core\u0026quot;\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026amp;lt; endl; } };\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Orange\u0026lt;/span\u0026gt;: Fruit { \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;virtual\u0026lt;/span\u0026gt; ~\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;Orange\u0026lt;/span\u0026gt;() {cout \u0026amp;lt;\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;toss peel\u0026quot;\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026amp;lt; endl; } };\n\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;main\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt; \u0026lt;/span\u0026gt;{ \n  Fruit *basket[]={ \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;Apple\u0026lt;/span\u0026gt;(), \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;Orange\u0026lt;/span\u0026gt;() };\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt; (\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;auto\u0026lt;/span\u0026gt; fruit: basket) \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;delete\u0026lt;/span\u0026gt; fruit;\n};\n\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;bad output\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;peel \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;or\u0026lt;/span\u0026gt; core should have been tossed\npeel \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;or\u0026lt;/span\u0026gt; core should have been tossed\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;(Note: Where I used struct for brevity, normally use class and specify public)\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Any class that is inherited publicly, polymorphic or not, should have a virtual destructor. To put another way, if it can be pointed to by a base class pointer, its base class should have a virtual destructor.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;If virtual, the derived class destructor gets called and then the base class destructor. If not virtual, only the base class destructor gets called.\u0026lt;/p\u0026gt;\n    "],"id":486,"title":"When to use virtual destructors?","content":"\n                \n\u0026lt;p\u0026gt;I have a solid understanding of most \u0026lt;code\u0026gt;OOP\u0026lt;/code\u0026gt; theory but the one thing that confuses me a lot is virtual destructors.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;I thought that the destructor always gets called no matter what and for every object in the chain.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;When are you meant to make them virtual and why?\u0026lt;/p\u0026gt;\n    ","slug":"when-to-use-virtual-destructors-1657388152135","postType":"QUESTION","createdAt":"2022-07-09T17:35:52.000Z","updatedAt":"2022-07-09T17:35:52.000Z","tags":[{"id":2447,"name":"virtual-destructor","slug":"virtual-destructor","createdAt":"2022-07-09T17:35:52.000Z","updatedAt":"2022-07-09T17:35:52.000Z","Questions_Tags":{"questionId":486,"tagId":2447}},{"id":2448,"name":"shared-ptr","slug":"shared-ptr","createdAt":"2022-07-09T17:35:52.000Z","updatedAt":"2022-07-09T17:35:52.000Z","Questions_Tags":{"questionId":486,"tagId":2448}}],"relatedQuestions":[{"title":"When to use virtual destructors?","slug":"when-to-use-virtual-destructors-1657388152135","tags":[{"name":"virtual-destructor","Questions_Tags":{"questionId":486,"tagId":2447}},{"name":"shared-ptr","Questions_Tags":{"questionId":486,"tagId":2448}}]}]},"randomQuestions":[{"title":"Strange result when removing item from a list while iterating over it [duplicate]","slug":"strange-result-when-removing-item-from-a-list-while-iterating-over-it-duplicate-1657387735759"},{"title":"Transpose / reshape dataframe without \"timevar\" from long to wide format","slug":"transpose-reshape-dataframe-without-\"timevar\"-from-long-to-wide-format-1657388213347"},{"title":"What is JavaScript's highest integer value that a number can go to without losing precision?","slug":"what-is-javascript's-highest-integer-value-that-a-number-can-go-to-without-losing-precision-1657387622983"},{"title":"MySQL pivot row into dynamic number of columns","slug":"mysql-pivot-row-into-dynamic-number-of-columns-1657387981930"},{"title":"How do you use a variable in a regular expression?","slug":"how-do-you-use-a-variable-in-a-regular-expression-1657387939007"},{"title":"Numbering rows within groups in a data frame","slug":"numbering-rows-within-groups-in-a-data-frame-1657388556436"},{"title":"Are 'Arrow Functions' and 'Functions' equivalent / interchangeable?","slug":"are-'arrow-functions'-and-'functions'-equivalent-interchangeable-1657384527873"},{"title":"Reference  What does this symbol mean in PHP?","slug":"reference-what-does-this-symbol-mean-in-php-1657384561666"},{"title":"Int division: Why is the result of 1/3 == 0?","slug":"int-division:-why-is-the-result-of-13-0-1657387547814"},{"title":"How to manage startActivityForResult on Android","slug":"how-to-manage-startactivityforresult-on-android-1657387967393"},{"title":"How do I Pandas group-by to get sum?","slug":"how-do-i-pandas-group-by-to-get-sum-1657387908708"},{"title":"What is the \"N+1 selects problem\" in ORM (Object-Relational Mapping)?","slug":"what-is-the-\"n+1-selects-problem\"-in-orm-(object-relational-mapping)-1657388055597"},{"title":"Passing data between view controllers","slug":"passing-data-between-view-controllers-1657384540021"},{"title":"How to add JTable in JPanel with null layout?","slug":"how-to-add-jtable-in-jpanel-with-null-layout-1657384590912"},{"title":"Efficiently convert rows to columns in sql server","slug":"efficiently-convert-rows-to-columns-in-sql-server-1657387919213"},{"title":"How to read a file line-by-line into a list?","slug":"how-to-read-a-file-line-by-line-into-a-list-1657387865894"},{"title":"How can I get useful error messages in PHP?","slug":"how-can-i-get-useful-error-messages-in-php-1657384609065"},{"title":"Why are these constructs using pre and post-increment undefined behavior?","slug":"why-are-these-constructs-using-pre-and-post-increment-undefined-behavior-1657384520109"},{"title":"How to fix \"Headers already sent\" error in PHP","slug":"how-to-fix-\"headers-already-sent\"-error-in-php-1657384315553"},{"title":"Get the cartesian product of a series of lists?","slug":"get-the-cartesian-product-of-a-series-of-lists-1657387709890"}]},"__N_SSG":true},"page":"/questions/[slug]","query":{"slug":"when-to-use-virtual-destructors-1657388152135"},"buildId":"00bsHgHZki2FteshOatnd","isFallback":false,"gsp":true,"locale":"en","locales":["en"],"defaultLocale":"en","scriptLoader":[]}</script></body></html>