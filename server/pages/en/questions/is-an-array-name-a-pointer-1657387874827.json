{"pageProps":{"data":{"answer":["\n&lt;p&gt;An array is an array and a pointer is a pointer, but in most cases array names are &lt;em&gt;converted&lt;/em&gt; to pointers. A term often used is that they &lt;em&gt;decay&lt;/em&gt; to pointers.&lt;/p&gt;\n\n&lt;p&gt;Here is an array:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; a[&lt;span class=&quot;hljs-number&quot;&gt;7&lt;/span&gt;];\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;&lt;code&gt;a&lt;/code&gt; contains space for seven integers, and you can put a value in one of them with an assignment, like this:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;a[&lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;] = &lt;span class=&quot;hljs-number&quot;&gt;9&lt;/span&gt;;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Here is a pointer:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; *p;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;&lt;code&gt;p&lt;/code&gt; doesn&apos;t contain any spaces for integers, but it can point to a space for an integer. We can, for example, set it to point to one of the places in the array &lt;code&gt;a&lt;/code&gt;, such as the first one:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;p = &amp;amp;a[&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;];\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;What can be confusing is that you can also write this:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;p = a;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;This does &lt;em&gt;not&lt;/em&gt; copy the contents of the array &lt;code&gt;a&lt;/code&gt; into the pointer &lt;code&gt;p&lt;/code&gt; (whatever that would mean). Instead, the array name &lt;code&gt;a&lt;/code&gt; is converted to a pointer to its first element. So that assignment does the same as the previous one.&lt;/p&gt;\n\n&lt;p&gt;Now you can use &lt;code&gt;p&lt;/code&gt; in a similar way to an array:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;p[&lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;] = &lt;span class=&quot;hljs-number&quot;&gt;17&lt;/span&gt;;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;The reason that this works is that the array dereferencing operator in C, &lt;code&gt;[ ]&lt;/code&gt;, is defined in terms of pointers. &lt;code&gt;x[y]&lt;/code&gt; means: start with the pointer &lt;code&gt;x&lt;/code&gt;, step &lt;code&gt;y&lt;/code&gt; elements forward after what the pointer points to, and then take whatever is there. Using pointer arithmetic syntax, &lt;code&gt;x[y]&lt;/code&gt; can also be written as &lt;code&gt;*(x+y)&lt;/code&gt;.&lt;/p&gt;\n\n&lt;p&gt;For this to work with a normal array, such as our &lt;code&gt;a&lt;/code&gt;, the name &lt;code&gt;a&lt;/code&gt; in &lt;code&gt;a[3]&lt;/code&gt; must first be converted to a pointer (to the first element in &lt;code&gt;a&lt;/code&gt;). Then we step 3 elements forward, and take whatever is there. In other words: take the element at position 3 in the array. (Which is the fourth element in the array, since the first one is numbered 0.)&lt;/p&gt;\n\n&lt;p&gt;So, in summary, array names in a C program are (in most cases) converted to pointers. One exception is when we use the &lt;code&gt;sizeof&lt;/code&gt; operator on an array. If &lt;code&gt;a&lt;/code&gt; was converted to a pointer in this context, &lt;code&gt;sizeof a&lt;/code&gt; would give the size of a pointer and not of the actual array, which would be rather useless, so in that case &lt;code&gt;a&lt;/code&gt; means the array itself.&lt;/p&gt;\n    ","\n&lt;p&gt;When an array is used as a value, its name represents the address of the first element.&lt;br&gt;\nWhen an array is not used as a value its name represents the whole array.&lt;/p&gt;\n\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; arr[&lt;span class=&quot;hljs-number&quot;&gt;7&lt;/span&gt;];\n\n&lt;span class=&quot;hljs-comment&quot;&gt;/* arr used as value */&lt;/span&gt;\nfoo(arr);\n&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; x = *(arr + &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;); &lt;span class=&quot;hljs-comment&quot;&gt;/* same as arr[1] */&lt;/span&gt;\n\n&lt;span class=&quot;hljs-comment&quot;&gt;/* arr not used as value */&lt;/span&gt;\n&lt;span class=&quot;hljs-type&quot;&gt;size_t&lt;/span&gt; bytes = &lt;span class=&quot;hljs-keyword&quot;&gt;sizeof&lt;/span&gt; arr;\n&lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt; *q = &amp;amp;arr; &lt;span class=&quot;hljs-comment&quot;&gt;/* void pointers are compatible with pointers to any object */&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n    ","\n&lt;p&gt;If an expression of array type (such as the array name) appears in a larger expression and it isn&apos;t the operand of either the &lt;code&gt;&amp;amp;&lt;/code&gt; or &lt;code&gt;sizeof&lt;/code&gt; operators, then the type of the array expression is converted from &quot;N-element array of T&quot; to &quot;pointer to T&quot;, and the value of the expression is the address of the first element in the array.  &lt;/p&gt;\n\n&lt;p&gt;In short, the array name is not a pointer, but in most contexts it is treated &lt;em&gt;as though&lt;/em&gt; it were a pointer.  &lt;/p&gt;\n\n&lt;p&gt;&lt;strong&gt;Edit&lt;/strong&gt;&lt;/p&gt;\n\n&lt;p&gt;Answering the question in the comment:&lt;/p&gt;\n\n&lt;blockquote&gt;\n  &lt;p&gt;If I use sizeof, do i count the size of only the elements of the array? Then the array head also takes up space with the information about length and a pointer (and this means that it takes more space, than a normal pointer would)?&lt;/p&gt;\n&lt;/blockquote&gt;\n\n&lt;p&gt;When you create an array, the only space that&apos;s allocated is the space for the elements themselves; no storage is materialized for a separate pointer or any metadata.  Given&lt;/p&gt;\n\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;char&lt;/span&gt; a[&lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;];\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;what you get in memory is&lt;/p&gt;\n\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;   +---+\na: |   | a[&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;]\n   +---+ \n   |   | a[&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;]\n   +---+\n   |   | a[&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;]\n   +---+\n    ...\n   +---+\n   |   | a[&lt;span class=&quot;hljs-number&quot;&gt;9&lt;/span&gt;]\n   +---+\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;The &lt;em&gt;expression&lt;/em&gt; &lt;code&gt;a&lt;/code&gt; refers to the entire array, but there&apos;s no &lt;em&gt;object&lt;/em&gt; &lt;code&gt;a&lt;/code&gt; separate from the array elements themselves.  Thus, &lt;code&gt;sizeof a&lt;/code&gt; gives you the size (in bytes) of the entire array.  The expression &lt;code&gt;&amp;amp;a&lt;/code&gt; gives you the address of the array, &lt;em&gt;which is the same as the address of the first element&lt;/em&gt;.  The difference between &lt;code&gt;&amp;amp;a&lt;/code&gt; and &lt;code&gt;&amp;amp;a[0]&lt;/code&gt; is the type of the result&lt;sup&gt;1&lt;/sup&gt; - &lt;code&gt;char (*)[10]&lt;/code&gt; in the first case and &lt;code&gt;char *&lt;/code&gt; in the second.  &lt;/p&gt;\n\n&lt;p&gt;Where things get weird is when you want to access individual elements - the expression &lt;code&gt;a[i]&lt;/code&gt; is defined as the result of &lt;code&gt;*(a + i)&lt;/code&gt; - given an address value &lt;code&gt;a&lt;/code&gt;, offset &lt;code&gt;i&lt;/code&gt; elements (&lt;em&gt;not bytes&lt;/em&gt;) from that address and dereference the result.&lt;/p&gt;\n\n&lt;p&gt;The problem is that &lt;code&gt;a&lt;/code&gt; isn&apos;t a pointer or an address - it&apos;s the entire array object.  Thus, the rule in C that whenever the compiler sees an expression of array type (such as &lt;code&gt;a&lt;/code&gt;, which has type &lt;code&gt;char [10]&lt;/code&gt;) &lt;em&gt;and&lt;/em&gt; that expression isn&apos;t the operand of the &lt;code&gt;sizeof&lt;/code&gt; or unary &lt;code&gt;&amp;amp;&lt;/code&gt; operators, the type of that expression is converted (&quot;decays&quot;) to a pointer type (&lt;code&gt;char *&lt;/code&gt;), and the value of the expression is the address of the first element of the array.  Therefore, the &lt;em&gt;expression&lt;/em&gt; &lt;code&gt;a&lt;/code&gt; has the same type and value as the expression &lt;code&gt;&amp;amp;a[0]&lt;/code&gt; (and by extension, the expression &lt;code&gt;*a&lt;/code&gt; has the same type and value as the expression &lt;code&gt;a[0]&lt;/code&gt;).  &lt;/p&gt;\n\n&lt;p&gt;C was derived from an earlier language called B, and in B &lt;code&gt;a&lt;/code&gt; &lt;em&gt;was&lt;/em&gt; a separate pointer object from the array elements &lt;code&gt;a[0]&lt;/code&gt;, &lt;code&gt;a[1]&lt;/code&gt;, etc.  Ritchie wanted to keep B&apos;s array semantics, but he didn&apos;t want to mess with storing the separate pointer object.  So he got rid of it.  Instead, the compiler will convert array expressions to pointer expressions during translation as necessary.  &lt;/p&gt;\n\n&lt;p&gt;Remember that I said arrays don&apos;t store any metadata about their size.  As soon as that array expression &quot;decays&quot; to a pointer, all you have is a pointer to a single element.  That element may be the first of a sequence of elements, or it may be a single object.  There&apos;s no way to know based on the pointer itself.  &lt;/p&gt;\n\n&lt;p&gt;When you pass an array expression to a function, all the function receives is a pointer to the first element - it has no idea how big the array is (this is why the &lt;code&gt;gets&lt;/code&gt; function was such a menace and was eventually removed from the library).  For the function to know how many elements the array has, you must either use a sentinel value (such as the 0 terminator in C strings) or you must pass the number of elements as a separate parameter.  &lt;/p&gt;\n\n&lt;hr&gt;\n\n&lt;ol&gt;\n&lt;sup&gt;&lt;li&gt;Which *may* affect how the address value is interpreted - depends on the machine.&lt;/li&gt;&lt;/sup&gt;\n&lt;/ol&gt;\n    ","\n&lt;p&gt;An array declared like this&lt;/p&gt;\n\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; a[&lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;];\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;allocates memory for 10 &lt;code&gt;int&lt;/code&gt;s. You can&apos;t modify &lt;code&gt;a&lt;/code&gt; but you can do pointer arithmetic with &lt;code&gt;a&lt;/code&gt;.&lt;/p&gt;\n\n&lt;p&gt;A pointer like this allocates memory for just the pointer &lt;code&gt;p&lt;/code&gt;:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; *p;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;It doesn&apos;t allocate any &lt;code&gt;int&lt;/code&gt;s. You can modify it:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;p = a;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;and use array subscripts as you can with a:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;p[&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;] = &lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt;;\na[&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;] = &lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt;;    &lt;span class=&quot;hljs-comment&quot;&gt;// same&lt;/span&gt;\n*(p+&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;) = &lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt;;  &lt;span class=&quot;hljs-comment&quot;&gt;// same effect&lt;/span&gt;\n*(a+&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;) = &lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt;;  &lt;span class=&quot;hljs-comment&quot;&gt;// same effect&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n    ","\n&lt;p&gt;The array name by itself yields a memory location, so you can treat the array name like a pointer:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; a[&lt;span class=&quot;hljs-number&quot;&gt;7&lt;/span&gt;];\n\na[&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;] = &lt;span class=&quot;hljs-number&quot;&gt;1976&lt;/span&gt;;\na[&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;] = &lt;span class=&quot;hljs-number&quot;&gt;1984&lt;/span&gt;;\n\n&lt;span class=&quot;hljs-built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;memory location of a: %p&quot;&lt;/span&gt;, a);\n\n&lt;span class=&quot;hljs-built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;value at memory location %p is %d&quot;&lt;/span&gt;, a, *a);\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;And other nifty stuff you can do to pointer (e.g. adding/substracting an offset), you can also do to an array:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;value at memory location %p is %d&quot;&lt;/span&gt;, a + &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;, *(a + &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;));\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Language-wise, if C didn&apos;t expose the array as just &lt;strong&gt;some sort of &quot;pointer&quot;&lt;/strong&gt;(pedantically it&apos;s just a memory location. It cannot point to arbitrary location in memory, nor can be controlled by the programmer). We always need to code this:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;value at memory location %p is %d&quot;&lt;/span&gt;, &amp;amp;a[&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;], a[&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;]);\n&lt;/code&gt;&lt;/pre&gt;\n    ","\n&lt;p&gt;I think this example sheds some light on the issue:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt;\n{\n        &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; a[&lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;] = {&lt;span class=&quot;hljs-number&quot;&gt;9&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;11&lt;/span&gt;};\n        &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; **b = &amp;amp;a;\n\n        &lt;span class=&quot;hljs-built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;a == &amp;amp;a: %d\\n&quot;&lt;/span&gt;, a == b);\n        &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;;\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;It compiles fine (with 2 warnings) in gcc 4.9.2, and prints the following:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;a == &amp;amp;a: &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;oops :-)&lt;/p&gt;\n\n&lt;p&gt;So, the conclusion is no, the array is not a pointer, it is not stored in memory (not even read-only one) as a pointer, even though it looks like it is, since you can obtain its address with the &amp;amp; operator. But - oops - that operator does not work :-)), either way, you&apos;ve been warned:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;p.c: In function main:\npp.c:&lt;span class=&quot;hljs-number&quot;&gt;6&lt;/span&gt;:&lt;span class=&quot;hljs-number&quot;&gt;12&lt;/span&gt;: warning: initialization from incompatible pointer type\n  &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; **b = &amp;amp;a;\n            ^\np.c:&lt;span class=&quot;hljs-number&quot;&gt;8&lt;/span&gt;:&lt;span class=&quot;hljs-number&quot;&gt;28&lt;/span&gt;: warning: comparison of distinct pointer types lacks a cast\n  &lt;span class=&quot;hljs-title function_&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;a == &amp;amp;a: %d\\n&quot;&lt;/span&gt;, a == b)&lt;/span&gt;;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;C++ refuses any such attempts with errors in compile-time.&lt;/p&gt;\n\n&lt;p&gt;Edit:&lt;/p&gt;\n\n&lt;p&gt;This is what I meant to demonstrate:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt;\n{\n    &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; a[&lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;] = {&lt;span class=&quot;hljs-number&quot;&gt;9&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;11&lt;/span&gt;};\n    &lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt; *c = a;\n\n    &lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt; *b = &amp;amp;a;\n    &lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt; *d = &amp;amp;c;\n\n    &lt;span class=&quot;hljs-built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;a == &amp;amp;a: %d\\n&quot;&lt;/span&gt;, a == b);\n    &lt;span class=&quot;hljs-built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;c == &amp;amp;c: %d\\n&quot;&lt;/span&gt;, c == d);\n    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;;\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Even though &lt;code&gt;c&lt;/code&gt; and &lt;code&gt;a&lt;/code&gt; &quot;point&quot; to the same memory, you can obtain address of the &lt;code&gt;c&lt;/code&gt; pointer, but you cannot obtain the address of the &lt;code&gt;a&lt;/code&gt; pointer.&lt;/p&gt;\n    ","\n&lt;p&gt;The following example provides a concrete difference between an array name and a pointer. Let say that you want to represent a 1D line with some given maximum dimension, you could do it either with an array or a pointer:&lt;/p&gt;\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;struct&lt;/span&gt; {&lt;/span&gt;\n   &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; length;\n   &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; line_as_array[&lt;span class=&quot;hljs-number&quot;&gt;1000&lt;/span&gt;];\n   &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt;* line_as_pointer;\n} Line;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;Now let&apos;s look at the behavior of the following code:&lt;/p&gt;\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;\n&lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;do_something_with_line&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(Line line)&lt;/span&gt; {\n   line.line_as_pointer[&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;] = &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;;\n   line.line_as_array[&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;] = &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;;\n}\n\n&lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt; {\n   Line my_line;\n   my_line.length = &lt;span class=&quot;hljs-number&quot;&gt;20&lt;/span&gt;;\n   my_line.line_as_pointer = (&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt;*) &lt;span class=&quot;hljs-built_in&quot;&gt;calloc&lt;/span&gt;(my_line.length, &lt;span class=&quot;hljs-keyword&quot;&gt;sizeof&lt;/span&gt;(&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt;));\n\n   my_line.line_as_pointer[&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;] = &lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;;\n   my_line.line_as_array[&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;] = &lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;;\n\n   do_something_with_line(my_line);\n\n   &lt;span class=&quot;hljs-built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;%d %d\\n&quot;&lt;/span&gt;, my_line.line_as_pointer[&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;], my_line.line_as_array[&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;]);\n};\n\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;This code will output:&lt;/p&gt;\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;That is because in the function call to &lt;code&gt;do_something_with_line&lt;/code&gt; the object was copied so:&lt;/p&gt;\n&lt;ol&gt;\n&lt;li&gt;The pointer &lt;code&gt;line_as_pointer&lt;/code&gt; still contains the same address it was pointing to&lt;/li&gt;\n&lt;li&gt;The array &lt;code&gt;line_as_array&lt;/code&gt; was copied to a new address which does not outlive the scope of the function&lt;/li&gt;\n&lt;/ol&gt;\n&lt;p&gt;So while arrays are not given by values when you directly input them to functions, when you encapsulate them in structs they are given by value (i.e. copied) which outlines here a major difference in behavior compared to the implementation using pointers.&lt;/p&gt;\n    ","\n&lt;p&gt;The array name behaves like a pointer and points to the first element of the array. Example:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; a[]={&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;};\n&lt;span class=&quot;hljs-built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;%p\\n&quot;&lt;/span&gt;,a);     &lt;span class=&quot;hljs-comment&quot;&gt;//result is similar to 0x7fff6fe40bc0&lt;/span&gt;\n&lt;span class=&quot;hljs-built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;%p\\n&quot;&lt;/span&gt;,&amp;amp;a[&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;]); &lt;span class=&quot;hljs-comment&quot;&gt;//result is similar to 0x7fff6fe40bc0&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Both the print statements will give exactly same output for a machine. In my system it gave: &lt;/p&gt;\n\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;&lt;span class=&quot;hljs-number&quot;&gt;0x7fff6fe40bc0&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n    ","\n&lt;p&gt;Array name is the address of 1st element of an array. So yes array name is a const pointer.&lt;/p&gt;\n    "],"id":405,"title":"Is an array name a pointer?","content":"\n                \n&lt;p&gt;Is an array&apos;s name a pointer in C?\nIf not, what is the difference between an array&apos;s name and a pointer variable?&lt;/p&gt;\n    ","slug":"is-an-array-name-a-pointer-1657387874827","postType":"QUESTION","createdAt":"2022-07-09T17:31:14.000Z","updatedAt":"2022-07-09T17:31:14.000Z","tags":[],"relatedQuestions":[]},"randomQuestions":[{"title":"How to add to the PYTHONPATH in Windows, so it finds my modules/packages?","slug":"how-to-add-to-the-pythonpath-in-windows-so-it-finds-my-modulespackages-1657388540360"},{"title":"How do I give text or an image a transparent background using CSS?","slug":"how-do-i-give-text-or-an-image-a-transparent-background-using-css-1657388188508"},{"title":"Can PHP PDO Statements accept the table or column name as parameter?","slug":"can-php-pdo-statements-accept-the-table-or-column-name-as-parameter-1657387478588"},{"title":"addEventListener vs onclick","slug":"addeventlistener-vs-onclick-1657388191429"},{"title":"Dynamically select data frame columns using $ and a character value","slug":"dynamically-select-data-frame-columns-using-dollar-and-a-character-value-1657387836662"},{"title":"Methods in ES6 objects: using arrow functions","slug":"methods-in-es6-objects:-using-arrow-functions-1657388249058"},{"title":"The useState set method is not reflecting a change immediately","slug":"the-usestate-set-method-is-not-reflecting-a-change-immediately-1657384524775"},{"title":"Int division: Why is the result of 1/3 == 0?","slug":"int-division:-why-is-the-result-of-13-0-1657387547814"},{"title":"Why should I not #include <bits/stdc++.h>?","slug":"why-should-i-not-include-lessbitsstdc++.hgreater-1657384470484"},{"title":"How to avoid having class data shared among instances?","slug":"how-to-avoid-having-class-data-shared-among-instances-1657387687732"},{"title":"Actual meaning of 'shell=True' in subprocess","slug":"actual-meaning-of-'shelltrue'-in-subprocess-1657388470341"},{"title":"$(document).ready equivalent without jQuery","slug":"dollar(document).ready-equivalent-without-jquery-1657388504115"},{"title":"Safely turning a JSON string into an object","slug":"safely-turning-a-json-string-into-an-object-1657388194824"},{"title":"What does if __name__ == \"__main__\": do?","slug":"what-does-if-__name__-\"__main__\":-do-1657384825815"},{"title":"Using async/await with a forEach loop","slug":"using-asyncawait-with-a-foreach-loop-1657384512667"},{"title":"PHP code is not being executed, but the code shows in the browser source code","slug":"php-code-is-not-being-executed-but-the-code-shows-in-the-browser-source-code-1657384553581"},{"title":"Deserialize JSON into C# dynamic object?","slug":"deserialize-json-into-c-dynamic-object-1657388568720"},{"title":"What is the !! (not not) operator in JavaScript?","slug":"what-is-the-!!-(not-not)-operator-in-javascript-1657387947844"},{"title":"Why don't flex items shrink past content size?","slug":"why-don't-flex-items-shrink-past-content-size-1657384687282"},{"title":"How to determine equality for two JavaScript objects?","slug":"how-to-determine-equality-for-two-javascript-objects-1657387638650"}]},"__N_SSG":true}