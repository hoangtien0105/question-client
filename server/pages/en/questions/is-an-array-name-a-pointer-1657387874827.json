{"pageProps":{"data":{"answer":["\n&lt;p&gt;An array is an array and a pointer is a pointer, but in most cases array names are &lt;em&gt;converted&lt;/em&gt; to pointers. A term often used is that they &lt;em&gt;decay&lt;/em&gt; to pointers.&lt;/p&gt;\n\n&lt;p&gt;Here is an array:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; a[&lt;span class=&quot;hljs-number&quot;&gt;7&lt;/span&gt;];\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;&lt;code&gt;a&lt;/code&gt; contains space for seven integers, and you can put a value in one of them with an assignment, like this:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;a[&lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;] = &lt;span class=&quot;hljs-number&quot;&gt;9&lt;/span&gt;;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Here is a pointer:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; *p;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;&lt;code&gt;p&lt;/code&gt; doesn&apos;t contain any spaces for integers, but it can point to a space for an integer. We can, for example, set it to point to one of the places in the array &lt;code&gt;a&lt;/code&gt;, such as the first one:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;p = &amp;amp;a[&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;];\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;What can be confusing is that you can also write this:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;p = a;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;This does &lt;em&gt;not&lt;/em&gt; copy the contents of the array &lt;code&gt;a&lt;/code&gt; into the pointer &lt;code&gt;p&lt;/code&gt; (whatever that would mean). Instead, the array name &lt;code&gt;a&lt;/code&gt; is converted to a pointer to its first element. So that assignment does the same as the previous one.&lt;/p&gt;\n\n&lt;p&gt;Now you can use &lt;code&gt;p&lt;/code&gt; in a similar way to an array:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;p[&lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;] = &lt;span class=&quot;hljs-number&quot;&gt;17&lt;/span&gt;;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;The reason that this works is that the array dereferencing operator in C, &lt;code&gt;[ ]&lt;/code&gt;, is defined in terms of pointers. &lt;code&gt;x[y]&lt;/code&gt; means: start with the pointer &lt;code&gt;x&lt;/code&gt;, step &lt;code&gt;y&lt;/code&gt; elements forward after what the pointer points to, and then take whatever is there. Using pointer arithmetic syntax, &lt;code&gt;x[y]&lt;/code&gt; can also be written as &lt;code&gt;*(x+y)&lt;/code&gt;.&lt;/p&gt;\n\n&lt;p&gt;For this to work with a normal array, such as our &lt;code&gt;a&lt;/code&gt;, the name &lt;code&gt;a&lt;/code&gt; in &lt;code&gt;a[3]&lt;/code&gt; must first be converted to a pointer (to the first element in &lt;code&gt;a&lt;/code&gt;). Then we step 3 elements forward, and take whatever is there. In other words: take the element at position 3 in the array. (Which is the fourth element in the array, since the first one is numbered 0.)&lt;/p&gt;\n\n&lt;p&gt;So, in summary, array names in a C program are (in most cases) converted to pointers. One exception is when we use the &lt;code&gt;sizeof&lt;/code&gt; operator on an array. If &lt;code&gt;a&lt;/code&gt; was converted to a pointer in this context, &lt;code&gt;sizeof a&lt;/code&gt; would give the size of a pointer and not of the actual array, which would be rather useless, so in that case &lt;code&gt;a&lt;/code&gt; means the array itself.&lt;/p&gt;\n    ","\n&lt;p&gt;When an array is used as a value, its name represents the address of the first element.&lt;br&gt;\nWhen an array is not used as a value its name represents the whole array.&lt;/p&gt;\n\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; arr[&lt;span class=&quot;hljs-number&quot;&gt;7&lt;/span&gt;];\n\n&lt;span class=&quot;hljs-comment&quot;&gt;/* arr used as value */&lt;/span&gt;\nfoo(arr);\n&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; x = *(arr + &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;); &lt;span class=&quot;hljs-comment&quot;&gt;/* same as arr[1] */&lt;/span&gt;\n\n&lt;span class=&quot;hljs-comment&quot;&gt;/* arr not used as value */&lt;/span&gt;\n&lt;span class=&quot;hljs-type&quot;&gt;size_t&lt;/span&gt; bytes = &lt;span class=&quot;hljs-keyword&quot;&gt;sizeof&lt;/span&gt; arr;\n&lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt; *q = &amp;amp;arr; &lt;span class=&quot;hljs-comment&quot;&gt;/* void pointers are compatible with pointers to any object */&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n    ","\n&lt;p&gt;If an expression of array type (such as the array name) appears in a larger expression and it isn&apos;t the operand of either the &lt;code&gt;&amp;amp;&lt;/code&gt; or &lt;code&gt;sizeof&lt;/code&gt; operators, then the type of the array expression is converted from &quot;N-element array of T&quot; to &quot;pointer to T&quot;, and the value of the expression is the address of the first element in the array.  &lt;/p&gt;\n\n&lt;p&gt;In short, the array name is not a pointer, but in most contexts it is treated &lt;em&gt;as though&lt;/em&gt; it were a pointer.  &lt;/p&gt;\n\n&lt;p&gt;&lt;strong&gt;Edit&lt;/strong&gt;&lt;/p&gt;\n\n&lt;p&gt;Answering the question in the comment:&lt;/p&gt;\n\n&lt;blockquote&gt;\n  &lt;p&gt;If I use sizeof, do i count the size of only the elements of the array? Then the array head also takes up space with the information about length and a pointer (and this means that it takes more space, than a normal pointer would)?&lt;/p&gt;\n&lt;/blockquote&gt;\n\n&lt;p&gt;When you create an array, the only space that&apos;s allocated is the space for the elements themselves; no storage is materialized for a separate pointer or any metadata.  Given&lt;/p&gt;\n\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;char&lt;/span&gt; a[&lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;];\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;what you get in memory is&lt;/p&gt;\n\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;   +---+\na: |   | a[&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;]\n   +---+ \n   |   | a[&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;]\n   +---+\n   |   | a[&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;]\n   +---+\n    ...\n   +---+\n   |   | a[&lt;span class=&quot;hljs-number&quot;&gt;9&lt;/span&gt;]\n   +---+\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;The &lt;em&gt;expression&lt;/em&gt; &lt;code&gt;a&lt;/code&gt; refers to the entire array, but there&apos;s no &lt;em&gt;object&lt;/em&gt; &lt;code&gt;a&lt;/code&gt; separate from the array elements themselves.  Thus, &lt;code&gt;sizeof a&lt;/code&gt; gives you the size (in bytes) of the entire array.  The expression &lt;code&gt;&amp;amp;a&lt;/code&gt; gives you the address of the array, &lt;em&gt;which is the same as the address of the first element&lt;/em&gt;.  The difference between &lt;code&gt;&amp;amp;a&lt;/code&gt; and &lt;code&gt;&amp;amp;a[0]&lt;/code&gt; is the type of the result&lt;sup&gt;1&lt;/sup&gt; - &lt;code&gt;char (*)[10]&lt;/code&gt; in the first case and &lt;code&gt;char *&lt;/code&gt; in the second.  &lt;/p&gt;\n\n&lt;p&gt;Where things get weird is when you want to access individual elements - the expression &lt;code&gt;a[i]&lt;/code&gt; is defined as the result of &lt;code&gt;*(a + i)&lt;/code&gt; - given an address value &lt;code&gt;a&lt;/code&gt;, offset &lt;code&gt;i&lt;/code&gt; elements (&lt;em&gt;not bytes&lt;/em&gt;) from that address and dereference the result.&lt;/p&gt;\n\n&lt;p&gt;The problem is that &lt;code&gt;a&lt;/code&gt; isn&apos;t a pointer or an address - it&apos;s the entire array object.  Thus, the rule in C that whenever the compiler sees an expression of array type (such as &lt;code&gt;a&lt;/code&gt;, which has type &lt;code&gt;char [10]&lt;/code&gt;) &lt;em&gt;and&lt;/em&gt; that expression isn&apos;t the operand of the &lt;code&gt;sizeof&lt;/code&gt; or unary &lt;code&gt;&amp;amp;&lt;/code&gt; operators, the type of that expression is converted (&quot;decays&quot;) to a pointer type (&lt;code&gt;char *&lt;/code&gt;), and the value of the expression is the address of the first element of the array.  Therefore, the &lt;em&gt;expression&lt;/em&gt; &lt;code&gt;a&lt;/code&gt; has the same type and value as the expression &lt;code&gt;&amp;amp;a[0]&lt;/code&gt; (and by extension, the expression &lt;code&gt;*a&lt;/code&gt; has the same type and value as the expression &lt;code&gt;a[0]&lt;/code&gt;).  &lt;/p&gt;\n\n&lt;p&gt;C was derived from an earlier language called B, and in B &lt;code&gt;a&lt;/code&gt; &lt;em&gt;was&lt;/em&gt; a separate pointer object from the array elements &lt;code&gt;a[0]&lt;/code&gt;, &lt;code&gt;a[1]&lt;/code&gt;, etc.  Ritchie wanted to keep B&apos;s array semantics, but he didn&apos;t want to mess with storing the separate pointer object.  So he got rid of it.  Instead, the compiler will convert array expressions to pointer expressions during translation as necessary.  &lt;/p&gt;\n\n&lt;p&gt;Remember that I said arrays don&apos;t store any metadata about their size.  As soon as that array expression &quot;decays&quot; to a pointer, all you have is a pointer to a single element.  That element may be the first of a sequence of elements, or it may be a single object.  There&apos;s no way to know based on the pointer itself.  &lt;/p&gt;\n\n&lt;p&gt;When you pass an array expression to a function, all the function receives is a pointer to the first element - it has no idea how big the array is (this is why the &lt;code&gt;gets&lt;/code&gt; function was such a menace and was eventually removed from the library).  For the function to know how many elements the array has, you must either use a sentinel value (such as the 0 terminator in C strings) or you must pass the number of elements as a separate parameter.  &lt;/p&gt;\n\n&lt;hr&gt;\n\n&lt;ol&gt;\n&lt;sup&gt;&lt;li&gt;Which *may* affect how the address value is interpreted - depends on the machine.&lt;/li&gt;&lt;/sup&gt;\n&lt;/ol&gt;\n    ","\n&lt;p&gt;An array declared like this&lt;/p&gt;\n\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; a[&lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;];\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;allocates memory for 10 &lt;code&gt;int&lt;/code&gt;s. You can&apos;t modify &lt;code&gt;a&lt;/code&gt; but you can do pointer arithmetic with &lt;code&gt;a&lt;/code&gt;.&lt;/p&gt;\n\n&lt;p&gt;A pointer like this allocates memory for just the pointer &lt;code&gt;p&lt;/code&gt;:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; *p;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;It doesn&apos;t allocate any &lt;code&gt;int&lt;/code&gt;s. You can modify it:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;p = a;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;and use array subscripts as you can with a:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;p[&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;] = &lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt;;\na[&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;] = &lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt;;    &lt;span class=&quot;hljs-comment&quot;&gt;// same&lt;/span&gt;\n*(p+&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;) = &lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt;;  &lt;span class=&quot;hljs-comment&quot;&gt;// same effect&lt;/span&gt;\n*(a+&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;) = &lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt;;  &lt;span class=&quot;hljs-comment&quot;&gt;// same effect&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n    ","\n&lt;p&gt;The array name by itself yields a memory location, so you can treat the array name like a pointer:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; a[&lt;span class=&quot;hljs-number&quot;&gt;7&lt;/span&gt;];\n\na[&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;] = &lt;span class=&quot;hljs-number&quot;&gt;1976&lt;/span&gt;;\na[&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;] = &lt;span class=&quot;hljs-number&quot;&gt;1984&lt;/span&gt;;\n\n&lt;span class=&quot;hljs-built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;memory location of a: %p&quot;&lt;/span&gt;, a);\n\n&lt;span class=&quot;hljs-built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;value at memory location %p is %d&quot;&lt;/span&gt;, a, *a);\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;And other nifty stuff you can do to pointer (e.g. adding/substracting an offset), you can also do to an array:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;value at memory location %p is %d&quot;&lt;/span&gt;, a + &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;, *(a + &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;));\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Language-wise, if C didn&apos;t expose the array as just &lt;strong&gt;some sort of &quot;pointer&quot;&lt;/strong&gt;(pedantically it&apos;s just a memory location. It cannot point to arbitrary location in memory, nor can be controlled by the programmer). We always need to code this:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;value at memory location %p is %d&quot;&lt;/span&gt;, &amp;amp;a[&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;], a[&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;]);\n&lt;/code&gt;&lt;/pre&gt;\n    ","\n&lt;p&gt;I think this example sheds some light on the issue:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt;\n{\n        &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; a[&lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;] = {&lt;span class=&quot;hljs-number&quot;&gt;9&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;11&lt;/span&gt;};\n        &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; **b = &amp;amp;a;\n\n        &lt;span class=&quot;hljs-built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;a == &amp;amp;a: %d\\n&quot;&lt;/span&gt;, a == b);\n        &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;;\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;It compiles fine (with 2 warnings) in gcc 4.9.2, and prints the following:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;a == &amp;amp;a: &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;oops :-)&lt;/p&gt;\n\n&lt;p&gt;So, the conclusion is no, the array is not a pointer, it is not stored in memory (not even read-only one) as a pointer, even though it looks like it is, since you can obtain its address with the &amp;amp; operator. But - oops - that operator does not work :-)), either way, you&apos;ve been warned:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;p.c: In function main:\npp.c:&lt;span class=&quot;hljs-number&quot;&gt;6&lt;/span&gt;:&lt;span class=&quot;hljs-number&quot;&gt;12&lt;/span&gt;: warning: initialization from incompatible pointer type\n  &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; **b = &amp;amp;a;\n            ^\np.c:&lt;span class=&quot;hljs-number&quot;&gt;8&lt;/span&gt;:&lt;span class=&quot;hljs-number&quot;&gt;28&lt;/span&gt;: warning: comparison of distinct pointer types lacks a cast\n  &lt;span class=&quot;hljs-title function_&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;a == &amp;amp;a: %d\\n&quot;&lt;/span&gt;, a == b)&lt;/span&gt;;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;C++ refuses any such attempts with errors in compile-time.&lt;/p&gt;\n\n&lt;p&gt;Edit:&lt;/p&gt;\n\n&lt;p&gt;This is what I meant to demonstrate:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt;\n{\n    &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; a[&lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;] = {&lt;span class=&quot;hljs-number&quot;&gt;9&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;11&lt;/span&gt;};\n    &lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt; *c = a;\n\n    &lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt; *b = &amp;amp;a;\n    &lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt; *d = &amp;amp;c;\n\n    &lt;span class=&quot;hljs-built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;a == &amp;amp;a: %d\\n&quot;&lt;/span&gt;, a == b);\n    &lt;span class=&quot;hljs-built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;c == &amp;amp;c: %d\\n&quot;&lt;/span&gt;, c == d);\n    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;;\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Even though &lt;code&gt;c&lt;/code&gt; and &lt;code&gt;a&lt;/code&gt; &quot;point&quot; to the same memory, you can obtain address of the &lt;code&gt;c&lt;/code&gt; pointer, but you cannot obtain the address of the &lt;code&gt;a&lt;/code&gt; pointer.&lt;/p&gt;\n    ","\n&lt;p&gt;The following example provides a concrete difference between an array name and a pointer. Let say that you want to represent a 1D line with some given maximum dimension, you could do it either with an array or a pointer:&lt;/p&gt;\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;struct&lt;/span&gt; {&lt;/span&gt;\n   &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; length;\n   &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; line_as_array[&lt;span class=&quot;hljs-number&quot;&gt;1000&lt;/span&gt;];\n   &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt;* line_as_pointer;\n} Line;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;Now let&apos;s look at the behavior of the following code:&lt;/p&gt;\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;\n&lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;do_something_with_line&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(Line line)&lt;/span&gt; {\n   line.line_as_pointer[&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;] = &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;;\n   line.line_as_array[&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;] = &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;;\n}\n\n&lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt; {\n   Line my_line;\n   my_line.length = &lt;span class=&quot;hljs-number&quot;&gt;20&lt;/span&gt;;\n   my_line.line_as_pointer = (&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt;*) &lt;span class=&quot;hljs-built_in&quot;&gt;calloc&lt;/span&gt;(my_line.length, &lt;span class=&quot;hljs-keyword&quot;&gt;sizeof&lt;/span&gt;(&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt;));\n\n   my_line.line_as_pointer[&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;] = &lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;;\n   my_line.line_as_array[&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;] = &lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;;\n\n   do_something_with_line(my_line);\n\n   &lt;span class=&quot;hljs-built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;%d %d\\n&quot;&lt;/span&gt;, my_line.line_as_pointer[&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;], my_line.line_as_array[&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;]);\n};\n\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;This code will output:&lt;/p&gt;\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;That is because in the function call to &lt;code&gt;do_something_with_line&lt;/code&gt; the object was copied so:&lt;/p&gt;\n&lt;ol&gt;\n&lt;li&gt;The pointer &lt;code&gt;line_as_pointer&lt;/code&gt; still contains the same address it was pointing to&lt;/li&gt;\n&lt;li&gt;The array &lt;code&gt;line_as_array&lt;/code&gt; was copied to a new address which does not outlive the scope of the function&lt;/li&gt;\n&lt;/ol&gt;\n&lt;p&gt;So while arrays are not given by values when you directly input them to functions, when you encapsulate them in structs they are given by value (i.e. copied) which outlines here a major difference in behavior compared to the implementation using pointers.&lt;/p&gt;\n    ","\n&lt;p&gt;The array name behaves like a pointer and points to the first element of the array. Example:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; a[]={&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;};\n&lt;span class=&quot;hljs-built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;%p\\n&quot;&lt;/span&gt;,a);     &lt;span class=&quot;hljs-comment&quot;&gt;//result is similar to 0x7fff6fe40bc0&lt;/span&gt;\n&lt;span class=&quot;hljs-built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;%p\\n&quot;&lt;/span&gt;,&amp;amp;a[&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;]); &lt;span class=&quot;hljs-comment&quot;&gt;//result is similar to 0x7fff6fe40bc0&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Both the print statements will give exactly same output for a machine. In my system it gave: &lt;/p&gt;\n\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;&lt;span class=&quot;hljs-number&quot;&gt;0x7fff6fe40bc0&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n    ","\n&lt;p&gt;Array name is the address of 1st element of an array. So yes array name is a const pointer.&lt;/p&gt;\n    "],"id":405,"title":"Is an array name a pointer?","content":"\n                \n&lt;p&gt;Is an array&apos;s name a pointer in C?\nIf not, what is the difference between an array&apos;s name and a pointer variable?&lt;/p&gt;\n    ","slug":"is-an-array-name-a-pointer-1657387874827","postType":"QUESTION","createdAt":"2022-07-09T17:31:14.000Z","updatedAt":"2022-07-09T17:31:14.000Z","tags":[],"relatedQuestions":[]},"randomQuestions":[{"title":"Download a file by jQuery.Ajax","slug":"download-a-file-by-jquery.ajax-1657388220611"},{"title":"How can I read and parse CSV files in C++?","slug":"how-can-i-read-and-parse-csv-files-in-c++-1657387869219"},{"title":"How do I make Git forget about a file that was tracked, but is now in .gitignore?","slug":"how-do-i-make-git-forget-about-a-file-that-was-tracked-but-is-now-in-.gitignore-1657387328843"},{"title":"Using regular expressions to parse HTML: why not?","slug":"using-regular-expressions-to-parse-html:-why-not-1657387543969"},{"title":"Flatten an irregular list of lists","slug":"flatten-an-irregular-list-of-lists-1657387315571"},{"title":"Trouble with UTF-8 characters; what I see is not what I stored","slug":"trouble-with-utf-8-characters-what-i-see-is-not-what-i-stored-1657384817490"},{"title":"How do I detect a click outside an element?","slug":"how-do-i-detect-a-click-outside-an-element-1657387505351"},{"title":"What's the simplest way to print a Java array?","slug":"what's-the-simplest-way-to-print-a-java-array-1657384702397"},{"title":"How can I remove a specific item from an array?","slug":"how-can-i-remove-a-specific-item-from-an-array-1657387552077"},{"title":"event.preventDefault() vs. return false","slug":"event.preventdefault()-vs.-return-false-1657387458377"},{"title":"How can I avoid Java code in JSP files, using JSP 2?","slug":"how-can-i-avoid-java-code-in-jsp-files-using-jsp-2-1657384618866"},{"title":"What are copy elision and return value optimization?","slug":"what-are-copy-elision-and-return-value-optimization-1657385455976"},{"title":"How do I use extern to share variables between source files?","slug":"how-do-i-use-extern-to-share-variables-between-source-files-1657387453605"},{"title":"How do I clone a list so that it doesn't change unexpectedly after assignment?","slug":"how-do-i-clone-a-list-so-that-it-doesn't-change-unexpectedly-after-assignment-1657384423195"},{"title":"mysqli or die, does it have to die?","slug":"mysqli-or-die-does-it-have-to-die-1657388533922"},{"title":"Random number generator only generating one random number","slug":"random-number-generator-only-generating-one-random-number-1657385468315"},{"title":"How to replace all occurrences of a string in JavaScript","slug":"how-to-replace-all-occurrences-of-a-string-in-javascript-1657384895467"},{"title":"Big O, how do you calculate/approximate it?","slug":"big-o-how-do-you-calculateapproximate-it-1657387856392"},{"title":"What is the difference between single-quoted and double-quoted strings in PHP?","slug":"what-is-the-difference-between-single-quoted-and-double-quoted-strings-in-php-1657384624345"},{"title":"How to create a MySQL hierarchical recursive query?","slug":"how-to-create-a-mysql-hierarchical-recursive-query-1657387662163"}]},"__N_SSG":true}