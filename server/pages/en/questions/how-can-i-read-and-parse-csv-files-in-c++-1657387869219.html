<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><meta name="twitter:card" content="summary_large_image"/><meta name="twitter:site" content="@solutionschecker.com"/><meta name="twitter:creator" content="@solutionschecker.com"/><meta property="og:url" content="https://solutionschecker.com"/><meta property="og:type" content="website"/><meta property="og:image" content="https://solutionschecker.com/solutions-checker-banner.png"/><meta property="og:image:alt" content="Find the solution to any question. We focus on finding the fastest possible solution for users. Main topics like coding, learning. - solutionschecker.com"/><link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png"/><link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png"/><link rel="manifest" href="/site.webmanifest"/><script type="application/ld+json">{"@context":"https://schema.org","@type":"Organization","logo":"/logo.svg","url":"https://solutionschecker.com"}</script><link name="keywords" content="text,csv,solutions checker, solution checker, how to, solution for, check for solution, resolve question, what is, what solution for, find solution"/><script type="application/ld+json">{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"item":{"@id":"https://solutionschecker.com","name":"Home"}},{"@type":"ListItem","position":2,"item":{"@id":"https://solutionschecker.com/questions","name":"Questions"}},{"@type":"ListItem","position":3,"item":{"@id":"https://solutionschecker.com/questions/how-can-i-read-and-parse-csv-files-in-c++-1657387869219","name":"Questions"}}]}</script><title>How can I read and parse CSV files in C++? | Solution Checker</title><meta name="robots" content="index,follow"/><meta name="description" content="I need to load and use CSV file data in C++.  At this point it can really just be a comma-delimited parser (ie don&#x27;t worry about escaping new lines and commas).  The main need is a line-by-line parser that will return a vector for the next line each time the method is called.

I found this article which looks quite promising:
http://www.boost.org/doc/libs/1_35_0/libs/spirit/example/fundamental/list_parser.cpp

I&#x27;ve never used Boost&#x27;s Spirit, but am willing to try it. But only if there isn&#x27;t a more straightforward solution I&#x27;m overlooking.
    "/><meta property="og:title" content="How can I read and parse CSV files in C++? | Solution Checker"/><meta property="og:description" content="I need to load and use CSV file data in C++.  At this point it can really just be a comma-delimited parser (ie don&#x27;t worry about escaping new lines and commas).  The main need is a line-by-line parser that will return a vector for the next line each time the method is called.

I found this article which looks quite promising:
http://www.boost.org/doc/libs/1_35_0/libs/spirit/example/fundamental/list_parser.cpp

I&#x27;ve never used Boost&#x27;s Spirit, but am willing to try it. But only if there isn&#x27;t a more straightforward solution I&#x27;m overlooking.
    "/><script type="application/ld+json">{"@context":"https://schema.org","@type":"QAPage","mainEntity":{"name":"How can I read and parse CSV files in C++?","text":"I need to load and use CSV file data in C++.  At this point it can really just be a comma-delimited parser (ie don&apos;t worry about escaping new lines and commas).  The main need is a line-by-line parser that will return a vector for the next line each time the method is called.\n\nI found this article which looks quite promising:\nhttp://www.boost.org/doc/libs/1_35_0/libs/spirit/example/fundamental/list_parser.cpp\n\nI&apos;ve never used Boost&apos;s Spirit, but am willing to try it. But only if there isn&apos;t a more straightforward solution I&apos;m overlooking.\n    ","answerCount":30,"upVoteCount":500,"suggestedAnswer":[{"text":"If you don&apos;t care about escaping comma and newline,\nAND you can&apos;t embed comma and newline in quotes (If you can&apos;t escape then...)\nthen its only about three lines of code (OK 14 -&gt;But its only 15 to read the whole file).\nstd::vector&lt;std::string&gt; getNextLineAndSplitIntoTokens(std::istream&amp; str)\n{\n    std::vector&lt;std::string&gt;   result;\n    std::string                line;\n    std::getline(str,line);\n\n    std::stringstream          lineStream(line);\n    std::string                cell;\n\n    while(std::getline(lineStream,cell, &apos;,&apos;))\n    {\n        result.push_back(cell);\n    }\n    // This checks for a trailing comma with no data after it.\n    if (!lineStream &amp;&amp; cell.empty())\n    {\n        // If there was a trailing comma then add an empty element.\n        result.push_back(&quot;&quot;);\n    }\n    return result;\n}\n\nI would just create a class representing a row.\nThen stream into that object:\n#include &lt;iterator&gt;\n#include &lt;iostream&gt;\n#include &lt;fstream&gt;\n#include &lt;sstream&gt;\n#include &lt;vector&gt;\n#include &lt;string&gt;\n\nclass CSVRow\n{\n    public:\n        std::string_view operator[](std::size_t index) const\n        {\n            return std::string_view(&amp;m_line[m_data[index] + 1], m_data[index + 1] -  (m_data[index] + 1));\n        }\n        std::size_t size() const\n        {\n            return m_data.size() - 1;\n        }\n        void readNextRow(std::istream&amp; str)\n        {\n            std::getline(str, m_line);\n\n            m_data.clear();\n            m_data.emplace_back(-1);\n            std::string::size_type pos = 0;\n            while((pos = m_line.find(&apos;,&apos;, pos)) != std::string::npos)\n            {\n                m_data.emplace_back(pos);\n                ++pos;\n            }\n            // This checks for a trailing comma with no data after it.\n            pos   = m_line.size();\n            m_data.emplace_back(pos);\n        }\n    private:\n        std::string         m_line;\n        std::vector&lt;int&gt;    m_data;\n};\n\nstd::istream&amp; operator&gt;&gt;(std::istream&amp; str, CSVRow&amp; data)\n{\n    data.readNextRow(str);\n    return str;\n}   \nint main()\n{\n    std::ifstream       file(&quot;plop.csv&quot;);\n\n    CSVRow              row;\n    while(file &gt;&gt; row)\n    {\n        std::cout &lt;&lt; &quot;4th Element(&quot; &lt;&lt; row[3] &lt;&lt; &quot;)\\n&quot;;\n    }\n}\n\nBut with a little work we could technically create an iterator:\nclass CSVIterator\n{   \n    public:\n        typedef std::input_iterator_tag     iterator_category;\n        typedef CSVRow                      value_type;\n        typedef std::size_t                 difference_type;\n        typedef CSVRow*                     pointer;\n        typedef CSVRow&amp;                     reference;\n\n        CSVIterator(std::istream&amp; str)  :m_str(str.good()?&amp;str:nullptr) { ++(*this); }\n        CSVIterator()                   :m_str(nullptr) {}\n\n        // Pre Increment\n        CSVIterator&amp; operator++()               {if (m_str) { if (!((*m_str) &gt;&gt; m_row)){m_str = nullptr;}}return *this;}\n        // Post increment\n        CSVIterator operator++(int)             {CSVIterator    tmp(*this);++(*this);return tmp;}\n        CSVRow const&amp; operator*()   const       {return m_row;}\n        CSVRow const* operator-&gt;()  const       {return &amp;m_row;}\n\n        bool operator==(CSVIterator const&amp; rhs) {return ((this == &amp;rhs) || ((this-&gt;m_str == nullptr) &amp;&amp; (rhs.m_str == nullptr)));}\n        bool operator!=(CSVIterator const&amp; rhs) {return !((*this) == rhs);}\n    private:\n        std::istream*       m_str;\n        CSVRow              m_row;\n};\n\n\nint main()\n{\n    std::ifstream       file(&quot;plop.csv&quot;);\n\n    for(CSVIterator loop(file); loop != CSVIterator(); ++loop)\n    {\n        std::cout &lt;&lt; &quot;4th Element(&quot; &lt;&lt; (*loop)[3] &lt;&lt; &quot;)\\n&quot;;\n    }\n}\n\nNow that we are in 2020 lets add a CSVRange object:\nclass CSVRange\n{\n    std::istream&amp;   stream;\n    public:\n        CSVRange(std::istream&amp; str)\n            : stream(str)\n        {}\n        CSVIterator begin() const {return CSVIterator{stream};}\n        CSVIterator end()   const {return CSVIterator{};}\n};\n\nint main()\n{\n    std::ifstream       file(&quot;plop.csv&quot;);\n\n    for(auto&amp; row: CSVRange(file))\n    {\n        std::cout &lt;&lt; &quot;4th Element(&quot; &lt;&lt; row[3] &lt;&lt; &quot;)\\n&quot;;\n    }\n}\n\n    ","url":"https://solutionschecker.com/questions/how-can-i-read-and-parse-csv-files-in-c++-1657387869219#solution1","@type":"Answer","upvoteCount":0},{"text":"My version is not using anything but the standard C++11 library. It copes well with Excel CSV quotation:\n\nspam eggs,&quot;foo,bar&quot;,&quot;&quot;&quot;fizz buzz&quot;&quot;&quot;\n1.23,4.567,-8.00E+09\n\n\nThe code is written as a finite-state machine and is consuming one character at a time. I think it&apos;s easier to reason about.\n\n#include &lt;istream&gt;\n#include &lt;string&gt;\n#include &lt;vector&gt;\n\nenum class CSVState {\n    UnquotedField,\n    QuotedField,\n    QuotedQuote\n};\n\nstd::vector&lt;std::string&gt; readCSVRow(const std::string &amp;row) {\n    CSVState state = CSVState::UnquotedField;\n    std::vector&lt;std::string&gt; fields {&quot;&quot;};\n    size_t i = 0; // index of the current field\n    for (char c : row) {\n        switch (state) {\n            case CSVState::UnquotedField:\n                switch (c) {\n                    case &apos;,&apos;: // end of field\n                              fields.push_back(&quot;&quot;); i++;\n                              break;\n                    case &apos;&quot;&apos;: state = CSVState::QuotedField;\n                              break;\n                    default:  fields[i].push_back(c);\n                              break; }\n                break;\n            case CSVState::QuotedField:\n                switch (c) {\n                    case &apos;&quot;&apos;: state = CSVState::QuotedQuote;\n                              break;\n                    default:  fields[i].push_back(c);\n                              break; }\n                break;\n            case CSVState::QuotedQuote:\n                switch (c) {\n                    case &apos;,&apos;: // , after closing quote\n                              fields.push_back(&quot;&quot;); i++;\n                              state = CSVState::UnquotedField;\n                              break;\n                    case &apos;&quot;&apos;: // &quot;&quot; -&gt; &quot;\n                              fields[i].push_back(&apos;&quot;&apos;);\n                              state = CSVState::QuotedField;\n                              break;\n                    default:  // end of quote\n                              state = CSVState::UnquotedField;\n                              break; }\n                break;\n        }\n    }\n    return fields;\n}\n\n/// Read CSV file, Excel dialect. Accept &quot;quoted fields &quot;&quot;with quotes&quot;&quot;&quot;\nstd::vector&lt;std::vector&lt;std::string&gt;&gt; readCSV(std::istream &amp;in) {\n    std::vector&lt;std::vector&lt;std::string&gt;&gt; table;\n    std::string row;\n    while (!in.eof()) {\n        std::getline(in, row);\n        if (in.bad() || in.fail()) {\n            break;\n        }\n        auto fields = readCSVRow(row);\n        table.push_back(fields);\n    }\n    return table;\n}\n\n    ","url":"https://solutionschecker.com/questions/how-can-i-read-and-parse-csv-files-in-c++-1657387869219#solution2","@type":"Answer","upvoteCount":0},{"text":"Solution using Boost Tokenizer:\n\nstd::vector&lt;std::string&gt; vec;\nusing namespace boost;\ntokenizer&lt;escaped_list_separator&lt;char&gt; &gt; tk(\n   line, escaped_list_separator&lt;char&gt;(&apos;\\\\&apos;, &apos;,&apos;, &apos;\\&quot;&apos;));\nfor (tokenizer&lt;escaped_list_separator&lt;char&gt; &gt;::iterator i(tk.begin());\n   i!=tk.end();++i) \n{\n   vec.push_back(*i);\n}\n\n    ","url":"https://solutionschecker.com/questions/how-can-i-read-and-parse-csv-files-in-c++-1657387869219#solution3","@type":"Answer","upvoteCount":0},{"text":"The C++ String Toolkit Library (StrTk) has a token grid class that allows you to load data either from text files, strings or char buffers, and to parse/process them in a row-column fashion.\n\nYou can specify the row delimiters and column delimiters or just use the defaults.\n\nvoid foo()\n{\n   std::string data = &quot;1,2,3,4,5\\n&quot;\n                      &quot;0,2,4,6,8\\n&quot;\n                      &quot;1,3,5,7,9\\n&quot;;\n\n   strtk::token_grid grid(data,data.size(),&quot;,&quot;);\n\n   for(std::size_t i = 0; i &lt; grid.row_count(); ++i)\n   {\n      strtk::token_grid::row_type r = grid.row(i);\n      for(std::size_t j = 0; j &lt; r.size(); ++j)\n      {\n         std::cout &lt;&lt; r.get&lt;int&gt;(j) &lt;&lt; &quot;\\t&quot;;\n      }\n      std::cout &lt;&lt; std::endl;\n   }\n   std::cout &lt;&lt; std::endl;\n}\n\n\nMore examples can be found Here\n    ","url":"https://solutionschecker.com/questions/how-can-i-read-and-parse-csv-files-in-c++-1657387869219#solution4","@type":"Answer","upvoteCount":0},{"text":"You can use Boost Tokenizer with escaped_list_separator.\n\nescaped_list_separator parses a superset of the csv. Boost::tokenizer\n\nThis only uses Boost tokenizer header files, no linking to boost libraries required.\nHere is an example, (see Parse CSV File With Boost Tokenizer In C++ for details or Boost::tokenizer ):\n#include &lt;iostream&gt;     // cout, endl\n#include &lt;fstream&gt;      // fstream\n#include &lt;vector&gt;\n#include &lt;string&gt;\n#include &lt;algorithm&gt;    // copy\n#include &lt;iterator&gt;     // ostream_operator\n#include &lt;boost/tokenizer.hpp&gt;\n\nint main()\n{\n    using namespace std;\n    using namespace boost;\n    string data(&quot;data.csv&quot;);\n\n    ifstream in(data.c_str());\n    if (!in.is_open()) return 1;\n\n    typedef tokenizer&lt; escaped_list_separator&lt;char&gt; &gt; Tokenizer;\n    vector&lt; string &gt; vec;\n    string line;\n\n    while (getline(in,line))\n    {\n        Tokenizer tok(line);\n        vec.assign(tok.begin(),tok.end());\n\n        // vector now contains strings from one row, output to cout here\n        copy(vec.begin(), vec.end(), ostream_iterator&lt;string&gt;(cout, &quot;|&quot;));\n\n        cout &lt;&lt; &quot;\\n----------------------&quot; &lt;&lt; endl;\n    }\n}\n\n    ","url":"https://solutionschecker.com/questions/how-can-i-read-and-parse-csv-files-in-c++-1657387869219#solution5","@type":"Answer","upvoteCount":0},{"text":"It is not overkill to use Spirit for parsing CSVs. Spirit is well suited for micro-parsing tasks. For instance, with Spirit 2.1, it is as easy as:\n\nbool r = phrase_parse(first, last,\n\n    //  Begin grammar\n    (\n        double_ % &apos;,&apos;\n    )\n    ,\n    //  End grammar\n\n    space, v);\n\n\nThe vector, v, gets stuffed with the values. There is a series of tutorials touching on this in the new Spirit 2.1 docs that&apos;s just been released with Boost 1.41.\n\nThe tutorial progresses from simple to complex. The CSV parsers are presented somewhere in the middle and touches on various techniques in using Spirit. The generated code is as tight as hand written code. Check out the assembler generated!\n    ","url":"https://solutionschecker.com/questions/how-can-i-read-and-parse-csv-files-in-c++-1657387869219#solution6","@type":"Answer","upvoteCount":0},{"text":"If you DO care about parsing CSV correctly, this will do it...relatively slowly as it works one char at a time.\n\n void ParseCSV(const string&amp; csvSource, vector&lt;vector&lt;string&gt; &gt;&amp; lines)\n    {\n       bool inQuote(false);\n       bool newLine(false);\n       string field;\n       lines.clear();\n       vector&lt;string&gt; line;\n\n       string::const_iterator aChar = csvSource.begin();\n       while (aChar != csvSource.end())\n       {\n          switch (*aChar)\n          {\n          case &apos;&quot;&apos;:\n             newLine = false;\n             inQuote = !inQuote;\n             break;\n\n          case &apos;,&apos;:\n             newLine = false;\n             if (inQuote == true)\n             {\n                field += *aChar;\n             }\n             else\n             {\n                line.push_back(field);\n                field.clear();\n             }\n             break;\n\n          case &apos;\\n&apos;:\n          case &apos;\\r&apos;:\n             if (inQuote == true)\n             {\n                field += *aChar;\n             }\n             else\n             {\n                if (newLine == false)\n                {\n                   line.push_back(field);\n                   lines.push_back(line);\n                   field.clear();\n                   line.clear();\n                   newLine = true;\n                }\n             }\n             break;\n\n          default:\n             newLine = false;\n             field.push_back(*aChar);\n             break;\n          }\n\n          aChar++;\n       }\n\n       if (field.size())\n          line.push_back(field);\n\n       if (line.size())\n          lines.push_back(line);\n    }\n\n    ","url":"https://solutionschecker.com/questions/how-can-i-read-and-parse-csv-files-in-c++-1657387869219#solution7","@type":"Answer","upvoteCount":0},{"text":"When using the Boost Tokenizer escaped_list_separator for CSV files, then one should be aware of the following:\n\n\nIt requires an escape-character (default back-slash - \\)\nIt requires a splitter/seperator-character (default comma - ,)\nIt requires an quote-character (default quote - &quot;)\n\n\nThe CSV format specified by wiki states that data fields can contain separators in quotes (supported):\n\n\n  1997,Ford,E350,&quot;Super, luxurious truck&quot;\n\n\nThe CSV format specified by wiki states that single quotes should be handled with double-quotes (escaped_list_separator will strip away all quote characters):\n\n\n  1997,Ford,E350,&quot;Super &quot;&quot;luxurious&quot;&quot; truck&quot;\n\n\nThe CSV format doesn&apos;t specify that any back-slash characters should be stripped away (escaped_list_separator will strip away all escape characters).\n\nA possible work-around to fix the default behavior of the boost escaped_list_separator:\n\n\nFirst replace all back-slash characters (\\) with two back-slash characters (\\\\) so they are not stripped away.\nSecondly replace all double-quotes (&quot;&quot;) with a single back-slash character and a quote (\\&quot;)\n\n\nThis work-around has the side-effect that empty data-fields that are represented by a double-quote, will be transformed into a single-quote-token. When iterating through the tokens, then one must check if the token is a single-quote, and treat it like an empty string.\n\nNot pretty but it works, as long there are not newlines within the quotes.\n    ","url":"https://solutionschecker.com/questions/how-can-i-read-and-parse-csv-files-in-c++-1657387869219#solution8","@type":"Answer","upvoteCount":0},{"text":"I wrote a header-only, C++11 CSV parser. It&apos;s well tested, fast, supports the entire CSV spec (quoted fields, delimiter/terminator in quotes, quote escaping, etc.), and is configurable to account for the CSVs that don&apos;t adhere to the specification.\n\nConfiguration is done through a fluent interface:\n\n// constructor accepts any input stream\nCsvParser parser = CsvParser(std::cin)\n  .delimiter(&apos;;&apos;)    // delimited by ; instead of ,\n  .quote(&apos;\\&apos;&apos;)       // quoted fields use &apos; instead of &quot;\n  .terminator(&apos;\\0&apos;); // terminated by \\0 instead of by \\r\\n, \\n, or \\r\n\n\nParsing is just a range based for loop:\n\n#include &lt;iostream&gt;\n#include &quot;../parser.hpp&quot;\n\nusing namespace aria::csv;\n\nint main() {\n  std::ifstream f(&quot;some_file.csv&quot;);\n  CsvParser parser(f);\n\n  for (auto&amp; row : parser) {\n    for (auto&amp; field : row) {\n      std::cout &lt;&lt; field &lt;&lt; &quot; | &quot;;\n    }\n    std::cout &lt;&lt; std::endl;\n  }\n}\n\n    ","url":"https://solutionschecker.com/questions/how-can-i-read-and-parse-csv-files-in-c++-1657387869219#solution9","@type":"Answer","upvoteCount":0},{"text":"As all the CSV questions seem to get redirected here, I thought I&apos;d post my answer here.  This answer does not directly address the asker&apos;s question. I wanted to be able to read in a stream that is known to be in CSV format, and also the types of each field was already known. Of course, the method below could be used to treat every field to be a string type.\n\nAs an example of how I wanted to be able to use a CSV input stream, consider the following input (taken from wikipedia&apos;s page on CSV):\n\nconst char input[] =\n&quot;Year,Make,Model,Description,Price\\n&quot;\n&quot;1997,Ford,E350,\\&quot;ac, abs, moon\\&quot;,3000.00\\n&quot;\n&quot;1999,Chevy,\\&quot;Venture \\&quot;\\&quot;Extended Edition\\&quot;\\&quot;\\&quot;,\\&quot;\\&quot;,4900.00\\n&quot;\n&quot;1999,Chevy,\\&quot;Venture \\&quot;\\&quot;Extended Edition, Very Large\\&quot;\\&quot;\\&quot;,\\&quot;\\&quot;,5000.00\\n&quot;\n&quot;1996,Jeep,Grand Cherokee,\\&quot;MUST SELL!\\n\\\nair, moon roof, loaded\\&quot;,4799.00\\n&quot;\n;\n\n\nThen, I wanted to be able to read in the data like this:\n\nstd::istringstream ss(input);\nstd::string title[5];\nint year;\nstd::string make, model, desc;\nfloat price;\ncsv_istream(ss)\n    &gt;&gt; title[0] &gt;&gt; title[1] &gt;&gt; title[2] &gt;&gt; title[3] &gt;&gt; title[4];\nwhile (csv_istream(ss)\n       &gt;&gt; year &gt;&gt; make &gt;&gt; model &gt;&gt; desc &gt;&gt; price) {\n    //...do something with the record...\n}\n\n\nThis was the solution I ended up with.\n\nstruct csv_istream {\n    std::istream &amp;is_;\n    csv_istream (std::istream &amp;is) : is_(is) {}\n    void scan_ws () const {\n        while (is_.good()) {\n            int c = is_.peek();\n            if (c != &apos; &apos; &amp;&amp; c != &apos;\\t&apos;) break;\n            is_.get();\n        }\n    }\n    void scan (std::string *s = 0) const {\n        std::string ws;\n        int c = is_.get();\n        if (is_.good()) {\n            do {\n                if (c == &apos;,&apos; || c == &apos;\\n&apos;) break;\n                if (s) {\n                    ws += c;\n                    if (c != &apos; &apos; &amp;&amp; c != &apos;\\t&apos;) {\n                        *s += ws;\n                        ws.clear();\n                    }\n                }\n                c = is_.get();\n            } while (is_.good());\n            if (is_.eof()) is_.clear();\n        }\n    }\n    template &lt;typename T, bool&gt; struct set_value {\n        void operator () (std::string in, T &amp;v) const {\n            std::istringstream(in) &gt;&gt; v;\n        }\n    };\n    template &lt;typename T&gt; struct set_value&lt;T, true&gt; {\n        template &lt;bool SIGNED&gt; void convert (std::string in, T &amp;v) const {\n            if (SIGNED) v = ::strtoll(in.c_str(), 0, 0);\n            else v = ::strtoull(in.c_str(), 0, 0);\n        }\n        void operator () (std::string in, T &amp;v) const {\n            convert&lt;is_signed_int&lt;T&gt;::val&gt;(in, v);\n        }\n    };\n    template &lt;typename T&gt; const csv_istream &amp; operator &gt;&gt; (T &amp;v) const {\n        std::string tmp;\n        scan(&amp;tmp);\n        set_value&lt;T, is_int&lt;T&gt;::val&gt;()(tmp, v);\n        return *this;\n    }\n    const csv_istream &amp; operator &gt;&gt; (std::string &amp;v) const {\n        v.clear();\n        scan_ws();\n        if (is_.peek() != &apos;&quot;&apos;) scan(&amp;v);\n        else {\n            std::string tmp;\n            is_.get();\n            std::getline(is_, tmp, &apos;&quot;&apos;);\n            while (is_.peek() == &apos;&quot;&apos;) {\n                v += tmp;\n                v += is_.get();\n                std::getline(is_, tmp, &apos;&quot;&apos;);\n            }\n            v += tmp;\n            scan();\n        }\n        return *this;\n    }\n    template &lt;typename T&gt;\n    const csv_istream &amp; operator &gt;&gt; (T &amp;(*manip)(T &amp;)) const {\n        is_ &gt;&gt; manip;\n        return *this;\n    }\n    operator bool () const { return !is_.fail(); }\n};\n\n\nWith the following helpers that may be simplified by the new integral traits templates in C++11:\n\ntemplate &lt;typename T&gt; struct is_signed_int { enum { val = false }; };\ntemplate &lt;&gt; struct is_signed_int&lt;short&gt; { enum { val = true}; };\ntemplate &lt;&gt; struct is_signed_int&lt;int&gt; { enum { val = true}; };\ntemplate &lt;&gt; struct is_signed_int&lt;long&gt; { enum { val = true}; };\ntemplate &lt;&gt; struct is_signed_int&lt;long long&gt; { enum { val = true}; };\n\ntemplate &lt;typename T&gt; struct is_unsigned_int { enum { val = false }; };\ntemplate &lt;&gt; struct is_unsigned_int&lt;unsigned short&gt; { enum { val = true}; };\ntemplate &lt;&gt; struct is_unsigned_int&lt;unsigned int&gt; { enum { val = true}; };\ntemplate &lt;&gt; struct is_unsigned_int&lt;unsigned long&gt; { enum { val = true}; };\ntemplate &lt;&gt; struct is_unsigned_int&lt;unsigned long long&gt; { enum { val = true}; };\n\ntemplate &lt;typename T&gt; struct is_int {\n    enum { val = (is_signed_int&lt;T&gt;::val || is_unsigned_int&lt;T&gt;::val) };\n};\n\n\nTry it online!\n    ","url":"https://solutionschecker.com/questions/how-can-i-read-and-parse-csv-files-in-c++-1657387869219#solution10","@type":"Answer","upvoteCount":0},{"text":"You might want to look at my FOSS project CSVfix (updated link), which is a CSV stream editor written in C++. The CSV parser is no prize, but does the job and the whole package may do what you need without you writing any code.\n\nSee alib/src/a_csv.cpp for the CSV parser, and csvlib/src/csved_ioman.cpp (IOManager::ReadCSV) for a usage example.\n    ","url":"https://solutionschecker.com/questions/how-can-i-read-and-parse-csv-files-in-c++-1657387869219#solution11","@type":"Answer","upvoteCount":0},{"text":"Another CSV I/O library can be found here:\n\nhttp://code.google.com/p/fast-cpp-csv-parser/\n\n#include &quot;csv.h&quot;\n\nint main(){\n  io::CSVReader&lt;3&gt; in(&quot;ram.csv&quot;);\n  in.read_header(io::ignore_extra_column, &quot;vendor&quot;, &quot;size&quot;, &quot;speed&quot;);\n  std::string vendor; int size; double speed;\n  while(in.read_row(vendor, size, speed)){\n    // do stuff with the data\n  }\n}\n\n    ","url":"https://solutionschecker.com/questions/how-can-i-read-and-parse-csv-files-in-c++-1657387869219#solution12","@type":"Answer","upvoteCount":0},{"text":"Another solution similar to Loki Astari&apos;s answer, in C++11. Rows here are std::tuples of a given type. The code scans one line, then scans until each delimiter, and then converts and dumps the value directly into the tuple (with a bit of template code).\n\nfor (auto row : csv&lt;std::string, int, float&gt;(file, &apos;,&apos;)) {\n    std::cout &lt;&lt; &quot;first col: &quot; &lt;&lt; std::get&lt;0&gt;(row) &lt;&lt; std::endl;\n}\n\n\nAdvanges:\n\n\nquite clean and simple to use, only C++11.\nautomatic type conversion into std::tuple&lt;t1, ...&gt; via operator&gt;&gt;.\n\n\nWhat&apos;s missing:\n\n\nescaping and quoting\nno error handling in case of malformed CSV.\n\n\nThe main code:\n\n#include &lt;iterator&gt;\n#include &lt;sstream&gt;\n#include &lt;string&gt;\n\nnamespace csvtools {\n    /// Read the last element of the tuple without calling recursively\n    template &lt;std::size_t idx, class... fields&gt;\n    typename std::enable_if&lt;idx &gt;= std::tuple_size&lt;std::tuple&lt;fields...&gt;&gt;::value - 1&gt;::type\n    read_tuple(std::istream &amp;in, std::tuple&lt;fields...&gt; &amp;out, const char delimiter) {\n        std::string cell;\n        std::getline(in, cell, delimiter);\n        std::stringstream cell_stream(cell);\n        cell_stream &gt;&gt; std::get&lt;idx&gt;(out);\n    }\n\n    /// Read the @p idx-th element of the tuple and then calls itself with @p idx + 1 to\n    /// read the next element of the tuple. Automatically falls in the previous case when\n    /// reaches the last element of the tuple thanks to enable_if\n    template &lt;std::size_t idx, class... fields&gt;\n    typename std::enable_if&lt;idx &lt; std::tuple_size&lt;std::tuple&lt;fields...&gt;&gt;::value - 1&gt;::type\n    read_tuple(std::istream &amp;in, std::tuple&lt;fields...&gt; &amp;out, const char delimiter) {\n        std::string cell;\n        std::getline(in, cell, delimiter);\n        std::stringstream cell_stream(cell);\n        cell_stream &gt;&gt; std::get&lt;idx&gt;(out);\n        read_tuple&lt;idx + 1, fields...&gt;(in, out, delimiter);\n    }\n}\n\n/// Iterable csv wrapper around a stream. @p fields the list of types that form up a row.\ntemplate &lt;class... fields&gt;\nclass csv {\n    std::istream &amp;_in;\n    const char _delim;\npublic:\n    typedef std::tuple&lt;fields...&gt; value_type;\n    class iterator;\n\n    /// Construct from a stream.\n    inline csv(std::istream &amp;in, const char delim) : _in(in), _delim(delim) {}\n\n    /// Status of the underlying stream\n    /// @{\n    inline bool good() const {\n        return _in.good();\n    }\n    inline const std::istream &amp;underlying_stream() const {\n        return _in;\n    }\n    /// @}\n\n    inline iterator begin();\n    inline iterator end();\nprivate:\n\n    /// Reads a line into a stringstream, and then reads the line into a tuple, that is returned\n    inline value_type read_row() {\n        std::string line;\n        std::getline(_in, line);\n        std::stringstream line_stream(line);\n        std::tuple&lt;fields...&gt; retval;\n        csvtools::read_tuple&lt;0, fields...&gt;(line_stream, retval, _delim);\n        return retval;\n    }\n};\n\n/// Iterator; just calls recursively @ref csv::read_row and stores the result.\ntemplate &lt;class... fields&gt;\nclass csv&lt;fields...&gt;::iterator {\n    csv::value_type _row;\n    csv *_parent;\npublic:\n    typedef std::input_iterator_tag iterator_category;\n    typedef csv::value_type         value_type;\n    typedef std::size_t             difference_type;\n    typedef csv::value_type *       pointer;\n    typedef csv::value_type &amp;       reference;\n\n    /// Construct an empty/end iterator\n    inline iterator() : _parent(nullptr) {}\n    /// Construct an iterator at the beginning of the @p parent csv object.\n    inline iterator(csv &amp;parent) : _parent(parent.good() ? &amp;parent : nullptr) {\n        ++(*this);\n    }\n\n    /// Read one row, if possible. Set to end if parent is not good anymore.\n    inline iterator &amp;operator++() {\n        if (_parent != nullptr) {\n            _row = _parent-&gt;read_row();\n            if (!_parent-&gt;good()) {\n                _parent = nullptr;\n            }\n        }\n        return *this;\n    }\n\n    inline iterator operator++(int) {\n        iterator copy = *this;\n        ++(*this);\n        return copy;\n    }\n\n    inline csv::value_type const &amp;operator*() const {\n        return _row;\n    }\n\n    inline csv::value_type const *operator-&gt;() const {\n        return &amp;_row;\n    }\n\n    bool operator==(iterator const &amp;other) {\n        return (this == &amp;other) or (_parent == nullptr and other._parent == nullptr);\n    }\n    bool operator!=(iterator const &amp;other) {\n        return not (*this == other);\n    }\n};\n\ntemplate &lt;class... fields&gt;\ntypename csv&lt;fields...&gt;::iterator csv&lt;fields...&gt;::begin() {\n    return iterator(*this);\n}\n\ntemplate &lt;class... fields&gt;\ntypename csv&lt;fields...&gt;::iterator csv&lt;fields...&gt;::end() {\n    return iterator();\n}\n\n\nI put a tiny working example on GitHub; I&apos;ve been using it for parsing some numerical data and it served its purpose.\n    ","url":"https://solutionschecker.com/questions/how-can-i-read-and-parse-csv-files-in-c++-1657387869219#solution13","@type":"Answer","upvoteCount":0},{"text":"Here is another implementation of a Unicode CSV parser (works with wchar_t). I wrote part of it, while Jonathan Leffler wrote the rest.\n\nNote: This parser is aimed at replicating Excel&apos;s behavior as closely as possible, specifically when importing broken or malformed CSV files.\n\nThis is the original question - Parsing CSV file with multiline fields and escaped double quotes\n\nThis is the code as a SSCCE (Short, Self-Contained, Correct Example).\n\n#include &lt;stdbool.h&gt;\n#include &lt;wchar.h&gt;\n#include &lt;wctype.h&gt;\n\nextern const wchar_t *nextCsvField(const wchar_t *p, wchar_t sep, bool *newline);\n\n// Returns a pointer to the start of the next field,\n// or zero if this is the last field in the CSV\n// p is the start position of the field\n// sep is the separator used, i.e. comma or semicolon\n// newline says whether the field ends with a newline or with a comma\nconst wchar_t *nextCsvField(const wchar_t *p, wchar_t sep, bool *newline)\n{\n    // Parse quoted sequences\n    if (&apos;&quot;&apos; == p[0]) {\n        p++;\n        while (1) {\n            // Find next double-quote\n            p = wcschr(p, L&apos;&quot;&apos;);\n            // If we don&apos;t find it or it&apos;s the last symbol\n            // then this is the last field\n            if (!p || !p[1])\n                return 0;\n            // Check for &quot;&quot;, it is an escaped double-quote\n            if (p[1] != &apos;&quot;&apos;)\n                break;\n            // Skip the escaped double-quote\n            p += 2;\n        }\n    }\n\n    // Find next newline or comma.\n    wchar_t newline_or_sep[4] = L&quot;\\n\\r &quot;;\n    newline_or_sep[2] = sep;\n    p = wcspbrk(p, newline_or_sep);\n\n    // If no newline or separator, this is the last field.\n    if (!p)\n        return 0;\n\n    // Check if we had newline.\n    *newline = (p[0] == &apos;\\r&apos; || p[0] == &apos;\\n&apos;);\n\n    // Handle &quot;\\r\\n&quot;, otherwise just increment\n    if (p[0] == &apos;\\r&apos; &amp;&amp; p[1] == &apos;\\n&apos;)\n        p += 2;\n    else\n        p++;\n\n    return p;\n}\n\nstatic wchar_t *csvFieldData(const wchar_t *fld_s, const wchar_t *fld_e, wchar_t *buffer, size_t buflen)\n{\n    wchar_t *dst = buffer;\n    wchar_t *end = buffer + buflen - 1;\n    const wchar_t *src = fld_s;\n\n    if (*src == L&apos;&quot;&apos;)\n    {\n        const wchar_t *p = src + 1;\n        while (p &lt; fld_e &amp;&amp; dst &lt; end)\n        {\n            if (p[0] == L&apos;&quot;&apos; &amp;&amp; p+1 &lt; fld_s &amp;&amp; p[1] == L&apos;&quot;&apos;)\n            {\n                *dst++ = p[0];\n                p += 2;\n            }\n            else if (p[0] == L&apos;&quot;&apos;)\n            {\n                p++;\n                break;\n            }\n            else\n                *dst++ = *p++;\n        }\n        src = p;\n    }\n    while (src &lt; fld_e &amp;&amp; dst &lt; end)\n        *dst++ = *src++;\n    if (dst &gt;= end)\n        return 0;\n    *dst = L&apos;\\0&apos;;\n    return(buffer);\n}\n\nstatic void dissect(const wchar_t *line)\n{\n    const wchar_t *start = line;\n    const wchar_t *next;\n    bool     eol;\n    wprintf(L&quot;Input %3zd: [%.*ls]\\n&quot;, wcslen(line), wcslen(line)-1, line);\n    while ((next = nextCsvField(start, L&apos;,&apos;, &amp;eol)) != 0)\n    {\n        wchar_t buffer[1024];\n        wprintf(L&quot;Raw Field: [%.*ls] (eol = %d)\\n&quot;, (next - start - eol), start, eol);\n        if (csvFieldData(start, next-1, buffer, sizeof(buffer)/sizeof(buffer[0])) != 0)\n            wprintf(L&quot;Field %3zd: [%ls]\\n&quot;, wcslen(buffer), buffer);\n        start = next;\n    }\n}\n\nstatic const wchar_t multiline[] =\n   L&quot;First field of first row,\\&quot;This field is multiline\\n&quot;\n    &quot;\\n&quot;\n    &quot;but that&apos;s OK because it&apos;s enclosed in double quotes, and this\\n&quot;\n    &quot;is an escaped \\&quot;\\&quot; double quote\\&quot; but this one \\&quot;\\&quot; is not\\n&quot;\n    &quot;   \\&quot;This is second field of second row, but it is not multiline\\n&quot;\n    &quot;   because it doesn&apos;t start \\n&quot;\n    &quot;   with an immediate double quote\\&quot;\\n&quot;\n    ;\n\nint main(void)\n{\n    wchar_t line[1024];\n\n    while (fgetws(line, sizeof(line)/sizeof(line[0]), stdin))\n        dissect(line);\n    dissect(multiline);\n\n    return 0;\n}\n\n    ","url":"https://solutionschecker.com/questions/how-can-i-read-and-parse-csv-files-in-c++-1657387869219#solution14","@type":"Answer","upvoteCount":0},{"text":"This is an old thread but its still at the top of search results, so I&apos;m adding my solution using std::stringstream and a simple string replace method by Yves Baumes I found here.  \n\nThe following example will read a file line by line, ignore comment lines starting with // and parse the other lines into a combination of strings, ints and doubles. Stringstream does the parsing, but expects fields to be delimited by whitespace, so I use stringreplace to turn commas into spaces first. It handles tabs ok, but doesn&apos;t deal with quoted strings.\n\nBad or missing input is simply ignored, which may or may not be good, depending on your circumstance.\n\n#include &lt;string&gt;\n#include &lt;sstream&gt;\n#include &lt;fstream&gt;\n\nvoid StringReplace(std::string&amp; str, const std::string&amp; oldStr, const std::string&amp; newStr)\n// code by  Yves Baumes\n// http://stackoverflow.com/questions/1494399/how-do-i-search-find-and-replace-in-a-standard-string\n{\n  size_t pos = 0;\n  while((pos = str.find(oldStr, pos)) != std::string::npos)\n  {\n     str.replace(pos, oldStr.length(), newStr);\n     pos += newStr.length();\n  }\n}\n\nvoid LoadCSV(std::string &amp;filename) {\n   std::ifstream stream(filename);\n   std::string in_line;\n   std::string Field;\n   std::string Chan;\n   int ChanType;\n   double Scale;\n   int Import;\n   while (std::getline(stream, in_line)) {\n      StringReplace(in_line, &quot;,&quot;, &quot; &quot;);\n      std::stringstream line(in_line);\n      line &gt;&gt; Field &gt;&gt; Chan &gt;&gt; ChanType &gt;&gt; Scale &gt;&gt; Import;\n      if (Field.substr(0,2)!=&quot;//&quot;) {\n         // do your stuff \n         // this is CBuilder code for demonstration, sorry\n         ShowMessage((String)Field.c_str() + &quot;\\n&quot; + Chan.c_str() + &quot;\\n&quot; + IntToStr(ChanType) + &quot;\\n&quot; +FloatToStr(Scale) + &quot;\\n&quot; +IntToStr(Import));\n      }\n   }\n}\n\n    ","url":"https://solutionschecker.com/questions/how-can-i-read-and-parse-csv-files-in-c++-1657387869219#solution15","@type":"Answer","upvoteCount":0},{"text":"I needed an easy-to-use C++ library for parsing CSV files but couldn&apos;t find any available, so I ended up building one.\nRapidcsv is a C++11 header-only library which gives direct access to parsed columns (or rows) as vectors, in datatype of choice. For example:\n\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;rapidcsv.h&gt;\n\nint main()\n{\n  rapidcsv::Document doc(&quot;../tests/msft.csv&quot;);\n\n  std::vector&lt;float&gt; close = doc.GetColumn&lt;float&gt;(&quot;Close&quot;);\n  std::cout &lt;&lt; &quot;Read &quot; &lt;&lt; close.size() &lt;&lt; &quot; values.&quot; &lt;&lt; std::endl;\n}\n\n    ","url":"https://solutionschecker.com/questions/how-can-i-read-and-parse-csv-files-in-c++-1657387869219#solution16","@type":"Answer","upvoteCount":0},{"text":"You can use the header-only Csv::Parser library.\n\nIt fully supports RFC 4180, including quoted values, escaped quotes, and newlines in field values.\nIt requires only standard C++ (C++17).\nIt supports reading CSV data from std::string_view at compile-time.\nIt&apos;s extensively tested using Catch2.\n\n    ","url":"https://solutionschecker.com/questions/how-can-i-read-and-parse-csv-files-in-c++-1657387869219#solution17","@type":"Answer","upvoteCount":0},{"text":"Here is code for reading a matrix, note you also have a csvwrite function in matlab\n\nvoid loadFromCSV( const std::string&amp; filename )\n{\n    std::ifstream       file( filename.c_str() );\n    std::vector&lt; std::vector&lt;std::string&gt; &gt;   matrix;\n    std::vector&lt;std::string&gt;   row;\n    std::string                line;\n    std::string                cell;\n\n    while( file )\n    {\n        std::getline(file,line);\n        std::stringstream lineStream(line);\n        row.clear();\n\n        while( std::getline( lineStream, cell, &apos;,&apos; ) )\n            row.push_back( cell );\n\n        if( !row.empty() )\n            matrix.push_back( row );\n    }\n\n    for( int i=0; i&lt;int(matrix.size()); i++ )\n    {\n        for( int j=0; j&lt;int(matrix[i].size()); j++ )\n            std::cout &lt;&lt; matrix[i][j] &lt;&lt; &quot; &quot;;\n\n        std::cout &lt;&lt; std::endl;\n    }\n}\n\n    ","url":"https://solutionschecker.com/questions/how-can-i-read-and-parse-csv-files-in-c++-1657387869219#solution18","@type":"Answer","upvoteCount":0},{"text":"Excuse me, but this all seems like a great deal of elaborate syntax to hide a few lines of code.\n\nWhy not this:\n\n/**\n\n  Read line from a CSV file\n\n  @param[in] fp file pointer to open file\n  @param[in] vls reference to vector of strings to hold next line\n\n  */\nvoid readCSV( FILE *fp, std::vector&lt;std::string&gt;&amp; vls )\n{\n    vls.clear();\n    if( ! fp )\n        return;\n    char buf[10000];\n    if( ! fgets( buf,999,fp) )\n        return;\n    std::string s = buf;\n    int p,q;\n    q = -1;\n    // loop over columns\n    while( 1 ) {\n        p = q;\n        q = s.find_first_of(&quot;,\\n&quot;,p+1);\n        if( q == -1 ) \n            break;\n        vls.push_back( s.substr(p+1,q-p-1) );\n    }\n}\n\nint _tmain(int argc, _TCHAR* argv[])\n{\n    std::vector&lt;std::string&gt; vls;\n    FILE * fp = fopen( argv[1], &quot;r&quot; );\n    if( ! fp )\n        return 1;\n    readCSV( fp, vls );\n    readCSV( fp, vls );\n    readCSV( fp, vls );\n    std::cout &lt;&lt; &quot;row 3, col 4 is &quot; &lt;&lt; vls[3].c_str() &lt;&lt; &quot;\\n&quot;;\n\n    return 0;\n}\n\n    ","url":"https://solutionschecker.com/questions/how-can-i-read-and-parse-csv-files-in-c++-1657387869219#solution19","@type":"Answer","upvoteCount":0},{"text":"You can open and read .csv file using fopen ,fscanf functions ,but the important thing is to parse the data.Simplest way to parse the data using delimiter.In case of .csv , delimiter is &apos;,&apos;.\n\nSuppose your data1.csv file is as follows : \n\nA,45,76,01\nB,77,67,02\nC,63,76,03\nD,65,44,04\n\n\nyou can tokenize data and store in char array and later use atoi() etc function for appropriate conversions  \n\nFILE *fp;\nchar str1[10], str2[10], str3[10], str4[10];\n\nfp = fopen(&quot;G:\\\\data1.csv&quot;, &quot;r&quot;);\nif(NULL == fp)\n{\n    printf(&quot;\\nError in opening file.&quot;);\n    return 0;\n}\nwhile(EOF != fscanf(fp, &quot; %[^,], %[^,], %[^,], %s, %s, %s, %s &quot;, str1, str2, str3, str4))\n{\n    printf(&quot;\\n%s %s %s %s&quot;, str1, str2, str3, str4);\n}\nfclose(fp);\n\n\n[^,], ^ -it inverts logic , means match any string that does not contain comma then last , says to match comma that terminated previous string. \n    ","url":"https://solutionschecker.com/questions/how-can-i-read-and-parse-csv-files-in-c++-1657387869219#solution20","@type":"Answer","upvoteCount":0},{"text":"The first thing you need to do is make sure the file exists. To accomplish\nthis you just need to try and open the file stream at the path. After you\nhave opened the file stream use stream.fail() to see if it worked as expected,\nor not.\n\nbool fileExists(string fileName)\n{\n\nifstream test;\n\ntest.open(fileName.c_str());\n\nif (test.fail())\n{\n    test.close();\n    return false;\n}\nelse\n{\n    test.close();\n    return true;\n}\n}\n\n\nYou must also verify that the file provided is the correct type of file.\nTo accomplish this you need to look through the file path provided until \nyou find the file extension. Once you have the file extension make sure\nthat it is a .csv file.\n\nbool verifyExtension(string filename)\n{\nint period = 0;\n\nfor (unsigned int i = 0; i &lt; filename.length(); i++)\n{\n    if (filename[i] == &apos;.&apos;)\n        period = i;\n}\n\nstring extension;\n\nfor (unsigned int i = period; i &lt; filename.length(); i++)\n    extension += filename[i];\n\nif (extension == &quot;.csv&quot;)\n    return true;\nelse\n    return false;\n}\n\n\nThis function will return the file extension which is used later in an error message.\n\nstring getExtension(string filename)\n{\nint period = 0;\n\nfor (unsigned int i = 0; i &lt; filename.length(); i++)\n{\n    if (filename[i] == &apos;.&apos;)\n        period = i;\n}\n\nstring extension;\n\nif (period != 0)\n{\n    for (unsigned int i = period; i &lt; filename.length(); i++)\n        extension += filename[i];\n}\nelse\n    extension = &quot;NO FILE&quot;;\n\nreturn extension;\n}\n\n\nThis function will actually call the error checks created above and then parse through the file.\n\nvoid parseFile(string fileName)\n{\n    if (fileExists(fileName) &amp;&amp; verifyExtension(fileName))\n    {\n        ifstream fs;\n        fs.open(fileName.c_str());\n        string fileCommand;\n\n        while (fs.good())\n        {\n            string temp;\n\n            getline(fs, fileCommand, &apos;\\n&apos;);\n\n            for (unsigned int i = 0; i &lt; fileCommand.length(); i++)\n            {\n                if (fileCommand[i] != &apos;,&apos;)\n                    temp += fileCommand[i];\n                else\n                    temp += &quot; &quot;;\n            }\n\n            if (temp != &quot;\\0&quot;)\n            {\n                // Place your code here to run the file.\n            }\n        }\n        fs.close();\n    }\n    else if (!fileExists(fileName))\n    {\n        cout &lt;&lt; &quot;Error: The provided file does not exist: &quot; &lt;&lt; fileName &lt;&lt; endl;\n\n        if (!verifyExtension(fileName))\n        {\n            if (getExtension(fileName) != &quot;NO FILE&quot;)\n                cout &lt;&lt; &quot;\\tCheck the file extension.&quot; &lt;&lt; endl;\n            else\n                cout &lt;&lt; &quot;\\tThere is no file in the provided path.&quot; &lt;&lt; endl;\n        }\n    }\n    else if (!verifyExtension(fileName)) \n    {\n        if (getExtension(fileName) != &quot;NO FILE&quot;)\n            cout &lt;&lt; &quot;Incorrect file extension provided: &quot; &lt;&lt; getExtension(fileName) &lt;&lt; endl;\n        else\n            cout &lt;&lt; &quot;There is no file in the following path: &quot; &lt;&lt; fileName &lt;&lt; endl;\n    }\n}\n\n    ","url":"https://solutionschecker.com/questions/how-can-i-read-and-parse-csv-files-in-c++-1657387869219#solution21","@type":"Answer","upvoteCount":0},{"text":"Since i&apos;m not used to boost right now, I will suggest a more simple solution. Lets suppose that your .csv file has 100 lines with 10 numbers in each line separated by a &apos;,&apos;. You could load this data in the form of an array with the following code:\n\n#include &lt;iostream&gt;\n#include &lt;fstream&gt;\n#include &lt;sstream&gt;\n#include &lt;string&gt;\nusing namespace std;\n\nint main()\n{\n    int A[100][10];\n    ifstream ifs;\n    ifs.open(&quot;name_of_file.csv&quot;);\n    string s1;\n    char c;\n    for(int k=0; k&lt;100; k++)\n    {\n        getline(ifs,s1);\n        stringstream stream(s1);\n        int j=0;\n        while(1)\n        {\n            stream &gt;&gt;A[k][j];\n            stream &gt;&gt; c;\n            j++;\n            if(!stream) {break;}\n        }\n    }\n\n\n}\n\n    ","url":"https://solutionschecker.com/questions/how-can-i-read-and-parse-csv-files-in-c++-1657387869219#solution22","@type":"Answer","upvoteCount":0},{"text":"You can use this library:\nhttps://github.com/vadamsky/csvworker\n\nCode for example:\n\n#include &lt;iostream&gt;\n#include &quot;csvworker.h&quot;\n\nusing namespace std;\n\nint main()\n{\n    //\n    CsvWorker csv;\n    csv.loadFromFile(&quot;example.csv&quot;);\n    cout &lt;&lt; csv.getRowsNumber() &lt;&lt; &quot;  &quot; &lt;&lt; csv.getColumnsNumber() &lt;&lt; endl;\n\n    csv.getFieldRef(0, 2) = &quot;0&quot;;\n    csv.getFieldRef(1, 1) = &quot;0&quot;;\n    csv.getFieldRef(1, 3) = &quot;0&quot;;\n    csv.getFieldRef(2, 0) = &quot;0&quot;;\n    csv.getFieldRef(2, 4) = &quot;0&quot;;\n    csv.getFieldRef(3, 1) = &quot;0&quot;;\n    csv.getFieldRef(3, 3) = &quot;0&quot;;\n    csv.getFieldRef(4, 2) = &quot;0&quot;;\n\n    for(unsigned int i=0;i&lt;csv.getRowsNumber();++i)\n    {\n        //cout &lt;&lt; csv.getRow(i) &lt;&lt; endl;\n        for(unsigned int j=0;j&lt;csv.getColumnsNumber();++j)\n        {\n            cout &lt;&lt; csv.getField(i, j) &lt;&lt; &quot;.&quot;;\n        }\n        cout &lt;&lt; endl;\n    }\n\n    csv.saveToFile(&quot;test.csv&quot;);\n\n    //\n    CsvWorker csv2(4,4);\n\n    csv2.getFieldRef(0, 0) = &quot;a&quot;;\n    csv2.getFieldRef(0, 1) = &quot;b&quot;;\n    csv2.getFieldRef(0, 2) = &quot;r&quot;;\n    csv2.getFieldRef(0, 3) = &quot;a&quot;;\n    csv2.getFieldRef(1, 0) = &quot;c&quot;;\n    csv2.getFieldRef(1, 1) = &quot;a&quot;;\n    csv2.getFieldRef(1, 2) = &quot;d&quot;;\n    csv2.getFieldRef(2, 0) = &quot;a&quot;;\n    csv2.getFieldRef(2, 1) = &quot;b&quot;;\n    csv2.getFieldRef(2, 2) = &quot;r&quot;;\n    csv2.getFieldRef(2, 3) = &quot;a&quot;;\n\n    csv2.saveToFile(&quot;test2.csv&quot;);\n\n    return 0;\n}\n\n    ","url":"https://solutionschecker.com/questions/how-can-i-read-and-parse-csv-files-in-c++-1657387869219#solution23","@type":"Answer","upvoteCount":0},{"text":"You gotta feel proud when you use something so beautiful as boost::spirit\n\nHere my attempt of a parser (almost) complying with the CSV specifications on this link CSV specs (I didn&apos;t need line breaks within fields. Also the spaces around the commas are dismissed).\n\nAfter you overcome the shocking experience of waiting 10 seconds for compiling this code :), you can sit back and enjoy.\n\n// csvparser.cpp\n#include &lt;boost/spirit/include/qi.hpp&gt;\n#include &lt;boost/spirit/include/phoenix_operator.hpp&gt;\n\n#include &lt;iostream&gt;\n#include &lt;string&gt;\n\nnamespace qi = boost::spirit::qi;\nnamespace bascii = boost::spirit::ascii;\n\ntemplate &lt;typename Iterator&gt;\nstruct csv_parser : qi::grammar&lt;Iterator, std::vector&lt;std::string&gt;(), \n    bascii::space_type&gt;\n{\n    qi::rule&lt;Iterator, char()                                           &gt; COMMA;\n    qi::rule&lt;Iterator, char()                                           &gt; DDQUOTE;\n    qi::rule&lt;Iterator, std::string(),               bascii::space_type  &gt; non_escaped;\n    qi::rule&lt;Iterator, std::string(),               bascii::space_type  &gt; escaped;\n    qi::rule&lt;Iterator, std::string(),               bascii::space_type  &gt; field;\n    qi::rule&lt;Iterator, std::vector&lt;std::string&gt;(),  bascii::space_type  &gt; start;\n\n    csv_parser() : csv_parser::base_type(start)\n    {\n        using namespace qi;\n        using qi::lit;\n        using qi::lexeme;\n        using bascii::char_;\n\n        start       = field % &apos;,&apos;;\n        field       = escaped | non_escaped;\n        escaped     = lexeme[&apos;&quot;&apos; &gt;&gt; *( char_ -(char_(&apos;&quot;&apos;) | &apos;,&apos;) | COMMA | DDQUOTE)  &gt;&gt; &apos;&quot;&apos;];\n        non_escaped = lexeme[       *( char_ -(char_(&apos;&quot;&apos;) | &apos;,&apos;)                  )        ];\n        DDQUOTE     = lit(&quot;\\&quot;\\&quot;&quot;)       [_val = &apos;&quot;&apos;];\n        COMMA       = lit(&quot;,&quot;)          [_val = &apos;,&apos;];\n    }\n\n};\n\nint main()\n{\n    std::cout &lt;&lt; &quot;Enter CSV lines [empty] to quit\\n&quot;;\n\n    using bascii::space;\n    typedef std::string::const_iterator iterator_type;\n    typedef csv_parser&lt;iterator_type&gt; csv_parser;\n\n    csv_parser grammar;\n    std::string str;\n    int fid;\n    while (getline(std::cin, str))\n    {\n        fid = 0;\n\n        if (str.empty())\n            break;\n\n        std::vector&lt;std::string&gt; csv;\n        std::string::const_iterator it_beg = str.begin();\n        std::string::const_iterator it_end = str.end();\n        bool r = phrase_parse(it_beg, it_end, grammar, space, csv);\n\n        if (r &amp;&amp; it_beg == it_end)\n        {\n            std::cout &lt;&lt; &quot;Parsing succeeded\\n&quot;;\n            for (auto&amp; field: csv)\n            {\n                std::cout &lt;&lt; &quot;field &quot; &lt;&lt; ++fid &lt;&lt; &quot;: &quot; &lt;&lt; field &lt;&lt; std::endl;\n            }\n        }\n        else\n        {\n            std::cout &lt;&lt; &quot;Parsing failed\\n&quot;;\n        }\n    }\n\n    return 0;\n}\n\n\nCompile:\n\nmake csvparser\n\n\nTest (example stolen from Wikipedia):\n\n./csvparser\nEnter CSV lines [empty] to quit\n\n1999,Chevy,&quot;Venture &quot;&quot;Extended Edition, Very Large&quot;&quot;&quot;,,5000.00\nParsing succeeded\nfield 1: 1999\nfield 2: Chevy\nfield 3: Venture &quot;Extended Edition, Very Large&quot;\nfield 4: \nfield 5: 5000.00\n\n1999,Chevy,&quot;Venture &quot;&quot;Extended Edition, Very Large&quot;&quot;&quot;,,5000.00&quot;\nParsing failed\n\n    ","url":"https://solutionschecker.com/questions/how-can-i-read-and-parse-csv-files-in-c++-1657387869219#solution24","@type":"Answer","upvoteCount":0},{"text":"This solution detects these 4 cases\n\ncomplete class is at\n\nhttps://github.com/pedro-vicente/csv-parser\n\n1,field 2,field 3,\n1,field 2,&quot;field 3 quoted, with separator&quot;,\n1,field 2,&quot;field 3\nwith newline&quot;,\n1,field 2,&quot;field 3\nwith newline and separator,&quot;,\n\n\nIt reads the file character by character, and reads 1 row at a time to a vector (of strings), therefore suitable for very large files.\n\nUsage is\n\nIterate until an empty row is returned (end of file). A row is a vector where each entry is a CSV column.\n\nread_csv_t csv;\ncsv.open(&quot;../test.csv&quot;);\nstd::vector&lt;std::string&gt; row;\nwhile (true)\n{\n  row = csv.read_row();\n  if (row.size() == 0)\n  {\n    break;\n  }\n}\n\n\nthe class declaration\n\nclass read_csv_t\n{\npublic:\n  read_csv_t();\n  int open(const std::string &amp;file_name);\n  std::vector&lt;std::string&gt; read_row();\nprivate:\n  std::ifstream m_ifs;\n};\n\n\nthe implementation\n\nstd::vector&lt;std::string&gt; read_csv_t::read_row()\n{\n  bool quote_mode = false;\n  std::vector&lt;std::string&gt; row;\n  std::string column;\n  char c;\n  while (m_ifs.get(c))\n  {\n    switch (c)\n    {\n      /////////////////////////////////////////////////////////////////////////////////////////////////////\n      //separator &apos;,&apos; detected. \n      //in quote mode add character to column\n      //push column if not in quote mode\n      /////////////////////////////////////////////////////////////////////////////////////////////////////\n\n    case &apos;,&apos;:\n      if (quote_mode == true)\n      {\n        column += c;\n      }\n      else\n      {\n        row.push_back(column);\n        column.clear();\n      }\n      break;\n\n      /////////////////////////////////////////////////////////////////////////////////////////////////////\n      //quote &apos;&quot;&apos; detected. \n      //toggle quote mode\n      /////////////////////////////////////////////////////////////////////////////////////////////////////\n\n    case &apos;&quot;&apos;:\n      quote_mode = !quote_mode;\n      break;\n\n      /////////////////////////////////////////////////////////////////////////////////////////////////////\n      //line end detected\n      //in quote mode add character to column\n      //return row if not in quote mode\n      /////////////////////////////////////////////////////////////////////////////////////////////////////\n\n    case &apos;\\n&apos;:\n    case &apos;\\r&apos;:\n      if (quote_mode == true)\n      {\n        column += c;\n      }\n      else\n      {\n        return row;\n      }\n      break;\n\n      /////////////////////////////////////////////////////////////////////////////////////////////////////\n      //default, add character to column\n      /////////////////////////////////////////////////////////////////////////////////////////////////////\n\n    default:\n      column += c;\n      break;\n    }\n  }\n\n  //return empty vector if end of file detected \n  m_ifs.close();\n  std::vector&lt;std::string&gt; v;\n  return v;\n}\n\n    ","url":"https://solutionschecker.com/questions/how-can-i-read-and-parse-csv-files-in-c++-1657387869219#solution25","@type":"Answer","upvoteCount":0},{"text":"Parsing CSV file lines with Stream\n\nI wrote a small example of parsing CSV file lines, it can be developed with for and while loops if desired:\n\n#include &lt;iostream&gt;\n#include &lt;fstream&gt;\n#include &lt;string.h&gt;\n\nusing namespace std;\n\nint main() {\n\n\nifstream fin(&quot;Infile.csv&quot;);\nofstream fout(&quot;OutFile.csv&quot;);\nstring strline, strremain, strCol1 , strout;\n\nstring delimeter =&quot;;&quot;;\n\nint d1;\n\n\nto continue until the end of the file:\n\nwhile (!fin.eof()){ \n\n\nget first line from InFile :\n\n    getline(fin,strline,&apos;\\n&apos;);      \n\n\nfind delimeter position in line:\n\n    d1 = strline.find(&apos;;&apos;);\n\n\nand parse first column:\n\n    strCol1 = strline.substr(0,d1); // parse first Column\n    d1++;\n    strremain = strline.substr(d1); // remaining line\n\n\ncreate output line in CSV format:\n\n    strout.append(strCol1);\n    strout.append(delimeter);\n\n\nwrite line to Out File:\n\n    fout &lt;&lt; strout &lt;&lt; endl; //out file line\n\n} \n\nfin.close();\nfout.close();\n\nreturn(0);\n}\n\n\nThis code is compiled and running. Good luck!\n    ","url":"https://solutionschecker.com/questions/how-can-i-read-and-parse-csv-files-in-c++-1657387869219#solution26","@type":"Answer","upvoteCount":0},{"text":"You could also take a look at capabilities of Qt library.\n\nIt has regular expressions support and QString class has nice methods, e.g. split() returning QStringList, list of strings obtained by splitting the original string with a provided delimiter. Should suffice for csv file.. \n\nTo get a column with a given header name I use following: c++ inheritance Qt problem qstring\n    ","url":"https://solutionschecker.com/questions/how-can-i-read-and-parse-csv-files-in-c++-1657387869219#solution27","@type":"Answer","upvoteCount":0},{"text":"If you don&apos;t want to deal with including boost in your project (it is considerably large if all you are going to use it for is CSV parsing...)\n\nI have had luck with the CSV parsing here:\n\nhttp://www.zedwood.com/article/112/cpp-csv-parser\n\nIt handles quoted fields - but does not handle inline \\n characters (which is probably fine for most uses).\n    ","url":"https://solutionschecker.com/questions/how-can-i-read-and-parse-csv-files-in-c++-1657387869219#solution28","@type":"Answer","upvoteCount":0},{"text":"For what it is worth, here is my implementation. It deals with wstring input, but could be adjusted to string easily. It does not handle newline in fields (as my application does not either, but adding its support isn&apos;t too difficult) and it does not comply with &quot;\\r\\n&quot; end of line as per RFC (assuming you use std::getline), but it does handle whitespace trimming and double-quotes correctly (hopefully).\n\nusing namespace std;\n\n// trim whitespaces around field or double-quotes, remove double-quotes and replace escaped double-quotes (double double-quotes)\nwstring trimquote(const wstring&amp; str, const wstring&amp; whitespace, const wchar_t quotChar)\n{\n    wstring ws;\n    wstring::size_type strBegin = str.find_first_not_of(whitespace);\n    if (strBegin == wstring::npos)\n        return L&quot;&quot;;\n\n    wstring::size_type strEnd = str.find_last_not_of(whitespace);\n    wstring::size_type strRange = strEnd - strBegin + 1;\n\n    if((str[strBegin] == quotChar) &amp;&amp; (str[strEnd] == quotChar))\n    {\n        ws = str.substr(strBegin+1, strRange-2);\n        strBegin = 0;\n        while((strEnd = ws.find(quotChar, strBegin)) != wstring::npos)\n        {\n            ws.erase(strEnd, 1);\n            strBegin = strEnd+1;\n        }\n\n    }\n    else\n        ws = str.substr(strBegin, strRange);\n    return ws;\n}\n\npair&lt;unsigned, unsigned&gt; nextCSVQuotePair(const wstring&amp; line, const wchar_t quotChar, unsigned ofs = 0)\n{\n    pair&lt;unsigned, unsigned&gt; r;\n    r.first = line.find(quotChar, ofs);\n    r.second = wstring::npos;\n    if(r.first != wstring::npos)\n    {\n        r.second = r.first;\n        while(((r.second = line.find(quotChar, r.second+1)) != wstring::npos)\n            &amp;&amp; (line[r.second+1] == quotChar)) // WARNING: assumes null-terminated string such that line[r.second+1] always exist\n            r.second++;\n\n    }\n    return r;\n}\n\nunsigned parseLine(vector&lt;wstring&gt;&amp; fields, const wstring&amp; line)\n{\n    unsigned ofs, ofs0, np;\n    const wchar_t delim = L&apos;,&apos;;\n    const wstring whitespace = L&quot; \\t\\xa0\\x3000\\x2000\\x2001\\x2002\\x2003\\x2004\\x2005\\x2006\\x2007\\x2008\\x2009\\x200a\\x202f\\x205f&quot;;\n    const wchar_t quotChar = L&apos;\\&quot;&apos;;\n    pair&lt;unsigned, unsigned&gt; quot;\n\n    fields.clear();\n\n    ofs = ofs0 = 0;\n    quot = nextCSVQuotePair(line, quotChar);\n    while((np = line.find(delim, ofs)) != wstring::npos)\n    {\n        if((np &gt; quot.first) &amp;&amp; (np &lt; quot.second))\n        { // skip delimiter inside quoted field\n            ofs = quot.second+1;\n            quot = nextCSVQuotePair(line, quotChar, ofs);\n            continue;\n        }\n        fields.push_back( trimquote(line.substr(ofs0, np-ofs0), whitespace, quotChar) );\n        ofs = ofs0 = np+1;\n    }\n    fields.push_back( trimquote(line.substr(ofs0), whitespace, quotChar) );\n\n    return fields.size();\n}\n\n    ","url":"https://solutionschecker.com/questions/how-can-i-read-and-parse-csv-files-in-c++-1657387869219#solution29","@type":"Answer","upvoteCount":0},{"text":"Here is a ready-to use function if all you need is to load a data file of doubles (no integers, no text).\n\n#include &lt;sstream&gt;\n#include &lt;fstream&gt;\n#include &lt;iterator&gt;\n#include &lt;string&gt;\n#include &lt;vector&gt;\n#include &lt;algorithm&gt;\n\nusing namespace std;\n\n/**\n * Parse a CSV data file and fill the 2d STL vector &quot;data&quot;.\n * Limits: only &quot;pure datas&quot; of doubles, not encapsulated by &quot; and without \\n inside.\n * Further no formatting in the data (e.g. scientific notation)\n * It however handles both dots and commas as decimal separators and removes thousand separator.\n * \n * returnCodes[0]: file access 0-&gt; ok 1-&gt; not able to read; 2-&gt; decimal separator equal to comma separator\n * returnCodes[1]: number of records\n * returnCodes[2]: number of fields. -1 If rows have different field size\n * \n */\nvector&lt;int&gt;\nreadCsvData (vector &lt;vector &lt;double&gt;&gt;&amp; data, const string&amp; filename, const string&amp; delimiter, const string&amp; decseparator){\n\n int vv[3] = { 0,0,0 };\n vector&lt;int&gt; returnCodes(&amp;vv[0], &amp;vv[0]+3);\n\n string rowstring, stringtoken;\n double doubletoken;\n int rowcount=0;\n int fieldcount=0;\n data.clear();\n\n ifstream iFile(filename, ios_base::in);\n if (!iFile.is_open()){\n   returnCodes[0] = 1;\n   return returnCodes;\n }\n while (getline(iFile, rowstring)) {\n    if (rowstring==&quot;&quot;) continue; // empty line\n    rowcount ++; //let&apos;s start with 1\n    if(delimiter == decseparator){\n      returnCodes[0] = 2;\n      return returnCodes;\n    }\n    if(decseparator != &quot;.&quot;){\n     // remove dots (used as thousand separators)\n     string::iterator end_pos = remove(rowstring.begin(), rowstring.end(), &apos;.&apos;);\n     rowstring.erase(end_pos, rowstring.end());\n     // replace decimal separator with dots.\n     replace(rowstring.begin(), rowstring.end(),decseparator.c_str()[0], &apos;.&apos;); \n    } else {\n     // remove commas (used as thousand separators)\n     string::iterator end_pos = remove(rowstring.begin(), rowstring.end(), &apos;,&apos;);\n     rowstring.erase(end_pos, rowstring.end());\n    }\n    // tokenize..\n    vector&lt;double&gt; tokens;\n    // Skip delimiters at beginning.\n    string::size_type lastPos = rowstring.find_first_not_of(delimiter, 0);\n    // Find first &quot;non-delimiter&quot;.\n    string::size_type pos     = rowstring.find_first_of(delimiter, lastPos);\n    while (string::npos != pos || string::npos != lastPos){\n        // Found a token, convert it to double add it to the vector.\n        stringtoken = rowstring.substr(lastPos, pos - lastPos);\n        if (stringtoken == &quot;&quot;) {\n      tokens.push_back(0.0);\n    } else {\n          istringstream totalSString(stringtoken);\n      totalSString &gt;&gt; doubletoken;\n      tokens.push_back(doubletoken);\n    }     \n        // Skip delimiters.  Note the &quot;not_of&quot;\n        lastPos = rowstring.find_first_not_of(delimiter, pos);\n        // Find next &quot;non-delimiter&quot;\n        pos = rowstring.find_first_of(delimiter, lastPos);\n    }\n    if(rowcount == 1){\n      fieldcount = tokens.size();\n      returnCodes[2] = tokens.size();\n    } else {\n      if ( tokens.size() != fieldcount){\n    returnCodes[2] = -1;\n      }\n    }\n    data.push_back(tokens);\n }\n iFile.close();\n returnCodes[1] = rowcount;\n return returnCodes;\n}\n\n    ","url":"https://solutionschecker.com/questions/how-can-i-read-and-parse-csv-files-in-c++-1657387869219#solution30","@type":"Answer","upvoteCount":0}],"@type":"Question"}}</script><meta name="next-head-count" content="22"/><script id="google-analytics" data-nscript="beforeInteractive">(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
})(window,document,'script','dataLayer','GTM-NXVLL8B');</script><link rel="preload" href="/_next/static/css/c116652e2d6f4ad0.css" as="style"/><link rel="stylesheet" href="/_next/static/css/c116652e2d6f4ad0.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-0d1b80a048d4787e.js"></script><script src="/_next/static/chunks/webpack-42cdea76c8170223.js" defer=""></script><script src="/_next/static/chunks/framework-4556c45dd113b893.js" defer=""></script><script src="/_next/static/chunks/main-ccfab947c79712f4.js" defer=""></script><script src="/_next/static/chunks/pages/_app-862498b6ec7885c3.js" defer=""></script><script src="/_next/static/chunks/294-106ef8570fa99deb.js" defer=""></script><script src="/_next/static/chunks/490-7f0418bb4354ac73.js" defer=""></script><script src="/_next/static/chunks/pages/questions/%5Bslug%5D-47289857226115f9.js" defer=""></script><script src="/_next/static/xZs8haGjOP63QuDE0kxeX/_buildManifest.js" defer=""></script><script src="/_next/static/xZs8haGjOP63QuDE0kxeX/_ssgManifest.js" defer=""></script></head><body><noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-NXVLL8B"
        height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript><div id="__next"><div class="wrapper"><header><nav class="bg-white border-gray-200 px-4 lg:px-6 py-2.5 dark:bg-gray-800"><div class="flex flex-wrap justify-between items-center mx-auto max-w-screen-xl"><a class="flex items-center" href="/"><img src="/logo-second.png" class="mr-3 h-6 sm:h-9" alt="Solution Checker Logo"/><h1 class="self-center text-xl font-semibold whitespace-nowrap dark:text-white">Solution Checker</h1></a><div class="flex items-center lg:order-2"><button data-collapse-toggle="mobile-menu-2" type="button" class="inline-flex items-center p-2 ml-1 text-sm text-gray-500 rounded-lg lg:hidden hover:bg-gray-100 focus:outline-none focus:ring-2 focus:ring-gray-200 dark:text-gray-400 dark:hover:bg-gray-700 dark:focus:ring-gray-600" aria-controls="mobile-menu-2" aria-expanded="false"><span class="sr-only">Open main menu</span><svg class="w-6 h-6" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M3 5a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM3 10a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM3 15a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1z" clip-rule="evenodd"></path></svg><svg class="hidden w-6 h-6" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z" clip-rule="evenodd"></path></svg></button></div><div class="hidden justify-between items-center w-full lg:flex lg:w-auto lg:order-1" id="mobile-menu-2"><ul class="flex flex-col mt-4 font-medium lg:flex-row lg:space-x-8 lg:mt-0"><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" aria-current="page" href="/">Home</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/questions?tab=news">Questions</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/post?tab=news">Post</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/questions/how-can-i-read-and-parse-csv-files-in-c++-1657387869219#">Coding</a></li></ul></div></div></nav></header><div class="main-content"><div class="question my-5"><div class="flex question-header items-center m-auto justify-center"><div class="rounded-xl w-full border p-5 shadow-md bg-white"><div class="flex w-full items-center justify-between border-b pb-3"><div class="flex items-center space-x-3"><div class="text-lg font-bold text-slate-700"><a href="/questions/how-can-i-read-and-parse-csv-files-in-c++-1657387869219"><h1>How can I read and parse CSV files in C++?</h1></a></div></div><div class="flex flex-wrap h-auto justify-end items-center space-x-8"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold" href="/questions/tag/text">text</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold" href="/questions/tag/csv">csv</a></div></div><div class="question-content mt-5">
                
<p>I need to load and use CSV file data in C++.  At this point it can really just be a comma-delimited parser (ie don't worry about escaping new lines and commas).  The main need is a line-by-line parser that will return a vector for the next line each time the method is called.</p>

<p>I found this article which looks quite promising:
<a href="http://www.boost.org/doc/libs/1_35_0/libs/spirit/example/fundamental/list_parser.cpp" rel="noreferrer">http://www.boost.org/doc/libs/1_35_0/libs/spirit/example/fundamental/list_parser.cpp</a></p>

<p>I've never used Boost's Spirit, but am willing to try it. But only if there isn't a more straightforward solution I'm overlooking.</p>
    </div></div></div><div class="solution-section"><nav class="flex pagination-solution flex-col justify-end"><h1 class="text-lg font-semibold mb-5">Navigate to solutions: </h1><ul class="inline-flex -space-x-px overflow-auto"><li class="pagination-solution-item"><span data-id="#solution1" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">1</span></li><li class="pagination-solution-item"><span data-id="#solution2" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">2</span></li><li class="pagination-solution-item"><span data-id="#solution3" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">3</span></li><li class="pagination-solution-item"><span data-id="#solution4" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">4</span></li><li class="pagination-solution-item"><span data-id="#solution5" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">5</span></li><li class="pagination-solution-item"><span data-id="#solution6" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">6</span></li><li class="pagination-solution-item"><span data-id="#solution7" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">7</span></li><li class="pagination-solution-item"><span data-id="#solution8" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">8</span></li><li class="pagination-solution-item"><span data-id="#solution9" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">9</span></li><li class="pagination-solution-item"><span data-id="#solution10" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">10</span></li><li class="pagination-solution-item"><span data-id="#solution11" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">11</span></li><li class="pagination-solution-item"><span data-id="#solution12" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">12</span></li><li class="pagination-solution-item"><span data-id="#solution13" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">13</span></li><li class="pagination-solution-item"><span data-id="#solution14" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">14</span></li><li class="pagination-solution-item"><span data-id="#solution15" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">15</span></li><li class="pagination-solution-item"><span data-id="#solution16" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">16</span></li><li class="pagination-solution-item"><span data-id="#solution17" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">17</span></li><li class="pagination-solution-item"><span data-id="#solution18" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">18</span></li><li class="pagination-solution-item"><span data-id="#solution19" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">19</span></li><li class="pagination-solution-item"><span data-id="#solution20" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">20</span></li><li class="pagination-solution-item"><span data-id="#solution21" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">21</span></li><li class="pagination-solution-item"><span data-id="#solution22" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">22</span></li><li class="pagination-solution-item"><span data-id="#solution23" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">23</span></li><li class="pagination-solution-item"><span data-id="#solution24" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">24</span></li><li class="pagination-solution-item"><span data-id="#solution25" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">25</span></li><li class="pagination-solution-item"><span data-id="#solution26" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">26</span></li><li class="pagination-solution-item"><span data-id="#solution27" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">27</span></li><li class="pagination-solution-item"><span data-id="#solution28" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">28</span></li><li class="pagination-solution-item"><span data-id="#solution29" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">29</span></li><li class="pagination-solution-item"><span data-id="#solution30" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">30</span></li></ul></nav><div id="solution1" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 1</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/text">text</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/csv">csv</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>If you don't care about escaping comma and newline,<br>
AND you can't embed comma and newline in quotes (If you can't escape then...)<br>
then its only about three lines of code (OK 14 -&gt;But its only 15 to read the whole file).</p>
<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-function">std::vector&lt;std::string&gt; <span class="hljs-title">getNextLineAndSplitIntoTokens</span><span class="hljs-params">(std::istream&amp; str)</span>
</span>{
    std::vector&lt;std::string&gt;   result;
    std::string                line;
    std::<span class="hljs-built_in">getline</span>(str,line);

    <span class="hljs-function">std::stringstream          <span class="hljs-title">lineStream</span><span class="hljs-params">(line)</span></span>;
    std::string                cell;

    <span class="hljs-keyword">while</span>(std::<span class="hljs-built_in">getline</span>(lineStream,cell, <span class="hljs-string">','</span>))
    {
        result.<span class="hljs-built_in">push_back</span>(cell);
    }
    <span class="hljs-comment">// This checks for a trailing comma with no data after it.</span>
    <span class="hljs-keyword">if</span> (!lineStream &amp;&amp; cell.<span class="hljs-built_in">empty</span>())
    {
        <span class="hljs-comment">// If there was a trailing comma then add an empty element.</span>
        result.<span class="hljs-built_in">push_back</span>(<span class="hljs-string">""</span>);
    }
    <span class="hljs-keyword">return</span> result;
}
</code></pre>
<p>I would just create a class representing a row.<br>
Then stream into that object:</p>
<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iterator&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fstream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sstream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span>

<span class="hljs-keyword">class</span> <span class="hljs-title class_">CSVRow</span>
{
    <span class="hljs-keyword">public</span>:
        std::string_view <span class="hljs-keyword">operator</span>[](std::<span class="hljs-type">size_t</span> index) <span class="hljs-type">const</span>
        {
            <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">string_view</span>(&amp;m_line[m_data[index] + <span class="hljs-number">1</span>], m_data[index + <span class="hljs-number">1</span>] -  (m_data[index] + <span class="hljs-number">1</span>));
        }
        <span class="hljs-function">std::<span class="hljs-type">size_t</span> <span class="hljs-title">size</span><span class="hljs-params">()</span> <span class="hljs-type">const</span>
        </span>{
            <span class="hljs-keyword">return</span> m_data.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;
        }
        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">readNextRow</span><span class="hljs-params">(std::istream&amp; str)</span>
        </span>{
            std::<span class="hljs-built_in">getline</span>(str, m_line);

            m_data.<span class="hljs-built_in">clear</span>();
            m_data.<span class="hljs-built_in">emplace_back</span>(<span class="hljs-number">-1</span>);
            std::string::size_type pos = <span class="hljs-number">0</span>;
            <span class="hljs-keyword">while</span>((pos = m_line.<span class="hljs-built_in">find</span>(<span class="hljs-string">','</span>, pos)) != std::string::npos)
            {
                m_data.<span class="hljs-built_in">emplace_back</span>(pos);
                ++pos;
            }
            <span class="hljs-comment">// This checks for a trailing comma with no data after it.</span>
            pos   = m_line.<span class="hljs-built_in">size</span>();
            m_data.<span class="hljs-built_in">emplace_back</span>(pos);
        }
    <span class="hljs-keyword">private</span>:
        std::string         m_line;
        std::vector&lt;<span class="hljs-type">int</span>&gt;    m_data;
};

std::istream&amp; <span class="hljs-keyword">operator</span>&gt;&gt;(std::istream&amp; str, CSVRow&amp; data)
{
    data.<span class="hljs-built_in">readNextRow</span>(str);
    <span class="hljs-keyword">return</span> str;
}   
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-function">std::ifstream       <span class="hljs-title">file</span><span class="hljs-params">(<span class="hljs-string">"plop.csv"</span>)</span></span>;

    CSVRow              row;
    <span class="hljs-keyword">while</span>(file &gt;&gt; row)
    {
        std::cout &lt;&lt; <span class="hljs-string">"4th Element("</span> &lt;&lt; row[<span class="hljs-number">3</span>] &lt;&lt; <span class="hljs-string">")\n"</span>;
    }
}
</code></pre>
<p>But with a little work we could technically create an iterator:</p>
<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">CSVIterator</span>
{   
    <span class="hljs-keyword">public</span>:
        <span class="hljs-keyword">typedef</span> std::input_iterator_tag     iterator_category;
        <span class="hljs-keyword">typedef</span> CSVRow                      value_type;
        <span class="hljs-keyword">typedef</span> std::<span class="hljs-type">size_t</span>                 difference_type;
        <span class="hljs-keyword">typedef</span> CSVRow*                     pointer;
        <span class="hljs-keyword">typedef</span> CSVRow&amp;                     reference;

        <span class="hljs-built_in">CSVIterator</span>(std::istream&amp; str)  :<span class="hljs-built_in">m_str</span>(str.<span class="hljs-built_in">good</span>()?&amp;str:<span class="hljs-literal">nullptr</span>) { ++(*<span class="hljs-keyword">this</span>); }
        <span class="hljs-built_in">CSVIterator</span>()                   :<span class="hljs-built_in">m_str</span>(<span class="hljs-literal">nullptr</span>) {}

        <span class="hljs-comment">// Pre Increment</span>
        CSVIterator&amp; <span class="hljs-keyword">operator</span>++()               {<span class="hljs-keyword">if</span> (m_str) { <span class="hljs-keyword">if</span> (!((*m_str) &gt;&gt; m_row)){m_str = <span class="hljs-literal">nullptr</span>;}}<span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;}
        <span class="hljs-comment">// Post increment</span>
        CSVIterator <span class="hljs-keyword">operator</span>++(<span class="hljs-type">int</span>)             {<span class="hljs-function">CSVIterator    <span class="hljs-title">tmp</span><span class="hljs-params">(*<span class="hljs-keyword">this</span>)</span></span>;++(*<span class="hljs-keyword">this</span>);<span class="hljs-keyword">return</span> tmp;}
        CSVRow <span class="hljs-type">const</span>&amp; <span class="hljs-keyword">operator</span>*()   <span class="hljs-type">const</span>       {<span class="hljs-keyword">return</span> m_row;}
        CSVRow <span class="hljs-type">const</span>* <span class="hljs-keyword">operator</span>-&gt;()  <span class="hljs-type">const</span>       {<span class="hljs-keyword">return</span> &amp;m_row;}

        <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>==(CSVIterator <span class="hljs-type">const</span>&amp; rhs) {<span class="hljs-built_in">return</span> ((<span class="hljs-keyword">this</span> == &amp;rhs) || ((<span class="hljs-keyword">this</span>-&gt;m_str == <span class="hljs-literal">nullptr</span>) &amp;&amp; (rhs.m_str == <span class="hljs-literal">nullptr</span>)));}
        <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>!=(CSVIterator <span class="hljs-type">const</span>&amp; rhs) {<span class="hljs-keyword">return</span> !((*<span class="hljs-keyword">this</span>) == rhs);}
    <span class="hljs-keyword">private</span>:
        std::istream*       m_str;
        CSVRow              m_row;
};


<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-function">std::ifstream       <span class="hljs-title">file</span><span class="hljs-params">(<span class="hljs-string">"plop.csv"</span>)</span></span>;

    <span class="hljs-keyword">for</span>(CSVIterator <span class="hljs-built_in">loop</span>(file); loop != <span class="hljs-built_in">CSVIterator</span>(); ++loop)
    {
        std::cout &lt;&lt; <span class="hljs-string">"4th Element("</span> &lt;&lt; (*loop)[<span class="hljs-number">3</span>] &lt;&lt; <span class="hljs-string">")\n"</span>;
    }
}
</code></pre>
<p>Now that we are in 2020 lets add a CSVRange object:</p>
<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">CSVRange</span>
{
    std::istream&amp;   stream;
    <span class="hljs-keyword">public</span>:
        <span class="hljs-built_in">CSVRange</span>(std::istream&amp; str)
            : <span class="hljs-built_in">stream</span>(str)
        {}
        <span class="hljs-function">CSVIterator <span class="hljs-title">begin</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>{<span class="hljs-keyword">return</span> CSVIterator{stream};}
        <span class="hljs-function">CSVIterator <span class="hljs-title">end</span><span class="hljs-params">()</span>   <span class="hljs-type">const</span> </span>{<span class="hljs-keyword">return</span> CSVIterator{};}
};

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-function">std::ifstream       <span class="hljs-title">file</span><span class="hljs-params">(<span class="hljs-string">"plop.csv"</span>)</span></span>;

    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span>&amp; row: <span class="hljs-built_in">CSVRange</span>(file))
    {
        std::cout &lt;&lt; <span class="hljs-string">"4th Element("</span> &lt;&lt; row[<span class="hljs-number">3</span>] &lt;&lt; <span class="hljs-string">")\n"</span>;
    }
}
</code></pre>
    </div></div></div></div><div id="solution2" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 2</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/text">text</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/csv">csv</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>My version is not using anything but the standard C++11 library. It copes well with Excel CSV quotation:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp">spam eggs,<span class="hljs-string">"foo,bar"</span>,<span class="hljs-string">""</span><span class="hljs-string">"fizz buzz"</span><span class="hljs-string">""</span>
<span class="hljs-number">1.23</span>,<span class="hljs-number">4.567</span>,<span class="hljs-number">-8.00E+09</span>
</code></pre>

<p>The code is written as a finite-state machine and is consuming one character at a time. I think it's easier to reason about.</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;istream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span>

<span class="hljs-keyword">enum class</span> <span class="hljs-title class_">CSVState</span> {
    UnquotedField,
    QuotedField,
    QuotedQuote
};

<span class="hljs-function">std::vector&lt;std::string&gt; <span class="hljs-title">readCSVRow</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string &amp;row)</span> </span>{
    CSVState state = CSVState::UnquotedField;
    std::vector&lt;std::string&gt; fields {<span class="hljs-string">""</span>};
    <span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; <span class="hljs-comment">// index of the current field</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> c : row) {
        <span class="hljs-keyword">switch</span> (state) {
            <span class="hljs-keyword">case</span> CSVState::UnquotedField:
                <span class="hljs-keyword">switch</span> (c) {
                    <span class="hljs-keyword">case</span> <span class="hljs-string">','</span>: <span class="hljs-comment">// end of field</span>
                              fields.<span class="hljs-built_in">push_back</span>(<span class="hljs-string">""</span>); i++;
                              <span class="hljs-keyword">break</span>;
                    <span class="hljs-keyword">case</span> <span class="hljs-string">'"'</span>: state = CSVState::QuotedField;
                              <span class="hljs-keyword">break</span>;
                    <span class="hljs-keyword">default</span>:  fields[i].<span class="hljs-built_in">push_back</span>(c);
                              <span class="hljs-keyword">break</span>; }
                <span class="hljs-keyword">break</span>;
            <span class="hljs-keyword">case</span> CSVState::QuotedField:
                <span class="hljs-keyword">switch</span> (c) {
                    <span class="hljs-keyword">case</span> <span class="hljs-string">'"'</span>: state = CSVState::QuotedQuote;
                              <span class="hljs-keyword">break</span>;
                    <span class="hljs-keyword">default</span>:  fields[i].<span class="hljs-built_in">push_back</span>(c);
                              <span class="hljs-keyword">break</span>; }
                <span class="hljs-keyword">break</span>;
            <span class="hljs-keyword">case</span> CSVState::QuotedQuote:
                <span class="hljs-keyword">switch</span> (c) {
                    <span class="hljs-keyword">case</span> <span class="hljs-string">','</span>: <span class="hljs-comment">// , after closing quote</span>
                              fields.<span class="hljs-built_in">push_back</span>(<span class="hljs-string">""</span>); i++;
                              state = CSVState::UnquotedField;
                              <span class="hljs-keyword">break</span>;
                    <span class="hljs-keyword">case</span> <span class="hljs-string">'"'</span>: <span class="hljs-comment">// "" -&gt; "</span>
                              fields[i].<span class="hljs-built_in">push_back</span>(<span class="hljs-string">'"'</span>);
                              state = CSVState::QuotedField;
                              <span class="hljs-keyword">break</span>;
                    <span class="hljs-keyword">default</span>:  <span class="hljs-comment">// end of quote</span>
                              state = CSVState::UnquotedField;
                              <span class="hljs-keyword">break</span>; }
                <span class="hljs-keyword">break</span>;
        }
    }
    <span class="hljs-keyword">return</span> fields;
}

<span class="hljs-comment">/// Read CSV file, Excel dialect. Accept "quoted fields ""with quotes"""</span>
std::vector&lt;std::vector&lt;std::string&gt;&gt; <span class="hljs-built_in">readCSV</span>(std::istream &amp;in) {
    std::vector&lt;std::vector&lt;std::string&gt;&gt; table;
    std::string row;
    <span class="hljs-keyword">while</span> (!in.<span class="hljs-built_in">eof</span>()) {
        std::<span class="hljs-built_in">getline</span>(in, row);
        <span class="hljs-keyword">if</span> (in.<span class="hljs-built_in">bad</span>() || in.<span class="hljs-built_in">fail</span>()) {
            <span class="hljs-keyword">break</span>;
        }
        <span class="hljs-keyword">auto</span> fields = <span class="hljs-built_in">readCSVRow</span>(row);
        table.<span class="hljs-built_in">push_back</span>(fields);
    }
    <span class="hljs-keyword">return</span> table;
}
</code></pre>
    </div></div></div></div><div id="solution3" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 3</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/text">text</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/csv">csv</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Solution using Boost Tokenizer:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp">std::vector&lt;std::string&gt; vec;
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> boost;
tokenizer&lt;escaped_list_separator&lt;<span class="hljs-type">char</span>&gt; &gt; <span class="hljs-built_in">tk</span>(
   line, <span class="hljs-built_in">escaped_list_separator</span>&lt;<span class="hljs-type">char</span>&gt;(<span class="hljs-string">'\\'</span>, <span class="hljs-string">','</span>, <span class="hljs-string">'\"'</span>));
<span class="hljs-keyword">for</span> (tokenizer&lt;escaped_list_separator&lt;<span class="hljs-type">char</span>&gt; &gt;::iterator <span class="hljs-built_in">i</span>(tk.<span class="hljs-built_in">begin</span>());
   i!=tk.<span class="hljs-built_in">end</span>();++i) 
{
   vec.<span class="hljs-built_in">push_back</span>(*i);
}
</code></pre>
    </div></div></div></div><div id="solution4" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 4</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/text">text</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/csv">csv</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>The <a href="http://www.partow.net/programming/strtk/index.html" rel="nofollow noreferrer">C++ String Toolkit Library (StrTk)</a> has a token grid class that allows you to load data either from <b>text files, strings or char buffers</b>, and to parse/process them in a row-column fashion.</p>

<p>You can specify the row delimiters and column delimiters or just use the defaults.</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span>
</span>{
   std::string data = <span class="hljs-string">"1,2,3,4,5\n"</span>
                      <span class="hljs-string">"0,2,4,6,8\n"</span>
                      <span class="hljs-string">"1,3,5,7,9\n"</span>;

   <span class="hljs-function">strtk::token_grid <span class="hljs-title">grid</span><span class="hljs-params">(data,data.size(),<span class="hljs-string">","</span>)</span></span>;

   <span class="hljs-keyword">for</span>(std::<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; grid.<span class="hljs-built_in">row_count</span>(); ++i)
   {
      strtk::token_grid::row_type r = grid.<span class="hljs-built_in">row</span>(i);
      <span class="hljs-keyword">for</span>(std::<span class="hljs-type">size_t</span> j = <span class="hljs-number">0</span>; j &lt; r.<span class="hljs-built_in">size</span>(); ++j)
      {
         std::cout &lt;&lt; r.<span class="hljs-built_in">get</span>&lt;<span class="hljs-type">int</span>&gt;(j) &lt;&lt; <span class="hljs-string">"\t"</span>;
      }
      std::cout &lt;&lt; std::endl;
   }
   std::cout &lt;&lt; std::endl;
}
</code></pre>

<p>More examples can be found <a href="http://www.partow.net/programming/strtk/index.html#tutorial" rel="nofollow noreferrer">Here</a></p>
    </div></div></div></div><div id="solution5" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 5</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/text">text</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/csv">csv</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p><strong>You can use Boost Tokenizer with escaped_list_separator.</strong></p>
<blockquote>
<p><strong>escaped_list_separator</strong> parses a superset of the csv. <a href="https://www.boost.org/doc/libs/release/libs/tokenizer/doc/escaped_list_separator.htm" rel="nofollow noreferrer">Boost::tokenizer</a></p>
</blockquote>
<p>This only uses Boost tokenizer header files, no linking to boost libraries required.</p>
<p>Here is an example, (see <a href="http://mybyteofcode.blogspot.com/2010/02/parse-csv-file-with-boost-tokenizer-in.html" rel="nofollow noreferrer">Parse CSV File With Boost Tokenizer In C++</a> for details or <code>Boost::tokenizer</code> ):</p>
<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span>     <span class="hljs-comment">// cout, endl</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fstream&gt;</span>      <span class="hljs-comment">// fstream</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span>    <span class="hljs-comment">// copy</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iterator&gt;</span>     <span class="hljs-comment">// ostream_operator</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;boost/tokenizer.hpp&gt;</span></span>

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;
    <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> boost;
    <span class="hljs-function">string <span class="hljs-title">data</span><span class="hljs-params">(<span class="hljs-string">"data.csv"</span>)</span></span>;

    <span class="hljs-function">ifstream <span class="hljs-title">in</span><span class="hljs-params">(data.c_str())</span></span>;
    <span class="hljs-keyword">if</span> (!in.<span class="hljs-built_in">is_open</span>()) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;

    <span class="hljs-keyword">typedef</span> tokenizer&lt; escaped_list_separator&lt;<span class="hljs-type">char</span>&gt; &gt; Tokenizer;
    vector&lt; string &gt; vec;
    string line;

    <span class="hljs-keyword">while</span> (<span class="hljs-built_in">getline</span>(in,line))
    {
        <span class="hljs-function">Tokenizer <span class="hljs-title">tok</span><span class="hljs-params">(line)</span></span>;
        vec.<span class="hljs-built_in">assign</span>(tok.<span class="hljs-built_in">begin</span>(),tok.<span class="hljs-built_in">end</span>());

        <span class="hljs-comment">// vector now contains strings from one row, output to cout here</span>
        <span class="hljs-built_in">copy</span>(vec.<span class="hljs-built_in">begin</span>(), vec.<span class="hljs-built_in">end</span>(), <span class="hljs-built_in">ostream_iterator</span>&lt;string&gt;(cout, <span class="hljs-string">"|"</span>));

        cout &lt;&lt; <span class="hljs-string">"\n----------------------"</span> &lt;&lt; endl;
    }
}
</code></pre>
    </div></div></div></div><div id="solution6" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 6</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/text">text</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/csv">csv</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>It is not overkill to use Spirit for parsing CSVs. Spirit is well suited for micro-parsing tasks. For instance, with Spirit 2.1, it is as easy as:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-type">bool</span> r = <span class="hljs-built_in">phrase_parse</span>(first, last,

    <span class="hljs-comment">//  Begin grammar</span>
    (
        double_ % <span class="hljs-string">','</span>
    )
    ,
    <span class="hljs-comment">//  End grammar</span>

    space, v);
</code></pre>

<p>The vector, v, gets stuffed with the values. <a href="http://www.boost.org/doc/libs/1_41_0/libs/spirit/doc/html/spirit/qi/tutorials.html" rel="noreferrer">There is a series of tutorials</a> touching on this in the new Spirit 2.1 docs that's just been released with Boost 1.41.</p>

<p>The tutorial progresses from simple to complex. The CSV parsers are presented somewhere in the middle and touches on various techniques in using Spirit. The generated code is as tight as hand written code. Check out the assembler generated!</p>
    </div></div></div></div><div id="solution7" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 7</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/text">text</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/csv">csv</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>If you <strong>DO</strong> care about parsing CSV correctly, this will do it...relatively slowly as it works one char at a time.</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"> <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ParseCSV</span><span class="hljs-params">(<span class="hljs-type">const</span> string&amp; csvSource, vector&lt;vector&lt;string&gt; &gt;&amp; lines)</span>
    </span>{
       <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">inQuote</span><span class="hljs-params">(<span class="hljs-literal">false</span>)</span></span>;
       <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">newLine</span><span class="hljs-params">(<span class="hljs-literal">false</span>)</span></span>;
       string field;
       lines.<span class="hljs-built_in">clear</span>();
       vector&lt;string&gt; line;

       string::const_iterator aChar = csvSource.<span class="hljs-built_in">begin</span>();
       <span class="hljs-keyword">while</span> (aChar != csvSource.<span class="hljs-built_in">end</span>())
       {
          <span class="hljs-keyword">switch</span> (*aChar)
          {
          <span class="hljs-keyword">case</span> <span class="hljs-string">'"'</span>:
             newLine = <span class="hljs-literal">false</span>;
             inQuote = !inQuote;
             <span class="hljs-keyword">break</span>;

          <span class="hljs-keyword">case</span> <span class="hljs-string">','</span>:
             newLine = <span class="hljs-literal">false</span>;
             <span class="hljs-keyword">if</span> (inQuote == <span class="hljs-literal">true</span>)
             {
                field += *aChar;
             }
             <span class="hljs-keyword">else</span>
             {
                line.<span class="hljs-built_in">push_back</span>(field);
                field.<span class="hljs-built_in">clear</span>();
             }
             <span class="hljs-keyword">break</span>;

          <span class="hljs-keyword">case</span> <span class="hljs-string">'\n'</span>:
          <span class="hljs-keyword">case</span> <span class="hljs-string">'\r'</span>:
             <span class="hljs-keyword">if</span> (inQuote == <span class="hljs-literal">true</span>)
             {
                field += *aChar;
             }
             <span class="hljs-keyword">else</span>
             {
                <span class="hljs-keyword">if</span> (newLine == <span class="hljs-literal">false</span>)
                {
                   line.<span class="hljs-built_in">push_back</span>(field);
                   lines.<span class="hljs-built_in">push_back</span>(line);
                   field.<span class="hljs-built_in">clear</span>();
                   line.<span class="hljs-built_in">clear</span>();
                   newLine = <span class="hljs-literal">true</span>;
                }
             }
             <span class="hljs-keyword">break</span>;

          <span class="hljs-keyword">default</span>:
             newLine = <span class="hljs-literal">false</span>;
             field.<span class="hljs-built_in">push_back</span>(*aChar);
             <span class="hljs-keyword">break</span>;
          }

          aChar++;
       }

       <span class="hljs-keyword">if</span> (field.<span class="hljs-built_in">size</span>())
          line.<span class="hljs-built_in">push_back</span>(field);

       <span class="hljs-keyword">if</span> (line.<span class="hljs-built_in">size</span>())
          lines.<span class="hljs-built_in">push_back</span>(line);
    }
</code></pre>
    </div></div></div></div><div id="solution8" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 8</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/text">text</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/csv">csv</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>When using the Boost Tokenizer escaped_list_separator for CSV files, then one should be aware of the following:</p>

<ol>
<li>It requires an escape-character (default back-slash - \)</li>
<li>It requires a splitter/seperator-character (default comma - ,)</li>
<li>It requires an quote-character (default quote - ")</li>
</ol>

<p>The CSV format specified by wiki states that data fields can contain separators in quotes (supported):</p>

<blockquote>
  <p>1997,Ford,E350,"Super, luxurious truck"</p>
</blockquote>

<p>The CSV format specified by wiki states that single quotes should be handled with double-quotes (escaped_list_separator will strip away all quote characters):</p>

<blockquote>
  <p>1997,Ford,E350,"Super ""luxurious"" truck"</p>
</blockquote>

<p>The CSV format doesn't specify that any back-slash characters should be stripped away (escaped_list_separator will strip away all escape characters).</p>

<p>A possible work-around to fix the default behavior of the boost escaped_list_separator:</p>

<ol>
<li>First replace all back-slash characters (\) with two back-slash characters (\\) so they are not stripped away.</li>
<li>Secondly replace all double-quotes ("") with a single back-slash character and a quote (\")</li>
</ol>

<p>This work-around has the side-effect that empty data-fields that are represented by a double-quote, will be transformed into a single-quote-token. When iterating through the tokens, then one must check if the token is a single-quote, and treat it like an empty string.</p>

<p>Not pretty but it works, as long there are not newlines within the quotes.</p>
    </div></div></div></div><div id="solution9" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 9</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/text">text</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/csv">csv</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p><a href="https://github.com/AriaFallah/csv-parser" rel="noreferrer">I wrote a header-only, C++11 CSV parser</a>. It's well tested, fast, supports the entire CSV spec (quoted fields, delimiter/terminator in quotes, quote escaping, etc.), and is configurable to account for the CSVs that don't adhere to the specification.</p>

<p>Configuration is done through a fluent interface:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-comment">// constructor accepts any input stream</span>
CsvParser parser = <span class="hljs-built_in">CsvParser</span>(std::cin)
  .<span class="hljs-built_in">delimiter</span>(<span class="hljs-string">';'</span>)    <span class="hljs-comment">// delimited by ; instead of ,</span>
  .<span class="hljs-built_in">quote</span>(<span class="hljs-string">'\''</span>)       <span class="hljs-comment">// quoted fields use ' instead of "</span>
  .<span class="hljs-built_in">terminator</span>(<span class="hljs-string">'\0'</span>); <span class="hljs-comment">// terminated by \0 instead of by \r\n, \n, or \r</span>
</code></pre>

<p>Parsing is just a range based for loop:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"../parser.hpp"</span></span>

<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> aria::csv;

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
  <span class="hljs-function">std::ifstream <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-string">"some_file.csv"</span>)</span></span>;
  <span class="hljs-function">CsvParser <span class="hljs-title">parser</span><span class="hljs-params">(f)</span></span>;

  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; row : parser) {
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; field : row) {
      std::cout &lt;&lt; field &lt;&lt; <span class="hljs-string">" | "</span>;
    }
    std::cout &lt;&lt; std::endl;
  }
}
</code></pre>
    </div></div></div></div><div id="solution10" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 10</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/text">text</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/csv">csv</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>As all the CSV questions seem to get redirected here, I thought I'd post my answer here.  This answer does not directly address the asker's question. I wanted to be able to read in a stream that is known to be in CSV format, and also the types of each field was already known. Of course, the method below could be used to treat every field to be a string type.</p>

<p>As an example of how I wanted to be able to use a CSV input stream, consider the following input (taken from <a href="http://en.wikipedia.org/wiki/Comma-separated_values" rel="nofollow noreferrer">wikipedia's page on CSV</a>):</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-type">const</span> <span class="hljs-type">char</span> input[] =
<span class="hljs-string">"Year,Make,Model,Description,Price\n"</span>
<span class="hljs-string">"1997,Ford,E350,\"ac, abs, moon\",3000.00\n"</span>
<span class="hljs-string">"1999,Chevy,\"Venture \"\"Extended Edition\"\"\",\"\",4900.00\n"</span>
<span class="hljs-string">"1999,Chevy,\"Venture \"\"Extended Edition, Very Large\"\"\",\"\",5000.00\n"</span>
<span class="hljs-string">"1996,Jeep,Grand Cherokee,\"MUST SELL!\n\
air, moon roof, loaded\",4799.00\n"</span>
;
</code></pre>

<p>Then, I wanted to be able to read in the data like this:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-function">std::istringstream <span class="hljs-title">ss</span><span class="hljs-params">(input)</span></span>;
std::string title[<span class="hljs-number">5</span>];
<span class="hljs-type">int</span> year;
std::string make, model, desc;
<span class="hljs-type">float</span> price;
<span class="hljs-built_in">csv_istream</span>(ss)
    &gt;&gt; title[<span class="hljs-number">0</span>] &gt;&gt; title[<span class="hljs-number">1</span>] &gt;&gt; title[<span class="hljs-number">2</span>] &gt;&gt; title[<span class="hljs-number">3</span>] &gt;&gt; title[<span class="hljs-number">4</span>];
<span class="hljs-keyword">while</span> (<span class="hljs-built_in">csv_istream</span>(ss)
       &gt;&gt; year &gt;&gt; make &gt;&gt; model &gt;&gt; desc &gt;&gt; price) {
    <span class="hljs-comment">//...do something with the record...</span>
}
</code></pre>

<p>This was the solution I ended up with.</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">csv_istream</span> {
    std::istream &amp;is_;
    <span class="hljs-built_in">csv_istream</span> (std::istream &amp;is) : <span class="hljs-built_in">is_</span>(is) {}
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">scan_ws</span> <span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>{
        <span class="hljs-keyword">while</span> (is_.<span class="hljs-built_in">good</span>()) {
            <span class="hljs-type">int</span> c = is_.<span class="hljs-built_in">peek</span>();
            <span class="hljs-keyword">if</span> (c != <span class="hljs-string">' '</span> &amp;&amp; c != <span class="hljs-string">'\t'</span>) <span class="hljs-keyword">break</span>;
            is_.<span class="hljs-built_in">get</span>();
        }
    }
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">scan</span> <span class="hljs-params">(std::string *s = <span class="hljs-number">0</span>)</span> <span class="hljs-type">const</span> </span>{
        std::string ws;
        <span class="hljs-type">int</span> c = is_.<span class="hljs-built_in">get</span>();
        <span class="hljs-keyword">if</span> (is_.<span class="hljs-built_in">good</span>()) {
            <span class="hljs-keyword">do</span> {
                <span class="hljs-keyword">if</span> (c == <span class="hljs-string">','</span> || c == <span class="hljs-string">'\n'</span>) <span class="hljs-keyword">break</span>;
                <span class="hljs-keyword">if</span> (s) {
                    ws += c;
                    <span class="hljs-keyword">if</span> (c != <span class="hljs-string">' '</span> &amp;&amp; c != <span class="hljs-string">'\t'</span>) {
                        *s += ws;
                        ws.<span class="hljs-built_in">clear</span>();
                    }
                }
                c = is_.<span class="hljs-built_in">get</span>();
            } <span class="hljs-keyword">while</span> (is_.<span class="hljs-built_in">good</span>());
            <span class="hljs-keyword">if</span> (is_.<span class="hljs-built_in">eof</span>()) is_.<span class="hljs-built_in">clear</span>();
        }
    }
    <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-type">bool</span>&gt; <span class="hljs-keyword">struct</span> <span class="hljs-title class_">set_value</span> {
        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">operator</span> <span class="hljs-params">()</span> <span class="hljs-params">(std::string in, T &amp;v)</span> <span class="hljs-type">const</span> </span>{
            std::<span class="hljs-built_in">istringstream</span>(in) &gt;&gt; v;
        }
    };
    <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-keyword">struct</span> <span class="hljs-title class_">set_value</span>&lt;T, <span class="hljs-literal">true</span>&gt; {
        <span class="hljs-keyword">template</span> &lt;<span class="hljs-type">bool</span> SIGNED&gt; <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">convert</span> <span class="hljs-params">(std::string in, T &amp;v)</span> <span class="hljs-type">const</span> </span>{
            <span class="hljs-keyword">if</span> (SIGNED) v = ::<span class="hljs-built_in">strtoll</span>(in.<span class="hljs-built_in">c_str</span>(), <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);
            <span class="hljs-keyword">else</span> v = ::<span class="hljs-built_in">strtoull</span>(in.<span class="hljs-built_in">c_str</span>(), <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);
        }
        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">operator</span> <span class="hljs-params">()</span> <span class="hljs-params">(std::string in, T &amp;v)</span> <span class="hljs-type">const</span> </span>{
            convert&lt;is_signed_int&lt;T&gt;::val&gt;(in, v);
        }
    };
    <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-type">const</span> csv_istream &amp; <span class="hljs-keyword">operator</span> &gt;&gt; (T &amp;v) <span class="hljs-type">const</span> {
        std::string tmp;
        <span class="hljs-built_in">scan</span>(&amp;tmp);
        set_value&lt;T, is_int&lt;T&gt;::val&gt;()(tmp, v);
        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;
    }
    <span class="hljs-type">const</span> csv_istream &amp; <span class="hljs-keyword">operator</span> &gt;&gt; (std::string &amp;v) <span class="hljs-type">const</span> {
        v.<span class="hljs-built_in">clear</span>();
        <span class="hljs-built_in">scan_ws</span>();
        <span class="hljs-keyword">if</span> (is_.<span class="hljs-built_in">peek</span>() != <span class="hljs-string">'"'</span>) <span class="hljs-built_in">scan</span>(&amp;v);
        <span class="hljs-keyword">else</span> {
            std::string tmp;
            is_.<span class="hljs-built_in">get</span>();
            std::<span class="hljs-built_in">getline</span>(is_, tmp, <span class="hljs-string">'"'</span>);
            <span class="hljs-keyword">while</span> (is_.<span class="hljs-built_in">peek</span>() == <span class="hljs-string">'"'</span>) {
                v += tmp;
                v += is_.<span class="hljs-built_in">get</span>();
                std::<span class="hljs-built_in">getline</span>(is_, tmp, <span class="hljs-string">'"'</span>);
            }
            v += tmp;
            <span class="hljs-built_in">scan</span>();
        }
        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;
    }
    <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
    <span class="hljs-type">const</span> csv_istream &amp; <span class="hljs-keyword">operator</span> &gt;&gt; (T &amp;(*manip)(T &amp;)) <span class="hljs-type">const</span> {
        is_ &gt;&gt; manip;
        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;
    }
    <span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">bool</span> <span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>{ <span class="hljs-keyword">return</span> !is_.<span class="hljs-built_in">fail</span>(); }
};
</code></pre>

<p>With the following helpers that may be simplified by the new integral traits templates in C++11:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-keyword">struct</span> <span class="hljs-title class_">is_signed_int</span> { <span class="hljs-keyword">enum</span> { val = <span class="hljs-literal">false</span> }; };
<span class="hljs-keyword">template</span> &lt;&gt; <span class="hljs-keyword">struct</span> <span class="hljs-title class_">is_signed_int</span>&lt;<span class="hljs-type">short</span>&gt; { <span class="hljs-keyword">enum</span> { val = <span class="hljs-literal">true</span>}; };
<span class="hljs-keyword">template</span> &lt;&gt; <span class="hljs-keyword">struct</span> <span class="hljs-title class_">is_signed_int</span>&lt;<span class="hljs-type">int</span>&gt; { <span class="hljs-keyword">enum</span> { val = <span class="hljs-literal">true</span>}; };
<span class="hljs-keyword">template</span> &lt;&gt; <span class="hljs-keyword">struct</span> <span class="hljs-title class_">is_signed_int</span>&lt;<span class="hljs-type">long</span>&gt; { <span class="hljs-keyword">enum</span> { val = <span class="hljs-literal">true</span>}; };
<span class="hljs-keyword">template</span> &lt;&gt; <span class="hljs-keyword">struct</span> <span class="hljs-title class_">is_signed_int</span>&lt;<span class="hljs-type">long</span> <span class="hljs-type">long</span>&gt; { <span class="hljs-keyword">enum</span> { val = <span class="hljs-literal">true</span>}; };

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-keyword">struct</span> <span class="hljs-title class_">is_unsigned_int</span> { <span class="hljs-keyword">enum</span> { val = <span class="hljs-literal">false</span> }; };
<span class="hljs-keyword">template</span> &lt;&gt; <span class="hljs-keyword">struct</span> <span class="hljs-title class_">is_unsigned_int</span>&lt;<span class="hljs-type">unsigned</span> <span class="hljs-type">short</span>&gt; { <span class="hljs-keyword">enum</span> { val = <span class="hljs-literal">true</span>}; };
<span class="hljs-keyword">template</span> &lt;&gt; <span class="hljs-keyword">struct</span> <span class="hljs-title class_">is_unsigned_int</span>&lt;<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>&gt; { <span class="hljs-keyword">enum</span> { val = <span class="hljs-literal">true</span>}; };
<span class="hljs-keyword">template</span> &lt;&gt; <span class="hljs-keyword">struct</span> <span class="hljs-title class_">is_unsigned_int</span>&lt;<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>&gt; { <span class="hljs-keyword">enum</span> { val = <span class="hljs-literal">true</span>}; };
<span class="hljs-keyword">template</span> &lt;&gt; <span class="hljs-keyword">struct</span> <span class="hljs-title class_">is_unsigned_int</span>&lt;<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span>&gt; { <span class="hljs-keyword">enum</span> { val = <span class="hljs-literal">true</span>}; };

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-keyword">struct</span> <span class="hljs-title class_">is_int</span> {
    <span class="hljs-keyword">enum</span> { val = (is_signed_int&lt;T&gt;::val || is_unsigned_int&lt;T&gt;::val) };
};
</code></pre>

<p><a href="https://tio.run/##rVZtT@NGEP7uXzG4UrDpFuXK0VNev/ToqRVUlaAnVQRFxt6EFc6u5d2YIi6/nc6sHbKOHTig5iWb3Zlnnnn1xln20zyOH38QMk6XCYehUNrkPFqMvc2eXm95hi@yNDK4Z@4zLqMFh4sx4PEyNiD0VIu55MlUSAMPwOVygR9FlMIIZlGqOawG@OugtOsO9Y3KzXgbAiX5dwLg33vUUyXn79WHF0BejOVSviearvZw/QXeFth2rLfEuB3pTeHeDfXuyNuAe4BPDSGoJ/li3O/TwbdvDTrVUUjWVoPHCjnWxVSUrVTBa5P0@@utDqIM7LYrGGzLhNAnewGtHlZWvlACUxtHcnqnIQghVlKvPaDn7kak3NI/nCuVBGHoHNJDDsfoIUlknN8G4aB@PoMghr0R7ONPpwPlemL2Q7hGXrdb0mSHGxek5LnFtvINXROYtAONBLpN8q7Mnd5Aupy3rBHd3c4mamtj4@EIvWL7lNFyPZHtHq41dNgCZSOu4ccRxIPWw2ei2Y5Gz4FFdAPQtHkYpzzKt5NXz8HzOzsCaoVbyqhZJXTI1YyiTssGIbcQ2tqQwbVS6VMzam6m2EhL7kTG1o/KeB4ZlVO518pISAYX0CmahVRrOBQtWyoQMoTxGIoGx8FOkk16QyROA2bs2Ntokktw/vuXP08@j0v6yK3guXkNdYpuiRFCgWmyakalKXpwGE/xSxAy6OLvVlo4vSocjeXzKqv/JdCVg8PWkTkOSLkIXxXy0oo7GjsbcpjAoJ2MS9ksso1JmkBBB7ccGrV8li@CDecwQOE67ZybZS7hwNyIqjFLR17k6rJqY100O6ea721zrhzZdor4OERKz1yetgRaOqEtLjsm@JMO7qdCcjLMwEaEjNYFnUlRcRtV3JoDrqC51mDwdLKDyqvo1Odcu0EbtNY22JXk1jL9vvRjqQYHi0iKLKR12CwAdIckrczL9fYEbifN5gawVtijKM4ikaKHqIJXEnp7LiIhSfjBqwjfRDm2dbY0l1cw8vx/sALZWXTL2ZlKeMo@cx3nIjNCSfZXLmI@kb7nf@j1PrHfVJ6wk6PjLpv4UcwgutYMFkrJic@Out3uYbe7Fu6xX294cY@CX7lEdhwm/sQ/@ddwmeAF7iQRZID2UNf@@9h7AwCDrzy/h9Mon3MX7LjO5hf2B@cZ@5JHMgHEzdUt5yh59vf5BZyfnJ7uTeTEi0ReugO5UjOGF8wITRG1T71ehYb3yubbBbQObESxsmodJ0zKL4@vBh4l4h4DXT9fUNTRIoUdEoz7wJuhUQMZxX3gObUVaB3aIsByKWG7V5v1B2f9s7M@ctYfkUbVsW24JTRxLCvylttP4kYLYkefllnoXmxjtTQwHILfJ@XRpU9fLA5tXvlbDW0lCb6StJaekSQCa1FLZrcscaxELd3dktaLStSuS1lMMN7kPW/1@B8" rel="nofollow noreferrer" title="C++ (gcc)  Try It Online">Try it online!</a></p>
    </div></div></div></div><div id="solution11" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 11</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/text">text</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/csv">csv</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>You might want to look at my FOSS project <a href="http://code.google.com/p/csvfix/" rel="nofollow noreferrer">CSVfix</a> (<a href="https://bitbucket.org/neilb/csvfix/" rel="nofollow noreferrer"><em>updated link</em></a>), which is a CSV stream editor written in C++. The CSV parser is no prize, but does the job and the whole package may do what you need without you writing any code.</p>

<p>See <a href="https://bitbucket.org/neilb/csvfix/src/default/alib/src/a_csv.cpp?fileviewer=file-view-default" rel="nofollow noreferrer">alib/src/a_csv.cpp</a> for the CSV parser, and <a href="https://bitbucket.org/neilb/csvfix/src/default/csvfix/src/csved_ioman.cpp?fileviewer=file-view-default#csved_ioman.cpp-348" rel="nofollow noreferrer">csvlib/src/csved_ioman.cpp</a> (<code>IOManager::ReadCSV</code>) for a usage example.</p>
    </div></div></div></div><div id="solution12" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 12</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/text">text</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/csv">csv</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Another CSV I/O library can be found here:</p>

<p><a href="http://code.google.com/p/fast-cpp-csv-parser/" rel="noreferrer">http://code.google.com/p/fast-cpp-csv-parser/</a></p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"csv.h"</span></span>

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>{
  <span class="hljs-function">io::CSVReader&lt;3&gt; <span class="hljs-title">in</span><span class="hljs-params">(<span class="hljs-string">"ram.csv"</span>)</span></span>;
  in.<span class="hljs-built_in">read_header</span>(io::ignore_extra_column, <span class="hljs-string">"vendor"</span>, <span class="hljs-string">"size"</span>, <span class="hljs-string">"speed"</span>);
  std::string vendor; <span class="hljs-type">int</span> size; <span class="hljs-type">double</span> speed;
  <span class="hljs-keyword">while</span>(in.<span class="hljs-built_in">read_row</span>(vendor, size, speed)){
    <span class="hljs-comment">// do stuff with the data</span>
  }
}
</code></pre>
    </div></div></div></div><div id="solution13" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 13</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/text">text</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/csv">csv</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Another solution similar to <a href="https://stackoverflow.com/a/1120224/1749822">Loki Astari's answer</a>, in C++11. Rows here are <code>std::tuple</code>s of a given type. The code scans one line, then scans until each delimiter, and then converts and dumps the value directly into the tuple (with a bit of template code).</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> row : <span class="hljs-built_in">csv</span>&lt;std::string, <span class="hljs-type">int</span>, <span class="hljs-type">float</span>&gt;(file, <span class="hljs-string">','</span>)) {
    std::cout &lt;&lt; <span class="hljs-string">"first col: "</span> &lt;&lt; std::<span class="hljs-built_in">get</span>&lt;<span class="hljs-number">0</span>&gt;(row) &lt;&lt; std::endl;
}
</code></pre>

<p><strong>Advanges:</strong></p>

<ul>
<li>quite clean and simple to use, only C++11.</li>
<li>automatic type conversion into <code>std::tuple&lt;t1, ...&gt;</code> via <code>operator&gt;&gt;</code>.</li>
</ul>

<p><strong>What's missing:</strong></p>

<ul>
<li>escaping and quoting</li>
<li>no error handling in case of malformed CSV.</li>
</ul>

<p>The main code:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iterator&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sstream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span>

<span class="hljs-keyword">namespace</span> csvtools {
    <span class="hljs-comment">/// Read the last element of the tuple without calling recursively</span>
    <span class="hljs-keyword">template</span> &lt;std::<span class="hljs-type">size_t</span> idx, <span class="hljs-keyword">class</span>... fields&gt;
    <span class="hljs-keyword">typename</span> std::enable_if&lt;idx &gt;= std::tuple_size&lt;std::tuple&lt;fields...&gt;&gt;::value - <span class="hljs-number">1</span>&gt;::type
    <span class="hljs-built_in">read_tuple</span>(std::istream &amp;in, std::tuple&lt;fields...&gt; &amp;out, <span class="hljs-type">const</span> <span class="hljs-type">char</span> delimiter) {
        std::string cell;
        std::<span class="hljs-built_in">getline</span>(in, cell, delimiter);
        <span class="hljs-function">std::stringstream <span class="hljs-title">cell_stream</span><span class="hljs-params">(cell)</span></span>;
        cell_stream &gt;&gt; std::<span class="hljs-built_in">get</span>&lt;idx&gt;(out);
    }

    <span class="hljs-comment">/// Read the @p idx-th element of the tuple and then calls itself with @p idx + 1 to</span>
    <span class="hljs-comment">/// read the next element of the tuple. Automatically falls in the previous case when</span>
    <span class="hljs-comment">/// reaches the last element of the tuple thanks to enable_if</span>
    <span class="hljs-keyword">template</span> &lt;std::<span class="hljs-type">size_t</span> idx, <span class="hljs-keyword">class</span>... fields&gt;
    <span class="hljs-keyword">typename</span> std::enable_if&lt;idx &lt; std::tuple_size&lt;std::tuple&lt;fields...&gt;&gt;::value - <span class="hljs-number">1</span>&gt;::<span class="hljs-function">type
    <span class="hljs-title">read_tuple</span><span class="hljs-params">(std::istream &amp;in, std::tuple&lt;fields...&gt; &amp;out, <span class="hljs-type">const</span> <span class="hljs-type">char</span> delimiter)</span> </span>{
        std::string cell;
        std::<span class="hljs-built_in">getline</span>(in, cell, delimiter);
        <span class="hljs-function">std::stringstream <span class="hljs-title">cell_stream</span><span class="hljs-params">(cell)</span></span>;
        cell_stream &gt;&gt; std::<span class="hljs-built_in">get</span>&lt;idx&gt;(out);
        <span class="hljs-built_in">read_tuple</span>&lt;idx + <span class="hljs-number">1</span>, fields...&gt;(in, out, delimiter);
    }
}

<span class="hljs-comment">/// Iterable csv wrapper around a stream. @p fields the list of types that form up a row.</span>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span>... fields&gt;
<span class="hljs-keyword">class</span> <span class="hljs-title class_">csv</span> {
    std::istream &amp;_in;
    <span class="hljs-type">const</span> <span class="hljs-type">char</span> _delim;
<span class="hljs-keyword">public</span>:
    <span class="hljs-keyword">typedef</span> std::tuple&lt;fields...&gt; value_type;
    <span class="hljs-keyword">class</span> <span class="hljs-title class_">iterator</span>;

    <span class="hljs-comment">/// Construct from a stream.</span>
    <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-title">csv</span><span class="hljs-params">(std::istream &amp;in, <span class="hljs-type">const</span> <span class="hljs-type">char</span> delim)</span> : _in(in), _delim(delim) {</span>}

    <span class="hljs-comment">/// Status of the underlying stream</span>
    <span class="hljs-comment">/// @{</span>
    <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">bool</span> <span class="hljs-title">good</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>{
        <span class="hljs-keyword">return</span> _in.<span class="hljs-built_in">good</span>();
    }
    <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">const</span> std::istream &amp;<span class="hljs-title">underlying_stream</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>{
        <span class="hljs-keyword">return</span> _in;
    }
    <span class="hljs-comment">/// @}</span>

    <span class="hljs-function"><span class="hljs-keyword">inline</span> iterator <span class="hljs-title">begin</span><span class="hljs-params">()</span></span>;
    <span class="hljs-function"><span class="hljs-keyword">inline</span> iterator <span class="hljs-title">end</span><span class="hljs-params">()</span></span>;
<span class="hljs-keyword">private</span>:

    <span class="hljs-comment">/// Reads a line into a stringstream, and then reads the line into a tuple, that is returned</span>
    <span class="hljs-function"><span class="hljs-keyword">inline</span> value_type <span class="hljs-title">read_row</span><span class="hljs-params">()</span> </span>{
        std::string line;
        std::<span class="hljs-built_in">getline</span>(_in, line);
        <span class="hljs-function">std::stringstream <span class="hljs-title">line_stream</span><span class="hljs-params">(line)</span></span>;
        std::tuple&lt;fields...&gt; retval;
        csvtools::<span class="hljs-built_in">read_tuple</span>&lt;<span class="hljs-number">0</span>, fields...&gt;(line_stream, retval, _delim);
        <span class="hljs-keyword">return</span> retval;
    }
};

<span class="hljs-comment">/// Iterator; just calls recursively @ref csv::read_row and stores the result.</span>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span>... fields&gt;
<span class="hljs-keyword">class</span> <span class="hljs-title class_">csv</span>&lt;fields...&gt;::iterator {
    csv::value_type _row;
    csv *_parent;
<span class="hljs-keyword">public</span>:
    <span class="hljs-keyword">typedef</span> std::input_iterator_tag iterator_category;
    <span class="hljs-keyword">typedef</span> csv::value_type         value_type;
    <span class="hljs-keyword">typedef</span> std::<span class="hljs-type">size_t</span>             difference_type;
    <span class="hljs-keyword">typedef</span> csv::value_type *       pointer;
    <span class="hljs-keyword">typedef</span> csv::value_type &amp;       reference;

    <span class="hljs-comment">/// Construct an empty/end iterator</span>
    <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-title">iterator</span><span class="hljs-params">()</span> : _parent(nullptr) {</span>}
    <span class="hljs-comment">/// Construct an iterator at the beginning of the @p parent csv object.</span>
    <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-title">iterator</span><span class="hljs-params">(csv &amp;parent)</span> : _parent(parent.good() ? &amp;parent : nullptr) {</span>
        ++(*<span class="hljs-keyword">this</span>);
    }

    <span class="hljs-comment">/// Read one row, if possible. Set to end if parent is not good anymore.</span>
    <span class="hljs-keyword">inline</span> iterator &amp;<span class="hljs-keyword">operator</span>++() {
        <span class="hljs-keyword">if</span> (_parent != <span class="hljs-literal">nullptr</span>) {
            _row = _parent-&gt;<span class="hljs-built_in">read_row</span>();
            <span class="hljs-keyword">if</span> (!_parent-&gt;<span class="hljs-built_in">good</span>()) {
                _parent = <span class="hljs-literal">nullptr</span>;
            }
        }
        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;
    }

    <span class="hljs-keyword">inline</span> iterator <span class="hljs-keyword">operator</span>++(<span class="hljs-type">int</span>) {
        iterator copy = *<span class="hljs-keyword">this</span>;
        ++(*<span class="hljs-keyword">this</span>);
        <span class="hljs-keyword">return</span> copy;
    }

    <span class="hljs-keyword">inline</span> csv::value_type <span class="hljs-type">const</span> &amp;<span class="hljs-keyword">operator</span>*() <span class="hljs-type">const</span> {
        <span class="hljs-keyword">return</span> _row;
    }

    <span class="hljs-keyword">inline</span> csv::value_type <span class="hljs-type">const</span> *<span class="hljs-keyword">operator</span>-&gt;() <span class="hljs-type">const</span> {
        <span class="hljs-keyword">return</span> &amp;_row;
    }

    <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>==(iterator <span class="hljs-type">const</span> &amp;other) {
        <span class="hljs-built_in">return</span> (<span class="hljs-keyword">this</span> == &amp;other) <span class="hljs-built_in">or</span> (_parent == <span class="hljs-literal">nullptr</span> <span class="hljs-keyword">and</span> other._parent == <span class="hljs-literal">nullptr</span>);
    }
    <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>!=(iterator <span class="hljs-type">const</span> &amp;other) {
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">not</span> (*<span class="hljs-keyword">this</span> == other);
    }
};

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span>... fields&gt;
<span class="hljs-keyword">typename</span> csv&lt;fields...&gt;::iterator csv&lt;fields...&gt;::<span class="hljs-built_in">begin</span>() {
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">iterator</span>(*<span class="hljs-keyword">this</span>);
}

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span>... fields&gt;
<span class="hljs-keyword">typename</span> csv&lt;fields...&gt;::iterator csv&lt;fields...&gt;::<span class="hljs-built_in">end</span>() {
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">iterator</span>();
}
</code></pre>

<p>I put a tiny working example on <a href="https://github.com/LizardM4/ballin-octo-tribble/tree/master/csv" rel="nofollow noreferrer">GitHub</a>; I've been using it for parsing some numerical data and it served its purpose.</p>
    </div></div></div></div><div id="solution14" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 14</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/text">text</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/csv">csv</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Here is another implementation of a Unicode CSV parser (works with wchar_t). I wrote part of it, while Jonathan Leffler wrote the rest.</p>

<p>Note: This parser is aimed at replicating Excel's behavior as closely as possible, specifically when importing <strong>broken or malformed</strong> CSV files.</p>

<p>This is the original question - <a href="https://stackoverflow.com/questions/15520113/parsing-csv-file-with-multiline-fields-and-escaped-double-quotes">Parsing CSV file with multiline fields and escaped double quotes</a></p>

<p>This is the code as a SSCCE (Short, Self-Contained, Correct Example).</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdbool.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;wchar.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;wctype.h&gt;</span></span>

<span class="hljs-function"><span class="hljs-keyword">extern</span> <span class="hljs-type">const</span> <span class="hljs-type">wchar_t</span> *<span class="hljs-title">nextCsvField</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">wchar_t</span> *p, <span class="hljs-type">wchar_t</span> sep, <span class="hljs-type">bool</span> *newline)</span></span>;

<span class="hljs-comment">// Returns a pointer to the start of the next field,</span>
<span class="hljs-comment">// or zero if this is the last field in the CSV</span>
<span class="hljs-comment">// p is the start position of the field</span>
<span class="hljs-comment">// sep is the separator used, i.e. comma or semicolon</span>
<span class="hljs-comment">// newline says whether the field ends with a newline or with a comma</span>
<span class="hljs-function"><span class="hljs-type">const</span> <span class="hljs-type">wchar_t</span> *<span class="hljs-title">nextCsvField</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">wchar_t</span> *p, <span class="hljs-type">wchar_t</span> sep, <span class="hljs-type">bool</span> *newline)</span>
</span>{
    <span class="hljs-comment">// Parse quoted sequences</span>
    <span class="hljs-keyword">if</span> (<span class="hljs-string">'"'</span> == p[<span class="hljs-number">0</span>]) {
        p++;
        <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) {
            <span class="hljs-comment">// Find next double-quote</span>
            p = <span class="hljs-built_in">wcschr</span>(p, <span class="hljs-string">L'"'</span>);
            <span class="hljs-comment">// If we don't find it or it's the last symbol</span>
            <span class="hljs-comment">// then this is the last field</span>
            <span class="hljs-keyword">if</span> (!p || !p[<span class="hljs-number">1</span>])
                <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
            <span class="hljs-comment">// Check for "", it is an escaped double-quote</span>
            <span class="hljs-keyword">if</span> (p[<span class="hljs-number">1</span>] != <span class="hljs-string">'"'</span>)
                <span class="hljs-keyword">break</span>;
            <span class="hljs-comment">// Skip the escaped double-quote</span>
            p += <span class="hljs-number">2</span>;
        }
    }

    <span class="hljs-comment">// Find next newline or comma.</span>
    <span class="hljs-type">wchar_t</span> newline_or_sep[<span class="hljs-number">4</span>] = <span class="hljs-string">L"\n\r "</span>;
    newline_or_sep[<span class="hljs-number">2</span>] = sep;
    p = <span class="hljs-built_in">wcspbrk</span>(p, newline_or_sep);

    <span class="hljs-comment">// If no newline or separator, this is the last field.</span>
    <span class="hljs-keyword">if</span> (!p)
        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;

    <span class="hljs-comment">// Check if we had newline.</span>
    *newline = (p[<span class="hljs-number">0</span>] == <span class="hljs-string">'\r'</span> || p[<span class="hljs-number">0</span>] == <span class="hljs-string">'\n'</span>);

    <span class="hljs-comment">// Handle "\r\n", otherwise just increment</span>
    <span class="hljs-keyword">if</span> (p[<span class="hljs-number">0</span>] == <span class="hljs-string">'\r'</span> &amp;&amp; p[<span class="hljs-number">1</span>] == <span class="hljs-string">'\n'</span>)
        p += <span class="hljs-number">2</span>;
    <span class="hljs-keyword">else</span>
        p++;

    <span class="hljs-keyword">return</span> p;
}

<span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">wchar_t</span> *<span class="hljs-title">csvFieldData</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">wchar_t</span> *fld_s, <span class="hljs-type">const</span> <span class="hljs-type">wchar_t</span> *fld_e, <span class="hljs-type">wchar_t</span> *buffer, <span class="hljs-type">size_t</span> buflen)</span>
</span>{
    <span class="hljs-type">wchar_t</span> *dst = buffer;
    <span class="hljs-type">wchar_t</span> *end = buffer + buflen - <span class="hljs-number">1</span>;
    <span class="hljs-type">const</span> <span class="hljs-type">wchar_t</span> *src = fld_s;

    <span class="hljs-keyword">if</span> (*src == <span class="hljs-string">L'"'</span>)
    {
        <span class="hljs-type">const</span> <span class="hljs-type">wchar_t</span> *p = src + <span class="hljs-number">1</span>;
        <span class="hljs-keyword">while</span> (p &lt; fld_e &amp;&amp; dst &lt; end)
        {
            <span class="hljs-keyword">if</span> (p[<span class="hljs-number">0</span>] == <span class="hljs-string">L'"'</span> &amp;&amp; p+<span class="hljs-number">1</span> &lt; fld_s &amp;&amp; p[<span class="hljs-number">1</span>] == <span class="hljs-string">L'"'</span>)
            {
                *dst++ = p[<span class="hljs-number">0</span>];
                p += <span class="hljs-number">2</span>;
            }
            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (p[<span class="hljs-number">0</span>] == <span class="hljs-string">L'"'</span>)
            {
                p++;
                <span class="hljs-keyword">break</span>;
            }
            <span class="hljs-keyword">else</span>
                *dst++ = *p++;
        }
        src = p;
    }
    <span class="hljs-keyword">while</span> (src &lt; fld_e &amp;&amp; dst &lt; end)
        *dst++ = *src++;
    <span class="hljs-keyword">if</span> (dst &gt;= end)
        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
    *dst = <span class="hljs-string">L'\0'</span>;
    <span class="hljs-keyword">return</span>(buffer);
}

<span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">dissect</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">wchar_t</span> *line)</span>
</span>{
    <span class="hljs-type">const</span> <span class="hljs-type">wchar_t</span> *start = line;
    <span class="hljs-type">const</span> <span class="hljs-type">wchar_t</span> *next;
    <span class="hljs-type">bool</span>     eol;
    <span class="hljs-built_in">wprintf</span>(<span class="hljs-string">L"Input %3zd: [%.*ls]\n"</span>, <span class="hljs-built_in">wcslen</span>(line), <span class="hljs-built_in">wcslen</span>(line)<span class="hljs-number">-1</span>, line);
    <span class="hljs-keyword">while</span> ((next = <span class="hljs-built_in">nextCsvField</span>(start, <span class="hljs-string">L','</span>, &amp;eol)) != <span class="hljs-number">0</span>)
    {
        <span class="hljs-type">wchar_t</span> buffer[<span class="hljs-number">1024</span>];
        <span class="hljs-built_in">wprintf</span>(<span class="hljs-string">L"Raw Field: [%.*ls] (eol = %d)\n"</span>, (next - start - eol), start, eol);
        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">csvFieldData</span>(start, next<span class="hljs-number">-1</span>, buffer, <span class="hljs-built_in">sizeof</span>(buffer)/<span class="hljs-built_in">sizeof</span>(buffer[<span class="hljs-number">0</span>])) != <span class="hljs-number">0</span>)
            <span class="hljs-built_in">wprintf</span>(<span class="hljs-string">L"Field %3zd: [%ls]\n"</span>, <span class="hljs-built_in">wcslen</span>(buffer), buffer);
        start = next;
    }
}

<span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">wchar_t</span> multiline[] =
   <span class="hljs-string">L"First field of first row,\"This field is multiline\n"</span>
    <span class="hljs-string">"\n"</span>
    <span class="hljs-string">"but that's OK because it's enclosed in double quotes, and this\n"</span>
    <span class="hljs-string">"is an escaped \"\" double quote\" but this one \"\" is not\n"</span>
    <span class="hljs-string">"   \"This is second field of second row, but it is not multiline\n"</span>
    <span class="hljs-string">"   because it doesn't start \n"</span>
    <span class="hljs-string">"   with an immediate double quote\"\n"</span>
    ;

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>
</span>{
    <span class="hljs-type">wchar_t</span> line[<span class="hljs-number">1024</span>];

    <span class="hljs-keyword">while</span> (<span class="hljs-built_in">fgetws</span>(line, <span class="hljs-built_in">sizeof</span>(line)/<span class="hljs-built_in">sizeof</span>(line[<span class="hljs-number">0</span>]), stdin))
        <span class="hljs-built_in">dissect</span>(line);
    <span class="hljs-built_in">dissect</span>(multiline);

    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>
    </div></div></div></div><div id="solution15" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 15</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/text">text</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/csv">csv</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>This is an old thread but its still at the top of search results, so I'm adding my solution using std::stringstream and a simple string replace method by Yves Baumes I found here.  </p>

<p>The following example will read a file line by line, ignore comment lines starting with // and parse the other lines into a combination of strings, ints and doubles. Stringstream does the parsing, but expects fields to be delimited by whitespace, so I use stringreplace to turn commas into spaces first. It handles tabs ok, but doesn't deal with quoted strings.</p>

<p>Bad or missing input is simply ignored, which may or may not be good, depending on your circumstance.</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sstream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fstream&gt;</span></span>

<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">StringReplace</span><span class="hljs-params">(std::string&amp; str, <span class="hljs-type">const</span> std::string&amp; oldStr, <span class="hljs-type">const</span> std::string&amp; newStr)</span>
<span class="hljs-comment">// code by  Yves Baumes</span>
<span class="hljs-comment">// http://stackoverflow.com/questions/1494399/how-do-i-search-find-and-replace-in-a-standard-string</span>
</span>{
  <span class="hljs-type">size_t</span> pos = <span class="hljs-number">0</span>;
  <span class="hljs-keyword">while</span>((pos = str.<span class="hljs-built_in">find</span>(oldStr, pos)) != std::string::npos)
  {
     str.<span class="hljs-built_in">replace</span>(pos, oldStr.<span class="hljs-built_in">length</span>(), newStr);
     pos += newStr.<span class="hljs-built_in">length</span>();
  }
}

<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">LoadCSV</span><span class="hljs-params">(std::string &amp;filename)</span> </span>{
   <span class="hljs-function">std::ifstream <span class="hljs-title">stream</span><span class="hljs-params">(filename)</span></span>;
   std::string in_line;
   std::string Field;
   std::string Chan;
   <span class="hljs-type">int</span> ChanType;
   <span class="hljs-type">double</span> Scale;
   <span class="hljs-type">int</span> Import;
   <span class="hljs-keyword">while</span> (std::<span class="hljs-built_in">getline</span>(stream, in_line)) {
      <span class="hljs-built_in">StringReplace</span>(in_line, <span class="hljs-string">","</span>, <span class="hljs-string">" "</span>);
      <span class="hljs-function">std::stringstream <span class="hljs-title">line</span><span class="hljs-params">(in_line)</span></span>;
      line &gt;&gt; Field &gt;&gt; Chan &gt;&gt; ChanType &gt;&gt; Scale &gt;&gt; Import;
      <span class="hljs-keyword">if</span> (Field.<span class="hljs-built_in">substr</span>(<span class="hljs-number">0</span>,<span class="hljs-number">2</span>)!=<span class="hljs-string">"//"</span>) {
         <span class="hljs-comment">// do your stuff </span>
         <span class="hljs-comment">// this is CBuilder code for demonstration, sorry</span>
         <span class="hljs-built_in">ShowMessage</span>((String)Field.<span class="hljs-built_in">c_str</span>() + <span class="hljs-string">"\n"</span> + Chan.<span class="hljs-built_in">c_str</span>() + <span class="hljs-string">"\n"</span> + <span class="hljs-built_in">IntToStr</span>(ChanType) + <span class="hljs-string">"\n"</span> +<span class="hljs-built_in">FloatToStr</span>(Scale) + <span class="hljs-string">"\n"</span> +<span class="hljs-built_in">IntToStr</span>(Import));
      }
   }
}
</code></pre>
    </div></div></div></div><div id="solution16" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 16</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/text">text</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/csv">csv</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>I needed an easy-to-use C++ library for parsing CSV files but couldn't find any available, so I ended up building one.
<a href="https://github.com/d99kris/rapidcsv/" rel="nofollow noreferrer">Rapidcsv</a> is a C++11 header-only library which gives direct access to parsed columns (or rows) as vectors, in datatype of choice. For example:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;rapidcsv.h&gt;</span></span>

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
  <span class="hljs-function">rapidcsv::Document <span class="hljs-title">doc</span><span class="hljs-params">(<span class="hljs-string">"../tests/msft.csv"</span>)</span></span>;

  std::vector&lt;<span class="hljs-type">float</span>&gt; close = doc.<span class="hljs-built_in">GetColumn</span>&lt;<span class="hljs-type">float</span>&gt;(<span class="hljs-string">"Close"</span>);
  std::cout &lt;&lt; <span class="hljs-string">"Read "</span> &lt;&lt; close.<span class="hljs-built_in">size</span>() &lt;&lt; <span class="hljs-string">" values."</span> &lt;&lt; std::endl;
}
</code></pre>
    </div></div></div></div><div id="solution17" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 17</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/text">text</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/csv">csv</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>You can use the header-only <a href="https://github.com/ashaduri/csv-parser" rel="nofollow noreferrer">Csv::Parser</a> library.</p>
<ul>
<li>It fully supports RFC 4180, including quoted values, escaped quotes, and newlines in field values.</li>
<li>It requires only standard C++ (C++17).</li>
<li>It supports reading CSV data from <code>std::string_view</code> at compile-time.</li>
<li>It's extensively tested using <a href="https://github.com/catchorg/Catch2" rel="nofollow noreferrer">Catch2</a>.</li>
</ul>
    </div></div></div></div><div id="solution18" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 18</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/text">text</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/csv">csv</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Here is code for reading a matrix, note you also have a csvwrite function in matlab</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">loadFromCSV</span><span class="hljs-params">( <span class="hljs-type">const</span> std::string&amp; filename )</span>
</span>{
    <span class="hljs-function">std::ifstream       <span class="hljs-title">file</span><span class="hljs-params">( filename.c_str() )</span></span>;
    std::vector&lt; std::vector&lt;std::string&gt; &gt;   matrix;
    std::vector&lt;std::string&gt;   row;
    std::string                line;
    std::string                cell;

    <span class="hljs-keyword">while</span>( file )
    {
        std::<span class="hljs-built_in">getline</span>(file,line);
        <span class="hljs-function">std::stringstream <span class="hljs-title">lineStream</span><span class="hljs-params">(line)</span></span>;
        row.<span class="hljs-built_in">clear</span>();

        <span class="hljs-keyword">while</span>( std::<span class="hljs-built_in">getline</span>( lineStream, cell, <span class="hljs-string">','</span> ) )
            row.<span class="hljs-built_in">push_back</span>( cell );

        <span class="hljs-keyword">if</span>( !row.<span class="hljs-built_in">empty</span>() )
            matrix.<span class="hljs-built_in">push_back</span>( row );
    }

    <span class="hljs-keyword">for</span>( <span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-built_in">int</span>(matrix.<span class="hljs-built_in">size</span>()); i++ )
    {
        <span class="hljs-keyword">for</span>( <span class="hljs-type">int</span> j=<span class="hljs-number">0</span>; j&lt;<span class="hljs-built_in">int</span>(matrix[i].<span class="hljs-built_in">size</span>()); j++ )
            std::cout &lt;&lt; matrix[i][j] &lt;&lt; <span class="hljs-string">" "</span>;

        std::cout &lt;&lt; std::endl;
    }
}
</code></pre>
    </div></div></div></div><div id="solution19" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 19</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/text">text</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/csv">csv</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Excuse me, but this all seems like a great deal of elaborate syntax to hide a few lines of code.</p>

<p>Why not this:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-comment">/**

  Read line from a CSV file

  @param[in] fp file pointer to open file
  @param[in] vls reference to vector of strings to hold next line

  */</span>
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">readCSV</span><span class="hljs-params">( FILE *fp, std::vector&lt;std::string&gt;&amp; vls )</span>
</span>{
    vls.<span class="hljs-built_in">clear</span>();
    <span class="hljs-keyword">if</span>( ! fp )
        <span class="hljs-keyword">return</span>;
    <span class="hljs-type">char</span> buf[<span class="hljs-number">10000</span>];
    <span class="hljs-keyword">if</span>( ! <span class="hljs-built_in">fgets</span>( buf,<span class="hljs-number">999</span>,fp) )
        <span class="hljs-keyword">return</span>;
    std::string s = buf;
    <span class="hljs-type">int</span> p,q;
    q = <span class="hljs-number">-1</span>;
    <span class="hljs-comment">// loop over columns</span>
    <span class="hljs-keyword">while</span>( <span class="hljs-number">1</span> ) {
        p = q;
        q = s.<span class="hljs-built_in">find_first_of</span>(<span class="hljs-string">",\n"</span>,p+<span class="hljs-number">1</span>);
        <span class="hljs-keyword">if</span>( q == <span class="hljs-number">-1</span> ) 
            <span class="hljs-keyword">break</span>;
        vls.<span class="hljs-built_in">push_back</span>( s.<span class="hljs-built_in">substr</span>(p+<span class="hljs-number">1</span>,q-p<span class="hljs-number">-1</span>) );
    }
}

<span class="hljs-type">int</span> _tmain(<span class="hljs-type">int</span> argc, _TCHAR* argv[])
{
    std::vector&lt;std::string&gt; vls;
    FILE * fp = <span class="hljs-built_in">fopen</span>( argv[<span class="hljs-number">1</span>], <span class="hljs-string">"r"</span> );
    <span class="hljs-keyword">if</span>( ! fp )
        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
    <span class="hljs-built_in">readCSV</span>( fp, vls );
    <span class="hljs-built_in">readCSV</span>( fp, vls );
    <span class="hljs-built_in">readCSV</span>( fp, vls );
    std::cout &lt;&lt; <span class="hljs-string">"row 3, col 4 is "</span> &lt;&lt; vls[<span class="hljs-number">3</span>].<span class="hljs-built_in">c_str</span>() &lt;&lt; <span class="hljs-string">"\n"</span>;

    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>
    </div></div></div></div><div id="solution20" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 20</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/text">text</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/csv">csv</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>You can open and read .csv file using fopen ,fscanf functions ,but the important thing is to parse the data.Simplest way to parse the data using delimiter.In case of .csv , delimiter is ','.</p>

<p>Suppose your data1.csv file is as follows : </p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp">A,<span class="hljs-number">45</span>,<span class="hljs-number">76</span>,<span class="hljs-number">01</span>
B,<span class="hljs-number">77</span>,<span class="hljs-number">67</span>,<span class="hljs-number">02</span>
C,<span class="hljs-number">63</span>,<span class="hljs-number">76</span>,<span class="hljs-number">03</span>
D,<span class="hljs-number">65</span>,<span class="hljs-number">44</span>,<span class="hljs-number">04</span>
</code></pre>

<p>you can tokenize data and store in char array and later use atoi() etc function for appropriate conversions  </p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp">FILE *fp;
<span class="hljs-type">char</span> str1[<span class="hljs-number">10</span>], str2[<span class="hljs-number">10</span>], str3[<span class="hljs-number">10</span>], str4[<span class="hljs-number">10</span>];

fp = <span class="hljs-built_in">fopen</span>(<span class="hljs-string">"G:\\data1.csv"</span>, <span class="hljs-string">"r"</span>);
<span class="hljs-keyword">if</span>(<span class="hljs-literal">NULL</span> == fp)
{
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"\nError in opening file."</span>);
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
<span class="hljs-keyword">while</span>(EOF != <span class="hljs-built_in">fscanf</span>(fp, <span class="hljs-string">" %[^,], %[^,], %[^,], %s, %s, %s, %s "</span>, str1, str2, str3, str4))
{
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n%s %s %s %s"</span>, str1, str2, str3, str4);
}
<span class="hljs-built_in">fclose</span>(fp);
</code></pre>

<p>[^,], ^ -it inverts logic , means match any string that does not contain comma then last , says to match comma that terminated previous string. </p>
    </div></div></div></div><div id="solution21" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 21</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/text">text</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/csv">csv</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>The first thing you need to do is make sure the file exists. To accomplish
this you just need to try and open the file stream at the path. After you
have opened the file stream use stream.fail() to see if it worked as expected,
or not.</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">fileExists</span><span class="hljs-params">(string fileName)</span>
</span>{

ifstream test;

test.<span class="hljs-built_in">open</span>(fileName.<span class="hljs-built_in">c_str</span>());

<span class="hljs-keyword">if</span> (test.<span class="hljs-built_in">fail</span>())
{
    test.<span class="hljs-built_in">close</span>();
    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
}
<span class="hljs-keyword">else</span>
{
    test.<span class="hljs-built_in">close</span>();
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
}
}
</code></pre>

<p>You must also verify that the file provided is the correct type of file.
To accomplish this you need to look through the file path provided until 
you find the file extension. Once you have the file extension make sure
that it is a .csv file.</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">verifyExtension</span><span class="hljs-params">(string filename)</span>
</span>{
<span class="hljs-type">int</span> period = <span class="hljs-number">0</span>;

<span class="hljs-keyword">for</span> (<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; filename.<span class="hljs-built_in">length</span>(); i++)
{
    <span class="hljs-keyword">if</span> (filename[i] == <span class="hljs-string">'.'</span>)
        period = i;
}

string extension;

<span class="hljs-keyword">for</span> (<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> i = period; i &lt; filename.<span class="hljs-built_in">length</span>(); i++)
    extension += filename[i];

<span class="hljs-keyword">if</span> (extension == <span class="hljs-string">".csv"</span>)
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
<span class="hljs-keyword">else</span>
    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
}
</code></pre>

<p>This function will return the file extension which is used later in an error message.</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-function">string <span class="hljs-title">getExtension</span><span class="hljs-params">(string filename)</span>
</span>{
<span class="hljs-type">int</span> period = <span class="hljs-number">0</span>;

<span class="hljs-keyword">for</span> (<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; filename.<span class="hljs-built_in">length</span>(); i++)
{
    <span class="hljs-keyword">if</span> (filename[i] == <span class="hljs-string">'.'</span>)
        period = i;
}

string extension;

<span class="hljs-keyword">if</span> (period != <span class="hljs-number">0</span>)
{
    <span class="hljs-keyword">for</span> (<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> i = period; i &lt; filename.<span class="hljs-built_in">length</span>(); i++)
        extension += filename[i];
}
<span class="hljs-keyword">else</span>
    extension = <span class="hljs-string">"NO FILE"</span>;

<span class="hljs-keyword">return</span> extension;
}
</code></pre>

<p>This function will actually call the error checks created above and then parse through the file.</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">parseFile</span><span class="hljs-params">(string fileName)</span>
</span>{
    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">fileExists</span>(fileName) &amp;&amp; <span class="hljs-built_in">verifyExtension</span>(fileName))
    {
        ifstream fs;
        fs.<span class="hljs-built_in">open</span>(fileName.<span class="hljs-built_in">c_str</span>());
        string fileCommand;

        <span class="hljs-keyword">while</span> (fs.<span class="hljs-built_in">good</span>())
        {
            string temp;

            <span class="hljs-built_in">getline</span>(fs, fileCommand, <span class="hljs-string">'\n'</span>);

            <span class="hljs-keyword">for</span> (<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; fileCommand.<span class="hljs-built_in">length</span>(); i++)
            {
                <span class="hljs-keyword">if</span> (fileCommand[i] != <span class="hljs-string">','</span>)
                    temp += fileCommand[i];
                <span class="hljs-keyword">else</span>
                    temp += <span class="hljs-string">" "</span>;
            }

            <span class="hljs-keyword">if</span> (temp != <span class="hljs-string">"\0"</span>)
            {
                <span class="hljs-comment">// Place your code here to run the file.</span>
            }
        }
        fs.<span class="hljs-built_in">close</span>();
    }
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">fileExists</span>(fileName))
    {
        cout &lt;&lt; <span class="hljs-string">"Error: The provided file does not exist: "</span> &lt;&lt; fileName &lt;&lt; endl;

        <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">verifyExtension</span>(fileName))
        {
            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">getExtension</span>(fileName) != <span class="hljs-string">"NO FILE"</span>)
                cout &lt;&lt; <span class="hljs-string">"\tCheck the file extension."</span> &lt;&lt; endl;
            <span class="hljs-keyword">else</span>
                cout &lt;&lt; <span class="hljs-string">"\tThere is no file in the provided path."</span> &lt;&lt; endl;
        }
    }
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">verifyExtension</span>(fileName)) 
    {
        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">getExtension</span>(fileName) != <span class="hljs-string">"NO FILE"</span>)
            cout &lt;&lt; <span class="hljs-string">"Incorrect file extension provided: "</span> &lt;&lt; <span class="hljs-built_in">getExtension</span>(fileName) &lt;&lt; endl;
        <span class="hljs-keyword">else</span>
            cout &lt;&lt; <span class="hljs-string">"There is no file in the following path: "</span> &lt;&lt; fileName &lt;&lt; endl;
    }
}
</code></pre>
    </div></div></div></div><div id="solution22" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 22</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/text">text</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/csv">csv</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Since i'm not used to boost right now, I will suggest a more simple solution. Lets suppose that your .csv file has 100 lines with 10 numbers in each line separated by a ','. You could load this data in the form of an array with the following code:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fstream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sstream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-type">int</span> A[<span class="hljs-number">100</span>][<span class="hljs-number">10</span>];
    ifstream ifs;
    ifs.<span class="hljs-built_in">open</span>(<span class="hljs-string">"name_of_file.csv"</span>);
    string s1;
    <span class="hljs-type">char</span> c;
    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">0</span>; k&lt;<span class="hljs-number">100</span>; k++)
    {
        <span class="hljs-built_in">getline</span>(ifs,s1);
        <span class="hljs-function">stringstream <span class="hljs-title">stream</span><span class="hljs-params">(s1)</span></span>;
        <span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;
        <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)
        {
            stream &gt;&gt;A[k][j];
            stream &gt;&gt; c;
            j++;
            <span class="hljs-keyword">if</span>(!stream) {<span class="hljs-keyword">break</span>;}
        }
    }


}
</code></pre>
    </div></div></div></div><div id="solution23" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 23</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/text">text</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/csv">csv</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>You can use this library:
<a href="https://github.com/vadamsky/csvworker" rel="nofollow noreferrer">https://github.com/vadamsky/csvworker</a></p>

<p>Code for example:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"csvworker.h"</span></span>

<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-comment">//</span>
    CsvWorker csv;
    csv.<span class="hljs-built_in">loadFromFile</span>(<span class="hljs-string">"example.csv"</span>);
    cout &lt;&lt; csv.<span class="hljs-built_in">getRowsNumber</span>() &lt;&lt; <span class="hljs-string">"  "</span> &lt;&lt; csv.<span class="hljs-built_in">getColumnsNumber</span>() &lt;&lt; endl;

    csv.<span class="hljs-built_in">getFieldRef</span>(<span class="hljs-number">0</span>, <span class="hljs-number">2</span>) = <span class="hljs-string">"0"</span>;
    csv.<span class="hljs-built_in">getFieldRef</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>) = <span class="hljs-string">"0"</span>;
    csv.<span class="hljs-built_in">getFieldRef</span>(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>) = <span class="hljs-string">"0"</span>;
    csv.<span class="hljs-built_in">getFieldRef</span>(<span class="hljs-number">2</span>, <span class="hljs-number">0</span>) = <span class="hljs-string">"0"</span>;
    csv.<span class="hljs-built_in">getFieldRef</span>(<span class="hljs-number">2</span>, <span class="hljs-number">4</span>) = <span class="hljs-string">"0"</span>;
    csv.<span class="hljs-built_in">getFieldRef</span>(<span class="hljs-number">3</span>, <span class="hljs-number">1</span>) = <span class="hljs-string">"0"</span>;
    csv.<span class="hljs-built_in">getFieldRef</span>(<span class="hljs-number">3</span>, <span class="hljs-number">3</span>) = <span class="hljs-string">"0"</span>;
    csv.<span class="hljs-built_in">getFieldRef</span>(<span class="hljs-number">4</span>, <span class="hljs-number">2</span>) = <span class="hljs-string">"0"</span>;

    <span class="hljs-keyword">for</span>(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;csv.<span class="hljs-built_in">getRowsNumber</span>();++i)
    {
        <span class="hljs-comment">//cout &lt;&lt; csv.getRow(i) &lt;&lt; endl;</span>
        <span class="hljs-keyword">for</span>(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;csv.<span class="hljs-built_in">getColumnsNumber</span>();++j)
        {
            cout &lt;&lt; csv.<span class="hljs-built_in">getField</span>(i, j) &lt;&lt; <span class="hljs-string">"."</span>;
        }
        cout &lt;&lt; endl;
    }

    csv.<span class="hljs-built_in">saveToFile</span>(<span class="hljs-string">"test.csv"</span>);

    <span class="hljs-comment">//</span>
    <span class="hljs-function">CsvWorker <span class="hljs-title">csv2</span><span class="hljs-params">(<span class="hljs-number">4</span>,<span class="hljs-number">4</span>)</span></span>;

    csv2.<span class="hljs-built_in">getFieldRef</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>) = <span class="hljs-string">"a"</span>;
    csv2.<span class="hljs-built_in">getFieldRef</span>(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>) = <span class="hljs-string">"b"</span>;
    csv2.<span class="hljs-built_in">getFieldRef</span>(<span class="hljs-number">0</span>, <span class="hljs-number">2</span>) = <span class="hljs-string">"r"</span>;
    csv2.<span class="hljs-built_in">getFieldRef</span>(<span class="hljs-number">0</span>, <span class="hljs-number">3</span>) = <span class="hljs-string">"a"</span>;
    csv2.<span class="hljs-built_in">getFieldRef</span>(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>) = <span class="hljs-string">"c"</span>;
    csv2.<span class="hljs-built_in">getFieldRef</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>) = <span class="hljs-string">"a"</span>;
    csv2.<span class="hljs-built_in">getFieldRef</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>) = <span class="hljs-string">"d"</span>;
    csv2.<span class="hljs-built_in">getFieldRef</span>(<span class="hljs-number">2</span>, <span class="hljs-number">0</span>) = <span class="hljs-string">"a"</span>;
    csv2.<span class="hljs-built_in">getFieldRef</span>(<span class="hljs-number">2</span>, <span class="hljs-number">1</span>) = <span class="hljs-string">"b"</span>;
    csv2.<span class="hljs-built_in">getFieldRef</span>(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>) = <span class="hljs-string">"r"</span>;
    csv2.<span class="hljs-built_in">getFieldRef</span>(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>) = <span class="hljs-string">"a"</span>;

    csv2.<span class="hljs-built_in">saveToFile</span>(<span class="hljs-string">"test2.csv"</span>);

    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>
    </div></div></div></div><div id="solution24" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 24</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/text">text</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/csv">csv</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>You gotta feel proud when you use something so beautiful as <code>boost::spirit</code></p>

<p>Here my attempt of a parser (almost) complying with the CSV specifications on this link <a href="http://www.ietf.org/rfc/rfc4180.txt" rel="nofollow noreferrer">CSV specs</a> (I didn't need line breaks within fields. Also the spaces around the commas are dismissed).</p>

<p>After you overcome the shocking experience of waiting 10 seconds for compiling this code :), you can sit back and enjoy.</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-comment">// csvparser.cpp</span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;boost/spirit/include/qi.hpp&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;boost/spirit/include/phoenix_operator.hpp&gt;</span></span>

<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span>

<span class="hljs-keyword">namespace</span> qi = boost::spirit::qi;
<span class="hljs-keyword">namespace</span> bascii = boost::spirit::ascii;

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Iterator&gt;
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">csv_parser</span> : qi::grammar&lt;Iterator, std::<span class="hljs-built_in">vector</span>&lt;std::string&gt;(), 
    bascii::space_type&gt;
{
    qi::rule&lt;Iterator, <span class="hljs-built_in">char</span>()                                           &gt; COMMA;
    qi::rule&lt;Iterator, <span class="hljs-built_in">char</span>()                                           &gt; DDQUOTE;
    qi::rule&lt;Iterator, std::<span class="hljs-built_in">string</span>(),               bascii::space_type  &gt; non_escaped;
    qi::rule&lt;Iterator, std::<span class="hljs-built_in">string</span>(),               bascii::space_type  &gt; escaped;
    qi::rule&lt;Iterator, std::<span class="hljs-built_in">string</span>(),               bascii::space_type  &gt; field;
    qi::rule&lt;Iterator, std::<span class="hljs-built_in">vector</span>&lt;std::string&gt;(),  bascii::space_type  &gt; start;

    <span class="hljs-built_in">csv_parser</span>() : csv_parser::<span class="hljs-built_in">base_type</span>(start)
    {
        <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> qi;
        <span class="hljs-keyword">using</span> qi::lit;
        <span class="hljs-keyword">using</span> qi::lexeme;
        <span class="hljs-keyword">using</span> bascii::char_;

        start       = field % <span class="hljs-string">','</span>;
        field       = escaped | non_escaped;
        escaped     = lexeme[<span class="hljs-string">'"'</span> &gt;&gt; *( char_ -(<span class="hljs-built_in">char_</span>(<span class="hljs-string">'"'</span>) | <span class="hljs-string">','</span>) | COMMA | DDQUOTE)  &gt;&gt; <span class="hljs-string">'"'</span>];
        non_escaped = lexeme[       *( char_ -(<span class="hljs-built_in">char_</span>(<span class="hljs-string">'"'</span>) | <span class="hljs-string">','</span>)                  )        ];
        DDQUOTE     = <span class="hljs-built_in">lit</span>(<span class="hljs-string">"\"\""</span>)       [_val = <span class="hljs-string">'"'</span>];
        COMMA       = <span class="hljs-built_in">lit</span>(<span class="hljs-string">","</span>)          [_val = <span class="hljs-string">','</span>];
    }

};

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    std::cout &lt;&lt; <span class="hljs-string">"Enter CSV lines [empty] to quit\n"</span>;

    <span class="hljs-keyword">using</span> bascii::space;
    <span class="hljs-keyword">typedef</span> std::string::const_iterator iterator_type;
    <span class="hljs-keyword">typedef</span> csv_parser&lt;iterator_type&gt; csv_parser;

    csv_parser grammar;
    std::string str;
    <span class="hljs-type">int</span> fid;
    <span class="hljs-keyword">while</span> (<span class="hljs-built_in">getline</span>(std::cin, str))
    {
        fid = <span class="hljs-number">0</span>;

        <span class="hljs-keyword">if</span> (str.<span class="hljs-built_in">empty</span>())
            <span class="hljs-keyword">break</span>;

        std::vector&lt;std::string&gt; csv;
        std::string::const_iterator it_beg = str.<span class="hljs-built_in">begin</span>();
        std::string::const_iterator it_end = str.<span class="hljs-built_in">end</span>();
        <span class="hljs-type">bool</span> r = <span class="hljs-built_in">phrase_parse</span>(it_beg, it_end, grammar, space, csv);

        <span class="hljs-keyword">if</span> (r &amp;&amp; it_beg == it_end)
        {
            std::cout &lt;&lt; <span class="hljs-string">"Parsing succeeded\n"</span>;
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; field: csv)
            {
                std::cout &lt;&lt; <span class="hljs-string">"field "</span> &lt;&lt; ++fid &lt;&lt; <span class="hljs-string">": "</span> &lt;&lt; field &lt;&lt; std::endl;
            }
        }
        <span class="hljs-keyword">else</span>
        {
            std::cout &lt;&lt; <span class="hljs-string">"Parsing failed\n"</span>;
        }
    }

    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>

<p>Compile:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp">make csvparser
</code></pre>

<p>Test (example stolen from <a href="https://en.wikipedia.org/wiki/Comma-separated_values#Example" rel="nofollow noreferrer">Wikipedia</a>):</p>

<pre class="lang-none s-code-block"><code>./csvparser
Enter CSV lines [empty] to quit

1999,Chevy,"Venture ""Extended Edition, Very Large""",,5000.00
Parsing succeeded
field 1: 1999
field 2: Chevy
field 3: Venture "Extended Edition, Very Large"
field 4: 
field 5: 5000.00

1999,Chevy,"Venture ""Extended Edition, Very Large""",,5000.00"
Parsing failed
</code></pre>
    </div></div></div></div><div id="solution25" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 25</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/text">text</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/csv">csv</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>This solution detects these 4 cases</p>

<p>complete class is at</p>

<p><a href="https://github.com/pedro-vicente/csv-parser" rel="nofollow noreferrer">https://github.com/pedro-vicente/csv-parser</a></p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-number">1</span>,field <span class="hljs-number">2</span>,field <span class="hljs-number">3</span>,
<span class="hljs-number">1</span>,field <span class="hljs-number">2</span>,<span class="hljs-string">"field 3 quoted, with separator"</span>,
<span class="hljs-number">1</span>,field <span class="hljs-number">2</span>,<span class="hljs-string">"field 3
with newline"</span>,
<span class="hljs-number">1</span>,field <span class="hljs-number">2</span>,<span class="hljs-string">"field 3
with newline and separator,"</span>,
</code></pre>

<p>It reads the file character by character, and reads 1 row at a time to a vector (of strings), therefore suitable for very large files.</p>

<p>Usage is</p>

<p>Iterate until an empty row is returned (end of file). A row is a vector where each entry is a CSV column.</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-type">read_csv_t</span> csv;
csv.<span class="hljs-built_in">open</span>(<span class="hljs-string">"../test.csv"</span>);
std::vector&lt;std::string&gt; row;
<span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)
{
  row = csv.<span class="hljs-built_in">read_row</span>();
  <span class="hljs-keyword">if</span> (row.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>)
  {
    <span class="hljs-keyword">break</span>;
  }
}
</code></pre>

<p>the class declaration</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">read_csv_t</span>
{
<span class="hljs-keyword">public</span>:
  <span class="hljs-built_in">read_csv_t</span>();
  <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">open</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string &amp;file_name)</span></span>;
  <span class="hljs-function">std::vector&lt;std::string&gt; <span class="hljs-title">read_row</span><span class="hljs-params">()</span></span>;
<span class="hljs-keyword">private</span>:
  std::ifstream m_ifs;
};
</code></pre>

<p>the implementation</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-function">std::vector&lt;std::string&gt; <span class="hljs-title">read_csv_t::read_row</span><span class="hljs-params">()</span>
</span>{
  <span class="hljs-type">bool</span> quote_mode = <span class="hljs-literal">false</span>;
  std::vector&lt;std::string&gt; row;
  std::string column;
  <span class="hljs-type">char</span> c;
  <span class="hljs-keyword">while</span> (m_ifs.<span class="hljs-built_in">get</span>(c))
  {
    <span class="hljs-keyword">switch</span> (c)
    {
      <span class="hljs-comment">/////////////////////////////////////////////////////////////////////////////////////////////////////</span>
      <span class="hljs-comment">//separator ',' detected. </span>
      <span class="hljs-comment">//in quote mode add character to column</span>
      <span class="hljs-comment">//push column if not in quote mode</span>
      <span class="hljs-comment">/////////////////////////////////////////////////////////////////////////////////////////////////////</span>

    <span class="hljs-keyword">case</span> <span class="hljs-string">','</span>:
      <span class="hljs-keyword">if</span> (quote_mode == <span class="hljs-literal">true</span>)
      {
        column += c;
      }
      <span class="hljs-keyword">else</span>
      {
        row.<span class="hljs-built_in">push_back</span>(column);
        column.<span class="hljs-built_in">clear</span>();
      }
      <span class="hljs-keyword">break</span>;

      <span class="hljs-comment">/////////////////////////////////////////////////////////////////////////////////////////////////////</span>
      <span class="hljs-comment">//quote '"' detected. </span>
      <span class="hljs-comment">//toggle quote mode</span>
      <span class="hljs-comment">/////////////////////////////////////////////////////////////////////////////////////////////////////</span>

    <span class="hljs-keyword">case</span> <span class="hljs-string">'"'</span>:
      quote_mode = !quote_mode;
      <span class="hljs-keyword">break</span>;

      <span class="hljs-comment">/////////////////////////////////////////////////////////////////////////////////////////////////////</span>
      <span class="hljs-comment">//line end detected</span>
      <span class="hljs-comment">//in quote mode add character to column</span>
      <span class="hljs-comment">//return row if not in quote mode</span>
      <span class="hljs-comment">/////////////////////////////////////////////////////////////////////////////////////////////////////</span>

    <span class="hljs-keyword">case</span> <span class="hljs-string">'\n'</span>:
    <span class="hljs-keyword">case</span> <span class="hljs-string">'\r'</span>:
      <span class="hljs-keyword">if</span> (quote_mode == <span class="hljs-literal">true</span>)
      {
        column += c;
      }
      <span class="hljs-keyword">else</span>
      {
        <span class="hljs-keyword">return</span> row;
      }
      <span class="hljs-keyword">break</span>;

      <span class="hljs-comment">/////////////////////////////////////////////////////////////////////////////////////////////////////</span>
      <span class="hljs-comment">//default, add character to column</span>
      <span class="hljs-comment">/////////////////////////////////////////////////////////////////////////////////////////////////////</span>

    <span class="hljs-keyword">default</span>:
      column += c;
      <span class="hljs-keyword">break</span>;
    }
  }

  <span class="hljs-comment">//return empty vector if end of file detected </span>
  m_ifs.<span class="hljs-built_in">close</span>();
  std::vector&lt;std::string&gt; v;
  <span class="hljs-keyword">return</span> v;
}
</code></pre>
    </div></div></div></div><div id="solution26" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 26</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/text">text</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/csv">csv</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p><strong><em>Parsing CSV file lines with Stream</em></strong></p>

<p>I wrote a small example of parsing CSV file lines, it can be developed with for and while loops if desired:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fstream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span>

<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{


<span class="hljs-function">ifstream <span class="hljs-title">fin</span><span class="hljs-params">(<span class="hljs-string">"Infile.csv"</span>)</span></span>;
<span class="hljs-function">ofstream <span class="hljs-title">fout</span><span class="hljs-params">(<span class="hljs-string">"OutFile.csv"</span>)</span></span>;
string strline, strremain, strCol1 , strout;

string delimeter =<span class="hljs-string">";"</span>;

<span class="hljs-type">int</span> d1;
</code></pre>

<p>to continue until the end of the file:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-keyword">while</span> (!fin.<span class="hljs-built_in">eof</span>()){ 
</code></pre>

<p>get first line from InFile :</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp">    <span class="hljs-built_in">getline</span>(fin,strline,<span class="hljs-string">'\n'</span>);      
</code></pre>

<p>find delimeter position in line:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp">    d1 = strline.<span class="hljs-built_in">find</span>(<span class="hljs-string">';'</span>);
</code></pre>

<p>and parse first column:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp">    strCol1 = strline.<span class="hljs-built_in">substr</span>(<span class="hljs-number">0</span>,d1); <span class="hljs-comment">// parse first Column</span>
    d1++;
    strremain = strline.<span class="hljs-built_in">substr</span>(d1); <span class="hljs-comment">// remaining line</span>
</code></pre>

<p>create output line in CSV format:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp">    strout.<span class="hljs-built_in">append</span>(strCol1);
    strout.<span class="hljs-built_in">append</span>(delimeter);
</code></pre>

<p>write line to Out File:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp">    fout &lt;&lt; strout &lt;&lt; endl; <span class="hljs-comment">//out file line</span>

} 

fin.<span class="hljs-built_in">close</span>();
fout.<span class="hljs-built_in">close</span>();

<span class="hljs-keyword">return</span>(<span class="hljs-number">0</span>);
}
</code></pre>

<p>This code is compiled and running. Good luck!</p>
    </div></div></div></div><div id="solution27" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 27</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/text">text</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/csv">csv</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>You could also take a look at capabilities of <code>Qt</code> library.</p>

<p>It has regular expressions support and QString class has nice methods, e.g. <code>split()</code> returning QStringList, list of strings obtained by splitting the original string with a provided delimiter. Should suffice for csv file.. </p>

<p>To get a column with a given header name I use following: <a href="https://stackoverflow.com/questions/970330/c-inheritance-qt-problem-qstring/1011601#1011601">c++ inheritance Qt problem qstring</a></p>
    </div></div></div></div><div id="solution28" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 28</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/text">text</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/csv">csv</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>If you don't want to deal with including boost in your project (it is considerably large if all you are going to use it for is CSV parsing...)</p>

<p>I have had luck with the CSV parsing here:</p>

<p><a href="http://www.zedwood.com/article/112/cpp-csv-parser" rel="nofollow">http://www.zedwood.com/article/112/cpp-csv-parser</a></p>

<p>It handles quoted fields - but does not handle inline \n characters (which is probably fine for most uses).</p>
    </div></div></div></div><div id="solution29" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 29</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/text">text</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/csv">csv</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>For what it is worth, here is my implementation. It deals with wstring input, but could be adjusted to string easily. It does not handle newline in fields (as my application does not either, but adding its support isn't too difficult) and it does not comply with "\r\n" end of line as per RFC (assuming you use std::getline), but it does handle whitespace trimming and double-quotes correctly (hopefully).</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;

<span class="hljs-comment">// trim whitespaces around field or double-quotes, remove double-quotes and replace escaped double-quotes (double double-quotes)</span>
<span class="hljs-function">wstring <span class="hljs-title">trimquote</span><span class="hljs-params">(<span class="hljs-type">const</span> wstring&amp; str, <span class="hljs-type">const</span> wstring&amp; whitespace, <span class="hljs-type">const</span> <span class="hljs-type">wchar_t</span> quotChar)</span>
</span>{
    wstring ws;
    wstring::size_type strBegin = str.<span class="hljs-built_in">find_first_not_of</span>(whitespace);
    <span class="hljs-keyword">if</span> (strBegin == wstring::npos)
        <span class="hljs-keyword">return</span> <span class="hljs-string">L""</span>;

    wstring::size_type strEnd = str.<span class="hljs-built_in">find_last_not_of</span>(whitespace);
    wstring::size_type strRange = strEnd - strBegin + <span class="hljs-number">1</span>;

    <span class="hljs-keyword">if</span>((str[strBegin] == quotChar) &amp;&amp; (str[strEnd] == quotChar))
    {
        ws = str.<span class="hljs-built_in">substr</span>(strBegin+<span class="hljs-number">1</span>, strRange<span class="hljs-number">-2</span>);
        strBegin = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">while</span>((strEnd = ws.<span class="hljs-built_in">find</span>(quotChar, strBegin)) != wstring::npos)
        {
            ws.<span class="hljs-built_in">erase</span>(strEnd, <span class="hljs-number">1</span>);
            strBegin = strEnd+<span class="hljs-number">1</span>;
        }

    }
    <span class="hljs-keyword">else</span>
        ws = str.<span class="hljs-built_in">substr</span>(strBegin, strRange);
    <span class="hljs-keyword">return</span> ws;
}

<span class="hljs-function">pair&lt;<span class="hljs-type">unsigned</span>, <span class="hljs-type">unsigned</span>&gt; <span class="hljs-title">nextCSVQuotePair</span><span class="hljs-params">(<span class="hljs-type">const</span> wstring&amp; line, <span class="hljs-type">const</span> <span class="hljs-type">wchar_t</span> quotChar, <span class="hljs-type">unsigned</span> ofs = <span class="hljs-number">0</span>)</span>
</span>{
    pair&lt;<span class="hljs-type">unsigned</span>, <span class="hljs-type">unsigned</span>&gt; r;
    r.first = line.<span class="hljs-built_in">find</span>(quotChar, ofs);
    r.second = wstring::npos;
    <span class="hljs-keyword">if</span>(r.first != wstring::npos)
    {
        r.second = r.first;
        <span class="hljs-keyword">while</span>(((r.second = line.<span class="hljs-built_in">find</span>(quotChar, r.second+<span class="hljs-number">1</span>)) != wstring::npos)
            &amp;&amp; (line[r.second+<span class="hljs-number">1</span>] == quotChar)) <span class="hljs-comment">// WARNING: assumes null-terminated string such that line[r.second+1] always exist</span>
            r.second++;

    }
    <span class="hljs-keyword">return</span> r;
}

<span class="hljs-function"><span class="hljs-type">unsigned</span> <span class="hljs-title">parseLine</span><span class="hljs-params">(vector&lt;wstring&gt;&amp; fields, <span class="hljs-type">const</span> wstring&amp; line)</span>
</span>{
    <span class="hljs-type">unsigned</span> ofs, ofs0, np;
    <span class="hljs-type">const</span> <span class="hljs-type">wchar_t</span> delim = <span class="hljs-string">L','</span>;
    <span class="hljs-type">const</span> wstring whitespace = <span class="hljs-string">L" \t\xa0\x3000\x2000\x2001\x2002\x2003\x2004\x2005\x2006\x2007\x2008\x2009\x200a\x202f\x205f"</span>;
    <span class="hljs-type">const</span> <span class="hljs-type">wchar_t</span> quotChar = <span class="hljs-string">L'\"'</span>;
    pair&lt;<span class="hljs-type">unsigned</span>, <span class="hljs-type">unsigned</span>&gt; quot;

    fields.<span class="hljs-built_in">clear</span>();

    ofs = ofs0 = <span class="hljs-number">0</span>;
    quot = <span class="hljs-built_in">nextCSVQuotePair</span>(line, quotChar);
    <span class="hljs-keyword">while</span>((np = line.<span class="hljs-built_in">find</span>(delim, ofs)) != wstring::npos)
    {
        <span class="hljs-keyword">if</span>((np &gt; quot.first) &amp;&amp; (np &lt; quot.second))
        { <span class="hljs-comment">// skip delimiter inside quoted field</span>
            ofs = quot.second+<span class="hljs-number">1</span>;
            quot = <span class="hljs-built_in">nextCSVQuotePair</span>(line, quotChar, ofs);
            <span class="hljs-keyword">continue</span>;
        }
        fields.<span class="hljs-built_in">push_back</span>( <span class="hljs-built_in">trimquote</span>(line.<span class="hljs-built_in">substr</span>(ofs0, np-ofs0), whitespace, quotChar) );
        ofs = ofs0 = np+<span class="hljs-number">1</span>;
    }
    fields.<span class="hljs-built_in">push_back</span>( <span class="hljs-built_in">trimquote</span>(line.<span class="hljs-built_in">substr</span>(ofs0), whitespace, quotChar) );

    <span class="hljs-keyword">return</span> fields.<span class="hljs-built_in">size</span>();
}
</code></pre>
    </div></div></div></div><div id="solution30" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 30</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/text">text</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/csv">csv</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Here is a ready-to use function if all you need is to load a data file of doubles (no integers, no text).</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sstream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fstream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iterator&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span>

<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;

<span class="hljs-comment">/**
 * Parse a CSV data file and fill the 2d STL vector "data".
 * Limits: only "pure datas" of doubles, not encapsulated by " and without \n inside.
 * Further no formatting in the data (e.g. scientific notation)
 * It however handles both dots and commas as decimal separators and removes thousand separator.
 * 
 * returnCodes[0]: file access 0-&gt; ok 1-&gt; not able to read; 2-&gt; decimal separator equal to comma separator
 * returnCodes[1]: number of records
 * returnCodes[2]: number of fields. -1 If rows have different field size
 * 
 */</span>
<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt;
<span class="hljs-title">readCsvData</span> <span class="hljs-params">(vector &lt;vector &lt;<span class="hljs-type">double</span>&gt;&gt;&amp; data, <span class="hljs-type">const</span> string&amp; filename, <span class="hljs-type">const</span> string&amp; delimiter, <span class="hljs-type">const</span> string&amp; decseparator)</span></span>{

 <span class="hljs-type">int</span> vv[<span class="hljs-number">3</span>] = { <span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span> };
 <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">returnCodes</span><span class="hljs-params">(&amp;vv[<span class="hljs-number">0</span>], &amp;vv[<span class="hljs-number">0</span>]+<span class="hljs-number">3</span>)</span></span>;

 string rowstring, stringtoken;
 <span class="hljs-type">double</span> doubletoken;
 <span class="hljs-type">int</span> rowcount=<span class="hljs-number">0</span>;
 <span class="hljs-type">int</span> fieldcount=<span class="hljs-number">0</span>;
 data.<span class="hljs-built_in">clear</span>();

 <span class="hljs-function">ifstream <span class="hljs-title">iFile</span><span class="hljs-params">(filename, ios_base::in)</span></span>;
 <span class="hljs-keyword">if</span> (!iFile.<span class="hljs-built_in">is_open</span>()){
   returnCodes[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;
   <span class="hljs-keyword">return</span> returnCodes;
 }
 <span class="hljs-keyword">while</span> (<span class="hljs-built_in">getline</span>(iFile, rowstring)) {
    <span class="hljs-keyword">if</span> (rowstring==<span class="hljs-string">""</span>) <span class="hljs-keyword">continue</span>; <span class="hljs-comment">// empty line</span>
    rowcount ++; <span class="hljs-comment">//let's start with 1</span>
    <span class="hljs-keyword">if</span>(delimiter == decseparator){
      returnCodes[<span class="hljs-number">0</span>] = <span class="hljs-number">2</span>;
      <span class="hljs-keyword">return</span> returnCodes;
    }
    <span class="hljs-keyword">if</span>(decseparator != <span class="hljs-string">"."</span>){
     <span class="hljs-comment">// remove dots (used as thousand separators)</span>
     string::iterator end_pos = <span class="hljs-built_in">remove</span>(rowstring.<span class="hljs-built_in">begin</span>(), rowstring.<span class="hljs-built_in">end</span>(), <span class="hljs-string">'.'</span>);
     rowstring.<span class="hljs-built_in">erase</span>(end_pos, rowstring.<span class="hljs-built_in">end</span>());
     <span class="hljs-comment">// replace decimal separator with dots.</span>
     <span class="hljs-built_in">replace</span>(rowstring.<span class="hljs-built_in">begin</span>(), rowstring.<span class="hljs-built_in">end</span>(),decseparator.<span class="hljs-built_in">c_str</span>()[<span class="hljs-number">0</span>], <span class="hljs-string">'.'</span>); 
    } <span class="hljs-keyword">else</span> {
     <span class="hljs-comment">// remove commas (used as thousand separators)</span>
     string::iterator end_pos = <span class="hljs-built_in">remove</span>(rowstring.<span class="hljs-built_in">begin</span>(), rowstring.<span class="hljs-built_in">end</span>(), <span class="hljs-string">','</span>);
     rowstring.<span class="hljs-built_in">erase</span>(end_pos, rowstring.<span class="hljs-built_in">end</span>());
    }
    <span class="hljs-comment">// tokenize..</span>
    vector&lt;<span class="hljs-type">double</span>&gt; tokens;
    <span class="hljs-comment">// Skip delimiters at beginning.</span>
    string::size_type lastPos = rowstring.<span class="hljs-built_in">find_first_not_of</span>(delimiter, <span class="hljs-number">0</span>);
    <span class="hljs-comment">// Find first "non-delimiter".</span>
    string::size_type pos     = rowstring.<span class="hljs-built_in">find_first_of</span>(delimiter, lastPos);
    <span class="hljs-keyword">while</span> (string::npos != pos || string::npos != lastPos){
        <span class="hljs-comment">// Found a token, convert it to double add it to the vector.</span>
        stringtoken = rowstring.<span class="hljs-built_in">substr</span>(lastPos, pos - lastPos);
        <span class="hljs-keyword">if</span> (stringtoken == <span class="hljs-string">""</span>) {
      tokens.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">0.0</span>);
    } <span class="hljs-keyword">else</span> {
          istringstream <span class="hljs-built_in">totalSString</span>(stringtoken);
      totalSString &gt;&gt; doubletoken;
      tokens.<span class="hljs-built_in">push_back</span>(doubletoken);
    }     
        <span class="hljs-comment">// Skip delimiters.  Note the "not_of"</span>
        lastPos = rowstring.<span class="hljs-built_in">find_first_not_of</span>(delimiter, pos);
        <span class="hljs-comment">// Find next "non-delimiter"</span>
        pos = rowstring.<span class="hljs-built_in">find_first_of</span>(delimiter, lastPos);
    }
    <span class="hljs-keyword">if</span>(rowcount == <span class="hljs-number">1</span>){
      fieldcount = tokens.<span class="hljs-built_in">size</span>();
      returnCodes[<span class="hljs-number">2</span>] = tokens.<span class="hljs-built_in">size</span>();
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-keyword">if</span> ( tokens.<span class="hljs-built_in">size</span>() != fieldcount){
    returnCodes[<span class="hljs-number">2</span>] = <span class="hljs-number">-1</span>;
      }
    }
    data.<span class="hljs-built_in">push_back</span>(tokens);
 }
 iFile.<span class="hljs-built_in">close</span>();
 returnCodes[<span class="hljs-number">1</span>] = rowcount;
 <span class="hljs-keyword">return</span> returnCodes;
}
</code></pre>
    </div></div></div></div></div></div><div class="widget"><a href="/questions/deserialize-json-into-c-dynamic-object-1657388568720">Deserialize JSON into C# dynamic object?</a><a href="/questions/is-there-a-javascript-jquery-dom-change-listener-1657387961200">Is there a JavaScript / jQuery DOM change listener?</a><a href="/questions/why-are-floating-point-numbers-inaccurate-1657387346111">Why are floating point numbers inaccurate?</a><a href="/questions/what-is-the-difference-between-single-quoted-and-double-quoted-strings-in-php-1657384624345">What is the difference between single-quoted and double-quoted strings in PHP?</a><a href="/questions/why-aren&#x27;t-variable-length-arrays-part-of-the-c++-standard-1657384712975">Why aren&#x27;t variable-length arrays part of the C++ standard?</a><a href="/questions/php-parsesyntax-errors-and-how-to-solve-them-1657384264713">PHP parse/syntax errors; and how to solve them</a><a href="/questions/passing-data-between-view-controllers-1657384540021">Passing data between view controllers</a><a href="/questions/maintain-the-aspect-ratio-of-a-div-with-css-1657387513615">Maintain the aspect ratio of a div with CSS</a><a href="/questions/what-is-a-stackoverflowerror-1657388319634">What is a StackOverflowError?</a><a href="/questions/how-do-i-execute-a-program-or-call-a-system-command-1657385465629">How do I execute a program or call a system command?</a><a href="/questions/how-to-access-the-correct-this-inside-a-callback-1657384283261">How to access the correct `this` inside a callback</a><a href="/questions/undefined-behavior-and-sequence-points-1657384639493">Undefined behavior and sequence points</a><a href="/questions/web-scraping-javascript-page-with-python-1657388240875">Web-scraping JavaScript page with Python</a><a href="/questions/how-do-i-give-text-or-an-image-a-transparent-background-using-css-1657388188508">How do I give text or an image a transparent background using CSS?</a><a href="/questions/how-to-use-java.util.scanner-to-correctly-read-user-input-from-system.in-and-act-on-it-1657388546306">How to use java.util.Scanner to correctly read user input from System.in and act on it?</a><a href="/questions/what-are-copy-elision-and-return-value-optimization-1657385455976">What are copy elision and return value optimization?</a><a href="/questions/how-to-determine-equality-for-two-javascript-objects-1657387638650">How to determine equality for two JavaScript objects?</a><a href="/questions/what-is-the-%22n+1-selects-problem%22-in-orm-(object-relational-mapping)-1657388055597">What is the &quot;N+1 selects problem&quot; in ORM (Object-Relational Mapping)?</a><a href="/questions/parsing-a-string-to-a-date-in-javascript-1657387782497">Parsing a string to a date in JavaScript</a><a href="/questions/why-use-integer-instead-of-long-1657388012352">Why Use Integer Instead of Long?</a></div></div><span class="cursor-pointer text-lg p-2" style="position:fixed;bottom:20px;left:20px;background:#000;z-index:2000;color:white">Go go top</span></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"data":{"answer":["\n\u0026lt;p\u0026gt;If you don\u0026apos;t care about escaping comma and newline,\u0026lt;br\u0026gt;\nAND you can\u0026apos;t embed comma and newline in quotes (If you can\u0026apos;t escape then...)\u0026lt;br\u0026gt;\nthen its only about three lines of code (OK 14 -\u0026amp;gt;But its only 15 to read the whole file).\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;std::vector\u0026amp;lt;std::string\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;getNextLineAndSplitIntoTokens\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(std::istream\u0026amp;amp; str)\u0026lt;/span\u0026gt;\n\u0026lt;/span\u0026gt;{\n    std::vector\u0026amp;lt;std::string\u0026amp;gt;   result;\n    std::string                line;\n    std::\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;getline\u0026lt;/span\u0026gt;(str,line);\n\n    \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;std::stringstream          \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;lineStream\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(line)\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;;\n    std::string                cell;\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;while\u0026lt;/span\u0026gt;(std::\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;getline\u0026lt;/span\u0026gt;(lineStream,cell, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;,\u0026apos;\u0026lt;/span\u0026gt;))\n    {\n        result.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;push_back\u0026lt;/span\u0026gt;(cell);\n    }\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// This checks for a trailing comma with no data after it.\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (!lineStream \u0026amp;amp;\u0026amp;amp; cell.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;empty\u0026lt;/span\u0026gt;())\n    {\n        \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// If there was a trailing comma then add an empty element.\u0026lt;/span\u0026gt;\n        result.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;push_back\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;\u0026quot;\u0026lt;/span\u0026gt;);\n    }\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; result;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;I would just create a class representing a row.\u0026lt;br\u0026gt;\nThen stream into that object:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;iterator\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;iostream\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;fstream\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;sstream\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;vector\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;string\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;CSVRow\u0026lt;/span\u0026gt;\n{\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt;:\n        std::string_view \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;operator\u0026lt;/span\u0026gt;[](std::\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;size_t\u0026lt;/span\u0026gt; index) \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt;\n        {\n            \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; std::\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;string_view\u0026lt;/span\u0026gt;(\u0026amp;amp;m_line[m_data[index] + \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;], m_data[index + \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;] -  (m_data[index] + \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;));\n        }\n        \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;std::\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;size_t\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;size\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt;\n        \u0026lt;/span\u0026gt;{\n            \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; m_data.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;size\u0026lt;/span\u0026gt;() - \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;;\n        }\n        \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;readNextRow\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(std::istream\u0026amp;amp; str)\u0026lt;/span\u0026gt;\n        \u0026lt;/span\u0026gt;{\n            std::\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;getline\u0026lt;/span\u0026gt;(str, m_line);\n\n            m_data.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;clear\u0026lt;/span\u0026gt;();\n            m_data.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;emplace_back\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;-1\u0026lt;/span\u0026gt;);\n            std::string::size_type pos = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;;\n            \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;while\u0026lt;/span\u0026gt;((pos = m_line.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;find\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;,\u0026apos;\u0026lt;/span\u0026gt;, pos)) != std::string::npos)\n            {\n                m_data.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;emplace_back\u0026lt;/span\u0026gt;(pos);\n                ++pos;\n            }\n            \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// This checks for a trailing comma with no data after it.\u0026lt;/span\u0026gt;\n            pos   = m_line.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;size\u0026lt;/span\u0026gt;();\n            m_data.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;emplace_back\u0026lt;/span\u0026gt;(pos);\n        }\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;private\u0026lt;/span\u0026gt;:\n        std::string         m_line;\n        std::vector\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;\u0026amp;gt;    m_data;\n};\n\nstd::istream\u0026amp;amp; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;operator\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026amp;gt;(std::istream\u0026amp;amp; str, CSVRow\u0026amp;amp; data)\n{\n    data.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;readNextRow\u0026lt;/span\u0026gt;(str);\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; str;\n}   \n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;main\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt;\n\u0026lt;/span\u0026gt;{\n    \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;std::ifstream       \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;file\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;plop.csv\u0026quot;\u0026lt;/span\u0026gt;)\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;;\n\n    CSVRow              row;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;while\u0026lt;/span\u0026gt;(file \u0026amp;gt;\u0026amp;gt; row)\n    {\n        std::cout \u0026amp;lt;\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;4th Element(\u0026quot;\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026amp;lt; row[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3\u0026lt;/span\u0026gt;] \u0026amp;lt;\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;)\\n\u0026quot;\u0026lt;/span\u0026gt;;\n    }\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;But with a little work we could technically create an iterator:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;CSVIterator\u0026lt;/span\u0026gt;\n{   \n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt;:\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typedef\u0026lt;/span\u0026gt; std::input_iterator_tag     iterator_category;\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typedef\u0026lt;/span\u0026gt; CSVRow                      value_type;\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typedef\u0026lt;/span\u0026gt; std::\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;size_t\u0026lt;/span\u0026gt;                 difference_type;\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typedef\u0026lt;/span\u0026gt; CSVRow*                     pointer;\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typedef\u0026lt;/span\u0026gt; CSVRow\u0026amp;amp;                     reference;\n\n        \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;CSVIterator\u0026lt;/span\u0026gt;(std::istream\u0026amp;amp; str)  :\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;m_str\u0026lt;/span\u0026gt;(str.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;good\u0026lt;/span\u0026gt;()?\u0026amp;amp;str:\u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;nullptr\u0026lt;/span\u0026gt;) { ++(*\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;this\u0026lt;/span\u0026gt;); }\n        \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;CSVIterator\u0026lt;/span\u0026gt;()                   :\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;m_str\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;nullptr\u0026lt;/span\u0026gt;) {}\n\n        \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Pre Increment\u0026lt;/span\u0026gt;\n        CSVIterator\u0026amp;amp; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;operator\u0026lt;/span\u0026gt;++()               {\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (m_str) { \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (!((*m_str) \u0026amp;gt;\u0026amp;gt; m_row)){m_str = \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;nullptr\u0026lt;/span\u0026gt;;}}\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; *\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;this\u0026lt;/span\u0026gt;;}\n        \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Post increment\u0026lt;/span\u0026gt;\n        CSVIterator \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;operator\u0026lt;/span\u0026gt;++(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;)             {\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;CSVIterator    \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;tmp\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(*\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;this\u0026lt;/span\u0026gt;)\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;;++(*\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;this\u0026lt;/span\u0026gt;);\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; tmp;}\n        CSVRow \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt;\u0026amp;amp; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;operator\u0026lt;/span\u0026gt;*()   \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt;       {\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; m_row;}\n        CSVRow \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt;* \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;operator\u0026lt;/span\u0026gt;-\u0026amp;gt;()  \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt;       {\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026amp;amp;m_row;}\n\n        \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;bool\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;operator\u0026lt;/span\u0026gt;==(CSVIterator \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt;\u0026amp;amp; rhs) {\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; ((\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;this\u0026lt;/span\u0026gt; == \u0026amp;amp;rhs) || ((\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;this\u0026lt;/span\u0026gt;-\u0026amp;gt;m_str == \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;nullptr\u0026lt;/span\u0026gt;) \u0026amp;amp;\u0026amp;amp; (rhs.m_str == \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;nullptr\u0026lt;/span\u0026gt;)));}\n        \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;bool\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;operator\u0026lt;/span\u0026gt;!=(CSVIterator \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt;\u0026amp;amp; rhs) {\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; !((*\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;this\u0026lt;/span\u0026gt;) == rhs);}\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;private\u0026lt;/span\u0026gt;:\n        std::istream*       m_str;\n        CSVRow              m_row;\n};\n\n\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;main\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt;\n\u0026lt;/span\u0026gt;{\n    \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;std::ifstream       \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;file\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;plop.csv\u0026quot;\u0026lt;/span\u0026gt;)\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;;\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt;(CSVIterator \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;loop\u0026lt;/span\u0026gt;(file); loop != \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;CSVIterator\u0026lt;/span\u0026gt;(); ++loop)\n    {\n        std::cout \u0026amp;lt;\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;4th Element(\u0026quot;\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026amp;lt; (*loop)[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3\u0026lt;/span\u0026gt;] \u0026amp;lt;\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;)\\n\u0026quot;\u0026lt;/span\u0026gt;;\n    }\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;Now that we are in 2020 lets add a CSVRange object:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;CSVRange\u0026lt;/span\u0026gt;\n{\n    std::istream\u0026amp;amp;   stream;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt;:\n        \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;CSVRange\u0026lt;/span\u0026gt;(std::istream\u0026amp;amp; str)\n            : \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;stream\u0026lt;/span\u0026gt;(str)\n        {}\n        \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;CSVIterator \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;begin\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; \u0026lt;/span\u0026gt;{\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; CSVIterator{stream};}\n        \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;CSVIterator \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;end\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt;   \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; \u0026lt;/span\u0026gt;{\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; CSVIterator{};}\n};\n\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;main\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt;\n\u0026lt;/span\u0026gt;{\n    \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;std::ifstream       \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;file\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;plop.csv\u0026quot;\u0026lt;/span\u0026gt;)\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;;\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;auto\u0026lt;/span\u0026gt;\u0026amp;amp; row: \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;CSVRange\u0026lt;/span\u0026gt;(file))\n    {\n        std::cout \u0026amp;lt;\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;4th Element(\u0026quot;\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026amp;lt; row[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3\u0026lt;/span\u0026gt;] \u0026amp;lt;\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;)\\n\u0026quot;\u0026lt;/span\u0026gt;;\n    }\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;My version is not using anything but the standard C++11 library. It copes well with Excel CSV quotation:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;spam eggs,\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;foo,bar\u0026quot;\u0026lt;/span\u0026gt;,\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;\u0026quot;\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;fizz buzz\u0026quot;\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;\u0026quot;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1.23\u0026lt;/span\u0026gt;,\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;4.567\u0026lt;/span\u0026gt;,\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;-8.00E+09\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;The code is written as a finite-state machine and is consuming one character at a time. I think it\u0026apos;s easier to reason about.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;istream\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;string\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;vector\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;enum class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;CSVState\u0026lt;/span\u0026gt; {\n    UnquotedField,\n    QuotedField,\n    QuotedQuote\n};\n\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;std::vector\u0026amp;lt;std::string\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;readCSVRow\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; std::string \u0026amp;amp;row)\u0026lt;/span\u0026gt; \u0026lt;/span\u0026gt;{\n    CSVState state = CSVState::UnquotedField;\n    std::vector\u0026amp;lt;std::string\u0026amp;gt; fields {\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;\u0026quot;\u0026lt;/span\u0026gt;};\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;size_t\u0026lt;/span\u0026gt; i = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// index of the current field\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt; (\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; c : row) {\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;switch\u0026lt;/span\u0026gt; (state) {\n            \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;case\u0026lt;/span\u0026gt; CSVState::UnquotedField:\n                \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;switch\u0026lt;/span\u0026gt; (c) {\n                    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;case\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;,\u0026apos;\u0026lt;/span\u0026gt;: \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// end of field\u0026lt;/span\u0026gt;\n                              fields.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;push_back\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;\u0026quot;\u0026lt;/span\u0026gt;); i++;\n                              \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;break\u0026lt;/span\u0026gt;;\n                    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;case\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;\u0026quot;\u0026apos;\u0026lt;/span\u0026gt;: state = CSVState::QuotedField;\n                              \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;break\u0026lt;/span\u0026gt;;\n                    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;default\u0026lt;/span\u0026gt;:  fields[i].\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;push_back\u0026lt;/span\u0026gt;(c);\n                              \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;break\u0026lt;/span\u0026gt;; }\n                \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;break\u0026lt;/span\u0026gt;;\n            \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;case\u0026lt;/span\u0026gt; CSVState::QuotedField:\n                \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;switch\u0026lt;/span\u0026gt; (c) {\n                    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;case\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;\u0026quot;\u0026apos;\u0026lt;/span\u0026gt;: state = CSVState::QuotedQuote;\n                              \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;break\u0026lt;/span\u0026gt;;\n                    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;default\u0026lt;/span\u0026gt;:  fields[i].\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;push_back\u0026lt;/span\u0026gt;(c);\n                              \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;break\u0026lt;/span\u0026gt;; }\n                \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;break\u0026lt;/span\u0026gt;;\n            \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;case\u0026lt;/span\u0026gt; CSVState::QuotedQuote:\n                \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;switch\u0026lt;/span\u0026gt; (c) {\n                    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;case\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;,\u0026apos;\u0026lt;/span\u0026gt;: \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// , after closing quote\u0026lt;/span\u0026gt;\n                              fields.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;push_back\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;\u0026quot;\u0026lt;/span\u0026gt;); i++;\n                              state = CSVState::UnquotedField;\n                              \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;break\u0026lt;/span\u0026gt;;\n                    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;case\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;\u0026quot;\u0026apos;\u0026lt;/span\u0026gt;: \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// \u0026quot;\u0026quot; -\u0026amp;gt; \u0026quot;\u0026lt;/span\u0026gt;\n                              fields[i].\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;push_back\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;\u0026quot;\u0026apos;\u0026lt;/span\u0026gt;);\n                              state = CSVState::QuotedField;\n                              \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;break\u0026lt;/span\u0026gt;;\n                    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;default\u0026lt;/span\u0026gt;:  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// end of quote\u0026lt;/span\u0026gt;\n                              state = CSVState::UnquotedField;\n                              \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;break\u0026lt;/span\u0026gt;; }\n                \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;break\u0026lt;/span\u0026gt;;\n        }\n    }\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; fields;\n}\n\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;/// Read CSV file, Excel dialect. Accept \u0026quot;quoted fields \u0026quot;\u0026quot;with quotes\u0026quot;\u0026quot;\u0026quot;\u0026lt;/span\u0026gt;\nstd::vector\u0026amp;lt;std::vector\u0026amp;lt;std::string\u0026amp;gt;\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;readCSV\u0026lt;/span\u0026gt;(std::istream \u0026amp;amp;in) {\n    std::vector\u0026amp;lt;std::vector\u0026amp;lt;std::string\u0026amp;gt;\u0026amp;gt; table;\n    std::string row;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;while\u0026lt;/span\u0026gt; (!in.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;eof\u0026lt;/span\u0026gt;()) {\n        std::\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;getline\u0026lt;/span\u0026gt;(in, row);\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (in.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;bad\u0026lt;/span\u0026gt;() || in.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;fail\u0026lt;/span\u0026gt;()) {\n            \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;break\u0026lt;/span\u0026gt;;\n        }\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;auto\u0026lt;/span\u0026gt; fields = \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;readCSVRow\u0026lt;/span\u0026gt;(row);\n        table.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;push_back\u0026lt;/span\u0026gt;(fields);\n    }\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; table;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Solution using Boost Tokenizer:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;std::vector\u0026amp;lt;std::string\u0026amp;gt; vec;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;using\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;namespace\u0026lt;/span\u0026gt; boost;\ntokenizer\u0026amp;lt;escaped_list_separator\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt;\u0026amp;gt; \u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;tk\u0026lt;/span\u0026gt;(\n   line, \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;escaped_list_separator\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt;\u0026amp;gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;\\\\\u0026apos;\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;,\u0026apos;\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;\\\u0026quot;\u0026apos;\u0026lt;/span\u0026gt;));\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt; (tokenizer\u0026amp;lt;escaped_list_separator\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt;\u0026amp;gt; \u0026amp;gt;::iterator \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;i\u0026lt;/span\u0026gt;(tk.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;begin\u0026lt;/span\u0026gt;());\n   i!=tk.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;end\u0026lt;/span\u0026gt;();++i) \n{\n   vec.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;push_back\u0026lt;/span\u0026gt;(*i);\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;The \u0026lt;a href=\u0026quot;http://www.partow.net/programming/strtk/index.html\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;C++ String Toolkit Library (StrTk)\u0026lt;/a\u0026gt; has a token grid class that allows you to load data either from \u0026lt;b\u0026gt;text files, strings or char buffers\u0026lt;/b\u0026gt;, and to parse/process them in a row-column fashion.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;You can specify the row delimiters and column delimiters or just use the defaults.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;foo\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt;\n\u0026lt;/span\u0026gt;{\n   std::string data = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;1,2,3,4,5\\n\u0026quot;\u0026lt;/span\u0026gt;\n                      \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;0,2,4,6,8\\n\u0026quot;\u0026lt;/span\u0026gt;\n                      \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;1,3,5,7,9\\n\u0026quot;\u0026lt;/span\u0026gt;;\n\n   \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;strtk::token_grid \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;grid\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(data,data.size(),\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;,\u0026quot;\u0026lt;/span\u0026gt;)\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;;\n\n   \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt;(std::\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;size_t\u0026lt;/span\u0026gt; i = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;; i \u0026amp;lt; grid.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;row_count\u0026lt;/span\u0026gt;(); ++i)\n   {\n      strtk::token_grid::row_type r = grid.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;row\u0026lt;/span\u0026gt;(i);\n      \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt;(std::\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;size_t\u0026lt;/span\u0026gt; j = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;; j \u0026amp;lt; r.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;size\u0026lt;/span\u0026gt;(); ++j)\n      {\n         std::cout \u0026amp;lt;\u0026amp;lt; r.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;get\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;\u0026amp;gt;(j) \u0026amp;lt;\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;\\t\u0026quot;\u0026lt;/span\u0026gt;;\n      }\n      std::cout \u0026amp;lt;\u0026amp;lt; std::endl;\n   }\n   std::cout \u0026amp;lt;\u0026amp;lt; std::endl;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;More examples can be found \u0026lt;a href=\u0026quot;http://www.partow.net/programming/strtk/index.html#tutorial\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;Here\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;You can use Boost Tokenizer with escaped_list_separator.\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;blockquote\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;escaped_list_separator\u0026lt;/strong\u0026gt; parses a superset of the csv. \u0026lt;a href=\u0026quot;https://www.boost.org/doc/libs/release/libs/tokenizer/doc/escaped_list_separator.htm\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;Boost::tokenizer\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\u0026lt;p\u0026gt;This only uses Boost tokenizer header files, no linking to boost libraries required.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Here is an example, (see \u0026lt;a href=\u0026quot;http://mybyteofcode.blogspot.com/2010/02/parse-csv-file-with-boost-tokenizer-in.html\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;Parse CSV File With Boost Tokenizer In C++\u0026lt;/a\u0026gt; for details or \u0026lt;code\u0026gt;Boost::tokenizer\u0026lt;/code\u0026gt; ):\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;iostream\u0026amp;gt;\u0026lt;/span\u0026gt;     \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// cout, endl\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;fstream\u0026amp;gt;\u0026lt;/span\u0026gt;      \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// fstream\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;vector\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;string\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;algorithm\u0026amp;gt;\u0026lt;/span\u0026gt;    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// copy\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;iterator\u0026amp;gt;\u0026lt;/span\u0026gt;     \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// ostream_operator\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;boost/tokenizer.hpp\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;main\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt;\n\u0026lt;/span\u0026gt;{\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;using\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;namespace\u0026lt;/span\u0026gt; std;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;using\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;namespace\u0026lt;/span\u0026gt; boost;\n    \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;string \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;data\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;data.csv\u0026quot;\u0026lt;/span\u0026gt;)\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;;\n\n    \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;ifstream \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;in\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(data.c_str())\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (!in.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;is_open\u0026lt;/span\u0026gt;()) \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;;\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typedef\u0026lt;/span\u0026gt; tokenizer\u0026amp;lt; escaped_list_separator\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt;\u0026amp;gt; \u0026amp;gt; Tokenizer;\n    vector\u0026amp;lt; string \u0026amp;gt; vec;\n    string line;\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;while\u0026lt;/span\u0026gt; (\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;getline\u0026lt;/span\u0026gt;(in,line))\n    {\n        \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;Tokenizer \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;tok\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(line)\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;;\n        vec.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;assign\u0026lt;/span\u0026gt;(tok.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;begin\u0026lt;/span\u0026gt;(),tok.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;end\u0026lt;/span\u0026gt;());\n\n        \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// vector now contains strings from one row, output to cout here\u0026lt;/span\u0026gt;\n        \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;copy\u0026lt;/span\u0026gt;(vec.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;begin\u0026lt;/span\u0026gt;(), vec.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;end\u0026lt;/span\u0026gt;(), \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;ostream_iterator\u0026lt;/span\u0026gt;\u0026amp;lt;string\u0026amp;gt;(cout, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;|\u0026quot;\u0026lt;/span\u0026gt;));\n\n        cout \u0026amp;lt;\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;\\n----------------------\u0026quot;\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026amp;lt; endl;\n    }\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;It is not overkill to use Spirit for parsing CSVs. Spirit is well suited for micro-parsing tasks. For instance, with Spirit 2.1, it is as easy as:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;bool\u0026lt;/span\u0026gt; r = \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;phrase_parse\u0026lt;/span\u0026gt;(first, last,\n\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//  Begin grammar\u0026lt;/span\u0026gt;\n    (\n        double_ % \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;,\u0026apos;\u0026lt;/span\u0026gt;\n    )\n    ,\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//  End grammar\u0026lt;/span\u0026gt;\n\n    space, v);\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;The vector, v, gets stuffed with the values. \u0026lt;a href=\u0026quot;http://www.boost.org/doc/libs/1_41_0/libs/spirit/doc/html/spirit/qi/tutorials.html\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;There is a series of tutorials\u0026lt;/a\u0026gt; touching on this in the new Spirit 2.1 docs that\u0026apos;s just been released with Boost 1.41.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;The tutorial progresses from simple to complex. The CSV parsers are presented somewhere in the middle and touches on various techniques in using Spirit. The generated code is as tight as hand written code. Check out the assembler generated!\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;If you \u0026lt;strong\u0026gt;DO\u0026lt;/strong\u0026gt; care about parsing CSV correctly, this will do it...relatively slowly as it works one char at a time.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt; \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;ParseCSV\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; string\u0026amp;amp; csvSource, vector\u0026amp;lt;vector\u0026amp;lt;string\u0026amp;gt; \u0026amp;gt;\u0026amp;amp; lines)\u0026lt;/span\u0026gt;\n    \u0026lt;/span\u0026gt;{\n       \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;bool\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;inQuote\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;false\u0026lt;/span\u0026gt;)\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;;\n       \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;bool\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;newLine\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;false\u0026lt;/span\u0026gt;)\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;;\n       string field;\n       lines.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;clear\u0026lt;/span\u0026gt;();\n       vector\u0026amp;lt;string\u0026amp;gt; line;\n\n       string::const_iterator aChar = csvSource.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;begin\u0026lt;/span\u0026gt;();\n       \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;while\u0026lt;/span\u0026gt; (aChar != csvSource.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;end\u0026lt;/span\u0026gt;())\n       {\n          \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;switch\u0026lt;/span\u0026gt; (*aChar)\n          {\n          \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;case\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;\u0026quot;\u0026apos;\u0026lt;/span\u0026gt;:\n             newLine = \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;false\u0026lt;/span\u0026gt;;\n             inQuote = !inQuote;\n             \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;break\u0026lt;/span\u0026gt;;\n\n          \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;case\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;,\u0026apos;\u0026lt;/span\u0026gt;:\n             newLine = \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;false\u0026lt;/span\u0026gt;;\n             \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (inQuote == \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;true\u0026lt;/span\u0026gt;)\n             {\n                field += *aChar;\n             }\n             \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;else\u0026lt;/span\u0026gt;\n             {\n                line.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;push_back\u0026lt;/span\u0026gt;(field);\n                field.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;clear\u0026lt;/span\u0026gt;();\n             }\n             \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;break\u0026lt;/span\u0026gt;;\n\n          \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;case\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;\\n\u0026apos;\u0026lt;/span\u0026gt;:\n          \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;case\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;\\r\u0026apos;\u0026lt;/span\u0026gt;:\n             \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (inQuote == \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;true\u0026lt;/span\u0026gt;)\n             {\n                field += *aChar;\n             }\n             \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;else\u0026lt;/span\u0026gt;\n             {\n                \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (newLine == \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;false\u0026lt;/span\u0026gt;)\n                {\n                   line.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;push_back\u0026lt;/span\u0026gt;(field);\n                   lines.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;push_back\u0026lt;/span\u0026gt;(line);\n                   field.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;clear\u0026lt;/span\u0026gt;();\n                   line.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;clear\u0026lt;/span\u0026gt;();\n                   newLine = \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;true\u0026lt;/span\u0026gt;;\n                }\n             }\n             \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;break\u0026lt;/span\u0026gt;;\n\n          \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;default\u0026lt;/span\u0026gt;:\n             newLine = \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;false\u0026lt;/span\u0026gt;;\n             field.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;push_back\u0026lt;/span\u0026gt;(*aChar);\n             \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;break\u0026lt;/span\u0026gt;;\n          }\n\n          aChar++;\n       }\n\n       \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (field.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;size\u0026lt;/span\u0026gt;())\n          line.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;push_back\u0026lt;/span\u0026gt;(field);\n\n       \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (line.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;size\u0026lt;/span\u0026gt;())\n          lines.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;push_back\u0026lt;/span\u0026gt;(line);\n    }\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;When using the Boost Tokenizer escaped_list_separator for CSV files, then one should be aware of the following:\u0026lt;/p\u0026gt;\n\n\u0026lt;ol\u0026gt;\n\u0026lt;li\u0026gt;It requires an escape-character (default back-slash - \\)\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;It requires a splitter/seperator-character (default comma - ,)\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;It requires an quote-character (default quote - \u0026quot;)\u0026lt;/li\u0026gt;\n\u0026lt;/ol\u0026gt;\n\n\u0026lt;p\u0026gt;The CSV format specified by wiki states that data fields can contain separators in quotes (supported):\u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;1997,Ford,E350,\u0026quot;Super, luxurious truck\u0026quot;\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;p\u0026gt;The CSV format specified by wiki states that single quotes should be handled with double-quotes (escaped_list_separator will strip away all quote characters):\u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;1997,Ford,E350,\u0026quot;Super \u0026quot;\u0026quot;luxurious\u0026quot;\u0026quot; truck\u0026quot;\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;p\u0026gt;The CSV format doesn\u0026apos;t specify that any back-slash characters should be stripped away (escaped_list_separator will strip away all escape characters).\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;A possible work-around to fix the default behavior of the boost escaped_list_separator:\u0026lt;/p\u0026gt;\n\n\u0026lt;ol\u0026gt;\n\u0026lt;li\u0026gt;First replace all back-slash characters (\\) with two back-slash characters (\\\\) so they are not stripped away.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Secondly replace all double-quotes (\u0026quot;\u0026quot;) with a single back-slash character and a quote (\\\u0026quot;)\u0026lt;/li\u0026gt;\n\u0026lt;/ol\u0026gt;\n\n\u0026lt;p\u0026gt;This work-around has the side-effect that empty data-fields that are represented by a double-quote, will be transformed into a single-quote-token. When iterating through the tokens, then one must check if the token is a single-quote, and treat it like an empty string.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Not pretty but it works, as long there are not newlines within the quotes.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;\u0026lt;a href=\u0026quot;https://github.com/AriaFallah/csv-parser\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;I wrote a header-only, C++11 CSV parser\u0026lt;/a\u0026gt;. It\u0026apos;s well tested, fast, supports the entire CSV spec (quoted fields, delimiter/terminator in quotes, quote escaping, etc.), and is configurable to account for the CSVs that don\u0026apos;t adhere to the specification.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Configuration is done through a fluent interface:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// constructor accepts any input stream\u0026lt;/span\u0026gt;\nCsvParser parser = \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;CsvParser\u0026lt;/span\u0026gt;(std::cin)\n  .\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;delimiter\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;;\u0026apos;\u0026lt;/span\u0026gt;)    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// delimited by ; instead of ,\u0026lt;/span\u0026gt;\n  .\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;quote\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;\\\u0026apos;\u0026apos;\u0026lt;/span\u0026gt;)       \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// quoted fields use \u0026apos; instead of \u0026quot;\u0026lt;/span\u0026gt;\n  .\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;terminator\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;\\0\u0026apos;\u0026lt;/span\u0026gt;); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// terminated by \\0 instead of by \\r\\n, \\n, or \\r\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Parsing is just a range based for loop:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;iostream\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;../parser.hpp\u0026quot;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;using\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;namespace\u0026lt;/span\u0026gt; aria::csv;\n\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;main\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt; \u0026lt;/span\u0026gt;{\n  \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;std::ifstream \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;f\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;some_file.csv\u0026quot;\u0026lt;/span\u0026gt;)\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;;\n  \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;CsvParser \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;parser\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(f)\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;;\n\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt; (\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;auto\u0026lt;/span\u0026gt;\u0026amp;amp; row : parser) {\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt; (\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;auto\u0026lt;/span\u0026gt;\u0026amp;amp; field : row) {\n      std::cout \u0026amp;lt;\u0026amp;lt; field \u0026amp;lt;\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot; | \u0026quot;\u0026lt;/span\u0026gt;;\n    }\n    std::cout \u0026amp;lt;\u0026amp;lt; std::endl;\n  }\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;As all the CSV questions seem to get redirected here, I thought I\u0026apos;d post my answer here.  This answer does not directly address the asker\u0026apos;s question. I wanted to be able to read in a stream that is known to be in CSV format, and also the types of each field was already known. Of course, the method below could be used to treat every field to be a string type.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;As an example of how I wanted to be able to use a CSV input stream, consider the following input (taken from \u0026lt;a href=\u0026quot;http://en.wikipedia.org/wiki/Comma-separated_values\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;wikipedia\u0026apos;s page on CSV\u0026lt;/a\u0026gt;):\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; input[] =\n\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Year,Make,Model,Description,Price\\n\u0026quot;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;1997,Ford,E350,\\\u0026quot;ac, abs, moon\\\u0026quot;,3000.00\\n\u0026quot;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;1999,Chevy,\\\u0026quot;Venture \\\u0026quot;\\\u0026quot;Extended Edition\\\u0026quot;\\\u0026quot;\\\u0026quot;,\\\u0026quot;\\\u0026quot;,4900.00\\n\u0026quot;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;1999,Chevy,\\\u0026quot;Venture \\\u0026quot;\\\u0026quot;Extended Edition, Very Large\\\u0026quot;\\\u0026quot;\\\u0026quot;,\\\u0026quot;\\\u0026quot;,5000.00\\n\u0026quot;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;1996,Jeep,Grand Cherokee,\\\u0026quot;MUST SELL!\\n\\\nair, moon roof, loaded\\\u0026quot;,4799.00\\n\u0026quot;\u0026lt;/span\u0026gt;\n;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Then, I wanted to be able to read in the data like this:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;std::istringstream \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;ss\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(input)\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;;\nstd::string title[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;5\u0026lt;/span\u0026gt;];\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; year;\nstd::string make, model, desc;\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;float\u0026lt;/span\u0026gt; price;\n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;csv_istream\u0026lt;/span\u0026gt;(ss)\n    \u0026amp;gt;\u0026amp;gt; title[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;] \u0026amp;gt;\u0026amp;gt; title[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;] \u0026amp;gt;\u0026amp;gt; title[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;] \u0026amp;gt;\u0026amp;gt; title[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3\u0026lt;/span\u0026gt;] \u0026amp;gt;\u0026amp;gt; title[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;4\u0026lt;/span\u0026gt;];\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;while\u0026lt;/span\u0026gt; (\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;csv_istream\u0026lt;/span\u0026gt;(ss)\n       \u0026amp;gt;\u0026amp;gt; year \u0026amp;gt;\u0026amp;gt; make \u0026amp;gt;\u0026amp;gt; model \u0026amp;gt;\u0026amp;gt; desc \u0026amp;gt;\u0026amp;gt; price) {\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//...do something with the record...\u0026lt;/span\u0026gt;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;This was the solution I ended up with.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;csv_istream\u0026lt;/span\u0026gt; {\n    std::istream \u0026amp;amp;is_;\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;csv_istream\u0026lt;/span\u0026gt; (std::istream \u0026amp;amp;is) : \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;is_\u0026lt;/span\u0026gt;(is) {}\n    \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;scan_ws\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; \u0026lt;/span\u0026gt;{\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;while\u0026lt;/span\u0026gt; (is_.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;good\u0026lt;/span\u0026gt;()) {\n            \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; c = is_.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;peek\u0026lt;/span\u0026gt;();\n            \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (c != \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos; \u0026apos;\u0026lt;/span\u0026gt; \u0026amp;amp;\u0026amp;amp; c != \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;\\t\u0026apos;\u0026lt;/span\u0026gt;) \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;break\u0026lt;/span\u0026gt;;\n            is_.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;get\u0026lt;/span\u0026gt;();\n        }\n    }\n    \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;scan\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(std::string *s = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;)\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; \u0026lt;/span\u0026gt;{\n        std::string ws;\n        \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; c = is_.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;get\u0026lt;/span\u0026gt;();\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (is_.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;good\u0026lt;/span\u0026gt;()) {\n            \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;do\u0026lt;/span\u0026gt; {\n                \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (c == \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;,\u0026apos;\u0026lt;/span\u0026gt; || c == \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;\\n\u0026apos;\u0026lt;/span\u0026gt;) \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;break\u0026lt;/span\u0026gt;;\n                \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (s) {\n                    ws += c;\n                    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (c != \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos; \u0026apos;\u0026lt;/span\u0026gt; \u0026amp;amp;\u0026amp;amp; c != \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;\\t\u0026apos;\u0026lt;/span\u0026gt;) {\n                        *s += ws;\n                        ws.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;clear\u0026lt;/span\u0026gt;();\n                    }\n                }\n                c = is_.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;get\u0026lt;/span\u0026gt;();\n            } \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;while\u0026lt;/span\u0026gt; (is_.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;good\u0026lt;/span\u0026gt;());\n            \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (is_.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;eof\u0026lt;/span\u0026gt;()) is_.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;clear\u0026lt;/span\u0026gt;();\n        }\n    }\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; T, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;bool\u0026lt;/span\u0026gt;\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;set_value\u0026lt;/span\u0026gt; {\n        \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;operator\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(std::string in, T \u0026amp;amp;v)\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; \u0026lt;/span\u0026gt;{\n            std::\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;istringstream\u0026lt;/span\u0026gt;(in) \u0026amp;gt;\u0026amp;gt; v;\n        }\n    };\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; T\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;set_value\u0026lt;/span\u0026gt;\u0026amp;lt;T, \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;true\u0026lt;/span\u0026gt;\u0026amp;gt; {\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;bool\u0026lt;/span\u0026gt; SIGNED\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;convert\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(std::string in, T \u0026amp;amp;v)\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; \u0026lt;/span\u0026gt;{\n            \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (SIGNED) v = ::\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;strtoll\u0026lt;/span\u0026gt;(in.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;c_str\u0026lt;/span\u0026gt;(), \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;);\n            \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;else\u0026lt;/span\u0026gt; v = ::\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;strtoull\u0026lt;/span\u0026gt;(in.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;c_str\u0026lt;/span\u0026gt;(), \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;);\n        }\n        \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;operator\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(std::string in, T \u0026amp;amp;v)\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; \u0026lt;/span\u0026gt;{\n            convert\u0026amp;lt;is_signed_int\u0026amp;lt;T\u0026amp;gt;::val\u0026amp;gt;(in, v);\n        }\n    };\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; T\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; csv_istream \u0026amp;amp; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;operator\u0026lt;/span\u0026gt; \u0026amp;gt;\u0026amp;gt; (T \u0026amp;amp;v) \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; {\n        std::string tmp;\n        \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;scan\u0026lt;/span\u0026gt;(\u0026amp;amp;tmp);\n        set_value\u0026amp;lt;T, is_int\u0026amp;lt;T\u0026amp;gt;::val\u0026amp;gt;()(tmp, v);\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; *\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;this\u0026lt;/span\u0026gt;;\n    }\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; csv_istream \u0026amp;amp; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;operator\u0026lt;/span\u0026gt; \u0026amp;gt;\u0026amp;gt; (std::string \u0026amp;amp;v) \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; {\n        v.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;clear\u0026lt;/span\u0026gt;();\n        \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;scan_ws\u0026lt;/span\u0026gt;();\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (is_.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;peek\u0026lt;/span\u0026gt;() != \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;\u0026quot;\u0026apos;\u0026lt;/span\u0026gt;) \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;scan\u0026lt;/span\u0026gt;(\u0026amp;amp;v);\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;else\u0026lt;/span\u0026gt; {\n            std::string tmp;\n            is_.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;get\u0026lt;/span\u0026gt;();\n            std::\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;getline\u0026lt;/span\u0026gt;(is_, tmp, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;\u0026quot;\u0026apos;\u0026lt;/span\u0026gt;);\n            \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;while\u0026lt;/span\u0026gt; (is_.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;peek\u0026lt;/span\u0026gt;() == \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;\u0026quot;\u0026apos;\u0026lt;/span\u0026gt;) {\n                v += tmp;\n                v += is_.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;get\u0026lt;/span\u0026gt;();\n                std::\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;getline\u0026lt;/span\u0026gt;(is_, tmp, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;\u0026quot;\u0026apos;\u0026lt;/span\u0026gt;);\n            }\n            v += tmp;\n            \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;scan\u0026lt;/span\u0026gt;();\n        }\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; *\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;this\u0026lt;/span\u0026gt;;\n    }\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; T\u0026amp;gt;\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; csv_istream \u0026amp;amp; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;operator\u0026lt;/span\u0026gt; \u0026amp;gt;\u0026amp;gt; (T \u0026amp;amp;(*manip)(T \u0026amp;amp;)) \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; {\n        is_ \u0026amp;gt;\u0026amp;gt; manip;\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; *\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;this\u0026lt;/span\u0026gt;;\n    }\n    \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;operator\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;bool\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; \u0026lt;/span\u0026gt;{ \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; !is_.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;fail\u0026lt;/span\u0026gt;(); }\n};\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;With the following helpers that may be simplified by the new integral traits templates in C++11:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; T\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;is_signed_int\u0026lt;/span\u0026gt; { \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;enum\u0026lt;/span\u0026gt; { val = \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;false\u0026lt;/span\u0026gt; }; };\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;is_signed_int\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;short\u0026lt;/span\u0026gt;\u0026amp;gt; { \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;enum\u0026lt;/span\u0026gt; { val = \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;true\u0026lt;/span\u0026gt;}; };\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;is_signed_int\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;\u0026amp;gt; { \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;enum\u0026lt;/span\u0026gt; { val = \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;true\u0026lt;/span\u0026gt;}; };\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;is_signed_int\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;long\u0026lt;/span\u0026gt;\u0026amp;gt; { \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;enum\u0026lt;/span\u0026gt; { val = \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;true\u0026lt;/span\u0026gt;}; };\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;is_signed_int\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;long\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;long\u0026lt;/span\u0026gt;\u0026amp;gt; { \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;enum\u0026lt;/span\u0026gt; { val = \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;true\u0026lt;/span\u0026gt;}; };\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; T\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;is_unsigned_int\u0026lt;/span\u0026gt; { \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;enum\u0026lt;/span\u0026gt; { val = \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;false\u0026lt;/span\u0026gt; }; };\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;is_unsigned_int\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;unsigned\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;short\u0026lt;/span\u0026gt;\u0026amp;gt; { \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;enum\u0026lt;/span\u0026gt; { val = \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;true\u0026lt;/span\u0026gt;}; };\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;is_unsigned_int\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;unsigned\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;\u0026amp;gt; { \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;enum\u0026lt;/span\u0026gt; { val = \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;true\u0026lt;/span\u0026gt;}; };\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;is_unsigned_int\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;unsigned\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;long\u0026lt;/span\u0026gt;\u0026amp;gt; { \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;enum\u0026lt;/span\u0026gt; { val = \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;true\u0026lt;/span\u0026gt;}; };\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;is_unsigned_int\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;unsigned\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;long\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;long\u0026lt;/span\u0026gt;\u0026amp;gt; { \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;enum\u0026lt;/span\u0026gt; { val = \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;true\u0026lt;/span\u0026gt;}; };\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; T\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;is_int\u0026lt;/span\u0026gt; {\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;enum\u0026lt;/span\u0026gt; { val = (is_signed_int\u0026amp;lt;T\u0026amp;gt;::val || is_unsigned_int\u0026amp;lt;T\u0026amp;gt;::val) };\n};\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;a href=\u0026quot;https://tio.run/##rVZtT@NGEP7uXzG4UrDpFuXK0VNev/ToqRVUlaAnVQRFxt6EFc6u5d2YIi6/nc6sHbKOHTig5iWb3Zlnnnn1xln20zyOH38QMk6XCYehUNrkPFqMvc2eXm95hi@yNDK4Z@4zLqMFh4sx4PEyNiD0VIu55MlUSAMPwOVygR9FlMIIZlGqOawG@OugtOsO9Y3KzXgbAiX5dwLg33vUUyXn79WHF0BejOVSviearvZw/QXeFth2rLfEuB3pTeHeDfXuyNuAe4BPDSGoJ/li3O/TwbdvDTrVUUjWVoPHCjnWxVSUrVTBa5P0@@utDqIM7LYrGGzLhNAnewGtHlZWvlACUxtHcnqnIQghVlKvPaDn7kak3NI/nCuVBGHoHNJDDsfoIUlknN8G4aB@PoMghr0R7ONPpwPlemL2Q7hGXrdb0mSHGxek5LnFtvINXROYtAONBLpN8q7Mnd5Aupy3rBHd3c4mamtj4@EIvWL7lNFyPZHtHq41dNgCZSOu4ccRxIPWw2ei2Y5Gz4FFdAPQtHkYpzzKt5NXz8HzOzsCaoVbyqhZJXTI1YyiTssGIbcQ2tqQwbVS6VMzam6m2EhL7kTG1o/KeB4ZlVO518pISAYX0CmahVRrOBQtWyoQMoTxGIoGx8FOkk16QyROA2bs2Ntokktw/vuXP08@j0v6yK3guXkNdYpuiRFCgWmyakalKXpwGE/xSxAy6OLvVlo4vSocjeXzKqv/JdCVg8PWkTkOSLkIXxXy0oo7GjsbcpjAoJ2MS9ksso1JmkBBB7ccGrV8li@CDecwQOE67ZybZS7hwNyIqjFLR17k6rJqY100O6ea721zrhzZdor4OERKz1yetgRaOqEtLjsm@JMO7qdCcjLMwEaEjNYFnUlRcRtV3JoDrqC51mDwdLKDyqvo1Odcu0EbtNY22JXk1jL9vvRjqQYHi0iKLKR12CwAdIckrczL9fYEbifN5gawVtijKM4ikaKHqIJXEnp7LiIhSfjBqwjfRDm2dbY0l1cw8vx/sALZWXTL2ZlKeMo@cx3nIjNCSfZXLmI@kb7nf@j1PrHfVJ6wk6PjLpv4UcwgutYMFkrJic@Out3uYbe7Fu6xX294cY@CX7lEdhwm/sQ/@ddwmeAF7iQRZID2UNf@@9h7AwCDrzy/h9Mon3MX7LjO5hf2B@cZ@5JHMgHEzdUt5yh59vf5BZyfnJ7uTeTEi0ReugO5UjOGF8wITRG1T71ehYb3yubbBbQObESxsmodJ0zKL4@vBh4l4h4DXT9fUNTRIoUdEoz7wJuhUQMZxX3gObUVaB3aIsByKWG7V5v1B2f9s7M@ctYfkUbVsW24JTRxLCvylttP4kYLYkefllnoXmxjtTQwHILfJ@XRpU9fLA5tXvlbDW0lCb6StJaekSQCa1FLZrcscaxELd3dktaLStSuS1lMMN7kPW/1@B8\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot; title=\u0026quot;C++ (gcc)  Try It Online\u0026quot;\u0026gt;Try it online!\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;You might want to look at my FOSS project \u0026lt;a href=\u0026quot;http://code.google.com/p/csvfix/\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;CSVfix\u0026lt;/a\u0026gt; (\u0026lt;a href=\u0026quot;https://bitbucket.org/neilb/csvfix/\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;\u0026lt;em\u0026gt;updated link\u0026lt;/em\u0026gt;\u0026lt;/a\u0026gt;), which is a CSV stream editor written in C++. The CSV parser is no prize, but does the job and the whole package may do what you need without you writing any code.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;See \u0026lt;a href=\u0026quot;https://bitbucket.org/neilb/csvfix/src/default/alib/src/a_csv.cpp?fileviewer=file-view-default\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;alib/src/a_csv.cpp\u0026lt;/a\u0026gt; for the CSV parser, and \u0026lt;a href=\u0026quot;https://bitbucket.org/neilb/csvfix/src/default/csvfix/src/csved_ioman.cpp?fileviewer=file-view-default#csved_ioman.cpp-348\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;csvlib/src/csved_ioman.cpp\u0026lt;/a\u0026gt; (\u0026lt;code\u0026gt;IOManager::ReadCSV\u0026lt;/code\u0026gt;) for a usage example.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Another CSV I/O library can be found here:\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;a href=\u0026quot;http://code.google.com/p/fast-cpp-csv-parser/\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;http://code.google.com/p/fast-cpp-csv-parser/\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;csv.h\u0026quot;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;main\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;{\n  \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;io::CSVReader\u0026amp;lt;3\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;in\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;ram.csv\u0026quot;\u0026lt;/span\u0026gt;)\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;;\n  in.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;read_header\u0026lt;/span\u0026gt;(io::ignore_extra_column, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;vendor\u0026quot;\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;size\u0026quot;\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;speed\u0026quot;\u0026lt;/span\u0026gt;);\n  std::string vendor; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; size; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;double\u0026lt;/span\u0026gt; speed;\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;while\u0026lt;/span\u0026gt;(in.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;read_row\u0026lt;/span\u0026gt;(vendor, size, speed)){\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// do stuff with the data\u0026lt;/span\u0026gt;\n  }\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Another solution similar to \u0026lt;a href=\u0026quot;https://stackoverflow.com/a/1120224/1749822\u0026quot;\u0026gt;Loki Astari\u0026apos;s answer\u0026lt;/a\u0026gt;, in C++11. Rows here are \u0026lt;code\u0026gt;std::tuple\u0026lt;/code\u0026gt;s of a given type. The code scans one line, then scans until each delimiter, and then converts and dumps the value directly into the tuple (with a bit of template code).\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt; (\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;auto\u0026lt;/span\u0026gt; row : \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;csv\u0026lt;/span\u0026gt;\u0026amp;lt;std::string, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;float\u0026lt;/span\u0026gt;\u0026amp;gt;(file, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;,\u0026apos;\u0026lt;/span\u0026gt;)) {\n    std::cout \u0026amp;lt;\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;first col: \u0026quot;\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026amp;lt; std::\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;get\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;\u0026amp;gt;(row) \u0026amp;lt;\u0026amp;lt; std::endl;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Advanges:\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;quite clean and simple to use, only C++11.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;automatic type conversion into \u0026lt;code\u0026gt;std::tuple\u0026amp;lt;t1, ...\u0026amp;gt;\u0026lt;/code\u0026gt; via \u0026lt;code\u0026gt;operator\u0026amp;gt;\u0026amp;gt;\u0026lt;/code\u0026gt;.\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;What\u0026apos;s missing:\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;escaping and quoting\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;no error handling in case of malformed CSV.\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\n\u0026lt;p\u0026gt;The main code:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;iterator\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;sstream\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;string\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;namespace\u0026lt;/span\u0026gt; csvtools {\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;/// Read the last element of the tuple without calling recursively\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt; \u0026amp;lt;std::\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;size_t\u0026lt;/span\u0026gt; idx, \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt;... fields\u0026amp;gt;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; std::enable_if\u0026amp;lt;idx \u0026amp;gt;= std::tuple_size\u0026amp;lt;std::tuple\u0026amp;lt;fields...\u0026amp;gt;\u0026amp;gt;::value - \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;\u0026amp;gt;::type\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;read_tuple\u0026lt;/span\u0026gt;(std::istream \u0026amp;amp;in, std::tuple\u0026amp;lt;fields...\u0026amp;gt; \u0026amp;amp;out, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; delimiter) {\n        std::string cell;\n        std::\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;getline\u0026lt;/span\u0026gt;(in, cell, delimiter);\n        \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;std::stringstream \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;cell_stream\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(cell)\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;;\n        cell_stream \u0026amp;gt;\u0026amp;gt; std::\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;get\u0026lt;/span\u0026gt;\u0026amp;lt;idx\u0026amp;gt;(out);\n    }\n\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;/// Read the @p idx-th element of the tuple and then calls itself with @p idx + 1 to\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;/// read the next element of the tuple. Automatically falls in the previous case when\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;/// reaches the last element of the tuple thanks to enable_if\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt; \u0026amp;lt;std::\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;size_t\u0026lt;/span\u0026gt; idx, \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt;... fields\u0026amp;gt;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; std::enable_if\u0026amp;lt;idx \u0026amp;lt; std::tuple_size\u0026amp;lt;std::tuple\u0026amp;lt;fields...\u0026amp;gt;\u0026amp;gt;::value - \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;\u0026amp;gt;::\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;type\n    \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;read_tuple\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(std::istream \u0026amp;amp;in, std::tuple\u0026amp;lt;fields...\u0026amp;gt; \u0026amp;amp;out, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; delimiter)\u0026lt;/span\u0026gt; \u0026lt;/span\u0026gt;{\n        std::string cell;\n        std::\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;getline\u0026lt;/span\u0026gt;(in, cell, delimiter);\n        \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;std::stringstream \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;cell_stream\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(cell)\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;;\n        cell_stream \u0026amp;gt;\u0026amp;gt; std::\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;get\u0026lt;/span\u0026gt;\u0026amp;lt;idx\u0026amp;gt;(out);\n        \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;read_tuple\u0026lt;/span\u0026gt;\u0026amp;lt;idx + \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;, fields...\u0026amp;gt;(in, out, delimiter);\n    }\n}\n\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;/// Iterable csv wrapper around a stream. @p fields the list of types that form up a row.\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt;... fields\u0026amp;gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;csv\u0026lt;/span\u0026gt; {\n    std::istream \u0026amp;amp;_in;\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; _delim;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt;:\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typedef\u0026lt;/span\u0026gt; std::tuple\u0026amp;lt;fields...\u0026amp;gt; value_type;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;iterator\u0026lt;/span\u0026gt;;\n\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;/// Construct from a stream.\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;inline\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;csv\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(std::istream \u0026amp;amp;in, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; delim)\u0026lt;/span\u0026gt; : _in(in), _delim(delim) {\u0026lt;/span\u0026gt;}\n\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;/// Status of the underlying stream\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;/// @{\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;inline\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;bool\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;good\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; \u0026lt;/span\u0026gt;{\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; _in.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;good\u0026lt;/span\u0026gt;();\n    }\n    \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;inline\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; std::istream \u0026amp;amp;\u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;underlying_stream\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; \u0026lt;/span\u0026gt;{\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; _in;\n    }\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;/// @}\u0026lt;/span\u0026gt;\n\n    \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;inline\u0026lt;/span\u0026gt; iterator \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;begin\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;;\n    \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;inline\u0026lt;/span\u0026gt; iterator \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;end\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;private\u0026lt;/span\u0026gt;:\n\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;/// Reads a line into a stringstream, and then reads the line into a tuple, that is returned\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;inline\u0026lt;/span\u0026gt; value_type \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;read_row\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt; \u0026lt;/span\u0026gt;{\n        std::string line;\n        std::\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;getline\u0026lt;/span\u0026gt;(_in, line);\n        \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;std::stringstream \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;line_stream\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(line)\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;;\n        std::tuple\u0026amp;lt;fields...\u0026amp;gt; retval;\n        csvtools::\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;read_tuple\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;, fields...\u0026amp;gt;(line_stream, retval, _delim);\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; retval;\n    }\n};\n\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;/// Iterator; just calls recursively @ref csv::read_row and stores the result.\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt;... fields\u0026amp;gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;csv\u0026lt;/span\u0026gt;\u0026amp;lt;fields...\u0026amp;gt;::iterator {\n    csv::value_type _row;\n    csv *_parent;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt;:\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typedef\u0026lt;/span\u0026gt; std::input_iterator_tag iterator_category;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typedef\u0026lt;/span\u0026gt; csv::value_type         value_type;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typedef\u0026lt;/span\u0026gt; std::\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;size_t\u0026lt;/span\u0026gt;             difference_type;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typedef\u0026lt;/span\u0026gt; csv::value_type *       pointer;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typedef\u0026lt;/span\u0026gt; csv::value_type \u0026amp;amp;       reference;\n\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;/// Construct an empty/end iterator\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;inline\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;iterator\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt; : _parent(nullptr) {\u0026lt;/span\u0026gt;}\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;/// Construct an iterator at the beginning of the @p parent csv object.\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;inline\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;iterator\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(csv \u0026amp;amp;parent)\u0026lt;/span\u0026gt; : _parent(parent.good() ? \u0026amp;amp;parent : nullptr) {\u0026lt;/span\u0026gt;\n        ++(*\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;this\u0026lt;/span\u0026gt;);\n    }\n\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;/// Read one row, if possible. Set to end if parent is not good anymore.\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;inline\u0026lt;/span\u0026gt; iterator \u0026amp;amp;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;operator\u0026lt;/span\u0026gt;++() {\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (_parent != \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;nullptr\u0026lt;/span\u0026gt;) {\n            _row = _parent-\u0026amp;gt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;read_row\u0026lt;/span\u0026gt;();\n            \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (!_parent-\u0026amp;gt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;good\u0026lt;/span\u0026gt;()) {\n                _parent = \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;nullptr\u0026lt;/span\u0026gt;;\n            }\n        }\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; *\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;this\u0026lt;/span\u0026gt;;\n    }\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;inline\u0026lt;/span\u0026gt; iterator \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;operator\u0026lt;/span\u0026gt;++(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;) {\n        iterator copy = *\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;this\u0026lt;/span\u0026gt;;\n        ++(*\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;this\u0026lt;/span\u0026gt;);\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; copy;\n    }\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;inline\u0026lt;/span\u0026gt; csv::value_type \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; \u0026amp;amp;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;operator\u0026lt;/span\u0026gt;*() \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; {\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; _row;\n    }\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;inline\u0026lt;/span\u0026gt; csv::value_type \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; *\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;operator\u0026lt;/span\u0026gt;-\u0026amp;gt;() \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; {\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026amp;amp;_row;\n    }\n\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;bool\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;operator\u0026lt;/span\u0026gt;==(iterator \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; \u0026amp;amp;other) {\n        \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; (\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;this\u0026lt;/span\u0026gt; == \u0026amp;amp;other) \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;or\u0026lt;/span\u0026gt; (_parent == \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;nullptr\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;and\u0026lt;/span\u0026gt; other._parent == \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;nullptr\u0026lt;/span\u0026gt;);\n    }\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;bool\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;operator\u0026lt;/span\u0026gt;!=(iterator \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; \u0026amp;amp;other) {\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;not\u0026lt;/span\u0026gt; (*\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;this\u0026lt;/span\u0026gt; == other);\n    }\n};\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt;... fields\u0026amp;gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; csv\u0026amp;lt;fields...\u0026amp;gt;::iterator csv\u0026amp;lt;fields...\u0026amp;gt;::\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;begin\u0026lt;/span\u0026gt;() {\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;iterator\u0026lt;/span\u0026gt;(*\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;this\u0026lt;/span\u0026gt;);\n}\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt;... fields\u0026amp;gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; csv\u0026amp;lt;fields...\u0026amp;gt;::iterator csv\u0026amp;lt;fields...\u0026amp;gt;::\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;end\u0026lt;/span\u0026gt;() {\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;iterator\u0026lt;/span\u0026gt;();\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;I put a tiny working example on \u0026lt;a href=\u0026quot;https://github.com/LizardM4/ballin-octo-tribble/tree/master/csv\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;GitHub\u0026lt;/a\u0026gt;; I\u0026apos;ve been using it for parsing some numerical data and it served its purpose.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Here is another implementation of a Unicode CSV parser (works with wchar_t). I wrote part of it, while Jonathan Leffler wrote the rest.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Note: This parser is aimed at replicating Excel\u0026apos;s behavior as closely as possible, specifically when importing \u0026lt;strong\u0026gt;broken or malformed\u0026lt;/strong\u0026gt; CSV files.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;This is the original question - \u0026lt;a href=\u0026quot;https://stackoverflow.com/questions/15520113/parsing-csv-file-with-multiline-fields-and-escaped-double-quotes\u0026quot;\u0026gt;Parsing CSV file with multiline fields and escaped double quotes\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;This is the code as a SSCCE (Short, Self-Contained, Correct Example).\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;stdbool.h\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;wchar.h\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;wctype.h\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;extern\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;wchar_t\u0026lt;/span\u0026gt; *\u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;nextCsvField\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;wchar_t\u0026lt;/span\u0026gt; *p, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;wchar_t\u0026lt;/span\u0026gt; sep, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;bool\u0026lt;/span\u0026gt; *newline)\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;;\n\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Returns a pointer to the start of the next field,\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// or zero if this is the last field in the CSV\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// p is the start position of the field\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// sep is the separator used, i.e. comma or semicolon\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// newline says whether the field ends with a newline or with a comma\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;wchar_t\u0026lt;/span\u0026gt; *\u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;nextCsvField\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;wchar_t\u0026lt;/span\u0026gt; *p, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;wchar_t\u0026lt;/span\u0026gt; sep, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;bool\u0026lt;/span\u0026gt; *newline)\u0026lt;/span\u0026gt;\n\u0026lt;/span\u0026gt;{\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Parse quoted sequences\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;\u0026quot;\u0026apos;\u0026lt;/span\u0026gt; == p[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;]) {\n        p++;\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;while\u0026lt;/span\u0026gt; (\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;) {\n            \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Find next double-quote\u0026lt;/span\u0026gt;\n            p = \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;wcschr\u0026lt;/span\u0026gt;(p, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;L\u0026apos;\u0026quot;\u0026apos;\u0026lt;/span\u0026gt;);\n            \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// If we don\u0026apos;t find it or it\u0026apos;s the last symbol\u0026lt;/span\u0026gt;\n            \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// then this is the last field\u0026lt;/span\u0026gt;\n            \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (!p || !p[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;])\n                \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;;\n            \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Check for \u0026quot;\u0026quot;, it is an escaped double-quote\u0026lt;/span\u0026gt;\n            \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (p[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;] != \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;\u0026quot;\u0026apos;\u0026lt;/span\u0026gt;)\n                \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;break\u0026lt;/span\u0026gt;;\n            \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Skip the escaped double-quote\u0026lt;/span\u0026gt;\n            p += \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;;\n        }\n    }\n\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Find next newline or comma.\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;wchar_t\u0026lt;/span\u0026gt; newline_or_sep[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;4\u0026lt;/span\u0026gt;] = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;L\u0026quot;\\n\\r \u0026quot;\u0026lt;/span\u0026gt;;\n    newline_or_sep[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;] = sep;\n    p = \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;wcspbrk\u0026lt;/span\u0026gt;(p, newline_or_sep);\n\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// If no newline or separator, this is the last field.\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (!p)\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;;\n\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Check if we had newline.\u0026lt;/span\u0026gt;\n    *newline = (p[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;] == \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;\\r\u0026apos;\u0026lt;/span\u0026gt; || p[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;] == \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;\\n\u0026apos;\u0026lt;/span\u0026gt;);\n\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Handle \u0026quot;\\r\\n\u0026quot;, otherwise just increment\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (p[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;] == \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;\\r\u0026apos;\u0026lt;/span\u0026gt; \u0026amp;amp;\u0026amp;amp; p[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;] == \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;\\n\u0026apos;\u0026lt;/span\u0026gt;)\n        p += \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;else\u0026lt;/span\u0026gt;\n        p++;\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; p;\n}\n\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;static\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;wchar_t\u0026lt;/span\u0026gt; *\u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;csvFieldData\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;wchar_t\u0026lt;/span\u0026gt; *fld_s, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;wchar_t\u0026lt;/span\u0026gt; *fld_e, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;wchar_t\u0026lt;/span\u0026gt; *buffer, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;size_t\u0026lt;/span\u0026gt; buflen)\u0026lt;/span\u0026gt;\n\u0026lt;/span\u0026gt;{\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;wchar_t\u0026lt;/span\u0026gt; *dst = buffer;\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;wchar_t\u0026lt;/span\u0026gt; *end = buffer + buflen - \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;;\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;wchar_t\u0026lt;/span\u0026gt; *src = fld_s;\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (*src == \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;L\u0026apos;\u0026quot;\u0026apos;\u0026lt;/span\u0026gt;)\n    {\n        \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;wchar_t\u0026lt;/span\u0026gt; *p = src + \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;;\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;while\u0026lt;/span\u0026gt; (p \u0026amp;lt; fld_e \u0026amp;amp;\u0026amp;amp; dst \u0026amp;lt; end)\n        {\n            \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (p[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;] == \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;L\u0026apos;\u0026quot;\u0026apos;\u0026lt;/span\u0026gt; \u0026amp;amp;\u0026amp;amp; p+\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt; \u0026amp;lt; fld_s \u0026amp;amp;\u0026amp;amp; p[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;] == \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;L\u0026apos;\u0026quot;\u0026apos;\u0026lt;/span\u0026gt;)\n            {\n                *dst++ = p[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;];\n                p += \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;;\n            }\n            \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;else\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (p[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;] == \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;L\u0026apos;\u0026quot;\u0026apos;\u0026lt;/span\u0026gt;)\n            {\n                p++;\n                \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;break\u0026lt;/span\u0026gt;;\n            }\n            \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;else\u0026lt;/span\u0026gt;\n                *dst++ = *p++;\n        }\n        src = p;\n    }\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;while\u0026lt;/span\u0026gt; (src \u0026amp;lt; fld_e \u0026amp;amp;\u0026amp;amp; dst \u0026amp;lt; end)\n        *dst++ = *src++;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (dst \u0026amp;gt;= end)\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;;\n    *dst = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;L\u0026apos;\\0\u0026apos;\u0026lt;/span\u0026gt;;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt;(buffer);\n}\n\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;static\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;dissect\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;wchar_t\u0026lt;/span\u0026gt; *line)\u0026lt;/span\u0026gt;\n\u0026lt;/span\u0026gt;{\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;wchar_t\u0026lt;/span\u0026gt; *start = line;\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;wchar_t\u0026lt;/span\u0026gt; *next;\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;bool\u0026lt;/span\u0026gt;     eol;\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;wprintf\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;L\u0026quot;Input %3zd: [%.*ls]\\n\u0026quot;\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;wcslen\u0026lt;/span\u0026gt;(line), \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;wcslen\u0026lt;/span\u0026gt;(line)\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;-1\u0026lt;/span\u0026gt;, line);\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;while\u0026lt;/span\u0026gt; ((next = \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;nextCsvField\u0026lt;/span\u0026gt;(start, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;L\u0026apos;,\u0026apos;\u0026lt;/span\u0026gt;, \u0026amp;amp;eol)) != \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;)\n    {\n        \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;wchar_t\u0026lt;/span\u0026gt; buffer[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1024\u0026lt;/span\u0026gt;];\n        \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;wprintf\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;L\u0026quot;Raw Field: [%.*ls] (eol = %d)\\n\u0026quot;\u0026lt;/span\u0026gt;, (next - start - eol), start, eol);\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;csvFieldData\u0026lt;/span\u0026gt;(start, next\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;-1\u0026lt;/span\u0026gt;, buffer, \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;sizeof\u0026lt;/span\u0026gt;(buffer)/\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;sizeof\u0026lt;/span\u0026gt;(buffer[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;])) != \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;)\n            \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;wprintf\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;L\u0026quot;Field %3zd: [%ls]\\n\u0026quot;\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;wcslen\u0026lt;/span\u0026gt;(buffer), buffer);\n        start = next;\n    }\n}\n\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;static\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;wchar_t\u0026lt;/span\u0026gt; multiline[] =\n   \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;L\u0026quot;First field of first row,\\\u0026quot;This field is multiline\\n\u0026quot;\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;\\n\u0026quot;\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;but that\u0026apos;s OK because it\u0026apos;s enclosed in double quotes, and this\\n\u0026quot;\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;is an escaped \\\u0026quot;\\\u0026quot; double quote\\\u0026quot; but this one \\\u0026quot;\\\u0026quot; is not\\n\u0026quot;\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;   \\\u0026quot;This is second field of second row, but it is not multiline\\n\u0026quot;\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;   because it doesn\u0026apos;t start \\n\u0026quot;\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;   with an immediate double quote\\\u0026quot;\\n\u0026quot;\u0026lt;/span\u0026gt;\n    ;\n\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;main\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt;)\u0026lt;/span\u0026gt;\n\u0026lt;/span\u0026gt;{\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;wchar_t\u0026lt;/span\u0026gt; line[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1024\u0026lt;/span\u0026gt;];\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;while\u0026lt;/span\u0026gt; (\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;fgetws\u0026lt;/span\u0026gt;(line, \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;sizeof\u0026lt;/span\u0026gt;(line)/\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;sizeof\u0026lt;/span\u0026gt;(line[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;]), stdin))\n        \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;dissect\u0026lt;/span\u0026gt;(line);\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;dissect\u0026lt;/span\u0026gt;(multiline);\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;This is an old thread but its still at the top of search results, so I\u0026apos;m adding my solution using std::stringstream and a simple string replace method by Yves Baumes I found here.  \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;The following example will read a file line by line, ignore comment lines starting with // and parse the other lines into a combination of strings, ints and doubles. Stringstream does the parsing, but expects fields to be delimited by whitespace, so I use stringreplace to turn commas into spaces first. It handles tabs ok, but doesn\u0026apos;t deal with quoted strings.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Bad or missing input is simply ignored, which may or may not be good, depending on your circumstance.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;string\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;sstream\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;fstream\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;StringReplace\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(std::string\u0026amp;amp; str, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; std::string\u0026amp;amp; oldStr, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; std::string\u0026amp;amp; newStr)\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// code by  Yves Baumes\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// http://stackoverflow.com/questions/1494399/how-do-i-search-find-and-replace-in-a-standard-string\u0026lt;/span\u0026gt;\n\u0026lt;/span\u0026gt;{\n  \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;size_t\u0026lt;/span\u0026gt; pos = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;;\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;while\u0026lt;/span\u0026gt;((pos = str.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;find\u0026lt;/span\u0026gt;(oldStr, pos)) != std::string::npos)\n  {\n     str.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;replace\u0026lt;/span\u0026gt;(pos, oldStr.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;length\u0026lt;/span\u0026gt;(), newStr);\n     pos += newStr.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;length\u0026lt;/span\u0026gt;();\n  }\n}\n\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;LoadCSV\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(std::string \u0026amp;amp;filename)\u0026lt;/span\u0026gt; \u0026lt;/span\u0026gt;{\n   \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;std::ifstream \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;stream\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(filename)\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;;\n   std::string in_line;\n   std::string Field;\n   std::string Chan;\n   \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; ChanType;\n   \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;double\u0026lt;/span\u0026gt; Scale;\n   \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; Import;\n   \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;while\u0026lt;/span\u0026gt; (std::\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;getline\u0026lt;/span\u0026gt;(stream, in_line)) {\n      \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;StringReplace\u0026lt;/span\u0026gt;(in_line, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;,\u0026quot;\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot; \u0026quot;\u0026lt;/span\u0026gt;);\n      \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;std::stringstream \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;line\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(in_line)\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;;\n      line \u0026amp;gt;\u0026amp;gt; Field \u0026amp;gt;\u0026amp;gt; Chan \u0026amp;gt;\u0026amp;gt; ChanType \u0026amp;gt;\u0026amp;gt; Scale \u0026amp;gt;\u0026amp;gt; Import;\n      \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (Field.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;substr\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;,\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;)!=\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;//\u0026quot;\u0026lt;/span\u0026gt;) {\n         \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// do your stuff \u0026lt;/span\u0026gt;\n         \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// this is CBuilder code for demonstration, sorry\u0026lt;/span\u0026gt;\n         \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;ShowMessage\u0026lt;/span\u0026gt;((String)Field.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;c_str\u0026lt;/span\u0026gt;() + \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;\\n\u0026quot;\u0026lt;/span\u0026gt; + Chan.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;c_str\u0026lt;/span\u0026gt;() + \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;\\n\u0026quot;\u0026lt;/span\u0026gt; + \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;IntToStr\u0026lt;/span\u0026gt;(ChanType) + \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;\\n\u0026quot;\u0026lt;/span\u0026gt; +\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;FloatToStr\u0026lt;/span\u0026gt;(Scale) + \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;\\n\u0026quot;\u0026lt;/span\u0026gt; +\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;IntToStr\u0026lt;/span\u0026gt;(Import));\n      }\n   }\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;I needed an easy-to-use C++ library for parsing CSV files but couldn\u0026apos;t find any available, so I ended up building one.\n\u0026lt;a href=\u0026quot;https://github.com/d99kris/rapidcsv/\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;Rapidcsv\u0026lt;/a\u0026gt; is a C++11 header-only library which gives direct access to parsed columns (or rows) as vectors, in datatype of choice. For example:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;iostream\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;vector\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;rapidcsv.h\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;main\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt;\n\u0026lt;/span\u0026gt;{\n  \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;rapidcsv::Document \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;doc\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;../tests/msft.csv\u0026quot;\u0026lt;/span\u0026gt;)\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;;\n\n  std::vector\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;float\u0026lt;/span\u0026gt;\u0026amp;gt; close = doc.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;GetColumn\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;float\u0026lt;/span\u0026gt;\u0026amp;gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Close\u0026quot;\u0026lt;/span\u0026gt;);\n  std::cout \u0026amp;lt;\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Read \u0026quot;\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026amp;lt; close.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;size\u0026lt;/span\u0026gt;() \u0026amp;lt;\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot; values.\u0026quot;\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026amp;lt; std::endl;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;You can use the header-only \u0026lt;a href=\u0026quot;https://github.com/ashaduri/csv-parser\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;Csv::Parser\u0026lt;/a\u0026gt; library.\u0026lt;/p\u0026gt;\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;It fully supports RFC 4180, including quoted values, escaped quotes, and newlines in field values.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;It requires only standard C++ (C++17).\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;It supports reading CSV data from \u0026lt;code\u0026gt;std::string_view\u0026lt;/code\u0026gt; at compile-time.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;It\u0026apos;s extensively tested using \u0026lt;a href=\u0026quot;https://github.com/catchorg/Catch2\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;Catch2\u0026lt;/a\u0026gt;.\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Here is code for reading a matrix, note you also have a csvwrite function in matlab\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;loadFromCSV\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;( \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; std::string\u0026amp;amp; filename )\u0026lt;/span\u0026gt;\n\u0026lt;/span\u0026gt;{\n    \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;std::ifstream       \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;file\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;( filename.c_str() )\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;;\n    std::vector\u0026amp;lt; std::vector\u0026amp;lt;std::string\u0026amp;gt; \u0026amp;gt;   matrix;\n    std::vector\u0026amp;lt;std::string\u0026amp;gt;   row;\n    std::string                line;\n    std::string                cell;\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;while\u0026lt;/span\u0026gt;( file )\n    {\n        std::\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;getline\u0026lt;/span\u0026gt;(file,line);\n        \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;std::stringstream \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;lineStream\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(line)\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;;\n        row.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;clear\u0026lt;/span\u0026gt;();\n\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;while\u0026lt;/span\u0026gt;( std::\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;getline\u0026lt;/span\u0026gt;( lineStream, cell, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;,\u0026apos;\u0026lt;/span\u0026gt; ) )\n            row.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;push_back\u0026lt;/span\u0026gt;( cell );\n\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt;( !row.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;empty\u0026lt;/span\u0026gt;() )\n            matrix.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;push_back\u0026lt;/span\u0026gt;( row );\n    }\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt;( \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; i=\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;; i\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;(matrix.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;size\u0026lt;/span\u0026gt;()); i++ )\n    {\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt;( \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; j=\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;; j\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;(matrix[i].\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;size\u0026lt;/span\u0026gt;()); j++ )\n            std::cout \u0026amp;lt;\u0026amp;lt; matrix[i][j] \u0026amp;lt;\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot; \u0026quot;\u0026lt;/span\u0026gt;;\n\n        std::cout \u0026amp;lt;\u0026amp;lt; std::endl;\n    }\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Excuse me, but this all seems like a great deal of elaborate syntax to hide a few lines of code.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Why not this:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;/**\n\n  Read line from a CSV file\n\n  @param[in] fp file pointer to open file\n  @param[in] vls reference to vector of strings to hold next line\n\n  */\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;readCSV\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;( FILE *fp, std::vector\u0026amp;lt;std::string\u0026amp;gt;\u0026amp;amp; vls )\u0026lt;/span\u0026gt;\n\u0026lt;/span\u0026gt;{\n    vls.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;clear\u0026lt;/span\u0026gt;();\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt;( ! fp )\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt;;\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; buf[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;10000\u0026lt;/span\u0026gt;];\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt;( ! \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;fgets\u0026lt;/span\u0026gt;( buf,\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;999\u0026lt;/span\u0026gt;,fp) )\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt;;\n    std::string s = buf;\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; p,q;\n    q = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;-1\u0026lt;/span\u0026gt;;\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// loop over columns\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;while\u0026lt;/span\u0026gt;( \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt; ) {\n        p = q;\n        q = s.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;find_first_of\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;,\\n\u0026quot;\u0026lt;/span\u0026gt;,p+\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;);\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt;( q == \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;-1\u0026lt;/span\u0026gt; ) \n            \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;break\u0026lt;/span\u0026gt;;\n        vls.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;push_back\u0026lt;/span\u0026gt;( s.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;substr\u0026lt;/span\u0026gt;(p+\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;,q-p\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;-1\u0026lt;/span\u0026gt;) );\n    }\n}\n\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; _tmain(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; argc, _TCHAR* argv[])\n{\n    std::vector\u0026amp;lt;std::string\u0026amp;gt; vls;\n    FILE * fp = \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;fopen\u0026lt;/span\u0026gt;( argv[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;], \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;r\u0026quot;\u0026lt;/span\u0026gt; );\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt;( ! fp )\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;;\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;readCSV\u0026lt;/span\u0026gt;( fp, vls );\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;readCSV\u0026lt;/span\u0026gt;( fp, vls );\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;readCSV\u0026lt;/span\u0026gt;( fp, vls );\n    std::cout \u0026amp;lt;\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;row 3, col 4 is \u0026quot;\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026amp;lt; vls[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3\u0026lt;/span\u0026gt;].\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;c_str\u0026lt;/span\u0026gt;() \u0026amp;lt;\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;\\n\u0026quot;\u0026lt;/span\u0026gt;;\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;You can open and read .csv file using fopen ,fscanf functions ,but the important thing is to parse the data.Simplest way to parse the data using delimiter.In case of .csv , delimiter is \u0026apos;,\u0026apos;.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Suppose your data1.csv file is as follows : \u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;A,\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;45\u0026lt;/span\u0026gt;,\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;76\u0026lt;/span\u0026gt;,\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;01\u0026lt;/span\u0026gt;\nB,\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;77\u0026lt;/span\u0026gt;,\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;67\u0026lt;/span\u0026gt;,\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;02\u0026lt;/span\u0026gt;\nC,\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;63\u0026lt;/span\u0026gt;,\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;76\u0026lt;/span\u0026gt;,\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;03\u0026lt;/span\u0026gt;\nD,\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;65\u0026lt;/span\u0026gt;,\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;44\u0026lt;/span\u0026gt;,\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;04\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;you can tokenize data and store in char array and later use atoi() etc function for appropriate conversions  \u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;FILE *fp;\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; str1[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;10\u0026lt;/span\u0026gt;], str2[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;10\u0026lt;/span\u0026gt;], str3[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;10\u0026lt;/span\u0026gt;], str4[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;10\u0026lt;/span\u0026gt;];\n\nfp = \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;fopen\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;G:\\\\data1.csv\u0026quot;\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;r\u0026quot;\u0026lt;/span\u0026gt;);\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;NULL\u0026lt;/span\u0026gt; == fp)\n{\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;printf\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;\\nError in opening file.\u0026quot;\u0026lt;/span\u0026gt;);\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;;\n}\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;while\u0026lt;/span\u0026gt;(EOF != \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;fscanf\u0026lt;/span\u0026gt;(fp, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot; %[^,], %[^,], %[^,], %s, %s, %s, %s \u0026quot;\u0026lt;/span\u0026gt;, str1, str2, str3, str4))\n{\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;printf\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;\\n%s %s %s %s\u0026quot;\u0026lt;/span\u0026gt;, str1, str2, str3, str4);\n}\n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;fclose\u0026lt;/span\u0026gt;(fp);\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;[^,], ^ -it inverts logic , means match any string that does not contain comma then last , says to match comma that terminated previous string. \u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;The first thing you need to do is make sure the file exists. To accomplish\nthis you just need to try and open the file stream at the path. After you\nhave opened the file stream use stream.fail() to see if it worked as expected,\nor not.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;bool\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;fileExists\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(string fileName)\u0026lt;/span\u0026gt;\n\u0026lt;/span\u0026gt;{\n\nifstream test;\n\ntest.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;open\u0026lt;/span\u0026gt;(fileName.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;c_str\u0026lt;/span\u0026gt;());\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (test.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;fail\u0026lt;/span\u0026gt;())\n{\n    test.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;close\u0026lt;/span\u0026gt;();\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;false\u0026lt;/span\u0026gt;;\n}\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;else\u0026lt;/span\u0026gt;\n{\n    test.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;close\u0026lt;/span\u0026gt;();\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;true\u0026lt;/span\u0026gt;;\n}\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;You must also verify that the file provided is the correct type of file.\nTo accomplish this you need to look through the file path provided until \nyou find the file extension. Once you have the file extension make sure\nthat it is a .csv file.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;bool\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;verifyExtension\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(string filename)\u0026lt;/span\u0026gt;\n\u0026lt;/span\u0026gt;{\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; period = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;;\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt; (\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;unsigned\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; i = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;; i \u0026amp;lt; filename.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;length\u0026lt;/span\u0026gt;(); i++)\n{\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (filename[i] == \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;.\u0026apos;\u0026lt;/span\u0026gt;)\n        period = i;\n}\n\nstring extension;\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt; (\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;unsigned\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; i = period; i \u0026amp;lt; filename.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;length\u0026lt;/span\u0026gt;(); i++)\n    extension += filename[i];\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (extension == \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;.csv\u0026quot;\u0026lt;/span\u0026gt;)\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;true\u0026lt;/span\u0026gt;;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;else\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;false\u0026lt;/span\u0026gt;;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;This function will return the file extension which is used later in an error message.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;string \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;getExtension\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(string filename)\u0026lt;/span\u0026gt;\n\u0026lt;/span\u0026gt;{\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; period = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;;\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt; (\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;unsigned\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; i = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;; i \u0026amp;lt; filename.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;length\u0026lt;/span\u0026gt;(); i++)\n{\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (filename[i] == \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;.\u0026apos;\u0026lt;/span\u0026gt;)\n        period = i;\n}\n\nstring extension;\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (period != \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;)\n{\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt; (\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;unsigned\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; i = period; i \u0026amp;lt; filename.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;length\u0026lt;/span\u0026gt;(); i++)\n        extension += filename[i];\n}\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;else\u0026lt;/span\u0026gt;\n    extension = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;NO FILE\u0026quot;\u0026lt;/span\u0026gt;;\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; extension;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;This function will actually call the error checks created above and then parse through the file.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;parseFile\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(string fileName)\u0026lt;/span\u0026gt;\n\u0026lt;/span\u0026gt;{\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;fileExists\u0026lt;/span\u0026gt;(fileName) \u0026amp;amp;\u0026amp;amp; \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;verifyExtension\u0026lt;/span\u0026gt;(fileName))\n    {\n        ifstream fs;\n        fs.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;open\u0026lt;/span\u0026gt;(fileName.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;c_str\u0026lt;/span\u0026gt;());\n        string fileCommand;\n\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;while\u0026lt;/span\u0026gt; (fs.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;good\u0026lt;/span\u0026gt;())\n        {\n            string temp;\n\n            \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;getline\u0026lt;/span\u0026gt;(fs, fileCommand, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;\\n\u0026apos;\u0026lt;/span\u0026gt;);\n\n            \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt; (\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;unsigned\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; i = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;; i \u0026amp;lt; fileCommand.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;length\u0026lt;/span\u0026gt;(); i++)\n            {\n                \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (fileCommand[i] != \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;,\u0026apos;\u0026lt;/span\u0026gt;)\n                    temp += fileCommand[i];\n                \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;else\u0026lt;/span\u0026gt;\n                    temp += \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot; \u0026quot;\u0026lt;/span\u0026gt;;\n            }\n\n            \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (temp != \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;\\0\u0026quot;\u0026lt;/span\u0026gt;)\n            {\n                \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Place your code here to run the file.\u0026lt;/span\u0026gt;\n            }\n        }\n        fs.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;close\u0026lt;/span\u0026gt;();\n    }\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;else\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (!\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;fileExists\u0026lt;/span\u0026gt;(fileName))\n    {\n        cout \u0026amp;lt;\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Error: The provided file does not exist: \u0026quot;\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026amp;lt; fileName \u0026amp;lt;\u0026amp;lt; endl;\n\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (!\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;verifyExtension\u0026lt;/span\u0026gt;(fileName))\n        {\n            \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;getExtension\u0026lt;/span\u0026gt;(fileName) != \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;NO FILE\u0026quot;\u0026lt;/span\u0026gt;)\n                cout \u0026amp;lt;\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;\\tCheck the file extension.\u0026quot;\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026amp;lt; endl;\n            \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;else\u0026lt;/span\u0026gt;\n                cout \u0026amp;lt;\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;\\tThere is no file in the provided path.\u0026quot;\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026amp;lt; endl;\n        }\n    }\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;else\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (!\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;verifyExtension\u0026lt;/span\u0026gt;(fileName)) \n    {\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;getExtension\u0026lt;/span\u0026gt;(fileName) != \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;NO FILE\u0026quot;\u0026lt;/span\u0026gt;)\n            cout \u0026amp;lt;\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Incorrect file extension provided: \u0026quot;\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;getExtension\u0026lt;/span\u0026gt;(fileName) \u0026amp;lt;\u0026amp;lt; endl;\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;else\u0026lt;/span\u0026gt;\n            cout \u0026amp;lt;\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;There is no file in the following path: \u0026quot;\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026amp;lt; fileName \u0026amp;lt;\u0026amp;lt; endl;\n    }\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Since i\u0026apos;m not used to boost right now, I will suggest a more simple solution. Lets suppose that your .csv file has 100 lines with 10 numbers in each line separated by a \u0026apos;,\u0026apos;. You could load this data in the form of an array with the following code:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;iostream\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;fstream\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;sstream\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;string\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;using\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;namespace\u0026lt;/span\u0026gt; std;\n\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;main\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt;\n\u0026lt;/span\u0026gt;{\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; A[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;100\u0026lt;/span\u0026gt;][\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;10\u0026lt;/span\u0026gt;];\n    ifstream ifs;\n    ifs.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;open\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;name_of_file.csv\u0026quot;\u0026lt;/span\u0026gt;);\n    string s1;\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; c;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; k=\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;; k\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;100\u0026lt;/span\u0026gt;; k++)\n    {\n        \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;getline\u0026lt;/span\u0026gt;(ifs,s1);\n        \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;stringstream \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;stream\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(s1)\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;;\n        \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; j=\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;;\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;while\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;)\n        {\n            stream \u0026amp;gt;\u0026amp;gt;A[k][j];\n            stream \u0026amp;gt;\u0026amp;gt; c;\n            j++;\n            \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt;(!stream) {\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;break\u0026lt;/span\u0026gt;;}\n        }\n    }\n\n\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;You can use this library:\n\u0026lt;a href=\u0026quot;https://github.com/vadamsky/csvworker\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;https://github.com/vadamsky/csvworker\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Code for example:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;iostream\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;csvworker.h\u0026quot;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;using\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;namespace\u0026lt;/span\u0026gt; std;\n\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;main\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt;\n\u0026lt;/span\u0026gt;{\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//\u0026lt;/span\u0026gt;\n    CsvWorker csv;\n    csv.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;loadFromFile\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;example.csv\u0026quot;\u0026lt;/span\u0026gt;);\n    cout \u0026amp;lt;\u0026amp;lt; csv.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;getRowsNumber\u0026lt;/span\u0026gt;() \u0026amp;lt;\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;  \u0026quot;\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026amp;lt; csv.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;getColumnsNumber\u0026lt;/span\u0026gt;() \u0026amp;lt;\u0026amp;lt; endl;\n\n    csv.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;getFieldRef\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;) = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;0\u0026quot;\u0026lt;/span\u0026gt;;\n    csv.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;getFieldRef\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;) = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;0\u0026quot;\u0026lt;/span\u0026gt;;\n    csv.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;getFieldRef\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3\u0026lt;/span\u0026gt;) = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;0\u0026quot;\u0026lt;/span\u0026gt;;\n    csv.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;getFieldRef\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;) = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;0\u0026quot;\u0026lt;/span\u0026gt;;\n    csv.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;getFieldRef\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;4\u0026lt;/span\u0026gt;) = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;0\u0026quot;\u0026lt;/span\u0026gt;;\n    csv.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;getFieldRef\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;) = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;0\u0026quot;\u0026lt;/span\u0026gt;;\n    csv.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;getFieldRef\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3\u0026lt;/span\u0026gt;) = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;0\u0026quot;\u0026lt;/span\u0026gt;;\n    csv.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;getFieldRef\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;4\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;) = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;0\u0026quot;\u0026lt;/span\u0026gt;;\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;unsigned\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; i=\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;;i\u0026amp;lt;csv.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;getRowsNumber\u0026lt;/span\u0026gt;();++i)\n    {\n        \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//cout \u0026amp;lt;\u0026amp;lt; csv.getRow(i) \u0026amp;lt;\u0026amp;lt; endl;\u0026lt;/span\u0026gt;\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;unsigned\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; j=\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;;j\u0026amp;lt;csv.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;getColumnsNumber\u0026lt;/span\u0026gt;();++j)\n        {\n            cout \u0026amp;lt;\u0026amp;lt; csv.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;getField\u0026lt;/span\u0026gt;(i, j) \u0026amp;lt;\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;.\u0026quot;\u0026lt;/span\u0026gt;;\n        }\n        cout \u0026amp;lt;\u0026amp;lt; endl;\n    }\n\n    csv.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;saveToFile\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;test.csv\u0026quot;\u0026lt;/span\u0026gt;);\n\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;CsvWorker \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;csv2\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;4\u0026lt;/span\u0026gt;,\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;4\u0026lt;/span\u0026gt;)\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;;\n\n    csv2.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;getFieldRef\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;) = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;a\u0026quot;\u0026lt;/span\u0026gt;;\n    csv2.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;getFieldRef\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;) = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;b\u0026quot;\u0026lt;/span\u0026gt;;\n    csv2.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;getFieldRef\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;) = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;r\u0026quot;\u0026lt;/span\u0026gt;;\n    csv2.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;getFieldRef\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3\u0026lt;/span\u0026gt;) = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;a\u0026quot;\u0026lt;/span\u0026gt;;\n    csv2.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;getFieldRef\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;) = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;c\u0026quot;\u0026lt;/span\u0026gt;;\n    csv2.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;getFieldRef\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;) = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;a\u0026quot;\u0026lt;/span\u0026gt;;\n    csv2.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;getFieldRef\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;) = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;d\u0026quot;\u0026lt;/span\u0026gt;;\n    csv2.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;getFieldRef\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;) = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;a\u0026quot;\u0026lt;/span\u0026gt;;\n    csv2.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;getFieldRef\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;) = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;b\u0026quot;\u0026lt;/span\u0026gt;;\n    csv2.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;getFieldRef\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;) = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;r\u0026quot;\u0026lt;/span\u0026gt;;\n    csv2.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;getFieldRef\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3\u0026lt;/span\u0026gt;) = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;a\u0026quot;\u0026lt;/span\u0026gt;;\n\n    csv2.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;saveToFile\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;test2.csv\u0026quot;\u0026lt;/span\u0026gt;);\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;You gotta feel proud when you use something so beautiful as \u0026lt;code\u0026gt;boost::spirit\u0026lt;/code\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Here my attempt of a parser (almost) complying with the CSV specifications on this link \u0026lt;a href=\u0026quot;http://www.ietf.org/rfc/rfc4180.txt\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;CSV specs\u0026lt;/a\u0026gt; (I didn\u0026apos;t need line breaks within fields. Also the spaces around the commas are dismissed).\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;After you overcome the shocking experience of waiting 10 seconds for compiling this code :), you can sit back and enjoy.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// csvparser.cpp\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;boost/spirit/include/qi.hpp\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;boost/spirit/include/phoenix_operator.hpp\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;iostream\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;string\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;namespace\u0026lt;/span\u0026gt; qi = boost::spirit::qi;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;namespace\u0026lt;/span\u0026gt; bascii = boost::spirit::ascii;\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; Iterator\u0026amp;gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;csv_parser\u0026lt;/span\u0026gt; : qi::grammar\u0026amp;lt;Iterator, std::\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;vector\u0026lt;/span\u0026gt;\u0026amp;lt;std::string\u0026amp;gt;(), \n    bascii::space_type\u0026amp;gt;\n{\n    qi::rule\u0026amp;lt;Iterator, \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt;()                                           \u0026amp;gt; COMMA;\n    qi::rule\u0026amp;lt;Iterator, \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt;()                                           \u0026amp;gt; DDQUOTE;\n    qi::rule\u0026amp;lt;Iterator, std::\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;string\u0026lt;/span\u0026gt;(),               bascii::space_type  \u0026amp;gt; non_escaped;\n    qi::rule\u0026amp;lt;Iterator, std::\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;string\u0026lt;/span\u0026gt;(),               bascii::space_type  \u0026amp;gt; escaped;\n    qi::rule\u0026amp;lt;Iterator, std::\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;string\u0026lt;/span\u0026gt;(),               bascii::space_type  \u0026amp;gt; field;\n    qi::rule\u0026amp;lt;Iterator, std::\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;vector\u0026lt;/span\u0026gt;\u0026amp;lt;std::string\u0026amp;gt;(),  bascii::space_type  \u0026amp;gt; start;\n\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;csv_parser\u0026lt;/span\u0026gt;() : csv_parser::\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;base_type\u0026lt;/span\u0026gt;(start)\n    {\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;using\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;namespace\u0026lt;/span\u0026gt; qi;\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;using\u0026lt;/span\u0026gt; qi::lit;\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;using\u0026lt;/span\u0026gt; qi::lexeme;\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;using\u0026lt;/span\u0026gt; bascii::char_;\n\n        start       = field % \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;,\u0026apos;\u0026lt;/span\u0026gt;;\n        field       = escaped | non_escaped;\n        escaped     = lexeme[\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;\u0026quot;\u0026apos;\u0026lt;/span\u0026gt; \u0026amp;gt;\u0026amp;gt; *( char_ -(\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;char_\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;\u0026quot;\u0026apos;\u0026lt;/span\u0026gt;) | \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;,\u0026apos;\u0026lt;/span\u0026gt;) | COMMA | DDQUOTE)  \u0026amp;gt;\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;\u0026quot;\u0026apos;\u0026lt;/span\u0026gt;];\n        non_escaped = lexeme[       *( char_ -(\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;char_\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;\u0026quot;\u0026apos;\u0026lt;/span\u0026gt;) | \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;,\u0026apos;\u0026lt;/span\u0026gt;)                  )        ];\n        DDQUOTE     = \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;lit\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;\\\u0026quot;\\\u0026quot;\u0026quot;\u0026lt;/span\u0026gt;)       [_val = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;\u0026quot;\u0026apos;\u0026lt;/span\u0026gt;];\n        COMMA       = \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;lit\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;,\u0026quot;\u0026lt;/span\u0026gt;)          [_val = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;,\u0026apos;\u0026lt;/span\u0026gt;];\n    }\n\n};\n\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;main\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt;\n\u0026lt;/span\u0026gt;{\n    std::cout \u0026amp;lt;\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Enter CSV lines [empty] to quit\\n\u0026quot;\u0026lt;/span\u0026gt;;\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;using\u0026lt;/span\u0026gt; bascii::space;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typedef\u0026lt;/span\u0026gt; std::string::const_iterator iterator_type;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typedef\u0026lt;/span\u0026gt; csv_parser\u0026amp;lt;iterator_type\u0026amp;gt; csv_parser;\n\n    csv_parser grammar;\n    std::string str;\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; fid;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;while\u0026lt;/span\u0026gt; (\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;getline\u0026lt;/span\u0026gt;(std::cin, str))\n    {\n        fid = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;;\n\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (str.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;empty\u0026lt;/span\u0026gt;())\n            \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;break\u0026lt;/span\u0026gt;;\n\n        std::vector\u0026amp;lt;std::string\u0026amp;gt; csv;\n        std::string::const_iterator it_beg = str.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;begin\u0026lt;/span\u0026gt;();\n        std::string::const_iterator it_end = str.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;end\u0026lt;/span\u0026gt;();\n        \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;bool\u0026lt;/span\u0026gt; r = \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;phrase_parse\u0026lt;/span\u0026gt;(it_beg, it_end, grammar, space, csv);\n\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (r \u0026amp;amp;\u0026amp;amp; it_beg == it_end)\n        {\n            std::cout \u0026amp;lt;\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Parsing succeeded\\n\u0026quot;\u0026lt;/span\u0026gt;;\n            \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt; (\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;auto\u0026lt;/span\u0026gt;\u0026amp;amp; field: csv)\n            {\n                std::cout \u0026amp;lt;\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;field \u0026quot;\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026amp;lt; ++fid \u0026amp;lt;\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;: \u0026quot;\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026amp;lt; field \u0026amp;lt;\u0026amp;lt; std::endl;\n            }\n        }\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;else\u0026lt;/span\u0026gt;\n        {\n            std::cout \u0026amp;lt;\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Parsing failed\\n\u0026quot;\u0026lt;/span\u0026gt;;\n        }\n    }\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Compile:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;make csvparser\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Test (example stolen from \u0026lt;a href=\u0026quot;https://en.wikipedia.org/wiki/Comma-separated_values#Example\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;Wikipedia\u0026lt;/a\u0026gt;):\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-none s-code-block\u0026quot;\u0026gt;\u0026lt;code\u0026gt;./csvparser\nEnter CSV lines [empty] to quit\n\n1999,Chevy,\u0026quot;Venture \u0026quot;\u0026quot;Extended Edition, Very Large\u0026quot;\u0026quot;\u0026quot;,,5000.00\nParsing succeeded\nfield 1: 1999\nfield 2: Chevy\nfield 3: Venture \u0026quot;Extended Edition, Very Large\u0026quot;\nfield 4: \nfield 5: 5000.00\n\n1999,Chevy,\u0026quot;Venture \u0026quot;\u0026quot;Extended Edition, Very Large\u0026quot;\u0026quot;\u0026quot;,,5000.00\u0026quot;\nParsing failed\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;This solution detects these 4 cases\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;complete class is at\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;a href=\u0026quot;https://github.com/pedro-vicente/csv-parser\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;https://github.com/pedro-vicente/csv-parser\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;,field \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;,field \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3\u0026lt;/span\u0026gt;,\n\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;,field \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;,\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;field 3 quoted, with separator\u0026quot;\u0026lt;/span\u0026gt;,\n\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;,field \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;,\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;field 3\nwith newline\u0026quot;\u0026lt;/span\u0026gt;,\n\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;,field \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;,\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;field 3\nwith newline and separator,\u0026quot;\u0026lt;/span\u0026gt;,\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;It reads the file character by character, and reads 1 row at a time to a vector (of strings), therefore suitable for very large files.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Usage is\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Iterate until an empty row is returned (end of file). A row is a vector where each entry is a CSV column.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;read_csv_t\u0026lt;/span\u0026gt; csv;\ncsv.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;open\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;../test.csv\u0026quot;\u0026lt;/span\u0026gt;);\nstd::vector\u0026amp;lt;std::string\u0026amp;gt; row;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;while\u0026lt;/span\u0026gt; (\u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;true\u0026lt;/span\u0026gt;)\n{\n  row = csv.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;read_row\u0026lt;/span\u0026gt;();\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (row.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;size\u0026lt;/span\u0026gt;() == \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;)\n  {\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;break\u0026lt;/span\u0026gt;;\n  }\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;the class declaration\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;read_csv_t\u0026lt;/span\u0026gt;\n{\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt;:\n  \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;read_csv_t\u0026lt;/span\u0026gt;();\n  \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;open\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; std::string \u0026amp;amp;file_name)\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;;\n  \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;std::vector\u0026amp;lt;std::string\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;read_row\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;private\u0026lt;/span\u0026gt;:\n  std::ifstream m_ifs;\n};\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;the implementation\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;std::vector\u0026amp;lt;std::string\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;read_csv_t::read_row\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt;\n\u0026lt;/span\u0026gt;{\n  \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;bool\u0026lt;/span\u0026gt; quote_mode = \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;false\u0026lt;/span\u0026gt;;\n  std::vector\u0026amp;lt;std::string\u0026amp;gt; row;\n  std::string column;\n  \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; c;\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;while\u0026lt;/span\u0026gt; (m_ifs.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;get\u0026lt;/span\u0026gt;(c))\n  {\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;switch\u0026lt;/span\u0026gt; (c)\n    {\n      \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;/////////////////////////////////////////////////////////////////////////////////////////////////////\u0026lt;/span\u0026gt;\n      \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//separator \u0026apos;,\u0026apos; detected. \u0026lt;/span\u0026gt;\n      \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//in quote mode add character to column\u0026lt;/span\u0026gt;\n      \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//push column if not in quote mode\u0026lt;/span\u0026gt;\n      \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;/////////////////////////////////////////////////////////////////////////////////////////////////////\u0026lt;/span\u0026gt;\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;case\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;,\u0026apos;\u0026lt;/span\u0026gt;:\n      \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (quote_mode == \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;true\u0026lt;/span\u0026gt;)\n      {\n        column += c;\n      }\n      \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;else\u0026lt;/span\u0026gt;\n      {\n        row.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;push_back\u0026lt;/span\u0026gt;(column);\n        column.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;clear\u0026lt;/span\u0026gt;();\n      }\n      \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;break\u0026lt;/span\u0026gt;;\n\n      \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;/////////////////////////////////////////////////////////////////////////////////////////////////////\u0026lt;/span\u0026gt;\n      \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//quote \u0026apos;\u0026quot;\u0026apos; detected. \u0026lt;/span\u0026gt;\n      \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//toggle quote mode\u0026lt;/span\u0026gt;\n      \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;/////////////////////////////////////////////////////////////////////////////////////////////////////\u0026lt;/span\u0026gt;\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;case\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;\u0026quot;\u0026apos;\u0026lt;/span\u0026gt;:\n      quote_mode = !quote_mode;\n      \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;break\u0026lt;/span\u0026gt;;\n\n      \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;/////////////////////////////////////////////////////////////////////////////////////////////////////\u0026lt;/span\u0026gt;\n      \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//line end detected\u0026lt;/span\u0026gt;\n      \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//in quote mode add character to column\u0026lt;/span\u0026gt;\n      \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//return row if not in quote mode\u0026lt;/span\u0026gt;\n      \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;/////////////////////////////////////////////////////////////////////////////////////////////////////\u0026lt;/span\u0026gt;\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;case\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;\\n\u0026apos;\u0026lt;/span\u0026gt;:\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;case\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;\\r\u0026apos;\u0026lt;/span\u0026gt;:\n      \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (quote_mode == \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;true\u0026lt;/span\u0026gt;)\n      {\n        column += c;\n      }\n      \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;else\u0026lt;/span\u0026gt;\n      {\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; row;\n      }\n      \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;break\u0026lt;/span\u0026gt;;\n\n      \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;/////////////////////////////////////////////////////////////////////////////////////////////////////\u0026lt;/span\u0026gt;\n      \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//default, add character to column\u0026lt;/span\u0026gt;\n      \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;/////////////////////////////////////////////////////////////////////////////////////////////////////\u0026lt;/span\u0026gt;\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;default\u0026lt;/span\u0026gt;:\n      column += c;\n      \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;break\u0026lt;/span\u0026gt;;\n    }\n  }\n\n  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//return empty vector if end of file detected \u0026lt;/span\u0026gt;\n  m_ifs.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;close\u0026lt;/span\u0026gt;();\n  std::vector\u0026amp;lt;std::string\u0026amp;gt; v;\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; v;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;\u0026lt;em\u0026gt;Parsing CSV file lines with Stream\u0026lt;/em\u0026gt;\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;I wrote a small example of parsing CSV file lines, it can be developed with for and while loops if desired:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;iostream\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;fstream\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;string.h\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;using\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;namespace\u0026lt;/span\u0026gt; std;\n\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;main\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt; \u0026lt;/span\u0026gt;{\n\n\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;ifstream \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;fin\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Infile.csv\u0026quot;\u0026lt;/span\u0026gt;)\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;;\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;ofstream \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;fout\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;OutFile.csv\u0026quot;\u0026lt;/span\u0026gt;)\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;;\nstring strline, strremain, strCol1 , strout;\n\nstring delimeter =\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;;\u0026quot;\u0026lt;/span\u0026gt;;\n\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; d1;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;to continue until the end of the file:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;while\u0026lt;/span\u0026gt; (!fin.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;eof\u0026lt;/span\u0026gt;()){ \n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;get first line from InFile :\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;getline\u0026lt;/span\u0026gt;(fin,strline,\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;\\n\u0026apos;\u0026lt;/span\u0026gt;);      \n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;find delimeter position in line:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;    d1 = strline.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;find\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;;\u0026apos;\u0026lt;/span\u0026gt;);\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;and parse first column:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;    strCol1 = strline.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;substr\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;,d1); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// parse first Column\u0026lt;/span\u0026gt;\n    d1++;\n    strremain = strline.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;substr\u0026lt;/span\u0026gt;(d1); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// remaining line\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;create output line in CSV format:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;    strout.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;append\u0026lt;/span\u0026gt;(strCol1);\n    strout.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;append\u0026lt;/span\u0026gt;(delimeter);\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;write line to Out File:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;    fout \u0026amp;lt;\u0026amp;lt; strout \u0026amp;lt;\u0026amp;lt; endl; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//out file line\u0026lt;/span\u0026gt;\n\n} \n\nfin.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;close\u0026lt;/span\u0026gt;();\nfout.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;close\u0026lt;/span\u0026gt;();\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;);\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;This code is compiled and running. Good luck!\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;You could also take a look at capabilities of \u0026lt;code\u0026gt;Qt\u0026lt;/code\u0026gt; library.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;It has regular expressions support and QString class has nice methods, e.g. \u0026lt;code\u0026gt;split()\u0026lt;/code\u0026gt; returning QStringList, list of strings obtained by splitting the original string with a provided delimiter. Should suffice for csv file.. \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;To get a column with a given header name I use following: \u0026lt;a href=\u0026quot;https://stackoverflow.com/questions/970330/c-inheritance-qt-problem-qstring/1011601#1011601\u0026quot;\u0026gt;c++ inheritance Qt problem qstring\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;If you don\u0026apos;t want to deal with including boost in your project (it is considerably large if all you are going to use it for is CSV parsing...)\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;I have had luck with the CSV parsing here:\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;a href=\u0026quot;http://www.zedwood.com/article/112/cpp-csv-parser\u0026quot; rel=\u0026quot;nofollow\u0026quot;\u0026gt;http://www.zedwood.com/article/112/cpp-csv-parser\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;It handles quoted fields - but does not handle inline \\n characters (which is probably fine for most uses).\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;For what it is worth, here is my implementation. It deals with wstring input, but could be adjusted to string easily. It does not handle newline in fields (as my application does not either, but adding its support isn\u0026apos;t too difficult) and it does not comply with \u0026quot;\\r\\n\u0026quot; end of line as per RFC (assuming you use std::getline), but it does handle whitespace trimming and double-quotes correctly (hopefully).\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;using\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;namespace\u0026lt;/span\u0026gt; std;\n\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// trim whitespaces around field or double-quotes, remove double-quotes and replace escaped double-quotes (double double-quotes)\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;wstring \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;trimquote\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; wstring\u0026amp;amp; str, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; wstring\u0026amp;amp; whitespace, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;wchar_t\u0026lt;/span\u0026gt; quotChar)\u0026lt;/span\u0026gt;\n\u0026lt;/span\u0026gt;{\n    wstring ws;\n    wstring::size_type strBegin = str.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;find_first_not_of\u0026lt;/span\u0026gt;(whitespace);\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (strBegin == wstring::npos)\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;L\u0026quot;\u0026quot;\u0026lt;/span\u0026gt;;\n\n    wstring::size_type strEnd = str.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;find_last_not_of\u0026lt;/span\u0026gt;(whitespace);\n    wstring::size_type strRange = strEnd - strBegin + \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;;\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt;((str[strBegin] == quotChar) \u0026amp;amp;\u0026amp;amp; (str[strEnd] == quotChar))\n    {\n        ws = str.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;substr\u0026lt;/span\u0026gt;(strBegin+\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;, strRange\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;-2\u0026lt;/span\u0026gt;);\n        strBegin = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;;\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;while\u0026lt;/span\u0026gt;((strEnd = ws.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;find\u0026lt;/span\u0026gt;(quotChar, strBegin)) != wstring::npos)\n        {\n            ws.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;erase\u0026lt;/span\u0026gt;(strEnd, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;);\n            strBegin = strEnd+\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;;\n        }\n\n    }\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;else\u0026lt;/span\u0026gt;\n        ws = str.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;substr\u0026lt;/span\u0026gt;(strBegin, strRange);\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; ws;\n}\n\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;pair\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;unsigned\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;unsigned\u0026lt;/span\u0026gt;\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;nextCSVQuotePair\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; wstring\u0026amp;amp; line, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;wchar_t\u0026lt;/span\u0026gt; quotChar, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;unsigned\u0026lt;/span\u0026gt; ofs = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;)\u0026lt;/span\u0026gt;\n\u0026lt;/span\u0026gt;{\n    pair\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;unsigned\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;unsigned\u0026lt;/span\u0026gt;\u0026amp;gt; r;\n    r.first = line.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;find\u0026lt;/span\u0026gt;(quotChar, ofs);\n    r.second = wstring::npos;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt;(r.first != wstring::npos)\n    {\n        r.second = r.first;\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;while\u0026lt;/span\u0026gt;(((r.second = line.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;find\u0026lt;/span\u0026gt;(quotChar, r.second+\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;)) != wstring::npos)\n            \u0026amp;amp;\u0026amp;amp; (line[r.second+\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;] == quotChar)) \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// WARNING: assumes null-terminated string such that line[r.second+1] always exist\u0026lt;/span\u0026gt;\n            r.second++;\n\n    }\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; r;\n}\n\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;unsigned\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;parseLine\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(vector\u0026amp;lt;wstring\u0026amp;gt;\u0026amp;amp; fields, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; wstring\u0026amp;amp; line)\u0026lt;/span\u0026gt;\n\u0026lt;/span\u0026gt;{\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;unsigned\u0026lt;/span\u0026gt; ofs, ofs0, np;\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;wchar_t\u0026lt;/span\u0026gt; delim = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;L\u0026apos;,\u0026apos;\u0026lt;/span\u0026gt;;\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; wstring whitespace = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;L\u0026quot; \\t\\xa0\\x3000\\x2000\\x2001\\x2002\\x2003\\x2004\\x2005\\x2006\\x2007\\x2008\\x2009\\x200a\\x202f\\x205f\u0026quot;\u0026lt;/span\u0026gt;;\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;wchar_t\u0026lt;/span\u0026gt; quotChar = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;L\u0026apos;\\\u0026quot;\u0026apos;\u0026lt;/span\u0026gt;;\n    pair\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;unsigned\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;unsigned\u0026lt;/span\u0026gt;\u0026amp;gt; quot;\n\n    fields.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;clear\u0026lt;/span\u0026gt;();\n\n    ofs = ofs0 = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;;\n    quot = \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;nextCSVQuotePair\u0026lt;/span\u0026gt;(line, quotChar);\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;while\u0026lt;/span\u0026gt;((np = line.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;find\u0026lt;/span\u0026gt;(delim, ofs)) != wstring::npos)\n    {\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt;((np \u0026amp;gt; quot.first) \u0026amp;amp;\u0026amp;amp; (np \u0026amp;lt; quot.second))\n        { \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// skip delimiter inside quoted field\u0026lt;/span\u0026gt;\n            ofs = quot.second+\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;;\n            quot = \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;nextCSVQuotePair\u0026lt;/span\u0026gt;(line, quotChar, ofs);\n            \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;continue\u0026lt;/span\u0026gt;;\n        }\n        fields.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;push_back\u0026lt;/span\u0026gt;( \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;trimquote\u0026lt;/span\u0026gt;(line.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;substr\u0026lt;/span\u0026gt;(ofs0, np-ofs0), whitespace, quotChar) );\n        ofs = ofs0 = np+\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;;\n    }\n    fields.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;push_back\u0026lt;/span\u0026gt;( \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;trimquote\u0026lt;/span\u0026gt;(line.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;substr\u0026lt;/span\u0026gt;(ofs0), whitespace, quotChar) );\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; fields.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;size\u0026lt;/span\u0026gt;();\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Here is a ready-to use function if all you need is to load a data file of doubles (no integers, no text).\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;sstream\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;fstream\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;iterator\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;string\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;vector\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;algorithm\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;using\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;namespace\u0026lt;/span\u0026gt; std;\n\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;/**\n * Parse a CSV data file and fill the 2d STL vector \u0026quot;data\u0026quot;.\n * Limits: only \u0026quot;pure datas\u0026quot; of doubles, not encapsulated by \u0026quot; and without \\n inside.\n * Further no formatting in the data (e.g. scientific notation)\n * It however handles both dots and commas as decimal separators and removes thousand separator.\n * \n * returnCodes[0]: file access 0-\u0026amp;gt; ok 1-\u0026amp;gt; not able to read; 2-\u0026amp;gt; decimal separator equal to comma separator\n * returnCodes[1]: number of records\n * returnCodes[2]: number of fields. -1 If rows have different field size\n * \n */\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;vector\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;\u0026amp;gt;\n\u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;readCsvData\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(vector \u0026amp;lt;vector \u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;double\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026amp;amp; data, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; string\u0026amp;amp; filename, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; string\u0026amp;amp; delimiter, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; string\u0026amp;amp; decseparator)\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;{\n\n \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; vv[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3\u0026lt;/span\u0026gt;] = { \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;,\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;,\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt; };\n \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;vector\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;returnCodes\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026amp;amp;vv[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;], \u0026amp;amp;vv[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;]+\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3\u0026lt;/span\u0026gt;)\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;;\n\n string rowstring, stringtoken;\n \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;double\u0026lt;/span\u0026gt; doubletoken;\n \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; rowcount=\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;;\n \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; fieldcount=\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;;\n data.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;clear\u0026lt;/span\u0026gt;();\n\n \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;ifstream \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;iFile\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(filename, ios_base::in)\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;;\n \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (!iFile.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;is_open\u0026lt;/span\u0026gt;()){\n   returnCodes[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;] = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;;\n   \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; returnCodes;\n }\n \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;while\u0026lt;/span\u0026gt; (\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;getline\u0026lt;/span\u0026gt;(iFile, rowstring)) {\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (rowstring==\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;\u0026quot;\u0026lt;/span\u0026gt;) \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;continue\u0026lt;/span\u0026gt;; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// empty line\u0026lt;/span\u0026gt;\n    rowcount ++; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//let\u0026apos;s start with 1\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt;(delimiter == decseparator){\n      returnCodes[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;] = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;;\n      \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; returnCodes;\n    }\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt;(decseparator != \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;.\u0026quot;\u0026lt;/span\u0026gt;){\n     \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// remove dots (used as thousand separators)\u0026lt;/span\u0026gt;\n     string::iterator end_pos = \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;remove\u0026lt;/span\u0026gt;(rowstring.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;begin\u0026lt;/span\u0026gt;(), rowstring.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;end\u0026lt;/span\u0026gt;(), \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;.\u0026apos;\u0026lt;/span\u0026gt;);\n     rowstring.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;erase\u0026lt;/span\u0026gt;(end_pos, rowstring.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;end\u0026lt;/span\u0026gt;());\n     \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// replace decimal separator with dots.\u0026lt;/span\u0026gt;\n     \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;replace\u0026lt;/span\u0026gt;(rowstring.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;begin\u0026lt;/span\u0026gt;(), rowstring.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;end\u0026lt;/span\u0026gt;(),decseparator.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;c_str\u0026lt;/span\u0026gt;()[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;], \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;.\u0026apos;\u0026lt;/span\u0026gt;); \n    } \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;else\u0026lt;/span\u0026gt; {\n     \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// remove commas (used as thousand separators)\u0026lt;/span\u0026gt;\n     string::iterator end_pos = \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;remove\u0026lt;/span\u0026gt;(rowstring.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;begin\u0026lt;/span\u0026gt;(), rowstring.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;end\u0026lt;/span\u0026gt;(), \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;,\u0026apos;\u0026lt;/span\u0026gt;);\n     rowstring.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;erase\u0026lt;/span\u0026gt;(end_pos, rowstring.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;end\u0026lt;/span\u0026gt;());\n    }\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// tokenize..\u0026lt;/span\u0026gt;\n    vector\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;double\u0026lt;/span\u0026gt;\u0026amp;gt; tokens;\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Skip delimiters at beginning.\u0026lt;/span\u0026gt;\n    string::size_type lastPos = rowstring.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;find_first_not_of\u0026lt;/span\u0026gt;(delimiter, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;);\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Find first \u0026quot;non-delimiter\u0026quot;.\u0026lt;/span\u0026gt;\n    string::size_type pos     = rowstring.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;find_first_of\u0026lt;/span\u0026gt;(delimiter, lastPos);\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;while\u0026lt;/span\u0026gt; (string::npos != pos || string::npos != lastPos){\n        \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Found a token, convert it to double add it to the vector.\u0026lt;/span\u0026gt;\n        stringtoken = rowstring.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;substr\u0026lt;/span\u0026gt;(lastPos, pos - lastPos);\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (stringtoken == \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;\u0026quot;\u0026lt;/span\u0026gt;) {\n      tokens.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;push_back\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0.0\u0026lt;/span\u0026gt;);\n    } \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;else\u0026lt;/span\u0026gt; {\n          istringstream \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;totalSString\u0026lt;/span\u0026gt;(stringtoken);\n      totalSString \u0026amp;gt;\u0026amp;gt; doubletoken;\n      tokens.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;push_back\u0026lt;/span\u0026gt;(doubletoken);\n    }     \n        \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Skip delimiters.  Note the \u0026quot;not_of\u0026quot;\u0026lt;/span\u0026gt;\n        lastPos = rowstring.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;find_first_not_of\u0026lt;/span\u0026gt;(delimiter, pos);\n        \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Find next \u0026quot;non-delimiter\u0026quot;\u0026lt;/span\u0026gt;\n        pos = rowstring.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;find_first_of\u0026lt;/span\u0026gt;(delimiter, lastPos);\n    }\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt;(rowcount == \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;){\n      fieldcount = tokens.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;size\u0026lt;/span\u0026gt;();\n      returnCodes[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;] = tokens.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;size\u0026lt;/span\u0026gt;();\n    } \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;else\u0026lt;/span\u0026gt; {\n      \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; ( tokens.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;size\u0026lt;/span\u0026gt;() != fieldcount){\n    returnCodes[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;] = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;-1\u0026lt;/span\u0026gt;;\n      }\n    }\n    data.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;push_back\u0026lt;/span\u0026gt;(tokens);\n }\n iFile.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;close\u0026lt;/span\u0026gt;();\n returnCodes[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;] = rowcount;\n \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; returnCodes;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    "],"id":402,"title":"How can I read and parse CSV files in C++?","content":"\n                \n\u0026lt;p\u0026gt;I need to load and use CSV file data in C++.  At this point it can really just be a comma-delimited parser (ie don\u0026apos;t worry about escaping new lines and commas).  The main need is a line-by-line parser that will return a vector for the next line each time the method is called.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;I found this article which looks quite promising:\n\u0026lt;a href=\u0026quot;http://www.boost.org/doc/libs/1_35_0/libs/spirit/example/fundamental/list_parser.cpp\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;http://www.boost.org/doc/libs/1_35_0/libs/spirit/example/fundamental/list_parser.cpp\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;I\u0026apos;ve never used Boost\u0026apos;s Spirit, but am willing to try it. But only if there isn\u0026apos;t a more straightforward solution I\u0026apos;m overlooking.\u0026lt;/p\u0026gt;\n    ","slug":"how-can-i-read-and-parse-csv-files-in-c++-1657387869219","postType":"QUESTION","createdAt":"2022-07-09T17:31:09.000Z","updatedAt":"2022-07-09T17:31:09.000Z","tags":[{"id":2159,"name":"text","slug":"text","createdAt":"2022-07-09T17:31:09.000Z","updatedAt":"2022-07-09T17:31:09.000Z","Questions_Tags":{"questionId":402,"tagId":2159}},{"id":2160,"name":"csv","slug":"csv","createdAt":"2022-07-09T17:31:09.000Z","updatedAt":"2022-07-09T17:31:09.000Z","Questions_Tags":{"questionId":402,"tagId":2160}}],"relatedQuestions":[{"title":"How can I read and parse CSV files in C++?","slug":"how-can-i-read-and-parse-csv-files-in-c++-1657387869219","tags":[{"name":"text","Questions_Tags":{"questionId":402,"tagId":2159}},{"name":"csv","Questions_Tags":{"questionId":402,"tagId":2160}}]}]},"randomQuestions":[{"title":"Deserialize JSON into C# dynamic object?","slug":"deserialize-json-into-c-dynamic-object-1657388568720"},{"title":"Is there a JavaScript / jQuery DOM change listener?","slug":"is-there-a-javascript-jquery-dom-change-listener-1657387961200"},{"title":"Why are floating point numbers inaccurate?","slug":"why-are-floating-point-numbers-inaccurate-1657387346111"},{"title":"What is the difference between single-quoted and double-quoted strings in PHP?","slug":"what-is-the-difference-between-single-quoted-and-double-quoted-strings-in-php-1657384624345"},{"title":"Why aren't variable-length arrays part of the C++ standard?","slug":"why-aren't-variable-length-arrays-part-of-the-c++-standard-1657384712975"},{"title":"PHP parse/syntax errors; and how to solve them","slug":"php-parsesyntax-errors-and-how-to-solve-them-1657384264713"},{"title":"Passing data between view controllers","slug":"passing-data-between-view-controllers-1657384540021"},{"title":"Maintain the aspect ratio of a div with CSS","slug":"maintain-the-aspect-ratio-of-a-div-with-css-1657387513615"},{"title":"What is a StackOverflowError?","slug":"what-is-a-stackoverflowerror-1657388319634"},{"title":"How do I execute a program or call a system command?","slug":"how-do-i-execute-a-program-or-call-a-system-command-1657385465629"},{"title":"How to access the correct `this` inside a callback","slug":"how-to-access-the-correct-this-inside-a-callback-1657384283261"},{"title":"Undefined behavior and sequence points","slug":"undefined-behavior-and-sequence-points-1657384639493"},{"title":"Web-scraping JavaScript page with Python","slug":"web-scraping-javascript-page-with-python-1657388240875"},{"title":"How do I give text or an image a transparent background using CSS?","slug":"how-do-i-give-text-or-an-image-a-transparent-background-using-css-1657388188508"},{"title":"How to use java.util.Scanner to correctly read user input from System.in and act on it?","slug":"how-to-use-java.util.scanner-to-correctly-read-user-input-from-system.in-and-act-on-it-1657388546306"},{"title":"What are copy elision and return value optimization?","slug":"what-are-copy-elision-and-return-value-optimization-1657385455976"},{"title":"How to determine equality for two JavaScript objects?","slug":"how-to-determine-equality-for-two-javascript-objects-1657387638650"},{"title":"What is the \"N+1 selects problem\" in ORM (Object-Relational Mapping)?","slug":"what-is-the-\"n+1-selects-problem\"-in-orm-(object-relational-mapping)-1657388055597"},{"title":"Parsing a string to a date in JavaScript","slug":"parsing-a-string-to-a-date-in-javascript-1657387782497"},{"title":"Why Use Integer Instead of Long?","slug":"why-use-integer-instead-of-long-1657388012352"}]},"__N_SSG":true},"page":"/questions/[slug]","query":{"slug":"how-can-i-read-and-parse-csv-files-in-c++-1657387869219"},"buildId":"xZs8haGjOP63QuDE0kxeX","isFallback":false,"gsp":true,"locale":"en","locales":["en"],"defaultLocale":"en","scriptLoader":[]}</script></body></html>