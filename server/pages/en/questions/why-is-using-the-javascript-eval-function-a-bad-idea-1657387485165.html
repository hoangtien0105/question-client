<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><meta name="twitter:card" content="summary_large_image"/><meta name="twitter:site" content="@solutionschecker.com"/><meta name="twitter:creator" content="@solutionschecker.com"/><meta property="og:url" content="https://solutionschecker.com"/><meta property="og:type" content="website"/><meta property="og:image" content="https://solutionschecker.com/solutions-checker-banner.png"/><meta property="og:image:alt" content="Find solution for coding, HTML, CSS, JAVASCRIPT, MYSQL, PHP, PYTHON,... quickly. - solutionschecker.com"/><script type="application/ld+json">{"@context":"https://schema.org","@type":"Organization","logo":"/logo.svg","url":"https://solutionschecker.com"}</script><title>Why is using the JavaScript eval function a bad idea? | Solutions Checker</title><meta name="robots" content="index,follow"/><meta name="description" content="The eval function is a powerful and easy way to dynamically generate code, so what are the caveats?
    "/><meta property="og:title" content="Why is using the JavaScript eval function a bad idea? | Solutions Checker"/><meta property="og:description" content="The eval function is a powerful and easy way to dynamically generate code, so what are the caveats?
    "/><script type="application/ld+json">{"@context":"https://schema.org","@type":"QAPage","mainEntity":{"name":"Why is using the JavaScript eval function a bad idea?","text":"The eval function is a powerful and easy way to dynamically generate code, so what are the caveats?\n    ","answerCount":25,"upVoteCount":500,"suggestedAnswer":[{"text":"\nImproper use of eval opens up your\ncode for injection attacks\nDebugging can be more challenging\n(no line numbers, etc.)\neval&apos;d code executes slower (no opportunity to compile/cache eval&apos;d code)\n\n\nEdit: As @Jeff Walden points out in comments, #3 is less true today than it was in 2008. However, while some caching of compiled scripts may happen this will only be limited to scripts that are eval&apos;d repeated with no modification. A more likely scenario is that you are eval&apos;ing scripts that have undergone slight modification each time and as such could not be cached. Let&apos;s just say that SOME eval&apos;d code executes more slowly.\n    ","url":"/questions/[slug]#solution1","@type":"Answer","upvoteCount":0},{"text":"eval isn&apos;t always evil. There are times where it&apos;s perfectly appropriate.\n\nHowever, eval is currently and historically massively over-used by people who don&apos;t know what they&apos;re doing. That includes people writing JavaScript tutorials, unfortunately, and in some cases this can indeed have security consequences - or, more often, simple bugs. So the more we can do to throw a question mark over eval, the better. Any time you use eval you need to sanity-check what you&apos;re doing, because chances are you could be doing it a better, safer, cleaner way.\n\nTo give an all-too-typical example, to set the colour of an element with an id stored in the variable &apos;potato&apos;:\n\neval(&apos;document.&apos; + potato + &apos;.style.color = &quot;red&quot;&apos;);\n\n\nIf the authors of the kind of code above had a clue about the basics of how JavaScript objects work, they&apos;d have realised that square brackets can be used instead of literal dot-names, obviating the need for eval:\n\ndocument[potato].style.color = &apos;red&apos;;\n\n\n...which is much easier to read as well as less potentially buggy.\n\n(But then, someone who /really/ knew what they were doing would say:\n\ndocument.getElementById(potato).style.color = &apos;red&apos;;\n\n\nwhich is more reliable than the dodgy old trick of accessing DOM elements straight out of the document object.)\n    ","url":"/questions/[slug]#solution2","@type":"Answer","upvoteCount":0},{"text":"I believe it&apos;s because it can execute any JavaScript function from a string. Using it makes it easier for people to inject rogue code into the application.\n    ","url":"/questions/[slug]#solution3","@type":"Answer","upvoteCount":0},{"text":"Two points come to mind:\n\n\nSecurity (but as long as you generate the string to be evaluated yourself, this might be a non-issue)\nPerformance: until the code to be executed is unknown, it cannot be optimized.  (about javascript and performance, certainly Steve Yegge&apos;s presentation)\n\n    ","url":"/questions/[slug]#solution4","@type":"Answer","upvoteCount":0},{"text":"It&apos;s generally only an issue if you&apos;re passing eval user input.\n    ","url":"/questions/[slug]#solution5","@type":"Answer","upvoteCount":0},{"text":"Passing user input to eval() is a security risk, but also each invocation of eval() creates a new instance of the JavaScript interpreter. This can be a resource hog.\n    ","url":"/questions/[slug]#solution6","@type":"Answer","upvoteCount":0},{"text":"Mainly, it&apos;s a lot harder to maintain and debug. It&apos;s like a goto. You can use it, but it makes it harder to find problems and harder on the people who may need to make changes later.\n    ","url":"/questions/[slug]#solution7","@type":"Answer","upvoteCount":0},{"text":"One thing to keep in mind is that you can often use eval() to execute code in an otherwise restricted environment - social networking sites that block specific JavaScript functions can sometimes be fooled by breaking them up in an eval block -\n\neval(&apos;al&apos; + &apos;er&apos; + &apos;t(\\&apos;&apos; + &apos;hi there!&apos; + &apos;\\&apos;)&apos;);\n\n\nSo if you&apos;re looking to run some JavaScript code where it might not otherwise be allowed (Myspace, I&apos;m looking at you...) then eval() can be a useful trick.\n\nHowever, for all the reasons mentioned above, you shouldn&apos;t use it for your own code, where you have complete control - it&apos;s just not necessary, and better-off relegated to the &apos;tricky JavaScript hacks&apos; shelf.\n    ","url":"/questions/[slug]#solution8","@type":"Answer","upvoteCount":0},{"text":"Unless you let eval() a dynamic content (through cgi or input), it is as safe and solid as all other JavaScript in your page.\n    ","url":"/questions/[slug]#solution9","@type":"Answer","upvoteCount":0},{"text":"Along with the rest of the answers, I don&apos;t think eval statements can have advanced minimization.\n    ","url":"/questions/[slug]#solution10","@type":"Answer","upvoteCount":0},{"text":"It is a possible security risk, it has a different scope of execution, and is quite inefficient, as it creates an entirely new scripting environment for the execution of the code. See here for some more info: eval.\n\nIt is quite useful, though, and used with moderation can add a lot of good functionality.\n    ","url":"/questions/[slug]#solution11","@type":"Answer","upvoteCount":0},{"text":"Unless you are 100% sure that the code being evaluated is from a trusted source (usually your own application) then it&apos;s a surefire way of exposing your system to a cross-site scripting attack.\n    ","url":"/questions/[slug]#solution12","@type":"Answer","upvoteCount":0},{"text":"It&apos;s not necessarily that bad provided you know what context you&apos;re using it in.\n\nIf your application is using eval() to create an object from some JSON which has come back from an XMLHttpRequest to your own site, created by your trusted server-side code, it&apos;s probably not a problem.\n\nUntrusted client-side JavaScript code can&apos;t do that much anyway. Provided the thing you&apos;re executing eval() on has come from a reasonable source, you&apos;re fine.\n    ","url":"/questions/[slug]#solution13","@type":"Answer","upvoteCount":0},{"text":"It greatly reduces your level of confidence about security.\n    ","url":"/questions/[slug]#solution14","@type":"Answer","upvoteCount":0},{"text":"If you want the user to input some logical functions and evaluate for AND the OR then the JavaScript eval function is perfect. I can accept two strings and eval(uate) string1 === string2, etc.\n    ","url":"/questions/[slug]#solution15","@type":"Answer","upvoteCount":0},{"text":"If you spot the use of eval() in your code, remember the mantra eval() is evil. \n\nThis\nfunction takes an arbitrary string and executes it as JavaScript code. When the code in\nquestion is known beforehand (not determined at runtime), theres no reason to use\neval(). \nIf the code is dynamically generated at runtime, theres often a better way to\nachieve the goal without eval(). \nFor example, just using square bracket notation to\naccess dynamic properties is better and simpler:\n\n// antipattern\nvar property = &quot;name&quot;;\nalert(eval(&quot;obj.&quot; + property));\n\n// preferred\nvar property = &quot;name&quot;;\nalert(obj[property]);\n\n\nUsing eval() also has security implications, because you might be executing code (for\nexample coming from the network) that has been tampered with. \nThis is a common antipattern when dealing with a JSON response from an Ajax request. \nIn those cases\nits better to use the browsers built-in methods to parse the JSON response to make\nsure its safe and valid. For browsers that dont support JSON.parse() natively, you can\nuse a library from JSON.org.\n\nIts also important to remember that passing strings to setInterval(), setTimeout(),\nand the Function() constructor is, for the most part, similar to using eval() and therefore\nshould be avoided. \n\nBehind the scenes, JavaScript still has to evaluate and execute\nthe string you pass as programming code:\n\n// antipatterns\nsetTimeout(&quot;myFunc()&quot;, 1000);\nsetTimeout(&quot;myFunc(1, 2, 3)&quot;, 1000);\n\n// preferred\nsetTimeout(myFunc, 1000);\nsetTimeout(function () {\nmyFunc(1, 2, 3);\n}, 1000);\n\n\nUsing the new Function() constructor is similar to eval() and should be approached\nwith care. It could be a powerful construct but is often misused. \nIf you absolutely must\nuse eval(), you can consider using new Function() instead. \n\nThere is a small potential\nbenefit because the code evaluated in new Function() will be running in a local function\nscope, so any variables defined with var in the code being evaluated will not become\nglobals automatically. \n\nAnother way to prevent automatic globals is to wrap the\neval() call into an immediate function.\n    ","url":"/questions/[slug]#solution16","@type":"Answer","upvoteCount":0},{"text":"Besides the possible security issues if you are executing user-submitted code, most of the time there&apos;s a better way that doesn&apos;t involve re-parsing the code every time it&apos;s executed. Anonymous functions or object properties can replace most uses of eval and are much safer and faster.\n    ","url":"/questions/[slug]#solution17","@type":"Answer","upvoteCount":0},{"text":"This may become more of an issue as the next generation of browsers come out with some flavor of a JavaScript compiler. Code executed via Eval may not perform as well as the rest of your JavaScript against these newer browsers. Someone should do some profiling.\n    ","url":"/questions/[slug]#solution18","@type":"Answer","upvoteCount":0},{"text":"This is one of good articles talking about eval and how it is not an evil:\nhttp://www.nczonline.net/blog/2013/06/25/eval-isnt-evil-just-misunderstood/\n\n\n  Im not saying you should go run out and start using eval()\n  everywhere. In fact, there are very few good use cases for running\n  eval() at all. There are definitely concerns with code clarity,\n  debugability, and certainly performance that should not be overlooked.\n  But you shouldnt be afraid to use it when you have a case where\n  eval() makes sense. Try not using it first, but dont let anyone scare\n  you into thinking your code is more fragile or less secure when eval()\n  is used appropriately.\n\n    ","url":"/questions/[slug]#solution19","@type":"Answer","upvoteCount":0},{"text":"eval() is very powerful and can be used to execute a JS statement or evaluate an expression. But the question isn&apos;t about the uses of eval() but lets just say some how the string you running with eval() is affected by a malicious party. At the end you will be running malicious code. With power comes great responsibility. So use it wisely is you are using it. \n This isn&apos;t related much to eval() function but this article has pretty good information:\n http://blogs.popart.com/2009/07/javascript-injection-attacks/\nIf you are looking for the basics of eval() look here: \nhttps://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/eval\n    ","url":"/questions/[slug]#solution20","@type":"Answer","upvoteCount":0},{"text":"The JavaScript Engine has a number of performance optimizations that it performs during the compilation phase. Some of these boil down to being able to essentially statically analyze the code as it lexes, and pre-determine where all the variable and function declarations are, so that it takes less effort to resolve identifiers during execution.\n\nBut if the Engine finds an eval(..) in the code, it essentially has to assume that all its awareness of identifier location may be invalid, because it cannot know at lexing time exactly what code you may pass to eval(..) to modify the lexical scope, or the contents of the object you may pass to with to create a new lexical scope to be consulted.\n\nIn other words, in the pessimistic sense, most of those optimizations it would make are pointless if eval(..) is present, so it simply doesn&apos;t perform the optimizations at all.\n\nThis explains it all.\n\nReference :\n\nhttps://github.com/getify/You-Dont-Know-JS/blob/master/scope%20&amp;%20closures/ch2.md#eval\n\nhttps://github.com/getify/You-Dont-Know-JS/blob/master/scope%20&amp;%20closures/ch2.md#performance\n    ","url":"/questions/[slug]#solution21","@type":"Answer","upvoteCount":0},{"text":"It&apos;s not always a bad idea. Take for example, code generation. I recently wrote a library called Hyperbars which bridges the gap between virtual-dom and handlebars. It does this by parsing a handlebars template and converting it to hyperscript which is subsequently used by virtual-dom. The hyperscript is generated as a string first and before returning it, eval() it to turn it into executable code. I have found eval() in this particular situation the exact opposite of evil. \n\nBasically from\n\n&lt;div&gt;\n    {{#each names}}\n        &lt;span&gt;{{this}}&lt;/span&gt;\n    {{/each}}\n&lt;/div&gt;\n\n\nTo this\n\n(function (state) {\n    var Runtime = Hyperbars.Runtime;\n    var context = state;\n    return h(&apos;div&apos;, {}, [Runtime.each(context[&apos;names&apos;], context, function (context, parent, options) {\n        return [h(&apos;span&apos;, {}, [options[&apos;@index&apos;], context])]\n    })])\n}.bind({}))\n\n\nThe performance of eval() isn&apos;t an issue in a situation like this because you only need to interpret the generated string once and then reuse the executable output many times over.\n\nYou can see how the code generation was achieved if you&apos;re curious here.\n    ","url":"/questions/[slug]#solution22","@type":"Answer","upvoteCount":0},{"text":"I would go as far as to say that it doesn&apos;t really matter if you use eval() in javascript which is run in browsers.*(caveat)\n\nAll modern browsers have a developer console where you can execute arbitrary javascript anyway and any semi-smart developer can look at your JS source and put whatever bits of it they need to into the dev console to do what they wish.\n\n*As long as your server endpoints have the correct validation &amp; sanitisation of user supplied values, it should not matter what gets parsed and eval&apos;d in your client side javascript.\n\nIf you were to ask if it&apos;s suitable to use eval() in PHP however, the answer is NO, unless you whitelist any values which may be passed to your eval statement.\n    ","url":"/questions/[slug]#solution23","@type":"Answer","upvoteCount":0},{"text":"Garbage collection\n\nThe browsers garbage collection has no idea if the code that&apos;s eval&apos;ed can be removed from memory so it just keeps it stored until the page is reloaded. \nNot too bad if your users are only on your page shortly, but it can be a problem for webapp&apos;s. \n\nHere&apos;s a script to demo the problem\n\nhttps://jsfiddle.net/CynderRnAsh/qux1osnw/\n\ndocument.getElementById(&quot;evalLeak&quot;).onclick = (e) =&gt; {\n  for(let x = 0; x &lt; 100; x++) {\n    eval(x.toString());\n  }\n};\n\n\nSomething as simple as the above code causes a small amount of memory to be store until the app dies. \nThis is worse when the evaled script is a giant function, and called on interval.\n    ","url":"/questions/[slug]#solution24","@type":"Answer","upvoteCount":0},{"text":"I won&apos;t attempt to refute anything said heretofore, but i will offer this use of eval() that (as far as I know) can&apos;t be done any other way.  There&apos;s probably other ways to code this, and probably ways to optimize it, but this is done longhand and without any bells and whistles for clarity sake to illustrate a use of eval that really doesn&apos;t have any other alternatives.  That is: dynamical (or more accurately) programmically-created object names (as opposed to values).\n\n//Place this in a common/global JS lib:\nvar NS = function(namespace){\n    var namespaceParts = String(namespace).split(&quot;.&quot;);\n    var namespaceToTest = &quot;&quot;;\n    for(var i = 0; i &lt; namespaceParts.length; i++){\n        if(i === 0){\n            namespaceToTest = namespaceParts[i];\n        }\n        else{\n            namespaceToTest = namespaceToTest + &quot;.&quot; + namespaceParts[i];\n        }\n\n        if(eval(&apos;typeof &apos; + namespaceToTest) === &quot;undefined&quot;){\n            eval(namespaceToTest + &apos; = {}&apos;);\n        }\n    }\n    return eval(namespace);\n}\n\n\n//Then, use this in your class definition libs:\nNS(&apos;Root.Namespace&apos;).Class = function(settings){\n  //Class constructor code here\n}\n//some generic method:\nRoot.Namespace.Class.prototype.Method = function(args){\n    //Code goes here\n    //this.MyOtherMethod(&quot;foo&quot;));  // =&gt; &quot;foo&quot;\n    return true;\n}\n\n\n//Then, in your applications, use this to instantiate an instance of your class:\nvar anInstanceOfClass = new Root.Namespace.Class(settings);\n\n\nEDIT:  by the way, I wouldn&apos;t suggest (for all the security reasons pointed out heretofore) that you base you object names on user input.  I can&apos;t imagine any good reason you&apos;d want to do that though.  Still, thought I&apos;d point it out that it wouldn&apos;t be a good idea :)\n    ","url":"/questions/[slug]#solution25","@type":"Answer","upvoteCount":0}],"@type":"Question"}}</script><meta name="next-head-count" content="16"/><link rel="preload" href="/_next/static/css/08bcc42a26fe5c92.css" as="style"/><link rel="stylesheet" href="/_next/static/css/08bcc42a26fe5c92.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-0d1b80a048d4787e.js"></script><script src="/_next/static/chunks/webpack-42cdea76c8170223.js" defer=""></script><script src="/_next/static/chunks/framework-4556c45dd113b893.js" defer=""></script><script src="/_next/static/chunks/main-ccfab947c79712f4.js" defer=""></script><script src="/_next/static/chunks/pages/_app-08d1a634dea6705e.js" defer=""></script><script src="/_next/static/chunks/29107295-fbcfe2172188e46f.js" defer=""></script><script src="/_next/static/chunks/150-b06815e21c943e0d.js" defer=""></script><script src="/_next/static/chunks/490-7f0418bb4354ac73.js" defer=""></script><script src="/_next/static/chunks/108-87de33c23337ff53.js" defer=""></script><script src="/_next/static/chunks/pages/questions/%5Bslug%5D-79a1437acf654019.js" defer=""></script><script src="/_next/static/TQ2eYlCSdocSK-hq6gkM0/_buildManifest.js" defer=""></script><script src="/_next/static/TQ2eYlCSdocSK-hq6gkM0/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="wrapper"><header><nav class="bg-white border-gray-200 px-4 lg:px-6 py-2.5 dark:bg-gray-800"><div class="flex flex-wrap justify-between items-center mx-auto max-w-screen-xl"><a class="flex items-center" href="/"><img src="/logo-second.png" class="mr-3 h-6 sm:h-9" alt="Solution Checker Logo"/><h4 class="self-center text-xl font-semibold whitespace-nowrap dark:text-white">Solution Checker</h4></a><div class="flex items-center lg:order-2"><button data-collapse-toggle="mobile-menu-2" type="button" class="inline-flex items-center p-2 ml-1 text-sm text-gray-500 rounded-lg lg:hidden hover:bg-gray-100 focus:outline-none focus:ring-2 focus:ring-gray-200 dark:text-gray-400 dark:hover:bg-gray-700 dark:focus:ring-gray-600" aria-controls="mobile-menu-2" aria-expanded="false"><span class="sr-only">Open main menu</span><svg class="w-6 h-6" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M3 5a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM3 10a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM3 15a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1z" clip-rule="evenodd"></path></svg><svg class="hidden w-6 h-6" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z" clip-rule="evenodd"></path></svg></button></div><div class="hidden justify-between items-center w-full lg:flex lg:w-auto lg:order-1" id="mobile-menu-2"><ul class="flex flex-col mt-4 font-medium lg:flex-row lg:space-x-8 lg:mt-0"><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" aria-current="page" href="/">Home</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/questions?tab=news">Questions</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/post?tab=news">Post</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/questions/why-is-using-the-javascript-eval-function-a-bad-idea-1657387485165#">Coding</a></li></ul></div></div></nav></header><div class="main-content"><div class="question my-5"><div class="flex question-header items-center m-auto justify-center"><div class="rounded-xl w-full border p-5 shadow-md bg-white"><div class="flex w-full items-center justify-between border-b pb-3"><div class="flex items-center space-x-3"><div class="text-lg font-bold text-slate-700"><a href="/questions/why-is-using-the-javascript-eval-function-a-bad-idea-1657387485165"><h1>Why is using the JavaScript eval function a bad idea?</h1></a></div></div><div class="flex flex-wrap h-auto justify-end items-center space-x-8"></div></div><div class="question-content mt-5">
                
<p>The eval function is a powerful and easy way to dynamically generate code, so what are the caveats?</p>
    </div></div></div><div class="solution-section"><nav class="flex pagination-solution flex-col justify-end"><ul class="inline-flex -space-x-px overflow-auto"><li class="pagination-solution-item"><span data-id="#solution1" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">1</span></li><li class="pagination-solution-item"><span data-id="#solution2" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">2</span></li><li class="pagination-solution-item"><span data-id="#solution3" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">3</span></li><li class="pagination-solution-item"><span data-id="#solution4" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">4</span></li><li class="pagination-solution-item"><span data-id="#solution5" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">5</span></li><li class="pagination-solution-item"><span data-id="#solution6" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">6</span></li><li class="pagination-solution-item"><span data-id="#solution7" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">7</span></li><li class="pagination-solution-item"><span data-id="#solution8" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">8</span></li><li class="pagination-solution-item"><span data-id="#solution9" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">9</span></li><li class="pagination-solution-item"><span data-id="#solution10" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">10</span></li><li class="pagination-solution-item"><span data-id="#solution11" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">11</span></li><li class="pagination-solution-item"><span data-id="#solution12" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">12</span></li><li class="pagination-solution-item"><span data-id="#solution13" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">13</span></li><li class="pagination-solution-item"><span data-id="#solution14" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">14</span></li><li class="pagination-solution-item"><span data-id="#solution15" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">15</span></li><li class="pagination-solution-item"><span data-id="#solution16" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">16</span></li><li class="pagination-solution-item"><span data-id="#solution17" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">17</span></li><li class="pagination-solution-item"><span data-id="#solution18" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">18</span></li><li class="pagination-solution-item"><span data-id="#solution19" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">19</span></li><li class="pagination-solution-item"><span data-id="#solution20" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">20</span></li><li class="pagination-solution-item"><span data-id="#solution21" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">21</span></li><li class="pagination-solution-item"><span data-id="#solution22" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">22</span></li><li class="pagination-solution-item"><span data-id="#solution23" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">23</span></li><li class="pagination-solution-item"><span data-id="#solution24" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">24</span></li><li class="pagination-solution-item"><span data-id="#solution25" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">25</span></li></ul></nav><div id="solution1" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 1</h4><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<ol>
<li><p>Improper use of <strong>eval</strong> opens up your
code for injection attacks</p></li>
<li><p><strong>Debugging</strong> can be more challenging
(no line numbers, etc.)</p></li>
<li><p>eval'd code executes slower (no opportunity to compile/cache eval'd code)</p></li>
</ol>

<p>Edit: As @Jeff Walden points out in comments, #3 is less true today than it was in 2008. However, while some caching of compiled scripts may happen this will only be limited to scripts that are eval'd repeated with no modification. A more likely scenario is that you are eval'ing scripts that have undergone slight modification each time and as such could not be cached. Let's just say that SOME eval'd code executes more slowly.</p>
    </div></div></div></div><div id="solution2" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 2</h4><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>eval isn't always evil. There are times where it's perfectly appropriate.</p>

<p>However, eval is currently and historically massively over-used by people who don't know what they're doing. That includes people writing JavaScript tutorials, unfortunately, and in some cases this can indeed have security consequences - or, more often, simple bugs. So the more we can do to throw a question mark over eval, the better. Any time you use eval you need to sanity-check what you're doing, because chances are you could be doing it a better, safer, cleaner way.</p>

<p>To give an all-too-typical example, to set the colour of an element with an id stored in the variable 'potato':</p>

<pre class="lang-js s-code-block"><code class="hljs language-javascript"><span class="hljs-built_in">eval</span>(<span class="hljs-string">'document.'</span> + potato + <span class="hljs-string">'.style.color = "red"'</span>);
</code></pre>

<p>If the authors of the kind of code above had a clue about the basics of how JavaScript objects work, they'd have realised that square brackets can be used instead of literal dot-names, obviating the need for eval:</p>

<pre class="lang-js s-code-block"><code class="hljs language-javascript"><span class="hljs-variable language_">document</span>[potato].<span class="hljs-property">style</span>.<span class="hljs-property">color</span> = <span class="hljs-string">'red'</span>;
</code></pre>

<p>...which is much easier to read as well as less potentially buggy.</p>

<p>(But then, someone who /really/ knew what they were doing would say:</p>

<pre class="lang-js s-code-block"><code class="hljs language-javascript"><span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(potato).<span class="hljs-property">style</span>.<span class="hljs-property">color</span> = <span class="hljs-string">'red'</span>;
</code></pre>

<p>which is more reliable than the dodgy old trick of accessing DOM elements straight out of the document object.)</p>
    </div></div></div></div><div id="solution3" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 3</h4><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>I believe it's because it can execute any JavaScript function from a string. Using it makes it easier for people to inject rogue code into the application.</p>
    </div></div></div></div><div id="solution4" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 4</h4><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Two points come to mind:</p>

<ol>
<li><p>Security (but as long as you generate the string to be evaluated yourself, this might be a non-issue)</p></li>
<li><p>Performance: until the code to be executed is unknown, it cannot be optimized.  (about javascript and performance, certainly <a href="http://steve-yegge.blogspot.com/2008/05/dynamic-languages-strike-back.html" rel="noreferrer">Steve Yegge's presentation</a>)</p></li>
</ol>
    </div></div></div></div><div id="solution5" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 5</h4><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>It's generally only an issue if you're passing eval user input.</p>
    </div></div></div></div><div id="solution6" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 6</h4><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Passing user input to eval() is a security risk, but also each invocation of eval() creates a new instance of the JavaScript interpreter. This can be a resource hog.</p>
    </div></div></div></div><div id="solution7" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 7</h4><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Mainly, it's a lot harder to maintain and debug. It's like a <code>goto</code>. You can use it, but it makes it harder to find problems and harder on the people who may need to make changes later.</p>
    </div></div></div></div><div id="solution8" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 8</h4><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>One thing to keep in mind is that you can often use eval() to execute code in an otherwise restricted environment - social networking sites that block specific JavaScript functions can sometimes be fooled by breaking them up in an eval block -</p>

<pre class="lang-js s-code-block"><code class="hljs language-javascript"><span class="hljs-built_in">eval</span>(<span class="hljs-string">'al'</span> + <span class="hljs-string">'er'</span> + <span class="hljs-string">'t(\''</span> + <span class="hljs-string">'hi there!'</span> + <span class="hljs-string">'\')'</span>);
</code></pre>

<p>So if you're looking to run some JavaScript code where it might not otherwise be allowed (<a href="http://en.wikipedia.org/wiki/Myspace" rel="noreferrer">Myspace</a>, I'm looking at you...) then eval() can be a useful trick.</p>

<p>However, for all the reasons mentioned above, you shouldn't use it for your own code, where you have complete control - it's just not necessary, and better-off relegated to the 'tricky JavaScript hacks' shelf.</p>
    </div></div></div></div><div id="solution9" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 9</h4><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Unless you let eval() a dynamic content (through cgi or input), it is as safe and solid as all other JavaScript in your page.</p>
    </div></div></div></div><div id="solution10" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 10</h4><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Along with the rest of the answers, I don't think eval statements can have advanced minimization.</p>
    </div></div></div></div><div id="solution11" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 11</h4><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>It is a possible security risk, it has a different scope of execution, and is quite inefficient, as it creates an entirely new scripting environment for the execution of the code. See here for some more info: <a href="http://userjs.org/help/tutorials/efficient-code#evalevil" rel="nofollow noreferrer">eval</a>.</p>

<p>It is quite useful, though, and used with moderation can add a lot of good functionality.</p>
    </div></div></div></div><div id="solution12" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 12</h4><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Unless you are 100% sure that the code being evaluated is from a trusted source (usually your own application) then it's a surefire way of exposing your system to a cross-site scripting attack.</p>
    </div></div></div></div><div id="solution13" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 13</h4><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>It's not necessarily that bad provided you know what context you're using it in.</p>

<p>If your application is using <code>eval()</code> to create an object from some JSON which has come back from an <a href="http://en.wikipedia.org/wiki/XMLHttpRequest" rel="nofollow noreferrer">XMLHttpRequest</a> to your own site, created by your trusted server-side code, it's probably not a problem.</p>

<p>Untrusted client-side JavaScript code can't do that much anyway. Provided the thing you're executing <code>eval()</code> on has come from a reasonable source, you're fine.</p>
    </div></div></div></div><div id="solution14" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 14</h4><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>It greatly reduces your level of confidence about security.</p>
    </div></div></div></div><div id="solution15" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 15</h4><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>If you want the user to input some logical functions and evaluate for AND the OR then the JavaScript eval function is perfect. I can accept two strings and <code>eval(uate) string1 === string2</code>, etc.</p>
    </div></div></div></div><div id="solution16" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 16</h4><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>If you spot the use of eval() in your code, remember the mantra eval() is evil. </p>

<p>This
function takes an arbitrary string and executes it as JavaScript code. When the code in
question is known beforehand (not determined at runtime), theres no reason to use
eval(). 
If the code is dynamically generated at runtime, theres often a better way to
achieve the goal without eval(). 
For example, just using square bracket notation to
access dynamic properties is better and simpler:</p>

<pre class="lang-js s-code-block"><code class="hljs language-javascript"><span class="hljs-comment">// antipattern</span>
<span class="hljs-keyword">var</span> property = <span class="hljs-string">"name"</span>;
<span class="hljs-title function_">alert</span>(<span class="hljs-built_in">eval</span>(<span class="hljs-string">"obj."</span> + property));

<span class="hljs-comment">// preferred</span>
<span class="hljs-keyword">var</span> property = <span class="hljs-string">"name"</span>;
<span class="hljs-title function_">alert</span>(obj[property]);
</code></pre>

<p>Using <code>eval()</code> also has security implications, because you might be executing code (for
example coming from the network) that has been tampered with. 
This is a common antipattern when dealing with a JSON response from an Ajax request. 
In those cases
its better to use the browsers built-in methods to parse the JSON response to make
sure its safe and valid. For browsers that dont support <code>JSON.parse()</code> natively, you can
use a library from JSON.org.</p>

<p>Its also important to remember that passing strings to <code>setInterval()</code>, <code>setTimeout()</code>,
and the <code>Function()</code> constructor is, for the most part, similar to using <code>eval()</code> and therefore
should be avoided. </p>

<p>Behind the scenes, JavaScript still has to evaluate and execute
the string you pass as programming code:</p>

<pre class="lang-js s-code-block"><code class="hljs language-javascript"><span class="hljs-comment">// antipatterns</span>
<span class="hljs-built_in">setTimeout</span>(<span class="hljs-string">"myFunc()"</span>, <span class="hljs-number">1000</span>);
<span class="hljs-built_in">setTimeout</span>(<span class="hljs-string">"myFunc(1, 2, 3)"</span>, <span class="hljs-number">1000</span>);

<span class="hljs-comment">// preferred</span>
<span class="hljs-built_in">setTimeout</span>(myFunc, <span class="hljs-number">1000</span>);
<span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
<span class="hljs-title function_">myFunc</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>);
}, <span class="hljs-number">1000</span>);
</code></pre>

<p>Using the new Function() constructor is similar to eval() and should be approached
with care. It could be a powerful construct but is often misused. 
If you absolutely must
use <code>eval()</code>, you can consider using new Function() instead. </p>

<p>There is a small potential
benefit because the code evaluated in new Function() will be running in a local function
scope, so any variables defined with var in the code being evaluated will not become
globals automatically. </p>

<p>Another way to prevent automatic globals is to wrap the
<code>eval()</code> call into an immediate function.</p>
    </div></div></div></div><div id="solution17" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 17</h4><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Besides the possible security issues if you are executing user-submitted code, most of the time there's a better way that doesn't involve re-parsing the code every time it's executed. Anonymous functions or object properties can replace most uses of eval and are much safer and faster.</p>
    </div></div></div></div><div id="solution18" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 18</h4><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>This may become more of an issue as the next generation of browsers come out with some flavor of a JavaScript compiler. Code executed via Eval may not perform as well as the rest of your JavaScript against these newer browsers. Someone should do some profiling.</p>
    </div></div></div></div><div id="solution19" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 19</h4><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>This is one of good articles talking about eval and how it is not an evil:
<a href="http://www.nczonline.net/blog/2013/06/25/eval-isnt-evil-just-misunderstood/" rel="nofollow">http://www.nczonline.net/blog/2013/06/25/eval-isnt-evil-just-misunderstood/</a></p>

<blockquote>
  <p>Im not saying you should go run out and start using eval()
  everywhere. In fact, there are very few good use cases for running
  eval() at all. There are definitely concerns with code clarity,
  debugability, and certainly performance that should not be overlooked.
  But you shouldnt be afraid to use it when you have a case where
  eval() makes sense. Try not using it first, but dont let anyone scare
  you into thinking your code is more fragile or less secure when eval()
  is used appropriately.</p>
</blockquote>
    </div></div></div></div><div id="solution20" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 20</h4><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>eval() is very powerful and can be used to execute a JS statement or evaluate an expression. But the question isn't about the uses of eval() but lets just say some how the string you running with eval() is affected by a malicious party. At the end you will be running malicious code. With power comes great responsibility. So use it wisely is you are using it. 
 This isn't related much to eval() function but this article has pretty good information:
 <a href="http://blogs.popart.com/2009/07/javascript-injection-attacks/" rel="nofollow">http://blogs.popart.com/2009/07/javascript-injection-attacks/</a>
If you are looking for the basics of eval() look here: 
<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/eval" rel="nofollow">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/eval</a></p>
    </div></div></div></div><div id="solution21" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 21</h4><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>The JavaScript Engine has a number of performance optimizations that it performs during the compilation phase. Some of these boil down to being able to essentially statically analyze the code as it lexes, and pre-determine where all the variable and function declarations are, so that it takes less effort to resolve identifiers during execution.</p>

<p>But if the Engine finds an eval(..) in the code, it essentially has to assume that all its awareness of identifier location may be invalid, because it cannot know at lexing time exactly what code you may pass to eval(..) to modify the lexical scope, or the contents of the object you may pass to with to create a new lexical scope to be consulted.</p>

<p>In other words, in the pessimistic sense, most of those optimizations it would make are pointless if eval(..) is present, so it simply doesn't perform the optimizations at all.</p>

<p>This explains it all.</p>

<p>Reference :</p>

<p><a href="https://github.com/getify/You-Dont-Know-JS/blob/master/scope%20&amp;%20closures/ch2.md#eval" rel="nofollow">https://github.com/getify/You-Dont-Know-JS/blob/master/scope%20&amp;%20closures/ch2.md#eval</a></p>

<p><a href="https://github.com/getify/You-Dont-Know-JS/blob/master/scope%20&amp;%20closures/ch2.md#performance" rel="nofollow">https://github.com/getify/You-Dont-Know-JS/blob/master/scope%20&amp;%20closures/ch2.md#performance</a></p>
    </div></div></div></div><div id="solution22" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 22</h4><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>It's not always a bad idea. Take for example, code generation. I recently wrote a library called <a href="https://github.com/vincentracine/hyperbars" rel="nofollow noreferrer">Hyperbars</a> which bridges the gap between <a href="https://github.com/Matt-Esch/virtual-dom" rel="nofollow noreferrer">virtual-dom</a> and <a href="http://handlebarsjs.com/" rel="nofollow noreferrer">handlebars</a>. It does this by parsing a handlebars template and converting it to <a href="https://github.com/dominictarr/hyperscript" rel="nofollow noreferrer">hyperscript</a> which is subsequently used by virtual-dom. The hyperscript is generated as a string first and before returning it, <code>eval()</code> it to turn it into executable code. I have found <code>eval()</code> in this particular situation the exact opposite of evil. </p>

<p>Basically from</p>

<pre class="lang-js s-code-block"><code class="hljs language-javascript">&lt;div&gt;
    {{#each names}}
        &lt;span&gt;{{<span class="hljs-variable language_">this</span>}}&lt;/span&gt;
    {{/each}}
&lt;/div&gt;
</code></pre>

<p>To this</p>

<pre class="lang-js s-code-block"><code class="hljs language-javascript">(<span class="hljs-keyword">function</span> (<span class="hljs-params">state</span>) {
    <span class="hljs-keyword">var</span> <span class="hljs-title class_">Runtime</span> = <span class="hljs-title class_">Hyperbars</span>.<span class="hljs-property">Runtime</span>;
    <span class="hljs-keyword">var</span> context = state;
    <span class="hljs-keyword">return</span> <span class="hljs-title function_">h</span>(<span class="hljs-string">'div'</span>, {}, [<span class="hljs-title class_">Runtime</span>.<span class="hljs-title function_">each</span>(context[<span class="hljs-string">'names'</span>], context, <span class="hljs-keyword">function</span> (<span class="hljs-params">context, parent, options</span>) {
        <span class="hljs-keyword">return</span> [<span class="hljs-title function_">h</span>(<span class="hljs-string">'span'</span>, {}, [options[<span class="hljs-string">'@index'</span>], context])]
    })])
}.<span class="hljs-title function_">bind</span>({}))
</code></pre>

<p>The performance of <code>eval()</code> isn't an issue in a situation like this because you only need to interpret the generated string once and then reuse the executable output many times over.</p>

<p>You can see how the code generation was achieved if you're curious <a href="https://github.com/vincentracine/hyperbars/blob/master/src/hyperbars.js#L131" rel="nofollow noreferrer">here</a>.</p>
    </div></div></div></div><div id="solution23" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 23</h4><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>I would go as far as to say that it doesn't really matter if you use <code>eval()</code> in javascript which is run in browsers.*(caveat)</p>

<p>All modern browsers have a developer console where you can execute arbitrary javascript anyway and any semi-smart developer can look at your JS source and put whatever bits of it they need to into the dev console to do what they wish.</p>

<p>*As long as your server endpoints have the correct validation &amp; sanitisation of user supplied values, it should not matter what gets parsed and eval'd in your client side javascript.</p>

<p>If you were to ask if it's suitable to use <code>eval()</code> in PHP however, the answer is <strong>NO</strong>, unless you <strong>whitelist</strong> any values which may be passed to your eval statement.</p>
    </div></div></div></div><div id="solution24" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 24</h4><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Garbage collection</p>

<p>The browsers garbage collection has no idea if the code that's eval'ed can be removed from memory so it just keeps it stored until the page is reloaded. 
Not too bad if your users are only on your page shortly, but it can be a problem for webapp's. </p>

<p>Here's a script to demo the problem</p>

<p><a href="https://jsfiddle.net/CynderRnAsh/qux1osnw/" rel="nofollow noreferrer">https://jsfiddle.net/CynderRnAsh/qux1osnw/</a></p>

<pre class="lang-js s-code-block"><code class="hljs language-javascript"><span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">"evalLeak"</span>).<span class="hljs-property">onclick</span> = <span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> {
  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> x = <span class="hljs-number">0</span>; x &lt; <span class="hljs-number">100</span>; x++) {
    <span class="hljs-built_in">eval</span>(x.<span class="hljs-title function_">toString</span>());
  }
};
</code></pre>

<p>Something as simple as the above code causes a small amount of memory to be store until the app dies. 
This is worse when the evaled script is a giant function, and called on interval.</p>
    </div></div></div></div><div id="solution25" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 25</h4><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>I won't attempt to refute anything said heretofore, but i will offer this use of eval() that (as far as I know) can't be done any other way.  There's probably other ways to code this, and probably ways to optimize it, but this is done longhand and without any bells and whistles for clarity sake to illustrate a use of eval that really doesn't have any other alternatives.  That is: dynamical (or more accurately) programmically-created object names (as opposed to values).</p>

<pre class="lang-js s-code-block"><code class="hljs language-javascript"><span class="hljs-comment">//Place this in a common/global JS lib:</span>
<span class="hljs-keyword">var</span> <span class="hljs-variable constant_">NS</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">namespace</span>){
    <span class="hljs-keyword">var</span> namespaceParts = <span class="hljs-title class_">String</span>(namespace).<span class="hljs-title function_">split</span>(<span class="hljs-string">"."</span>);
    <span class="hljs-keyword">var</span> namespaceToTest = <span class="hljs-string">""</span>;
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; namespaceParts.<span class="hljs-property">length</span>; i++){
        <span class="hljs-keyword">if</span>(i === <span class="hljs-number">0</span>){
            namespaceToTest = namespaceParts[i];
        }
        <span class="hljs-keyword">else</span>{
            namespaceToTest = namespaceToTest + <span class="hljs-string">"."</span> + namespaceParts[i];
        }

        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">eval</span>(<span class="hljs-string">'typeof '</span> + namespaceToTest) === <span class="hljs-string">"undefined"</span>){
            <span class="hljs-built_in">eval</span>(namespaceToTest + <span class="hljs-string">' = {}'</span>);
        }
    }
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">eval</span>(namespace);
}


<span class="hljs-comment">//Then, use this in your class definition libs:</span>
<span class="hljs-title function_">NS</span>(<span class="hljs-string">'Root.Namespace'</span>).<span class="hljs-property">Class</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">settings</span>){
  <span class="hljs-comment">//Class constructor code here</span>
}
<span class="hljs-comment">//some generic method:</span>
<span class="hljs-title class_">Root</span>.<span class="hljs-property">Namespace</span>.<span class="hljs-property">Class</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">Method</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">args</span>){
    <span class="hljs-comment">//Code goes here</span>
    <span class="hljs-comment">//this.MyOtherMethod("foo"));  // =&gt; "foo"</span>
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
}


<span class="hljs-comment">//Then, in your applications, use this to instantiate an instance of your class:</span>
<span class="hljs-keyword">var</span> anInstanceOfClass = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Root</span>.<span class="hljs-property">Namespace</span>.<span class="hljs-title class_">Class</span>(settings);
</code></pre>

<p>EDIT:  by the way, I wouldn't suggest (for all the security reasons pointed out heretofore) that you base you object names on user input.  I can't imagine any good reason you'd want to do that though.  Still, thought I'd point it out that it wouldn't be a good idea :)</p>
    </div></div></div></div></div></div><div class="widget"><a href="/questions/grouping-functions-(tapply-by-aggregate)-and-the-*apply-family-1657387844286">Grouping functions (tapply, by, aggregate) and the *apply family</a><a href="/questions/how-do-i-use-reflection-to-call-a-generic-method-1657387256751">How do I use reflection to call a generic method?</a><a href="/questions/what-is-an-efficient-way-to-implement-a-singleton-pattern-in-java-closed-1657387970474">What is an efficient way to implement a singleton pattern in Java? [closed]</a><a href="/questions/with-arrays-why-is-it-the-case-that-a5-5a-1657387956216">With arrays, why is it the case that a[5] == 5[a]?</a><a href="/questions/short-description-of-the-scoping-rules-1657384853121">Short description of the scoping rules?</a><a href="/questions/what-are-the-rules-for-javascript&#x27;s-automatic-semicolon-insertion-(asi)-1657387472789">What are the rules for JavaScript&#x27;s automatic semicolon insertion (ASI)?</a><a href="/questions/how-do-i-split-a-list-into-equally-sized-chunks-1657384580399">How do I split a list into equally-sized chunks?</a><a href="/questions/why-does-jquery-or-a-dom-method-such-as-getelementbyid-not-find-the-element-1657384326458">Why does jQuery or a DOM method such as getElementById not find the element?</a><a href="/questions/where-do-i-find-the-current-c-or-c++-standard-documents-1657388006897">Where do I find the current C or C++ standard documents?</a><a href="/questions/php-mail-function-doesn&#x27;t-complete-sending-of-e-mail-1657384307499">PHP mail function doesn&#x27;t complete sending of e-mail</a><a href="/questions/what-is-the-difference-between-char-s-and-char-*s-1657387823570">What is the difference between char s[] and char *s?</a><a href="/questions/can-php-pdo-statements-accept-the-table-or-column-name-as-parameter-1657387478588">Can PHP PDO Statements accept the table or column name as parameter?</a><a href="/questions/prefer-composition-over-inheritance-1657387399409">Prefer composition over inheritance?</a><a href="/questions/preview-an-image-before-it-is-uploaded-1657388048128">Preview an image before it is uploaded</a><a href="/questions/what-is-the-(function()-)()-construct-in-javascript-1657385508348">What is the (function() { } )() construct in JavaScript?</a><a href="/questions/importing-files-from-different-folder-1657388203798">Importing files from different folder</a><a href="/questions/why-does-std::getline()-skip-input-after-a-formatted-extraction-1657384756118">Why does std::getline() skip input after a formatted extraction?</a><a href="/questions/what-is-the-meaning-of-single-and-double-underscore-before-an-object-name-1657387926929">What is the meaning of single and double underscore before an object name?</a><a href="/questions/scanner-is-skipping-nextline()-after-using-next()-or-nextfoo()-1657384379697">Scanner is skipping nextLine() after using next() or nextFoo()?</a><a href="/questions/the-definitive-c++-book-guide-and-list-1657384247395">The Definitive C++ Book Guide and List</a></div></div><span class="cursor-pointer text-lg p-2" style="position:fixed;bottom:20px;left:20px;background:#000;z-index:2000;color:white">Go go top</span></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"data":{"answer":["\n\u0026lt;ol\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;Improper use of \u0026lt;strong\u0026gt;eval\u0026lt;/strong\u0026gt; opens up your\ncode for injection attacks\u0026lt;/p\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Debugging\u0026lt;/strong\u0026gt; can be more challenging\n(no line numbers, etc.)\u0026lt;/p\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;eval\u0026apos;d code executes slower (no opportunity to compile/cache eval\u0026apos;d code)\u0026lt;/p\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;/ol\u0026gt;\n\n\u0026lt;p\u0026gt;Edit: As @Jeff Walden points out in comments, #3 is less true today than it was in 2008. However, while some caching of compiled scripts may happen this will only be limited to scripts that are eval\u0026apos;d repeated with no modification. A more likely scenario is that you are eval\u0026apos;ing scripts that have undergone slight modification each time and as such could not be cached. Let\u0026apos;s just say that SOME eval\u0026apos;d code executes more slowly.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;eval isn\u0026apos;t always evil. There are times where it\u0026apos;s perfectly appropriate.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;However, eval is currently and historically massively over-used by people who don\u0026apos;t know what they\u0026apos;re doing. That includes people writing JavaScript tutorials, unfortunately, and in some cases this can indeed have security consequences - or, more often, simple bugs. So the more we can do to throw a question mark over eval, the better. Any time you use eval you need to sanity-check what you\u0026apos;re doing, because chances are you could be doing it a better, safer, cleaner way.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;To give an all-too-typical example, to set the colour of an element with an id stored in the variable \u0026apos;potato\u0026apos;:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;eval\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;document.\u0026apos;\u0026lt;/span\u0026gt; + potato + \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;.style.color = \u0026quot;red\u0026quot;\u0026apos;\u0026lt;/span\u0026gt;);\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;If the authors of the kind of code above had a clue about the basics of how JavaScript objects work, they\u0026apos;d have realised that square brackets can be used instead of literal dot-names, obviating the need for eval:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;document\u0026lt;/span\u0026gt;[potato].\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;style\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;color\u0026lt;/span\u0026gt; = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;red\u0026apos;\u0026lt;/span\u0026gt;;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;...which is much easier to read as well as less potentially buggy.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;(But then, someone who /really/ knew what they were doing would say:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;document\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;getElementById\u0026lt;/span\u0026gt;(potato).\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;style\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;color\u0026lt;/span\u0026gt; = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;red\u0026apos;\u0026lt;/span\u0026gt;;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;which is more reliable than the dodgy old trick of accessing DOM elements straight out of the document object.)\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;I believe it\u0026apos;s because it can execute any JavaScript function from a string. Using it makes it easier for people to inject rogue code into the application.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Two points come to mind:\u0026lt;/p\u0026gt;\n\n\u0026lt;ol\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;Security (but as long as you generate the string to be evaluated yourself, this might be a non-issue)\u0026lt;/p\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;Performance: until the code to be executed is unknown, it cannot be optimized.  (about javascript and performance, certainly \u0026lt;a href=\u0026quot;http://steve-yegge.blogspot.com/2008/05/dynamic-languages-strike-back.html\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;Steve Yegge\u0026apos;s presentation\u0026lt;/a\u0026gt;)\u0026lt;/p\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;/ol\u0026gt;\n    ","\n\u0026lt;p\u0026gt;It\u0026apos;s generally only an issue if you\u0026apos;re passing eval user input.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Passing user input to eval() is a security risk, but also each invocation of eval() creates a new instance of the JavaScript interpreter. This can be a resource hog.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Mainly, it\u0026apos;s a lot harder to maintain and debug. It\u0026apos;s like a \u0026lt;code\u0026gt;goto\u0026lt;/code\u0026gt;. You can use it, but it makes it harder to find problems and harder on the people who may need to make changes later.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;One thing to keep in mind is that you can often use eval() to execute code in an otherwise restricted environment - social networking sites that block specific JavaScript functions can sometimes be fooled by breaking them up in an eval block -\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;eval\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;al\u0026apos;\u0026lt;/span\u0026gt; + \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;er\u0026apos;\u0026lt;/span\u0026gt; + \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;t(\\\u0026apos;\u0026apos;\u0026lt;/span\u0026gt; + \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;hi there!\u0026apos;\u0026lt;/span\u0026gt; + \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;\\\u0026apos;)\u0026apos;\u0026lt;/span\u0026gt;);\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;So if you\u0026apos;re looking to run some JavaScript code where it might not otherwise be allowed (\u0026lt;a href=\u0026quot;http://en.wikipedia.org/wiki/Myspace\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;Myspace\u0026lt;/a\u0026gt;, I\u0026apos;m looking at you...) then eval() can be a useful trick.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;However, for all the reasons mentioned above, you shouldn\u0026apos;t use it for your own code, where you have complete control - it\u0026apos;s just not necessary, and better-off relegated to the \u0026apos;tricky JavaScript hacks\u0026apos; shelf.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Unless you let eval() a dynamic content (through cgi or input), it is as safe and solid as all other JavaScript in your page.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Along with the rest of the answers, I don\u0026apos;t think eval statements can have advanced minimization.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;It is a possible security risk, it has a different scope of execution, and is quite inefficient, as it creates an entirely new scripting environment for the execution of the code. See here for some more info: \u0026lt;a href=\u0026quot;http://userjs.org/help/tutorials/efficient-code#evalevil\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;eval\u0026lt;/a\u0026gt;.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;It is quite useful, though, and used with moderation can add a lot of good functionality.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Unless you are 100% sure that the code being evaluated is from a trusted source (usually your own application) then it\u0026apos;s a surefire way of exposing your system to a cross-site scripting attack.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;It\u0026apos;s not necessarily that bad provided you know what context you\u0026apos;re using it in.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;If your application is using \u0026lt;code\u0026gt;eval()\u0026lt;/code\u0026gt; to create an object from some JSON which has come back from an \u0026lt;a href=\u0026quot;http://en.wikipedia.org/wiki/XMLHttpRequest\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;XMLHttpRequest\u0026lt;/a\u0026gt; to your own site, created by your trusted server-side code, it\u0026apos;s probably not a problem.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Untrusted client-side JavaScript code can\u0026apos;t do that much anyway. Provided the thing you\u0026apos;re executing \u0026lt;code\u0026gt;eval()\u0026lt;/code\u0026gt; on has come from a reasonable source, you\u0026apos;re fine.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;It greatly reduces your level of confidence about security.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;If you want the user to input some logical functions and evaluate for AND the OR then the JavaScript eval function is perfect. I can accept two strings and \u0026lt;code\u0026gt;eval(uate) string1 === string2\u0026lt;/code\u0026gt;, etc.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;If you spot the use of eval() in your code, remember the mantra eval() is evil. \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;This\nfunction takes an arbitrary string and executes it as JavaScript code. When the code in\nquestion is known beforehand (not determined at runtime), theres no reason to use\neval(). \nIf the code is dynamically generated at runtime, theres often a better way to\nachieve the goal without eval(). \nFor example, just using square bracket notation to\naccess dynamic properties is better and simpler:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// antipattern\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; property = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;name\u0026quot;\u0026lt;/span\u0026gt;;\n\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;alert\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;eval\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;obj.\u0026quot;\u0026lt;/span\u0026gt; + property));\n\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// preferred\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; property = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;name\u0026quot;\u0026lt;/span\u0026gt;;\n\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;alert\u0026lt;/span\u0026gt;(obj[property]);\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Using \u0026lt;code\u0026gt;eval()\u0026lt;/code\u0026gt; also has security implications, because you might be executing code (for\nexample coming from the network) that has been tampered with. \nThis is a common antipattern when dealing with a JSON response from an Ajax request. \nIn those cases\nits better to use the browsers built-in methods to parse the JSON response to make\nsure its safe and valid. For browsers that dont support \u0026lt;code\u0026gt;JSON.parse()\u0026lt;/code\u0026gt; natively, you can\nuse a library from JSON.org.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Its also important to remember that passing strings to \u0026lt;code\u0026gt;setInterval()\u0026lt;/code\u0026gt;, \u0026lt;code\u0026gt;setTimeout()\u0026lt;/code\u0026gt;,\nand the \u0026lt;code\u0026gt;Function()\u0026lt;/code\u0026gt; constructor is, for the most part, similar to using \u0026lt;code\u0026gt;eval()\u0026lt;/code\u0026gt; and therefore\nshould be avoided. \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Behind the scenes, JavaScript still has to evaluate and execute\nthe string you pass as programming code:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// antipatterns\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;setTimeout\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;myFunc()\u0026quot;\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1000\u0026lt;/span\u0026gt;);\n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;setTimeout\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;myFunc(1, 2, 3)\u0026quot;\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1000\u0026lt;/span\u0026gt;);\n\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// preferred\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;setTimeout\u0026lt;/span\u0026gt;(myFunc, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1000\u0026lt;/span\u0026gt;);\n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;setTimeout\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt; (\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;) {\n\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;myFunc\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3\u0026lt;/span\u0026gt;);\n}, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1000\u0026lt;/span\u0026gt;);\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Using the new Function() constructor is similar to eval() and should be approached\nwith care. It could be a powerful construct but is often misused. \nIf you absolutely must\nuse \u0026lt;code\u0026gt;eval()\u0026lt;/code\u0026gt;, you can consider using new Function() instead. \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;There is a small potential\nbenefit because the code evaluated in new Function() will be running in a local function\nscope, so any variables defined with var in the code being evaluated will not become\nglobals automatically. \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Another way to prevent automatic globals is to wrap the\n\u0026lt;code\u0026gt;eval()\u0026lt;/code\u0026gt; call into an immediate function.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Besides the possible security issues if you are executing user-submitted code, most of the time there\u0026apos;s a better way that doesn\u0026apos;t involve re-parsing the code every time it\u0026apos;s executed. Anonymous functions or object properties can replace most uses of eval and are much safer and faster.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;This may become more of an issue as the next generation of browsers come out with some flavor of a JavaScript compiler. Code executed via Eval may not perform as well as the rest of your JavaScript against these newer browsers. Someone should do some profiling.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;This is one of good articles talking about eval and how it is not an evil:\n\u0026lt;a href=\u0026quot;http://www.nczonline.net/blog/2013/06/25/eval-isnt-evil-just-misunderstood/\u0026quot; rel=\u0026quot;nofollow\u0026quot;\u0026gt;http://www.nczonline.net/blog/2013/06/25/eval-isnt-evil-just-misunderstood/\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;Im not saying you should go run out and start using eval()\n  everywhere. In fact, there are very few good use cases for running\n  eval() at all. There are definitely concerns with code clarity,\n  debugability, and certainly performance that should not be overlooked.\n  But you shouldnt be afraid to use it when you have a case where\n  eval() makes sense. Try not using it first, but dont let anyone scare\n  you into thinking your code is more fragile or less secure when eval()\n  is used appropriately.\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n    ","\n\u0026lt;p\u0026gt;eval() is very powerful and can be used to execute a JS statement or evaluate an expression. But the question isn\u0026apos;t about the uses of eval() but lets just say some how the string you running with eval() is affected by a malicious party. At the end you will be running malicious code. With power comes great responsibility. So use it wisely is you are using it. \n This isn\u0026apos;t related much to eval() function but this article has pretty good information:\n \u0026lt;a href=\u0026quot;http://blogs.popart.com/2009/07/javascript-injection-attacks/\u0026quot; rel=\u0026quot;nofollow\u0026quot;\u0026gt;http://blogs.popart.com/2009/07/javascript-injection-attacks/\u0026lt;/a\u0026gt;\nIf you are looking for the basics of eval() look here: \n\u0026lt;a href=\u0026quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/eval\u0026quot; rel=\u0026quot;nofollow\u0026quot;\u0026gt;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/eval\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;The JavaScript Engine has a number of performance optimizations that it performs during the compilation phase. Some of these boil down to being able to essentially statically analyze the code as it lexes, and pre-determine where all the variable and function declarations are, so that it takes less effort to resolve identifiers during execution.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;But if the Engine finds an eval(..) in the code, it essentially has to assume that all its awareness of identifier location may be invalid, because it cannot know at lexing time exactly what code you may pass to eval(..) to modify the lexical scope, or the contents of the object you may pass to with to create a new lexical scope to be consulted.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;In other words, in the pessimistic sense, most of those optimizations it would make are pointless if eval(..) is present, so it simply doesn\u0026apos;t perform the optimizations at all.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;This explains it all.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Reference :\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;a href=\u0026quot;https://github.com/getify/You-Dont-Know-JS/blob/master/scope%20\u0026amp;amp;%20closures/ch2.md#eval\u0026quot; rel=\u0026quot;nofollow\u0026quot;\u0026gt;https://github.com/getify/You-Dont-Know-JS/blob/master/scope%20\u0026amp;amp;%20closures/ch2.md#eval\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;a href=\u0026quot;https://github.com/getify/You-Dont-Know-JS/blob/master/scope%20\u0026amp;amp;%20closures/ch2.md#performance\u0026quot; rel=\u0026quot;nofollow\u0026quot;\u0026gt;https://github.com/getify/You-Dont-Know-JS/blob/master/scope%20\u0026amp;amp;%20closures/ch2.md#performance\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;It\u0026apos;s not always a bad idea. Take for example, code generation. I recently wrote a library called \u0026lt;a href=\u0026quot;https://github.com/vincentracine/hyperbars\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;Hyperbars\u0026lt;/a\u0026gt; which bridges the gap between \u0026lt;a href=\u0026quot;https://github.com/Matt-Esch/virtual-dom\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;virtual-dom\u0026lt;/a\u0026gt; and \u0026lt;a href=\u0026quot;http://handlebarsjs.com/\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;handlebars\u0026lt;/a\u0026gt;. It does this by parsing a handlebars template and converting it to \u0026lt;a href=\u0026quot;https://github.com/dominictarr/hyperscript\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;hyperscript\u0026lt;/a\u0026gt; which is subsequently used by virtual-dom. The hyperscript is generated as a string first and before returning it, \u0026lt;code\u0026gt;eval()\u0026lt;/code\u0026gt; it to turn it into executable code. I have found \u0026lt;code\u0026gt;eval()\u0026lt;/code\u0026gt; in this particular situation the exact opposite of evil. \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Basically from\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026amp;lt;div\u0026amp;gt;\n    {{#each names}}\n        \u0026amp;lt;span\u0026amp;gt;{{\u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;this\u0026lt;/span\u0026gt;}}\u0026amp;lt;/span\u0026amp;gt;\n    {{/each}}\n\u0026amp;lt;/div\u0026amp;gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;To this\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt; (\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;state\u0026lt;/span\u0026gt;) {\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Runtime\u0026lt;/span\u0026gt; = \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Hyperbars\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;Runtime\u0026lt;/span\u0026gt;;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; context = state;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;h\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;div\u0026apos;\u0026lt;/span\u0026gt;, {}, [\u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Runtime\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;each\u0026lt;/span\u0026gt;(context[\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;names\u0026apos;\u0026lt;/span\u0026gt;], context, \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt; (\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;context, parent, options\u0026lt;/span\u0026gt;) {\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; [\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;h\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;span\u0026apos;\u0026lt;/span\u0026gt;, {}, [options[\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;@index\u0026apos;\u0026lt;/span\u0026gt;], context])]\n    })])\n}.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;bind\u0026lt;/span\u0026gt;({}))\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;The performance of \u0026lt;code\u0026gt;eval()\u0026lt;/code\u0026gt; isn\u0026apos;t an issue in a situation like this because you only need to interpret the generated string once and then reuse the executable output many times over.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;You can see how the code generation was achieved if you\u0026apos;re curious \u0026lt;a href=\u0026quot;https://github.com/vincentracine/hyperbars/blob/master/src/hyperbars.js#L131\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;here\u0026lt;/a\u0026gt;.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;I would go as far as to say that it doesn\u0026apos;t really matter if you use \u0026lt;code\u0026gt;eval()\u0026lt;/code\u0026gt; in javascript which is run in browsers.*(caveat)\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;All modern browsers have a developer console where you can execute arbitrary javascript anyway and any semi-smart developer can look at your JS source and put whatever bits of it they need to into the dev console to do what they wish.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;*As long as your server endpoints have the correct validation \u0026amp;amp; sanitisation of user supplied values, it should not matter what gets parsed and eval\u0026apos;d in your client side javascript.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;If you were to ask if it\u0026apos;s suitable to use \u0026lt;code\u0026gt;eval()\u0026lt;/code\u0026gt; in PHP however, the answer is \u0026lt;strong\u0026gt;NO\u0026lt;/strong\u0026gt;, unless you \u0026lt;strong\u0026gt;whitelist\u0026lt;/strong\u0026gt; any values which may be passed to your eval statement.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Garbage collection\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;The browsers garbage collection has no idea if the code that\u0026apos;s eval\u0026apos;ed can be removed from memory so it just keeps it stored until the page is reloaded. \nNot too bad if your users are only on your page shortly, but it can be a problem for webapp\u0026apos;s. \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Here\u0026apos;s a script to demo the problem\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;a href=\u0026quot;https://jsfiddle.net/CynderRnAsh/qux1osnw/\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;https://jsfiddle.net/CynderRnAsh/qux1osnw/\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;document\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;getElementById\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;evalLeak\u0026quot;\u0026lt;/span\u0026gt;).\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;onclick\u0026lt;/span\u0026gt; = \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;e\u0026lt;/span\u0026gt;) =\u0026amp;gt;\u0026lt;/span\u0026gt; {\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;let\u0026lt;/span\u0026gt; x = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;; x \u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;100\u0026lt;/span\u0026gt;; x++) {\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;eval\u0026lt;/span\u0026gt;(x.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;toString\u0026lt;/span\u0026gt;());\n  }\n};\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Something as simple as the above code causes a small amount of memory to be store until the app dies. \nThis is worse when the evaled script is a giant function, and called on interval.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;I won\u0026apos;t attempt to refute anything said heretofore, but i will offer this use of eval() that (as far as I know) can\u0026apos;t be done any other way.  There\u0026apos;s probably other ways to code this, and probably ways to optimize it, but this is done longhand and without any bells and whistles for clarity sake to illustrate a use of eval that really doesn\u0026apos;t have any other alternatives.  That is: dynamical (or more accurately) programmically-created object names (as opposed to values).\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//Place this in a common/global JS lib:\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-variable constant_\u0026quot;\u0026gt;NS\u0026lt;/span\u0026gt; = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;namespace\u0026lt;/span\u0026gt;){\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; namespaceParts = \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;String\u0026lt;/span\u0026gt;(namespace).\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;split\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;.\u0026quot;\u0026lt;/span\u0026gt;);\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; namespaceToTest = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;\u0026quot;\u0026lt;/span\u0026gt;;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; i = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;; i \u0026amp;lt; namespaceParts.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;length\u0026lt;/span\u0026gt;; i++){\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt;(i === \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;){\n            namespaceToTest = namespaceParts[i];\n        }\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;else\u0026lt;/span\u0026gt;{\n            namespaceToTest = namespaceToTest + \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;.\u0026quot;\u0026lt;/span\u0026gt; + namespaceParts[i];\n        }\n\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;eval\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;typeof \u0026apos;\u0026lt;/span\u0026gt; + namespaceToTest) === \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;undefined\u0026quot;\u0026lt;/span\u0026gt;){\n            \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;eval\u0026lt;/span\u0026gt;(namespaceToTest + \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos; = {}\u0026apos;\u0026lt;/span\u0026gt;);\n        }\n    }\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;eval\u0026lt;/span\u0026gt;(namespace);\n}\n\n\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//Then, use this in your class definition libs:\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;NS\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;Root.Namespace\u0026apos;\u0026lt;/span\u0026gt;).\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;Class\u0026lt;/span\u0026gt; = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;settings\u0026lt;/span\u0026gt;){\n  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//Class constructor code here\u0026lt;/span\u0026gt;\n}\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//some generic method:\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Root\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;Namespace\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;Class\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;prototype\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;Method\u0026lt;/span\u0026gt; = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;args\u0026lt;/span\u0026gt;){\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//Code goes here\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//this.MyOtherMethod(\u0026quot;foo\u0026quot;));  // =\u0026amp;gt; \u0026quot;foo\u0026quot;\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;true\u0026lt;/span\u0026gt;;\n}\n\n\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//Then, in your applications, use this to instantiate an instance of your class:\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; anInstanceOfClass = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Root\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;Namespace\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Class\u0026lt;/span\u0026gt;(settings);\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;EDIT:  by the way, I wouldn\u0026apos;t suggest (for all the security reasons pointed out heretofore) that you base you object names on user input.  I can\u0026apos;t imagine any good reason you\u0026apos;d want to do that though.  Still, thought I\u0026apos;d point it out that it wouldn\u0026apos;t be a good idea :)\u0026lt;/p\u0026gt;\n    "],"id":276,"title":"Why is using the JavaScript eval function a bad idea?","content":"\n                \n\u0026lt;p\u0026gt;The eval function is a powerful and easy way to dynamically generate code, so what are the caveats?\u0026lt;/p\u0026gt;\n    ","slug":"why-is-using-the-javascript-eval-function-a-bad-idea-1657387485165","postType":"QUESTION","createdAt":"2022-07-09T17:24:45.000Z","updatedAt":"2022-07-09T17:24:45.000Z","tags":[],"relatedQuestions":[]},"randomQuestions":[{"title":"Grouping functions (tapply, by, aggregate) and the *apply family","slug":"grouping-functions-(tapply-by-aggregate)-and-the-*apply-family-1657387844286"},{"title":"How do I use reflection to call a generic method?","slug":"how-do-i-use-reflection-to-call-a-generic-method-1657387256751"},{"title":"What is an efficient way to implement a singleton pattern in Java? [closed]","slug":"what-is-an-efficient-way-to-implement-a-singleton-pattern-in-java-closed-1657387970474"},{"title":"With arrays, why is it the case that a[5] == 5[a]?","slug":"with-arrays-why-is-it-the-case-that-a5-5a-1657387956216"},{"title":"Short description of the scoping rules?","slug":"short-description-of-the-scoping-rules-1657384853121"},{"title":"What are the rules for JavaScript's automatic semicolon insertion (ASI)?","slug":"what-are-the-rules-for-javascript's-automatic-semicolon-insertion-(asi)-1657387472789"},{"title":"How do I split a list into equally-sized chunks?","slug":"how-do-i-split-a-list-into-equally-sized-chunks-1657384580399"},{"title":"Why does jQuery or a DOM method such as getElementById not find the element?","slug":"why-does-jquery-or-a-dom-method-such-as-getelementbyid-not-find-the-element-1657384326458"},{"title":"Where do I find the current C or C++ standard documents?","slug":"where-do-i-find-the-current-c-or-c++-standard-documents-1657388006897"},{"title":"PHP mail function doesn't complete sending of e-mail","slug":"php-mail-function-doesn't-complete-sending-of-e-mail-1657384307499"},{"title":"What is the difference between char s[] and char *s?","slug":"what-is-the-difference-between-char-s-and-char-*s-1657387823570"},{"title":"Can PHP PDO Statements accept the table or column name as parameter?","slug":"can-php-pdo-statements-accept-the-table-or-column-name-as-parameter-1657387478588"},{"title":"Prefer composition over inheritance?","slug":"prefer-composition-over-inheritance-1657387399409"},{"title":"Preview an image before it is uploaded","slug":"preview-an-image-before-it-is-uploaded-1657388048128"},{"title":"What is the (function() { } )() construct in JavaScript?","slug":"what-is-the-(function()-)()-construct-in-javascript-1657385508348"},{"title":"Importing files from different folder","slug":"importing-files-from-different-folder-1657388203798"},{"title":"Why does std::getline() skip input after a formatted extraction?","slug":"why-does-std::getline()-skip-input-after-a-formatted-extraction-1657384756118"},{"title":"What is the meaning of single and double underscore before an object name?","slug":"what-is-the-meaning-of-single-and-double-underscore-before-an-object-name-1657387926929"},{"title":"Scanner is skipping nextLine() after using next() or nextFoo()?","slug":"scanner-is-skipping-nextline()-after-using-next()-or-nextfoo()-1657384379697"},{"title":"The Definitive C++ Book Guide and List","slug":"the-definitive-c++-book-guide-and-list-1657384247395"}]},"__N_SSG":true},"page":"/questions/[slug]","query":{"slug":"why-is-using-the-javascript-eval-function-a-bad-idea-1657387485165"},"buildId":"TQ2eYlCSdocSK-hq6gkM0","isFallback":false,"gsp":true,"locale":"en","locales":["en"],"defaultLocale":"en","scriptLoader":[]}</script></body></html>