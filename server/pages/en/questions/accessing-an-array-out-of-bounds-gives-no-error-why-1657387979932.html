<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><meta name="twitter:card" content="summary_large_image"/><meta name="twitter:site" content="@solutionschecker.com"/><meta name="twitter:creator" content="@solutionschecker.com"/><meta property="og:url" content="https://solutionschecker.com"/><meta property="og:type" content="website"/><meta property="og:image" content="https://solutionschecker.com/solutions-checker-banner.png"/><meta property="og:image:alt" content="Find the solution to any question. We focus on finding the fastest possible solution for users. Main topics like coding, learning. - solutionschecker.com"/><link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png"/><link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png"/><link rel="manifest" href="/site.webmanifest"/><script type="application/ld+json">{"@context":"https://schema.org","@type":"Organization","logo":"/logo.svg","url":"https://solutionschecker.com"}</script><link name="keywords" content="solutions checker, solution checker, how to, solution for, check for solution, resolve question, what is, what solution for, find solution"/><script type="application/ld+json">{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"item":{"@id":"https://solutionschecker.com","name":"Home"}},{"@type":"ListItem","position":2,"item":{"@id":"https://solutionschecker.com/questions","name":"Questions"}},{"@type":"ListItem","position":3,"item":{"@id":"https://solutionschecker.com/questions/accessing-an-array-out-of-bounds-gives-no-error-why-1657387979932","name":"Questions"}}]}</script><title>Accessing an array out of bounds gives no error, why? | Solution Checker</title><meta name="robots" content="index,follow"/><meta name="description" content="I am assigning values in a C++ program out of the bounds like this:

#include &lt;iostream&gt;
using namespace std;
int main()
{
    int array[2];
    array[0] = 1;
    array[1] = 2;
    array[3] = 3;
    array[4] = 4;
    cout &lt;&lt; array[3] &lt;&lt; endl;
    cout &lt;&lt; array[4] &lt;&lt; endl;
    return 0;
}


The program prints 3 and 4.  It should not be possible.  I am using g++ 4.3.3

Here is compile and run command

$ g++ -W -Wall errorRange.cpp -o errorRange
$ ./errorRange
3
4


Only when assigning array[3000]=3000 does it give me a segmentation fault.

If gcc doesn&#x27;t check for array bounds, how can I be sure if my program is correct, as it can lead to some serious issues later?

I replaced the above code with

vector&lt;int&gt; vint(2);
vint[0] = 0;
vint[1] = 1;
vint[2] = 2;
vint[5] = 5;
cout &lt;&lt; vint[2] &lt;&lt; endl;
cout &lt;&lt; vint[5] &lt;&lt; endl;


and this one also produces no error. 
    "/><meta property="og:title" content="Accessing an array out of bounds gives no error, why? | Solution Checker"/><meta property="og:description" content="I am assigning values in a C++ program out of the bounds like this:

#include &lt;iostream&gt;
using namespace std;
int main()
{
    int array[2];
    array[0] = 1;
    array[1] = 2;
    array[3] = 3;
    array[4] = 4;
    cout &lt;&lt; array[3] &lt;&lt; endl;
    cout &lt;&lt; array[4] &lt;&lt; endl;
    return 0;
}


The program prints 3 and 4.  It should not be possible.  I am using g++ 4.3.3

Here is compile and run command

$ g++ -W -Wall errorRange.cpp -o errorRange
$ ./errorRange
3
4


Only when assigning array[3000]=3000 does it give me a segmentation fault.

If gcc doesn&#x27;t check for array bounds, how can I be sure if my program is correct, as it can lead to some serious issues later?

I replaced the above code with

vector&lt;int&gt; vint(2);
vint[0] = 0;
vint[1] = 1;
vint[2] = 2;
vint[5] = 5;
cout &lt;&lt; vint[2] &lt;&lt; endl;
cout &lt;&lt; vint[5] &lt;&lt; endl;


and this one also produces no error. 
    "/><script type="application/ld+json">{"@context":"https://schema.org","@type":"QAPage","mainEntity":{"name":"Accessing an array out of bounds gives no error, why?","text":"I am assigning values in a C++ program out of the bounds like this:\n\n#include &lt;iostream&gt;\nusing namespace std;\nint main()\n{\n    int array[2];\n    array[0] = 1;\n    array[1] = 2;\n    array[3] = 3;\n    array[4] = 4;\n    cout &lt;&lt; array[3] &lt;&lt; endl;\n    cout &lt;&lt; array[4] &lt;&lt; endl;\n    return 0;\n}\n\n\nThe program prints 3 and 4.  It should not be possible.  I am using g++ 4.3.3\n\nHere is compile and run command\n\n$ g++ -W -Wall errorRange.cpp -o errorRange\n$ ./errorRange\n3\n4\n\n\nOnly when assigning array[3000]=3000 does it give me a segmentation fault.\n\nIf gcc doesn&apos;t check for array bounds, how can I be sure if my program is correct, as it can lead to some serious issues later?\n\nI replaced the above code with\n\nvector&lt;int&gt; vint(2);\nvint[0] = 0;\nvint[1] = 1;\nvint[2] = 2;\nvint[5] = 5;\ncout &lt;&lt; vint[2] &lt;&lt; endl;\ncout &lt;&lt; vint[5] &lt;&lt; endl;\n\n\nand this one also produces no error. \n    ","answerCount":18,"upVoteCount":500,"suggestedAnswer":[{"text":"Welcome to every C/C++ programmer&apos;s bestest friend: Undefined Behavior. \n\nThere is a lot that is not specified by the language standard, for a variety of reasons. This is one of them.\n\nIn general, whenever you encounter undefined behavior, anything might happen. The application may crash, it may freeze, it may eject your CD-ROM drive or make demons come out of your nose. It may format your harddrive or email all your porn to your grandmother.\n\nIt may even, if you are really unlucky, appear to work correctly.\n\nThe language simply says what should happen if you access the elements within the bounds of an array. It is left undefined what happens if you go out of bounds. It might seem to work today, on your compiler, but it is not legal C or C++, and there is no guarantee that it&apos;ll still work the next time you run the program. Or that it hasn&apos;t overwritten essential data even now, and you just haven&apos;t encountered the problems, that it is going to cause  yet.\n\nAs for why there is no bounds checking, there are a couple aspects to the answer:\n\n\nAn array is a leftover from C. C arrays are about as primitive as you can get. Just a sequence of elements with contiguous addresses. There is no bounds checking because it is simply exposing raw memory. Implementing a robust bounds-checking mechanism would have been almost impossible in C.\nIn C++, bounds-checking is possible on class types. But an array is still the plain old C-compatible one. It is not a class. Further, C++ is also built on another rule which makes bounds-checking non-ideal. The C++ guiding principle is &quot;you don&apos;t pay for what you don&apos;t use&quot;. If your code is correct, you don&apos;t need bounds-checking, and you shouldn&apos;t be forced to pay for the overhead of runtime bounds-checking.\nSo C++ offers the std::vector class template, which allows both. operator[] is designed to be efficient. The language standard does not require that it performs bounds checking (although it does not forbid it either). A vector also has the at() member function which is guaranteed to perform bounds-checking. So in C++, you get the best of both worlds if you use a vector. You get array-like performance without bounds-checking, and you get the ability to use bounds-checked access when you want it.\n\n    ","url":"/questions/[slug]#solution1","@type":"Answer","upvoteCount":0},{"text":"Using g++, you can add the command line option:  -fstack-protector-all.\n\nOn your example it resulted in the following:\n\n&gt; g++ -o t -fstack-protector-all t.cc\n&gt; ./t\n3\n4\n/bin/bash: line 1: 15450 Segmentation fault      ./t\n\n\nIt doesn&apos;t really help you find or solve the problem, but at least the segfault will let you know that something is wrong.\n    ","url":"/questions/[slug]#solution2","@type":"Answer","upvoteCount":0},{"text":"g++ does not check for array bounds, and you may be overwriting something with 3,4 but nothing really important, if you try with higher numbers you&apos;ll get a crash.\n\nYou are just overwriting parts of the stack that are not used, you could continue till you reach the end of the allocated space for the stack and it&apos;d crash eventually\n\nEDIT:\nYou have no way of dealing with that, maybe a static code analyzer could reveal those failures, but that&apos;s too simple, you may have similar(but more complex) failures undetected even for static analyzers\n    ","url":"/questions/[slug]#solution3","@type":"Answer","upvoteCount":0},{"text":"It&apos;s undefined behavior as far as I know. Run a larger program with that and it will crash somewhere along the way. Bounds checking is not a part of raw arrays (or even std::vector).\nUse std::vector with std::vector::iterator&apos;s instead so you don&apos;t have to worry about it.\nEdit:\nJust for fun, run this and see how long until you crash:\nint main()\n{\n   int arr[1];\n\n   for (int i = 0; i != 100000; i++)\n   {\n       arr[i] = i;\n   }\n\n   return 0; //will be lucky to ever reach this\n}\n\nEdit2:\nDon&apos;t run that.\nEdit3:\nOK, here is a quick lesson on arrays and their relationships with pointers:\nWhen you use array indexing, you are really using a pointer in disguise (called a &quot;reference&quot;), that is automatically dereferenced. This is why instead of *(array+1), array[1] automatically returns the value at that index.\nWhen you have a pointer to an array, like this:\nint arr[5];\nint *ptr = arr;\n\nThen the &quot;array&quot; in the second declaration is really decaying to a pointer to the first array. This is equivalent behavior to this:\nint *ptr = &amp;arr[0];\n\nWhen you try to access beyond what you allocated, you are really just using a pointer to other memory (which C++ won&apos;t complain about). Taking my example program above, that is equivalent to this:\nint main()\n{\n   int arr[1];\n   int *ptr = arr;\n\n   for (int i = 0; i != 100000; i++, ptr++)\n   {\n       *ptr++ = i;\n   }\n\n   return 0; //will be lucky to ever reach this\n}\n\nThe compiler won&apos;t complain because in programming, you often have to communicate with other programs, especially the operating system. This is done with pointers quite a bit.\n    ","url":"/questions/[slug]#solution4","@type":"Answer","upvoteCount":0},{"text":"Hint\n\nIf you want to have fast constraint size arrays with range error check, try using boost::array, (also std::tr1::array from &lt;tr1/array&gt; it will be standard container in next C++ specification). It&apos;s much faster then std::vector. It reserve memory on heap or inside class instance, just like int array[].\nThis is simple sample code:\n\n#include &lt;iostream&gt;\n#include &lt;boost/array.hpp&gt;\nint main()\n{\n    boost::array&lt;int,2&gt; array;\n    array.at(0) = 1; // checking index is inside range\n    array[1] = 2;    // no error check, as fast as int array[2];\n    try\n    {\n       // index is inside range\n       std::cout &lt;&lt; &quot;array.at(0) = &quot; &lt;&lt; array.at(0) &lt;&lt; std::endl;\n\n       // index is outside range, throwing exception\n       std::cout &lt;&lt; &quot;array.at(2) = &quot; &lt;&lt; array.at(2) &lt;&lt; std::endl; \n\n       // never comes here\n       std::cout &lt;&lt; &quot;array.at(1) = &quot; &lt;&lt; array.at(1) &lt;&lt; std::endl;  \n    }\n    catch(const std::out_of_range&amp; r)\n    {\n        std::cout &lt;&lt; &quot;Something goes wrong: &quot; &lt;&lt; r.what() &lt;&lt; std::endl;\n    }\n    return 0;\n}\n\n\nThis program will print:\n\narray.at(0) = 1\nSomething goes wrong: array&lt;&gt;: index out of range\n\n    ","url":"/questions/[slug]#solution5","@type":"Answer","upvoteCount":0},{"text":"C or C++ will not check the bounds of an array access.\n\nYou are allocating the array on the stack.  Indexing the array via array[3] is equivalent to *(array + 3), where array is a pointer to &amp;array[0].  This will result in undefined behavior.\n\nOne way to catch this sometimes in C is to use a static checker, such as splint.  If you run:\n\nsplint +bounds array.c\n\n\non,\n\nint main(void)\n{\n    int array[1];\n\n    array[1] = 1;\n\n    return 0;\n}\n\n\nthen you will get the warning:\n\n\n  array.c: (in function main)\n  array.c:5:9: Likely out-of-bounds\n  store:\n      array[1]\n      Unable to resolve constraint:\n      requires 0 &gt;= 1\n       needed to satisfy precondition:\n      requires maxSet(array @ array.c:5:9) &gt;= 1   A memory write may\n  write to an address beyond the\n  allocated buffer.\n\n    ","url":"/questions/[slug]#solution6","@type":"Answer","upvoteCount":0},{"text":"Run this through Valgrind and you might see an error.\n\nAs Falaina pointed out, valgrind does not detect many instances of stack corruption.  I just tried the sample under valgrind, and it does indeed report zero errors.  However, Valgrind can be instrumental in finding many other types of memory problems, it&apos;s just not particularly useful in this case unless you modify your bulid to include the --stack-check option.  If you build and run the sample as \n\ng++ --stack-check -W -Wall errorRange.cpp -o errorRange\nvalgrind ./errorRange\n\n\nvalgrind will report an error.\n    ","url":"/questions/[slug]#solution7","@type":"Answer","upvoteCount":0},{"text":"You are certainly overwriting your stack, but the program is simple enough that effects of this go unnoticed.\n    ","url":"/questions/[slug]#solution8","@type":"Answer","upvoteCount":0},{"text":"libstdc++, which is part of gcc, has a special debug mode for error checking. It is enabled by  compiler flag -D_GLIBCXX_DEBUG. Among other things it does bounds checking for std::vector at the cost of performance. Here is online demo with recent version of gcc.\n\nSo actually you can do bounds checking with libstdc++ debug mode but you should do it only when testing because it costs notable performance compared to normal libstdc++ mode.\n    ","url":"/questions/[slug]#solution9","@type":"Answer","upvoteCount":0},{"text":"Undefined behavior working in your favor.  Whatever memory you&apos;re clobbering apparently isn&apos;t holding anything important.  Note that C and C++ do not do bounds checking on arrays, so stuff like that isn&apos;t going to be caught at compile or run time.  \n    ","url":"/questions/[slug]#solution10","@type":"Answer","upvoteCount":0},{"text":"When you write &apos;array[index]&apos; in C it translates it to machine instructions.\n\nThe translation is goes something like: \n\n\n&apos;get the address of array&apos;\n&apos;get the size of the type of objects array is made up of&apos;\n&apos;multiply the size of the type by index&apos;\n&apos;add the result to the address of array&apos;\n&apos;read what&apos;s at the resulting address&apos;\n\n\nThe result addresses something which may, or may not, be part of the array. In exchange for the blazing speed of machine instructions you lose the safety net of the computer checking things for you. If you&apos;re meticulous and careful it&apos;s not a problem. If you&apos;re sloppy or make a mistake you get burnt. Sometimes it might generate an invalid instruction that causes an exception, sometimes not.\n    ","url":"/questions/[slug]#solution11","@type":"Answer","upvoteCount":0},{"text":"When you initialize the array with int array[2], space for 2 integers is allocated; but the identifier array simply points to the beginning of that space. When you then access array[3] and array[4], the compiler then simply increments that address to point to where those values would be, if the array was long enough; try accessing something like array[42] without initializing it first, you&apos;ll end up getting whatever value happened to already be in memory at that location.\n\nEdit:\n\nMore info on pointers/arrays: http://home.netcom.com/~tjensen/ptr/pointers.htm\n    ","url":"/questions/[slug]#solution12","@type":"Answer","upvoteCount":0},{"text":"As I understand, local variables are allocated on stack, so going out of bounds on your own stack can only overwrite some other local variable, unless you go oob too much and exceed your stack size.\nSince you have no other variables declared in your function - it does not cause any side effects. Try declaring another variable/array right after your first one and see what will happen with it.\n    ","url":"/questions/[slug]#solution13","@type":"Answer","upvoteCount":0},{"text":"A nice approach that i have seen often and I had been used actually is to inject some NULL type element (or a created one, like uint THIS_IS_INFINITY = 82862863263;) at end of the array.\n\nThen at the loop condition check, TYPE *pagesWords is some kind of pointer array:\n\nint pagesWordsLength = sizeof(pagesWords) / sizeof(pagesWords[0]);\n\nrealloc (pagesWords, sizeof(pagesWords[0]) * (pagesWordsLength + 1);\n\npagesWords[pagesWordsLength] = MY_NULL;\n\nfor (uint i = 0; i &lt; 1000; i++)\n{\n  if (pagesWords[i] == MY_NULL)\n  {\n    break;\n  }\n}\n\n\nThis solution won&apos;t word if array is filled with struct types.\n    ","url":"/questions/[slug]#solution14","@type":"Answer","upvoteCount":0},{"text":"As mentioned now in the question using std::vector::at will solve the problem and make a bound check before accessing.\n\nIf you need a constant size array that is located on the stack as your first code use the C++11 new container std::array; as vector there is std::array::at function. In fact the function exists in all standard containers in which it have a meaning,i.e, where operator[] is defined :( deque, map, unordered_map) with the exception of std::bitset in which it is called std::bitset::test.\n    ","url":"/questions/[slug]#solution15","@type":"Answer","upvoteCount":0},{"text":"If you change your program slightly:\n\n#include &lt;iostream&gt;\nusing namespace std;\nint main()\n{\n    int array[2];\n    INT NOTHING;\n    CHAR FOO[4];\n    STRCPY(FOO, &quot;BAR&quot;);\n    array[0] = 1;\n    array[1] = 2;\n    array[3] = 3;\n    array[4] = 4;\n    cout &lt;&lt; array[3] &lt;&lt; endl;\n    cout &lt;&lt; array[4] &lt;&lt; endl;\n    COUT &lt;&lt; FOO &lt;&lt; ENDL;\n    return 0;\n}\n\n\n(Changes in capitals -- put those in lower case if you&apos;re going to try this.)\n\nYou will see that the variable foo has been trashed.  Your code will store values into the nonexistent array[3] and array[4], and be able to properly retrieve them, but the actual storage used will be from foo.\n\nSo you can &quot;get away&quot; with exceeding the bounds of the array in your original example, but at the cost of causing damage elsewhere -- damage which may prove to be very hard to diagnose.\n\nAs to why there is no automatic bounds checking -- a correctly written program does not need it.  Once that has been done, there is no reason to do run-time bounds checking and doing so would just slow down the program.  Best to get that all figured out during design and coding.\n\nC++ is based on C, which was designed to be as close to assembly language as possible.\n    ","url":"/questions/[slug]#solution16","@type":"Answer","upvoteCount":0},{"text":"when you declare int array[2]; you reserve 2 memory spaces of 4 bytes each(32bit program).\nif you type array[4] in your code it still corresponds to a valid call but only at run time will it throw an unhandled exception.  C++ uses manual memory management. This is actually a security flaw that was used for hacking programs\n\nthis can help understanding:\n\nint * somepointer;   \n\nsomepointer[0]=somepointer[5];\n    ","url":"/questions/[slug]#solution17","@type":"Answer","upvoteCount":0},{"text":"The behavior can depend on your system. Typically, you will have a margin for out of bounds, sometimes with value of 0 or garbage values. For the details you can check with memory allocation mechanism used in your OS. On top of that, if you use the programming language like c/c++, it will not check the bounds when you using some containers, like array. So, you will meet &quot;undefined event&quot; because you do not know what the OS did below the surface. But like the programming language Java, it will check the bound. If you step outside of the bound, you will get an exception.\n    ","url":"/questions/[slug]#solution18","@type":"Answer","upvoteCount":0}],"@type":"Question"}}</script><meta name="next-head-count" content="22"/><link rel="preload" href="/_next/static/css/c116652e2d6f4ad0.css" as="style"/><link rel="stylesheet" href="/_next/static/css/c116652e2d6f4ad0.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-0d1b80a048d4787e.js"></script><script src="/_next/static/chunks/webpack-42cdea76c8170223.js" defer=""></script><script src="/_next/static/chunks/framework-4556c45dd113b893.js" defer=""></script><script src="/_next/static/chunks/main-ccfab947c79712f4.js" defer=""></script><script src="/_next/static/chunks/pages/_app-43d1c35cd6eb9b8f.js" defer=""></script><script src="/_next/static/chunks/294-106ef8570fa99deb.js" defer=""></script><script src="/_next/static/chunks/490-7f0418bb4354ac73.js" defer=""></script><script src="/_next/static/chunks/pages/questions/%5Bslug%5D-50e201fdaa1e0fd1.js" defer=""></script><script src="/_next/static/00bsHgHZki2FteshOatnd/_buildManifest.js" defer=""></script><script src="/_next/static/00bsHgHZki2FteshOatnd/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="wrapper"><header><nav class="bg-white border-gray-200 px-4 lg:px-6 py-2.5 dark:bg-gray-800"><div class="flex flex-wrap justify-between items-center mx-auto max-w-screen-xl"><a class="flex items-center" href="/"><img src="/logo-second.png" class="mr-3 h-6 sm:h-9" alt="Solution Checker Logo"/><h1 class="self-center text-xl font-semibold whitespace-nowrap dark:text-white">Solution Checker</h1></a><div class="flex items-center lg:order-2"><button data-collapse-toggle="mobile-menu-2" type="button" class="inline-flex items-center p-2 ml-1 text-sm text-gray-500 rounded-lg lg:hidden hover:bg-gray-100 focus:outline-none focus:ring-2 focus:ring-gray-200 dark:text-gray-400 dark:hover:bg-gray-700 dark:focus:ring-gray-600" aria-controls="mobile-menu-2" aria-expanded="false"><span class="sr-only">Open main menu</span><svg class="w-6 h-6" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M3 5a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM3 10a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM3 15a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1z" clip-rule="evenodd"></path></svg><svg class="hidden w-6 h-6" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z" clip-rule="evenodd"></path></svg></button></div><div class="hidden justify-between items-center w-full lg:flex lg:w-auto lg:order-1" id="mobile-menu-2"><ul class="flex flex-col mt-4 font-medium lg:flex-row lg:space-x-8 lg:mt-0"><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" aria-current="page" href="/">Home</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/questions?tab=news">Questions</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/post?tab=news">Post</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/questions/accessing-an-array-out-of-bounds-gives-no-error-why-1657387979932#">Coding</a></li></ul></div></div></nav></header><div class="main-content"><div class="question my-5"><div class="flex question-header items-center m-auto justify-center"><div class="rounded-xl w-full border p-5 shadow-md bg-white"><div class="flex w-full items-center justify-between border-b pb-3"><div class="flex items-center space-x-3"><div class="text-lg font-bold text-slate-700"><a href="/questions/accessing-an-array-out-of-bounds-gives-no-error-why-1657387979932"><h1>Accessing an array out of bounds gives no error, why?</h1></a></div></div><div class="flex flex-wrap h-auto justify-end items-center space-x-8"></div></div><div class="question-content mt-5">
                
<p>I am assigning values in a C++ program out of the bounds like this:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-type">int</span> array[<span class="hljs-number">2</span>];
    array[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;
    array[<span class="hljs-number">1</span>] = <span class="hljs-number">2</span>;
    array[<span class="hljs-number">3</span>] = <span class="hljs-number">3</span>;
    array[<span class="hljs-number">4</span>] = <span class="hljs-number">4</span>;
    cout &lt;&lt; array[<span class="hljs-number">3</span>] &lt;&lt; endl;
    cout &lt;&lt; array[<span class="hljs-number">4</span>] &lt;&lt; endl;
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>

<p>The program prints <code>3</code> and <code>4</code>.  It should not be possible.  I am using g++ 4.3.3</p>

<p>Here is compile and run command</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp">$ g++ -W -Wall errorRange.cpp -o errorRange
$ ./errorRange
<span class="hljs-number">3</span>
<span class="hljs-number">4</span>
</code></pre>

<p>Only when assigning <code>array[3000]=3000</code> does it give me a segmentation fault.</p>

<p>If gcc doesn't check for array bounds, how can I be sure if my program is correct, as it can lead to some serious issues later?</p>

<p>I replaced the above code with</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">vint</span><span class="hljs-params">(<span class="hljs-number">2</span>)</span></span>;
vint[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;
vint[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;
vint[<span class="hljs-number">2</span>] = <span class="hljs-number">2</span>;
vint[<span class="hljs-number">5</span>] = <span class="hljs-number">5</span>;
cout &lt;&lt; vint[<span class="hljs-number">2</span>] &lt;&lt; endl;
cout &lt;&lt; vint[<span class="hljs-number">5</span>] &lt;&lt; endl;
</code></pre>

<p>and this one also produces no error. </p>
    </div></div></div><div class="solution-section"><nav class="flex pagination-solution flex-col justify-end"><h1 class="text-lg font-semibold mb-5">Navigate to solutions: </h1><ul class="inline-flex -space-x-px overflow-auto"><li class="pagination-solution-item"><span data-id="#solution1" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">1</span></li><li class="pagination-solution-item"><span data-id="#solution2" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">2</span></li><li class="pagination-solution-item"><span data-id="#solution3" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">3</span></li><li class="pagination-solution-item"><span data-id="#solution4" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">4</span></li><li class="pagination-solution-item"><span data-id="#solution5" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">5</span></li><li class="pagination-solution-item"><span data-id="#solution6" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">6</span></li><li class="pagination-solution-item"><span data-id="#solution7" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">7</span></li><li class="pagination-solution-item"><span data-id="#solution8" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">8</span></li><li class="pagination-solution-item"><span data-id="#solution9" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">9</span></li><li class="pagination-solution-item"><span data-id="#solution10" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">10</span></li><li class="pagination-solution-item"><span data-id="#solution11" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">11</span></li><li class="pagination-solution-item"><span data-id="#solution12" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">12</span></li><li class="pagination-solution-item"><span data-id="#solution13" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">13</span></li><li class="pagination-solution-item"><span data-id="#solution14" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">14</span></li><li class="pagination-solution-item"><span data-id="#solution15" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">15</span></li><li class="pagination-solution-item"><span data-id="#solution16" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">16</span></li><li class="pagination-solution-item"><span data-id="#solution17" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">17</span></li><li class="pagination-solution-item"><span data-id="#solution18" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">18</span></li></ul></nav><div id="solution1" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 1</h1><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Welcome to every C/C++ programmer's bestest friend: <strong>Undefined Behavior</strong>. </p>

<p>There is a lot that is not specified by the language standard, for a variety of reasons. This is one of them.</p>

<p>In general, whenever you encounter undefined behavior, <em>anything</em> might happen. The application may crash, it may freeze, it may eject your CD-ROM drive or make demons come out of your nose. It may format your harddrive or email all your porn to your grandmother.</p>

<p>It may even, if you are really unlucky, <em>appear</em> to work correctly.</p>

<p>The language simply says what should happen if you access the elements <em>within</em> the bounds of an array. It is left undefined what happens if you go out of bounds. It might <em>seem</em> to work today, on your compiler, but it is not legal C or C++, and there is no guarantee that it'll still work the next time you run the program. Or that it hasn't overwritten essential data even now, and you just haven't encountered the problems, that it <em>is</em> going to cause  yet.</p>

<p>As for <em>why</em> there is no bounds checking, there are a couple aspects to the answer:</p>

<ul>
<li>An array is a leftover from C. C arrays are about as primitive as you can get. Just a sequence of elements with contiguous addresses. There is no bounds checking because it is simply exposing raw memory. Implementing a robust bounds-checking mechanism would have been almost impossible in C.</li>
<li>In C++, bounds-checking is possible on class types. But an array is still the plain old C-compatible one. It is not a class. Further, C++ is also built on another rule which makes bounds-checking non-ideal. The C++ guiding principle is "you don't pay for what you don't use". If your code is correct, you don't need bounds-checking, and you shouldn't be forced to pay for the overhead of runtime bounds-checking.</li>
<li>So C++ offers the <code>std::vector</code> class template, which allows both. <code>operator[]</code> is designed to be efficient. The language standard does not require that it performs bounds checking (although it does not forbid it either). A vector also has the <code>at()</code> member function which <em>is guaranteed</em> to perform bounds-checking. So in C++, you get the best of both worlds if you use a vector. You get array-like performance without bounds-checking, <em>and</em> you get the ability to use bounds-checked access when you want it.</li>
</ul>
    </div></div></div></div><div id="solution2" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 2</h1><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Using g++, you can add the command line option:  <code>-fstack-protector-all</code>.</p>

<p>On your example it resulted in the following:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp">&gt; g++ -o t -fstack-protector-all t.cc
&gt; ./t
<span class="hljs-number">3</span>
<span class="hljs-number">4</span>
/bin/bash: line <span class="hljs-number">1</span>: <span class="hljs-number">15450</span> Segmentation fault      ./t
</code></pre>

<p>It doesn't really help you find or solve the problem, but at least the segfault will let you know that <em>something</em> is wrong.</p>
    </div></div></div></div><div id="solution3" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 3</h1><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>g++ does not check for array bounds, and you may be overwriting something with 3,4 but nothing really important, if you try with higher numbers you'll get a crash.</p>

<p>You are just overwriting parts of the stack that are not used, you could continue till you reach the end of the allocated space for the stack and it'd crash eventually</p>

<p>EDIT:
You have no way of dealing with that, maybe a static code analyzer could reveal those failures, but that's too simple, you may have similar(but more complex) failures undetected even for static analyzers</p>
    </div></div></div></div><div id="solution4" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 4</h1><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>It's undefined behavior as far as I know. Run a larger program with that and it will crash somewhere along the way. Bounds checking is not a part of raw arrays (or even std::vector).</p>
<p>Use std::vector with <code>std::vector::iterator</code>'s instead so you don't have to worry about it.</p>
<p>Edit:</p>
<p>Just for fun, run this and see how long until you crash:</p>
<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
   <span class="hljs-type">int</span> arr[<span class="hljs-number">1</span>];

   <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i != <span class="hljs-number">100000</span>; i++)
   {
       arr[i] = i;
   }

   <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <span class="hljs-comment">//will be lucky to ever reach this</span>
}
</code></pre>
<p>Edit2:</p>
<p>Don't run that.</p>
<p>Edit3:</p>
<p>OK, here is a quick lesson on arrays and their relationships with pointers:</p>
<p>When you use array indexing, you are really using a pointer in disguise (called a "reference"), that is automatically dereferenced. This is why instead of *(array+1), array[1] automatically returns the value at that index.</p>
<p>When you have a pointer to an array, like this:</p>
<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-type">int</span> arr[<span class="hljs-number">5</span>];
<span class="hljs-type">int</span> *ptr = arr;
</code></pre>
<p>Then the "array" in the second declaration is really decaying to a pointer to the first array. This is equivalent behavior to this:</p>
<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-type">int</span> *ptr = &amp;arr[<span class="hljs-number">0</span>];
</code></pre>
<p>When you try to access beyond what you allocated, you are really just using a pointer to other memory (which C++ won't complain about). Taking my example program above, that is equivalent to this:</p>
<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
   <span class="hljs-type">int</span> arr[<span class="hljs-number">1</span>];
   <span class="hljs-type">int</span> *ptr = arr;

   <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i != <span class="hljs-number">100000</span>; i++, ptr++)
   {
       *ptr++ = i;
   }

   <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <span class="hljs-comment">//will be lucky to ever reach this</span>
}
</code></pre>
<p>The compiler won't complain because in programming, you often have to communicate with other programs, especially the operating system. This is done with pointers quite a bit.</p>
    </div></div></div></div><div id="solution5" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 5</h1><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<h2>Hint</h2>

<p>If you want to have fast constraint size arrays with range error check, try using <a href="http://www.boost.org/doc/libs/1_39_0/doc/html/array.html" rel="noreferrer">boost::array</a>, (also <a href="http://beans.seartipy.com/2006/12/10/getting-started-with-c-tr1-libraries/" rel="noreferrer">std::tr1::array</a> from <code>&lt;tr1/array&gt;</code> it will be standard container in next C++ specification). It's much faster then std::vector. It reserve memory on heap or inside class instance, just like int array[].<br>
This is simple sample code:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;boost/array.hpp&gt;</span></span>
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    boost::array&lt;<span class="hljs-type">int</span>,2&gt; array;
    array.<span class="hljs-built_in">at</span>(<span class="hljs-number">0</span>) = <span class="hljs-number">1</span>; <span class="hljs-comment">// checking index is inside range</span>
    array[<span class="hljs-number">1</span>] = <span class="hljs-number">2</span>;    <span class="hljs-comment">// no error check, as fast as int array[2];</span>
    <span class="hljs-keyword">try</span>
    {
       <span class="hljs-comment">// index is inside range</span>
       std::cout &lt;&lt; <span class="hljs-string">"array.at(0) = "</span> &lt;&lt; array.<span class="hljs-built_in">at</span>(<span class="hljs-number">0</span>) &lt;&lt; std::endl;

       <span class="hljs-comment">// index is outside range, throwing exception</span>
       std::cout &lt;&lt; <span class="hljs-string">"array.at(2) = "</span> &lt;&lt; array.<span class="hljs-built_in">at</span>(<span class="hljs-number">2</span>) &lt;&lt; std::endl; 

       <span class="hljs-comment">// never comes here</span>
       std::cout &lt;&lt; <span class="hljs-string">"array.at(1) = "</span> &lt;&lt; array.<span class="hljs-built_in">at</span>(<span class="hljs-number">1</span>) &lt;&lt; std::endl;  
    }
    <span class="hljs-built_in">catch</span>(<span class="hljs-type">const</span> std::out_of_range&amp; r)
    {
        std::cout &lt;&lt; <span class="hljs-string">"Something goes wrong: "</span> &lt;&lt; r.<span class="hljs-built_in">what</span>() &lt;&lt; std::endl;
    }
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>

<p>This program will print:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp">array.<span class="hljs-built_in">at</span>(<span class="hljs-number">0</span>) = <span class="hljs-number">1</span>
Something goes wrong: array&lt;&gt;: index out of range
</code></pre>
    </div></div></div></div><div id="solution6" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 6</h1><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>C or C++ will not check the bounds of an array access.</p>

<p>You are allocating the array on the stack.  Indexing the array via <code>array[3]</code> is equivalent to *<code>(array + 3)</code>, where array is a pointer to &amp;array[0].  This will result in undefined behavior.</p>

<p>One way to catch this <strong>sometimes</strong> in C is to use a static checker, such as <strong>splint</strong>.  If you run:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp">splint +bounds array.c
</code></pre>

<p>on,</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>
</span>{
    <span class="hljs-type">int</span> array[<span class="hljs-number">1</span>];

    array[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;

    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>

<p>then you will get the warning:</p>

<blockquote>
  <p>array.c: (in function main)
  array.c:5:9: Likely out-of-bounds
  store:
      array[1]
      Unable to resolve constraint:
      requires 0 &gt;= 1
       needed to satisfy precondition:
      requires maxSet(array @ array.c:5:9) &gt;= 1   A memory write may
  write to an address beyond the
  allocated buffer.</p>
</blockquote>
    </div></div></div></div><div id="solution7" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 7</h1><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Run this through <a href="http://valgrind.org/" rel="nofollow noreferrer">Valgrind</a> and you might see an error.</p>

<p>As Falaina pointed out, valgrind does not detect many instances of stack corruption.  I just tried the sample under valgrind, and it does indeed report zero errors.  However, Valgrind can be instrumental in finding many other types of memory problems, it's just not particularly useful in this case unless you modify your bulid to include the --stack-check option.  If you build and run the sample as </p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp">g++ --stack-check -W -Wall errorRange.cpp -o errorRange
valgrind ./errorRange
</code></pre>

<p>valgrind <strong>will</strong> report an error.</p>
    </div></div></div></div><div id="solution8" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 8</h1><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>You are certainly overwriting your stack, but the program is simple enough that effects of this go unnoticed.</p>
    </div></div></div></div><div id="solution9" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 9</h1><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>libstdc++, which is part of gcc, has a special <a href="https://gcc.gnu.org/onlinedocs/libstdc++/manual/debug_mode.html" rel="nofollow noreferrer">debug mode</a> for error checking. It is enabled by  compiler flag <code>-D_GLIBCXX_DEBUG</code>. Among other things it does bounds checking for <code>std::vector</code> at the cost of performance. Here is <a href="https://wandbox.org/permlink/XaTJtZdqier9zrI4" rel="nofollow noreferrer">online demo</a> with recent version of gcc.</p>

<p>So actually you can do bounds checking with libstdc++ debug mode but you should do it only when testing because it costs notable performance compared to normal libstdc++ mode.</p>
    </div></div></div></div><div id="solution10" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 10</h1><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Undefined behavior working in your favor.  Whatever memory you're clobbering apparently isn't holding anything important.  Note that C and C++ do not do bounds checking on arrays, so stuff like that isn't going to be caught at compile or run time.  </p>
    </div></div></div></div><div id="solution11" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 11</h1><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>When you write 'array[index]' in C it translates it to machine instructions.</p>

<p>The translation is goes something like: </p>

<ol>
<li>'get the address of array'</li>
<li>'get the size of the type of objects array is made up of'</li>
<li>'multiply the size of the type by index'</li>
<li>'add the result to the address of array'</li>
<li>'read what's at the resulting address'</li>
</ol>

<p>The result addresses something which may, or may not, be part of the array. In exchange for the blazing speed of machine instructions you lose the safety net of the computer checking things for you. If you're meticulous and careful it's not a problem. If you're sloppy or make a mistake you get burnt. Sometimes it might generate an invalid instruction that causes an exception, sometimes not.</p>
    </div></div></div></div><div id="solution12" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 12</h1><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>When you initialize the array with <code>int array[2]</code>, space for 2 integers is allocated; but the identifier <code>array</code> simply points to the beginning of that space. When you then access <code>array[3]</code> and <code>array[4]</code>, the compiler then simply increments that address to point to where those values would be, if the array was long enough; try accessing something like <code>array[42]</code> without initializing it first, you'll end up getting whatever value happened to already be in memory at that location.</p>

<p>Edit:</p>

<p>More info on pointers/arrays: <a href="http://home.netcom.com/~tjensen/ptr/pointers.htm" rel="nofollow noreferrer">http://home.netcom.com/~tjensen/ptr/pointers.htm</a></p>
    </div></div></div></div><div id="solution13" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 13</h1><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>As I understand, local variables are allocated on stack, so going out of bounds on your own stack can only overwrite some other local variable, unless you go oob too much and exceed your stack size.
Since you have no other variables declared in your function - it does not cause any side effects. Try declaring another variable/array right after your first one and see what will happen with it.</p>
    </div></div></div></div><div id="solution14" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 14</h1><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>A nice approach that i have seen often and I had been used actually is to inject some NULL type element (or a created one, like <code>uint THIS_IS_INFINITY = 82862863263;</code>) at end of the array.</p>

<p>Then at the loop condition check, <code>TYPE *pagesWords</code> is some kind of pointer array:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-type">int</span> pagesWordsLength = <span class="hljs-built_in">sizeof</span>(pagesWords) / <span class="hljs-built_in">sizeof</span>(pagesWords[<span class="hljs-number">0</span>]);

<span class="hljs-built_in">realloc</span> (pagesWords, <span class="hljs-built_in">sizeof</span>(pagesWords[<span class="hljs-number">0</span>]) * (pagesWordsLength + <span class="hljs-number">1</span>);

pagesWords[pagesWordsLength] = MY_NULL;

<span class="hljs-keyword">for</span> (uint i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++)
{
  <span class="hljs-keyword">if</span> (pagesWords[i] == MY_NULL)
  {
    <span class="hljs-keyword">break</span>;
  }
}
</code></pre>

<p>This solution won't word if array is filled with <code>struct</code> types.</p>
    </div></div></div></div><div id="solution15" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 15</h1><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>As mentioned now in the question using std::vector::at will solve the problem and make a bound check before accessing.</p>

<p>If you need a constant size array that is located on the stack as your first code use the C++11 new container std::array; as vector there is std::array::at function. In fact the function exists in all standard containers in which it have a meaning,i.e, where operator[] is defined :( deque, map, unordered_map) with the exception of std::bitset in which it is called std::bitset::test.</p>
    </div></div></div></div><div id="solution16" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 16</h1><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>If you change your program slightly:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-type">int</span> array[<span class="hljs-number">2</span>];
    INT NOTHING;
    CHAR FOO[<span class="hljs-number">4</span>];
    <span class="hljs-built_in">STRCPY</span>(FOO, <span class="hljs-string">"BAR"</span>);
    array[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;
    array[<span class="hljs-number">1</span>] = <span class="hljs-number">2</span>;
    array[<span class="hljs-number">3</span>] = <span class="hljs-number">3</span>;
    array[<span class="hljs-number">4</span>] = <span class="hljs-number">4</span>;
    cout &lt;&lt; array[<span class="hljs-number">3</span>] &lt;&lt; endl;
    cout &lt;&lt; array[<span class="hljs-number">4</span>] &lt;&lt; endl;
    COUT &lt;&lt; FOO &lt;&lt; ENDL;
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>

<p>(Changes in capitals -- put those in lower case if you're going to try this.)</p>

<p>You will see that the variable <strong>foo</strong> has been trashed.  Your code <strong>will</strong> store values into the nonexistent array[3] and array[4], and be able to properly retrieve them, but the actual storage used will be from <strong>foo</strong>.</p>

<p>So you can "get away" with exceeding the bounds of the array in your original example, but at the cost of causing damage elsewhere -- damage which may prove to be <strong>very</strong> hard to diagnose.</p>

<p>As to why there is no automatic bounds checking -- a correctly written program does not need it.  Once that has been done, there is no reason to do run-time bounds checking and doing so would just slow down the program.  Best to get that all figured out during design and coding.</p>

<p>C++ is based on C, which was designed to be as close to assembly language as possible.</p>
    </div></div></div></div><div id="solution17" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 17</h1><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>when you declare int array[2]; you reserve 2 memory spaces of 4 bytes each(32bit program).
if you type array[4] in your code it still corresponds to a valid call but only at run time will it throw an unhandled exception.  C++ uses manual memory management. This is actually a security flaw that was used for hacking programs</p>

<p>this can help understanding:</p>

<p>int * somepointer;   </p>

<p>somepointer[0]=somepointer[5];</p>
    </div></div></div></div><div id="solution18" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 18</h1><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>The behavior can depend on your system. Typically, you will have a margin for out of bounds, sometimes with value of 0 or garbage values. For the details you can check with memory allocation mechanism used in your OS. On top of that, if you use the programming language like c/c++, it will not check the bounds when you using some containers, like array. So, you will meet "undefined event" because you do not know what the OS did below the surface. But like the programming language Java, it will check the bound. If you step outside of the bound, you will get an exception.</p>
    </div></div></div></div></div></div><div class="widget"><a href="/questions/how-to-randomize-(shuffle)-a-javascript-array-1657384790171">How to randomize (shuffle) a JavaScript array?</a><a href="/questions/how-can-i-validate-an-email-address-in-javascript-1657385475959">How can I validate an email address in JavaScript?</a><a href="/questions/download-a-file-by-jquery.ajax-1657388220611">Download a file by jQuery.Ajax</a><a href="/questions/what-is-the-javascript-version-of-sleep()-1657387391406">What is the JavaScript version of sleep()?</a><a href="/questions/percentage-height-html-5css-1657387471048">Percentage Height HTML 5/CSS</a><a href="/questions/how-do-i-redirect-to-another-webpage-1657384869767">How do I redirect to another webpage?</a><a href="/questions/transpose-reshape-dataframe-without-%22timevar%22-from-long-to-wide-format-1657388213347">Transpose / reshape dataframe without &quot;timevar&quot; from long to wide format</a><a href="/questions/string.equals-versus-duplicate-1657387599972">String.equals versus == [duplicate]</a><a href="/questions/randomize-a-listlesstgreater-1657388172793">Randomize a List&lt;T&gt;</a><a href="/questions/what-is-an-undefined-referenceunresolved-external-symbol-error-and-how-do-i-fix-it-1657384255179">What is an undefined reference/unresolved external symbol error and how do I fix it?</a><a href="/questions/actual-meaning-of-&#x27;shelltrue&#x27;-in-subprocess-1657388470341">Actual meaning of &#x27;shell=True&#x27; in subprocess</a><a href="/questions/how-do-i-revert-a-git-repository-to-a-previous-commit-1657387714717">How do I revert a Git repository to a previous commit?</a><a href="/questions/the-definitive-c-book-guide-and-list-1657384747653">The Definitive C Book Guide and List</a><a href="/questions/fetch-the-rows-which-have-the-max-value-for-a-column-for-each-distinct-value-of-another-column-1657387423925">Fetch the rows which have the Max value for a column for each distinct value of another column</a><a href="/questions/what-is-event-bubbling-and-capturing-1657388059203">What is event bubbling and capturing?</a><a href="/questions/how-do-i-list-all-files-of-a-directory-1657388340404">How do I list all files of a directory?</a><a href="/questions/using-global-variables-in-a-function-1657384796002">Using global variables in a function</a><a href="/questions/make-container-shrink-to-fit-child-elements-as-they-wrap-1657388134549">Make container shrink-to-fit child elements as they wrap</a><a href="/questions/webdriverwait-not-working-as-expected-1657387373148">WebDriverWait not working as expected</a><a href="/questions/why-is-the-command-bound-to-a-button-or-event-executed-when-declared-1657384872054">Why is the command bound to a Button or event executed when declared?</a></div></div><span class="cursor-pointer text-lg p-2" style="position:fixed;bottom:20px;left:20px;background:#000;z-index:2000;color:white">Go go top</span></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"data":{"answer":["\n\u0026lt;p\u0026gt;Welcome to every C/C++ programmer\u0026apos;s bestest friend: \u0026lt;strong\u0026gt;Undefined Behavior\u0026lt;/strong\u0026gt;. \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;There is a lot that is not specified by the language standard, for a variety of reasons. This is one of them.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;In general, whenever you encounter undefined behavior, \u0026lt;em\u0026gt;anything\u0026lt;/em\u0026gt; might happen. The application may crash, it may freeze, it may eject your CD-ROM drive or make demons come out of your nose. It may format your harddrive or email all your porn to your grandmother.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;It may even, if you are really unlucky, \u0026lt;em\u0026gt;appear\u0026lt;/em\u0026gt; to work correctly.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;The language simply says what should happen if you access the elements \u0026lt;em\u0026gt;within\u0026lt;/em\u0026gt; the bounds of an array. It is left undefined what happens if you go out of bounds. It might \u0026lt;em\u0026gt;seem\u0026lt;/em\u0026gt; to work today, on your compiler, but it is not legal C or C++, and there is no guarantee that it\u0026apos;ll still work the next time you run the program. Or that it hasn\u0026apos;t overwritten essential data even now, and you just haven\u0026apos;t encountered the problems, that it \u0026lt;em\u0026gt;is\u0026lt;/em\u0026gt; going to cause  yet.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;As for \u0026lt;em\u0026gt;why\u0026lt;/em\u0026gt; there is no bounds checking, there are a couple aspects to the answer:\u0026lt;/p\u0026gt;\n\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;An array is a leftover from C. C arrays are about as primitive as you can get. Just a sequence of elements with contiguous addresses. There is no bounds checking because it is simply exposing raw memory. Implementing a robust bounds-checking mechanism would have been almost impossible in C.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;In C++, bounds-checking is possible on class types. But an array is still the plain old C-compatible one. It is not a class. Further, C++ is also built on another rule which makes bounds-checking non-ideal. The C++ guiding principle is \u0026quot;you don\u0026apos;t pay for what you don\u0026apos;t use\u0026quot;. If your code is correct, you don\u0026apos;t need bounds-checking, and you shouldn\u0026apos;t be forced to pay for the overhead of runtime bounds-checking.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;So C++ offers the \u0026lt;code\u0026gt;std::vector\u0026lt;/code\u0026gt; class template, which allows both. \u0026lt;code\u0026gt;operator[]\u0026lt;/code\u0026gt; is designed to be efficient. The language standard does not require that it performs bounds checking (although it does not forbid it either). A vector also has the \u0026lt;code\u0026gt;at()\u0026lt;/code\u0026gt; member function which \u0026lt;em\u0026gt;is guaranteed\u0026lt;/em\u0026gt; to perform bounds-checking. So in C++, you get the best of both worlds if you use a vector. You get array-like performance without bounds-checking, \u0026lt;em\u0026gt;and\u0026lt;/em\u0026gt; you get the ability to use bounds-checked access when you want it.\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Using g++, you can add the command line option:  \u0026lt;code\u0026gt;-fstack-protector-all\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;On your example it resulted in the following:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026amp;gt; g++ -o t -fstack-protector-all t.cc\n\u0026amp;gt; ./t\n\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;4\u0026lt;/span\u0026gt;\n/bin/bash: line \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;: \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;15450\u0026lt;/span\u0026gt; Segmentation fault      ./t\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;It doesn\u0026apos;t really help you find or solve the problem, but at least the segfault will let you know that \u0026lt;em\u0026gt;something\u0026lt;/em\u0026gt; is wrong.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;g++ does not check for array bounds, and you may be overwriting something with 3,4 but nothing really important, if you try with higher numbers you\u0026apos;ll get a crash.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;You are just overwriting parts of the stack that are not used, you could continue till you reach the end of the allocated space for the stack and it\u0026apos;d crash eventually\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;EDIT:\nYou have no way of dealing with that, maybe a static code analyzer could reveal those failures, but that\u0026apos;s too simple, you may have similar(but more complex) failures undetected even for static analyzers\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;It\u0026apos;s undefined behavior as far as I know. Run a larger program with that and it will crash somewhere along the way. Bounds checking is not a part of raw arrays (or even std::vector).\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Use std::vector with \u0026lt;code\u0026gt;std::vector::iterator\u0026lt;/code\u0026gt;\u0026apos;s instead so you don\u0026apos;t have to worry about it.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Edit:\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Just for fun, run this and see how long until you crash:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;main\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt;\n\u0026lt;/span\u0026gt;{\n   \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; arr[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;];\n\n   \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt; (\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; i = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;; i != \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;100000\u0026lt;/span\u0026gt;; i++)\n   {\n       arr[i] = i;\n   }\n\n   \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//will be lucky to ever reach this\u0026lt;/span\u0026gt;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;Edit2:\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Don\u0026apos;t run that.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Edit3:\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;OK, here is a quick lesson on arrays and their relationships with pointers:\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;When you use array indexing, you are really using a pointer in disguise (called a \u0026quot;reference\u0026quot;), that is automatically dereferenced. This is why instead of *(array+1), array[1] automatically returns the value at that index.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;When you have a pointer to an array, like this:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; arr[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;5\u0026lt;/span\u0026gt;];\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; *ptr = arr;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;Then the \u0026quot;array\u0026quot; in the second declaration is really decaying to a pointer to the first array. This is equivalent behavior to this:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; *ptr = \u0026amp;amp;arr[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;];\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;When you try to access beyond what you allocated, you are really just using a pointer to other memory (which C++ won\u0026apos;t complain about). Taking my example program above, that is equivalent to this:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;main\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt;\n\u0026lt;/span\u0026gt;{\n   \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; arr[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;];\n   \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; *ptr = arr;\n\n   \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt; (\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; i = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;; i != \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;100000\u0026lt;/span\u0026gt;; i++, ptr++)\n   {\n       *ptr++ = i;\n   }\n\n   \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//will be lucky to ever reach this\u0026lt;/span\u0026gt;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;The compiler won\u0026apos;t complain because in programming, you often have to communicate with other programs, especially the operating system. This is done with pointers quite a bit.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;h2\u0026gt;Hint\u0026lt;/h2\u0026gt;\n\n\u0026lt;p\u0026gt;If you want to have fast constraint size arrays with range error check, try using \u0026lt;a href=\u0026quot;http://www.boost.org/doc/libs/1_39_0/doc/html/array.html\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;boost::array\u0026lt;/a\u0026gt;, (also \u0026lt;a href=\u0026quot;http://beans.seartipy.com/2006/12/10/getting-started-with-c-tr1-libraries/\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;std::tr1::array\u0026lt;/a\u0026gt; from \u0026lt;code\u0026gt;\u0026amp;lt;tr1/array\u0026amp;gt;\u0026lt;/code\u0026gt; it will be standard container in next C++ specification). It\u0026apos;s much faster then std::vector. It reserve memory on heap or inside class instance, just like int array[].\u0026lt;br\u0026gt;\nThis is simple sample code:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;iostream\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;boost/array.hpp\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;main\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt;\n\u0026lt;/span\u0026gt;{\n    boost::array\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;,2\u0026amp;gt; array;\n    array.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;at\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;) = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// checking index is inside range\u0026lt;/span\u0026gt;\n    array[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;] = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;;    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// no error check, as fast as int array[2];\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;try\u0026lt;/span\u0026gt;\n    {\n       \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// index is inside range\u0026lt;/span\u0026gt;\n       std::cout \u0026amp;lt;\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;array.at(0) = \u0026quot;\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026amp;lt; array.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;at\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;) \u0026amp;lt;\u0026amp;lt; std::endl;\n\n       \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// index is outside range, throwing exception\u0026lt;/span\u0026gt;\n       std::cout \u0026amp;lt;\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;array.at(2) = \u0026quot;\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026amp;lt; array.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;at\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;) \u0026amp;lt;\u0026amp;lt; std::endl; \n\n       \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// never comes here\u0026lt;/span\u0026gt;\n       std::cout \u0026amp;lt;\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;array.at(1) = \u0026quot;\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026amp;lt; array.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;at\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;) \u0026amp;lt;\u0026amp;lt; std::endl;  \n    }\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;catch\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; std::out_of_range\u0026amp;amp; r)\n    {\n        std::cout \u0026amp;lt;\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Something goes wrong: \u0026quot;\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026amp;lt; r.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;what\u0026lt;/span\u0026gt;() \u0026amp;lt;\u0026amp;lt; std::endl;\n    }\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;This program will print:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;array.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;at\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;) = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;\nSomething goes wrong: array\u0026amp;lt;\u0026amp;gt;: index out of range\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;C or C++ will not check the bounds of an array access.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;You are allocating the array on the stack.  Indexing the array via \u0026lt;code\u0026gt;array[3]\u0026lt;/code\u0026gt; is equivalent to *\u0026lt;code\u0026gt;(array + 3)\u0026lt;/code\u0026gt;, where array is a pointer to \u0026amp;amp;array[0].  This will result in undefined behavior.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;One way to catch this \u0026lt;strong\u0026gt;sometimes\u0026lt;/strong\u0026gt; in C is to use a static checker, such as \u0026lt;strong\u0026gt;splint\u0026lt;/strong\u0026gt;.  If you run:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;splint +bounds array.c\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;on,\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;main\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt;)\u0026lt;/span\u0026gt;\n\u0026lt;/span\u0026gt;{\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; array[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;];\n\n    array[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;] = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;;\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;then you will get the warning:\u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;array.c: (in function main)\n  array.c:5:9: Likely out-of-bounds\n  store:\n      array[1]\n      Unable to resolve constraint:\n      requires 0 \u0026amp;gt;= 1\n       needed to satisfy precondition:\n      requires maxSet(array @ array.c:5:9) \u0026amp;gt;= 1   A memory write may\n  write to an address beyond the\n  allocated buffer.\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Run this through \u0026lt;a href=\u0026quot;http://valgrind.org/\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;Valgrind\u0026lt;/a\u0026gt; and you might see an error.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;As Falaina pointed out, valgrind does not detect many instances of stack corruption.  I just tried the sample under valgrind, and it does indeed report zero errors.  However, Valgrind can be instrumental in finding many other types of memory problems, it\u0026apos;s just not particularly useful in this case unless you modify your bulid to include the --stack-check option.  If you build and run the sample as \u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;g++ --stack-check -W -Wall errorRange.cpp -o errorRange\nvalgrind ./errorRange\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;valgrind \u0026lt;strong\u0026gt;will\u0026lt;/strong\u0026gt; report an error.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;You are certainly overwriting your stack, but the program is simple enough that effects of this go unnoticed.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;libstdc++, which is part of gcc, has a special \u0026lt;a href=\u0026quot;https://gcc.gnu.org/onlinedocs/libstdc++/manual/debug_mode.html\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;debug mode\u0026lt;/a\u0026gt; for error checking. It is enabled by  compiler flag \u0026lt;code\u0026gt;-D_GLIBCXX_DEBUG\u0026lt;/code\u0026gt;. Among other things it does bounds checking for \u0026lt;code\u0026gt;std::vector\u0026lt;/code\u0026gt; at the cost of performance. Here is \u0026lt;a href=\u0026quot;https://wandbox.org/permlink/XaTJtZdqier9zrI4\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;online demo\u0026lt;/a\u0026gt; with recent version of gcc.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;So actually you can do bounds checking with libstdc++ debug mode but you should do it only when testing because it costs notable performance compared to normal libstdc++ mode.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Undefined behavior working in your favor.  Whatever memory you\u0026apos;re clobbering apparently isn\u0026apos;t holding anything important.  Note that C and C++ do not do bounds checking on arrays, so stuff like that isn\u0026apos;t going to be caught at compile or run time.  \u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;When you write \u0026apos;array[index]\u0026apos; in C it translates it to machine instructions.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;The translation is goes something like: \u0026lt;/p\u0026gt;\n\n\u0026lt;ol\u0026gt;\n\u0026lt;li\u0026gt;\u0026apos;get the address of array\u0026apos;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026apos;get the size of the type of objects array is made up of\u0026apos;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026apos;multiply the size of the type by index\u0026apos;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026apos;add the result to the address of array\u0026apos;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026apos;read what\u0026apos;s at the resulting address\u0026apos;\u0026lt;/li\u0026gt;\n\u0026lt;/ol\u0026gt;\n\n\u0026lt;p\u0026gt;The result addresses something which may, or may not, be part of the array. In exchange for the blazing speed of machine instructions you lose the safety net of the computer checking things for you. If you\u0026apos;re meticulous and careful it\u0026apos;s not a problem. If you\u0026apos;re sloppy or make a mistake you get burnt. Sometimes it might generate an invalid instruction that causes an exception, sometimes not.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;When you initialize the array with \u0026lt;code\u0026gt;int array[2]\u0026lt;/code\u0026gt;, space for 2 integers is allocated; but the identifier \u0026lt;code\u0026gt;array\u0026lt;/code\u0026gt; simply points to the beginning of that space. When you then access \u0026lt;code\u0026gt;array[3]\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;array[4]\u0026lt;/code\u0026gt;, the compiler then simply increments that address to point to where those values would be, if the array was long enough; try accessing something like \u0026lt;code\u0026gt;array[42]\u0026lt;/code\u0026gt; without initializing it first, you\u0026apos;ll end up getting whatever value happened to already be in memory at that location.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Edit:\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;More info on pointers/arrays: \u0026lt;a href=\u0026quot;http://home.netcom.com/~tjensen/ptr/pointers.htm\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;http://home.netcom.com/~tjensen/ptr/pointers.htm\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;As I understand, local variables are allocated on stack, so going out of bounds on your own stack can only overwrite some other local variable, unless you go oob too much and exceed your stack size.\nSince you have no other variables declared in your function - it does not cause any side effects. Try declaring another variable/array right after your first one and see what will happen with it.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;A nice approach that i have seen often and I had been used actually is to inject some NULL type element (or a created one, like \u0026lt;code\u0026gt;uint THIS_IS_INFINITY = 82862863263;\u0026lt;/code\u0026gt;) at end of the array.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Then at the loop condition check, \u0026lt;code\u0026gt;TYPE *pagesWords\u0026lt;/code\u0026gt; is some kind of pointer array:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; pagesWordsLength = \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;sizeof\u0026lt;/span\u0026gt;(pagesWords) / \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;sizeof\u0026lt;/span\u0026gt;(pagesWords[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;]);\n\n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;realloc\u0026lt;/span\u0026gt; (pagesWords, \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;sizeof\u0026lt;/span\u0026gt;(pagesWords[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;]) * (pagesWordsLength + \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;);\n\npagesWords[pagesWordsLength] = MY_NULL;\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt; (uint i = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;; i \u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1000\u0026lt;/span\u0026gt;; i++)\n{\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (pagesWords[i] == MY_NULL)\n  {\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;break\u0026lt;/span\u0026gt;;\n  }\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;This solution won\u0026apos;t word if array is filled with \u0026lt;code\u0026gt;struct\u0026lt;/code\u0026gt; types.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;As mentioned now in the question using std::vector::at will solve the problem and make a bound check before accessing.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;If you need a constant size array that is located on the stack as your first code use the C++11 new container std::array; as vector there is std::array::at function. In fact the function exists in all standard containers in which it have a meaning,i.e, where operator[] is defined :( deque, map, unordered_map) with the exception of std::bitset in which it is called std::bitset::test.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;If you change your program slightly:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;iostream\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;using\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;namespace\u0026lt;/span\u0026gt; std;\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;main\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt;\n\u0026lt;/span\u0026gt;{\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; array[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;];\n    INT NOTHING;\n    CHAR FOO[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;4\u0026lt;/span\u0026gt;];\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;STRCPY\u0026lt;/span\u0026gt;(FOO, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;BAR\u0026quot;\u0026lt;/span\u0026gt;);\n    array[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;] = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;;\n    array[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;] = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;;\n    array[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3\u0026lt;/span\u0026gt;] = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3\u0026lt;/span\u0026gt;;\n    array[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;4\u0026lt;/span\u0026gt;] = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;4\u0026lt;/span\u0026gt;;\n    cout \u0026amp;lt;\u0026amp;lt; array[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3\u0026lt;/span\u0026gt;] \u0026amp;lt;\u0026amp;lt; endl;\n    cout \u0026amp;lt;\u0026amp;lt; array[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;4\u0026lt;/span\u0026gt;] \u0026amp;lt;\u0026amp;lt; endl;\n    COUT \u0026amp;lt;\u0026amp;lt; FOO \u0026amp;lt;\u0026amp;lt; ENDL;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;(Changes in capitals -- put those in lower case if you\u0026apos;re going to try this.)\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;You will see that the variable \u0026lt;strong\u0026gt;foo\u0026lt;/strong\u0026gt; has been trashed.  Your code \u0026lt;strong\u0026gt;will\u0026lt;/strong\u0026gt; store values into the nonexistent array[3] and array[4], and be able to properly retrieve them, but the actual storage used will be from \u0026lt;strong\u0026gt;foo\u0026lt;/strong\u0026gt;.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;So you can \u0026quot;get away\u0026quot; with exceeding the bounds of the array in your original example, but at the cost of causing damage elsewhere -- damage which may prove to be \u0026lt;strong\u0026gt;very\u0026lt;/strong\u0026gt; hard to diagnose.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;As to why there is no automatic bounds checking -- a correctly written program does not need it.  Once that has been done, there is no reason to do run-time bounds checking and doing so would just slow down the program.  Best to get that all figured out during design and coding.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;C++ is based on C, which was designed to be as close to assembly language as possible.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;when you declare int array[2]; you reserve 2 memory spaces of 4 bytes each(32bit program).\nif you type array[4] in your code it still corresponds to a valid call but only at run time will it throw an unhandled exception.  C++ uses manual memory management. This is actually a security flaw that was used for hacking programs\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;this can help understanding:\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;int * somepointer;   \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;somepointer[0]=somepointer[5];\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;The behavior can depend on your system. Typically, you will have a margin for out of bounds, sometimes with value of 0 or garbage values. For the details you can check with memory allocation mechanism used in your OS. On top of that, if you use the programming language like c/c++, it will not check the bounds when you using some containers, like array. So, you will meet \u0026quot;undefined event\u0026quot; because you do not know what the OS did below the surface. But like the programming language Java, it will check the bound. If you step outside of the bound, you will get an exception.\u0026lt;/p\u0026gt;\n    "],"id":437,"title":"Accessing an array out of bounds gives no error, why?","content":"\n                \n\u0026lt;p\u0026gt;I am assigning values in a C++ program out of the bounds like this:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;iostream\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;using\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;namespace\u0026lt;/span\u0026gt; std;\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;main\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt;\n\u0026lt;/span\u0026gt;{\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; array[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;];\n    array[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;] = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;;\n    array[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;] = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;;\n    array[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3\u0026lt;/span\u0026gt;] = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3\u0026lt;/span\u0026gt;;\n    array[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;4\u0026lt;/span\u0026gt;] = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;4\u0026lt;/span\u0026gt;;\n    cout \u0026amp;lt;\u0026amp;lt; array[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3\u0026lt;/span\u0026gt;] \u0026amp;lt;\u0026amp;lt; endl;\n    cout \u0026amp;lt;\u0026amp;lt; array[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;4\u0026lt;/span\u0026gt;] \u0026amp;lt;\u0026amp;lt; endl;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;The program prints \u0026lt;code\u0026gt;3\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;4\u0026lt;/code\u0026gt;.  It should not be possible.  I am using g++ 4.3.3\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Here is compile and run command\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;$ g++ -W -Wall errorRange.cpp -o errorRange\n$ ./errorRange\n\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;4\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Only when assigning \u0026lt;code\u0026gt;array[3000]=3000\u0026lt;/code\u0026gt; does it give me a segmentation fault.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;If gcc doesn\u0026apos;t check for array bounds, how can I be sure if my program is correct, as it can lead to some serious issues later?\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;I replaced the above code with\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;vector\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;vint\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;)\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;;\nvint[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;] = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;;\nvint[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;] = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;;\nvint[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;] = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;;\nvint[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;5\u0026lt;/span\u0026gt;] = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;5\u0026lt;/span\u0026gt;;\ncout \u0026amp;lt;\u0026amp;lt; vint[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;] \u0026amp;lt;\u0026amp;lt; endl;\ncout \u0026amp;lt;\u0026amp;lt; vint[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;5\u0026lt;/span\u0026gt;] \u0026amp;lt;\u0026amp;lt; endl;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;and this one also produces no error. \u0026lt;/p\u0026gt;\n    ","slug":"accessing-an-array-out-of-bounds-gives-no-error-why-1657387979932","postType":"QUESTION","createdAt":"2022-07-09T17:32:59.000Z","updatedAt":"2022-07-09T17:32:59.000Z","tags":[],"relatedQuestions":[]},"randomQuestions":[{"title":"How to randomize (shuffle) a JavaScript array?","slug":"how-to-randomize-(shuffle)-a-javascript-array-1657384790171"},{"title":"How can I validate an email address in JavaScript?","slug":"how-can-i-validate-an-email-address-in-javascript-1657385475959"},{"title":"Download a file by jQuery.Ajax","slug":"download-a-file-by-jquery.ajax-1657388220611"},{"title":"What is the JavaScript version of sleep()?","slug":"what-is-the-javascript-version-of-sleep()-1657387391406"},{"title":"Percentage Height HTML 5/CSS","slug":"percentage-height-html-5css-1657387471048"},{"title":"How do I redirect to another webpage?","slug":"how-do-i-redirect-to-another-webpage-1657384869767"},{"title":"Transpose / reshape dataframe without \"timevar\" from long to wide format","slug":"transpose-reshape-dataframe-without-\"timevar\"-from-long-to-wide-format-1657388213347"},{"title":"String.equals versus == [duplicate]","slug":"string.equals-versus-duplicate-1657387599972"},{"title":"Randomize a List\u003cT\u003e","slug":"randomize-a-listlesstgreater-1657388172793"},{"title":"What is an undefined reference/unresolved external symbol error and how do I fix it?","slug":"what-is-an-undefined-referenceunresolved-external-symbol-error-and-how-do-i-fix-it-1657384255179"},{"title":"Actual meaning of 'shell=True' in subprocess","slug":"actual-meaning-of-'shelltrue'-in-subprocess-1657388470341"},{"title":"How do I revert a Git repository to a previous commit?","slug":"how-do-i-revert-a-git-repository-to-a-previous-commit-1657387714717"},{"title":"The Definitive C Book Guide and List","slug":"the-definitive-c-book-guide-and-list-1657384747653"},{"title":"Fetch the rows which have the Max value for a column for each distinct value of another column","slug":"fetch-the-rows-which-have-the-max-value-for-a-column-for-each-distinct-value-of-another-column-1657387423925"},{"title":"What is event bubbling and capturing?","slug":"what-is-event-bubbling-and-capturing-1657388059203"},{"title":"How do I list all files of a directory?","slug":"how-do-i-list-all-files-of-a-directory-1657388340404"},{"title":"Using global variables in a function","slug":"using-global-variables-in-a-function-1657384796002"},{"title":"Make container shrink-to-fit child elements as they wrap","slug":"make-container-shrink-to-fit-child-elements-as-they-wrap-1657388134549"},{"title":"WebDriverWait not working as expected","slug":"webdriverwait-not-working-as-expected-1657387373148"},{"title":"Why is the command bound to a Button or event executed when declared?","slug":"why-is-the-command-bound-to-a-button-or-event-executed-when-declared-1657384872054"}]},"__N_SSG":true},"page":"/questions/[slug]","query":{"slug":"accessing-an-array-out-of-bounds-gives-no-error-why-1657387979932"},"buildId":"00bsHgHZki2FteshOatnd","isFallback":false,"gsp":true,"locale":"en","locales":["en"],"defaultLocale":"en","scriptLoader":[]}</script></body></html>