<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><meta name="twitter:card" content="summary_large_image"/><meta name="twitter:site" content="@solutionschecker.com"/><meta name="twitter:creator" content="@solutionschecker.com"/><meta property="og:url" content="https://solutionschecker.com"/><meta property="og:type" content="website"/><meta property="og:image" content="https://solutionschecker.com/solutions-checker-banner.png"/><meta property="og:image:alt" content="Find solution for coding, HTML, CSS, JAVASCRIPT, MYSQL, PHP, PYTHON,... quickly. - solutionschecker.com"/><script type="application/ld+json">{"@context":"https://schema.org","@type":"Organization","logo":"/logo.svg","url":"https://solutionschecker.com"}</script><title>UnboundLocalError on local variable when reassigned after first use | Solutions Checker</title><meta name="robots" content="index,follow"/><meta name="description" content="The following code works as expected in both Python 2.5 and 3.0:

a, b, c = (1, 2, 3)

print(a, b, c)

def test():
    print(a)
    print(b)
    print(c)    # (A)
    #c+=1       # (B)
test()


However, when I uncomment line (B), I get an UnboundLocalError: &#x27;c&#x27; not assigned at line (A). The values of a and b are printed correctly. This has me completely baffled for two reasons:


Why is there a runtime error thrown at line (A) because of a later statement on line (B)?
Why are variables a and b printed as expected, while c raises an error?


The only explanation I can come up with is that a local variable c is created by the assignment c+=1, which takes precedent over the &quot;global&quot; variable c even before the local variable is created. Of course, it doesn&#x27;t make sense for a variable to &quot;steal&quot; scope before it exists.

Could someone please explain this behavior?
    "/><meta property="og:title" content="UnboundLocalError on local variable when reassigned after first use | Solutions Checker"/><meta property="og:description" content="The following code works as expected in both Python 2.5 and 3.0:

a, b, c = (1, 2, 3)

print(a, b, c)

def test():
    print(a)
    print(b)
    print(c)    # (A)
    #c+=1       # (B)
test()


However, when I uncomment line (B), I get an UnboundLocalError: &#x27;c&#x27; not assigned at line (A). The values of a and b are printed correctly. This has me completely baffled for two reasons:


Why is there a runtime error thrown at line (A) because of a later statement on line (B)?
Why are variables a and b printed as expected, while c raises an error?


The only explanation I can come up with is that a local variable c is created by the assignment c+=1, which takes precedent over the &quot;global&quot; variable c even before the local variable is created. Of course, it doesn&#x27;t make sense for a variable to &quot;steal&quot; scope before it exists.

Could someone please explain this behavior?
    "/><script type="application/ld+json">{"@context":"https://schema.org","@type":"QAPage","mainEntity":{"name":"UnboundLocalError on local variable when reassigned after first use","text":"The following code works as expected in both Python 2.5 and 3.0:\n\na, b, c = (1, 2, 3)\n\nprint(a, b, c)\n\ndef test():\n    print(a)\n    print(b)\n    print(c)    # (A)\n    #c+=1       # (B)\ntest()\n\n\nHowever, when I uncomment line (B), I get an UnboundLocalError: &apos;c&apos; not assigned at line (A). The values of a and b are printed correctly. This has me completely baffled for two reasons:\n\n\nWhy is there a runtime error thrown at line (A) because of a later statement on line (B)?\nWhy are variables a and b printed as expected, while c raises an error?\n\n\nThe only explanation I can come up with is that a local variable c is created by the assignment c+=1, which takes precedent over the &quot;global&quot; variable c even before the local variable is created. Of course, it doesn&apos;t make sense for a variable to &quot;steal&quot; scope before it exists.\n\nCould someone please explain this behavior?\n    ","answerCount":13,"upVoteCount":500,"suggestedAnswer":[{"text":"Python treats variables in functions differently depending on whether you assign values to them from inside or outside the function.  If a variable is assigned within a function, it is treated by default as a local variable.  Therefore, when you uncomment the line, you are trying to reference the local variable c before any value has been assigned to it.\nIf you want the variable c to refer to the global c = 3 assigned before the function, put\nglobal c\n\nas the first line of the function.\nAs for python 3, there is now\nnonlocal c\n\nthat you can use to refer to the nearest enclosing function scope that has a c variable.\n    ","url":"/questions/[slug]#solution1","@type":"Answer","upvoteCount":0},{"text":"Python is a little weird in that it keeps everything in a dictionary for the various scopes.  The original a,b,c are in the uppermost scope and so in that uppermost dictionary.  The function has its own dictionary.  When you reach the print(a) and print(b) statements, there&apos;s nothing by that name in the dictionary, so Python looks up the list and finds them in the global dictionary.\n\nNow we get to c+=1, which is, of course, equivalent to c=c+1.  When Python scans that line, it says &quot;aha, there&apos;s a variable named c, I&apos;ll put it into my local scope dictionary.&quot;  Then when it goes looking for a value for c for the c on the right hand side of the assignment, it finds its local variable named c, which has no value yet, and so throws the error.\n\nThe statement global c mentioned above simply tells the parser that it uses the c from the global scope and so doesn&apos;t need a new one.\n\nThe reason it says there&apos;s an issue on the line it does is because it is effectively looking for the names before it tries to generate code, and so in some sense doesn&apos;t think it&apos;s really doing that line yet.  I&apos;d argue that is a usability bug, but it&apos;s generally a good practice to just learn not to take a compiler&apos;s messages too seriously.\n\nIf it&apos;s any comfort, I spent probably a day digging and experimenting with this same issue before I found something Guido had written about the dictionaries that Explained Everything.\n\nUpdate, see comments:\n\nIt doesn&apos;t scan the code twice, but it does scan the code in two phases, lexing and parsing.\n\nConsider how the parse of this line of code works.  The lexer reads the source text and breaks it into lexemes, the &quot;smallest components&quot; of the grammar.  So when it hits the line\n\nc+=1\n\n\nit breaks it up into something like\n\nSYMBOL(c) OPERATOR(+=) DIGIT(1)\n\n\nThe parser eventually wants to make this into a parse tree and execute it, but since it&apos;s an assignment, before it does, it looks for the name c in the local dictionary, doesn&apos;t see it, and inserts it in the dictionary, marking it as uninitialized. In a fully compiled language, it would just go into the symbol table and wait for the parse, but since it WON&apos;T have the luxury of a second pass, the lexer does a little extra work to make life easier later on.   Only, then it sees the OPERATOR, sees that the rules say &quot;if you have an operator += the left hand side must have been initialized&quot; and says &quot;whoops!&quot;\n\nThe point here is that it hasn&apos;t really started the parse of the line yet.  This is all happening sort of preparatory to the actual parse, so the line counter hasn&apos;t advanced to the next line.  Thus when it signals the error, it still thinks its on the previous line.\n\nAs I say, you could argue it&apos;s a usability bug, but its actually a fairly common thing.  Some compilers are more honest about it and say &quot;error on or around line XXX&quot;, but this one doesn&apos;t.\n    ","url":"/questions/[slug]#solution2","@type":"Answer","upvoteCount":0},{"text":"Taking a look at the disassembly may clarify what is happening:\n\n&gt;&gt;&gt; def f():\n...    print a\n...    print b\n...    a = 1\n\n&gt;&gt;&gt; import dis\n&gt;&gt;&gt; dis.dis(f)\n\n  2           0 LOAD_FAST                0 (a)\n              3 PRINT_ITEM\n              4 PRINT_NEWLINE\n\n  3           5 LOAD_GLOBAL              0 (b)\n              8 PRINT_ITEM\n              9 PRINT_NEWLINE\n\n  4          10 LOAD_CONST               1 (1)\n             13 STORE_FAST               0 (a)\n             16 LOAD_CONST               0 (None)\n             19 RETURN_VALUE\n\n\nAs you can see, the bytecode for accessing a is LOAD_FAST, and for b, LOAD_GLOBAL.  This is because the compiler has identified that a is assigned to within the function, and classified it as a local variable.  The access mechanism for locals is fundamentally different for globals - they are statically assigned an offset in the frame&apos;s variables table, meaning lookup is a quick index, rather than the more expensive dict lookup as for globals.  Because of this, Python is reading the print a line as &quot;get the value of local variable &apos;a&apos; held in slot 0, and print it&quot;, and when it detects that this variable is still uninitialised, raises an exception.\n    ","url":"/questions/[slug]#solution3","@type":"Answer","upvoteCount":0},{"text":"Python has rather interesting behavior when you try traditional global variable semantics.  I don&apos;t remember the details, but you can read the value of a variable declared in &apos;global&apos; scope just fine, but if you want to modify it, you have to use the global keyword.  Try changing test() to this:\n\ndef test():\n    global c\n    print(a)\n    print(b)\n    print(c)    # (A)\n    c+=1        # (B)\n\n\nAlso, the reason you are getting this error is because you can also declare a new variable inside that function with the same name as a &apos;global&apos; one, and it would be completely separate.  The interpreter thinks you are trying to make a new variable in this scope called c and modify it all in one operation, which isn&apos;t allowed in Python because this new c wasn&apos;t initialized.\n    ","url":"/questions/[slug]#solution4","@type":"Answer","upvoteCount":0},{"text":"The best example that makes it clear is:\n\nbar = 42\ndef foo():\n    print bar\n    if False:\n        bar = 0\n\n\nwhen calling foo() , this also raises UnboundLocalError although we will never reach to line bar=0, so logically local variable should never be created.\n\nThe mystery lies in &quot;Python is an Interpreted Language&quot; and the declaration of the function foo is interpreted as a single statement (i.e. a compound statement), it just interprets it dumbly and creates local and global scopes. So bar is recognized in local scope before execution.\n\nFor more examples like this Read this post: http://blog.amir.rachum.com/blog/2013/07/09/python-common-newbie-mistakes-part-2/\n\nThis post provides a Complete Description and Analyses of the Python Scoping of variables:\n    ","url":"/questions/[slug]#solution5","@type":"Answer","upvoteCount":0},{"text":"Here are two links that may help\n\n1: docs.python.org/3.1/faq/programming.html?highlight=nonlocal#why-am-i-getting-an-unboundlocalerror-when-the-variable-has-a-value\n\n2: docs.python.org/3.1/faq/programming.html?highlight=nonlocal#how-do-i-write-a-function-with-output-parameters-call-by-reference\n\nlink one describes the error UnboundLocalError.  Link two can help with with re-writing your test function.  Based on link two, the original problem could be rewritten as:\n\n&gt;&gt;&gt; a, b, c = (1, 2, 3)\n&gt;&gt;&gt; print (a, b, c)\n(1, 2, 3)\n&gt;&gt;&gt; def test (a, b, c):\n...     print (a)\n...     print (b)\n...     print (c)\n...     c += 1\n...     return a, b, c\n...\n&gt;&gt;&gt; a, b, c = test (a, b, c)\n1\n2\n3\n&gt;&gt;&gt; print (a, b ,c)\n(1, 2, 4)\n\n    ","url":"/questions/[slug]#solution6","@type":"Answer","upvoteCount":0},{"text":"This is not a direct answer to your question, but it is closely related, as it&apos;s another gotcha caused by the relationship between augmented assignment and function scopes.\n\nIn most cases, you tend to think of augmented assignment (a += b) as exactly equivalent to simple assignment (a = a + b). It is possible to get into some trouble with this though, in one corner case. Let me explain:\n\nThe way Python&apos;s simple assignment works means that if a is passed into a function (like func(a); note that Python is always pass-by-reference), then a = a + b will not modify the a that is passed in. Instead, it will just modify the local pointer to a. \n\nBut if you use a += b, then it is sometimes implemented as:\n\na = a + b\n\n\nor sometimes (if the method exists) as:\n\na.__iadd__(b)\n\n\nIn the first case (as long as a is not declared global), there are no side-effects outside local scope, as the assignment to a is just a pointer update.\n\nIn the second case, a will actually modify itself, so all references to a will point to the modified version. This is demonstrated by the following code:\n\ndef copy_on_write(a):\n      a = a + a\ndef inplace_add(a):\n      a += a\na = [1]\ncopy_on_write(a)\nprint a # [1]\ninplace_add(a)\nprint a # [1, 1]\nb = 1\ncopy_on_write(b)\nprint b # [1]\ninplace_add(b)\nprint b # 1\n\n\nSo the trick is to avoid augmented assignment on function arguments (I try to only use it for local/loop variables). Use simple assignment, and you will be safe from ambiguous behaviour. \n    ","url":"/questions/[slug]#solution7","@type":"Answer","upvoteCount":0},{"text":"The Python interpreter will read a function as a complete unit. I think of it as reading it in two passes, once to gather its closure (the local variables), then again to turn it into byte-code.\n\nAs I&apos;m sure you were already aware, any name used on the left of a &apos;=&apos; is implicitly a local variable. More than once I&apos;ve been caught out by changing a variable access to a += and it&apos;s suddenly a different variable.\n\nI also wanted to point out it&apos;s not really anything to do with global scope specifically. You get the same behaviour with nested functions.\n    ","url":"/questions/[slug]#solution8","@type":"Answer","upvoteCount":0},{"text":"c+=1 assigns c, python assumes assigned variables are local, but in this case it hasn&apos;t been declared locally.\n\nEither use the global or nonlocal keywords. \n\nnonlocal works only in python 3, so if you&apos;re using python 2 and don&apos;t want to make your variable global, you can use a mutable object:\n\nmy_variables = { # a mutable object\n    &apos;c&apos;: 3\n}\n\ndef test():\n    my_variables[&apos;c&apos;] +=1\n\ntest()\n\n    ","url":"/questions/[slug]#solution9","@type":"Answer","upvoteCount":0},{"text":"The best way to reach class variable is directly accesing by class name\n\nclass Employee:\n    counter=0\n\n    def __init__(self):\n        Employee.counter+=1\n\n    ","url":"/questions/[slug]#solution10","@type":"Answer","upvoteCount":0},{"text":"You can also get this message if you define a variable with the same name as a method.\nFor example:\ndef teams():\n    ...\n\ndef some_other_method():\n    teams = teams()\n\nThe solution, is to rename method teams() to something else like get_teams().\nSince it is only used locally, the Python message is rather misleading!\nYou end up with something like this to get around it:\ndef teams():\n    ...\n\ndef some_other_method():\n    teams = get_teams()\n\n    ","url":"/questions/[slug]#solution11","@type":"Answer","upvoteCount":0},{"text":"This issue can also occur when the del keyword is utilized on the variable down the line, after initialization, typically in a loop or a conditional block.\n    ","url":"/questions/[slug]#solution12","@type":"Answer","upvoteCount":0},{"text":"The same problem bothers me. Using nonlocal and global can solve the problem.\nHowever, attention is needed for the usage of nonlocal, it works for nested functions. However, at the module level, it does not work. See examples here.\n    ","url":"/questions/[slug]#solution13","@type":"Answer","upvoteCount":0}],"@type":"Question"}}</script><meta name="next-head-count" content="16"/><link rel="preload" href="/_next/static/css/08bcc42a26fe5c92.css" as="style"/><link rel="stylesheet" href="/_next/static/css/08bcc42a26fe5c92.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-0d1b80a048d4787e.js"></script><script src="/_next/static/chunks/webpack-42cdea76c8170223.js" defer=""></script><script src="/_next/static/chunks/framework-4556c45dd113b893.js" defer=""></script><script src="/_next/static/chunks/main-ccfab947c79712f4.js" defer=""></script><script src="/_next/static/chunks/pages/_app-08d1a634dea6705e.js" defer=""></script><script src="/_next/static/chunks/29107295-fbcfe2172188e46f.js" defer=""></script><script src="/_next/static/chunks/150-b06815e21c943e0d.js" defer=""></script><script src="/_next/static/chunks/490-7f0418bb4354ac73.js" defer=""></script><script src="/_next/static/chunks/108-87de33c23337ff53.js" defer=""></script><script src="/_next/static/chunks/pages/questions/%5Bslug%5D-79a1437acf654019.js" defer=""></script><script src="/_next/static/6ctJfCympFH_chh5mjicD/_buildManifest.js" defer=""></script><script src="/_next/static/6ctJfCympFH_chh5mjicD/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="wrapper"><header><nav class="bg-white border-gray-200 px-4 lg:px-6 py-2.5 dark:bg-gray-800"><div class="flex flex-wrap justify-between items-center mx-auto max-w-screen-xl"><a class="flex items-center" href="/"><img src="/logo-second.png" class="mr-3 h-6 sm:h-9" alt="Solution Checker Logo"/><h4 class="self-center text-xl font-semibold whitespace-nowrap dark:text-white">Solution Checker</h4></a><div class="flex items-center lg:order-2"><button data-collapse-toggle="mobile-menu-2" type="button" class="inline-flex items-center p-2 ml-1 text-sm text-gray-500 rounded-lg lg:hidden hover:bg-gray-100 focus:outline-none focus:ring-2 focus:ring-gray-200 dark:text-gray-400 dark:hover:bg-gray-700 dark:focus:ring-gray-600" aria-controls="mobile-menu-2" aria-expanded="false"><span class="sr-only">Open main menu</span><svg class="w-6 h-6" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M3 5a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM3 10a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM3 15a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1z" clip-rule="evenodd"></path></svg><svg class="hidden w-6 h-6" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z" clip-rule="evenodd"></path></svg></button></div><div class="hidden justify-between items-center w-full lg:flex lg:w-auto lg:order-1" id="mobile-menu-2"><ul class="flex flex-col mt-4 font-medium lg:flex-row lg:space-x-8 lg:mt-0"><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" aria-current="page" href="/">Home</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/questions?tab=news">Questions</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/post?tab=news">Post</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/questions/unboundlocalerror-on-local-variable-when-reassigned-after-first-use-1657387685248#">Coding</a></li></ul></div></div></nav></header><div class="main-content"><div class="question my-5"><div class="flex question-header items-center m-auto justify-center"><div class="rounded-xl w-full border p-5 shadow-md bg-white"><div class="flex w-full items-center justify-between border-b pb-3"><div class="flex items-center space-x-3"><div class="text-lg font-bold text-slate-700"><a href="/questions/unboundlocalerror-on-local-variable-when-reassigned-after-first-use-1657387685248"><h1>UnboundLocalError on local variable when reassigned after first use</h1></a></div></div><div class="flex flex-wrap h-auto justify-end items-center space-x-8"></div></div><div class="question-content mt-5">
                
<p>The following code works as expected in both Python 2.5 and 3.0:</p>

<pre class="lang-py s-code-block"><code class="hljs language-python">a, b, c = (<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)

<span class="hljs-built_in">print</span>(a, b, c)

<span class="hljs-keyword">def</span> <span class="hljs-title function_">test</span>():
    <span class="hljs-built_in">print</span>(a)
    <span class="hljs-built_in">print</span>(b)
    <span class="hljs-built_in">print</span>(c)    <span class="hljs-comment"># (A)</span>
    <span class="hljs-comment">#c+=1       # (B)</span>
test()
</code></pre>

<p>However, when I uncomment line <strong>(B)</strong>, I get an <code>UnboundLocalError: 'c' not assigned</code> at line <strong>(A)</strong>. The values of <code>a</code> and <code>b</code> are printed correctly. This has me completely baffled for two reasons:</p>

<ol>
<li><p>Why is there a runtime error thrown at line <strong>(A)</strong> because of a later statement on line <strong>(B)</strong>?</p></li>
<li><p>Why are variables <code>a</code> and <code>b</code> printed as expected, while <code>c</code> raises an error?</p></li>
</ol>

<p>The only explanation I can come up with is that a <strong>local</strong> variable <code>c</code> is created by the assignment <code>c+=1</code>, which takes precedent over the "global" variable <code>c</code> even before the local variable is created. Of course, it doesn't make sense for a variable to "steal" scope before it exists.</p>

<p>Could someone please explain this behavior?</p>
    </div></div></div><div class="solution-section"><nav class="flex pagination-solution flex-col justify-end"><ul class="inline-flex -space-x-px overflow-auto"><li class="pagination-solution-item"><span data-id="#solution1" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">1</span></li><li class="pagination-solution-item"><span data-id="#solution2" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">2</span></li><li class="pagination-solution-item"><span data-id="#solution3" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">3</span></li><li class="pagination-solution-item"><span data-id="#solution4" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">4</span></li><li class="pagination-solution-item"><span data-id="#solution5" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">5</span></li><li class="pagination-solution-item"><span data-id="#solution6" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">6</span></li><li class="pagination-solution-item"><span data-id="#solution7" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">7</span></li><li class="pagination-solution-item"><span data-id="#solution8" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">8</span></li><li class="pagination-solution-item"><span data-id="#solution9" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">9</span></li><li class="pagination-solution-item"><span data-id="#solution10" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">10</span></li><li class="pagination-solution-item"><span data-id="#solution11" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">11</span></li><li class="pagination-solution-item"><span data-id="#solution12" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">12</span></li><li class="pagination-solution-item"><span data-id="#solution13" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">13</span></li></ul></nav><div id="solution1" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 1</h4><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Python treats variables in functions differently depending on whether you assign values to them from inside or outside the function.  If a variable is assigned within a function, it is treated by default as a local variable.  Therefore, when you uncomment the line, you are trying to reference the local variable <code>c</code> before any value has been assigned to it.</p>
<p>If you want the variable <code>c</code> to refer to the global <code>c = 3</code> assigned before the function, put</p>
<pre class="lang-py s-code-block"><code class="hljs language-python"><span class="hljs-keyword">global</span> c
</code></pre>
<p>as the first line of the function.</p>
<p>As for python 3, there is now</p>
<pre class="lang-py s-code-block"><code class="hljs language-python"><span class="hljs-keyword">nonlocal</span> c
</code></pre>
<p>that you can use to refer to the nearest enclosing function scope that has a <code>c</code> variable.</p>
    </div></div></div></div><div id="solution2" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 2</h4><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Python is a little weird in that it keeps everything in a dictionary for the various scopes.  The original a,b,c are in the uppermost scope and so in that uppermost dictionary.  The function has its own dictionary.  When you reach the <code>print(a)</code> and <code>print(b)</code> statements, there's nothing by that name in the dictionary, so Python looks up the list and finds them in the global dictionary.</p>

<p>Now we get to <code>c+=1</code>, which is, of course, equivalent to <code>c=c+1</code>.  When Python scans that line, it says "aha, there's a variable named c, I'll put it into my local scope dictionary."  Then when it goes looking for a value for c for the c on the right hand side of the assignment, it finds its <em>local variable named c</em>, which has no value yet, and so throws the error.</p>

<p>The statement <code>global c</code> mentioned above simply tells the parser that it uses the <code>c</code> from the global scope and so doesn't need a new one.</p>

<p>The reason it says there's an issue on the line it does is because it is effectively looking for the names before it tries to generate code, and so in some sense doesn't think it's really doing that line yet.  I'd argue that is a usability bug, but it's generally a good practice to just learn not to take a compiler's messages <em>too</em> seriously.</p>

<p>If it's any comfort, I spent probably a day digging and experimenting with this same issue before I found something Guido had written about the dictionaries that Explained Everything.</p>

<h3>Update, see comments:</h3>

<p>It doesn't scan the code twice, but it does scan the code in two phases, lexing and parsing.</p>

<p>Consider how the parse of this line of code works.  The lexer reads the source text and breaks it into lexemes, the "smallest components" of the grammar.  So when it hits the line</p>

<pre class="lang-py s-code-block"><code class="hljs language-python">c+=<span class="hljs-number">1</span>
</code></pre>

<p>it breaks it up into something like</p>

<pre class="lang-py s-code-block"><code class="hljs language-python">SYMBOL(c) OPERATOR(+=) DIGIT(<span class="hljs-number">1</span>)
</code></pre>

<p>The parser eventually wants to make this into a parse tree and execute it, but since it's an assignment, before it does, it looks for the name c in the local dictionary, doesn't see it, and inserts it in the dictionary, marking it as uninitialized. In a fully compiled language, it would just go into the symbol table and wait for the parse, but since it WON'T have the luxury of a second pass, the lexer does a little extra work to make life easier later on.   Only, then it sees the OPERATOR, sees that the rules say "if you have an operator += the left hand side must have been initialized" and says "whoops!"</p>

<p>The point here is that it <em>hasn't really started the parse of the line yet</em>.  This is all happening sort of preparatory to the actual parse, so the line counter hasn't advanced to the next line.  Thus when it signals the error, it still thinks its on the previous line.</p>

<p>As I say, you could argue it's a usability bug, but its actually a fairly common thing.  Some compilers are more honest about it and say "error on or around line XXX", but this one doesn't.</p>
    </div></div></div></div><div id="solution3" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 3</h4><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Taking a look at the disassembly may clarify what is happening:</p>

<pre class="lang-py s-code-block"><code class="hljs language-python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">def</span> <span class="hljs-title function_">f</span>():
<span class="hljs-meta">... </span>   <span class="hljs-built_in">print</span> a
<span class="hljs-meta">... </span>   <span class="hljs-built_in">print</span> b
<span class="hljs-meta">... </span>   a = <span class="hljs-number">1</span>

<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> dis
<span class="hljs-meta">&gt;&gt;&gt; </span>dis.dis(f)

  <span class="hljs-number">2</span>           <span class="hljs-number">0</span> LOAD_FAST                <span class="hljs-number">0</span> (a)
              <span class="hljs-number">3</span> PRINT_ITEM
              <span class="hljs-number">4</span> PRINT_NEWLINE

  <span class="hljs-number">3</span>           <span class="hljs-number">5</span> LOAD_GLOBAL              <span class="hljs-number">0</span> (b)
              <span class="hljs-number">8</span> PRINT_ITEM
              <span class="hljs-number">9</span> PRINT_NEWLINE

  <span class="hljs-number">4</span>          <span class="hljs-number">10</span> LOAD_CONST               <span class="hljs-number">1</span> (<span class="hljs-number">1</span>)
             <span class="hljs-number">13</span> STORE_FAST               <span class="hljs-number">0</span> (a)
             <span class="hljs-number">16</span> LOAD_CONST               <span class="hljs-number">0</span> (<span class="hljs-literal">None</span>)
             <span class="hljs-number">19</span> RETURN_VALUE
</code></pre>

<p>As you can see, the bytecode for accessing a is <code>LOAD_FAST</code>, and for b, <code>LOAD_GLOBAL</code>.  This is because the compiler has identified that a is assigned to within the function, and classified it as a local variable.  The access mechanism for locals is fundamentally different for globals - they are statically assigned an offset in the frame's variables table, meaning lookup is a quick index, rather than the more expensive dict lookup as for globals.  Because of this, Python is reading the <code>print a</code> line as "get the value of local variable 'a' held in slot 0, and print it", and when it detects that this variable is still uninitialised, raises an exception.</p>
    </div></div></div></div><div id="solution4" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 4</h4><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Python has rather interesting behavior when you try traditional global variable semantics.  I don't remember the details, but you can read the value of a variable declared in 'global' scope just fine, but if you want to modify it, you have to use the <code>global</code> keyword.  Try changing <code>test()</code> to this:</p>

<pre class="lang-py s-code-block"><code class="hljs language-python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">test</span>():
    <span class="hljs-keyword">global</span> c
    <span class="hljs-built_in">print</span>(a)
    <span class="hljs-built_in">print</span>(b)
    <span class="hljs-built_in">print</span>(c)    <span class="hljs-comment"># (A)</span>
    c+=<span class="hljs-number">1</span>        <span class="hljs-comment"># (B)</span>
</code></pre>

<p>Also, the reason you are getting this error is because you can also declare a new variable inside that function with the same name as a 'global' one, and it would be completely separate.  The interpreter thinks you are trying to make a new variable in this scope called <code>c</code> and modify it all in one operation, which isn't allowed in Python because this new <code>c</code> wasn't initialized.</p>
    </div></div></div></div><div id="solution5" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 5</h4><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>The best example that makes it clear is:</p>

<pre class="lang-py s-code-block"><code class="hljs language-python">bar = <span class="hljs-number">42</span>
<span class="hljs-keyword">def</span> <span class="hljs-title function_">foo</span>():
    <span class="hljs-built_in">print</span> bar
    <span class="hljs-keyword">if</span> <span class="hljs-literal">False</span>:
        bar = <span class="hljs-number">0</span>
</code></pre>

<p>when calling <code>foo()</code> , this also <strong>raises</strong> <code>UnboundLocalError</code> although we will never reach to line <code>bar=0</code>, so logically local variable should never be created.</p>

<p>The mystery lies in "<strong>Python is an Interpreted Language</strong>" and the declaration of the function <code>foo</code> is interpreted as a single statement (i.e. a compound statement), it just interprets it dumbly and creates local and global scopes. So <code>bar</code> is recognized in local scope before execution.</p>

<p>For <strong>more examples</strong> like this Read this post: <a href="http://blog.amir.rachum.com/blog/2013/07/09/python-common-newbie-mistakes-part-2/" rel="noreferrer">http://blog.amir.rachum.com/blog/2013/07/09/python-common-newbie-mistakes-part-2/</a></p>

<p>This post provides a Complete Description and Analyses of the Python Scoping of variables:</p>
    </div></div></div></div><div id="solution6" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 6</h4><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Here are two links that may help</p>

<p>1: <a href="http://docs.python.org/3.1/faq/programming.html?highlight=nonlocal#why-am-i-getting-an-unboundlocalerror-when-the-variable-has-a-value" rel="nofollow noreferrer">docs.python.org/3.1/faq/programming.html?highlight=nonlocal#why-am-i-getting-an-unboundlocalerror-when-the-variable-has-a-value</a></p>

<p>2: <a href="http://docs.python.org/3.1/faq/programming.html?highlight=nonlocal#how-do-i-write-a-function-with-output-parameters-call-by-reference" rel="nofollow noreferrer">docs.python.org/3.1/faq/programming.html?highlight=nonlocal#how-do-i-write-a-function-with-output-parameters-call-by-reference</a></p>

<p>link one describes the error UnboundLocalError.  Link two can help with with re-writing your test function.  Based on link two, the original problem could be rewritten as:</p>

<pre class="lang-py s-code-block"><code class="hljs language-python"><span class="hljs-meta">&gt;&gt;&gt; </span>a, b, c = (<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">print</span> (a, b, c)
(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">def</span> <span class="hljs-title function_">test</span> (a, b, c):
<span class="hljs-meta">... </span>    <span class="hljs-built_in">print</span> (a)
<span class="hljs-meta">... </span>    <span class="hljs-built_in">print</span> (b)
<span class="hljs-meta">... </span>    <span class="hljs-built_in">print</span> (c)
<span class="hljs-meta">... </span>    c += <span class="hljs-number">1</span>
<span class="hljs-meta">... </span>    <span class="hljs-keyword">return</span> a, b, c
...
<span class="hljs-meta">&gt;&gt;&gt; </span>a, b, c = test (a, b, c)
<span class="hljs-number">1</span>
<span class="hljs-number">2</span>
<span class="hljs-number">3</span>
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">print</span> (a, b ,c)
(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>)
</code></pre>
    </div></div></div></div><div id="solution7" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 7</h4><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>This is not a direct answer to your question, but it is closely related, as it's another gotcha caused by the relationship between augmented assignment and function scopes.</p>

<p>In most cases, you tend to think of augmented assignment (<code>a += b</code>) as exactly equivalent to simple assignment (<code>a = a + b</code>). It is possible to get into some trouble with this though, in one corner case. Let me explain:</p>

<p>The way Python's simple assignment works means that if <code>a</code> is passed into a function (like <code>func(a)</code>; note that Python is always pass-by-reference), then <code>a = a + b</code> will not modify the <code>a</code> that is passed in. Instead, it will just modify the local pointer to <code>a</code>. </p>

<p>But if you use <code>a += b</code>, then it is sometimes implemented as:</p>

<pre class="lang-py s-code-block"><code class="hljs language-python">a = a + b
</code></pre>

<p>or sometimes (if the method exists) as:</p>

<pre class="lang-py s-code-block"><code class="hljs language-python">a.__iadd__(b)
</code></pre>

<p>In the first case (as long as <code>a</code> is not declared global), there are no side-effects outside local scope, as the assignment to <code>a</code> is just a pointer update.</p>

<p>In the second case, <code>a</code> will actually modify itself, so all references to <code>a</code> will point to the modified version. This is demonstrated by the following code:</p>

<pre class="lang-py s-code-block"><code class="hljs language-python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">copy_on_write</span>(<span class="hljs-params">a</span>):
      a = a + a
<span class="hljs-keyword">def</span> <span class="hljs-title function_">inplace_add</span>(<span class="hljs-params">a</span>):
      a += a
a = [<span class="hljs-number">1</span>]
copy_on_write(a)
<span class="hljs-built_in">print</span> a <span class="hljs-comment"># [1]</span>
inplace_add(a)
<span class="hljs-built_in">print</span> a <span class="hljs-comment"># [1, 1]</span>
b = <span class="hljs-number">1</span>
copy_on_write(b)
<span class="hljs-built_in">print</span> b <span class="hljs-comment"># [1]</span>
inplace_add(b)
<span class="hljs-built_in">print</span> b <span class="hljs-comment"># 1</span>
</code></pre>

<p>So the trick is to avoid augmented assignment on function arguments (I try to only use it for local/loop variables). Use simple assignment, and you will be safe from ambiguous behaviour. </p>
    </div></div></div></div><div id="solution8" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 8</h4><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>The Python interpreter will read a function as a complete unit. I think of it as reading it in two passes, once to gather its closure (the local variables), then again to turn it into byte-code.</p>

<p>As I'm sure you were already aware, any name used on the left of a '=' is implicitly a local variable. More than once I've been caught out by changing a variable access to a += and it's suddenly a different variable.</p>

<p>I also wanted to point out it's not really anything to do with global scope specifically. You get the same behaviour with nested functions.</p>
    </div></div></div></div><div id="solution9" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 9</h4><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p><code>c+=1</code> assigns <code>c</code>, python assumes assigned variables are local, but in this case it hasn't been declared locally.</p>

<p>Either use the <code>global</code> or <code>nonlocal</code> keywords. </p>

<p><code>nonlocal</code> works only in python 3, so if you're using python 2 and don't want to make your variable global, you can use a mutable object:</p>

<pre class="lang-py s-code-block"><code class="hljs language-python">my_variables = { <span class="hljs-comment"># a mutable object</span>
    <span class="hljs-string">'c'</span>: <span class="hljs-number">3</span>
}

<span class="hljs-keyword">def</span> <span class="hljs-title function_">test</span>():
    my_variables[<span class="hljs-string">'c'</span>] +=<span class="hljs-number">1</span>

test()
</code></pre>
    </div></div></div></div><div id="solution10" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 10</h4><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>The best way to reach class variable is directly accesing by class name</p>

<pre class="lang-py s-code-block"><code class="hljs language-python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Employee</span>:
    counter=<span class="hljs-number">0</span>

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):
        Employee.counter+=<span class="hljs-number">1</span>
</code></pre>
    </div></div></div></div><div id="solution11" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 11</h4><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>You can also get this message if you define a variable with the same name as a method.</p>
<p>For example:</p>
<pre class="lang-py s-code-block"><code class="hljs language-python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">teams</span>():
    ...

<span class="hljs-keyword">def</span> <span class="hljs-title function_">some_other_method</span>():
    teams = teams()
</code></pre>
<p>The solution, is to rename method <code>teams()</code> to something else like <code>get_teams()</code>.</p>
<p>Since it is only used locally, the Python message is rather misleading!</p>
<p>You end up with something like this to get around it:</p>
<pre class="lang-py s-code-block"><code class="hljs language-python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">teams</span>():
    ...

<span class="hljs-keyword">def</span> <span class="hljs-title function_">some_other_method</span>():
    teams = get_teams()
</code></pre>
    </div></div></div></div><div id="solution12" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 12</h4><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>This issue can also occur when the <code>del</code> keyword is utilized on the variable down the line, after initialization, typically in a loop or a conditional block.</p>
    </div></div></div></div><div id="solution13" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 13</h4><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>The same problem bothers me. Using <code>nonlocal</code> and <code>global</code> can solve the problem.<br>
However, attention is needed for the usage of <code>nonlocal</code>, it works for nested functions. However, at the module level, it does not work. See <a href="https://www.programiz.com/python-programming/global-local-nonlocal-variables#Nonlocal%20Variables" rel="nofollow noreferrer">examples</a> here.</p>
    </div></div></div></div></div></div><div class="widget"><a href="/questions/the-use-of-multiple-jframes:-good-or-bad-practice-closed-1657384478184">The Use of Multiple JFrames: Good or Bad Practice? [closed]</a><a href="/questions/how-can-i-access-and-process-nested-objects-arrays-or-json-1657384332823">How can I access and process nested objects, arrays, or JSON?</a><a href="/questions/the-usestate-set-method-is-not-reflecting-a-change-immediately-1657384524775">The useState set method is not reflecting a change immediately</a><a href="/questions/what-is-the-difference-between-and-equals()-in-java-1657387729654">What is the difference between == and equals() in Java?</a><a href="/questions/what-to-do-regular-expression-pattern-doesn&#x27;t-match-anywhere-in-string-1657388095896">What to do Regular expression pattern doesn&#x27;t match anywhere in string?</a><a href="/questions/why-does-the-order-in-which-libraries-are-linked-sometimes-cause-errors-in-gcc-1657387609554">Why does the order in which libraries are linked sometimes cause errors in GCC?</a><a href="/questions/change-the-maximum-upload-file-size-1657388495156">Change the maximum upload file size</a><a href="/questions/what-is-the-purpose-of-the-var-keyword-and-when-should-i-use-it-(or-omit-it)-1657387525538">What is the purpose of the var keyword and when should I use it (or omit it)?</a><a href="/questions/what-is-the-best-way-to-detect-a-mobile-device-1657387665025">What is the best way to detect a mobile device?</a><a href="/questions/how-to-access-a-local-variable-from-a-different-function-using-pointers-1657388159760">How to access a local variable from a different function using pointers?</a><a href="/questions/does-python-have-a-ternary-conditional-operator-1657387555448">Does Python have a ternary conditional operator?</a><a href="/questions/efficiently-convert-rows-to-columns-in-sql-server-1657387919213">Efficiently convert rows to columns in sql server</a><a href="/questions/how-do-i-merge-two-dictionaries-in-a-single-expression-1657387593160">How do I merge two dictionaries in a single expression?</a><a href="/questions/variables-are-not-behaving-as-expected-1657384865672">Variables are not behaving as expected</a><a href="/questions/are-dictionaries-ordered-in-python-3.6+-1657387834234">Are dictionaries ordered in Python 3.6+?</a><a href="/questions/default-constructor-with-empty-brackets-1657388246967">Default constructor with empty brackets</a><a href="/questions/what-is-viewmodel-in-mvc-1657387451244">What is ViewModel in MVC?</a><a href="/questions/why-use-getters-and-settersaccessors-1657387343971">Why use getters and setters/accessors?</a><a href="/questions/how-to-parse-json-in-java-1657384575136">How to parse JSON in Java</a><a href="/questions/var-functionname-function()-vs-function-functionname()-1657384724077">var functionName = function() {} vs function functionName() {}</a></div></div><span class="cursor-pointer text-lg p-2" style="position:fixed;bottom:20px;left:20px;background:#000;z-index:2000;color:white">Go go top</span></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"data":{"answer":["\n\u0026lt;p\u0026gt;Python treats variables in functions differently depending on whether you assign values to them from inside or outside the function.  If a variable is assigned within a function, it is treated by default as a local variable.  Therefore, when you uncomment the line, you are trying to reference the local variable \u0026lt;code\u0026gt;c\u0026lt;/code\u0026gt; before any value has been assigned to it.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;If you want the variable \u0026lt;code\u0026gt;c\u0026lt;/code\u0026gt; to refer to the global \u0026lt;code\u0026gt;c = 3\u0026lt;/code\u0026gt; assigned before the function, put\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;global\u0026lt;/span\u0026gt; c\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;as the first line of the function.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;As for python 3, there is now\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;nonlocal\u0026lt;/span\u0026gt; c\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;that you can use to refer to the nearest enclosing function scope that has a \u0026lt;code\u0026gt;c\u0026lt;/code\u0026gt; variable.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Python is a little weird in that it keeps everything in a dictionary for the various scopes.  The original a,b,c are in the uppermost scope and so in that uppermost dictionary.  The function has its own dictionary.  When you reach the \u0026lt;code\u0026gt;print(a)\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;print(b)\u0026lt;/code\u0026gt; statements, there\u0026apos;s nothing by that name in the dictionary, so Python looks up the list and finds them in the global dictionary.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Now we get to \u0026lt;code\u0026gt;c+=1\u0026lt;/code\u0026gt;, which is, of course, equivalent to \u0026lt;code\u0026gt;c=c+1\u0026lt;/code\u0026gt;.  When Python scans that line, it says \u0026quot;aha, there\u0026apos;s a variable named c, I\u0026apos;ll put it into my local scope dictionary.\u0026quot;  Then when it goes looking for a value for c for the c on the right hand side of the assignment, it finds its \u0026lt;em\u0026gt;local variable named c\u0026lt;/em\u0026gt;, which has no value yet, and so throws the error.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;The statement \u0026lt;code\u0026gt;global c\u0026lt;/code\u0026gt; mentioned above simply tells the parser that it uses the \u0026lt;code\u0026gt;c\u0026lt;/code\u0026gt; from the global scope and so doesn\u0026apos;t need a new one.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;The reason it says there\u0026apos;s an issue on the line it does is because it is effectively looking for the names before it tries to generate code, and so in some sense doesn\u0026apos;t think it\u0026apos;s really doing that line yet.  I\u0026apos;d argue that is a usability bug, but it\u0026apos;s generally a good practice to just learn not to take a compiler\u0026apos;s messages \u0026lt;em\u0026gt;too\u0026lt;/em\u0026gt; seriously.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;If it\u0026apos;s any comfort, I spent probably a day digging and experimenting with this same issue before I found something Guido had written about the dictionaries that Explained Everything.\u0026lt;/p\u0026gt;\n\n\u0026lt;h3\u0026gt;Update, see comments:\u0026lt;/h3\u0026gt;\n\n\u0026lt;p\u0026gt;It doesn\u0026apos;t scan the code twice, but it does scan the code in two phases, lexing and parsing.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Consider how the parse of this line of code works.  The lexer reads the source text and breaks it into lexemes, the \u0026quot;smallest components\u0026quot; of the grammar.  So when it hits the line\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;c+=\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;it breaks it up into something like\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;SYMBOL(c) OPERATOR(+=) DIGIT(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;)\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;The parser eventually wants to make this into a parse tree and execute it, but since it\u0026apos;s an assignment, before it does, it looks for the name c in the local dictionary, doesn\u0026apos;t see it, and inserts it in the dictionary, marking it as uninitialized. In a fully compiled language, it would just go into the symbol table and wait for the parse, but since it WON\u0026apos;T have the luxury of a second pass, the lexer does a little extra work to make life easier later on.   Only, then it sees the OPERATOR, sees that the rules say \u0026quot;if you have an operator += the left hand side must have been initialized\u0026quot; and says \u0026quot;whoops!\u0026quot;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;The point here is that it \u0026lt;em\u0026gt;hasn\u0026apos;t really started the parse of the line yet\u0026lt;/em\u0026gt;.  This is all happening sort of preparatory to the actual parse, so the line counter hasn\u0026apos;t advanced to the next line.  Thus when it signals the error, it still thinks its on the previous line.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;As I say, you could argue it\u0026apos;s a usability bug, but its actually a fairly common thing.  Some compilers are more honest about it and say \u0026quot;error on or around line XXX\u0026quot;, but this one doesn\u0026apos;t.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Taking a look at the disassembly may clarify what is happening:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026amp;gt; \u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;def\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;f\u0026lt;/span\u0026gt;():\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;... \u0026lt;/span\u0026gt;   \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt; a\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;... \u0026lt;/span\u0026gt;   \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt; b\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;... \u0026lt;/span\u0026gt;   a = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026amp;gt; \u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;import\u0026lt;/span\u0026gt; dis\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026amp;gt; \u0026lt;/span\u0026gt;dis.dis(f)\n\n  \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;           \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt; LOAD_FAST                \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt; (a)\n              \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3\u0026lt;/span\u0026gt; PRINT_ITEM\n              \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;4\u0026lt;/span\u0026gt; PRINT_NEWLINE\n\n  \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3\u0026lt;/span\u0026gt;           \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;5\u0026lt;/span\u0026gt; LOAD_GLOBAL              \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt; (b)\n              \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;8\u0026lt;/span\u0026gt; PRINT_ITEM\n              \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;9\u0026lt;/span\u0026gt; PRINT_NEWLINE\n\n  \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;4\u0026lt;/span\u0026gt;          \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;10\u0026lt;/span\u0026gt; LOAD_CONST               \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt; (\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;)\n             \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;13\u0026lt;/span\u0026gt; STORE_FAST               \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt; (a)\n             \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;16\u0026lt;/span\u0026gt; LOAD_CONST               \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt; (\u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;None\u0026lt;/span\u0026gt;)\n             \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;19\u0026lt;/span\u0026gt; RETURN_VALUE\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;As you can see, the bytecode for accessing a is \u0026lt;code\u0026gt;LOAD_FAST\u0026lt;/code\u0026gt;, and for b, \u0026lt;code\u0026gt;LOAD_GLOBAL\u0026lt;/code\u0026gt;.  This is because the compiler has identified that a is assigned to within the function, and classified it as a local variable.  The access mechanism for locals is fundamentally different for globals - they are statically assigned an offset in the frame\u0026apos;s variables table, meaning lookup is a quick index, rather than the more expensive dict lookup as for globals.  Because of this, Python is reading the \u0026lt;code\u0026gt;print a\u0026lt;/code\u0026gt; line as \u0026quot;get the value of local variable \u0026apos;a\u0026apos; held in slot 0, and print it\u0026quot;, and when it detects that this variable is still uninitialised, raises an exception.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Python has rather interesting behavior when you try traditional global variable semantics.  I don\u0026apos;t remember the details, but you can read the value of a variable declared in \u0026apos;global\u0026apos; scope just fine, but if you want to modify it, you have to use the \u0026lt;code\u0026gt;global\u0026lt;/code\u0026gt; keyword.  Try changing \u0026lt;code\u0026gt;test()\u0026lt;/code\u0026gt; to this:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;def\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;test\u0026lt;/span\u0026gt;():\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;global\u0026lt;/span\u0026gt; c\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt;(a)\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt;(b)\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt;(c)    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;# (A)\u0026lt;/span\u0026gt;\n    c+=\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;        \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;# (B)\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Also, the reason you are getting this error is because you can also declare a new variable inside that function with the same name as a \u0026apos;global\u0026apos; one, and it would be completely separate.  The interpreter thinks you are trying to make a new variable in this scope called \u0026lt;code\u0026gt;c\u0026lt;/code\u0026gt; and modify it all in one operation, which isn\u0026apos;t allowed in Python because this new \u0026lt;code\u0026gt;c\u0026lt;/code\u0026gt; wasn\u0026apos;t initialized.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;The best example that makes it clear is:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;bar = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;42\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;def\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;foo\u0026lt;/span\u0026gt;():\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt; bar\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;False\u0026lt;/span\u0026gt;:\n        bar = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;when calling \u0026lt;code\u0026gt;foo()\u0026lt;/code\u0026gt; , this also \u0026lt;strong\u0026gt;raises\u0026lt;/strong\u0026gt; \u0026lt;code\u0026gt;UnboundLocalError\u0026lt;/code\u0026gt; although we will never reach to line \u0026lt;code\u0026gt;bar=0\u0026lt;/code\u0026gt;, so logically local variable should never be created.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;The mystery lies in \u0026quot;\u0026lt;strong\u0026gt;Python is an Interpreted Language\u0026lt;/strong\u0026gt;\u0026quot; and the declaration of the function \u0026lt;code\u0026gt;foo\u0026lt;/code\u0026gt; is interpreted as a single statement (i.e. a compound statement), it just interprets it dumbly and creates local and global scopes. So \u0026lt;code\u0026gt;bar\u0026lt;/code\u0026gt; is recognized in local scope before execution.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;For \u0026lt;strong\u0026gt;more examples\u0026lt;/strong\u0026gt; like this Read this post: \u0026lt;a href=\u0026quot;http://blog.amir.rachum.com/blog/2013/07/09/python-common-newbie-mistakes-part-2/\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;http://blog.amir.rachum.com/blog/2013/07/09/python-common-newbie-mistakes-part-2/\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;This post provides a Complete Description and Analyses of the Python Scoping of variables:\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Here are two links that may help\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;1: \u0026lt;a href=\u0026quot;http://docs.python.org/3.1/faq/programming.html?highlight=nonlocal#why-am-i-getting-an-unboundlocalerror-when-the-variable-has-a-value\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;docs.python.org/3.1/faq/programming.html?highlight=nonlocal#why-am-i-getting-an-unboundlocalerror-when-the-variable-has-a-value\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;2: \u0026lt;a href=\u0026quot;http://docs.python.org/3.1/faq/programming.html?highlight=nonlocal#how-do-i-write-a-function-with-output-parameters-call-by-reference\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;docs.python.org/3.1/faq/programming.html?highlight=nonlocal#how-do-i-write-a-function-with-output-parameters-call-by-reference\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;link one describes the error UnboundLocalError.  Link two can help with with re-writing your test function.  Based on link two, the original problem could be rewritten as:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026amp;gt; \u0026lt;/span\u0026gt;a, b, c = (\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3\u0026lt;/span\u0026gt;)\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026amp;gt; \u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt; (a, b, c)\n(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3\u0026lt;/span\u0026gt;)\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026amp;gt; \u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;def\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;test\u0026lt;/span\u0026gt; (a, b, c):\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;... \u0026lt;/span\u0026gt;    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt; (a)\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;... \u0026lt;/span\u0026gt;    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt; (b)\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;... \u0026lt;/span\u0026gt;    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt; (c)\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;... \u0026lt;/span\u0026gt;    c += \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;... \u0026lt;/span\u0026gt;    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; a, b, c\n...\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026amp;gt; \u0026lt;/span\u0026gt;a, b, c = test (a, b, c)\n\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026amp;gt; \u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt; (a, b ,c)\n(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;4\u0026lt;/span\u0026gt;)\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;This is not a direct answer to your question, but it is closely related, as it\u0026apos;s another gotcha caused by the relationship between augmented assignment and function scopes.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;In most cases, you tend to think of augmented assignment (\u0026lt;code\u0026gt;a += b\u0026lt;/code\u0026gt;) as exactly equivalent to simple assignment (\u0026lt;code\u0026gt;a = a + b\u0026lt;/code\u0026gt;). It is possible to get into some trouble with this though, in one corner case. Let me explain:\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;The way Python\u0026apos;s simple assignment works means that if \u0026lt;code\u0026gt;a\u0026lt;/code\u0026gt; is passed into a function (like \u0026lt;code\u0026gt;func(a)\u0026lt;/code\u0026gt;; note that Python is always pass-by-reference), then \u0026lt;code\u0026gt;a = a + b\u0026lt;/code\u0026gt; will not modify the \u0026lt;code\u0026gt;a\u0026lt;/code\u0026gt; that is passed in. Instead, it will just modify the local pointer to \u0026lt;code\u0026gt;a\u0026lt;/code\u0026gt;. \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;But if you use \u0026lt;code\u0026gt;a += b\u0026lt;/code\u0026gt;, then it is sometimes implemented as:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;a = a + b\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;or sometimes (if the method exists) as:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;a.__iadd__(b)\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;In the first case (as long as \u0026lt;code\u0026gt;a\u0026lt;/code\u0026gt; is not declared global), there are no side-effects outside local scope, as the assignment to \u0026lt;code\u0026gt;a\u0026lt;/code\u0026gt; is just a pointer update.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;In the second case, \u0026lt;code\u0026gt;a\u0026lt;/code\u0026gt; will actually modify itself, so all references to \u0026lt;code\u0026gt;a\u0026lt;/code\u0026gt; will point to the modified version. This is demonstrated by the following code:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;def\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;copy_on_write\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;a\u0026lt;/span\u0026gt;):\n      a = a + a\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;def\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;inplace_add\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;a\u0026lt;/span\u0026gt;):\n      a += a\na = [\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;]\ncopy_on_write(a)\n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt; a \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;# [1]\u0026lt;/span\u0026gt;\ninplace_add(a)\n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt; a \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;# [1, 1]\u0026lt;/span\u0026gt;\nb = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;\ncopy_on_write(b)\n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt; b \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;# [1]\u0026lt;/span\u0026gt;\ninplace_add(b)\n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt; b \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;# 1\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;So the trick is to avoid augmented assignment on function arguments (I try to only use it for local/loop variables). Use simple assignment, and you will be safe from ambiguous behaviour. \u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;The Python interpreter will read a function as a complete unit. I think of it as reading it in two passes, once to gather its closure (the local variables), then again to turn it into byte-code.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;As I\u0026apos;m sure you were already aware, any name used on the left of a \u0026apos;=\u0026apos; is implicitly a local variable. More than once I\u0026apos;ve been caught out by changing a variable access to a += and it\u0026apos;s suddenly a different variable.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;I also wanted to point out it\u0026apos;s not really anything to do with global scope specifically. You get the same behaviour with nested functions.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;\u0026lt;code\u0026gt;c+=1\u0026lt;/code\u0026gt; assigns \u0026lt;code\u0026gt;c\u0026lt;/code\u0026gt;, python assumes assigned variables are local, but in this case it hasn\u0026apos;t been declared locally.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Either use the \u0026lt;code\u0026gt;global\u0026lt;/code\u0026gt; or \u0026lt;code\u0026gt;nonlocal\u0026lt;/code\u0026gt; keywords. \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;code\u0026gt;nonlocal\u0026lt;/code\u0026gt; works only in python 3, so if you\u0026apos;re using python 2 and don\u0026apos;t want to make your variable global, you can use a mutable object:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;my_variables = { \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;# a mutable object\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;c\u0026apos;\u0026lt;/span\u0026gt;: \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3\u0026lt;/span\u0026gt;\n}\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;def\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;test\u0026lt;/span\u0026gt;():\n    my_variables[\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;c\u0026apos;\u0026lt;/span\u0026gt;] +=\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;\n\ntest()\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;The best way to reach class variable is directly accesing by class name\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Employee\u0026lt;/span\u0026gt;:\n    counter=\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;def\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;__init__\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;self\u0026lt;/span\u0026gt;):\n        Employee.counter+=\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;You can also get this message if you define a variable with the same name as a method.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;For example:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;def\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;teams\u0026lt;/span\u0026gt;():\n    ...\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;def\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;some_other_method\u0026lt;/span\u0026gt;():\n    teams = teams()\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;The solution, is to rename method \u0026lt;code\u0026gt;teams()\u0026lt;/code\u0026gt; to something else like \u0026lt;code\u0026gt;get_teams()\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Since it is only used locally, the Python message is rather misleading!\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;You end up with something like this to get around it:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;def\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;teams\u0026lt;/span\u0026gt;():\n    ...\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;def\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;some_other_method\u0026lt;/span\u0026gt;():\n    teams = get_teams()\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;This issue can also occur when the \u0026lt;code\u0026gt;del\u0026lt;/code\u0026gt; keyword is utilized on the variable down the line, after initialization, typically in a loop or a conditional block.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;The same problem bothers me. Using \u0026lt;code\u0026gt;nonlocal\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;global\u0026lt;/code\u0026gt; can solve the problem.\u0026lt;br\u0026gt;\nHowever, attention is needed for the usage of \u0026lt;code\u0026gt;nonlocal\u0026lt;/code\u0026gt;, it works for nested functions. However, at the module level, it does not work. See \u0026lt;a href=\u0026quot;https://www.programiz.com/python-programming/global-local-nonlocal-variables#Nonlocal%20Variables\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;examples\u0026lt;/a\u0026gt; here.\u0026lt;/p\u0026gt;\n    "],"id":339,"title":"UnboundLocalError on local variable when reassigned after first use","content":"\n                \n\u0026lt;p\u0026gt;The following code works as expected in both Python 2.5 and 3.0:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;a, b, c = (\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3\u0026lt;/span\u0026gt;)\n\n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt;(a, b, c)\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;def\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;test\u0026lt;/span\u0026gt;():\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt;(a)\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt;(b)\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt;(c)    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;# (A)\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;#c+=1       # (B)\u0026lt;/span\u0026gt;\ntest()\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;However, when I uncomment line \u0026lt;strong\u0026gt;(B)\u0026lt;/strong\u0026gt;, I get an \u0026lt;code\u0026gt;UnboundLocalError: \u0026apos;c\u0026apos; not assigned\u0026lt;/code\u0026gt; at line \u0026lt;strong\u0026gt;(A)\u0026lt;/strong\u0026gt;. The values of \u0026lt;code\u0026gt;a\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;b\u0026lt;/code\u0026gt; are printed correctly. This has me completely baffled for two reasons:\u0026lt;/p\u0026gt;\n\n\u0026lt;ol\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;Why is there a runtime error thrown at line \u0026lt;strong\u0026gt;(A)\u0026lt;/strong\u0026gt; because of a later statement on line \u0026lt;strong\u0026gt;(B)\u0026lt;/strong\u0026gt;?\u0026lt;/p\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;Why are variables \u0026lt;code\u0026gt;a\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;b\u0026lt;/code\u0026gt; printed as expected, while \u0026lt;code\u0026gt;c\u0026lt;/code\u0026gt; raises an error?\u0026lt;/p\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;/ol\u0026gt;\n\n\u0026lt;p\u0026gt;The only explanation I can come up with is that a \u0026lt;strong\u0026gt;local\u0026lt;/strong\u0026gt; variable \u0026lt;code\u0026gt;c\u0026lt;/code\u0026gt; is created by the assignment \u0026lt;code\u0026gt;c+=1\u0026lt;/code\u0026gt;, which takes precedent over the \u0026quot;global\u0026quot; variable \u0026lt;code\u0026gt;c\u0026lt;/code\u0026gt; even before the local variable is created. Of course, it doesn\u0026apos;t make sense for a variable to \u0026quot;steal\u0026quot; scope before it exists.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Could someone please explain this behavior?\u0026lt;/p\u0026gt;\n    ","slug":"unboundlocalerror-on-local-variable-when-reassigned-after-first-use-1657387685248","postType":"QUESTION","createdAt":"2022-07-09T17:28:05.000Z","updatedAt":"2022-07-09T17:28:05.000Z","tags":[],"relatedQuestions":[]},"randomQuestions":[{"title":"The Use of Multiple JFrames: Good or Bad Practice? [closed]","slug":"the-use-of-multiple-jframes:-good-or-bad-practice-closed-1657384478184"},{"title":"How can I access and process nested objects, arrays, or JSON?","slug":"how-can-i-access-and-process-nested-objects-arrays-or-json-1657384332823"},{"title":"The useState set method is not reflecting a change immediately","slug":"the-usestate-set-method-is-not-reflecting-a-change-immediately-1657384524775"},{"title":"What is the difference between == and equals() in Java?","slug":"what-is-the-difference-between-and-equals()-in-java-1657387729654"},{"title":"What to do Regular expression pattern doesn't match anywhere in string?","slug":"what-to-do-regular-expression-pattern-doesn't-match-anywhere-in-string-1657388095896"},{"title":"Why does the order in which libraries are linked sometimes cause errors in GCC?","slug":"why-does-the-order-in-which-libraries-are-linked-sometimes-cause-errors-in-gcc-1657387609554"},{"title":"Change the maximum upload file size","slug":"change-the-maximum-upload-file-size-1657388495156"},{"title":"What is the purpose of the var keyword and when should I use it (or omit it)?","slug":"what-is-the-purpose-of-the-var-keyword-and-when-should-i-use-it-(or-omit-it)-1657387525538"},{"title":"What is the best way to detect a mobile device?","slug":"what-is-the-best-way-to-detect-a-mobile-device-1657387665025"},{"title":"How to access a local variable from a different function using pointers?","slug":"how-to-access-a-local-variable-from-a-different-function-using-pointers-1657388159760"},{"title":"Does Python have a ternary conditional operator?","slug":"does-python-have-a-ternary-conditional-operator-1657387555448"},{"title":"Efficiently convert rows to columns in sql server","slug":"efficiently-convert-rows-to-columns-in-sql-server-1657387919213"},{"title":"How do I merge two dictionaries in a single expression?","slug":"how-do-i-merge-two-dictionaries-in-a-single-expression-1657387593160"},{"title":"Variables are not behaving as expected","slug":"variables-are-not-behaving-as-expected-1657384865672"},{"title":"Are dictionaries ordered in Python 3.6+?","slug":"are-dictionaries-ordered-in-python-3.6+-1657387834234"},{"title":"Default constructor with empty brackets","slug":"default-constructor-with-empty-brackets-1657388246967"},{"title":"What is ViewModel in MVC?","slug":"what-is-viewmodel-in-mvc-1657387451244"},{"title":"Why use getters and setters/accessors?","slug":"why-use-getters-and-settersaccessors-1657387343971"},{"title":"How to parse JSON in Java","slug":"how-to-parse-json-in-java-1657384575136"},{"title":"var functionName = function() {} vs function functionName() {}","slug":"var-functionname-function()-vs-function-functionname()-1657384724077"}]},"__N_SSG":true},"page":"/questions/[slug]","query":{"slug":"unboundlocalerror-on-local-variable-when-reassigned-after-first-use-1657387685248"},"buildId":"6ctJfCympFH_chh5mjicD","isFallback":false,"gsp":true,"locale":"en","locales":["en"],"defaultLocale":"en","scriptLoader":[]}</script></body></html>