<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><meta name="twitter:card" content="summary_large_image"/><meta name="twitter:site" content="@solutionschecker.com"/><meta name="twitter:creator" content="@solutionschecker.com"/><meta property="og:url" content="https://solutionschecker.com"/><meta property="og:type" content="website"/><meta property="og:image" content="https://solutionschecker.com/solutions-checker-banner.png"/><meta property="og:image:alt" content="Find solution for coding, HTML, CSS, JAVASCRIPT, MYSQL, PHP, PYTHON,... quickly. - solutionschecker.com"/><script type="application/ld+json">{"@context":"https://schema.org","@type":"Organization","logo":"/logo.svg","url":"https://solutionschecker.com"}</script><title>How do I iterate over the words of a string? | Solutions Checker</title><meta name="robots" content="index,follow"/><meta name="description" content="How do I iterate over the words of a string composed of words separated by whitespace?
Note that I&#x27;m not interested in C string functions or that kind of character manipulation/access. I prefer elegance over efficiency. My current solution:
#include &lt;iostream&gt;
#include &lt;sstream&gt;
#include &lt;string&gt;

using namespace std;

int main() {
    string s = &quot;Somewhere down the road&quot;;
    istringstream iss(s);

    do {
        string subs;
        iss &gt;&gt; subs;
        cout &lt;&lt; &quot;Substring: &quot; &lt;&lt; subs &lt;&lt; endl;
    } while (iss);
}

    "/><meta property="og:title" content="How do I iterate over the words of a string? | Solutions Checker"/><meta property="og:description" content="How do I iterate over the words of a string composed of words separated by whitespace?
Note that I&#x27;m not interested in C string functions or that kind of character manipulation/access. I prefer elegance over efficiency. My current solution:
#include &lt;iostream&gt;
#include &lt;sstream&gt;
#include &lt;string&gt;

using namespace std;

int main() {
    string s = &quot;Somewhere down the road&quot;;
    istringstream iss(s);

    do {
        string subs;
        iss &gt;&gt; subs;
        cout &lt;&lt; &quot;Substring: &quot; &lt;&lt; subs &lt;&lt; endl;
    } while (iss);
}

    "/><script type="application/ld+json">{"@context":"https://schema.org","@type":"QAPage","mainEntity":{"name":"How do I iterate over the words of a string?","text":"How do I iterate over the words of a string composed of words separated by whitespace?\nNote that I&apos;m not interested in C string functions or that kind of character manipulation/access. I prefer elegance over efficiency. My current solution:\n#include &lt;iostream&gt;\n#include &lt;sstream&gt;\n#include &lt;string&gt;\n\nusing namespace std;\n\nint main() {\n    string s = &quot;Somewhere down the road&quot;;\n    istringstream iss(s);\n\n    do {\n        string subs;\n        iss &gt;&gt; subs;\n        cout &lt;&lt; &quot;Substring: &quot; &lt;&lt; subs &lt;&lt; endl;\n    } while (iss);\n}\n\n    ","answerCount":30,"upVoteCount":500,"suggestedAnswer":[{"text":"I use this to split string by a delimiter. The first puts the results in a pre-constructed vector, the second returns a new vector.\n\n\n\n#include &lt;string&gt;\n#include &lt;sstream&gt;\n#include &lt;vector&gt;\n#include &lt;iterator&gt;\n\ntemplate &lt;typename Out&gt;\nvoid split(const std::string &amp;s, char delim, Out result) {\n    std::istringstream iss(s);\n    std::string item;\n    while (std::getline(iss, item, delim)) {\n        *result++ = item;\n    }\n}\n\nstd::vector&lt;std::string&gt; split(const std::string &amp;s, char delim) {\n    std::vector&lt;std::string&gt; elems;\n    split(s, delim, std::back_inserter(elems));\n    return elems;\n}\n\n\n\n\nNote that this solution does not skip empty tokens, so the following will find 4 items, one of which is empty:\n\nstd::vector&lt;std::string&gt; x = split(&quot;one:two::three&quot;, &apos;:&apos;);\n\n    ","url":"/questions/[slug]#solution1","@type":"Answer","upvoteCount":0},{"text":"For what it&apos;s worth, here&apos;s another way to extract tokens from an input string, relying only on standard library facilities. It&apos;s an example of the power and elegance behind the design of the STL.\n\n#include &lt;iostream&gt;\n#include &lt;string&gt;\n#include &lt;sstream&gt;\n#include &lt;algorithm&gt;\n#include &lt;iterator&gt;\n\nint main() {\n    using namespace std;\n    string sentence = &quot;And I feel fine...&quot;;\n    istringstream iss(sentence);\n    copy(istream_iterator&lt;string&gt;(iss),\n         istream_iterator&lt;string&gt;(),\n         ostream_iterator&lt;string&gt;(cout, &quot;\\n&quot;));\n}\n\n\nInstead of copying the extracted tokens to an output stream, one could insert them into a container, using the same generic copy algorithm.\n\nvector&lt;string&gt; tokens;\ncopy(istream_iterator&lt;string&gt;(iss),\n     istream_iterator&lt;string&gt;(),\n     back_inserter(tokens));\n\n\n... or create the vector directly:\n\nvector&lt;string&gt; tokens{istream_iterator&lt;string&gt;{iss},\n                      istream_iterator&lt;string&gt;{}};\n\n    ","url":"/questions/[slug]#solution2","@type":"Answer","upvoteCount":0},{"text":"A possible solution using Boost might be:\n\n#include &lt;boost/algorithm/string.hpp&gt;\nstd::vector&lt;std::string&gt; strs;\nboost::split(strs, &quot;string to split&quot;, boost::is_any_of(&quot;\\t &quot;));\n\n\nThis approach might be even faster than the stringstream approach. And since this is a generic template function it can be used to split other types of strings (wchar, etc. or UTF-8) using all kinds of delimiters.\n\nSee the documentation for details.\n    ","url":"/questions/[slug]#solution3","@type":"Answer","upvoteCount":0},{"text":"#include &lt;vector&gt;\n#include &lt;string&gt;\n#include &lt;sstream&gt;\n\nint main()\n{\n    std::string str(&quot;Split me by whitespaces&quot;);\n    std::string buf;                 // Have a buffer string\n    std::stringstream ss(str);       // Insert the string into a stream\n\n    std::vector&lt;std::string&gt; tokens; // Create vector to hold our words\n\n    while (ss &gt;&gt; buf)\n        tokens.push_back(buf);\n\n    return 0;\n}\n\n    ","url":"/questions/[slug]#solution4","@type":"Answer","upvoteCount":0},{"text":"For those with whom it does not sit well to sacrifice all efficiency for code size and see &quot;efficient&quot; as a type of elegance, the following should hit a sweet spot (and I think the template container class is an awesomely elegant addition.):\n\ntemplate &lt; class ContainerT &gt;\nvoid tokenize(const std::string&amp; str, ContainerT&amp; tokens,\n              const std::string&amp; delimiters = &quot; &quot;, bool trimEmpty = false)\n{\n   std::string::size_type pos, lastPos = 0, length = str.length();\n\n   using value_type = typename ContainerT::value_type;\n   using size_type  = typename ContainerT::size_type;\n\n   while(lastPos &lt; length + 1)\n   {\n      pos = str.find_first_of(delimiters, lastPos);\n      if(pos == std::string::npos)\n      {\n         pos = length;\n      }\n\n      if(pos != lastPos || !trimEmpty)\n         tokens.push_back(value_type(str.data()+lastPos,\n               (size_type)pos-lastPos ));\n\n      lastPos = pos + 1;\n   }\n}\n\n\nI usually choose to use std::vector&lt;std::string&gt; types as my second parameter (ContainerT)... but list&lt;&gt; is way faster than vector&lt;&gt; for when direct access is not needed, and you can even create your own string class and use something like std::list&lt;subString&gt; where subString does not do any copies for incredible speed increases.\n\nIt&apos;s more than double as fast as the fastest tokenize on this page and almost 5 times faster than some others. Also with the perfect parameter types you can eliminate all string and list copies for additional speed increases.\n\nAdditionally it does not do the (extremely inefficient) return of result, but rather it passes the tokens as a reference, thus also allowing you to build up tokens using multiple calls if you so wished.\n\nLastly it allows you to specify whether to trim empty tokens from the results via a last optional parameter.\n\nAll it needs is std::string... the rest are optional. It does not use streams or the boost library, but is flexible enough to be able to accept some of these foreign types naturally.\n    ","url":"/questions/[slug]#solution5","@type":"Answer","upvoteCount":0},{"text":"Here&apos;s another solution. It&apos;s compact and reasonably efficient:\n\nstd::vector&lt;std::string&gt; split(const std::string &amp;text, char sep) {\n  std::vector&lt;std::string&gt; tokens;\n  std::size_t start = 0, end = 0;\n  while ((end = text.find(sep, start)) != std::string::npos) {\n    tokens.push_back(text.substr(start, end - start));\n    start = end + 1;\n  }\n  tokens.push_back(text.substr(start));\n  return tokens;\n}\n\n\nIt can easily be templatised to handle string separators, wide strings, etc.\n\nNote that splitting &quot;&quot; results in a single empty string and splitting &quot;,&quot; (ie. sep) results in two empty strings.\n\nIt can also be easily expanded to skip empty tokens:\n\nstd::vector&lt;std::string&gt; split(const std::string &amp;text, char sep) {\n    std::vector&lt;std::string&gt; tokens;\n    std::size_t start = 0, end = 0;\n    while ((end = text.find(sep, start)) != std::string::npos) {\n        if (end != start) {\n          tokens.push_back(text.substr(start, end - start));\n        }\n        start = end + 1;\n    }\n    if (end != start) {\n       tokens.push_back(text.substr(start));\n    }\n    return tokens;\n}\n\n\n\n\nIf splitting a string at multiple delimiters while skipping empty tokens is desired, this version may be used:\n\nstd::vector&lt;std::string&gt; split(const std::string&amp; text, const std::string&amp; delims)\n{\n    std::vector&lt;std::string&gt; tokens;\n    std::size_t start = text.find_first_not_of(delims), end = 0;\n\n    while((end = text.find_first_of(delims, start)) != std::string::npos)\n    {\n        tokens.push_back(text.substr(start, end - start));\n        start = text.find_first_not_of(delims, end);\n    }\n    if(start != std::string::npos)\n        tokens.push_back(text.substr(start));\n\n    return tokens;\n}\n\n    ","url":"/questions/[slug]#solution6","@type":"Answer","upvoteCount":0},{"text":"This is my favorite way to iterate through a string. You can do whatever you want per word.\n\nstring line = &quot;a line of text to iterate through&quot;;\nstring word;\n\nistringstream iss(line, istringstream::in);\n\nwhile( iss &gt;&gt; word )     \n{\n    // Do something on `word` here...\n}\n\n    ","url":"/questions/[slug]#solution7","@type":"Answer","upvoteCount":0},{"text":"This is similar to Stack Overflow question How do I tokenize a string in C++?. Requires Boost external library\n#include &lt;iostream&gt;\n#include &lt;string&gt;\n#include &lt;boost/tokenizer.hpp&gt;\n\nusing namespace std;\nusing namespace boost;\n\nint main(int argc, char** argv)\n{\n    string text = &quot;token  test\\tstring&quot;;\n\n    char_separator&lt;char&gt; sep(&quot; \\t&quot;);\n    tokenizer&lt;char_separator&lt;char&gt;&gt; tokens(text, sep);\n    for (const string&amp; t : tokens)\n    {\n        cout &lt;&lt; t &lt;&lt; &quot;.&quot; &lt;&lt; endl;\n    }\n}\n\n    ","url":"/questions/[slug]#solution8","@type":"Answer","upvoteCount":0},{"text":"I like the following because it puts the results into a vector, supports a string as a delim and gives control over keeping empty values. But, it doesn&apos;t look as good then.\n\n#include &lt;ostream&gt;\n#include &lt;string&gt;\n#include &lt;vector&gt;\n#include &lt;algorithm&gt;\n#include &lt;iterator&gt;\nusing namespace std;\n\nvector&lt;string&gt; split(const string&amp; s, const string&amp; delim, const bool keep_empty = true) {\n    vector&lt;string&gt; result;\n    if (delim.empty()) {\n        result.push_back(s);\n        return result;\n    }\n    string::const_iterator substart = s.begin(), subend;\n    while (true) {\n        subend = search(substart, s.end(), delim.begin(), delim.end());\n        string temp(substart, subend);\n        if (keep_empty || !temp.empty()) {\n            result.push_back(temp);\n        }\n        if (subend == s.end()) {\n            break;\n        }\n        substart = subend + delim.size();\n    }\n    return result;\n}\n\nint main() {\n    const vector&lt;string&gt; words = split(&quot;So close no matter how far&quot;, &quot; &quot;);\n    copy(words.begin(), words.end(), ostream_iterator&lt;string&gt;(cout, &quot;\\n&quot;));\n}\n\n\nOf course, Boost has a split() that works partially like that. And, if by &apos;white-space&apos;, you really do mean any type of white-space, using Boost&apos;s split with is_any_of() works great.\n    ","url":"/questions/[slug]#solution9","@type":"Answer","upvoteCount":0},{"text":"The STL does not have such a method available already.\n\nHowever, you can either use C&apos;s strtok() function by using the std::string::c_str() member, or you can write your own. Here is a code sample I found after a quick Google search (&quot;STL string split&quot;):\n\nvoid Tokenize(const string&amp; str,\n              vector&lt;string&gt;&amp; tokens,\n              const string&amp; delimiters = &quot; &quot;)\n{\n    // Skip delimiters at beginning.\n    string::size_type lastPos = str.find_first_not_of(delimiters, 0);\n    // Find first &quot;non-delimiter&quot;.\n    string::size_type pos     = str.find_first_of(delimiters, lastPos);\n\n    while (string::npos != pos || string::npos != lastPos)\n    {\n        // Found a token, add it to the vector.\n        tokens.push_back(str.substr(lastPos, pos - lastPos));\n        // Skip delimiters.  Note the &quot;not_of&quot;\n        lastPos = str.find_first_not_of(delimiters, pos);\n        // Find next &quot;non-delimiter&quot;\n        pos = str.find_first_of(delimiters, lastPos);\n    }\n}\n\n\nTaken from: http://oopweb.com/CPP/Documents/CPPHOWTO/Volume/C++Programming-HOWTO-7.html\n\nIf you have questions about the code sample, leave a comment and I will explain.\n\nAnd just because it does not implement a typedef called iterator or overload the &lt;&lt; operator does not mean it is bad code. I use C functions quite frequently. For example, printf and scanf both are faster than std::cin and std::cout (significantly), the fopen syntax is a lot more friendly for binary types, and they also tend to produce smaller EXEs.\n\nDon&apos;t get sold on this &quot;Elegance over performance&quot; deal.\n    ","url":"/questions/[slug]#solution10","@type":"Answer","upvoteCount":0},{"text":"Here is a split function that:\n\n\nis generic\nuses standard C++ (no boost)\naccepts multiple delimiters\nignores empty tokens (can easily be changed)\n\ntemplate&lt;typename T&gt;\nvector&lt;T&gt; \nsplit(const T &amp; str, const T &amp; delimiters) {\n    vector&lt;T&gt; v;\n    typename T::size_type start = 0;\n    auto pos = str.find_first_of(delimiters, start);\n    while(pos != T::npos) {\n        if(pos != start) // ignore empty tokens\n            v.emplace_back(str, start, pos - start);\n        start = pos + 1;\n        pos = str.find_first_of(delimiters, start);\n    }\n    if(start &lt; str.length()) // ignore trailing delimiter\n        v.emplace_back(str, start, str.length() - start); // add what&apos;s left of the string\n    return v;\n}\n\n\n\nExample usage:\n\n    vector&lt;string&gt; v = split&lt;string&gt;(&quot;Hello, there; World&quot;, &quot;;,&quot;);\n    vector&lt;wstring&gt; v = split&lt;wstring&gt;(L&quot;Hello, there; World&quot;, L&quot;;,&quot;);\n\n    ","url":"/questions/[slug]#solution11","@type":"Answer","upvoteCount":0},{"text":"I have a 2 lines solution to this problem:\n\nchar sep = &apos; &apos;;\nstd::string s=&quot;1 This is an example&quot;;\n\nfor(size_t p=0, q=0; p!=s.npos; p=q)\n  std::cout &lt;&lt; s.substr(p+(p!=0), (q=s.find(sep, p+1))-p-(p!=0)) &lt;&lt; std::endl;\n\n\nThen instead of printing you can put it in a vector.\n    ","url":"/questions/[slug]#solution12","@type":"Answer","upvoteCount":0},{"text":"Yet another flexible and fast way\n\ntemplate&lt;typename Operator&gt;\nvoid tokenize(Operator&amp; op, const char* input, const char* delimiters) {\n  const char* s = input;\n  const char* e = s;\n  while (*e != 0) {\n    e = s;\n    while (*e != 0 &amp;&amp; strchr(delimiters, *e) == 0) ++e;\n    if (e - s &gt; 0) {\n      op(s, e - s);\n    }\n    s = e + 1;\n  }\n}\n\n\nTo use it with a vector of strings (Edit: Since someone pointed out not to inherit STL classes... hrmf ;) ) :\n\ntemplate&lt;class ContainerType&gt;\nclass Appender {\npublic:\n  Appender(ContainerType&amp; container) : container_(container) {;}\n  void operator() (const char* s, unsigned length) { \n    container_.push_back(std::string(s,length));\n  }\nprivate:\n  ContainerType&amp; container_;\n};\n\nstd::vector&lt;std::string&gt; strVector;\nAppender v(strVector);\ntokenize(v, &quot;A number of words to be tokenized&quot;, &quot; \\t&quot;);\n\n\nThat&apos;s it! And that&apos;s just one way to use the tokenizer, like how to just \ncount words:\n\nclass WordCounter {\npublic:\n  WordCounter() : noOfWords(0) {}\n  void operator() (const char*, unsigned) {\n    ++noOfWords;\n  }\n  unsigned noOfWords;\n};\n\nWordCounter wc;\ntokenize(wc, &quot;A number of words to be counted&quot;, &quot; \\t&quot;); \nASSERT( wc.noOfWords == 7 );\n\n\nLimited by imagination ;)\n    ","url":"/questions/[slug]#solution13","@type":"Answer","upvoteCount":0},{"text":"Here&apos;s a simple solution that uses only the standard regex library\n\n#include &lt;regex&gt;\n#include &lt;string&gt;\n#include &lt;vector&gt;\n\nstd::vector&lt;string&gt; Tokenize( const string str, const std::regex regex )\n{\n    using namespace std;\n\n    std::vector&lt;string&gt; result;\n\n    sregex_token_iterator it( str.begin(), str.end(), regex, -1 );\n    sregex_token_iterator reg_end;\n\n    for ( ; it != reg_end; ++it ) {\n        if ( !it-&gt;str().empty() ) //token could be empty:check\n            result.emplace_back( it-&gt;str() );\n    }\n\n    return result;\n}\n\n\nThe regex argument allows checking for multiple arguments (spaces, commas, etc.)\n\nI usually only check to split on spaces and commas, so I also have this default function:\n\nstd::vector&lt;string&gt; TokenizeDefault( const string str )\n{\n    using namespace std;\n\n    regex re( &quot;[\\\\s,]+&quot; );\n\n    return Tokenize( str, re );\n}\n\n\nThe &quot;[\\\\s,]+&quot; checks for spaces (\\\\s) and commas (,).\n\nNote, if you want to split wstring instead of string,\n\n\nchange all std::regex to std::wregex\nchange all sregex_token_iterator to wsregex_token_iterator\n\n\nNote, you might also want to take the string argument by reference, depending on your compiler.\n    ","url":"/questions/[slug]#solution14","@type":"Answer","upvoteCount":0},{"text":"Using std::stringstream as you have works perfectly fine, and do exactly what you wanted. If you&apos;re just looking for different way of doing things though, you can use std::find()/std::find_first_of() and std::string::substr().\n\nHere&apos;s an example:\n\n#include &lt;iostream&gt;\n#include &lt;string&gt;\n\nint main()\n{\n    std::string s(&quot;Somewhere down the road&quot;);\n    std::string::size_type prev_pos = 0, pos = 0;\n\n    while( (pos = s.find(&apos; &apos;, pos)) != std::string::npos )\n    {\n        std::string substring( s.substr(prev_pos, pos-prev_pos) );\n\n        std::cout &lt;&lt; substring &lt;&lt; &apos;\\n&apos;;\n\n        prev_pos = ++pos;\n    }\n\n    std::string substring( s.substr(prev_pos, pos-prev_pos) ); // Last word\n    std::cout &lt;&lt; substring &lt;&lt; &apos;\\n&apos;;\n\n    return 0;\n}\n\n    ","url":"/questions/[slug]#solution15","@type":"Answer","upvoteCount":0},{"text":"If you like to use boost, but want to use a whole string as delimiter (instead of single characters as in most of the previously proposed solutions), you can use the boost_split_iterator.\n\nExample code including convenient template:\n\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;boost/algorithm/string.hpp&gt;\n\ntemplate&lt;typename _OutputIterator&gt;\ninline void split(\n    const std::string&amp; str, \n    const std::string&amp; delim, \n    _OutputIterator result)\n{\n    using namespace boost::algorithm;\n    typedef split_iterator&lt;std::string::const_iterator&gt; It;\n\n    for(It iter=make_split_iterator(str, first_finder(delim, is_equal()));\n            iter!=It();\n            ++iter)\n    {\n        *(result++) = boost::copy_range&lt;std::string&gt;(*iter);\n    }\n}\n\nint main(int argc, char* argv[])\n{\n    using namespace std;\n\n    vector&lt;string&gt; splitted;\n    split(&quot;HelloFOOworldFOO!&quot;, &quot;FOO&quot;, back_inserter(splitted));\n\n    // or directly to console, for example\n    split(&quot;HelloFOOworldFOO!&quot;, &quot;FOO&quot;, ostream_iterator&lt;string&gt;(cout, &quot;\\n&quot;));\n    return 0;\n}\n\n    ","url":"/questions/[slug]#solution16","@type":"Answer","upvoteCount":0},{"text":"Heres a regex solution that only uses the standard regex library.  (I&apos;m a little rusty, so there may be a few syntax errors, but this is at least the general idea)\n\n#include &lt;regex.h&gt;\n#include &lt;string.h&gt;\n#include &lt;vector.h&gt;\n\nusing namespace std;\n\nvector&lt;string&gt; split(string s){\n    regex r (&quot;\\\\w+&quot;); //regex matches whole words, (greedy, so no fragment words)\n    regex_iterator&lt;string::iterator&gt; rit ( s.begin(), s.end(), r );\n    regex_iterator&lt;string::iterator&gt; rend; //iterators to iterate thru words\n    vector&lt;string&gt; result&lt;regex_iterator&gt;(rit, rend);\n    return result;  //iterates through the matches to fill the vector\n}\n\n    ","url":"/questions/[slug]#solution17","@type":"Answer","upvoteCount":0},{"text":"There is a function named strtok.\n\n#include&lt;string&gt;\nusing namespace std;\n\nvector&lt;string&gt; split(char* str,const char* delim)\n{\n    char* saveptr;\n    char* token = strtok_r(str,delim,&amp;saveptr);\n\n    vector&lt;string&gt; result;\n\n    while(token != NULL)\n    {\n        result.push_back(token);\n        token = strtok_r(NULL,delim,&amp;saveptr);\n    }\n    return result;\n}\n\n    ","url":"/questions/[slug]#solution18","@type":"Answer","upvoteCount":0},{"text":"The stringstream can be convenient if you need to parse the string by non-space symbols:\n\nstring s = &quot;Name:JAck; Spouse:Susan; ...&quot;;\nstring dummy, name, spouse;\n\nistringstream iss(s);\ngetline(iss, dummy, &apos;:&apos;);\ngetline(iss, name, &apos;;&apos;);\ngetline(iss, dummy, &apos;:&apos;);\ngetline(iss, spouse, &apos;;&apos;)\n\n    ","url":"/questions/[slug]#solution19","@type":"Answer","upvoteCount":0},{"text":"Using std::string_view and Eric Niebler&apos;s range-v3 library:\n\nhttps://wandbox.org/permlink/kW5lwRCL1pxjp2pW\n\n#include &lt;iostream&gt;\n#include &lt;string&gt;\n#include &lt;string_view&gt;\n#include &quot;range/v3/view.hpp&quot;\n#include &quot;range/v3/algorithm.hpp&quot;\n\nint main() {\n    std::string s = &quot;Somewhere down the range v3 library&quot;;\n    ranges::for_each(s  \n        |   ranges::view::split(&apos; &apos;)\n        |   ranges::view::transform([](auto &amp;&amp;sub) {\n                return std::string_view(&amp;*sub.begin(), ranges::distance(sub));\n            }),\n        [](auto s) {std::cout &lt;&lt; &quot;Substring: &quot; &lt;&lt; s &lt;&lt; &quot;\\n&quot;;}\n    );\n}\n\n\nBy using a range for loop instead of ranges::for_each algorithm:\n\n#include &lt;iostream&gt;\n#include &lt;string&gt;\n#include &lt;string_view&gt;\n#include &quot;range/v3/view.hpp&quot;\n\nint main()\n{\n    std::string str = &quot;Somewhere down the range v3 library&quot;;\n    for (auto s : str | ranges::view::split(&apos; &apos;)\n                      | ranges::view::transform([](auto&amp;&amp; sub) { return std::string_view(&amp;*sub.begin(), ranges::distance(sub)); }\n                      ))\n    {\n        std::cout &lt;&lt; &quot;Substring: &quot; &lt;&lt; s &lt;&lt; &quot;\\n&quot;;\n    }\n}\n\n    ","url":"/questions/[slug]#solution20","@type":"Answer","upvoteCount":0},{"text":"C++20 finally blesses us with a split function. Or rather, a range adapter. Godbolt link.\n\n#include &lt;iostream&gt;\n#include &lt;ranges&gt;\n#include &lt;string_view&gt;\n\nnamespace ranges = std::ranges;\nnamespace views = std::views;\n\nusing str = std::string_view;\n\nconstexpr auto view =\n    &quot;Multiple words&quot;\n    | views::split(&apos; &apos;)\n    | views::transform([](auto &amp;&amp;r) -&gt; str {\n        return {\n            &amp;*r.begin(),\n            static_cast&lt;str::size_type&gt;(ranges::distance(r))\n        };\n    });\n\nauto main() -&gt; int {\n    for (str &amp;&amp;sv : view) {\n        std::cout &lt;&lt; sv &lt;&lt; &apos;\\n&apos;;\n    }\n}\n\n    ","url":"/questions/[slug]#solution21","@type":"Answer","upvoteCount":0},{"text":"So far I used the one in Boost, but I needed something that doesn&apos;t depends on it, so I came to this:\n\nstatic void Split(std::vector&lt;std::string&gt;&amp; lst, const std::string&amp; input, const std::string&amp; separators, bool remove_empty = true)\n{\n    std::ostringstream word;\n    for (size_t n = 0; n &lt; input.size(); ++n)\n    {\n        if (std::string::npos == separators.find(input[n]))\n            word &lt;&lt; input[n];\n        else\n        {\n            if (!word.str().empty() || !remove_empty)\n                lst.push_back(word.str());\n            word.str(&quot;&quot;);\n        }\n    }\n    if (!word.str().empty() || !remove_empty)\n        lst.push_back(word.str());\n}\n\n\nA good point is that in separators you can pass more than one character.\n    ","url":"/questions/[slug]#solution22","@type":"Answer","upvoteCount":0},{"text":"Short and elegant\n\n#include &lt;vector&gt;\n#include &lt;string&gt;\nusing namespace std;\n\nvector&lt;string&gt; split(string data, string token)\n{\n    vector&lt;string&gt; output;\n    size_t pos = string::npos; // size_t to avoid improbable overflow\n    do\n    {\n        pos = data.find(token);\n        output.push_back(data.substr(0, pos));\n        if (string::npos != pos)\n            data = data.substr(pos + token.size());\n    } while (string::npos != pos);\n    return output;\n}\n\n\ncan use any string as delimiter, also can be used with binary data (std::string supports binary data, including nulls)\n\nusing:\n\nauto a = split(&quot;this!!is!!!example!string&quot;, &quot;!!&quot;);\n\n\noutput:\n\nthis\nis\n!example!string\n\n    ","url":"/questions/[slug]#solution23","@type":"Answer","upvoteCount":0},{"text":"I&apos;ve rolled my own using strtok and used boost to split a string.  The best method I have found is the C++ String Toolkit Library.  It is incredibly flexible and fast.\n\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;string&gt;\n#include &lt;strtk.hpp&gt;\n\nconst char *whitespace  = &quot; \\t\\r\\n\\f&quot;;\nconst char *whitespace_and_punctuation  = &quot; \\t\\r\\n\\f;,=&quot;;\n\nint main()\n{\n    {   // normal parsing of a string into a vector of strings\n        std::string s(&quot;Somewhere down the road&quot;);\n        std::vector&lt;std::string&gt; result;\n        if( strtk::parse( s, whitespace, result ) )\n        {\n            for(size_t i = 0; i &lt; result.size(); ++i )\n                std::cout &lt;&lt; result[i] &lt;&lt; std::endl;\n        }\n    }\n\n    {  // parsing a string into a vector of floats with other separators\n        // besides spaces\n\n        std::string s(&quot;3.0, 3.14; 4.0&quot;);\n        std::vector&lt;float&gt; values;\n        if( strtk::parse( s, whitespace_and_punctuation, values ) )\n        {\n            for(size_t i = 0; i &lt; values.size(); ++i )\n                std::cout &lt;&lt; values[i] &lt;&lt; std::endl;\n        }\n    }\n\n    {  // parsing a string into specific variables\n\n        std::string s(&quot;angle = 45; radius = 9.9&quot;);\n        std::string w1, w2;\n        float v1, v2;\n        if( strtk::parse( s, whitespace_and_punctuation, w1, v1, w2, v2) )\n        {\n            std::cout &lt;&lt; &quot;word &quot; &lt;&lt; w1 &lt;&lt; &quot;, value &quot; &lt;&lt; v1 &lt;&lt; std::endl;\n            std::cout &lt;&lt; &quot;word &quot; &lt;&lt; w2 &lt;&lt; &quot;, value &quot; &lt;&lt; v2 &lt;&lt; std::endl;\n        }\n    }\n\n    return 0;\n}\n\n\nThe toolkit has much more flexibility than this simple example shows but its utility in parsing a string into useful elements is incredible.\n    ","url":"/questions/[slug]#solution24","@type":"Answer","upvoteCount":0},{"text":"I made this because I needed an easy way to split strings and c-based strings... Hopefully someone else can find it useful as well. Also it doesn&apos;t rely on tokens and you can use fields as delimiters, which is another key I needed.\n\nI&apos;m sure there&apos;s improvements that can be made to even further improve its elegance and please do by all means\n\nStringSplitter.hpp:\n\n#include &lt;vector&gt;\n#include &lt;iostream&gt;\n#include &lt;string.h&gt;\n\nusing namespace std;\n\nclass StringSplit\n{\nprivate:\n    void copy_fragment(char*, char*, char*);\n    void copy_fragment(char*, char*, char);\n    bool match_fragment(char*, char*, int);\n    int untilnextdelim(char*, char);\n    int untilnextdelim(char*, char*);\n    void assimilate(char*, char);\n    void assimilate(char*, char*);\n    bool string_contains(char*, char*);\n    long calc_string_size(char*);\n    void copy_string(char*, char*);\n\npublic:\n    vector&lt;char*&gt; split_cstr(char);\n    vector&lt;char*&gt; split_cstr(char*);\n    vector&lt;string&gt; split_string(char);\n    vector&lt;string&gt; split_string(char*);\n    char* String;\n    bool do_string;\n    bool keep_empty;\n    vector&lt;char*&gt; Container;\n    vector&lt;string&gt; ContainerS;\n\n    StringSplit(char * in)\n    {\n        String = in;\n    }\n\n    StringSplit(string in)\n    {\n        size_t len = calc_string_size((char*)in.c_str());\n        String = new char[len + 1];\n        memset(String, 0, len + 1);\n        copy_string(String, (char*)in.c_str());\n        do_string = true;\n    }\n\n    ~StringSplit()\n    {\n        for (int i = 0; i &lt; Container.size(); i++)\n        {\n            if (Container[i] != NULL)\n            {\n                delete[] Container[i];\n            }\n        }\n        if (do_string)\n        {\n            delete[] String;\n        }\n    }\n};\n\n\nStringSplitter.cpp:\n\n#include &lt;string.h&gt;\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &quot;StringSplit.hpp&quot;\n\nusing namespace std;\n\nvoid StringSplit::assimilate(char*src, char delim)\n{\n    int until = untilnextdelim(src, delim);\n    if (until &gt; 0)\n    {\n        char * temp = new char[until + 1];\n        memset(temp, 0, until + 1);\n        copy_fragment(temp, src, delim);\n        if (keep_empty || *temp != 0)\n        {\n            if (!do_string)\n            {\n                Container.push_back(temp);\n            }\n            else\n            {\n                string x = temp;\n                ContainerS.push_back(x);\n            }\n\n        }\n        else\n        {\n            delete[] temp;\n        }\n    }\n}\n\nvoid StringSplit::assimilate(char*src, char* delim)\n{\n    int until = untilnextdelim(src, delim);\n    if (until &gt; 0)\n    {\n        char * temp = new char[until + 1];\n        memset(temp, 0, until + 1);\n        copy_fragment(temp, src, delim);\n        if (keep_empty || *temp != 0)\n        {\n            if (!do_string)\n            {\n                Container.push_back(temp);\n            }\n            else\n            {\n                string x = temp;\n                ContainerS.push_back(x);\n            }\n        }\n        else\n        {\n            delete[] temp;\n        }\n    }\n}\n\nlong StringSplit::calc_string_size(char* _in)\n{\n    long i = 0;\n    while (*_in++)\n    {\n        i++;\n    }\n    return i;\n}\n\nbool StringSplit::string_contains(char* haystack, char* needle)\n{\n    size_t len = calc_string_size(needle);\n    size_t lenh = calc_string_size(haystack);\n    while (lenh--)\n    {\n        if (match_fragment(haystack + lenh, needle, len))\n        {\n            return true;\n        }\n    }\n    return false;\n}\n\nbool StringSplit::match_fragment(char* _src, char* cmp, int len)\n{\n    while (len--)\n    {\n        if (*(_src + len) != *(cmp + len))\n        {\n            return false;\n        }\n    }\n    return true;\n}\n\nint StringSplit::untilnextdelim(char* _in, char delim)\n{\n    size_t len = calc_string_size(_in);\n    if (*_in == delim)\n    {\n        _in += 1;\n        return len - 1;\n    }\n\n    int c = 0;\n    while (*(_in + c) != delim &amp;&amp; c &lt; len)\n    {\n        c++;\n    }\n\n    return c;\n}\n\nint StringSplit::untilnextdelim(char* _in, char* delim)\n{\n    int s = calc_string_size(delim);\n    int c = 1 + s;\n\n    if (!string_contains(_in, delim))\n    {\n        return calc_string_size(_in);\n    }\n    else if (match_fragment(_in, delim, s))\n    {\n        _in += s;\n        return calc_string_size(_in);\n    }\n\n    while (!match_fragment(_in + c, delim, s))\n    {\n        c++;\n    }\n\n    return c;\n}\n\nvoid StringSplit::copy_fragment(char* dest, char* src, char delim)\n{\n    if (*src == delim)\n    {\n        src++;\n    }\n\n    int c = 0;\n    while (*(src + c) != delim &amp;&amp; *(src + c))\n    {\n        *(dest + c) = *(src + c);\n        c++;\n    }\n    *(dest + c) = 0;\n}\n\nvoid StringSplit::copy_string(char* dest, char* src)\n{\n    int i = 0;\n    while (*(src + i))\n    {\n        *(dest + i) = *(src + i);\n        i++;\n    }\n}\n\nvoid StringSplit::copy_fragment(char* dest, char* src, char* delim)\n{\n    size_t len = calc_string_size(delim);\n    size_t lens = calc_string_size(src);\n\n    if (match_fragment(src, delim, len))\n    {\n        src += len;\n        lens -= len;\n    }\n\n    int c = 0;\n    while (!match_fragment(src + c, delim, len) &amp;&amp; (c &lt; lens))\n    {\n        *(dest + c) = *(src + c);\n        c++;\n    }\n    *(dest + c) = 0;\n}\n\nvector&lt;char*&gt; StringSplit::split_cstr(char Delimiter)\n{\n    int i = 0;\n    while (*String)\n    {\n        if (*String != Delimiter &amp;&amp; i == 0)\n        {\n            assimilate(String, Delimiter);\n        }\n        if (*String == Delimiter)\n        {\n            assimilate(String, Delimiter);\n        }\n        i++;\n        String++;\n    }\n\n    String -= i;\n    delete[] String;\n\n    return Container;\n}\n\nvector&lt;string&gt; StringSplit::split_string(char Delimiter)\n{\n    do_string = true;\n\n    int i = 0;\n    while (*String)\n    {\n        if (*String != Delimiter &amp;&amp; i == 0)\n        {\n            assimilate(String, Delimiter);\n        }\n        if (*String == Delimiter)\n        {\n            assimilate(String, Delimiter);\n        }\n        i++;\n        String++;\n    }\n\n    String -= i;\n    delete[] String;\n\n    return ContainerS;\n}\n\nvector&lt;char*&gt; StringSplit::split_cstr(char* Delimiter)\n{\n    int i = 0;\n    size_t LenDelim = calc_string_size(Delimiter);\n\n    while(*String)\n    {\n        if (!match_fragment(String, Delimiter, LenDelim) &amp;&amp; i == 0)\n        {\n            assimilate(String, Delimiter);\n        }\n        if (match_fragment(String, Delimiter, LenDelim))\n        {\n            assimilate(String,Delimiter);\n        }\n        i++;\n        String++;\n    }\n\n    String -= i;\n    delete[] String;\n\n    return Container;\n}\n\nvector&lt;string&gt; StringSplit::split_string(char* Delimiter)\n{\n    do_string = true;\n    int i = 0;\n    size_t LenDelim = calc_string_size(Delimiter);\n\n    while (*String)\n    {\n        if (!match_fragment(String, Delimiter, LenDelim) &amp;&amp; i == 0)\n        {\n            assimilate(String, Delimiter);\n        }\n        if (match_fragment(String, Delimiter, LenDelim))\n        {\n            assimilate(String, Delimiter);\n        }\n        i++;\n        String++;\n    }\n\n    String -= i;\n    delete[] String;\n\n    return ContainerS;\n}\n\n\nExamples:\n\nint main(int argc, char*argv[])\n{\n    StringSplit ss = &quot;This:CUT:is:CUT:an:CUT:example:CUT:cstring&quot;;\n    vector&lt;char*&gt; Split = ss.split_cstr(&quot;:CUT:&quot;);\n\n    for (int i = 0; i &lt; Split.size(); i++)\n    {\n        cout &lt;&lt; Split[i] &lt;&lt; endl;\n    }\n\n    return 0;\n}\n\n\nWill output:\n\nThis\nis\nan\nexample\ncstring\n\nint main(int argc, char*argv[])\n{\n    StringSplit ss = &quot;This:is:an:example:cstring&quot;;\n    vector&lt;char*&gt; Split = ss.split_cstr(&apos;:&apos;);\n\n    for (int i = 0; i &lt; Split.size(); i++)\n    {\n        cout &lt;&lt; Split[i] &lt;&lt; endl;\n    }\n\n    return 0;\n}\n\nint main(int argc, char*argv[])\n{\n    string mystring = &quot;This[SPLIT]is[SPLIT]an[SPLIT]example[SPLIT]string&quot;;\n    StringSplit ss = mystring;\n    vector&lt;string&gt; Split = ss.split_string(&quot;[SPLIT]&quot;);\n\n    for (int i = 0; i &lt; Split.size(); i++)\n    {\n        cout &lt;&lt; Split[i] &lt;&lt; endl;\n    }\n\n    return 0;\n}\n\nint main(int argc, char*argv[])\n{\n    string mystring = &quot;This|is|an|example|string&quot;;\n    StringSplit ss = mystring;\n    vector&lt;string&gt; Split = ss.split_string(&apos;|&apos;);\n\n    for (int i = 0; i &lt; Split.size(); i++)\n    {\n        cout &lt;&lt; Split[i] &lt;&lt; endl;\n    }\n\n    return 0;\n}\n\n\nTo keep empty entries (by default empties will be excluded):\n\nStringSplit ss = mystring;\nss.keep_empty = true;\nvector&lt;string&gt; Split = ss.split_string(&quot;:DELIM:&quot;);\n\n\nThe goal was to make it similar to C#&apos;s Split() method where splitting a string is as easy as:\n\nString[] Split = \n    &quot;Hey:cut:what&apos;s:cut:your:cut:name?&quot;.Split(new[]{&quot;:cut:&quot;}, StringSplitOptions.None);\n\nforeach(String X in Split)\n{\n    Console.Write(X);\n}\n\n\nI hope someone else can find this as useful as I do.\n    ","url":"/questions/[slug]#solution25","@type":"Answer","upvoteCount":0},{"text":"This answer takes the string and puts it into a vector of strings. It uses the boost library.\n\n#include &lt;boost/algorithm/string.hpp&gt;\nstd::vector&lt;std::string&gt; strs;\nboost::split(strs, &quot;string to split&quot;, boost::is_any_of(&quot;\\t &quot;));\n\n    ","url":"/questions/[slug]#solution26","@type":"Answer","upvoteCount":0},{"text":"What about this:\n\n#include &lt;string&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\nvector&lt;string&gt; split(string str, const char delim) {\n    vector&lt;string&gt; v;\n    string tmp;\n\n    for(string::const_iterator i; i = str.begin(); i &lt;= str.end(); ++i) {\n        if(*i != delim &amp;&amp; i != str.end()) {\n            tmp += *i; \n        } else {\n            v.push_back(tmp);\n            tmp = &quot;&quot;; \n        }   \n    }   \n\n    return v;\n}\n\n    ","url":"/questions/[slug]#solution27","@type":"Answer","upvoteCount":0},{"text":"Here&apos;s another way of doing it..\n\nvoid split_string(string text,vector&lt;string&gt;&amp; words)\n{\n  int i=0;\n  char ch;\n  string word;\n\n  while(ch=text[i++])\n  {\n    if (isspace(ch))\n    {\n      if (!word.empty())\n      {\n        words.push_back(word);\n      }\n      word = &quot;&quot;;\n    }\n    else\n    {\n      word += ch;\n    }\n  }\n  if (!word.empty())\n  {\n    words.push_back(word);\n  }\n}\n\n    ","url":"/questions/[slug]#solution28","@type":"Answer","upvoteCount":0},{"text":"I like to use the boost/regex methods for this task since they provide maximum flexibility for specifying the splitting criteria.\n\n#include &lt;iostream&gt;\n#include &lt;string&gt;\n#include &lt;boost/regex.hpp&gt;\n\nint main() {\n    std::string line(&quot;A:::line::to:split&quot;);\n    const boost::regex re(&quot;:+&quot;); // one or more colons\n\n    // -1 means find inverse matches aka split\n    boost::sregex_token_iterator tokens(line.begin(),line.end(),re,-1);\n    boost::sregex_token_iterator end;\n\n    for (; tokens != end; ++tokens)\n        std::cout &lt;&lt; *tokens &lt;&lt; std::endl;\n}\n\n    ","url":"/questions/[slug]#solution29","@type":"Answer","upvoteCount":0},{"text":"Recently I had to split a camel-cased word into subwords.  There are no delimiters, just upper characters. \n\n#include &lt;string&gt;\n#include &lt;list&gt;\n#include &lt;locale&gt; // std::isupper\n\ntemplate&lt;class String&gt;\nconst std::list&lt;String&gt; split_camel_case_string(const String &amp;s)\n{\n    std::list&lt;String&gt; R;\n    String w;\n\n    for (String::const_iterator i = s.begin(); i &lt; s.end(); ++i) {  {\n        if (std::isupper(*i)) {\n            if (w.length()) {\n                R.push_back(w);\n                w.clear();\n            }\n        }\n        w += *i;\n    }\n\n    if (w.length())\n        R.push_back(w);\n    return R;\n}\n\n\nFor example, this splits &quot;AQueryTrades&quot; into &quot;A&quot;, &quot;Query&quot; and &quot;Trades&quot;.  The function works with narrow and wide strings. Because it respects the current locale it splits &quot;RaumfahrtÜberwachungsVerordnung&quot; into &quot;Raumfahrt&quot;, &quot;Überwachungs&quot; and &quot;Verordnung&quot;.\n\nNote std::upper should be really passed as function template argument. Then the more generalized from of this function can split at delimiters like &quot;,&quot;, &quot;;&quot; or &quot; &quot; too.\n    ","url":"/questions/[slug]#solution30","@type":"Answer","upvoteCount":0}],"@type":"Question"}}</script><meta name="next-head-count" content="16"/><link rel="preload" href="/_next/static/css/08bcc42a26fe5c92.css" as="style"/><link rel="stylesheet" href="/_next/static/css/08bcc42a26fe5c92.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-0d1b80a048d4787e.js"></script><script src="/_next/static/chunks/webpack-42cdea76c8170223.js" defer=""></script><script src="/_next/static/chunks/framework-4556c45dd113b893.js" defer=""></script><script src="/_next/static/chunks/main-ccfab947c79712f4.js" defer=""></script><script src="/_next/static/chunks/pages/_app-08d1a634dea6705e.js" defer=""></script><script src="/_next/static/chunks/29107295-fbcfe2172188e46f.js" defer=""></script><script src="/_next/static/chunks/150-b06815e21c943e0d.js" defer=""></script><script src="/_next/static/chunks/490-7f0418bb4354ac73.js" defer=""></script><script src="/_next/static/chunks/108-87de33c23337ff53.js" defer=""></script><script src="/_next/static/chunks/pages/questions/%5Bslug%5D-79a1437acf654019.js" defer=""></script><script src="/_next/static/6ctJfCympFH_chh5mjicD/_buildManifest.js" defer=""></script><script src="/_next/static/6ctJfCympFH_chh5mjicD/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="wrapper"><header><nav class="bg-white border-gray-200 px-4 lg:px-6 py-2.5 dark:bg-gray-800"><div class="flex flex-wrap justify-between items-center mx-auto max-w-screen-xl"><a class="flex items-center" href="/"><img src="/logo-second.png" class="mr-3 h-6 sm:h-9" alt="Solution Checker Logo"/><h4 class="self-center text-xl font-semibold whitespace-nowrap dark:text-white">Solution Checker</h4></a><div class="flex items-center lg:order-2"><button data-collapse-toggle="mobile-menu-2" type="button" class="inline-flex items-center p-2 ml-1 text-sm text-gray-500 rounded-lg lg:hidden hover:bg-gray-100 focus:outline-none focus:ring-2 focus:ring-gray-200 dark:text-gray-400 dark:hover:bg-gray-700 dark:focus:ring-gray-600" aria-controls="mobile-menu-2" aria-expanded="false"><span class="sr-only">Open main menu</span><svg class="w-6 h-6" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M3 5a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM3 10a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM3 15a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1z" clip-rule="evenodd"></path></svg><svg class="hidden w-6 h-6" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z" clip-rule="evenodd"></path></svg></button></div><div class="hidden justify-between items-center w-full lg:flex lg:w-auto lg:order-1" id="mobile-menu-2"><ul class="flex flex-col mt-4 font-medium lg:flex-row lg:space-x-8 lg:mt-0"><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" aria-current="page" href="/">Home</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/questions?tab=news">Questions</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/post?tab=news">Post</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/questions/how-do-i-iterate-over-the-words-of-a-string-1657384806129#">Coding</a></li></ul></div></div></nav></header><div class="main-content"><div class="question my-5"><div class="flex question-header items-center m-auto justify-center"><div class="rounded-xl w-full border p-5 shadow-md bg-white"><div class="flex w-full items-center justify-between border-b pb-3"><div class="flex items-center space-x-3"><div class="text-lg font-bold text-slate-700"><a href="/questions/how-do-i-iterate-over-the-words-of-a-string-1657384806129"><h1>How do I iterate over the words of a string?</h1></a></div></div><div class="flex flex-wrap h-auto justify-end items-center space-x-8"></div></div><div class="question-content mt-5">
                
<p>How do I iterate over the words of a string composed of words separated by whitespace?</p>
<p>Note that I'm not interested in C string functions or that kind of character manipulation/access. I prefer elegance over efficiency. My current solution:</p>
<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sstream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span>

<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    string s = <span class="hljs-string">"Somewhere down the road"</span>;
    <span class="hljs-function">istringstream <span class="hljs-title">iss</span><span class="hljs-params">(s)</span></span>;

    <span class="hljs-keyword">do</span> {
        string subs;
        iss &gt;&gt; subs;
        cout &lt;&lt; <span class="hljs-string">"Substring: "</span> &lt;&lt; subs &lt;&lt; endl;
    } <span class="hljs-keyword">while</span> (iss);
}
</code></pre>
    </div></div></div><div class="solution-section"><nav class="flex pagination-solution flex-col justify-end"><ul class="inline-flex -space-x-px overflow-auto"><li class="pagination-solution-item"><span data-id="#solution1" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">1</span></li><li class="pagination-solution-item"><span data-id="#solution2" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">2</span></li><li class="pagination-solution-item"><span data-id="#solution3" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">3</span></li><li class="pagination-solution-item"><span data-id="#solution4" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">4</span></li><li class="pagination-solution-item"><span data-id="#solution5" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">5</span></li><li class="pagination-solution-item"><span data-id="#solution6" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">6</span></li><li class="pagination-solution-item"><span data-id="#solution7" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">7</span></li><li class="pagination-solution-item"><span data-id="#solution8" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">8</span></li><li class="pagination-solution-item"><span data-id="#solution9" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">9</span></li><li class="pagination-solution-item"><span data-id="#solution10" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">10</span></li><li class="pagination-solution-item"><span data-id="#solution11" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">11</span></li><li class="pagination-solution-item"><span data-id="#solution12" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">12</span></li><li class="pagination-solution-item"><span data-id="#solution13" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">13</span></li><li class="pagination-solution-item"><span data-id="#solution14" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">14</span></li><li class="pagination-solution-item"><span data-id="#solution15" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">15</span></li><li class="pagination-solution-item"><span data-id="#solution16" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">16</span></li><li class="pagination-solution-item"><span data-id="#solution17" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">17</span></li><li class="pagination-solution-item"><span data-id="#solution18" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">18</span></li><li class="pagination-solution-item"><span data-id="#solution19" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">19</span></li><li class="pagination-solution-item"><span data-id="#solution20" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">20</span></li><li class="pagination-solution-item"><span data-id="#solution21" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">21</span></li><li class="pagination-solution-item"><span data-id="#solution22" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">22</span></li><li class="pagination-solution-item"><span data-id="#solution23" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">23</span></li><li class="pagination-solution-item"><span data-id="#solution24" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">24</span></li><li class="pagination-solution-item"><span data-id="#solution25" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">25</span></li><li class="pagination-solution-item"><span data-id="#solution26" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">26</span></li><li class="pagination-solution-item"><span data-id="#solution27" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">27</span></li><li class="pagination-solution-item"><span data-id="#solution28" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">28</span></li><li class="pagination-solution-item"><span data-id="#solution29" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">29</span></li><li class="pagination-solution-item"><span data-id="#solution30" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">30</span></li></ul></nav><div id="solution1" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 1</h4><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>I use this to split string by a delimiter. The first puts the results in a pre-constructed vector, the second returns a new vector.</p>



<pre class="lang-c++ s-code-block"><code class="hljs language-c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sstream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iterator&gt;</span></span>

template &lt;typename Out&gt;
<span class="hljs-type">void</span> <span class="hljs-title function_">split</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> &amp;s, <span class="hljs-type">char</span> delim, Out result)</span> {
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">istringstream</span> <span class="hljs-title function_">iss</span><span class="hljs-params">(s)</span>;
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> item;
    <span class="hljs-keyword">while</span> (<span class="hljs-built_in">std</span>::getline(iss, item, delim)) {
        *result++ = item;
    }
}

<span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&gt; <span class="hljs-title function_">split</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> &amp;s, <span class="hljs-type">char</span> delim)</span> {
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&gt; elems;
    split(s, delim, <span class="hljs-built_in">std</span>::back_inserter(elems));
    <span class="hljs-keyword">return</span> elems;
}
</code></pre>

<hr>

<p>Note that this solution does not skip empty tokens, so the following will find 4 items, one of which is empty:</p>

<pre class="lang-c++ s-code-block"><code class="hljs language-c"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&gt; x = split(<span class="hljs-string">"one:two::three"</span>, <span class="hljs-string">':'</span>);
</code></pre>
    </div></div></div></div><div id="solution2" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 2</h4><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>For what it's worth, here's another way to extract tokens from an input string, relying only on standard library facilities. It's an example of the power and elegance behind the design of the STL.</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sstream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iterator&gt;</span></span>

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;
    string sentence = <span class="hljs-string">"And I feel fine..."</span>;
    <span class="hljs-function">istringstream <span class="hljs-title">iss</span><span class="hljs-params">(sentence)</span></span>;
    <span class="hljs-built_in">copy</span>(<span class="hljs-built_in">istream_iterator</span>&lt;string&gt;(iss),
         <span class="hljs-built_in">istream_iterator</span>&lt;string&gt;(),
         <span class="hljs-built_in">ostream_iterator</span>&lt;string&gt;(cout, <span class="hljs-string">"\n"</span>));
}
</code></pre>

<p>Instead of copying the extracted tokens to an output stream, one could insert them into a container, using the same generic <a href="https://en.cppreference.com/w/cpp/algorithm/copy" rel="noreferrer"><code>copy</code></a> algorithm.</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp">vector&lt;string&gt; tokens;
<span class="hljs-built_in">copy</span>(<span class="hljs-built_in">istream_iterator</span>&lt;string&gt;(iss),
     <span class="hljs-built_in">istream_iterator</span>&lt;string&gt;(),
     <span class="hljs-built_in">back_inserter</span>(tokens));
</code></pre>

<p>... or create the <code>vector</code> directly:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp">vector&lt;string&gt; tokens{istream_iterator&lt;string&gt;{iss},
                      istream_iterator&lt;string&gt;{}};
</code></pre>
    </div></div></div></div><div id="solution3" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 3</h4><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>A possible solution using Boost might be:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;boost/algorithm/string.hpp&gt;</span></span>
std::vector&lt;std::string&gt; strs;
boost::<span class="hljs-built_in">split</span>(strs, <span class="hljs-string">"string to split"</span>, boost::<span class="hljs-built_in">is_any_of</span>(<span class="hljs-string">"\t "</span>));
</code></pre>

<p>This approach might be even faster than the <code>stringstream</code> approach. And since this is a generic template function it can be used to split other types of strings (wchar, etc. or UTF-8) using all kinds of delimiters.</p>

<p>See the <a href="http://www.boost.org/doc/libs/1_36_0/doc/html/string_algo/usage.html" rel="noreferrer">documentation</a> for details.</p>
    </div></div></div></div><div id="solution4" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 4</h4><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sstream&gt;</span></span>

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-function">std::string <span class="hljs-title">str</span><span class="hljs-params">(<span class="hljs-string">"Split me by whitespaces"</span>)</span></span>;
    std::string buf;                 <span class="hljs-comment">// Have a buffer string</span>
    <span class="hljs-function">std::stringstream <span class="hljs-title">ss</span><span class="hljs-params">(str)</span></span>;       <span class="hljs-comment">// Insert the string into a stream</span>

    std::vector&lt;std::string&gt; tokens; <span class="hljs-comment">// Create vector to hold our words</span>

    <span class="hljs-keyword">while</span> (ss &gt;&gt; buf)
        tokens.<span class="hljs-built_in">push_back</span>(buf);

    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>
    </div></div></div></div><div id="solution5" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 5</h4><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>For those with whom it does not sit well to sacrifice all efficiency for code size and see "efficient" as a type of elegance, the following should hit a sweet spot (and I think the template container class is an awesomely elegant addition.):</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-keyword">template</span> &lt; <span class="hljs-keyword">class</span> <span class="hljs-title class_">ContainerT</span> &gt;
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">tokenize</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; str, ContainerT&amp; tokens,
              <span class="hljs-type">const</span> std::string&amp; delimiters = <span class="hljs-string">" "</span>, <span class="hljs-type">bool</span> trimEmpty = <span class="hljs-literal">false</span>)</span>
</span>{
   std::string::size_type pos, lastPos = <span class="hljs-number">0</span>, length = str.<span class="hljs-built_in">length</span>();

   <span class="hljs-keyword">using</span> value_type = <span class="hljs-keyword">typename</span> ContainerT::value_type;
   <span class="hljs-keyword">using</span> size_type  = <span class="hljs-keyword">typename</span> ContainerT::size_type;

   <span class="hljs-keyword">while</span>(lastPos &lt; length + <span class="hljs-number">1</span>)
   {
      pos = str.<span class="hljs-built_in">find_first_of</span>(delimiters, lastPos);
      <span class="hljs-keyword">if</span>(pos == std::string::npos)
      {
         pos = length;
      }

      <span class="hljs-keyword">if</span>(pos != lastPos || !trimEmpty)
         tokens.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">value_type</span>(str.<span class="hljs-built_in">data</span>()+lastPos,
               (size_type)pos-lastPos ));

      lastPos = pos + <span class="hljs-number">1</span>;
   }
}
</code></pre>

<p>I usually choose to use <code>std::vector&lt;std::string&gt;</code> types as my second parameter (<code>ContainerT</code>)... but <code>list&lt;&gt;</code> is way faster than <code>vector&lt;&gt;</code> for when direct access is not needed, and you can even create your own string class and use something like <code>std::list&lt;subString&gt;</code> where <code>subString</code> does not do any copies for incredible speed increases.</p>

<p>It's more than double as fast as the fastest tokenize on this page and almost 5 times faster than some others. Also with the perfect parameter types you can eliminate all string and list copies for additional speed increases.</p>

<p>Additionally it does not do the (extremely inefficient) return of result, but rather it passes the tokens as a reference, thus also allowing you to build up tokens using multiple calls if you so wished.</p>

<p>Lastly it allows you to specify whether to trim empty tokens from the results via a last optional parameter.</p>

<p>All it needs is <code>std::string</code>... the rest are optional. It does not use streams or the boost library, but is flexible enough to be able to accept some of these foreign types naturally.</p>
    </div></div></div></div><div id="solution6" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 6</h4><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Here's another solution. It's compact and reasonably efficient:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-function">std::vector&lt;std::string&gt; <span class="hljs-title">split</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string &amp;text, <span class="hljs-type">char</span> sep)</span> </span>{
  std::vector&lt;std::string&gt; tokens;
  std::<span class="hljs-type">size_t</span> start = <span class="hljs-number">0</span>, end = <span class="hljs-number">0</span>;
  <span class="hljs-keyword">while</span> ((end = text.<span class="hljs-built_in">find</span>(sep, start)) != std::string::npos) {
    tokens.<span class="hljs-built_in">push_back</span>(text.<span class="hljs-built_in">substr</span>(start, end - start));
    start = end + <span class="hljs-number">1</span>;
  }
  tokens.<span class="hljs-built_in">push_back</span>(text.<span class="hljs-built_in">substr</span>(start));
  <span class="hljs-keyword">return</span> tokens;
}
</code></pre>

<p>It can easily be templatised to handle string separators, wide strings, etc.</p>

<p>Note that splitting <code>""</code> results in a single empty string and splitting <code>","</code> (ie. sep) results in two empty strings.</p>

<p>It can also be easily expanded to skip empty tokens:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-function">std::vector&lt;std::string&gt; <span class="hljs-title">split</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string &amp;text, <span class="hljs-type">char</span> sep)</span> </span>{
    std::vector&lt;std::string&gt; tokens;
    std::<span class="hljs-type">size_t</span> start = <span class="hljs-number">0</span>, end = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">while</span> ((end = text.<span class="hljs-built_in">find</span>(sep, start)) != std::string::npos) {
        <span class="hljs-keyword">if</span> (end != start) {
          tokens.<span class="hljs-built_in">push_back</span>(text.<span class="hljs-built_in">substr</span>(start, end - start));
        }
        start = end + <span class="hljs-number">1</span>;
    }
    <span class="hljs-keyword">if</span> (end != start) {
       tokens.<span class="hljs-built_in">push_back</span>(text.<span class="hljs-built_in">substr</span>(start));
    }
    <span class="hljs-keyword">return</span> tokens;
}
</code></pre>

<hr>

<p>If splitting a string at multiple delimiters while skipping empty tokens is desired, this version may be used:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-function">std::vector&lt;std::string&gt; <span class="hljs-title">split</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; text, <span class="hljs-type">const</span> std::string&amp; delims)</span>
</span>{
    std::vector&lt;std::string&gt; tokens;
    std::<span class="hljs-type">size_t</span> start = text.<span class="hljs-built_in">find_first_not_of</span>(delims), end = <span class="hljs-number">0</span>;

    <span class="hljs-keyword">while</span>((end = text.<span class="hljs-built_in">find_first_of</span>(delims, start)) != std::string::npos)
    {
        tokens.<span class="hljs-built_in">push_back</span>(text.<span class="hljs-built_in">substr</span>(start, end - start));
        start = text.<span class="hljs-built_in">find_first_not_of</span>(delims, end);
    }
    <span class="hljs-keyword">if</span>(start != std::string::npos)
        tokens.<span class="hljs-built_in">push_back</span>(text.<span class="hljs-built_in">substr</span>(start));

    <span class="hljs-keyword">return</span> tokens;
}
</code></pre>
    </div></div></div></div><div id="solution7" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 7</h4><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>This is my favorite way to iterate through a string. You can do whatever you want per word.</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp">string line = <span class="hljs-string">"a line of text to iterate through"</span>;
string word;

<span class="hljs-function">istringstream <span class="hljs-title">iss</span><span class="hljs-params">(line, istringstream::in)</span></span>;

<span class="hljs-keyword">while</span>( iss &gt;&gt; word )     
{
    <span class="hljs-comment">// Do something on `word` here...</span>
}
</code></pre>
    </div></div></div></div><div id="solution8" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 8</h4><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>This is similar to Stack&nbsp;Overflow question <em><a href="https://stackoverflow.com/questions/53849/how-do-i-tokenize-a-string-in-c">How do I tokenize a string in C++?</a></em>. <strong>Requires Boost external library</strong></p>
<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;boost/tokenizer.hpp&gt;</span></span>

<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> boost;

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>** argv)</span>
</span>{
    string text = <span class="hljs-string">"token  test\tstring"</span>;

    <span class="hljs-function">char_separator&lt;<span class="hljs-type">char</span>&gt; <span class="hljs-title">sep</span><span class="hljs-params">(<span class="hljs-string">" \t"</span>)</span></span>;
    tokenizer&lt;char_separator&lt;<span class="hljs-type">char</span>&gt;&gt; <span class="hljs-built_in">tokens</span>(text, sep);
    <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> string&amp; t : tokens)
    {
        cout &lt;&lt; t &lt;&lt; <span class="hljs-string">"."</span> &lt;&lt; endl;
    }
}
</code></pre>
    </div></div></div></div><div id="solution9" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 9</h4><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>I like the following because it puts the results into a vector, supports a string as a delim and gives control over keeping empty values. But, it doesn't look as good then.</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;ostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iterator&gt;</span></span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;

<span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">split</span><span class="hljs-params">(<span class="hljs-type">const</span> string&amp; s, <span class="hljs-type">const</span> string&amp; delim, <span class="hljs-type">const</span> <span class="hljs-type">bool</span> keep_empty = <span class="hljs-literal">true</span>)</span> </span>{
    vector&lt;string&gt; result;
    <span class="hljs-keyword">if</span> (delim.<span class="hljs-built_in">empty</span>()) {
        result.<span class="hljs-built_in">push_back</span>(s);
        <span class="hljs-keyword">return</span> result;
    }
    string::const_iterator substart = s.<span class="hljs-built_in">begin</span>(), subend;
    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) {
        subend = <span class="hljs-built_in">search</span>(substart, s.<span class="hljs-built_in">end</span>(), delim.<span class="hljs-built_in">begin</span>(), delim.<span class="hljs-built_in">end</span>());
        <span class="hljs-function">string <span class="hljs-title">temp</span><span class="hljs-params">(substart, subend)</span></span>;
        <span class="hljs-keyword">if</span> (keep_empty || !temp.<span class="hljs-built_in">empty</span>()) {
            result.<span class="hljs-built_in">push_back</span>(temp);
        }
        <span class="hljs-keyword">if</span> (subend == s.<span class="hljs-built_in">end</span>()) {
            <span class="hljs-keyword">break</span>;
        }
        substart = subend + delim.<span class="hljs-built_in">size</span>();
    }
    <span class="hljs-keyword">return</span> result;
}

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-type">const</span> vector&lt;string&gt; words = <span class="hljs-built_in">split</span>(<span class="hljs-string">"So close no matter how far"</span>, <span class="hljs-string">" "</span>);
    <span class="hljs-built_in">copy</span>(words.<span class="hljs-built_in">begin</span>(), words.<span class="hljs-built_in">end</span>(), <span class="hljs-built_in">ostream_iterator</span>&lt;string&gt;(cout, <span class="hljs-string">"\n"</span>));
}
</code></pre>

<p>Of course, Boost has a <a href="http://www.boost.org/doc/libs/1_36_0/doc/html/string_algo/usage.html#id3483755" rel="noreferrer"><code>split()</code></a> that works partially like that. And, if by 'white-space', you really do mean any type of white-space, using Boost's split with <code>is_any_of()</code> works great.</p>
    </div></div></div></div><div id="solution10" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 10</h4><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>The STL does not have such a method available already.</p>

<p>However, you can either use C's <a href="http://en.cppreference.com/w/c/string/byte/strtok" rel="noreferrer"><code>strtok()</code></a> function by using the <a href="http://en.cppreference.com/w/cpp/string/basic_string/c_str" rel="noreferrer"><code>std::string::c_str()</code></a> member, or you can write your own. Here is a code sample I found after a quick Google search (<strong>"STL string split"</strong>):</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Tokenize</span><span class="hljs-params">(<span class="hljs-type">const</span> string&amp; str,
              vector&lt;string&gt;&amp; tokens,
              <span class="hljs-type">const</span> string&amp; delimiters = <span class="hljs-string">" "</span>)</span>
</span>{
    <span class="hljs-comment">// Skip delimiters at beginning.</span>
    string::size_type lastPos = str.<span class="hljs-built_in">find_first_not_of</span>(delimiters, <span class="hljs-number">0</span>);
    <span class="hljs-comment">// Find first "non-delimiter".</span>
    string::size_type pos     = str.<span class="hljs-built_in">find_first_of</span>(delimiters, lastPos);

    <span class="hljs-keyword">while</span> (string::npos != pos || string::npos != lastPos)
    {
        <span class="hljs-comment">// Found a token, add it to the vector.</span>
        tokens.<span class="hljs-built_in">push_back</span>(str.<span class="hljs-built_in">substr</span>(lastPos, pos - lastPos));
        <span class="hljs-comment">// Skip delimiters.  Note the "not_of"</span>
        lastPos = str.<span class="hljs-built_in">find_first_not_of</span>(delimiters, pos);
        <span class="hljs-comment">// Find next "non-delimiter"</span>
        pos = str.<span class="hljs-built_in">find_first_of</span>(delimiters, lastPos);
    }
}
</code></pre>

<p>Taken from: <a href="http://oopweb.com/CPP/Documents/CPPHOWTO/Volume/C++Programming-HOWTO-7.html" rel="noreferrer">http://oopweb.com/CPP/Documents/CPPHOWTO/Volume/C++Programming-HOWTO-7.html</a></p>

<p>If you have questions about the code sample, leave a comment and I will explain.</p>

<p>And just because it does not implement a <code>typedef</code> called iterator or overload the <code>&lt;&lt;</code> operator does not mean it is bad code. I use C functions quite frequently. For example, <a href="http://en.cppreference.com/w/c/io/fprintf" rel="noreferrer"><code>printf</code></a> and <a href="http://en.cppreference.com/w/c/io/fscanf" rel="noreferrer"><code>scanf</code></a> both are faster than <a href="http://en.cppreference.com/w/cpp/io/cin" rel="noreferrer"><code>std::cin</code></a> and <a href="http://en.cppreference.com/w/cpp/io/cout" rel="noreferrer"><code>std::cout</code></a> (significantly), the <a href="http://en.cppreference.com/w/c/io/fopen" rel="noreferrer"><code>fopen</code></a> syntax is a lot more friendly for binary types, and they also tend to produce smaller EXEs.</p>

<p>Don't get sold on this <strong>"Elegance over performance"</strong> deal.</p>
    </div></div></div></div><div id="solution11" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 11</h4><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Here is a split function that:</p>

<ul>
<li>is generic</li>
<li>uses standard C++ (no boost)</li>
<li>accepts multiple delimiters</li>
<li><p>ignores empty tokens (can easily be changed)</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;
vector&lt;T&gt; 
<span class="hljs-title">split</span><span class="hljs-params">(<span class="hljs-type">const</span> T &amp; str, <span class="hljs-type">const</span> T &amp; delimiters)</span> </span>{
    vector&lt;T&gt; v;
    <span class="hljs-keyword">typename</span> T::size_type start = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">auto</span> pos = str.<span class="hljs-built_in">find_first_of</span>(delimiters, start);
    <span class="hljs-keyword">while</span>(pos != T::npos) {
        <span class="hljs-keyword">if</span>(pos != start) <span class="hljs-comment">// ignore empty tokens</span>
            v.<span class="hljs-built_in">emplace_back</span>(str, start, pos - start);
        start = pos + <span class="hljs-number">1</span>;
        pos = str.<span class="hljs-built_in">find_first_of</span>(delimiters, start);
    }
    <span class="hljs-keyword">if</span>(start &lt; str.<span class="hljs-built_in">length</span>()) <span class="hljs-comment">// ignore trailing delimiter</span>
        v.<span class="hljs-built_in">emplace_back</span>(str, start, str.<span class="hljs-built_in">length</span>() - start); <span class="hljs-comment">// add what's left of the string</span>
    <span class="hljs-keyword">return</span> v;
}
</code></pre></li>
</ul>

<p>Example usage:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp">    vector&lt;string&gt; v = <span class="hljs-built_in">split</span>&lt;string&gt;(<span class="hljs-string">"Hello, there; World"</span>, <span class="hljs-string">";,"</span>);
    vector&lt;wstring&gt; v = <span class="hljs-built_in">split</span>&lt;wstring&gt;(<span class="hljs-string">L"Hello, there; World"</span>, <span class="hljs-string">L";,"</span>);
</code></pre>
    </div></div></div></div><div id="solution12" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 12</h4><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>I have a 2 lines solution to this problem:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-type">char</span> sep = <span class="hljs-string">' '</span>;
std::string s=<span class="hljs-string">"1 This is an example"</span>;

<span class="hljs-keyword">for</span>(<span class="hljs-type">size_t</span> p=<span class="hljs-number">0</span>, q=<span class="hljs-number">0</span>; p!=s.npos; p=q)
  std::cout &lt;&lt; s.<span class="hljs-built_in">substr</span>(p+(p!=<span class="hljs-number">0</span>), (q=s.<span class="hljs-built_in">find</span>(sep, p+<span class="hljs-number">1</span>))-p-(p!=<span class="hljs-number">0</span>)) &lt;&lt; std::endl;
</code></pre>

<p>Then instead of printing you can put it in a vector.</p>
    </div></div></div></div><div id="solution13" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 13</h4><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Yet another flexible and fast way</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Operator&gt;
<span class="hljs-type">void</span> <span class="hljs-title">tokenize</span><span class="hljs-params">(Operator&amp; op, <span class="hljs-type">const</span> <span class="hljs-type">char</span>* input, <span class="hljs-type">const</span> <span class="hljs-type">char</span>* delimiters)</span> </span>{
  <span class="hljs-type">const</span> <span class="hljs-type">char</span>* s = input;
  <span class="hljs-type">const</span> <span class="hljs-type">char</span>* e = s;
  <span class="hljs-keyword">while</span> (*e != <span class="hljs-number">0</span>) {
    e = s;
    <span class="hljs-keyword">while</span> (*e != <span class="hljs-number">0</span> &amp;&amp; <span class="hljs-built_in">strchr</span>(delimiters, *e) == <span class="hljs-number">0</span>) ++e;
    <span class="hljs-keyword">if</span> (e - s &gt; <span class="hljs-number">0</span>) {
      <span class="hljs-built_in">op</span>(s, e - s);
    }
    s = e + <span class="hljs-number">1</span>;
  }
}
</code></pre>

<p>To use it with a vector of strings (Edit: Since someone pointed out not to inherit STL classes... hrmf ;) ) :</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">ContainerType</span>&gt;
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Appender</span> {
<span class="hljs-keyword">public</span>:
  <span class="hljs-built_in">Appender</span>(ContainerType&amp; container) : <span class="hljs-built_in">container_</span>(container) {;}
  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span> <span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* s, <span class="hljs-type">unsigned</span> length)</span> </span>{ 
    container_.<span class="hljs-built_in">push_back</span>(std::<span class="hljs-built_in">string</span>(s,length));
  }
<span class="hljs-keyword">private</span>:
  ContainerType&amp; container_;
};

std::vector&lt;std::string&gt; strVector;
<span class="hljs-function">Appender <span class="hljs-title">v</span><span class="hljs-params">(strVector)</span></span>;
<span class="hljs-built_in">tokenize</span>(v, <span class="hljs-string">"A number of words to be tokenized"</span>, <span class="hljs-string">" \t"</span>);
</code></pre>

<p>That's it! And that's just one way to use the tokenizer, like how to just 
count words:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">WordCounter</span> {
<span class="hljs-keyword">public</span>:
  <span class="hljs-built_in">WordCounter</span>() : <span class="hljs-built_in">noOfWords</span>(<span class="hljs-number">0</span>) {}
  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span> <span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>*, <span class="hljs-type">unsigned</span>)</span> </span>{
    ++noOfWords;
  }
  <span class="hljs-type">unsigned</span> noOfWords;
};

WordCounter wc;
<span class="hljs-built_in">tokenize</span>(wc, <span class="hljs-string">"A number of words to be counted"</span>, <span class="hljs-string">" \t"</span>); 
<span class="hljs-built_in">ASSERT</span>( wc.noOfWords == <span class="hljs-number">7</span> );
</code></pre>

<p>Limited by imagination ;)</p>
    </div></div></div></div><div id="solution14" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 14</h4><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Here's a simple solution that uses only the standard regex library</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;regex&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span>

<span class="hljs-function">std::vector&lt;string&gt; <span class="hljs-title">Tokenize</span><span class="hljs-params">( <span class="hljs-type">const</span> string str, <span class="hljs-type">const</span> std::regex regex )</span>
</span>{
    <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;

    std::vector&lt;string&gt; result;

    <span class="hljs-function">sregex_token_iterator <span class="hljs-title">it</span><span class="hljs-params">( str.begin(), str.end(), regex, <span class="hljs-number">-1</span> )</span></span>;
    sregex_token_iterator reg_end;

    <span class="hljs-keyword">for</span> ( ; it != reg_end; ++it ) {
        <span class="hljs-keyword">if</span> ( !it-&gt;<span class="hljs-built_in">str</span>().<span class="hljs-built_in">empty</span>() ) <span class="hljs-comment">//token could be empty:check</span>
            result.<span class="hljs-built_in">emplace_back</span>( it-&gt;<span class="hljs-built_in">str</span>() );
    }

    <span class="hljs-keyword">return</span> result;
}
</code></pre>

<p>The regex argument allows checking for multiple arguments (spaces, commas, etc.)</p>

<p>I usually only check to split on spaces and commas, so I also have this default function:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-function">std::vector&lt;string&gt; <span class="hljs-title">TokenizeDefault</span><span class="hljs-params">( <span class="hljs-type">const</span> string str )</span>
</span>{
    <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;

    <span class="hljs-function">regex <span class="hljs-title">re</span><span class="hljs-params">( <span class="hljs-string">"[\\s,]+"</span> )</span></span>;

    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Tokenize</span>( str, re );
}
</code></pre>

<p>The <code>"[\\s,]+"</code> checks for spaces (<code>\\s</code>) and commas (<code>,</code>).</p>

<p>Note, if you want to split <code>wstring</code> instead of <code>string</code>,</p>

<ul>
<li>change all <code>std::regex</code> to <code>std::wregex</code></li>
<li>change all <code>sregex_token_iterator</code> to <code>wsregex_token_iterator</code></li>
</ul>

<p>Note, you might also want to take the string argument by reference, depending on your compiler.</p>
    </div></div></div></div><div id="solution15" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 15</h4><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Using <code>std::stringstream</code> as you have works perfectly fine, and do exactly what you wanted. If you're just looking for different way of doing things though, you can use <a href="http://en.cppreference.com/w/cpp/algorithm/find" rel="noreferrer"><code>std::find()</code></a>/<a href="http://en.cppreference.com/w/cpp/algorithm/find_first_of" rel="noreferrer"><code>std::find_first_of()</code></a> and <a href="http://en.cppreference.com/w/cpp/string/basic_string/substr" rel="noreferrer"><code>std::string::substr()</code></a>.</p>

<p>Here's an example:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span>

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-function">std::string <span class="hljs-title">s</span><span class="hljs-params">(<span class="hljs-string">"Somewhere down the road"</span>)</span></span>;
    std::string::size_type prev_pos = <span class="hljs-number">0</span>, pos = <span class="hljs-number">0</span>;

    <span class="hljs-keyword">while</span>( (pos = s.<span class="hljs-built_in">find</span>(<span class="hljs-string">' '</span>, pos)) != std::string::npos )
    {
        <span class="hljs-function">std::string <span class="hljs-title">substring</span><span class="hljs-params">( s.substr(prev_pos, pos-prev_pos) )</span></span>;

        std::cout &lt;&lt; substring &lt;&lt; <span class="hljs-string">'\n'</span>;

        prev_pos = ++pos;
    }

    <span class="hljs-function">std::string <span class="hljs-title">substring</span><span class="hljs-params">( s.substr(prev_pos, pos-prev_pos) )</span></span>; <span class="hljs-comment">// Last word</span>
    std::cout &lt;&lt; substring &lt;&lt; <span class="hljs-string">'\n'</span>;

    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>
    </div></div></div></div><div id="solution16" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 16</h4><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>If you like to use boost, but want to use a whole string as delimiter (instead of single characters as in most of the previously proposed solutions), you can use the <code>boost_split_iterator</code>.</p>

<p>Example code including convenient template:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;boost/algorithm/string.hpp&gt;</span></span>

<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> _OutputIterator&gt;
<span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">split</span><span class="hljs-params">(
    <span class="hljs-type">const</span> std::string&amp; str, 
    <span class="hljs-type">const</span> std::string&amp; delim, 
    _OutputIterator result)</span>
</span>{
    <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> boost::algorithm;
    <span class="hljs-keyword">typedef</span> split_iterator&lt;std::string::const_iterator&gt; It;

    <span class="hljs-keyword">for</span>(It iter=<span class="hljs-built_in">make_split_iterator</span>(str, <span class="hljs-built_in">first_finder</span>(delim, <span class="hljs-built_in">is_equal</span>()));
            iter!=<span class="hljs-built_in">It</span>();
            ++iter)
    {
        *(result++) = boost::<span class="hljs-built_in">copy_range</span>&lt;std::string&gt;(*iter);
    }
}

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>* argv[])</span>
</span>{
    <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;

    vector&lt;string&gt; splitted;
    <span class="hljs-built_in">split</span>(<span class="hljs-string">"HelloFOOworldFOO!"</span>, <span class="hljs-string">"FOO"</span>, <span class="hljs-built_in">back_inserter</span>(splitted));

    <span class="hljs-comment">// or directly to console, for example</span>
    <span class="hljs-built_in">split</span>(<span class="hljs-string">"HelloFOOworldFOO!"</span>, <span class="hljs-string">"FOO"</span>, <span class="hljs-built_in">ostream_iterator</span>&lt;string&gt;(cout, <span class="hljs-string">"\n"</span>));
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>
    </div></div></div></div><div id="solution17" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 17</h4><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Heres a regex solution that only uses the standard regex library.  (I'm a little rusty, so there may be a few syntax errors, but this is at least the general idea)</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;regex.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector.h&gt;</span></span>

<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;

<span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">split</span><span class="hljs-params">(string s)</span></span>{
    <span class="hljs-function">regex <span class="hljs-title">r</span> <span class="hljs-params">(<span class="hljs-string">"\\w+"</span>)</span></span>; <span class="hljs-comment">//regex matches whole words, (greedy, so no fragment words)</span>
    <span class="hljs-function">regex_iterator&lt;string::iterator&gt; <span class="hljs-title">rit</span> <span class="hljs-params">( s.begin(), s.end(), r )</span></span>;
    regex_iterator&lt;string::iterator&gt; rend; <span class="hljs-comment">//iterators to iterate thru words</span>
    vector&lt;string&gt; <span class="hljs-built_in">result</span>&lt;regex_iterator&gt;(rit, rend);
    <span class="hljs-keyword">return</span> result;  <span class="hljs-comment">//iterates through the matches to fill the vector</span>
}
</code></pre>
    </div></div></div></div><div id="solution18" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 18</h4><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>There is a function named <a href="http://www.cplusplus.com/reference/clibrary/cstring/strtok/" rel="noreferrer"><code>strtok</code></a>.</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;string&gt;</span></span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;

<span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">split</span><span class="hljs-params">(<span class="hljs-type">char</span>* str,<span class="hljs-type">const</span> <span class="hljs-type">char</span>* delim)</span>
</span>{
    <span class="hljs-type">char</span>* saveptr;
    <span class="hljs-type">char</span>* token = <span class="hljs-built_in">strtok_r</span>(str,delim,&amp;saveptr);

    vector&lt;string&gt; result;

    <span class="hljs-keyword">while</span>(token != <span class="hljs-literal">NULL</span>)
    {
        result.<span class="hljs-built_in">push_back</span>(token);
        token = <span class="hljs-built_in">strtok_r</span>(<span class="hljs-literal">NULL</span>,delim,&amp;saveptr);
    }
    <span class="hljs-keyword">return</span> result;
}
</code></pre>
    </div></div></div></div><div id="solution19" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 19</h4><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>The <a href="http://www.cplusplus.com/reference/sstream/stringstream/" rel="noreferrer">stringstream</a> can be convenient if you need to parse the string by non-space symbols:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp">string s = <span class="hljs-string">"Name:JAck; Spouse:Susan; ..."</span>;
string dummy, name, spouse;

<span class="hljs-function">istringstream <span class="hljs-title">iss</span><span class="hljs-params">(s)</span></span>;
<span class="hljs-built_in">getline</span>(iss, dummy, <span class="hljs-string">':'</span>);
<span class="hljs-built_in">getline</span>(iss, name, <span class="hljs-string">';'</span>);
<span class="hljs-built_in">getline</span>(iss, dummy, <span class="hljs-string">':'</span>);
<span class="hljs-built_in">getline</span>(iss, spouse, <span class="hljs-string">';'</span>)
</code></pre>
    </div></div></div></div><div id="solution20" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 20</h4><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Using <code>std::string_view</code> and Eric Niebler's <code>range-v3</code> library:</p>

<p><a href="https://wandbox.org/permlink/kW5lwRCL1pxjp2pW" rel="noreferrer">https://wandbox.org/permlink/kW5lwRCL1pxjp2pW</a></p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string_view&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"range/v3/view.hpp"</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"range/v3/algorithm.hpp"</span></span>

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    std::string s = <span class="hljs-string">"Somewhere down the range v3 library"</span>;
    ranges::for_each(s  
        |   ranges::view::<span class="hljs-built_in">split</span>(<span class="hljs-string">' '</span>)
        |   ranges::view::<span class="hljs-built_in">transform</span>([](<span class="hljs-keyword">auto</span> &amp;&amp;sub) {
                <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">string_view</span>(&amp;*sub.<span class="hljs-built_in">begin</span>(), ranges::<span class="hljs-built_in">distance</span>(sub));
            }),
        [](<span class="hljs-keyword">auto</span> s) {std::cout &lt;&lt; <span class="hljs-string">"Substring: "</span> &lt;&lt; s &lt;&lt; <span class="hljs-string">"\n"</span>;}
    );
}
</code></pre>

<p>By using a range <code>for</code> loop instead of <code>ranges::for_each</code> algorithm:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string_view&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"range/v3/view.hpp"</span></span>

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    std::string str = <span class="hljs-string">"Somewhere down the range v3 library"</span>;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> s : str | ranges::view::<span class="hljs-built_in">split</span>(<span class="hljs-string">' '</span>)
                      | ranges::view::<span class="hljs-built_in">transform</span>([](<span class="hljs-keyword">auto</span>&amp;&amp; sub) { <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">string_view</span>(&amp;*sub.<span class="hljs-built_in">begin</span>(), ranges::<span class="hljs-built_in">distance</span>(sub)); }
                      ))
    {
        std::cout &lt;&lt; <span class="hljs-string">"Substring: "</span> &lt;&lt; s &lt;&lt; <span class="hljs-string">"\n"</span>;
    }
}
</code></pre>
    </div></div></div></div><div id="solution21" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 21</h4><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>C++20 finally blesses us with a <code>split</code> function. Or rather, a range adapter. <a href="https://godbolt.org/z/6mZ8hG" rel="noreferrer">Godbolt link</a>.</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;ranges&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string_view&gt;</span></span>

<span class="hljs-keyword">namespace</span> ranges = std::ranges;
<span class="hljs-keyword">namespace</span> views = std::views;

<span class="hljs-keyword">using</span> str = std::string_view;

<span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">auto</span> view =
    <span class="hljs-string">"Multiple words"</span>
    | views::<span class="hljs-built_in">split</span>(<span class="hljs-string">' '</span>)
    | views::<span class="hljs-built_in">transform</span>([](<span class="hljs-keyword">auto</span> &amp;&amp;r) -&gt; str {
        <span class="hljs-keyword">return</span> {
            &amp;*r.<span class="hljs-built_in">begin</span>(),
            <span class="hljs-built_in">static_cast</span>&lt;str::size_type&gt;(ranges::<span class="hljs-built_in">distance</span>(r))
        };
    });

<span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> -&gt; <span class="hljs-type">int</span> </span>{
    <span class="hljs-keyword">for</span> (str &amp;&amp;sv : view) {
        std::cout &lt;&lt; sv &lt;&lt; <span class="hljs-string">'\n'</span>;
    }
}
</code></pre>
    </div></div></div></div><div id="solution22" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 22</h4><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>So far I used the one in <a href="http://en.wikipedia.org/wiki/Boost_C++_Libraries" rel="noreferrer">Boost</a>, but I needed something that doesn't depends on it, so I came to this:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">Split</span><span class="hljs-params">(std::vector&lt;std::string&gt;&amp; lst, <span class="hljs-type">const</span> std::string&amp; input, <span class="hljs-type">const</span> std::string&amp; separators, <span class="hljs-type">bool</span> remove_empty = <span class="hljs-literal">true</span>)</span>
</span>{
    std::ostringstream word;
    <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> n = <span class="hljs-number">0</span>; n &lt; input.<span class="hljs-built_in">size</span>(); ++n)
    {
        <span class="hljs-keyword">if</span> (std::string::npos == separators.<span class="hljs-built_in">find</span>(input[n]))
            word &lt;&lt; input[n];
        <span class="hljs-keyword">else</span>
        {
            <span class="hljs-keyword">if</span> (!word.<span class="hljs-built_in">str</span>().<span class="hljs-built_in">empty</span>() || !remove_empty)
                lst.<span class="hljs-built_in">push_back</span>(word.<span class="hljs-built_in">str</span>());
            word.<span class="hljs-built_in">str</span>(<span class="hljs-string">""</span>);
        }
    }
    <span class="hljs-keyword">if</span> (!word.<span class="hljs-built_in">str</span>().<span class="hljs-built_in">empty</span>() || !remove_empty)
        lst.<span class="hljs-built_in">push_back</span>(word.<span class="hljs-built_in">str</span>());
}
</code></pre>

<p>A good point is that in <code>separators</code> you can pass more than one character.</p>
    </div></div></div></div><div id="solution23" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 23</h4><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Short and elegant</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;

<span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">split</span><span class="hljs-params">(string data, string token)</span>
</span>{
    vector&lt;string&gt; output;
    <span class="hljs-type">size_t</span> pos = string::npos; <span class="hljs-comment">// size_t to avoid improbable overflow</span>
    <span class="hljs-keyword">do</span>
    {
        pos = data.<span class="hljs-built_in">find</span>(token);
        output.<span class="hljs-built_in">push_back</span>(data.<span class="hljs-built_in">substr</span>(<span class="hljs-number">0</span>, pos));
        <span class="hljs-keyword">if</span> (string::npos != pos)
            data = data.<span class="hljs-built_in">substr</span>(pos + token.<span class="hljs-built_in">size</span>());
    } <span class="hljs-keyword">while</span> (string::npos != pos);
    <span class="hljs-keyword">return</span> output;
}
</code></pre>

<p>can use any string as delimiter, also can be used with binary data (std::string supports binary data, including nulls)</p>

<p>using:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-keyword">auto</span> a = <span class="hljs-built_in">split</span>(<span class="hljs-string">"this!!is!!!example!string"</span>, <span class="hljs-string">"!!"</span>);
</code></pre>

<p>output:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-keyword">this</span>
is
!example!string
</code></pre>
    </div></div></div></div><div id="solution24" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 24</h4><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>I've rolled my own using strtok and used boost to split a string.  The best method I have found is the <a href="http://www.partow.net/programming/strtk/">C++ String Toolkit Library</a>.  It is incredibly flexible and fast.</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;strtk.hpp&gt;</span></span>

<span class="hljs-type">const</span> <span class="hljs-type">char</span> *whitespace  = <span class="hljs-string">" \t\r\n\f"</span>;
<span class="hljs-type">const</span> <span class="hljs-type">char</span> *whitespace_and_punctuation  = <span class="hljs-string">" \t\r\n\f;,="</span>;

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    {   <span class="hljs-comment">// normal parsing of a string into a vector of strings</span>
        <span class="hljs-function">std::string <span class="hljs-title">s</span><span class="hljs-params">(<span class="hljs-string">"Somewhere down the road"</span>)</span></span>;
        std::vector&lt;std::string&gt; result;
        <span class="hljs-keyword">if</span>( strtk::<span class="hljs-built_in">parse</span>( s, whitespace, result ) )
        {
            <span class="hljs-keyword">for</span>(<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; result.<span class="hljs-built_in">size</span>(); ++i )
                std::cout &lt;&lt; result[i] &lt;&lt; std::endl;
        }
    }

    {  <span class="hljs-comment">// parsing a string into a vector of floats with other separators</span>
        <span class="hljs-comment">// besides spaces</span>

        <span class="hljs-function">std::string <span class="hljs-title">s</span><span class="hljs-params">(<span class="hljs-string">"3.0, 3.14; 4.0"</span>)</span></span>;
        std::vector&lt;<span class="hljs-type">float</span>&gt; values;
        <span class="hljs-keyword">if</span>( strtk::<span class="hljs-built_in">parse</span>( s, whitespace_and_punctuation, values ) )
        {
            <span class="hljs-keyword">for</span>(<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; values.<span class="hljs-built_in">size</span>(); ++i )
                std::cout &lt;&lt; values[i] &lt;&lt; std::endl;
        }
    }

    {  <span class="hljs-comment">// parsing a string into specific variables</span>

        <span class="hljs-function">std::string <span class="hljs-title">s</span><span class="hljs-params">(<span class="hljs-string">"angle = 45; radius = 9.9"</span>)</span></span>;
        std::string w1, w2;
        <span class="hljs-type">float</span> v1, v2;
        <span class="hljs-keyword">if</span>( strtk::<span class="hljs-built_in">parse</span>( s, whitespace_and_punctuation, w1, v1, w2, v2) )
        {
            std::cout &lt;&lt; <span class="hljs-string">"word "</span> &lt;&lt; w1 &lt;&lt; <span class="hljs-string">", value "</span> &lt;&lt; v1 &lt;&lt; std::endl;
            std::cout &lt;&lt; <span class="hljs-string">"word "</span> &lt;&lt; w2 &lt;&lt; <span class="hljs-string">", value "</span> &lt;&lt; v2 &lt;&lt; std::endl;
        }
    }

    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>

<p>The toolkit has much more flexibility than this simple example shows but its utility in parsing a string into useful elements is incredible.</p>
    </div></div></div></div><div id="solution25" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 25</h4><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>I made this because I needed an easy way to split strings and c-based strings... Hopefully someone else can find it useful as well. Also it doesn't rely on tokens and you can use fields as delimiters, which is another key I needed.</p>

<p>I'm sure there's improvements that can be made to even further improve its elegance and please do by all means</p>

<p>StringSplitter.hpp:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span>

<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;

<span class="hljs-keyword">class</span> <span class="hljs-title class_">StringSplit</span>
{
<span class="hljs-keyword">private</span>:
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">copy_fragment</span><span class="hljs-params">(<span class="hljs-type">char</span>*, <span class="hljs-type">char</span>*, <span class="hljs-type">char</span>*)</span></span>;
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">copy_fragment</span><span class="hljs-params">(<span class="hljs-type">char</span>*, <span class="hljs-type">char</span>*, <span class="hljs-type">char</span>)</span></span>;
    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">match_fragment</span><span class="hljs-params">(<span class="hljs-type">char</span>*, <span class="hljs-type">char</span>*, <span class="hljs-type">int</span>)</span></span>;
    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">untilnextdelim</span><span class="hljs-params">(<span class="hljs-type">char</span>*, <span class="hljs-type">char</span>)</span></span>;
    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">untilnextdelim</span><span class="hljs-params">(<span class="hljs-type">char</span>*, <span class="hljs-type">char</span>*)</span></span>;
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">assimilate</span><span class="hljs-params">(<span class="hljs-type">char</span>*, <span class="hljs-type">char</span>)</span></span>;
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">assimilate</span><span class="hljs-params">(<span class="hljs-type">char</span>*, <span class="hljs-type">char</span>*)</span></span>;
    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">string_contains</span><span class="hljs-params">(<span class="hljs-type">char</span>*, <span class="hljs-type">char</span>*)</span></span>;
    <span class="hljs-function"><span class="hljs-type">long</span> <span class="hljs-title">calc_string_size</span><span class="hljs-params">(<span class="hljs-type">char</span>*)</span></span>;
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">copy_string</span><span class="hljs-params">(<span class="hljs-type">char</span>*, <span class="hljs-type">char</span>*)</span></span>;

<span class="hljs-keyword">public</span>:
    <span class="hljs-function">vector&lt;<span class="hljs-type">char</span>*&gt; <span class="hljs-title">split_cstr</span><span class="hljs-params">(<span class="hljs-type">char</span>)</span></span>;
    <span class="hljs-function">vector&lt;<span class="hljs-type">char</span>*&gt; <span class="hljs-title">split_cstr</span><span class="hljs-params">(<span class="hljs-type">char</span>*)</span></span>;
    <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">split_string</span><span class="hljs-params">(<span class="hljs-type">char</span>)</span></span>;
    <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">split_string</span><span class="hljs-params">(<span class="hljs-type">char</span>*)</span></span>;
    <span class="hljs-type">char</span>* String;
    <span class="hljs-type">bool</span> do_string;
    <span class="hljs-type">bool</span> keep_empty;
    vector&lt;<span class="hljs-type">char</span>*&gt; Container;
    vector&lt;string&gt; ContainerS;

    <span class="hljs-built_in">StringSplit</span>(<span class="hljs-type">char</span> * in)
    {
        String = in;
    }

    <span class="hljs-built_in">StringSplit</span>(string in)
    {
        <span class="hljs-type">size_t</span> len = <span class="hljs-built_in">calc_string_size</span>((<span class="hljs-type">char</span>*)in.<span class="hljs-built_in">c_str</span>());
        String = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[len + <span class="hljs-number">1</span>];
        <span class="hljs-built_in">memset</span>(String, <span class="hljs-number">0</span>, len + <span class="hljs-number">1</span>);
        <span class="hljs-built_in">copy_string</span>(String, (<span class="hljs-type">char</span>*)in.<span class="hljs-built_in">c_str</span>());
        do_string = <span class="hljs-literal">true</span>;
    }

    ~<span class="hljs-built_in">StringSplit</span>()
    {
        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; Container.<span class="hljs-built_in">size</span>(); i++)
        {
            <span class="hljs-keyword">if</span> (Container[i] != <span class="hljs-literal">NULL</span>)
            {
                <span class="hljs-keyword">delete</span>[] Container[i];
            }
        }
        <span class="hljs-keyword">if</span> (do_string)
        {
            <span class="hljs-keyword">delete</span>[] String;
        }
    }
};
</code></pre>

<p>StringSplitter.cpp:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"StringSplit.hpp"</span></span>

<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;

<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">StringSplit::assimilate</span><span class="hljs-params">(<span class="hljs-type">char</span>*src, <span class="hljs-type">char</span> delim)</span>
</span>{
    <span class="hljs-type">int</span> until = <span class="hljs-built_in">untilnextdelim</span>(src, delim);
    <span class="hljs-keyword">if</span> (until &gt; <span class="hljs-number">0</span>)
    {
        <span class="hljs-type">char</span> * temp = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[until + <span class="hljs-number">1</span>];
        <span class="hljs-built_in">memset</span>(temp, <span class="hljs-number">0</span>, until + <span class="hljs-number">1</span>);
        <span class="hljs-built_in">copy_fragment</span>(temp, src, delim);
        <span class="hljs-keyword">if</span> (keep_empty || *temp != <span class="hljs-number">0</span>)
        {
            <span class="hljs-keyword">if</span> (!do_string)
            {
                Container.<span class="hljs-built_in">push_back</span>(temp);
            }
            <span class="hljs-keyword">else</span>
            {
                string x = temp;
                ContainerS.<span class="hljs-built_in">push_back</span>(x);
            }

        }
        <span class="hljs-keyword">else</span>
        {
            <span class="hljs-keyword">delete</span>[] temp;
        }
    }
}

<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">StringSplit::assimilate</span><span class="hljs-params">(<span class="hljs-type">char</span>*src, <span class="hljs-type">char</span>* delim)</span>
</span>{
    <span class="hljs-type">int</span> until = <span class="hljs-built_in">untilnextdelim</span>(src, delim);
    <span class="hljs-keyword">if</span> (until &gt; <span class="hljs-number">0</span>)
    {
        <span class="hljs-type">char</span> * temp = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[until + <span class="hljs-number">1</span>];
        <span class="hljs-built_in">memset</span>(temp, <span class="hljs-number">0</span>, until + <span class="hljs-number">1</span>);
        <span class="hljs-built_in">copy_fragment</span>(temp, src, delim);
        <span class="hljs-keyword">if</span> (keep_empty || *temp != <span class="hljs-number">0</span>)
        {
            <span class="hljs-keyword">if</span> (!do_string)
            {
                Container.<span class="hljs-built_in">push_back</span>(temp);
            }
            <span class="hljs-keyword">else</span>
            {
                string x = temp;
                ContainerS.<span class="hljs-built_in">push_back</span>(x);
            }
        }
        <span class="hljs-keyword">else</span>
        {
            <span class="hljs-keyword">delete</span>[] temp;
        }
    }
}

<span class="hljs-function"><span class="hljs-type">long</span> <span class="hljs-title">StringSplit::calc_string_size</span><span class="hljs-params">(<span class="hljs-type">char</span>* _in)</span>
</span>{
    <span class="hljs-type">long</span> i = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">while</span> (*_in++)
    {
        i++;
    }
    <span class="hljs-keyword">return</span> i;
}

<span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">StringSplit::string_contains</span><span class="hljs-params">(<span class="hljs-type">char</span>* haystack, <span class="hljs-type">char</span>* needle)</span>
</span>{
    <span class="hljs-type">size_t</span> len = <span class="hljs-built_in">calc_string_size</span>(needle);
    <span class="hljs-type">size_t</span> lenh = <span class="hljs-built_in">calc_string_size</span>(haystack);
    <span class="hljs-keyword">while</span> (lenh--)
    {
        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">match_fragment</span>(haystack + lenh, needle, len))
        {
            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
        }
    }
    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
}

<span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">StringSplit::match_fragment</span><span class="hljs-params">(<span class="hljs-type">char</span>* _src, <span class="hljs-type">char</span>* cmp, <span class="hljs-type">int</span> len)</span>
</span>{
    <span class="hljs-keyword">while</span> (len--)
    {
        <span class="hljs-keyword">if</span> (*(_src + len) != *(cmp + len))
        {
            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
        }
    }
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
}

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">StringSplit::untilnextdelim</span><span class="hljs-params">(<span class="hljs-type">char</span>* _in, <span class="hljs-type">char</span> delim)</span>
</span>{
    <span class="hljs-type">size_t</span> len = <span class="hljs-built_in">calc_string_size</span>(_in);
    <span class="hljs-keyword">if</span> (*_in == delim)
    {
        _in += <span class="hljs-number">1</span>;
        <span class="hljs-keyword">return</span> len - <span class="hljs-number">1</span>;
    }

    <span class="hljs-type">int</span> c = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">while</span> (*(_in + c) != delim &amp;&amp; c &lt; len)
    {
        c++;
    }

    <span class="hljs-keyword">return</span> c;
}

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">StringSplit::untilnextdelim</span><span class="hljs-params">(<span class="hljs-type">char</span>* _in, <span class="hljs-type">char</span>* delim)</span>
</span>{
    <span class="hljs-type">int</span> s = <span class="hljs-built_in">calc_string_size</span>(delim);
    <span class="hljs-type">int</span> c = <span class="hljs-number">1</span> + s;

    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">string_contains</span>(_in, delim))
    {
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">calc_string_size</span>(_in);
    }
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">match_fragment</span>(_in, delim, s))
    {
        _in += s;
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">calc_string_size</span>(_in);
    }

    <span class="hljs-keyword">while</span> (!<span class="hljs-built_in">match_fragment</span>(_in + c, delim, s))
    {
        c++;
    }

    <span class="hljs-keyword">return</span> c;
}

<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">StringSplit::copy_fragment</span><span class="hljs-params">(<span class="hljs-type">char</span>* dest, <span class="hljs-type">char</span>* src, <span class="hljs-type">char</span> delim)</span>
</span>{
    <span class="hljs-keyword">if</span> (*src == delim)
    {
        src++;
    }

    <span class="hljs-type">int</span> c = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">while</span> (*(src + c) != delim &amp;&amp; *(src + c))
    {
        *(dest + c) = *(src + c);
        c++;
    }
    *(dest + c) = <span class="hljs-number">0</span>;
}

<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">StringSplit::copy_string</span><span class="hljs-params">(<span class="hljs-type">char</span>* dest, <span class="hljs-type">char</span>* src)</span>
</span>{
    <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">while</span> (*(src + i))
    {
        *(dest + i) = *(src + i);
        i++;
    }
}

<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">StringSplit::copy_fragment</span><span class="hljs-params">(<span class="hljs-type">char</span>* dest, <span class="hljs-type">char</span>* src, <span class="hljs-type">char</span>* delim)</span>
</span>{
    <span class="hljs-type">size_t</span> len = <span class="hljs-built_in">calc_string_size</span>(delim);
    <span class="hljs-type">size_t</span> lens = <span class="hljs-built_in">calc_string_size</span>(src);

    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">match_fragment</span>(src, delim, len))
    {
        src += len;
        lens -= len;
    }

    <span class="hljs-type">int</span> c = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">while</span> (!<span class="hljs-built_in">match_fragment</span>(src + c, delim, len) &amp;&amp; (c &lt; lens))
    {
        *(dest + c) = *(src + c);
        c++;
    }
    *(dest + c) = <span class="hljs-number">0</span>;
}

<span class="hljs-function">vector&lt;<span class="hljs-type">char</span>*&gt; <span class="hljs-title">StringSplit::split_cstr</span><span class="hljs-params">(<span class="hljs-type">char</span> Delimiter)</span>
</span>{
    <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">while</span> (*String)
    {
        <span class="hljs-keyword">if</span> (*String != Delimiter &amp;&amp; i == <span class="hljs-number">0</span>)
        {
            <span class="hljs-built_in">assimilate</span>(String, Delimiter);
        }
        <span class="hljs-keyword">if</span> (*String == Delimiter)
        {
            <span class="hljs-built_in">assimilate</span>(String, Delimiter);
        }
        i++;
        String++;
    }

    String -= i;
    <span class="hljs-keyword">delete</span>[] String;

    <span class="hljs-keyword">return</span> Container;
}

<span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">StringSplit::split_string</span><span class="hljs-params">(<span class="hljs-type">char</span> Delimiter)</span>
</span>{
    do_string = <span class="hljs-literal">true</span>;

    <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">while</span> (*String)
    {
        <span class="hljs-keyword">if</span> (*String != Delimiter &amp;&amp; i == <span class="hljs-number">0</span>)
        {
            <span class="hljs-built_in">assimilate</span>(String, Delimiter);
        }
        <span class="hljs-keyword">if</span> (*String == Delimiter)
        {
            <span class="hljs-built_in">assimilate</span>(String, Delimiter);
        }
        i++;
        String++;
    }

    String -= i;
    <span class="hljs-keyword">delete</span>[] String;

    <span class="hljs-keyword">return</span> ContainerS;
}

<span class="hljs-function">vector&lt;<span class="hljs-type">char</span>*&gt; <span class="hljs-title">StringSplit::split_cstr</span><span class="hljs-params">(<span class="hljs-type">char</span>* Delimiter)</span>
</span>{
    <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;
    <span class="hljs-type">size_t</span> LenDelim = <span class="hljs-built_in">calc_string_size</span>(Delimiter);

    <span class="hljs-keyword">while</span>(*String)
    {
        <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">match_fragment</span>(String, Delimiter, LenDelim) &amp;&amp; i == <span class="hljs-number">0</span>)
        {
            <span class="hljs-built_in">assimilate</span>(String, Delimiter);
        }
        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">match_fragment</span>(String, Delimiter, LenDelim))
        {
            <span class="hljs-built_in">assimilate</span>(String,Delimiter);
        }
        i++;
        String++;
    }

    String -= i;
    <span class="hljs-keyword">delete</span>[] String;

    <span class="hljs-keyword">return</span> Container;
}

<span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">StringSplit::split_string</span><span class="hljs-params">(<span class="hljs-type">char</span>* Delimiter)</span>
</span>{
    do_string = <span class="hljs-literal">true</span>;
    <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;
    <span class="hljs-type">size_t</span> LenDelim = <span class="hljs-built_in">calc_string_size</span>(Delimiter);

    <span class="hljs-keyword">while</span> (*String)
    {
        <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">match_fragment</span>(String, Delimiter, LenDelim) &amp;&amp; i == <span class="hljs-number">0</span>)
        {
            <span class="hljs-built_in">assimilate</span>(String, Delimiter);
        }
        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">match_fragment</span>(String, Delimiter, LenDelim))
        {
            <span class="hljs-built_in">assimilate</span>(String, Delimiter);
        }
        i++;
        String++;
    }

    String -= i;
    <span class="hljs-keyword">delete</span>[] String;

    <span class="hljs-keyword">return</span> ContainerS;
}
</code></pre>

<p>Examples:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>*argv[])</span>
</span>{
    StringSplit ss = <span class="hljs-string">"This:CUT:is:CUT:an:CUT:example:CUT:cstring"</span>;
    vector&lt;<span class="hljs-type">char</span>*&gt; Split = ss.<span class="hljs-built_in">split_cstr</span>(<span class="hljs-string">":CUT:"</span>);

    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; Split.<span class="hljs-built_in">size</span>(); i++)
    {
        cout &lt;&lt; Split[i] &lt;&lt; endl;
    }

    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>

<p>Will output:</p>

<p>This<br>
is<br>
an<br>
example<br>
cstring<br></p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>*argv[])</span>
</span>{
    StringSplit ss = <span class="hljs-string">"This:is:an:example:cstring"</span>;
    vector&lt;<span class="hljs-type">char</span>*&gt; Split = ss.<span class="hljs-built_in">split_cstr</span>(<span class="hljs-string">':'</span>);

    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; Split.<span class="hljs-built_in">size</span>(); i++)
    {
        cout &lt;&lt; Split[i] &lt;&lt; endl;
    }

    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>*argv[])</span>
</span>{
    string mystring = <span class="hljs-string">"This[SPLIT]is[SPLIT]an[SPLIT]example[SPLIT]string"</span>;
    StringSplit ss = mystring;
    vector&lt;string&gt; Split = ss.<span class="hljs-built_in">split_string</span>(<span class="hljs-string">"[SPLIT]"</span>);

    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; Split.<span class="hljs-built_in">size</span>(); i++)
    {
        cout &lt;&lt; Split[i] &lt;&lt; endl;
    }

    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>*argv[])</span>
</span>{
    string mystring = <span class="hljs-string">"This|is|an|example|string"</span>;
    StringSplit ss = mystring;
    vector&lt;string&gt; Split = ss.<span class="hljs-built_in">split_string</span>(<span class="hljs-string">'|'</span>);

    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; Split.<span class="hljs-built_in">size</span>(); i++)
    {
        cout &lt;&lt; Split[i] &lt;&lt; endl;
    }

    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>

<p>To keep empty entries (by default empties will be excluded):</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp">StringSplit ss = mystring;
ss.keep_empty = <span class="hljs-literal">true</span>;
vector&lt;string&gt; Split = ss.<span class="hljs-built_in">split_string</span>(<span class="hljs-string">":DELIM:"</span>);
</code></pre>

<p>The goal was to make it similar to C#'s Split() method where splitting a string is as easy as:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp">String[] Split = 
    <span class="hljs-string">"Hey:cut:what's:cut:your:cut:name?"</span>.<span class="hljs-built_in">Split</span>(<span class="hljs-keyword">new</span>[]{<span class="hljs-string">":cut:"</span>}, StringSplitOptions.None);

foreach(String X in Split)
{
    Console.<span class="hljs-built_in">Write</span>(X);
}
</code></pre>

<p>I hope someone else can find this as useful as I do.</p>
    </div></div></div></div><div id="solution26" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 26</h4><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>This answer takes the string and puts it into a vector of strings. It uses the boost library.</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;boost/algorithm/string.hpp&gt;</span></span>
std::vector&lt;std::string&gt; strs;
boost::<span class="hljs-built_in">split</span>(strs, <span class="hljs-string">"string to split"</span>, boost::<span class="hljs-built_in">is_any_of</span>(<span class="hljs-string">"\t "</span>));
</code></pre>
    </div></div></div></div><div id="solution27" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 27</h4><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>What about this:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span>

<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;

<span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">split</span><span class="hljs-params">(string str, <span class="hljs-type">const</span> <span class="hljs-type">char</span> delim)</span> </span>{
    vector&lt;string&gt; v;
    string tmp;

    <span class="hljs-keyword">for</span>(string::const_iterator i; i = str.<span class="hljs-built_in">begin</span>(); i &lt;= str.<span class="hljs-built_in">end</span>(); ++i) {
        <span class="hljs-keyword">if</span>(*i != delim &amp;&amp; i != str.<span class="hljs-built_in">end</span>()) {
            tmp += *i; 
        } <span class="hljs-keyword">else</span> {
            v.<span class="hljs-built_in">push_back</span>(tmp);
            tmp = <span class="hljs-string">""</span>; 
        }   
    }   

    <span class="hljs-keyword">return</span> v;
}
</code></pre>
    </div></div></div></div><div id="solution28" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 28</h4><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Here's another way of doing it..</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">split_string</span><span class="hljs-params">(string text,vector&lt;string&gt;&amp; words)</span>
</span>{
  <span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;
  <span class="hljs-type">char</span> ch;
  string word;

  <span class="hljs-keyword">while</span>(ch=text[i++])
  {
    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isspace</span>(ch))
    {
      <span class="hljs-keyword">if</span> (!word.<span class="hljs-built_in">empty</span>())
      {
        words.<span class="hljs-built_in">push_back</span>(word);
      }
      word = <span class="hljs-string">""</span>;
    }
    <span class="hljs-keyword">else</span>
    {
      word += ch;
    }
  }
  <span class="hljs-keyword">if</span> (!word.<span class="hljs-built_in">empty</span>())
  {
    words.<span class="hljs-built_in">push_back</span>(word);
  }
}
</code></pre>
    </div></div></div></div><div id="solution29" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 29</h4><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>I like to use the boost/regex methods for this task since they provide maximum flexibility for specifying the splitting criteria.</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;boost/regex.hpp&gt;</span></span>

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-function">std::string <span class="hljs-title">line</span><span class="hljs-params">(<span class="hljs-string">"A:::line::to:split"</span>)</span></span>;
    <span class="hljs-function"><span class="hljs-type">const</span> boost::regex <span class="hljs-title">re</span><span class="hljs-params">(<span class="hljs-string">":+"</span>)</span></span>; <span class="hljs-comment">// one or more colons</span>

    <span class="hljs-comment">// -1 means find inverse matches aka split</span>
    <span class="hljs-function">boost::sregex_token_iterator <span class="hljs-title">tokens</span><span class="hljs-params">(line.begin(),line.end(),re,<span class="hljs-number">-1</span>)</span></span>;
    boost::sregex_token_iterator end;

    <span class="hljs-keyword">for</span> (; tokens != end; ++tokens)
        std::cout &lt;&lt; *tokens &lt;&lt; std::endl;
}
</code></pre>
    </div></div></div></div><div id="solution30" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 30</h4><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Recently I had to split a camel-cased word into subwords.  There are no delimiters, just upper characters. </p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;list&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;locale&gt;</span> <span class="hljs-comment">// std::isupper</span></span>

<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> String&gt;
<span class="hljs-type">const</span> std::list&lt;String&gt; <span class="hljs-title">split_camel_case_string</span><span class="hljs-params">(<span class="hljs-type">const</span> String &amp;s)</span>
</span>{
    std::list&lt;String&gt; R;
    String w;

    <span class="hljs-keyword">for</span> (String::const_iterator i = s.<span class="hljs-built_in">begin</span>(); i &lt; s.<span class="hljs-built_in">end</span>(); ++i) {  {
        <span class="hljs-keyword">if</span> (std::<span class="hljs-built_in">isupper</span>(*i)) {
            <span class="hljs-keyword">if</span> (w.<span class="hljs-built_in">length</span>()) {
                R.<span class="hljs-built_in">push_back</span>(w);
                w.<span class="hljs-built_in">clear</span>();
            }
        }
        w += *i;
    }

    <span class="hljs-keyword">if</span> (w.<span class="hljs-built_in">length</span>())
        R.<span class="hljs-built_in">push_back</span>(w);
    <span class="hljs-keyword">return</span> R;
}
</code></pre>

<p>For example, this splits "AQueryTrades" into "A", "Query" and "Trades".  The function works with narrow and wide strings. Because it respects the current locale it splits "RaumfahrtÜberwachungsVerordnung" into "Raumfahrt", "Überwachungs" and "Verordnung".</p>

<p>Note <code>std::upper</code> should be really passed as function template argument. Then the more generalized from of this function can split at delimiters like <code>","</code>, <code>";"</code> or <code>" "</code> too.</p>
    </div></div></div></div></div></div><div class="widget"><a href="/questions/get-selected-value-in-dropdown-list-using-javascript-1657387631638">Get selected value in dropdown list using JavaScript</a><a href="/questions/how-to-count-the-number-of-set-bits-in-a-32-bit-integer-1657388437370">How to count the number of set bits in a 32-bit integer?</a><a href="/questions/simulating-group_concat-mysql-function-in-microsoft-sql-server-2005-1657384832169">Simulating group_concat MySQL function in Microsoft SQL Server 2005?</a><a href="/questions/self-references-in-object-literals-initializers-1657384835356">Self-references in object literals / initializers</a><a href="/questions/how-to-sum-a-variable-by-group-1657384838148">How to sum a variable by group</a><a href="/questions/what-is-this-weird-colon-member-(%22-:-%22)-syntax-in-the-constructor-1657387264047">What is this weird colon-member (&quot; : &quot;) syntax in the constructor?</a><a href="/questions/captured-variable-in-a-loop-in-c-1657387696779">Captured variable in a loop in C#</a><a href="/questions/what-does-the-&#x27;static&#x27;-keyword-do-in-a-class-1657388554238">What does the &#x27;static&#x27; keyword do in a class?</a><a href="/questions/%22cross-origin-requests-are-only-supported-for-http.%22-error-when-loading-a-local-file-1657387942403">&quot;Cross origin requests are only supported for HTTP.&quot; error when loading a local file</a><a href="/questions/how-do-i-pass-data-between-activities-in-android-application-1657384739839">How do I pass data between Activities in Android application?</a><a href="/questions/what-is-the-canonical-way-to-check-for-errors-using-the-cuda-runtime-api-1657387302698">What is the canonical way to check for errors using the CUDA runtime API?</a><a href="/questions/query-based-on-multiple-where-clauses-in-firebase-1657387494547">Query based on multiple where clauses in Firebase</a><a href="/questions/get-the-row(s)-which-have-the-max-value-in-groups-using-groupby-1657388014787">Get the row(s) which have the max value in groups using groupby</a><a href="/questions/how-do-i-get-php-errors-to-display-1657384570095">How do I get PHP errors to display?</a><a href="/questions/read-file-line-by-line-using-ifstream-in-c++-1657388236966">Read file line by line using ifstream in C++</a><a href="/questions/how-do-i-properly-clean-up-excel-interop-objects-1657388329706">How do I properly clean up Excel interop objects?</a><a href="/questions/.prop()-vs-.attr()-1657384898328">.prop() vs .attr()</a><a href="/questions/how-do-i-give-text-or-an-image-a-transparent-background-using-css-1657388188508">How do I give text or an image a transparent background using CSS?</a><a href="/questions/grouping-functions-(tapply-by-aggregate)-and-the-*apply-family-1657387844286">Grouping functions (tapply, by, aggregate) and the *apply family</a><a href="/questions/how-can-i-group-an-array-of-objects-by-key-1657388065372">How can I group an array of objects by key?</a></div></div><span class="cursor-pointer text-lg p-2" style="position:fixed;bottom:20px;left:20px;background:#000;z-index:2000;color:white">Go go top</span></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"data":{"answer":["\n\u0026lt;p\u0026gt;I use this to split string by a delimiter. The first puts the results in a pre-constructed vector, the second returns a new vector.\u0026lt;/p\u0026gt;\n\n\n\n\u0026lt;pre class=\u0026quot;lang-c++ s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;string\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;sstream\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;vector\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;iterator\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\ntemplate \u0026amp;lt;typename Out\u0026amp;gt;\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;split\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;std\u0026lt;/span\u0026gt;::\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;string\u0026lt;/span\u0026gt; \u0026amp;amp;s, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; delim, Out result)\u0026lt;/span\u0026gt; {\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;std\u0026lt;/span\u0026gt;::\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;istringstream\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;iss\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(s)\u0026lt;/span\u0026gt;;\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;std\u0026lt;/span\u0026gt;::\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;string\u0026lt;/span\u0026gt; item;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;while\u0026lt;/span\u0026gt; (\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;std\u0026lt;/span\u0026gt;::getline(iss, item, delim)) {\n        *result++ = item;\n    }\n}\n\n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;std\u0026lt;/span\u0026gt;::\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;vector\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;std\u0026lt;/span\u0026gt;::\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;string\u0026lt;/span\u0026gt;\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;split\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;std\u0026lt;/span\u0026gt;::\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;string\u0026lt;/span\u0026gt; \u0026amp;amp;s, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; delim)\u0026lt;/span\u0026gt; {\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;std\u0026lt;/span\u0026gt;::\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;vector\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;std\u0026lt;/span\u0026gt;::\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;string\u0026lt;/span\u0026gt;\u0026amp;gt; elems;\n    split(s, delim, \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;std\u0026lt;/span\u0026gt;::back_inserter(elems));\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; elems;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;hr\u0026gt;\n\n\u0026lt;p\u0026gt;Note that this solution does not skip empty tokens, so the following will find 4 items, one of which is empty:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c++ s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;std\u0026lt;/span\u0026gt;::\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;vector\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;std\u0026lt;/span\u0026gt;::\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;string\u0026lt;/span\u0026gt;\u0026amp;gt; x = split(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;one:two::three\u0026quot;\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;:\u0026apos;\u0026lt;/span\u0026gt;);\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;For what it\u0026apos;s worth, here\u0026apos;s another way to extract tokens from an input string, relying only on standard library facilities. It\u0026apos;s an example of the power and elegance behind the design of the STL.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;iostream\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;string\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;sstream\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;algorithm\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;iterator\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;main\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt; \u0026lt;/span\u0026gt;{\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;using\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;namespace\u0026lt;/span\u0026gt; std;\n    string sentence = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;And I feel fine...\u0026quot;\u0026lt;/span\u0026gt;;\n    \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;istringstream \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;iss\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(sentence)\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;;\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;copy\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;istream_iterator\u0026lt;/span\u0026gt;\u0026amp;lt;string\u0026amp;gt;(iss),\n         \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;istream_iterator\u0026lt;/span\u0026gt;\u0026amp;lt;string\u0026amp;gt;(),\n         \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;ostream_iterator\u0026lt;/span\u0026gt;\u0026amp;lt;string\u0026amp;gt;(cout, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;\\n\u0026quot;\u0026lt;/span\u0026gt;));\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Instead of copying the extracted tokens to an output stream, one could insert them into a container, using the same generic \u0026lt;a href=\u0026quot;https://en.cppreference.com/w/cpp/algorithm/copy\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;\u0026lt;code\u0026gt;copy\u0026lt;/code\u0026gt;\u0026lt;/a\u0026gt; algorithm.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;vector\u0026amp;lt;string\u0026amp;gt; tokens;\n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;copy\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;istream_iterator\u0026lt;/span\u0026gt;\u0026amp;lt;string\u0026amp;gt;(iss),\n     \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;istream_iterator\u0026lt;/span\u0026gt;\u0026amp;lt;string\u0026amp;gt;(),\n     \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;back_inserter\u0026lt;/span\u0026gt;(tokens));\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;... or create the \u0026lt;code\u0026gt;vector\u0026lt;/code\u0026gt; directly:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;vector\u0026amp;lt;string\u0026amp;gt; tokens{istream_iterator\u0026amp;lt;string\u0026amp;gt;{iss},\n                      istream_iterator\u0026amp;lt;string\u0026amp;gt;{}};\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;A possible solution using Boost might be:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;boost/algorithm/string.hpp\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\nstd::vector\u0026amp;lt;std::string\u0026amp;gt; strs;\nboost::\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;split\u0026lt;/span\u0026gt;(strs, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;string to split\u0026quot;\u0026lt;/span\u0026gt;, boost::\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;is_any_of\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;\\t \u0026quot;\u0026lt;/span\u0026gt;));\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;This approach might be even faster than the \u0026lt;code\u0026gt;stringstream\u0026lt;/code\u0026gt; approach. And since this is a generic template function it can be used to split other types of strings (wchar, etc. or UTF-8) using all kinds of delimiters.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;See the \u0026lt;a href=\u0026quot;http://www.boost.org/doc/libs/1_36_0/doc/html/string_algo/usage.html\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;documentation\u0026lt;/a\u0026gt; for details.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;vector\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;string\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;sstream\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;main\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt;\n\u0026lt;/span\u0026gt;{\n    \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;std::string \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;str\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Split me by whitespaces\u0026quot;\u0026lt;/span\u0026gt;)\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;;\n    std::string buf;                 \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Have a buffer string\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;std::stringstream \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;ss\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(str)\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;;       \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Insert the string into a stream\u0026lt;/span\u0026gt;\n\n    std::vector\u0026amp;lt;std::string\u0026amp;gt; tokens; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Create vector to hold our words\u0026lt;/span\u0026gt;\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;while\u0026lt;/span\u0026gt; (ss \u0026amp;gt;\u0026amp;gt; buf)\n        tokens.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;push_back\u0026lt;/span\u0026gt;(buf);\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;For those with whom it does not sit well to sacrifice all efficiency for code size and see \u0026quot;efficient\u0026quot; as a type of elegance, the following should hit a sweet spot (and I think the template container class is an awesomely elegant addition.):\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt; \u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;ContainerT\u0026lt;/span\u0026gt; \u0026amp;gt;\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;tokenize\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; std::string\u0026amp;amp; str, ContainerT\u0026amp;amp; tokens,\n              \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; std::string\u0026amp;amp; delimiters = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot; \u0026quot;\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;bool\u0026lt;/span\u0026gt; trimEmpty = \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;false\u0026lt;/span\u0026gt;)\u0026lt;/span\u0026gt;\n\u0026lt;/span\u0026gt;{\n   std::string::size_type pos, lastPos = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;, length = str.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;length\u0026lt;/span\u0026gt;();\n\n   \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;using\u0026lt;/span\u0026gt; value_type = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; ContainerT::value_type;\n   \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;using\u0026lt;/span\u0026gt; size_type  = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; ContainerT::size_type;\n\n   \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;while\u0026lt;/span\u0026gt;(lastPos \u0026amp;lt; length + \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;)\n   {\n      pos = str.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;find_first_of\u0026lt;/span\u0026gt;(delimiters, lastPos);\n      \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt;(pos == std::string::npos)\n      {\n         pos = length;\n      }\n\n      \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt;(pos != lastPos || !trimEmpty)\n         tokens.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;push_back\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;value_type\u0026lt;/span\u0026gt;(str.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;data\u0026lt;/span\u0026gt;()+lastPos,\n               (size_type)pos-lastPos ));\n\n      lastPos = pos + \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;;\n   }\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;I usually choose to use \u0026lt;code\u0026gt;std::vector\u0026amp;lt;std::string\u0026amp;gt;\u0026lt;/code\u0026gt; types as my second parameter (\u0026lt;code\u0026gt;ContainerT\u0026lt;/code\u0026gt;)... but \u0026lt;code\u0026gt;list\u0026amp;lt;\u0026amp;gt;\u0026lt;/code\u0026gt; is way faster than \u0026lt;code\u0026gt;vector\u0026amp;lt;\u0026amp;gt;\u0026lt;/code\u0026gt; for when direct access is not needed, and you can even create your own string class and use something like \u0026lt;code\u0026gt;std::list\u0026amp;lt;subString\u0026amp;gt;\u0026lt;/code\u0026gt; where \u0026lt;code\u0026gt;subString\u0026lt;/code\u0026gt; does not do any copies for incredible speed increases.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;It\u0026apos;s more than double as fast as the fastest tokenize on this page and almost 5 times faster than some others. Also with the perfect parameter types you can eliminate all string and list copies for additional speed increases.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Additionally it does not do the (extremely inefficient) return of result, but rather it passes the tokens as a reference, thus also allowing you to build up tokens using multiple calls if you so wished.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Lastly it allows you to specify whether to trim empty tokens from the results via a last optional parameter.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;All it needs is \u0026lt;code\u0026gt;std::string\u0026lt;/code\u0026gt;... the rest are optional. It does not use streams or the boost library, but is flexible enough to be able to accept some of these foreign types naturally.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Here\u0026apos;s another solution. It\u0026apos;s compact and reasonably efficient:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;std::vector\u0026amp;lt;std::string\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;split\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; std::string \u0026amp;amp;text, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; sep)\u0026lt;/span\u0026gt; \u0026lt;/span\u0026gt;{\n  std::vector\u0026amp;lt;std::string\u0026amp;gt; tokens;\n  std::\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;size_t\u0026lt;/span\u0026gt; start = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;, end = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;;\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;while\u0026lt;/span\u0026gt; ((end = text.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;find\u0026lt;/span\u0026gt;(sep, start)) != std::string::npos) {\n    tokens.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;push_back\u0026lt;/span\u0026gt;(text.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;substr\u0026lt;/span\u0026gt;(start, end - start));\n    start = end + \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;;\n  }\n  tokens.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;push_back\u0026lt;/span\u0026gt;(text.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;substr\u0026lt;/span\u0026gt;(start));\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; tokens;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;It can easily be templatised to handle string separators, wide strings, etc.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Note that splitting \u0026lt;code\u0026gt;\u0026quot;\u0026quot;\u0026lt;/code\u0026gt; results in a single empty string and splitting \u0026lt;code\u0026gt;\u0026quot;,\u0026quot;\u0026lt;/code\u0026gt; (ie. sep) results in two empty strings.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;It can also be easily expanded to skip empty tokens:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;std::vector\u0026amp;lt;std::string\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;split\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; std::string \u0026amp;amp;text, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; sep)\u0026lt;/span\u0026gt; \u0026lt;/span\u0026gt;{\n    std::vector\u0026amp;lt;std::string\u0026amp;gt; tokens;\n    std::\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;size_t\u0026lt;/span\u0026gt; start = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;, end = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;while\u0026lt;/span\u0026gt; ((end = text.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;find\u0026lt;/span\u0026gt;(sep, start)) != std::string::npos) {\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (end != start) {\n          tokens.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;push_back\u0026lt;/span\u0026gt;(text.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;substr\u0026lt;/span\u0026gt;(start, end - start));\n        }\n        start = end + \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;;\n    }\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (end != start) {\n       tokens.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;push_back\u0026lt;/span\u0026gt;(text.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;substr\u0026lt;/span\u0026gt;(start));\n    }\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; tokens;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;hr\u0026gt;\n\n\u0026lt;p\u0026gt;If splitting a string at multiple delimiters while skipping empty tokens is desired, this version may be used:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;std::vector\u0026amp;lt;std::string\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;split\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; std::string\u0026amp;amp; text, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; std::string\u0026amp;amp; delims)\u0026lt;/span\u0026gt;\n\u0026lt;/span\u0026gt;{\n    std::vector\u0026amp;lt;std::string\u0026amp;gt; tokens;\n    std::\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;size_t\u0026lt;/span\u0026gt; start = text.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;find_first_not_of\u0026lt;/span\u0026gt;(delims), end = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;;\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;while\u0026lt;/span\u0026gt;((end = text.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;find_first_of\u0026lt;/span\u0026gt;(delims, start)) != std::string::npos)\n    {\n        tokens.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;push_back\u0026lt;/span\u0026gt;(text.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;substr\u0026lt;/span\u0026gt;(start, end - start));\n        start = text.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;find_first_not_of\u0026lt;/span\u0026gt;(delims, end);\n    }\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt;(start != std::string::npos)\n        tokens.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;push_back\u0026lt;/span\u0026gt;(text.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;substr\u0026lt;/span\u0026gt;(start));\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; tokens;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;This is my favorite way to iterate through a string. You can do whatever you want per word.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;string line = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;a line of text to iterate through\u0026quot;\u0026lt;/span\u0026gt;;\nstring word;\n\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;istringstream \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;iss\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(line, istringstream::in)\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;;\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;while\u0026lt;/span\u0026gt;( iss \u0026amp;gt;\u0026amp;gt; word )     \n{\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Do something on `word` here...\u0026lt;/span\u0026gt;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;This is similar to Stack\u0026amp;nbsp;Overflow question \u0026lt;em\u0026gt;\u0026lt;a href=\u0026quot;https://stackoverflow.com/questions/53849/how-do-i-tokenize-a-string-in-c\u0026quot;\u0026gt;How do I tokenize a string in C++?\u0026lt;/a\u0026gt;\u0026lt;/em\u0026gt;. \u0026lt;strong\u0026gt;Requires Boost external library\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;iostream\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;string\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;boost/tokenizer.hpp\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;using\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;namespace\u0026lt;/span\u0026gt; std;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;using\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;namespace\u0026lt;/span\u0026gt; boost;\n\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;main\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; argc, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt;** argv)\u0026lt;/span\u0026gt;\n\u0026lt;/span\u0026gt;{\n    string text = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;token  test\\tstring\u0026quot;\u0026lt;/span\u0026gt;;\n\n    \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;char_separator\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt;\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;sep\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot; \\t\u0026quot;\u0026lt;/span\u0026gt;)\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;;\n    tokenizer\u0026amp;lt;char_separator\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;tokens\u0026lt;/span\u0026gt;(text, sep);\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt; (\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; string\u0026amp;amp; t : tokens)\n    {\n        cout \u0026amp;lt;\u0026amp;lt; t \u0026amp;lt;\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;.\u0026quot;\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026amp;lt; endl;\n    }\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;I like the following because it puts the results into a vector, supports a string as a delim and gives control over keeping empty values. But, it doesn\u0026apos;t look as good then.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;ostream\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;string\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;vector\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;algorithm\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;iterator\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;using\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;namespace\u0026lt;/span\u0026gt; std;\n\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;vector\u0026amp;lt;string\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;split\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; string\u0026amp;amp; s, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; string\u0026amp;amp; delim, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;bool\u0026lt;/span\u0026gt; keep_empty = \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;true\u0026lt;/span\u0026gt;)\u0026lt;/span\u0026gt; \u0026lt;/span\u0026gt;{\n    vector\u0026amp;lt;string\u0026amp;gt; result;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (delim.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;empty\u0026lt;/span\u0026gt;()) {\n        result.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;push_back\u0026lt;/span\u0026gt;(s);\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; result;\n    }\n    string::const_iterator substart = s.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;begin\u0026lt;/span\u0026gt;(), subend;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;while\u0026lt;/span\u0026gt; (\u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;true\u0026lt;/span\u0026gt;) {\n        subend = \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;search\u0026lt;/span\u0026gt;(substart, s.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;end\u0026lt;/span\u0026gt;(), delim.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;begin\u0026lt;/span\u0026gt;(), delim.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;end\u0026lt;/span\u0026gt;());\n        \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;string \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;temp\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(substart, subend)\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;;\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (keep_empty || !temp.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;empty\u0026lt;/span\u0026gt;()) {\n            result.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;push_back\u0026lt;/span\u0026gt;(temp);\n        }\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (subend == s.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;end\u0026lt;/span\u0026gt;()) {\n            \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;break\u0026lt;/span\u0026gt;;\n        }\n        substart = subend + delim.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;size\u0026lt;/span\u0026gt;();\n    }\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; result;\n}\n\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;main\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt; \u0026lt;/span\u0026gt;{\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; vector\u0026amp;lt;string\u0026amp;gt; words = \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;split\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;So close no matter how far\u0026quot;\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot; \u0026quot;\u0026lt;/span\u0026gt;);\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;copy\u0026lt;/span\u0026gt;(words.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;begin\u0026lt;/span\u0026gt;(), words.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;end\u0026lt;/span\u0026gt;(), \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;ostream_iterator\u0026lt;/span\u0026gt;\u0026amp;lt;string\u0026amp;gt;(cout, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;\\n\u0026quot;\u0026lt;/span\u0026gt;));\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Of course, Boost has a \u0026lt;a href=\u0026quot;http://www.boost.org/doc/libs/1_36_0/doc/html/string_algo/usage.html#id3483755\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;\u0026lt;code\u0026gt;split()\u0026lt;/code\u0026gt;\u0026lt;/a\u0026gt; that works partially like that. And, if by \u0026apos;white-space\u0026apos;, you really do mean any type of white-space, using Boost\u0026apos;s split with \u0026lt;code\u0026gt;is_any_of()\u0026lt;/code\u0026gt; works great.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;The STL does not have such a method available already.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;However, you can either use C\u0026apos;s \u0026lt;a href=\u0026quot;http://en.cppreference.com/w/c/string/byte/strtok\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;\u0026lt;code\u0026gt;strtok()\u0026lt;/code\u0026gt;\u0026lt;/a\u0026gt; function by using the \u0026lt;a href=\u0026quot;http://en.cppreference.com/w/cpp/string/basic_string/c_str\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;\u0026lt;code\u0026gt;std::string::c_str()\u0026lt;/code\u0026gt;\u0026lt;/a\u0026gt; member, or you can write your own. Here is a code sample I found after a quick Google search (\u0026lt;strong\u0026gt;\u0026quot;STL string split\u0026quot;\u0026lt;/strong\u0026gt;):\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;Tokenize\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; string\u0026amp;amp; str,\n              vector\u0026amp;lt;string\u0026amp;gt;\u0026amp;amp; tokens,\n              \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; string\u0026amp;amp; delimiters = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot; \u0026quot;\u0026lt;/span\u0026gt;)\u0026lt;/span\u0026gt;\n\u0026lt;/span\u0026gt;{\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Skip delimiters at beginning.\u0026lt;/span\u0026gt;\n    string::size_type lastPos = str.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;find_first_not_of\u0026lt;/span\u0026gt;(delimiters, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;);\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Find first \u0026quot;non-delimiter\u0026quot;.\u0026lt;/span\u0026gt;\n    string::size_type pos     = str.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;find_first_of\u0026lt;/span\u0026gt;(delimiters, lastPos);\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;while\u0026lt;/span\u0026gt; (string::npos != pos || string::npos != lastPos)\n    {\n        \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Found a token, add it to the vector.\u0026lt;/span\u0026gt;\n        tokens.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;push_back\u0026lt;/span\u0026gt;(str.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;substr\u0026lt;/span\u0026gt;(lastPos, pos - lastPos));\n        \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Skip delimiters.  Note the \u0026quot;not_of\u0026quot;\u0026lt;/span\u0026gt;\n        lastPos = str.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;find_first_not_of\u0026lt;/span\u0026gt;(delimiters, pos);\n        \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Find next \u0026quot;non-delimiter\u0026quot;\u0026lt;/span\u0026gt;\n        pos = str.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;find_first_of\u0026lt;/span\u0026gt;(delimiters, lastPos);\n    }\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Taken from: \u0026lt;a href=\u0026quot;http://oopweb.com/CPP/Documents/CPPHOWTO/Volume/C++Programming-HOWTO-7.html\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;http://oopweb.com/CPP/Documents/CPPHOWTO/Volume/C++Programming-HOWTO-7.html\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;If you have questions about the code sample, leave a comment and I will explain.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;And just because it does not implement a \u0026lt;code\u0026gt;typedef\u0026lt;/code\u0026gt; called iterator or overload the \u0026lt;code\u0026gt;\u0026amp;lt;\u0026amp;lt;\u0026lt;/code\u0026gt; operator does not mean it is bad code. I use C functions quite frequently. For example, \u0026lt;a href=\u0026quot;http://en.cppreference.com/w/c/io/fprintf\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;\u0026lt;code\u0026gt;printf\u0026lt;/code\u0026gt;\u0026lt;/a\u0026gt; and \u0026lt;a href=\u0026quot;http://en.cppreference.com/w/c/io/fscanf\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;\u0026lt;code\u0026gt;scanf\u0026lt;/code\u0026gt;\u0026lt;/a\u0026gt; both are faster than \u0026lt;a href=\u0026quot;http://en.cppreference.com/w/cpp/io/cin\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;\u0026lt;code\u0026gt;std::cin\u0026lt;/code\u0026gt;\u0026lt;/a\u0026gt; and \u0026lt;a href=\u0026quot;http://en.cppreference.com/w/cpp/io/cout\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;\u0026lt;code\u0026gt;std::cout\u0026lt;/code\u0026gt;\u0026lt;/a\u0026gt; (significantly), the \u0026lt;a href=\u0026quot;http://en.cppreference.com/w/c/io/fopen\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;\u0026lt;code\u0026gt;fopen\u0026lt;/code\u0026gt;\u0026lt;/a\u0026gt; syntax is a lot more friendly for binary types, and they also tend to produce smaller EXEs.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Don\u0026apos;t get sold on this \u0026lt;strong\u0026gt;\u0026quot;Elegance over performance\u0026quot;\u0026lt;/strong\u0026gt; deal.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Here is a split function that:\u0026lt;/p\u0026gt;\n\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;is generic\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;uses standard C++ (no boost)\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;accepts multiple delimiters\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;ignores empty tokens (can easily be changed)\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; T\u0026amp;gt;\nvector\u0026amp;lt;T\u0026amp;gt; \n\u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;split\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; T \u0026amp;amp; str, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; T \u0026amp;amp; delimiters)\u0026lt;/span\u0026gt; \u0026lt;/span\u0026gt;{\n    vector\u0026amp;lt;T\u0026amp;gt; v;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; T::size_type start = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;auto\u0026lt;/span\u0026gt; pos = str.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;find_first_of\u0026lt;/span\u0026gt;(delimiters, start);\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;while\u0026lt;/span\u0026gt;(pos != T::npos) {\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt;(pos != start) \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// ignore empty tokens\u0026lt;/span\u0026gt;\n            v.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;emplace_back\u0026lt;/span\u0026gt;(str, start, pos - start);\n        start = pos + \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;;\n        pos = str.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;find_first_of\u0026lt;/span\u0026gt;(delimiters, start);\n    }\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt;(start \u0026amp;lt; str.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;length\u0026lt;/span\u0026gt;()) \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// ignore trailing delimiter\u0026lt;/span\u0026gt;\n        v.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;emplace_back\u0026lt;/span\u0026gt;(str, start, str.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;length\u0026lt;/span\u0026gt;() - start); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// add what\u0026apos;s left of the string\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; v;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\n\u0026lt;p\u0026gt;Example usage:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;    vector\u0026amp;lt;string\u0026amp;gt; v = \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;split\u0026lt;/span\u0026gt;\u0026amp;lt;string\u0026amp;gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Hello, there; World\u0026quot;\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;;,\u0026quot;\u0026lt;/span\u0026gt;);\n    vector\u0026amp;lt;wstring\u0026amp;gt; v = \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;split\u0026lt;/span\u0026gt;\u0026amp;lt;wstring\u0026amp;gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;L\u0026quot;Hello, there; World\u0026quot;\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;L\u0026quot;;,\u0026quot;\u0026lt;/span\u0026gt;);\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;I have a 2 lines solution to this problem:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; sep = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos; \u0026apos;\u0026lt;/span\u0026gt;;\nstd::string s=\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;1 This is an example\u0026quot;\u0026lt;/span\u0026gt;;\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;size_t\u0026lt;/span\u0026gt; p=\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;, q=\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;; p!=s.npos; p=q)\n  std::cout \u0026amp;lt;\u0026amp;lt; s.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;substr\u0026lt;/span\u0026gt;(p+(p!=\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;), (q=s.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;find\u0026lt;/span\u0026gt;(sep, p+\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;))-p-(p!=\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;)) \u0026amp;lt;\u0026amp;lt; std::endl;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Then instead of printing you can put it in a vector.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Yet another flexible and fast way\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; Operator\u0026amp;gt;\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;tokenize\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(Operator\u0026amp;amp; op, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt;* input, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt;* delimiters)\u0026lt;/span\u0026gt; \u0026lt;/span\u0026gt;{\n  \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt;* s = input;\n  \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt;* e = s;\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;while\u0026lt;/span\u0026gt; (*e != \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;) {\n    e = s;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;while\u0026lt;/span\u0026gt; (*e != \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt; \u0026amp;amp;\u0026amp;amp; \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;strchr\u0026lt;/span\u0026gt;(delimiters, *e) == \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;) ++e;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (e - s \u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;) {\n      \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;op\u0026lt;/span\u0026gt;(s, e - s);\n    }\n    s = e + \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;;\n  }\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;To use it with a vector of strings (Edit: Since someone pointed out not to inherit STL classes... hrmf ;) ) :\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;ContainerType\u0026lt;/span\u0026gt;\u0026amp;gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Appender\u0026lt;/span\u0026gt; {\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt;:\n  \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;Appender\u0026lt;/span\u0026gt;(ContainerType\u0026amp;amp; container) : \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;container_\u0026lt;/span\u0026gt;(container) {;}\n  \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;operator\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt;* s, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;unsigned\u0026lt;/span\u0026gt; length)\u0026lt;/span\u0026gt; \u0026lt;/span\u0026gt;{ \n    container_.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;push_back\u0026lt;/span\u0026gt;(std::\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;string\u0026lt;/span\u0026gt;(s,length));\n  }\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;private\u0026lt;/span\u0026gt;:\n  ContainerType\u0026amp;amp; container_;\n};\n\nstd::vector\u0026amp;lt;std::string\u0026amp;gt; strVector;\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;Appender \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;v\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(strVector)\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;;\n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;tokenize\u0026lt;/span\u0026gt;(v, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;A number of words to be tokenized\u0026quot;\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot; \\t\u0026quot;\u0026lt;/span\u0026gt;);\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;That\u0026apos;s it! And that\u0026apos;s just one way to use the tokenizer, like how to just \ncount words:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;WordCounter\u0026lt;/span\u0026gt; {\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt;:\n  \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;WordCounter\u0026lt;/span\u0026gt;() : \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;noOfWords\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;) {}\n  \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;operator\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt;*, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;unsigned\u0026lt;/span\u0026gt;)\u0026lt;/span\u0026gt; \u0026lt;/span\u0026gt;{\n    ++noOfWords;\n  }\n  \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;unsigned\u0026lt;/span\u0026gt; noOfWords;\n};\n\nWordCounter wc;\n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;tokenize\u0026lt;/span\u0026gt;(wc, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;A number of words to be counted\u0026quot;\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot; \\t\u0026quot;\u0026lt;/span\u0026gt;); \n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;ASSERT\u0026lt;/span\u0026gt;( wc.noOfWords == \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;7\u0026lt;/span\u0026gt; );\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Limited by imagination ;)\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Here\u0026apos;s a simple solution that uses only the standard regex library\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;regex\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;string\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;vector\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;std::vector\u0026amp;lt;string\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;Tokenize\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;( \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; string str, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; std::regex regex )\u0026lt;/span\u0026gt;\n\u0026lt;/span\u0026gt;{\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;using\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;namespace\u0026lt;/span\u0026gt; std;\n\n    std::vector\u0026amp;lt;string\u0026amp;gt; result;\n\n    \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;sregex_token_iterator \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;it\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;( str.begin(), str.end(), regex, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;-1\u0026lt;/span\u0026gt; )\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;;\n    sregex_token_iterator reg_end;\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt; ( ; it != reg_end; ++it ) {\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; ( !it-\u0026amp;gt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;str\u0026lt;/span\u0026gt;().\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;empty\u0026lt;/span\u0026gt;() ) \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//token could be empty:check\u0026lt;/span\u0026gt;\n            result.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;emplace_back\u0026lt;/span\u0026gt;( it-\u0026amp;gt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;str\u0026lt;/span\u0026gt;() );\n    }\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; result;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;The regex argument allows checking for multiple arguments (spaces, commas, etc.)\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;I usually only check to split on spaces and commas, so I also have this default function:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;std::vector\u0026amp;lt;string\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;TokenizeDefault\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;( \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; string str )\u0026lt;/span\u0026gt;\n\u0026lt;/span\u0026gt;{\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;using\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;namespace\u0026lt;/span\u0026gt; std;\n\n    \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;regex \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;re\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;( \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;[\\\\s,]+\u0026quot;\u0026lt;/span\u0026gt; )\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;;\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;Tokenize\u0026lt;/span\u0026gt;( str, re );\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;The \u0026lt;code\u0026gt;\u0026quot;[\\\\s,]+\u0026quot;\u0026lt;/code\u0026gt; checks for spaces (\u0026lt;code\u0026gt;\\\\s\u0026lt;/code\u0026gt;) and commas (\u0026lt;code\u0026gt;,\u0026lt;/code\u0026gt;).\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Note, if you want to split \u0026lt;code\u0026gt;wstring\u0026lt;/code\u0026gt; instead of \u0026lt;code\u0026gt;string\u0026lt;/code\u0026gt;,\u0026lt;/p\u0026gt;\n\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;change all \u0026lt;code\u0026gt;std::regex\u0026lt;/code\u0026gt; to \u0026lt;code\u0026gt;std::wregex\u0026lt;/code\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;change all \u0026lt;code\u0026gt;sregex_token_iterator\u0026lt;/code\u0026gt; to \u0026lt;code\u0026gt;wsregex_token_iterator\u0026lt;/code\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\n\u0026lt;p\u0026gt;Note, you might also want to take the string argument by reference, depending on your compiler.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Using \u0026lt;code\u0026gt;std::stringstream\u0026lt;/code\u0026gt; as you have works perfectly fine, and do exactly what you wanted. If you\u0026apos;re just looking for different way of doing things though, you can use \u0026lt;a href=\u0026quot;http://en.cppreference.com/w/cpp/algorithm/find\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;\u0026lt;code\u0026gt;std::find()\u0026lt;/code\u0026gt;\u0026lt;/a\u0026gt;/\u0026lt;a href=\u0026quot;http://en.cppreference.com/w/cpp/algorithm/find_first_of\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;\u0026lt;code\u0026gt;std::find_first_of()\u0026lt;/code\u0026gt;\u0026lt;/a\u0026gt; and \u0026lt;a href=\u0026quot;http://en.cppreference.com/w/cpp/string/basic_string/substr\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;\u0026lt;code\u0026gt;std::string::substr()\u0026lt;/code\u0026gt;\u0026lt;/a\u0026gt;.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Here\u0026apos;s an example:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;iostream\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;string\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;main\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt;\n\u0026lt;/span\u0026gt;{\n    \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;std::string \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;s\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Somewhere down the road\u0026quot;\u0026lt;/span\u0026gt;)\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;;\n    std::string::size_type prev_pos = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;, pos = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;;\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;while\u0026lt;/span\u0026gt;( (pos = s.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;find\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos; \u0026apos;\u0026lt;/span\u0026gt;, pos)) != std::string::npos )\n    {\n        \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;std::string \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;substring\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;( s.substr(prev_pos, pos-prev_pos) )\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;;\n\n        std::cout \u0026amp;lt;\u0026amp;lt; substring \u0026amp;lt;\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;\\n\u0026apos;\u0026lt;/span\u0026gt;;\n\n        prev_pos = ++pos;\n    }\n\n    \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;std::string \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;substring\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;( s.substr(prev_pos, pos-prev_pos) )\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Last word\u0026lt;/span\u0026gt;\n    std::cout \u0026amp;lt;\u0026amp;lt; substring \u0026amp;lt;\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;\\n\u0026apos;\u0026lt;/span\u0026gt;;\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;If you like to use boost, but want to use a whole string as delimiter (instead of single characters as in most of the previously proposed solutions), you can use the \u0026lt;code\u0026gt;boost_split_iterator\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Example code including convenient template:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;iostream\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;vector\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;boost/algorithm/string.hpp\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; _OutputIterator\u0026amp;gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;inline\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;split\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; std::string\u0026amp;amp; str, \n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; std::string\u0026amp;amp; delim, \n    _OutputIterator result)\u0026lt;/span\u0026gt;\n\u0026lt;/span\u0026gt;{\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;using\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;namespace\u0026lt;/span\u0026gt; boost::algorithm;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typedef\u0026lt;/span\u0026gt; split_iterator\u0026amp;lt;std::string::const_iterator\u0026amp;gt; It;\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt;(It iter=\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;make_split_iterator\u0026lt;/span\u0026gt;(str, \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;first_finder\u0026lt;/span\u0026gt;(delim, \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;is_equal\u0026lt;/span\u0026gt;()));\n            iter!=\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;It\u0026lt;/span\u0026gt;();\n            ++iter)\n    {\n        *(result++) = boost::\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;copy_range\u0026lt;/span\u0026gt;\u0026amp;lt;std::string\u0026amp;gt;(*iter);\n    }\n}\n\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;main\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; argc, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt;* argv[])\u0026lt;/span\u0026gt;\n\u0026lt;/span\u0026gt;{\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;using\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;namespace\u0026lt;/span\u0026gt; std;\n\n    vector\u0026amp;lt;string\u0026amp;gt; splitted;\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;split\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;HelloFOOworldFOO!\u0026quot;\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;FOO\u0026quot;\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;back_inserter\u0026lt;/span\u0026gt;(splitted));\n\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// or directly to console, for example\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;split\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;HelloFOOworldFOO!\u0026quot;\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;FOO\u0026quot;\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;ostream_iterator\u0026lt;/span\u0026gt;\u0026amp;lt;string\u0026amp;gt;(cout, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;\\n\u0026quot;\u0026lt;/span\u0026gt;));\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Heres a regex solution that only uses the standard regex library.  (I\u0026apos;m a little rusty, so there may be a few syntax errors, but this is at least the general idea)\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;regex.h\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;string.h\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;vector.h\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;using\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;namespace\u0026lt;/span\u0026gt; std;\n\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;vector\u0026amp;lt;string\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;split\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(string s)\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;{\n    \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;regex \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;r\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;\\\\w+\u0026quot;\u0026lt;/span\u0026gt;)\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//regex matches whole words, (greedy, so no fragment words)\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;regex_iterator\u0026amp;lt;string::iterator\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;rit\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;( s.begin(), s.end(), r )\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;;\n    regex_iterator\u0026amp;lt;string::iterator\u0026amp;gt; rend; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//iterators to iterate thru words\u0026lt;/span\u0026gt;\n    vector\u0026amp;lt;string\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;result\u0026lt;/span\u0026gt;\u0026amp;lt;regex_iterator\u0026amp;gt;(rit, rend);\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; result;  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//iterates through the matches to fill the vector\u0026lt;/span\u0026gt;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;There is a function named \u0026lt;a href=\u0026quot;http://www.cplusplus.com/reference/clibrary/cstring/strtok/\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;\u0026lt;code\u0026gt;strtok\u0026lt;/code\u0026gt;\u0026lt;/a\u0026gt;.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;string\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;using\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;namespace\u0026lt;/span\u0026gt; std;\n\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;vector\u0026amp;lt;string\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;split\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt;* str,\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt;* delim)\u0026lt;/span\u0026gt;\n\u0026lt;/span\u0026gt;{\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt;* saveptr;\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt;* token = \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;strtok_r\u0026lt;/span\u0026gt;(str,delim,\u0026amp;amp;saveptr);\n\n    vector\u0026amp;lt;string\u0026amp;gt; result;\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;while\u0026lt;/span\u0026gt;(token != \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;NULL\u0026lt;/span\u0026gt;)\n    {\n        result.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;push_back\u0026lt;/span\u0026gt;(token);\n        token = \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;strtok_r\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;NULL\u0026lt;/span\u0026gt;,delim,\u0026amp;amp;saveptr);\n    }\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; result;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;The \u0026lt;a href=\u0026quot;http://www.cplusplus.com/reference/sstream/stringstream/\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;stringstream\u0026lt;/a\u0026gt; can be convenient if you need to parse the string by non-space symbols:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;string s = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Name:JAck; Spouse:Susan; ...\u0026quot;\u0026lt;/span\u0026gt;;\nstring dummy, name, spouse;\n\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;istringstream \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;iss\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(s)\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;;\n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;getline\u0026lt;/span\u0026gt;(iss, dummy, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;:\u0026apos;\u0026lt;/span\u0026gt;);\n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;getline\u0026lt;/span\u0026gt;(iss, name, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;;\u0026apos;\u0026lt;/span\u0026gt;);\n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;getline\u0026lt;/span\u0026gt;(iss, dummy, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;:\u0026apos;\u0026lt;/span\u0026gt;);\n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;getline\u0026lt;/span\u0026gt;(iss, spouse, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;;\u0026apos;\u0026lt;/span\u0026gt;)\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Using \u0026lt;code\u0026gt;std::string_view\u0026lt;/code\u0026gt; and Eric Niebler\u0026apos;s \u0026lt;code\u0026gt;range-v3\u0026lt;/code\u0026gt; library:\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;a href=\u0026quot;https://wandbox.org/permlink/kW5lwRCL1pxjp2pW\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;https://wandbox.org/permlink/kW5lwRCL1pxjp2pW\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;iostream\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;string\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;string_view\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;range/v3/view.hpp\u0026quot;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;range/v3/algorithm.hpp\u0026quot;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;main\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt; \u0026lt;/span\u0026gt;{\n    std::string s = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Somewhere down the range v3 library\u0026quot;\u0026lt;/span\u0026gt;;\n    ranges::for_each(s  \n        |   ranges::view::\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;split\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos; \u0026apos;\u0026lt;/span\u0026gt;)\n        |   ranges::view::\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;transform\u0026lt;/span\u0026gt;([](\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;auto\u0026lt;/span\u0026gt; \u0026amp;amp;\u0026amp;amp;sub) {\n                \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; std::\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;string_view\u0026lt;/span\u0026gt;(\u0026amp;amp;*sub.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;begin\u0026lt;/span\u0026gt;(), ranges::\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;distance\u0026lt;/span\u0026gt;(sub));\n            }),\n        [](\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;auto\u0026lt;/span\u0026gt; s) {std::cout \u0026amp;lt;\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Substring: \u0026quot;\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026amp;lt; s \u0026amp;lt;\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;\\n\u0026quot;\u0026lt;/span\u0026gt;;}\n    );\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;By using a range \u0026lt;code\u0026gt;for\u0026lt;/code\u0026gt; loop instead of \u0026lt;code\u0026gt;ranges::for_each\u0026lt;/code\u0026gt; algorithm:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;iostream\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;string\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;string_view\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;range/v3/view.hpp\u0026quot;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;main\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt;\n\u0026lt;/span\u0026gt;{\n    std::string str = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Somewhere down the range v3 library\u0026quot;\u0026lt;/span\u0026gt;;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt; (\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;auto\u0026lt;/span\u0026gt; s : str | ranges::view::\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;split\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos; \u0026apos;\u0026lt;/span\u0026gt;)\n                      | ranges::view::\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;transform\u0026lt;/span\u0026gt;([](\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;auto\u0026lt;/span\u0026gt;\u0026amp;amp;\u0026amp;amp; sub) { \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; std::\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;string_view\u0026lt;/span\u0026gt;(\u0026amp;amp;*sub.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;begin\u0026lt;/span\u0026gt;(), ranges::\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;distance\u0026lt;/span\u0026gt;(sub)); }\n                      ))\n    {\n        std::cout \u0026amp;lt;\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Substring: \u0026quot;\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026amp;lt; s \u0026amp;lt;\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;\\n\u0026quot;\u0026lt;/span\u0026gt;;\n    }\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;C++20 finally blesses us with a \u0026lt;code\u0026gt;split\u0026lt;/code\u0026gt; function. Or rather, a range adapter. \u0026lt;a href=\u0026quot;https://godbolt.org/z/6mZ8hG\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;Godbolt link\u0026lt;/a\u0026gt;.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;iostream\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;ranges\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;string_view\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;namespace\u0026lt;/span\u0026gt; ranges = std::ranges;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;namespace\u0026lt;/span\u0026gt; views = std::views;\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;using\u0026lt;/span\u0026gt; str = std::string_view;\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;constexpr\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;auto\u0026lt;/span\u0026gt; view =\n    \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Multiple words\u0026quot;\u0026lt;/span\u0026gt;\n    | views::\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;split\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos; \u0026apos;\u0026lt;/span\u0026gt;)\n    | views::\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;transform\u0026lt;/span\u0026gt;([](\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;auto\u0026lt;/span\u0026gt; \u0026amp;amp;\u0026amp;amp;r) -\u0026amp;gt; str {\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; {\n            \u0026amp;amp;*r.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;begin\u0026lt;/span\u0026gt;(),\n            \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;static_cast\u0026lt;/span\u0026gt;\u0026amp;lt;str::size_type\u0026amp;gt;(ranges::\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;distance\u0026lt;/span\u0026gt;(r))\n        };\n    });\n\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;auto\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;main\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt; -\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;/span\u0026gt;{\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt; (str \u0026amp;amp;\u0026amp;amp;sv : view) {\n        std::cout \u0026amp;lt;\u0026amp;lt; sv \u0026amp;lt;\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;\\n\u0026apos;\u0026lt;/span\u0026gt;;\n    }\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;So far I used the one in \u0026lt;a href=\u0026quot;http://en.wikipedia.org/wiki/Boost_C++_Libraries\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;Boost\u0026lt;/a\u0026gt;, but I needed something that doesn\u0026apos;t depends on it, so I came to this:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;static\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;Split\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(std::vector\u0026amp;lt;std::string\u0026amp;gt;\u0026amp;amp; lst, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; std::string\u0026amp;amp; input, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; std::string\u0026amp;amp; separators, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;bool\u0026lt;/span\u0026gt; remove_empty = \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;true\u0026lt;/span\u0026gt;)\u0026lt;/span\u0026gt;\n\u0026lt;/span\u0026gt;{\n    std::ostringstream word;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt; (\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;size_t\u0026lt;/span\u0026gt; n = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;; n \u0026amp;lt; input.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;size\u0026lt;/span\u0026gt;(); ++n)\n    {\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (std::string::npos == separators.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;find\u0026lt;/span\u0026gt;(input[n]))\n            word \u0026amp;lt;\u0026amp;lt; input[n];\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;else\u0026lt;/span\u0026gt;\n        {\n            \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (!word.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;str\u0026lt;/span\u0026gt;().\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;empty\u0026lt;/span\u0026gt;() || !remove_empty)\n                lst.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;push_back\u0026lt;/span\u0026gt;(word.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;str\u0026lt;/span\u0026gt;());\n            word.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;str\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;\u0026quot;\u0026lt;/span\u0026gt;);\n        }\n    }\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (!word.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;str\u0026lt;/span\u0026gt;().\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;empty\u0026lt;/span\u0026gt;() || !remove_empty)\n        lst.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;push_back\u0026lt;/span\u0026gt;(word.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;str\u0026lt;/span\u0026gt;());\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;A good point is that in \u0026lt;code\u0026gt;separators\u0026lt;/code\u0026gt; you can pass more than one character.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Short and elegant\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;vector\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;string\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;using\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;namespace\u0026lt;/span\u0026gt; std;\n\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;vector\u0026amp;lt;string\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;split\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(string data, string token)\u0026lt;/span\u0026gt;\n\u0026lt;/span\u0026gt;{\n    vector\u0026amp;lt;string\u0026amp;gt; output;\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;size_t\u0026lt;/span\u0026gt; pos = string::npos; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// size_t to avoid improbable overflow\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;do\u0026lt;/span\u0026gt;\n    {\n        pos = data.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;find\u0026lt;/span\u0026gt;(token);\n        output.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;push_back\u0026lt;/span\u0026gt;(data.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;substr\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;, pos));\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (string::npos != pos)\n            data = data.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;substr\u0026lt;/span\u0026gt;(pos + token.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;size\u0026lt;/span\u0026gt;());\n    } \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;while\u0026lt;/span\u0026gt; (string::npos != pos);\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; output;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;can use any string as delimiter, also can be used with binary data (std::string supports binary data, including nulls)\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;using:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;auto\u0026lt;/span\u0026gt; a = \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;split\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;this!!is!!!example!string\u0026quot;\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;!!\u0026quot;\u0026lt;/span\u0026gt;);\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;output:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;this\u0026lt;/span\u0026gt;\nis\n!example!string\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;I\u0026apos;ve rolled my own using strtok and used boost to split a string.  The best method I have found is the \u0026lt;a href=\u0026quot;http://www.partow.net/programming/strtk/\u0026quot;\u0026gt;C++ String Toolkit Library\u0026lt;/a\u0026gt;.  It is incredibly flexible and fast.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;iostream\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;vector\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;string\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;strtk.hpp\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; *whitespace  = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot; \\t\\r\\n\\f\u0026quot;\u0026lt;/span\u0026gt;;\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; *whitespace_and_punctuation  = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot; \\t\\r\\n\\f;,=\u0026quot;\u0026lt;/span\u0026gt;;\n\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;main\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt;\n\u0026lt;/span\u0026gt;{\n    {   \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// normal parsing of a string into a vector of strings\u0026lt;/span\u0026gt;\n        \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;std::string \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;s\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Somewhere down the road\u0026quot;\u0026lt;/span\u0026gt;)\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;;\n        std::vector\u0026amp;lt;std::string\u0026amp;gt; result;\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt;( strtk::\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;parse\u0026lt;/span\u0026gt;( s, whitespace, result ) )\n        {\n            \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;size_t\u0026lt;/span\u0026gt; i = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;; i \u0026amp;lt; result.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;size\u0026lt;/span\u0026gt;(); ++i )\n                std::cout \u0026amp;lt;\u0026amp;lt; result[i] \u0026amp;lt;\u0026amp;lt; std::endl;\n        }\n    }\n\n    {  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// parsing a string into a vector of floats with other separators\u0026lt;/span\u0026gt;\n        \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// besides spaces\u0026lt;/span\u0026gt;\n\n        \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;std::string \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;s\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;3.0, 3.14; 4.0\u0026quot;\u0026lt;/span\u0026gt;)\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;;\n        std::vector\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;float\u0026lt;/span\u0026gt;\u0026amp;gt; values;\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt;( strtk::\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;parse\u0026lt;/span\u0026gt;( s, whitespace_and_punctuation, values ) )\n        {\n            \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;size_t\u0026lt;/span\u0026gt; i = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;; i \u0026amp;lt; values.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;size\u0026lt;/span\u0026gt;(); ++i )\n                std::cout \u0026amp;lt;\u0026amp;lt; values[i] \u0026amp;lt;\u0026amp;lt; std::endl;\n        }\n    }\n\n    {  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// parsing a string into specific variables\u0026lt;/span\u0026gt;\n\n        \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;std::string \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;s\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;angle = 45; radius = 9.9\u0026quot;\u0026lt;/span\u0026gt;)\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;;\n        std::string w1, w2;\n        \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;float\u0026lt;/span\u0026gt; v1, v2;\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt;( strtk::\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;parse\u0026lt;/span\u0026gt;( s, whitespace_and_punctuation, w1, v1, w2, v2) )\n        {\n            std::cout \u0026amp;lt;\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;word \u0026quot;\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026amp;lt; w1 \u0026amp;lt;\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;, value \u0026quot;\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026amp;lt; v1 \u0026amp;lt;\u0026amp;lt; std::endl;\n            std::cout \u0026amp;lt;\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;word \u0026quot;\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026amp;lt; w2 \u0026amp;lt;\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;, value \u0026quot;\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026amp;lt; v2 \u0026amp;lt;\u0026amp;lt; std::endl;\n        }\n    }\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;The toolkit has much more flexibility than this simple example shows but its utility in parsing a string into useful elements is incredible.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;I made this because I needed an easy way to split strings and c-based strings... Hopefully someone else can find it useful as well. Also it doesn\u0026apos;t rely on tokens and you can use fields as delimiters, which is another key I needed.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;I\u0026apos;m sure there\u0026apos;s improvements that can be made to even further improve its elegance and please do by all means\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;StringSplitter.hpp:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;vector\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;iostream\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;string.h\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;using\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;namespace\u0026lt;/span\u0026gt; std;\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;StringSplit\u0026lt;/span\u0026gt;\n{\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;private\u0026lt;/span\u0026gt;:\n    \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;copy_fragment\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt;*, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt;*, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt;*)\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;;\n    \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;copy_fragment\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt;*, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt;*, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt;)\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;;\n    \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;bool\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;match_fragment\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt;*, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt;*, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;)\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;;\n    \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;untilnextdelim\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt;*, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt;)\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;;\n    \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;untilnextdelim\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt;*, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt;*)\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;;\n    \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;assimilate\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt;*, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt;)\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;;\n    \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;assimilate\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt;*, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt;*)\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;;\n    \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;bool\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;string_contains\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt;*, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt;*)\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;;\n    \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;long\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;calc_string_size\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt;*)\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;;\n    \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;copy_string\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt;*, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt;*)\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;;\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt;:\n    \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;vector\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt;*\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;split_cstr\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt;)\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;;\n    \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;vector\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt;*\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;split_cstr\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt;*)\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;;\n    \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;vector\u0026amp;lt;string\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;split_string\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt;)\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;;\n    \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;vector\u0026amp;lt;string\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;split_string\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt;*)\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;;\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt;* String;\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;bool\u0026lt;/span\u0026gt; do_string;\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;bool\u0026lt;/span\u0026gt; keep_empty;\n    vector\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt;*\u0026amp;gt; Container;\n    vector\u0026amp;lt;string\u0026amp;gt; ContainerS;\n\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;StringSplit\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; * in)\n    {\n        String = in;\n    }\n\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;StringSplit\u0026lt;/span\u0026gt;(string in)\n    {\n        \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;size_t\u0026lt;/span\u0026gt; len = \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;calc_string_size\u0026lt;/span\u0026gt;((\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt;*)in.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;c_str\u0026lt;/span\u0026gt;());\n        String = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt;[len + \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;];\n        \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;memset\u0026lt;/span\u0026gt;(String, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;, len + \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;);\n        \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;copy_string\u0026lt;/span\u0026gt;(String, (\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt;*)in.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;c_str\u0026lt;/span\u0026gt;());\n        do_string = \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;true\u0026lt;/span\u0026gt;;\n    }\n\n    ~\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;StringSplit\u0026lt;/span\u0026gt;()\n    {\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt; (\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; i = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;; i \u0026amp;lt; Container.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;size\u0026lt;/span\u0026gt;(); i++)\n        {\n            \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (Container[i] != \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;NULL\u0026lt;/span\u0026gt;)\n            {\n                \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;delete\u0026lt;/span\u0026gt;[] Container[i];\n            }\n        }\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (do_string)\n        {\n            \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;delete\u0026lt;/span\u0026gt;[] String;\n        }\n    }\n};\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;StringSplitter.cpp:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;string.h\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;iostream\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;vector\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;StringSplit.hpp\u0026quot;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;using\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;namespace\u0026lt;/span\u0026gt; std;\n\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;StringSplit::assimilate\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt;*src, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; delim)\u0026lt;/span\u0026gt;\n\u0026lt;/span\u0026gt;{\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; until = \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;untilnextdelim\u0026lt;/span\u0026gt;(src, delim);\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (until \u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;)\n    {\n        \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; * temp = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt;[until + \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;];\n        \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;memset\u0026lt;/span\u0026gt;(temp, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;, until + \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;);\n        \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;copy_fragment\u0026lt;/span\u0026gt;(temp, src, delim);\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (keep_empty || *temp != \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;)\n        {\n            \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (!do_string)\n            {\n                Container.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;push_back\u0026lt;/span\u0026gt;(temp);\n            }\n            \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;else\u0026lt;/span\u0026gt;\n            {\n                string x = temp;\n                ContainerS.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;push_back\u0026lt;/span\u0026gt;(x);\n            }\n\n        }\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;else\u0026lt;/span\u0026gt;\n        {\n            \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;delete\u0026lt;/span\u0026gt;[] temp;\n        }\n    }\n}\n\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;StringSplit::assimilate\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt;*src, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt;* delim)\u0026lt;/span\u0026gt;\n\u0026lt;/span\u0026gt;{\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; until = \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;untilnextdelim\u0026lt;/span\u0026gt;(src, delim);\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (until \u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;)\n    {\n        \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; * temp = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt;[until + \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;];\n        \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;memset\u0026lt;/span\u0026gt;(temp, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;, until + \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;);\n        \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;copy_fragment\u0026lt;/span\u0026gt;(temp, src, delim);\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (keep_empty || *temp != \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;)\n        {\n            \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (!do_string)\n            {\n                Container.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;push_back\u0026lt;/span\u0026gt;(temp);\n            }\n            \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;else\u0026lt;/span\u0026gt;\n            {\n                string x = temp;\n                ContainerS.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;push_back\u0026lt;/span\u0026gt;(x);\n            }\n        }\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;else\u0026lt;/span\u0026gt;\n        {\n            \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;delete\u0026lt;/span\u0026gt;[] temp;\n        }\n    }\n}\n\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;long\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;StringSplit::calc_string_size\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt;* _in)\u0026lt;/span\u0026gt;\n\u0026lt;/span\u0026gt;{\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;long\u0026lt;/span\u0026gt; i = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;while\u0026lt;/span\u0026gt; (*_in++)\n    {\n        i++;\n    }\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; i;\n}\n\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;bool\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;StringSplit::string_contains\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt;* haystack, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt;* needle)\u0026lt;/span\u0026gt;\n\u0026lt;/span\u0026gt;{\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;size_t\u0026lt;/span\u0026gt; len = \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;calc_string_size\u0026lt;/span\u0026gt;(needle);\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;size_t\u0026lt;/span\u0026gt; lenh = \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;calc_string_size\u0026lt;/span\u0026gt;(haystack);\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;while\u0026lt;/span\u0026gt; (lenh--)\n    {\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;match_fragment\u0026lt;/span\u0026gt;(haystack + lenh, needle, len))\n        {\n            \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;true\u0026lt;/span\u0026gt;;\n        }\n    }\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;false\u0026lt;/span\u0026gt;;\n}\n\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;bool\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;StringSplit::match_fragment\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt;* _src, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt;* cmp, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; len)\u0026lt;/span\u0026gt;\n\u0026lt;/span\u0026gt;{\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;while\u0026lt;/span\u0026gt; (len--)\n    {\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (*(_src + len) != *(cmp + len))\n        {\n            \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;false\u0026lt;/span\u0026gt;;\n        }\n    }\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;true\u0026lt;/span\u0026gt;;\n}\n\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;StringSplit::untilnextdelim\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt;* _in, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; delim)\u0026lt;/span\u0026gt;\n\u0026lt;/span\u0026gt;{\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;size_t\u0026lt;/span\u0026gt; len = \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;calc_string_size\u0026lt;/span\u0026gt;(_in);\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (*_in == delim)\n    {\n        _in += \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;;\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; len - \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;;\n    }\n\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; c = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;while\u0026lt;/span\u0026gt; (*(_in + c) != delim \u0026amp;amp;\u0026amp;amp; c \u0026amp;lt; len)\n    {\n        c++;\n    }\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; c;\n}\n\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;StringSplit::untilnextdelim\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt;* _in, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt;* delim)\u0026lt;/span\u0026gt;\n\u0026lt;/span\u0026gt;{\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; s = \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;calc_string_size\u0026lt;/span\u0026gt;(delim);\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; c = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt; + s;\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (!\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;string_contains\u0026lt;/span\u0026gt;(_in, delim))\n    {\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;calc_string_size\u0026lt;/span\u0026gt;(_in);\n    }\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;else\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;match_fragment\u0026lt;/span\u0026gt;(_in, delim, s))\n    {\n        _in += s;\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;calc_string_size\u0026lt;/span\u0026gt;(_in);\n    }\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;while\u0026lt;/span\u0026gt; (!\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;match_fragment\u0026lt;/span\u0026gt;(_in + c, delim, s))\n    {\n        c++;\n    }\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; c;\n}\n\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;StringSplit::copy_fragment\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt;* dest, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt;* src, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; delim)\u0026lt;/span\u0026gt;\n\u0026lt;/span\u0026gt;{\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (*src == delim)\n    {\n        src++;\n    }\n\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; c = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;while\u0026lt;/span\u0026gt; (*(src + c) != delim \u0026amp;amp;\u0026amp;amp; *(src + c))\n    {\n        *(dest + c) = *(src + c);\n        c++;\n    }\n    *(dest + c) = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;;\n}\n\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;StringSplit::copy_string\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt;* dest, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt;* src)\u0026lt;/span\u0026gt;\n\u0026lt;/span\u0026gt;{\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; i = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;while\u0026lt;/span\u0026gt; (*(src + i))\n    {\n        *(dest + i) = *(src + i);\n        i++;\n    }\n}\n\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;StringSplit::copy_fragment\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt;* dest, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt;* src, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt;* delim)\u0026lt;/span\u0026gt;\n\u0026lt;/span\u0026gt;{\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;size_t\u0026lt;/span\u0026gt; len = \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;calc_string_size\u0026lt;/span\u0026gt;(delim);\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;size_t\u0026lt;/span\u0026gt; lens = \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;calc_string_size\u0026lt;/span\u0026gt;(src);\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;match_fragment\u0026lt;/span\u0026gt;(src, delim, len))\n    {\n        src += len;\n        lens -= len;\n    }\n\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; c = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;while\u0026lt;/span\u0026gt; (!\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;match_fragment\u0026lt;/span\u0026gt;(src + c, delim, len) \u0026amp;amp;\u0026amp;amp; (c \u0026amp;lt; lens))\n    {\n        *(dest + c) = *(src + c);\n        c++;\n    }\n    *(dest + c) = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;;\n}\n\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;vector\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt;*\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;StringSplit::split_cstr\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; Delimiter)\u0026lt;/span\u0026gt;\n\u0026lt;/span\u0026gt;{\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; i = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;while\u0026lt;/span\u0026gt; (*String)\n    {\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (*String != Delimiter \u0026amp;amp;\u0026amp;amp; i == \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;)\n        {\n            \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;assimilate\u0026lt;/span\u0026gt;(String, Delimiter);\n        }\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (*String == Delimiter)\n        {\n            \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;assimilate\u0026lt;/span\u0026gt;(String, Delimiter);\n        }\n        i++;\n        String++;\n    }\n\n    String -= i;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;delete\u0026lt;/span\u0026gt;[] String;\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; Container;\n}\n\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;vector\u0026amp;lt;string\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;StringSplit::split_string\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; Delimiter)\u0026lt;/span\u0026gt;\n\u0026lt;/span\u0026gt;{\n    do_string = \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;true\u0026lt;/span\u0026gt;;\n\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; i = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;while\u0026lt;/span\u0026gt; (*String)\n    {\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (*String != Delimiter \u0026amp;amp;\u0026amp;amp; i == \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;)\n        {\n            \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;assimilate\u0026lt;/span\u0026gt;(String, Delimiter);\n        }\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (*String == Delimiter)\n        {\n            \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;assimilate\u0026lt;/span\u0026gt;(String, Delimiter);\n        }\n        i++;\n        String++;\n    }\n\n    String -= i;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;delete\u0026lt;/span\u0026gt;[] String;\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; ContainerS;\n}\n\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;vector\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt;*\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;StringSplit::split_cstr\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt;* Delimiter)\u0026lt;/span\u0026gt;\n\u0026lt;/span\u0026gt;{\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; i = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;;\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;size_t\u0026lt;/span\u0026gt; LenDelim = \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;calc_string_size\u0026lt;/span\u0026gt;(Delimiter);\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;while\u0026lt;/span\u0026gt;(*String)\n    {\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (!\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;match_fragment\u0026lt;/span\u0026gt;(String, Delimiter, LenDelim) \u0026amp;amp;\u0026amp;amp; i == \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;)\n        {\n            \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;assimilate\u0026lt;/span\u0026gt;(String, Delimiter);\n        }\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;match_fragment\u0026lt;/span\u0026gt;(String, Delimiter, LenDelim))\n        {\n            \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;assimilate\u0026lt;/span\u0026gt;(String,Delimiter);\n        }\n        i++;\n        String++;\n    }\n\n    String -= i;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;delete\u0026lt;/span\u0026gt;[] String;\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; Container;\n}\n\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;vector\u0026amp;lt;string\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;StringSplit::split_string\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt;* Delimiter)\u0026lt;/span\u0026gt;\n\u0026lt;/span\u0026gt;{\n    do_string = \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;true\u0026lt;/span\u0026gt;;\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; i = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;;\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;size_t\u0026lt;/span\u0026gt; LenDelim = \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;calc_string_size\u0026lt;/span\u0026gt;(Delimiter);\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;while\u0026lt;/span\u0026gt; (*String)\n    {\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (!\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;match_fragment\u0026lt;/span\u0026gt;(String, Delimiter, LenDelim) \u0026amp;amp;\u0026amp;amp; i == \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;)\n        {\n            \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;assimilate\u0026lt;/span\u0026gt;(String, Delimiter);\n        }\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;match_fragment\u0026lt;/span\u0026gt;(String, Delimiter, LenDelim))\n        {\n            \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;assimilate\u0026lt;/span\u0026gt;(String, Delimiter);\n        }\n        i++;\n        String++;\n    }\n\n    String -= i;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;delete\u0026lt;/span\u0026gt;[] String;\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; ContainerS;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Examples:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;main\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; argc, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt;*argv[])\u0026lt;/span\u0026gt;\n\u0026lt;/span\u0026gt;{\n    StringSplit ss = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;This:CUT:is:CUT:an:CUT:example:CUT:cstring\u0026quot;\u0026lt;/span\u0026gt;;\n    vector\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt;*\u0026amp;gt; Split = ss.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;split_cstr\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;:CUT:\u0026quot;\u0026lt;/span\u0026gt;);\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt; (\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; i = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;; i \u0026amp;lt; Split.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;size\u0026lt;/span\u0026gt;(); i++)\n    {\n        cout \u0026amp;lt;\u0026amp;lt; Split[i] \u0026amp;lt;\u0026amp;lt; endl;\n    }\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Will output:\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;This\u0026lt;br\u0026gt;\nis\u0026lt;br\u0026gt;\nan\u0026lt;br\u0026gt;\nexample\u0026lt;br\u0026gt;\ncstring\u0026lt;br\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;main\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; argc, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt;*argv[])\u0026lt;/span\u0026gt;\n\u0026lt;/span\u0026gt;{\n    StringSplit ss = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;This:is:an:example:cstring\u0026quot;\u0026lt;/span\u0026gt;;\n    vector\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt;*\u0026amp;gt; Split = ss.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;split_cstr\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;:\u0026apos;\u0026lt;/span\u0026gt;);\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt; (\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; i = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;; i \u0026amp;lt; Split.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;size\u0026lt;/span\u0026gt;(); i++)\n    {\n        cout \u0026amp;lt;\u0026amp;lt; Split[i] \u0026amp;lt;\u0026amp;lt; endl;\n    }\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;;\n}\n\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;main\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; argc, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt;*argv[])\u0026lt;/span\u0026gt;\n\u0026lt;/span\u0026gt;{\n    string mystring = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;This[SPLIT]is[SPLIT]an[SPLIT]example[SPLIT]string\u0026quot;\u0026lt;/span\u0026gt;;\n    StringSplit ss = mystring;\n    vector\u0026amp;lt;string\u0026amp;gt; Split = ss.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;split_string\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;[SPLIT]\u0026quot;\u0026lt;/span\u0026gt;);\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt; (\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; i = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;; i \u0026amp;lt; Split.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;size\u0026lt;/span\u0026gt;(); i++)\n    {\n        cout \u0026amp;lt;\u0026amp;lt; Split[i] \u0026amp;lt;\u0026amp;lt; endl;\n    }\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;;\n}\n\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;main\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; argc, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt;*argv[])\u0026lt;/span\u0026gt;\n\u0026lt;/span\u0026gt;{\n    string mystring = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;This|is|an|example|string\u0026quot;\u0026lt;/span\u0026gt;;\n    StringSplit ss = mystring;\n    vector\u0026amp;lt;string\u0026amp;gt; Split = ss.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;split_string\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;|\u0026apos;\u0026lt;/span\u0026gt;);\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt; (\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; i = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;; i \u0026amp;lt; Split.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;size\u0026lt;/span\u0026gt;(); i++)\n    {\n        cout \u0026amp;lt;\u0026amp;lt; Split[i] \u0026amp;lt;\u0026amp;lt; endl;\n    }\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;To keep empty entries (by default empties will be excluded):\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;StringSplit ss = mystring;\nss.keep_empty = \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;true\u0026lt;/span\u0026gt;;\nvector\u0026amp;lt;string\u0026amp;gt; Split = ss.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;split_string\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;:DELIM:\u0026quot;\u0026lt;/span\u0026gt;);\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;The goal was to make it similar to C#\u0026apos;s Split() method where splitting a string is as easy as:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;String[] Split = \n    \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Hey:cut:what\u0026apos;s:cut:your:cut:name?\u0026quot;\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;Split\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt;[]{\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;:cut:\u0026quot;\u0026lt;/span\u0026gt;}, StringSplitOptions.None);\n\nforeach(String X in Split)\n{\n    Console.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;Write\u0026lt;/span\u0026gt;(X);\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;I hope someone else can find this as useful as I do.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;This answer takes the string and puts it into a vector of strings. It uses the boost library.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;boost/algorithm/string.hpp\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\nstd::vector\u0026amp;lt;std::string\u0026amp;gt; strs;\nboost::\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;split\u0026lt;/span\u0026gt;(strs, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;string to split\u0026quot;\u0026lt;/span\u0026gt;, boost::\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;is_any_of\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;\\t \u0026quot;\u0026lt;/span\u0026gt;));\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;What about this:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;string\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;vector\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;using\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;namespace\u0026lt;/span\u0026gt; std;\n\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;vector\u0026amp;lt;string\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;split\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(string str, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; delim)\u0026lt;/span\u0026gt; \u0026lt;/span\u0026gt;{\n    vector\u0026amp;lt;string\u0026amp;gt; v;\n    string tmp;\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt;(string::const_iterator i; i = str.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;begin\u0026lt;/span\u0026gt;(); i \u0026amp;lt;= str.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;end\u0026lt;/span\u0026gt;(); ++i) {\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt;(*i != delim \u0026amp;amp;\u0026amp;amp; i != str.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;end\u0026lt;/span\u0026gt;()) {\n            tmp += *i; \n        } \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;else\u0026lt;/span\u0026gt; {\n            v.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;push_back\u0026lt;/span\u0026gt;(tmp);\n            tmp = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;\u0026quot;\u0026lt;/span\u0026gt;; \n        }   \n    }   \n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; v;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Here\u0026apos;s another way of doing it..\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;split_string\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(string text,vector\u0026amp;lt;string\u0026amp;gt;\u0026amp;amp; words)\u0026lt;/span\u0026gt;\n\u0026lt;/span\u0026gt;{\n  \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; i=\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;;\n  \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; ch;\n  string word;\n\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;while\u0026lt;/span\u0026gt;(ch=text[i++])\n  {\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;isspace\u0026lt;/span\u0026gt;(ch))\n    {\n      \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (!word.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;empty\u0026lt;/span\u0026gt;())\n      {\n        words.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;push_back\u0026lt;/span\u0026gt;(word);\n      }\n      word = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;\u0026quot;\u0026lt;/span\u0026gt;;\n    }\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;else\u0026lt;/span\u0026gt;\n    {\n      word += ch;\n    }\n  }\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (!word.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;empty\u0026lt;/span\u0026gt;())\n  {\n    words.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;push_back\u0026lt;/span\u0026gt;(word);\n  }\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;I like to use the boost/regex methods for this task since they provide maximum flexibility for specifying the splitting criteria.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;iostream\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;string\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;boost/regex.hpp\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;main\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt; \u0026lt;/span\u0026gt;{\n    \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;std::string \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;line\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;A:::line::to:split\u0026quot;\u0026lt;/span\u0026gt;)\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;;\n    \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; boost::regex \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;re\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;:+\u0026quot;\u0026lt;/span\u0026gt;)\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// one or more colons\u0026lt;/span\u0026gt;\n\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// -1 means find inverse matches aka split\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;boost::sregex_token_iterator \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;tokens\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(line.begin(),line.end(),re,\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;-1\u0026lt;/span\u0026gt;)\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;;\n    boost::sregex_token_iterator end;\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt; (; tokens != end; ++tokens)\n        std::cout \u0026amp;lt;\u0026amp;lt; *tokens \u0026amp;lt;\u0026amp;lt; std::endl;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Recently I had to split a camel-cased word into subwords.  There are no delimiters, just upper characters. \u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;string\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;list\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;locale\u0026amp;gt;\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// std::isupper\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; String\u0026amp;gt;\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; std::list\u0026amp;lt;String\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;split_camel_case_string\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; String \u0026amp;amp;s)\u0026lt;/span\u0026gt;\n\u0026lt;/span\u0026gt;{\n    std::list\u0026amp;lt;String\u0026amp;gt; R;\n    String w;\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt; (String::const_iterator i = s.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;begin\u0026lt;/span\u0026gt;(); i \u0026amp;lt; s.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;end\u0026lt;/span\u0026gt;(); ++i) {  {\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (std::\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;isupper\u0026lt;/span\u0026gt;(*i)) {\n            \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (w.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;length\u0026lt;/span\u0026gt;()) {\n                R.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;push_back\u0026lt;/span\u0026gt;(w);\n                w.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;clear\u0026lt;/span\u0026gt;();\n            }\n        }\n        w += *i;\n    }\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (w.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;length\u0026lt;/span\u0026gt;())\n        R.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;push_back\u0026lt;/span\u0026gt;(w);\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; R;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;For example, this splits \u0026quot;AQueryTrades\u0026quot; into \u0026quot;A\u0026quot;, \u0026quot;Query\u0026quot; and \u0026quot;Trades\u0026quot;.  The function works with narrow and wide strings. Because it respects the current locale it splits \u0026quot;RaumfahrtÜberwachungsVerordnung\u0026quot; into \u0026quot;Raumfahrt\u0026quot;, \u0026quot;Überwachungs\u0026quot; and \u0026quot;Verordnung\u0026quot;.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Note \u0026lt;code\u0026gt;std::upper\u0026lt;/code\u0026gt; should be really passed as function template argument. Then the more generalized from of this function can split at delimiters like \u0026lt;code\u0026gt;\u0026quot;,\u0026quot;\u0026lt;/code\u0026gt;, \u0026lt;code\u0026gt;\u0026quot;;\u0026quot;\u0026lt;/code\u0026gt; or \u0026lt;code\u0026gt;\u0026quot; \u0026quot;\u0026lt;/code\u0026gt; too.\u0026lt;/p\u0026gt;\n    "],"id":156,"title":"How do I iterate over the words of a string?","content":"\n                \n\u0026lt;p\u0026gt;How do I iterate over the words of a string composed of words separated by whitespace?\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Note that I\u0026apos;m not interested in C string functions or that kind of character manipulation/access. I prefer elegance over efficiency. My current solution:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;iostream\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;sstream\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;string\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;using\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;namespace\u0026lt;/span\u0026gt; std;\n\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;main\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt; \u0026lt;/span\u0026gt;{\n    string s = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Somewhere down the road\u0026quot;\u0026lt;/span\u0026gt;;\n    \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;istringstream \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;iss\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(s)\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;;\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;do\u0026lt;/span\u0026gt; {\n        string subs;\n        iss \u0026amp;gt;\u0026amp;gt; subs;\n        cout \u0026amp;lt;\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Substring: \u0026quot;\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026amp;lt; subs \u0026amp;lt;\u0026amp;lt; endl;\n    } \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;while\u0026lt;/span\u0026gt; (iss);\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","slug":"how-do-i-iterate-over-the-words-of-a-string-1657384806129","postType":"QUESTION","createdAt":"2022-07-09T16:40:06.000Z","updatedAt":"2022-07-09T16:40:06.000Z","tags":[],"relatedQuestions":[]},"randomQuestions":[{"title":"Get selected value in dropdown list using JavaScript","slug":"get-selected-value-in-dropdown-list-using-javascript-1657387631638"},{"title":"How to count the number of set bits in a 32-bit integer?","slug":"how-to-count-the-number-of-set-bits-in-a-32-bit-integer-1657388437370"},{"title":"Simulating group_concat MySQL function in Microsoft SQL Server 2005?","slug":"simulating-group_concat-mysql-function-in-microsoft-sql-server-2005-1657384832169"},{"title":"Self-references in object literals / initializers","slug":"self-references-in-object-literals-initializers-1657384835356"},{"title":"How to sum a variable by group","slug":"how-to-sum-a-variable-by-group-1657384838148"},{"title":"What is this weird colon-member (\" : \") syntax in the constructor?","slug":"what-is-this-weird-colon-member-(\"-:-\")-syntax-in-the-constructor-1657387264047"},{"title":"Captured variable in a loop in C#","slug":"captured-variable-in-a-loop-in-c-1657387696779"},{"title":"What does the 'static' keyword do in a class?","slug":"what-does-the-'static'-keyword-do-in-a-class-1657388554238"},{"title":"\"Cross origin requests are only supported for HTTP.\" error when loading a local file","slug":"\"cross-origin-requests-are-only-supported-for-http.\"-error-when-loading-a-local-file-1657387942403"},{"title":"How do I pass data between Activities in Android application?","slug":"how-do-i-pass-data-between-activities-in-android-application-1657384739839"},{"title":"What is the canonical way to check for errors using the CUDA runtime API?","slug":"what-is-the-canonical-way-to-check-for-errors-using-the-cuda-runtime-api-1657387302698"},{"title":"Query based on multiple where clauses in Firebase","slug":"query-based-on-multiple-where-clauses-in-firebase-1657387494547"},{"title":"Get the row(s) which have the max value in groups using groupby","slug":"get-the-row(s)-which-have-the-max-value-in-groups-using-groupby-1657388014787"},{"title":"How do I get PHP errors to display?","slug":"how-do-i-get-php-errors-to-display-1657384570095"},{"title":"Read file line by line using ifstream in C++","slug":"read-file-line-by-line-using-ifstream-in-c++-1657388236966"},{"title":"How do I properly clean up Excel interop objects?","slug":"how-do-i-properly-clean-up-excel-interop-objects-1657388329706"},{"title":".prop() vs .attr()","slug":".prop()-vs-.attr()-1657384898328"},{"title":"How do I give text or an image a transparent background using CSS?","slug":"how-do-i-give-text-or-an-image-a-transparent-background-using-css-1657388188508"},{"title":"Grouping functions (tapply, by, aggregate) and the *apply family","slug":"grouping-functions-(tapply-by-aggregate)-and-the-*apply-family-1657387844286"},{"title":"How can I group an array of objects by key?","slug":"how-can-i-group-an-array-of-objects-by-key-1657388065372"}]},"__N_SSG":true},"page":"/questions/[slug]","query":{"slug":"how-do-i-iterate-over-the-words-of-a-string-1657384806129"},"buildId":"6ctJfCympFH_chh5mjicD","isFallback":false,"gsp":true,"locale":"en","locales":["en"],"defaultLocale":"en","scriptLoader":[]}</script></body></html>