<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><meta name="twitter:card" content="summary_large_image"/><meta name="twitter:site" content="@solutionschecker.com"/><meta name="twitter:creator" content="@solutionschecker.com"/><meta property="og:url" content="https://solutionschecker.com"/><meta property="og:type" content="website"/><meta property="og:image" content="https://solutionschecker.com/solutions-checker-banner.png"/><meta property="og:image:alt" content="Find the solution to any question. We focus on finding the fastest possible solution for users. Main topics like coding, learning. - solutionschecker.com"/><link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png"/><link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png"/><link rel="manifest" href="/site.webmanifest"/><script type="application/ld+json">{"@context":"https://schema.org","@type":"Organization","logo":"/logo.svg","url":"https://solutionschecker.com"}</script><link name="keywords" content="solutions checker, solution checker, how to, solution for, check for solution, resolve question, what is, what solution for, find solution"/><script type="application/ld+json">{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"item":{"@id":"https://solutionschecker.com","name":"Home"}},{"@type":"ListItem","position":2,"item":{"@id":"https://solutionschecker.com/questions","name":"Questions"}},{"@type":"ListItem","position":3,"item":{"@id":"https://solutionschecker.com/questions/using-regular-expressions-to-parse-html:-why-not-1657387543969","name":"Questions"}}]}</script><title>Using regular expressions to parse HTML: why not? | Solution Checker</title><meta name="robots" content="index,follow"/><meta name="description" content="It seems like every question on stackoverflow where the asker is using regex to grab some information from HTML will inevitably have an &quot;answer&quot; that says not to use regex to parse HTML.

Why not? I&#x27;m aware that there are quote-unquote &quot;real&quot; HTML parsers out there like Beautiful Soup, and I&#x27;m sure they&#x27;re powerful and useful, but if you&#x27;re just doing something simple, quick, or dirty, then why bother using something so complicated when a few regex statements will work just fine?

Moreover, is there just something fundamental that I don&#x27;t understand about regex that makes them a bad choice for parsing in general?
    "/><meta property="og:title" content="Using regular expressions to parse HTML: why not? | Solution Checker"/><meta property="og:description" content="It seems like every question on stackoverflow where the asker is using regex to grab some information from HTML will inevitably have an &quot;answer&quot; that says not to use regex to parse HTML.

Why not? I&#x27;m aware that there are quote-unquote &quot;real&quot; HTML parsers out there like Beautiful Soup, and I&#x27;m sure they&#x27;re powerful and useful, but if you&#x27;re just doing something simple, quick, or dirty, then why bother using something so complicated when a few regex statements will work just fine?

Moreover, is there just something fundamental that I don&#x27;t understand about regex that makes them a bad choice for parsing in general?
    "/><script type="application/ld+json">{"@context":"https://schema.org","@type":"QAPage","mainEntity":{"name":"Using regular expressions to parse HTML: why not?","text":"It seems like every question on stackoverflow where the asker is using regex to grab some information from HTML will inevitably have an &quot;answer&quot; that says not to use regex to parse HTML.\n\nWhy not? I&apos;m aware that there are quote-unquote &quot;real&quot; HTML parsers out there like Beautiful Soup, and I&apos;m sure they&apos;re powerful and useful, but if you&apos;re just doing something simple, quick, or dirty, then why bother using something so complicated when a few regex statements will work just fine?\n\nMoreover, is there just something fundamental that I don&apos;t understand about regex that makes them a bad choice for parsing in general?\n    ","answerCount":18,"upVoteCount":500,"suggestedAnswer":[{"text":"Entire HTML parsing is not possible with regular expressions, since it depends on matching the opening and the closing tag which is not possible with regexps.\n\nRegular expressions can only match regular languages but HTML is a context-free language and not a regular language (As @StefanPochmann pointed out, regular languages are also context-free, so context-free doesn&apos;t necessarily mean not regular). The only thing you can do with regexps on HTML is heuristics but that will not work on every condition. It should be possible to present a HTML file that will be matched wrongly by any regular expression.\n    ","url":"https://solutionschecker.com/questions/using-regular-expressions-to-parse-html:-why-not-1657387543969#solution1","@type":"Answer","upvoteCount":0},{"text":"For quick´n´dirty regexp will do fine.  But the fundamental thing to know is that it is impossible to construct a regexp that will correctly parse HTML.\n\nThe reason is that regexps cant handle arbitarly nested expressions.  See Can regular expressions be used to match nested patterns?\n    ","url":"https://solutionschecker.com/questions/using-regular-expressions-to-parse-html:-why-not-1657387543969#solution2","@type":"Answer","upvoteCount":0},{"text":"(From http://htmlparsing.com/regexes)\n\nSay you&apos;ve got a file of HTML where you&apos;re trying to extract URLs from\n&lt;img&gt; tags.\n\n&lt;img src=&quot;http://example.com/whatever.jpg&quot;&gt;\n\n\nSo you write a regex like this in Perl:\n\nif ( $html =~ /&lt;img src=&quot;(.+)&quot;/ ) {\n    $url = $1;\n}\n\n\nIn this case, $url will indeed contain\nhttp://example.com/whatever.jpg.  But what happens when\nyou start getting HTML like this:\n\n&lt;img src=&apos;http://example.com/whatever.jpg&apos;&gt;\n\n\nor\n\n&lt;img src=http://example.com/whatever.jpg&gt;\n\n\nor\n\n&lt;img border=0 src=&quot;http://example.com/whatever.jpg&quot;&gt;\n\n\nor\n\n&lt;img\n    src=&quot;http://example.com/whatever.jpg&quot;&gt;\n\n\nor you start getting false positives from\n\n&lt;!-- // commented out\n&lt;img src=&quot;http://example.com/outdated.png&quot;&gt;\n--&gt;\n\n\nIt looks so simple, and it might be simple for a single, unchanging file, but for anything that you&apos;re going to be doing on arbitrary HTML data, regexes are just a recipe for future heartache.\n    ","url":"https://solutionschecker.com/questions/using-regular-expressions-to-parse-html:-why-not-1657387543969#solution3","@type":"Answer","upvoteCount":0},{"text":"Two quick reasons:\n\n\nwriting a regex that can stand up to malicious input is hard; way harder than using a prebuilt tool\nwriting a regex that can work with the ridiculous markup that you will inevitably be stuck with is hard; way harder than using a prebuilt tool\n\n\nRegarding the suitability of regexes for parsing in general: they aren&apos;t suitable. Have you ever seen the sorts of regexes you would need to parse most languages?\n    ","url":"https://solutionschecker.com/questions/using-regular-expressions-to-parse-html:-why-not-1657387543969#solution4","@type":"Answer","upvoteCount":0},{"text":"As far as parsing goes, regular expressions can be useful in the &quot;lexical analysis&quot; (lexer) stage, where the input is broken down into tokens. It&apos;s less useful in the actual &quot;build a parse tree&quot; stage.\n\nFor an HTML parser, I&apos;d expect it to only accept well-formed HTML and that requires capabilities outside what a regular expression can do (they cannot &quot;count&quot; and make sure that a given number of opening elements are balanced by the same number of closing elements).\n    ","url":"https://solutionschecker.com/questions/using-regular-expressions-to-parse-html:-why-not-1657387543969#solution5","@type":"Answer","upvoteCount":0},{"text":"Because there are many ways to &quot;screw up&quot; HTML that browsers will treat in a rather liberal way but it would take quite some effort to reproduce the browser&apos;s liberal behaviour to cover all cases with regular expressions, so your regex will inevitably fail on some special cases, and that would possibly introduce serious security gaps in your system.\n    ","url":"https://solutionschecker.com/questions/using-regular-expressions-to-parse-html:-why-not-1657387543969#solution6","@type":"Answer","upvoteCount":0},{"text":"The problem is that most users who ask a question that has to do with HTML and regex do this because they can&apos;t find an own regex that works. Then one has to think whether everything would be easier when using a DOM or SAX parser or something similar. They are optimized and constructed for the purpose of working with XML-like document structures.\n\nSure, there are problems that can be solved easily with regular expressions. But the emphasis lies on easily. \n\nIf you just want to find all URLs that look like http://.../ you&apos;re fine with regexps. But if you want to find all URLs that are in a a-Element that has the class &apos;mylink&apos; you probably better use a appropriate parser.\n    ","url":"https://solutionschecker.com/questions/using-regular-expressions-to-parse-html:-why-not-1657387543969#solution7","@type":"Answer","upvoteCount":0},{"text":"Regular expressions were not designed to handle a nested tag structure, and it is at best complicated (at worst, impossible) to handle all the possible edge cases you get with real HTML.\n    ","url":"https://solutionschecker.com/questions/using-regular-expressions-to-parse-html:-why-not-1657387543969#solution8","@type":"Answer","upvoteCount":0},{"text":"I believe that the answer lies in computation theory. For a language to be parsed using regex it must be by definition &quot;regular&quot; (link). HTML is not a regular language as it does not meet a number of criteria for a regular language (much to do with the many levels of nesting inherent in html code). If you are interested in the theory of computation I would recommend this book.\n    ","url":"https://solutionschecker.com/questions/using-regular-expressions-to-parse-html:-why-not-1657387543969#solution9","@type":"Answer","upvoteCount":0},{"text":"HTML/XML is divided into markup and content. \nRegex is only useful doing a lexical tag parse.\nI guess you could deduce the content.\nIt would be a good choice for a SAX parser.\nTags and content could be delivered to a user\ndefined function where nesting/closure of elements\ncan be kept track of.  \n\nAs far as just parsing the tags, it can be done with\nregex and used to strip tags from a document.\n\nOver years of testing, I&apos;ve found the secret to the\nway browsers parse tags, both well and ill formed.  \n\nThe normal elements are parsed with this form:\n\nThe core of these tags use this regex\n\n (?:\n      &quot; [\\S\\s]*? &quot; \n   |  &apos; [\\S\\s]*? &apos; \n   |  [^&gt;]? \n )+\n\n\nYou&apos;ll notice this [^&gt;]? as one of the alternations.\nThis will match unbalanced quotes from ill-formed tags.  \n\nIt is also, the single most root of all evil to regular expressions.\nThe way it&apos;s used will trigger a bump-along to satisfy it&apos;s greedy, must-match\nquantified container.  \n\nIf used passively, there is never a problem\nBut, if you force something to match by interspersing it with\na wanted attribute/value pair, and don&apos;t provide adequate protection\nfrom backtracking, it&apos;s an out of control nightmare.\n\nThis is the general form for just plain old tags.\nNotice the  [\\w:] representing the tag name?\nIn reality, the legal characters representing the tag name\nare an incredible list of Unicode characters.  \n\n &lt;     \n (?:\n      [\\w:]+ \n      \\s+ \n      (?:\n           &quot; [\\S\\s]*? &quot; \n        |  &apos; [\\S\\s]*? &apos; \n        |  [^&gt;]? \n      )+\n      \\s* /?\n )\n &gt;\n\n\n\n\nMoving on, we also see that you just can&apos;t search for a specific tag\nwithout parsing ALL tags.\nI mean you could, but it would have to use a combination of\nverbs like (*SKIP)(*FAIL) but still all tags have to be parsed.\n\nThe reason is that tag syntax may be hidden inside other tags, etc.\n\nSo, to passively parse all tags, a regex is needed like the one below.\nThis particular one matches invisible content as well.\n\nAs new HTML or xml or any other develop new constructs, just add it as\none of the alternations. \n\n\n\nWeb page note - I&apos;ve never seen a web page (or xhtml/xml) that this\nhad trouble with. If you find one, let me know.  \n\nPerformance note - It&apos;s quick. This is the fastest tag parser I&apos;ve seen\n(there may be faster, who knows).\nI have several specific versions.  It is also excellent as scraper\n(if you&apos;re the hands-on type).\n\n\n\nComplete raw regex  \n\n&lt;(?:(?:(?:(script|style|object|embed|applet|noframes|noscript|noembed)(?:\\s+(?&gt;&quot;[\\S\\s]*?&quot;|&apos;[\\S\\s]*?&apos;|(?:(?!/&gt;)[^&gt;])?)+)?\\s*&gt;)[\\S\\s]*?&lt;/\\1\\s*(?=&gt;))|(?:/?[\\w:]+\\s*/?)|(?:[\\w:]+\\s+(?:&quot;[\\S\\s]*?&quot;|&apos;[\\S\\s]*?&apos;|[^&gt;]?)+\\s*/?)|\\?[\\S\\s]*?\\?|(?:!(?:(?:DOCTYPE[\\S\\s]*?)|(?:\\[CDATA\\[[\\S\\s]*?\\]\\])|(?:--[\\S\\s]*?--)|(?:ATTLIST[\\S\\s]*?)|(?:ENTITY[\\S\\s]*?)|(?:ELEMENT[\\S\\s]*?))))&gt;  \n\nFormatted look  \n\n &lt;\n (?:\n      (?:\n           (?:\n                # Invisible content; end tag req&apos;d\n                (                             # (1 start)\n                     script\n                  |  style\n                  |  object\n                  |  embed\n                  |  applet\n                  |  noframes\n                  |  noscript\n                  |  noembed \n                )                             # (1 end)\n                (?:\n                     \\s+ \n                     (?&gt;\n                          &quot; [\\S\\s]*? &quot;\n                       |  &apos; [\\S\\s]*? &apos;\n                       |  (?:\n                               (?! /&gt; )\n                               [^&gt;] \n                          )?\n                     )+\n                )?\n                \\s* &gt;\n           )\n\n           [\\S\\s]*? &lt;/ \\1 \\s* \n           (?= &gt; )\n      )\n\n   |  (?: /? [\\w:]+ \\s* /? )\n   |  (?:\n           [\\w:]+ \n           \\s+ \n           (?:\n                &quot; [\\S\\s]*? &quot; \n             |  &apos; [\\S\\s]*? &apos; \n             |  [^&gt;]? \n           )+\n           \\s* /?\n      )\n   |  \\? [\\S\\s]*? \\?\n   |  (?:\n           !\n           (?:\n                (?: DOCTYPE [\\S\\s]*? )\n             |  (?: \\[CDATA\\[ [\\S\\s]*? \\]\\] )\n             |  (?: -- [\\S\\s]*? -- )\n             |  (?: ATTLIST [\\S\\s]*? )\n             |  (?: ENTITY [\\S\\s]*? )\n             |  (?: ELEMENT [\\S\\s]*? )\n           )\n      )\n )\n &gt;\n\n    ","url":"https://solutionschecker.com/questions/using-regular-expressions-to-parse-html:-why-not-1657387543969#solution10","@type":"Answer","upvoteCount":0},{"text":"This expression retrieves attributes from HTML elements. It supports:\n\n\nunquoted / quoted attributes,\nsingle / double quotes,\nescaped quotes inside attributes,\nspaces around equals signs,\nany number of attributes,\ncheck only for attributes inside tags,\nescape comments, and\nmanage different quotes within an attribute value.\n\n\n(?:\\&lt;\\!\\-\\-(?:(?!\\-\\-\\&gt;)\\r\\n?|\\n|.)*?-\\-\\&gt;)|(?:&lt;(\\S+)\\s+(?=.*&gt;)|(?&lt;=[=\\s])\\G)(?:((?:(?!\\s|=).)*)\\s*?=\\s*?[\\&quot;&apos;]?((?:(?&lt;=\\&quot;)(?:(?&lt;=\\\\)\\&quot;|[^\\&quot;])*|(?&lt;=&apos;)(?:(?&lt;=\\\\)&apos;|[^&apos;])*)|(?:(?!\\&quot;|&apos;)(?:(?!\\/&gt;|&gt;|\\s).)+))[\\&quot;&apos;]?\\s*)\n\nCheck it out. It works better with the &quot;gisx&quot; flags, as in the demo.\n    ","url":"https://solutionschecker.com/questions/using-regular-expressions-to-parse-html:-why-not-1657387543969#solution11","@type":"Answer","upvoteCount":0},{"text":"&quot;It depends&quot; though. It&apos;s true that regexes don&apos;t and can&apos;t parse HTML with true accuracy, for all the reasons given here. If, however, the consequences of getting it wrong (such as not handling nested tags) are minor, and if regexes are super-convenient in your environment (such as when you&apos;re hacking Perl), go ahead.\n\nSuppose you&apos;re, oh, maybe parsing web pages that link to your site--perhaps you found them with a Google link search--and you want a quick way to get a general idea of the context surround your link. You&apos;re trying to run a little report that might alert you to link spam, something like that.\n\nIn that case, misparsing some of the documents isn&apos;t going to be a big deal. Nobody but you will see the mistakes, and if you&apos;re very lucky there will be few enough that you can follow up individually.\n\nI guess I&apos;m saying it&apos;s a tradeoff. Sometimes implementing or using a correct parser--as easy as that may be--might not be worth the trouble if accuracy isn&apos;t critical.\n\nJust be careful with your assumptions. I can think of a few ways the regexp shortcut can backfire if you&apos;re trying to parse something that will be shown in public, for example.\n    ","url":"https://solutionschecker.com/questions/using-regular-expressions-to-parse-html:-why-not-1657387543969#solution12","@type":"Answer","upvoteCount":0},{"text":"There are definitely cases where using a regular expression to parse some information from HTML is the correct way to go - it depends a lot on the specific situation.\n\nThe consensus above is that in general it is a bad idea. However if the HTML structure is known (and unlikely to change) then it is still a valid approach.\n    ","url":"https://solutionschecker.com/questions/using-regular-expressions-to-parse-html:-why-not-1657387543969#solution13","@type":"Answer","upvoteCount":0},{"text":"Keep in mind that while HTML itself isn&apos;t regular, portions of a page you are looking at might be regular.\n\nFor example, it is an error for &lt;form&gt; tags to be nested; if the web page is working correctly, then using a regular expression to grab a &lt;form&gt; would be completely reasonable.\n\nI recently did some web scraping using only Selenium and regular expressions.  I got away with it because the data I wanted was put in a &lt;form&gt;, and put in a simple table format (so I could even count on &lt;table&gt;, &lt;tr&gt; and &lt;td&gt; to be non-nested--which is actually highly unusual).  In some degree, regular expressions were even almost necessary, because some of the structure I needed to access was delimited by comments.  (Beautiful Soup can give you comments, but it would have been difficult to grab &lt;!-- BEGIN --&gt; and &lt;!-- END --&gt; blocks using Beautiful Soup.)\n\nIf I had to worry about nested tables, however, my approach simply would not have worked!  I would have had to fall back on Beautiful Soup.  Even then, however, sometimes you can use a regular expression to grab the chunk you need, and then drill down from there.\n    ","url":"https://solutionschecker.com/questions/using-regular-expressions-to-parse-html:-why-not-1657387543969#solution14","@type":"Answer","upvoteCount":0},{"text":"Actually, HTML parsing with regex is perfectly possible in PHP. You just have to parse the whole string backwards using strrpos to find &lt; and repeat the regex from there using ungreedy specifiers each time to get over nested tags. Not fancy and terribly slow on large things, but I used it for my own personal template editor for my website. I wasn&apos;t actually parsing HTML, but a few custom tags I made for querying database entries to display tables of data (my &lt;#if()&gt; tag could highlight special entries this way). I wasn&apos;t prepared to go for an XML parser on just a couple of self created tags (with very non-XML data within them) here and there.\n\nSo, even though this question is considerably dead, it still shows up in a Google search. I read it and thought &quot;challenge accepted&quot; and finished fixing my simple code without having to replace everything. Decided to offer a different opinion to anyone searching for a similar reason. Also the last answer was posted 4 hours ago so this is still a hot topic.\n    ","url":"https://solutionschecker.com/questions/using-regular-expressions-to-parse-html:-why-not-1657387543969#solution15","@type":"Answer","upvoteCount":0},{"text":"I tried my hand at a regex for this too. It&apos;s mostly useful for finding chunks of content paired with the next HTML tag, and it doesn&apos;t look for matching close tags, but it will pick up close tags. Roll a stack in your own language to check those. \n\nUse with &apos;sx&apos; options.  &apos;g&apos; too if you&apos;re feeling lucky:\n\n(?P&lt;content&gt;.*?)                # Content up to next tag\n(?P&lt;markup&gt;                     # Entire tag\n  &lt;!\\[CDATA\\[(?P&lt;cdata&gt;.+?)]]&gt;| # &lt;![CDATA[ ... ]]&gt;\n  &lt;!--(?P&lt;comment&gt;.+?)--&gt;|      # &lt;!-- Comment --&gt;\n  &lt;/\\s*(?P&lt;close_tag&gt;\\w+)\\s*&gt;|  # &lt;/tag&gt;\n  &lt;(?P&lt;tag&gt;\\w+)                 # &lt;tag ...\n    (?P&lt;attributes&gt;\n      (?P&lt;attribute&gt;\\s+\n# &lt;snip&gt;: Use this part to get the attributes out of &apos;attributes&apos; group.\n        (?P&lt;attribute_name&gt;\\w+)\n        (?:\\s*=\\s*\n          (?P&lt;attribute_value&gt;\n            [\\w:/.\\-]+|         # Unquoted\n            (?=(?P&lt;_v&gt;          # Quoted\n              (?P&lt;_q&gt;[&apos;\\&quot;]).*?(?&lt;!\\\\)(?P=_q)))\n            (?P=_v)\n          ))?\n# &lt;/snip&gt;\n      )*\n    )\\s*\n  (?P&lt;is_self_closing&gt;/?)   # Self-closing indicator\n  &gt;)                        # End of tag\n\n\nThis one is designed for Python (it might work for other languages, haven&apos;t tried it, it uses positive lookaheads, negative lookbehinds, and named backreferences).  Supports:\n\n\nOpen Tag - &lt;div ...&gt;\nClose Tag - &lt;/div&gt;\nComment - &lt;!-- ... --&gt;\nCDATA - &lt;![CDATA[ ... ]]&gt;\nSelf-Closing Tag - &lt;div .../&gt;\nOptional Attribute Values - &lt;input checked&gt;\nUnquoted / Quoted Attribute Values - &lt;div style=&apos;...&apos;&gt;\nSingle / Double Quotes - &lt;div style=&quot;...&quot;&gt;\nEscaped Quotes - &lt;a title=&apos;John\\&apos;s Story&apos;&gt;\n(this isn&apos;t really valid HTML, but I&apos;m a nice guy)\nSpaces Around Equals Signs - &lt;a href = &apos;...&apos;&gt;\nNamed Captures For Interesting Bits\n\n\nIt&apos;s also pretty good about not triggering on malformed tags, like when you forget a &lt; or &gt;.\n\nIf your regex flavor supports repeated named captures then you&apos;re golden, but Python re doesn&apos;t (I know regex does, but I need to use vanilla Python). Here&apos;s what you get:\n\n\ncontent - All of the content up to the next tag. You could leave this out.\nmarkup - The entire tag with everything in it.\ncomment - If it&apos;s a comment, the comment contents.\ncdata - If it&apos;s a &lt;![CDATA[...]]&gt;, the CDATA contents.\nclose_tag - If it&apos;s a close tag (&lt;/div&gt;), the tag name.\ntag - If it&apos;s an open tag (&lt;div&gt;), the tag name.\nattributes - All attributes inside the tag. Use this to get all attributes if you don&apos;t get repeated groups.\nattribute - Repeated, each attribute.\nattribute_name - Repeated, each attribute name.\nattribute_value - Repeated, each attribute value. This includes the quotes if it was quoted.\nis_self_closing - This is / if it&apos;s a self-closing tag, otherwise nothing.\n_q and _v - Ignore these; they&apos;re used internally for backreferences.\n\n\nIf your regex engine doesn&apos;t support repeated named captures, there&apos;s a section called out that you can use to get each attribute. Just run that regex on the attributes group to get each attribute, attribute_name and attribute_value out of it.\n\nDemo here: https://regex101.com/r/mH8jSu/11\n    ","url":"https://solutionschecker.com/questions/using-regular-expressions-to-parse-html:-why-not-1657387543969#solution16","@type":"Answer","upvoteCount":0},{"text":"Regular expressions are not powerful enough for such a language like HTML. Sure, there are some examples where you can use regular expressions. But in general it is not appropriate for parsing.\n    ","url":"https://solutionschecker.com/questions/using-regular-expressions-to-parse-html:-why-not-1657387543969#solution17","@type":"Answer","upvoteCount":0},{"text":"You, know...there&apos;s a lot of mentality of you CAN&apos;T do it and I think that everyone on both sides of the fence are right and wrong.  You CAN do it, but it takes a little more processing than just running one regex against it.  Take this (I wrote this inside of an hour) as an example.  It assumes the HTML is completely valid, but depending on what language you&apos;re using to apply the aforementioned regex, you could do some fixing of the HTML to make sure that it will succeed.  For example, removing closing tags that are not supposed to be there: &lt;/img&gt; for example.  Then, add the closing single HTML forward slash to elements that are missing them, etc.\n\nI&apos;d use this in the context of writing a library that would allow me to perform HTML element retrieval akin to that of JavaScript&apos;s [x].getElementsByTagName(), for example.  I&apos;d just splice up the functionality I wrote in the DEFINE section of the regex and use it for stepping inside of a tree of elements, one at time.\n\nSo, will this be the final 100% answer for validating HTML?  No.  But it&apos;s a start and with a little more work, it can be done.  However, trying to do it inside of one regex execution is not practical, nor efficient.\n    ","url":"https://solutionschecker.com/questions/using-regular-expressions-to-parse-html:-why-not-1657387543969#solution18","@type":"Answer","upvoteCount":0}],"@type":"Question"}}</script><meta name="next-head-count" content="22"/><script id="google-analytics" data-nscript="beforeInteractive">(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
})(window,document,'script','dataLayer','GTM-NXVLL8B');</script><link rel="preload" href="/_next/static/css/c116652e2d6f4ad0.css" as="style"/><link rel="stylesheet" href="/_next/static/css/c116652e2d6f4ad0.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-0d1b80a048d4787e.js"></script><script src="/_next/static/chunks/webpack-42cdea76c8170223.js" defer=""></script><script src="/_next/static/chunks/framework-4556c45dd113b893.js" defer=""></script><script src="/_next/static/chunks/main-ccfab947c79712f4.js" defer=""></script><script src="/_next/static/chunks/pages/_app-862498b6ec7885c3.js" defer=""></script><script src="/_next/static/chunks/294-106ef8570fa99deb.js" defer=""></script><script src="/_next/static/chunks/490-7f0418bb4354ac73.js" defer=""></script><script src="/_next/static/chunks/pages/questions/%5Bslug%5D-47289857226115f9.js" defer=""></script><script src="/_next/static/xZs8haGjOP63QuDE0kxeX/_buildManifest.js" defer=""></script><script src="/_next/static/xZs8haGjOP63QuDE0kxeX/_ssgManifest.js" defer=""></script></head><body><noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-NXVLL8B"
        height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript><div id="__next"><div class="wrapper"><header><nav class="bg-white border-gray-200 px-4 lg:px-6 py-2.5 dark:bg-gray-800"><div class="flex flex-wrap justify-between items-center mx-auto max-w-screen-xl"><a class="flex items-center" href="/"><img src="/logo-second.png" class="mr-3 h-6 sm:h-9" alt="Solution Checker Logo"/><h1 class="self-center text-xl font-semibold whitespace-nowrap dark:text-white">Solution Checker</h1></a><div class="flex items-center lg:order-2"><button data-collapse-toggle="mobile-menu-2" type="button" class="inline-flex items-center p-2 ml-1 text-sm text-gray-500 rounded-lg lg:hidden hover:bg-gray-100 focus:outline-none focus:ring-2 focus:ring-gray-200 dark:text-gray-400 dark:hover:bg-gray-700 dark:focus:ring-gray-600" aria-controls="mobile-menu-2" aria-expanded="false"><span class="sr-only">Open main menu</span><svg class="w-6 h-6" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M3 5a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM3 10a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM3 15a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1z" clip-rule="evenodd"></path></svg><svg class="hidden w-6 h-6" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z" clip-rule="evenodd"></path></svg></button></div><div class="hidden justify-between items-center w-full lg:flex lg:w-auto lg:order-1" id="mobile-menu-2"><ul class="flex flex-col mt-4 font-medium lg:flex-row lg:space-x-8 lg:mt-0"><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" aria-current="page" href="/">Home</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/questions?tab=news">Questions</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/post?tab=news">Post</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/questions/using-regular-expressions-to-parse-html:-why-not-1657387543969#">Coding</a></li></ul></div></div></nav></header><div class="main-content"><div class="question my-5"><div class="flex question-header items-center m-auto justify-center"><div class="rounded-xl w-full border p-5 shadow-md bg-white"><div class="flex w-full items-center justify-between border-b pb-3"><div class="flex items-center space-x-3"><div class="text-lg font-bold text-slate-700"><a href="/questions/using-regular-expressions-to-parse-html:-why-not-1657387543969"><h1>Using regular expressions to parse HTML: why not?</h1></a></div></div><div class="flex flex-wrap h-auto justify-end items-center space-x-8"></div></div><div class="question-content mt-5">
                
<p>It seems like every question on stackoverflow where the asker is using regex to grab some information from HTML will inevitably have an "answer" that says not to use regex to parse HTML.</p>

<p>Why not? I'm aware that there are quote-unquote "real" HTML parsers out there like <a href="http://www.crummy.com/software/BeautifulSoup/" rel="noreferrer">Beautiful Soup</a>, and I'm sure they're powerful and useful, but if you're just doing something simple, quick, or dirty, then why bother using something so complicated when a few regex statements will work just fine?</p>

<p>Moreover, is there just something fundamental that I don't understand about regex that makes them a bad choice for parsing in general?</p>
    </div></div></div><div class="solution-section"><nav class="flex pagination-solution flex-col justify-end"><h1 class="text-lg font-semibold mb-5">Navigate to solutions: </h1><ul class="inline-flex -space-x-px overflow-auto"><li class="pagination-solution-item"><span data-id="#solution1" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">1</span></li><li class="pagination-solution-item"><span data-id="#solution2" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">2</span></li><li class="pagination-solution-item"><span data-id="#solution3" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">3</span></li><li class="pagination-solution-item"><span data-id="#solution4" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">4</span></li><li class="pagination-solution-item"><span data-id="#solution5" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">5</span></li><li class="pagination-solution-item"><span data-id="#solution6" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">6</span></li><li class="pagination-solution-item"><span data-id="#solution7" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">7</span></li><li class="pagination-solution-item"><span data-id="#solution8" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">8</span></li><li class="pagination-solution-item"><span data-id="#solution9" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">9</span></li><li class="pagination-solution-item"><span data-id="#solution10" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">10</span></li><li class="pagination-solution-item"><span data-id="#solution11" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">11</span></li><li class="pagination-solution-item"><span data-id="#solution12" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">12</span></li><li class="pagination-solution-item"><span data-id="#solution13" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">13</span></li><li class="pagination-solution-item"><span data-id="#solution14" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">14</span></li><li class="pagination-solution-item"><span data-id="#solution15" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">15</span></li><li class="pagination-solution-item"><span data-id="#solution16" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">16</span></li><li class="pagination-solution-item"><span data-id="#solution17" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">17</span></li><li class="pagination-solution-item"><span data-id="#solution18" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">18</span></li></ul></nav><div id="solution1" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 1</h1><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Entire HTML parsing is not possible with regular expressions, since it depends on matching the opening and the closing tag which is not possible with regexps.</p>

<p>Regular expressions can only match <a href="http://en.wikipedia.org/wiki/Regular_grammar" rel="noreferrer">regular languages</a> but HTML is a <a href="http://en.wikipedia.org/wiki/Context-free_grammar" rel="noreferrer">context-free language</a> and <em>not</em> a regular language (As @StefanPochmann pointed out, regular languages are also context-free, so context-free doesn't necessarily mean not regular). The only thing you can do with regexps on HTML is heuristics but that will not work on every condition. It should be possible to present a HTML file that will be matched wrongly by any regular expression.</p>
    </div></div></div></div><div id="solution2" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 2</h1><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>For quick´n´dirty regexp will do fine.  But the fundamental thing to know is that it is <em>impossible</em> to construct a regexp that will <em>correctly</em> parse HTML.</p>

<p>The reason is that regexps cant handle arbitarly nested expressions.  See <a href="https://stackoverflow.com/questions/133601/can-regular-expressions-be-used-to-match-nested-patterns">Can regular expressions be used to match nested patterns?</a></p>
    </div></div></div></div><div id="solution3" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 3</h1><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>(From <a href="http://htmlparsing.com/regexes" rel="noreferrer">http://htmlparsing.com/regexes</a>)</p>

<p>Say you've got a file of HTML where you're trying to extract URLs from
&lt;img&gt; tags.</p>

<pre class="default s-code-block"><code class="hljs language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"http://example.com/whatever.jpg"</span>&gt;</span>
</code></pre>

<p>So you write a regex like this in Perl:</p>

<pre class="default s-code-block"><code class="hljs language-bash"><span class="hljs-keyword">if</span> ( <span class="hljs-variable">$html</span> =~ /&lt;img src=<span class="hljs-string">"(.+)"</span>/ ) {
    <span class="hljs-variable">$url</span> = <span class="hljs-variable">$1</span>;
}
</code></pre>

<p>In this case, <code>$url</code> will indeed contain
<code>http://example.com/whatever.jpg</code>.  But what happens when
you start getting HTML like this:</p>

<pre class="default s-code-block"><code class="hljs language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">'http://example.com/whatever.jpg'</span>&gt;</span>
</code></pre>

<p>or</p>

<pre class="default s-code-block"><code class="hljs language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">http://example.com/whatever.jpg</span>&gt;</span>
</code></pre>

<p>or</p>

<pre class="default s-code-block"><code class="hljs language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">border</span>=<span class="hljs-string">0</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"http://example.com/whatever.jpg"</span>&gt;</span>
</code></pre>

<p>or</p>

<pre class="default s-code-block"><code class="hljs language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">img</span>
    <span class="hljs-attr">src</span>=<span class="hljs-string">"http://example.com/whatever.jpg"</span>&gt;</span>
</code></pre>

<p>or you start getting false positives from</p>

<pre class="default s-code-block"><code class="hljs language-xml"><span class="hljs-comment">&lt;!-- // commented out
&lt;img src="http://example.com/outdated.png"&gt;
--&gt;</span>
</code></pre>

<p>It looks so simple, and it might be simple for a single, unchanging file, but for anything that you're going to be doing on arbitrary HTML data, regexes are just a recipe for future heartache.</p>
    </div></div></div></div><div id="solution4" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 4</h1><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Two quick reasons:</p>

<ul>
<li>writing a regex that can stand up to malicious input is hard; way harder than using a prebuilt tool</li>
<li>writing a regex that can work with the ridiculous markup that you will inevitably be stuck with is hard; way harder than using a prebuilt tool</li>
</ul>

<p>Regarding the suitability of regexes for parsing in general: they aren't suitable. Have you ever seen the sorts of regexes you would need to parse most languages?</p>
    </div></div></div></div><div id="solution5" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 5</h1><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>As far as parsing goes, regular expressions can be useful in the "lexical analysis" (lexer) stage, where the input is broken down into tokens. It's less useful in the actual "build a parse tree" stage.</p>

<p>For an HTML parser, I'd expect it to only accept well-formed HTML and that requires capabilities outside what a regular expression can do (they cannot "count" and make sure that a given number of opening elements are balanced by the same number of closing elements).</p>
    </div></div></div></div><div id="solution6" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 6</h1><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Because there are many ways to "screw up" HTML that browsers will treat in a rather liberal way but it would take quite some effort to reproduce the browser's liberal behaviour to cover all cases with regular expressions, so your regex will inevitably fail on some special cases, and that would possibly introduce serious security gaps in your system.</p>
    </div></div></div></div><div id="solution7" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 7</h1><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>The problem is that most users who ask a question that has to do with HTML and regex do this because they can't find an own regex that works. Then one has to think whether everything would be easier when using a DOM or SAX parser or something similar. They are optimized and constructed for the purpose of working with XML-like document structures.</p>

<p>Sure, there are problems that can be solved easily with regular expressions. But the emphasis lies on <strong>easily</strong>. </p>

<p>If you just want to find all URLs that look like <code>http://.../</code> you're fine with regexps. But if you want to find all URLs that are in a a-Element that has the class 'mylink' you probably better use a appropriate parser.</p>
    </div></div></div></div><div id="solution8" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 8</h1><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Regular expressions were not designed to handle a nested tag structure, and it is at best complicated (at worst, impossible) to handle all the possible edge cases you get with real HTML.</p>
    </div></div></div></div><div id="solution9" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 9</h1><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>I believe that the answer lies in computation theory. For a language to be parsed using regex it must be by definition "regular" (<a href="http://en.wikipedia.org/wiki/Regular_language" rel="noreferrer">link</a>). HTML is not a regular language as it does not meet a number of criteria for a regular language (much to do with the many levels of nesting inherent in html code). If you are interested in the theory of computation I would recommend <a href="http://books.google.co.uk/books?id=eRYFAAAACAAJ&amp;dq=theory+of+computation&amp;ei=WqimSamaGYvCMvCFrIQO" rel="noreferrer">this</a> book.</p>
    </div></div></div></div><div id="solution10" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 10</h1><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>HTML/XML is divided into markup and content. 
Regex is only useful doing a lexical tag parse.
I guess you could deduce the content.
It would be a good choice for a SAX parser.
Tags and content could be delivered to a user
defined function where nesting/closure of elements
can be kept track of.  </p>

<p>As far as just parsing the tags, it can be done with
regex and used to strip tags from a document.</p>

<p>Over years of testing, I've found the secret to the
way browsers parse tags, both well and ill formed.  </p>

<p>The normal elements are parsed with this form:</p>

<p>The core of these tags use this regex</p>

<pre class="default s-code-block"><code class="hljs language-lisp"> (?:
      <span class="hljs-string">" [\S\s]*? "</span> 
   |  ' [\S\s]*? ' 
   |  [^&gt;]? 
 )+
</code></pre>

<p>You'll notice this <code>[^&gt;]?</code> as one of the alternations.
This will match unbalanced quotes from ill-formed tags.  </p>

<p>It is also, the single most <em>root of all evil</em> to regular expressions.
The way it's used will trigger a bump-along to satisfy it's greedy, must-match
quantified container.  </p>

<p>If used passively, there is never a problem
But, if you <em>force</em> something to match by interspersing it with
a wanted attribute/value pair, and don't provide adequate protection
from backtracking, it's an out of control nightmare.</p>

<p>This is the general form for just plain old tags.
Notice the  <code>[\w:]</code> representing the tag name?
In reality, the <em>legal</em> characters representing the tag name
are an incredible list of Unicode characters.  </p>

<pre class="default s-code-block"><code class="hljs language-lisp"> &lt;     
 (?:
      [\w:]+ 
      \s+ 
      (?:
           <span class="hljs-string">" [\S\s]*? "</span> 
        |  ' [\S\s]*? ' 
        |  [^&gt;]? 
      )+
      \s* /?
 )
 &gt;
</code></pre>

<hr>

<p>Moving on, we also see that you just can't search for a specific tag
without parsing <em>ALL</em> tags.
I mean you could, but it would have to use a combination of
verbs like (*SKIP)(*FAIL) but still all tags have to be parsed.</p>

<p>The reason is that tag syntax may be hidden inside other tags, etc.</p>

<p>So, to passively parse all tags, a regex is needed like the one below.
This particular one matches <em>invisible content</em> as well.</p>

<p>As new HTML or xml or any other develop new constructs, just add it as
one of the alternations. </p>

<hr>

<p><em>Web page note - I've never seen a web page (or xhtml/xml) that this<br>
had trouble with. If you find one, let me know.</em>  </p>

<p><em>Performance note - It's quick. This is the fastest tag parser I've seen<br>
(there may be faster, who knows).<br>
I have several specific versions.  It is also excellent as scraper<br>
(if you're the hands-on type).</em></p>

<hr>

<p>Complete raw regex  </p>

<p><code>&lt;(?:(?:(?:(script|style|object|embed|applet|noframes|noscript|noembed)(?:\s+(?&gt;"[\S\s]*?"|'[\S\s]*?'|(?:(?!/&gt;)[^&gt;])?)+)?\s*&gt;)[\S\s]*?&lt;/\1\s*(?=&gt;))|(?:/?[\w:]+\s*/?)|(?:[\w:]+\s+(?:"[\S\s]*?"|'[\S\s]*?'|[^&gt;]?)+\s*/?)|\?[\S\s]*?\?|(?:!(?:(?:DOCTYPE[\S\s]*?)|(?:\[CDATA\[[\S\s]*?\]\])|(?:--[\S\s]*?--)|(?:ATTLIST[\S\s]*?)|(?:ENTITY[\S\s]*?)|(?:ELEMENT[\S\s]*?))))&gt;</code>  </p>

<p>Formatted look  </p>

<pre class="default s-code-block"><code class="hljs language-lisp"> &lt;
 (?:
      (?:
           (?:
                # Invisible content<span class="hljs-comment">; end tag req'd</span>
                (                             <span class="hljs-name">#</span> (<span class="hljs-number">1</span> start)
                     script
                  |  style
                  |  object
                  |  embed
                  |  applet
                  |  noframes
                  |  noscript
                  |  noembed 
                )                             # (1 end)
                (?:
                     \s+ 
                     (?&gt;
                          " [\S\s]*? "
                       |  ' [\S\s]*? '
                       |  (?:
                               (?! /&gt; )
                               [^&gt;] 
                          )?
                     )+
                )?
                \s* &gt;
           )

           [\S\s]*? &lt;/ \1 \s* 
           (?= &gt; )
      )

   |  (?: /? [\w:]+ \s* /? )
   |  (?:
           [\w:]+ 
           \s+ 
           (?:
                <span class="hljs-string">" [\S\s]*? "</span> 
             |  ' [\S\s]*? ' 
             |  [^&gt;]? 
           )+
           \s* /?
      )
   |  \? [\S\s]*? \?
   |  (?:
           !
           (?:
                (?: DOCTYPE [\S\s]*? )
             |  (?: \[CDATA\[ [\S\s]*? \]\] )
             |  (?: -- [\S\s]*? -- )
             |  (?: ATTLIST [\S\s]*? )
             |  (?: ENTITY [\S\s]*? )
             |  (?: ELEMENT [\S\s]*? )
           )
      )
 )
 &gt;
</code></pre>
    </div></div></div></div><div id="solution11" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 11</h1><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>This expression retrieves attributes from HTML elements. It supports:</p>

<ul>
<li>unquoted / quoted attributes,</li>
<li>single / double quotes,</li>
<li>escaped quotes inside attributes,</li>
<li>spaces around equals signs,</li>
<li>any number of attributes,</li>
<li>check only for attributes inside tags,</li>
<li>escape comments, and</li>
<li>manage different quotes within an attribute value.</li>
</ul>

<p><code>(?:\&lt;\!\-\-(?:(?!\-\-\&gt;)\r\n?|\n|.)*?-\-\&gt;)|(?:&lt;(\S+)\s+(?=.*&gt;)|(?&lt;=[=\s])\G)(?:((?:(?!\s|=).)*)\s*?=\s*?[\"']?((?:(?&lt;=\")(?:(?&lt;=\\)\"|[^\"])*|(?&lt;=')(?:(?&lt;=\\)'|[^'])*)|(?:(?!\"|')(?:(?!\/&gt;|&gt;|\s).)+))[\"']?\s*)</code></p>

<p><a href="https://regex101.com/r/wRD0zq/1" rel="nofollow noreferrer">Check it out</a>. It works better with the "gisx" flags, as in the demo.</p>
    </div></div></div></div><div id="solution12" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 12</h1><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>"It depends" though. It's true that regexes don't and can't parse HTML with true accuracy, for all the reasons given here. If, however, the consequences of getting it wrong (such as not handling nested tags) are minor, and if regexes are super-convenient in your environment (such as when you're hacking Perl), go ahead.</p>

<p>Suppose you're, oh, maybe parsing web pages that link to your site--perhaps you found them with a Google link search--and you want a quick way to get a general idea of the context surround your link. You're trying to run a little report that might alert you to link spam, something like that.</p>

<p>In that case, misparsing some of the documents isn't going to be a big deal. Nobody but you will see the mistakes, and if you're very lucky there will be few enough that you can follow up individually.</p>

<p>I guess I'm saying it's a tradeoff. Sometimes implementing or using a correct parser--as easy as that may be--might not be worth the trouble if accuracy isn't critical.</p>

<p>Just be careful with your assumptions. I can think of a few ways the regexp shortcut can backfire if you're trying to parse something that will be shown in public, for example.</p>
    </div></div></div></div><div id="solution13" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 13</h1><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>There are definitely cases where using a regular expression to parse some information from HTML is the correct way to go - it depends a lot on the specific situation.</p>

<p>The consensus above is that in general it is a bad idea. However if the HTML structure is known (and unlikely to change) then it is still a valid approach.</p>
    </div></div></div></div><div id="solution14" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 14</h1><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Keep in mind that while HTML itself isn't regular, portions of a page you are looking at <em>might</em> be regular.</p>

<p>For example, it is an error for <code>&lt;form&gt;</code> tags to be nested; if the web page is working correctly, then using a regular expression to grab a <code>&lt;form&gt;</code> would be completely reasonable.</p>

<p>I recently did some web scraping using only Selenium and regular expressions.  I got away with it because the data I wanted was put in a <code>&lt;form&gt;</code>, and put in a simple table format (so I could even count on <code>&lt;table&gt;</code>, <code>&lt;tr&gt;</code> and <code>&lt;td&gt;</code> to be non-nested--which is actually highly unusual).  In some degree, regular expressions were even almost necessary, because some of the structure I needed to access was delimited by comments.  (Beautiful Soup can give you comments, but it would have been difficult to grab <code>&lt;!-- BEGIN --&gt;</code> and <code>&lt;!-- END --&gt;</code> blocks using Beautiful Soup.)</p>

<p>If I had to worry about nested tables, however, my approach simply would not have worked!  I would have had to fall back on Beautiful Soup.  Even then, however, sometimes you can use a regular expression to grab the chunk you need, and then drill down from there.</p>
    </div></div></div></div><div id="solution15" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 15</h1><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Actually, HTML parsing with regex is perfectly possible in PHP. You just have to parse the whole string backwards using <code>strrpos</code> to find <code>&lt;</code> and repeat the regex from there using ungreedy specifiers each time to get over nested tags. Not fancy and terribly slow on large things, but I used it for my own personal template editor for my website. I wasn't actually parsing HTML, but a few custom tags I made for querying database entries to display tables of data (my <code>&lt;#if()&gt;</code> tag could highlight special entries this way). I wasn't prepared to go for an XML parser on just a couple of self created tags (with very non-XML data within them) here and there.</p>

<p>So, even though this question is considerably dead, it still shows up in a Google search. I read it and thought "challenge accepted" and finished fixing my simple code without having to replace everything. Decided to offer a different opinion to anyone searching for a similar reason. Also the last answer was posted 4 hours ago so this is still a hot topic.</p>
    </div></div></div></div><div id="solution16" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 16</h1><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>I tried my hand at a regex for this too. It's mostly useful for finding chunks of content paired with the next HTML tag, and it doesn't look for <strong><em>matching</em></strong> close tags, but it will pick up close tags. Roll a stack in your own language to check those. </p>

<p>Use with 'sx' options.  'g' too if you're feeling lucky:</p>

<pre class="default s-code-block"><code class="hljs language-php-template"><span class="language-xml">(?P<span class="hljs-tag">&lt;<span class="hljs-name">content</span>&gt;</span>.*?)                # Content up to next tag
(?P<span class="hljs-tag">&lt;<span class="hljs-name">markup</span>&gt;</span>                     # Entire tag
  &lt;!\[CDATA\[(?P<span class="hljs-tag">&lt;<span class="hljs-name">cdata</span>&gt;</span>.+?)]]&gt;| # &lt;![CDATA[ ... ]]&gt;
  <span class="hljs-comment">&lt;!--(?P&lt;comment&gt;.+?)--&gt;</span>|      # <span class="hljs-comment">&lt;!-- Comment --&gt;</span>
  &lt;/\s*(?P<span class="hljs-tag">&lt;<span class="hljs-name">close_tag</span>&gt;</span>\w+)\s*&gt;|  # <span class="hljs-tag">&lt;/<span class="hljs-name">tag</span>&gt;</span>
  &lt;(?P<span class="hljs-tag">&lt;<span class="hljs-name">tag</span>&gt;</span>\w+)                 # <span class="hljs-tag">&lt;<span class="hljs-name">tag</span> <span class="hljs-attr">...</span>
    (?<span class="hljs-attr">P</span>&lt;<span class="hljs-attr">attributes</span>&gt;</span>
      (?P<span class="hljs-tag">&lt;<span class="hljs-name">attribute</span>&gt;</span>\s+
# <span class="hljs-tag">&lt;<span class="hljs-name">snip</span>&gt;</span>: Use this part to get the attributes out of 'attributes' group.
        (?P<span class="hljs-tag">&lt;<span class="hljs-name">attribute_name</span>&gt;</span>\w+)
        (?:\s*=\s*
          (?P<span class="hljs-tag">&lt;<span class="hljs-name">attribute_value</span>&gt;</span>
            [\w:/.\-]+|         # Unquoted
            (?=(?P<span class="hljs-tag">&lt;<span class="hljs-name">_v</span>&gt;</span>          # Quoted
              (?P<span class="hljs-tag">&lt;<span class="hljs-name">_q</span>&gt;</span>['\"]).*?(?&lt;!\\)(?P=_q)))
            (?P=_v)
          ))?
# <span class="hljs-tag">&lt;/<span class="hljs-name">snip</span>&gt;</span>
      )*
    )\s*
  (?P<span class="hljs-tag">&lt;<span class="hljs-name">is_self_closing</span>&gt;</span>/?)   # Self-closing indicator
  &gt;)                        # End of tag
</span></code></pre>

<p>This one is designed for Python (it might work for other languages, haven't tried it, it uses positive lookaheads, negative lookbehinds, and named backreferences).  Supports:</p>

<ul>
<li>Open Tag - <code>&lt;div ...&gt;</code></li>
<li>Close Tag - <code>&lt;/div&gt;</code></li>
<li>Comment - <code>&lt;!-- ... --&gt;</code></li>
<li>CDATA - <code>&lt;![CDATA[ ... ]]&gt;</code></li>
<li>Self-Closing Tag - <code>&lt;div .../&gt;</code></li>
<li>Optional Attribute Values - <code>&lt;input checked&gt;</code></li>
<li>Unquoted / Quoted Attribute Values - <code>&lt;div style='...'&gt;</code></li>
<li>Single / Double Quotes - <code>&lt;div style="..."&gt;</code></li>
<li>Escaped Quotes - <code>&lt;a title='John\'s Story'&gt;</code><br>
<em>(this isn't really valid HTML, but I'm a nice guy)</em></li>
<li>Spaces Around Equals Signs - <code>&lt;a href = '...'&gt;</code></li>
<li>Named Captures For Interesting Bits</li>
</ul>

<p>It's also pretty good about not triggering on malformed tags, like when you forget a <code>&lt;</code> or <code>&gt;</code>.</p>

<p>If your regex flavor supports repeated named captures then you're golden, but Python <code>re</code> doesn't (I know regex does, but I need to use vanilla Python). Here's what you get:</p>

<ul>
<li><code>content</code> - All of the content up to the next tag. You could leave this out.</li>
<li><code>markup</code> - The entire tag with everything in it.</li>
<li><code>comment</code> - If it's a comment, the comment contents.</li>
<li><code>cdata</code> - If it's a <code>&lt;![CDATA[...]]&gt;</code>, the CDATA contents.</li>
<li><code>close_tag</code> - If it's a close tag (<code>&lt;/div&gt;</code>), the tag name.</li>
<li><code>tag</code> - If it's an open tag (<code>&lt;div&gt;</code>), the tag name.</li>
<li><code>attributes</code> - All attributes inside the tag. Use this to get all attributes if you don't get repeated groups.</li>
<li><code>attribute</code> - Repeated, each attribute.</li>
<li><code>attribute_name</code> - Repeated, each attribute name.</li>
<li><code>attribute_value</code> - Repeated, each attribute value. This includes the quotes if it was quoted.</li>
<li><code>is_self_closing</code> - This is <code>/</code> if it's a self-closing tag, otherwise nothing.</li>
<li><code>_q</code> and <code>_v</code> - Ignore these; they're used internally for backreferences.</li>
</ul>

<p>If your regex engine doesn't support repeated named captures, there's a section called out that you can use to get each attribute. Just run that regex on the <code>attributes</code> group to get each <code>attribute</code>, <code>attribute_name</code> and <code>attribute_value</code> out of it.</p>

<p>Demo here: <a href="https://regex101.com/r/mH8jSu/11" rel="nofollow noreferrer">https://regex101.com/r/mH8jSu/11</a></p>
    </div></div></div></div><div id="solution17" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 17</h1><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Regular expressions are not powerful enough for such a language like HTML. Sure, there are some examples where you can use regular expressions. But in general it is not appropriate for parsing.</p>
    </div></div></div></div><div id="solution18" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 18</h1><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>You, know...there's a lot of mentality of you <strong>CAN'T</strong> do it and I think that everyone on both sides of the fence are right and wrong.  You <strong>CAN</strong> do it, but it takes a little more processing than just running one regex against it.  Take <a href="http://bit.ly/1MKKkXh" rel="nofollow">this</a> (I wrote this inside of an hour) as an example.  It assumes the HTML is completely valid, but depending on what language you're using to apply the aforementioned regex, you could do some fixing of the HTML to make sure that it will succeed.  For example, removing closing tags that are not supposed to be there: <em><code>&lt;/img&gt;</code></em> for example.  Then, add the closing single HTML forward slash to elements that are missing them, etc.</p>

<p>I'd use this in the context of writing a library that would allow me to perform HTML element retrieval akin to that of JavaScript's <code>[x].getElementsByTagName()</code>, for example.  I'd just splice up the functionality I wrote in the DEFINE section of the regex and use it for stepping inside of a tree of elements, one at time.</p>

<p>So, will this be the final 100% answer for validating HTML?  No.  But it's a start and with a little more work, it can be done.  However, trying to do it inside of one regex execution is not practical, nor efficient.</p>
    </div></div></div></div></div></div><div class="widget"><a href="/questions/asynctask-android-example-1657388127898">AsyncTask Android example</a><a href="/questions/how-do-i-use-shell-variables-in-an-awk-script-1657387754261">How do I use shell variables in an awk script?</a><a href="/questions/how-can-i-sort-arrays-and-data-in-php-1657384726665">How can I sort arrays and data in PHP?</a><a href="/questions/split-comma-separated-strings-in-a-column-into-separate-rows-1657387785823">Split comma-separated strings in a column into separate rows</a><a href="/questions/error:-could-not-find-function-...-in-r-1657388476492">Error: could not find function ... in R</a><a href="/questions/removing-duplicates-in-lists-1657388207448">Removing duplicates in lists</a><a href="/questions/how-to-use-java.util.scanner-to-correctly-read-user-input-from-system.in-and-act-on-it-1657388546306">How to use java.util.Scanner to correctly read user input from System.in and act on it?</a><a href="/questions/how-can-i-iterate-through-two-lists-in-parallel-1657387278930">How can I iterate through two lists in parallel?</a><a href="/questions/how-do-you-parse-and-process-htmlxml-in-php-1657384351267">How do you parse and process HTML/XML in PHP?</a><a href="/questions/how-to-remove-items-from-a-list-while-iterating-1657384496375">How to remove items from a list while iterating?</a><a href="/questions/http-get-with-request-body-1657387379038">HTTP GET with request body</a><a href="/questions/why-aren&#x27;t-variable-length-arrays-part-of-the-c++-standard-1657384712975">Why aren&#x27;t variable-length arrays part of the C++ standard?</a><a href="/questions/short-description-of-the-scoping-rules-1657384853121">Short description of the scoping rules?</a><a href="/questions/xmlhttprequest-cannot-load-xxx-no-&#x27;access-control-allow-origin&#x27;-header-1657384758362">XMLHttpRequest cannot load XXX No &#x27;Access-Control-Allow-Origin&#x27; header</a><a href="/questions/importing-files-from-different-folder-1657388203798">Importing files from different folder</a><a href="/questions/submit-same-partial-view-called-multiple-times-data-to-controller-1657387887213">Submit same Partial View called multiple times data to controller?</a><a href="/questions/what-is-the-difference-between-__str__-and-__repr__-1657387738760">What is the difference between __str__ and __repr__?</a><a href="/questions/using-limit-within-group-by-to-get-n-results-per-group-1657388324167">Using LIMIT within GROUP BY to get N results per group?</a><a href="/questions/what-is-move-semantics-1657387702625">What is move semantics?</a><a href="/questions/how-to-return-value-from-an-asynchronous-callback-function-duplicate-1657387545611">How to return value from an asynchronous callback function? [duplicate]</a></div></div><span class="cursor-pointer text-lg p-2" style="position:fixed;bottom:20px;left:20px;background:#000;z-index:2000;color:white">Go go top</span></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"data":{"answer":["\n\u0026lt;p\u0026gt;Entire HTML parsing is not possible with regular expressions, since it depends on matching the opening and the closing tag which is not possible with regexps.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Regular expressions can only match \u0026lt;a href=\u0026quot;http://en.wikipedia.org/wiki/Regular_grammar\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;regular languages\u0026lt;/a\u0026gt; but HTML is a \u0026lt;a href=\u0026quot;http://en.wikipedia.org/wiki/Context-free_grammar\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;context-free language\u0026lt;/a\u0026gt; and \u0026lt;em\u0026gt;not\u0026lt;/em\u0026gt; a regular language (As @StefanPochmann pointed out, regular languages are also context-free, so context-free doesn\u0026apos;t necessarily mean not regular). The only thing you can do with regexps on HTML is heuristics but that will not work on every condition. It should be possible to present a HTML file that will be matched wrongly by any regular expression.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;For quick´n´dirty regexp will do fine.  But the fundamental thing to know is that it is \u0026lt;em\u0026gt;impossible\u0026lt;/em\u0026gt; to construct a regexp that will \u0026lt;em\u0026gt;correctly\u0026lt;/em\u0026gt; parse HTML.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;The reason is that regexps cant handle arbitarly nested expressions.  See \u0026lt;a href=\u0026quot;https://stackoverflow.com/questions/133601/can-regular-expressions-be-used-to-match-nested-patterns\u0026quot;\u0026gt;Can regular expressions be used to match nested patterns?\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;(From \u0026lt;a href=\u0026quot;http://htmlparsing.com/regexes\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;http://htmlparsing.com/regexes\u0026lt;/a\u0026gt;)\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Say you\u0026apos;ve got a file of HTML where you\u0026apos;re trying to extract URLs from\n\u0026amp;lt;img\u0026amp;gt; tags.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;default s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-xml\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-tag\u0026quot;\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;img\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-attr\u0026quot;\u0026gt;src\u0026lt;/span\u0026gt;=\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;http://example.com/whatever.jpg\u0026quot;\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;So you write a regex like this in Perl:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;default s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-bash\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; ( \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$html\u0026lt;/span\u0026gt; =~ /\u0026amp;lt;img src=\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;(.+)\u0026quot;\u0026lt;/span\u0026gt;/ ) {\n    \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$url\u0026lt;/span\u0026gt; = \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$1\u0026lt;/span\u0026gt;;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;In this case, \u0026lt;code\u0026gt;$url\u0026lt;/code\u0026gt; will indeed contain\n\u0026lt;code\u0026gt;http://example.com/whatever.jpg\u0026lt;/code\u0026gt;.  But what happens when\nyou start getting HTML like this:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;default s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-xml\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-tag\u0026quot;\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;img\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-attr\u0026quot;\u0026gt;src\u0026lt;/span\u0026gt;=\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;http://example.com/whatever.jpg\u0026apos;\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;or\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;default s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-xml\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-tag\u0026quot;\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;img\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-attr\u0026quot;\u0026gt;src\u0026lt;/span\u0026gt;=\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;http://example.com/whatever.jpg\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;or\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;default s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-xml\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-tag\u0026quot;\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;img\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-attr\u0026quot;\u0026gt;border\u0026lt;/span\u0026gt;=\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-attr\u0026quot;\u0026gt;src\u0026lt;/span\u0026gt;=\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;http://example.com/whatever.jpg\u0026quot;\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;or\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;default s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-xml\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-tag\u0026quot;\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;img\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-attr\u0026quot;\u0026gt;src\u0026lt;/span\u0026gt;=\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;http://example.com/whatever.jpg\u0026quot;\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;or you start getting false positives from\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;default s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-xml\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;\u0026amp;lt;!-- // commented out\n\u0026amp;lt;img src=\u0026quot;http://example.com/outdated.png\u0026quot;\u0026amp;gt;\n--\u0026amp;gt;\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;It looks so simple, and it might be simple for a single, unchanging file, but for anything that you\u0026apos;re going to be doing on arbitrary HTML data, regexes are just a recipe for future heartache.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Two quick reasons:\u0026lt;/p\u0026gt;\n\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;writing a regex that can stand up to malicious input is hard; way harder than using a prebuilt tool\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;writing a regex that can work with the ridiculous markup that you will inevitably be stuck with is hard; way harder than using a prebuilt tool\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\n\u0026lt;p\u0026gt;Regarding the suitability of regexes for parsing in general: they aren\u0026apos;t suitable. Have you ever seen the sorts of regexes you would need to parse most languages?\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;As far as parsing goes, regular expressions can be useful in the \u0026quot;lexical analysis\u0026quot; (lexer) stage, where the input is broken down into tokens. It\u0026apos;s less useful in the actual \u0026quot;build a parse tree\u0026quot; stage.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;For an HTML parser, I\u0026apos;d expect it to only accept well-formed HTML and that requires capabilities outside what a regular expression can do (they cannot \u0026quot;count\u0026quot; and make sure that a given number of opening elements are balanced by the same number of closing elements).\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Because there are many ways to \u0026quot;screw up\u0026quot; HTML that browsers will treat in a rather liberal way but it would take quite some effort to reproduce the browser\u0026apos;s liberal behaviour to cover all cases with regular expressions, so your regex will inevitably fail on some special cases, and that would possibly introduce serious security gaps in your system.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;The problem is that most users who ask a question that has to do with HTML and regex do this because they can\u0026apos;t find an own regex that works. Then one has to think whether everything would be easier when using a DOM or SAX parser or something similar. They are optimized and constructed for the purpose of working with XML-like document structures.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Sure, there are problems that can be solved easily with regular expressions. But the emphasis lies on \u0026lt;strong\u0026gt;easily\u0026lt;/strong\u0026gt;. \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;If you just want to find all URLs that look like \u0026lt;code\u0026gt;http://.../\u0026lt;/code\u0026gt; you\u0026apos;re fine with regexps. But if you want to find all URLs that are in a a-Element that has the class \u0026apos;mylink\u0026apos; you probably better use a appropriate parser.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Regular expressions were not designed to handle a nested tag structure, and it is at best complicated (at worst, impossible) to handle all the possible edge cases you get with real HTML.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;I believe that the answer lies in computation theory. For a language to be parsed using regex it must be by definition \u0026quot;regular\u0026quot; (\u0026lt;a href=\u0026quot;http://en.wikipedia.org/wiki/Regular_language\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;link\u0026lt;/a\u0026gt;). HTML is not a regular language as it does not meet a number of criteria for a regular language (much to do with the many levels of nesting inherent in html code). If you are interested in the theory of computation I would recommend \u0026lt;a href=\u0026quot;http://books.google.co.uk/books?id=eRYFAAAACAAJ\u0026amp;amp;dq=theory+of+computation\u0026amp;amp;ei=WqimSamaGYvCMvCFrIQO\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;this\u0026lt;/a\u0026gt; book.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;HTML/XML is divided into markup and content. \nRegex is only useful doing a lexical tag parse.\nI guess you could deduce the content.\nIt would be a good choice for a SAX parser.\nTags and content could be delivered to a user\ndefined function where nesting/closure of elements\ncan be kept track of.  \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;As far as just parsing the tags, it can be done with\nregex and used to strip tags from a document.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Over years of testing, I\u0026apos;ve found the secret to the\nway browsers parse tags, both well and ill formed.  \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;The normal elements are parsed with this form:\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;The core of these tags use this regex\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;default s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-lisp\u0026quot;\u0026gt; (?:\n      \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot; [\\S\\s]*? \u0026quot;\u0026lt;/span\u0026gt; \n   |  \u0026apos; [\\S\\s]*? \u0026apos; \n   |  [^\u0026amp;gt;]? \n )+\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;You\u0026apos;ll notice this \u0026lt;code\u0026gt;[^\u0026amp;gt;]?\u0026lt;/code\u0026gt; as one of the alternations.\nThis will match unbalanced quotes from ill-formed tags.  \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;It is also, the single most \u0026lt;em\u0026gt;root of all evil\u0026lt;/em\u0026gt; to regular expressions.\nThe way it\u0026apos;s used will trigger a bump-along to satisfy it\u0026apos;s greedy, must-match\nquantified container.  \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;If used passively, there is never a problem\nBut, if you \u0026lt;em\u0026gt;force\u0026lt;/em\u0026gt; something to match by interspersing it with\na wanted attribute/value pair, and don\u0026apos;t provide adequate protection\nfrom backtracking, it\u0026apos;s an out of control nightmare.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;This is the general form for just plain old tags.\nNotice the  \u0026lt;code\u0026gt;[\\w:]\u0026lt;/code\u0026gt; representing the tag name?\nIn reality, the \u0026lt;em\u0026gt;legal\u0026lt;/em\u0026gt; characters representing the tag name\nare an incredible list of Unicode characters.  \u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;default s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-lisp\u0026quot;\u0026gt; \u0026amp;lt;     \n (?:\n      [\\w:]+ \n      \\s+ \n      (?:\n           \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot; [\\S\\s]*? \u0026quot;\u0026lt;/span\u0026gt; \n        |  \u0026apos; [\\S\\s]*? \u0026apos; \n        |  [^\u0026amp;gt;]? \n      )+\n      \\s* /?\n )\n \u0026amp;gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;hr\u0026gt;\n\n\u0026lt;p\u0026gt;Moving on, we also see that you just can\u0026apos;t search for a specific tag\nwithout parsing \u0026lt;em\u0026gt;ALL\u0026lt;/em\u0026gt; tags.\nI mean you could, but it would have to use a combination of\nverbs like (*SKIP)(*FAIL) but still all tags have to be parsed.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;The reason is that tag syntax may be hidden inside other tags, etc.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;So, to passively parse all tags, a regex is needed like the one below.\nThis particular one matches \u0026lt;em\u0026gt;invisible content\u0026lt;/em\u0026gt; as well.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;As new HTML or xml or any other develop new constructs, just add it as\none of the alternations. \u0026lt;/p\u0026gt;\n\n\u0026lt;hr\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;em\u0026gt;Web page note - I\u0026apos;ve never seen a web page (or xhtml/xml) that this\u0026lt;br\u0026gt;\nhad trouble with. If you find one, let me know.\u0026lt;/em\u0026gt;  \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;em\u0026gt;Performance note - It\u0026apos;s quick. This is the fastest tag parser I\u0026apos;ve seen\u0026lt;br\u0026gt;\n(there may be faster, who knows).\u0026lt;br\u0026gt;\nI have several specific versions.  It is also excellent as scraper\u0026lt;br\u0026gt;\n(if you\u0026apos;re the hands-on type).\u0026lt;/em\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;hr\u0026gt;\n\n\u0026lt;p\u0026gt;Complete raw regex  \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;code\u0026gt;\u0026amp;lt;(?:(?:(?:(script|style|object|embed|applet|noframes|noscript|noembed)(?:\\s+(?\u0026amp;gt;\u0026quot;[\\S\\s]*?\u0026quot;|\u0026apos;[\\S\\s]*?\u0026apos;|(?:(?!/\u0026amp;gt;)[^\u0026amp;gt;])?)+)?\\s*\u0026amp;gt;)[\\S\\s]*?\u0026amp;lt;/\\1\\s*(?=\u0026amp;gt;))|(?:/?[\\w:]+\\s*/?)|(?:[\\w:]+\\s+(?:\u0026quot;[\\S\\s]*?\u0026quot;|\u0026apos;[\\S\\s]*?\u0026apos;|[^\u0026amp;gt;]?)+\\s*/?)|\\?[\\S\\s]*?\\?|(?:!(?:(?:DOCTYPE[\\S\\s]*?)|(?:\\[CDATA\\[[\\S\\s]*?\\]\\])|(?:--[\\S\\s]*?--)|(?:ATTLIST[\\S\\s]*?)|(?:ENTITY[\\S\\s]*?)|(?:ELEMENT[\\S\\s]*?))))\u0026amp;gt;\u0026lt;/code\u0026gt;  \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Formatted look  \u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;default s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-lisp\u0026quot;\u0026gt; \u0026amp;lt;\n (?:\n      (?:\n           (?:\n                # Invisible content\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;; end tag req\u0026apos;d\u0026lt;/span\u0026gt;\n                (                             \u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;#\u0026lt;/span\u0026gt; (\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt; start)\n                     script\n                  |  style\n                  |  object\n                  |  embed\n                  |  applet\n                  |  noframes\n                  |  noscript\n                  |  noembed \n                )                             # (1 end)\n                (?:\n                     \\s+ \n                     (?\u0026amp;gt;\n                          \u0026quot; [\\S\\s]*? \u0026quot;\n                       |  \u0026apos; [\\S\\s]*? \u0026apos;\n                       |  (?:\n                               (?! /\u0026amp;gt; )\n                               [^\u0026amp;gt;] \n                          )?\n                     )+\n                )?\n                \\s* \u0026amp;gt;\n           )\n\n           [\\S\\s]*? \u0026amp;lt;/ \\1 \\s* \n           (?= \u0026amp;gt; )\n      )\n\n   |  (?: /? [\\w:]+ \\s* /? )\n   |  (?:\n           [\\w:]+ \n           \\s+ \n           (?:\n                \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot; [\\S\\s]*? \u0026quot;\u0026lt;/span\u0026gt; \n             |  \u0026apos; [\\S\\s]*? \u0026apos; \n             |  [^\u0026amp;gt;]? \n           )+\n           \\s* /?\n      )\n   |  \\? [\\S\\s]*? \\?\n   |  (?:\n           !\n           (?:\n                (?: DOCTYPE [\\S\\s]*? )\n             |  (?: \\[CDATA\\[ [\\S\\s]*? \\]\\] )\n             |  (?: -- [\\S\\s]*? -- )\n             |  (?: ATTLIST [\\S\\s]*? )\n             |  (?: ENTITY [\\S\\s]*? )\n             |  (?: ELEMENT [\\S\\s]*? )\n           )\n      )\n )\n \u0026amp;gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;This expression retrieves attributes from HTML elements. It supports:\u0026lt;/p\u0026gt;\n\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;unquoted / quoted attributes,\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;single / double quotes,\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;escaped quotes inside attributes,\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;spaces around equals signs,\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;any number of attributes,\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;check only for attributes inside tags,\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;escape comments, and\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;manage different quotes within an attribute value.\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;code\u0026gt;(?:\\\u0026amp;lt;\\!\\-\\-(?:(?!\\-\\-\\\u0026amp;gt;)\\r\\n?|\\n|.)*?-\\-\\\u0026amp;gt;)|(?:\u0026amp;lt;(\\S+)\\s+(?=.*\u0026amp;gt;)|(?\u0026amp;lt;=[=\\s])\\G)(?:((?:(?!\\s|=).)*)\\s*?=\\s*?[\\\u0026quot;\u0026apos;]?((?:(?\u0026amp;lt;=\\\u0026quot;)(?:(?\u0026amp;lt;=\\\\)\\\u0026quot;|[^\\\u0026quot;])*|(?\u0026amp;lt;=\u0026apos;)(?:(?\u0026amp;lt;=\\\\)\u0026apos;|[^\u0026apos;])*)|(?:(?!\\\u0026quot;|\u0026apos;)(?:(?!\\/\u0026amp;gt;|\u0026amp;gt;|\\s).)+))[\\\u0026quot;\u0026apos;]?\\s*)\u0026lt;/code\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;a href=\u0026quot;https://regex101.com/r/wRD0zq/1\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;Check it out\u0026lt;/a\u0026gt;. It works better with the \u0026quot;gisx\u0026quot; flags, as in the demo.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;\u0026quot;It depends\u0026quot; though. It\u0026apos;s true that regexes don\u0026apos;t and can\u0026apos;t parse HTML with true accuracy, for all the reasons given here. If, however, the consequences of getting it wrong (such as not handling nested tags) are minor, and if regexes are super-convenient in your environment (such as when you\u0026apos;re hacking Perl), go ahead.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Suppose you\u0026apos;re, oh, maybe parsing web pages that link to your site--perhaps you found them with a Google link search--and you want a quick way to get a general idea of the context surround your link. You\u0026apos;re trying to run a little report that might alert you to link spam, something like that.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;In that case, misparsing some of the documents isn\u0026apos;t going to be a big deal. Nobody but you will see the mistakes, and if you\u0026apos;re very lucky there will be few enough that you can follow up individually.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;I guess I\u0026apos;m saying it\u0026apos;s a tradeoff. Sometimes implementing or using a correct parser--as easy as that may be--might not be worth the trouble if accuracy isn\u0026apos;t critical.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Just be careful with your assumptions. I can think of a few ways the regexp shortcut can backfire if you\u0026apos;re trying to parse something that will be shown in public, for example.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;There are definitely cases where using a regular expression to parse some information from HTML is the correct way to go - it depends a lot on the specific situation.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;The consensus above is that in general it is a bad idea. However if the HTML structure is known (and unlikely to change) then it is still a valid approach.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Keep in mind that while HTML itself isn\u0026apos;t regular, portions of a page you are looking at \u0026lt;em\u0026gt;might\u0026lt;/em\u0026gt; be regular.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;For example, it is an error for \u0026lt;code\u0026gt;\u0026amp;lt;form\u0026amp;gt;\u0026lt;/code\u0026gt; tags to be nested; if the web page is working correctly, then using a regular expression to grab a \u0026lt;code\u0026gt;\u0026amp;lt;form\u0026amp;gt;\u0026lt;/code\u0026gt; would be completely reasonable.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;I recently did some web scraping using only Selenium and regular expressions.  I got away with it because the data I wanted was put in a \u0026lt;code\u0026gt;\u0026amp;lt;form\u0026amp;gt;\u0026lt;/code\u0026gt;, and put in a simple table format (so I could even count on \u0026lt;code\u0026gt;\u0026amp;lt;table\u0026amp;gt;\u0026lt;/code\u0026gt;, \u0026lt;code\u0026gt;\u0026amp;lt;tr\u0026amp;gt;\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;\u0026amp;lt;td\u0026amp;gt;\u0026lt;/code\u0026gt; to be non-nested--which is actually highly unusual).  In some degree, regular expressions were even almost necessary, because some of the structure I needed to access was delimited by comments.  (Beautiful Soup can give you comments, but it would have been difficult to grab \u0026lt;code\u0026gt;\u0026amp;lt;!-- BEGIN --\u0026amp;gt;\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;\u0026amp;lt;!-- END --\u0026amp;gt;\u0026lt;/code\u0026gt; blocks using Beautiful Soup.)\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;If I had to worry about nested tables, however, my approach simply would not have worked!  I would have had to fall back on Beautiful Soup.  Even then, however, sometimes you can use a regular expression to grab the chunk you need, and then drill down from there.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Actually, HTML parsing with regex is perfectly possible in PHP. You just have to parse the whole string backwards using \u0026lt;code\u0026gt;strrpos\u0026lt;/code\u0026gt; to find \u0026lt;code\u0026gt;\u0026amp;lt;\u0026lt;/code\u0026gt; and repeat the regex from there using ungreedy specifiers each time to get over nested tags. Not fancy and terribly slow on large things, but I used it for my own personal template editor for my website. I wasn\u0026apos;t actually parsing HTML, but a few custom tags I made for querying database entries to display tables of data (my \u0026lt;code\u0026gt;\u0026amp;lt;#if()\u0026amp;gt;\u0026lt;/code\u0026gt; tag could highlight special entries this way). I wasn\u0026apos;t prepared to go for an XML parser on just a couple of self created tags (with very non-XML data within them) here and there.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;So, even though this question is considerably dead, it still shows up in a Google search. I read it and thought \u0026quot;challenge accepted\u0026quot; and finished fixing my simple code without having to replace everything. Decided to offer a different opinion to anyone searching for a similar reason. Also the last answer was posted 4 hours ago so this is still a hot topic.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;I tried my hand at a regex for this too. It\u0026apos;s mostly useful for finding chunks of content paired with the next HTML tag, and it doesn\u0026apos;t look for \u0026lt;strong\u0026gt;\u0026lt;em\u0026gt;matching\u0026lt;/em\u0026gt;\u0026lt;/strong\u0026gt; close tags, but it will pick up close tags. Roll a stack in your own language to check those. \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Use with \u0026apos;sx\u0026apos; options.  \u0026apos;g\u0026apos; too if you\u0026apos;re feeling lucky:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;default s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-php-template\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;language-xml\u0026quot;\u0026gt;(?P\u0026lt;span class=\u0026quot;hljs-tag\u0026quot;\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;content\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026lt;/span\u0026gt;.*?)                # Content up to next tag\n(?P\u0026lt;span class=\u0026quot;hljs-tag\u0026quot;\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;markup\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026lt;/span\u0026gt;                     # Entire tag\n  \u0026amp;lt;!\\[CDATA\\[(?P\u0026lt;span class=\u0026quot;hljs-tag\u0026quot;\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;cdata\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026lt;/span\u0026gt;.+?)]]\u0026amp;gt;| # \u0026amp;lt;![CDATA[ ... ]]\u0026amp;gt;\n  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;\u0026amp;lt;!--(?P\u0026amp;lt;comment\u0026amp;gt;.+?)--\u0026amp;gt;\u0026lt;/span\u0026gt;|      # \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;\u0026amp;lt;!-- Comment --\u0026amp;gt;\u0026lt;/span\u0026gt;\n  \u0026amp;lt;/\\s*(?P\u0026lt;span class=\u0026quot;hljs-tag\u0026quot;\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;close_tag\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026lt;/span\u0026gt;\\w+)\\s*\u0026amp;gt;|  # \u0026lt;span class=\u0026quot;hljs-tag\u0026quot;\u0026gt;\u0026amp;lt;/\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;tag\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026lt;/span\u0026gt;\n  \u0026amp;lt;(?P\u0026lt;span class=\u0026quot;hljs-tag\u0026quot;\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;tag\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026lt;/span\u0026gt;\\w+)                 # \u0026lt;span class=\u0026quot;hljs-tag\u0026quot;\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;tag\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-attr\u0026quot;\u0026gt;...\u0026lt;/span\u0026gt;\n    (?\u0026lt;span class=\u0026quot;hljs-attr\u0026quot;\u0026gt;P\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-attr\u0026quot;\u0026gt;attributes\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026lt;/span\u0026gt;\n      (?P\u0026lt;span class=\u0026quot;hljs-tag\u0026quot;\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;attribute\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026lt;/span\u0026gt;\\s+\n# \u0026lt;span class=\u0026quot;hljs-tag\u0026quot;\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;snip\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026lt;/span\u0026gt;: Use this part to get the attributes out of \u0026apos;attributes\u0026apos; group.\n        (?P\u0026lt;span class=\u0026quot;hljs-tag\u0026quot;\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;attribute_name\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026lt;/span\u0026gt;\\w+)\n        (?:\\s*=\\s*\n          (?P\u0026lt;span class=\u0026quot;hljs-tag\u0026quot;\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;attribute_value\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026lt;/span\u0026gt;\n            [\\w:/.\\-]+|         # Unquoted\n            (?=(?P\u0026lt;span class=\u0026quot;hljs-tag\u0026quot;\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;_v\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026lt;/span\u0026gt;          # Quoted\n              (?P\u0026lt;span class=\u0026quot;hljs-tag\u0026quot;\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;_q\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026lt;/span\u0026gt;[\u0026apos;\\\u0026quot;]).*?(?\u0026amp;lt;!\\\\)(?P=_q)))\n            (?P=_v)\n          ))?\n# \u0026lt;span class=\u0026quot;hljs-tag\u0026quot;\u0026gt;\u0026amp;lt;/\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;snip\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026lt;/span\u0026gt;\n      )*\n    )\\s*\n  (?P\u0026lt;span class=\u0026quot;hljs-tag\u0026quot;\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;is_self_closing\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026lt;/span\u0026gt;/?)   # Self-closing indicator\n  \u0026amp;gt;)                        # End of tag\n\u0026lt;/span\u0026gt;\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;This one is designed for Python (it might work for other languages, haven\u0026apos;t tried it, it uses positive lookaheads, negative lookbehinds, and named backreferences).  Supports:\u0026lt;/p\u0026gt;\n\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;Open Tag - \u0026lt;code\u0026gt;\u0026amp;lt;div ...\u0026amp;gt;\u0026lt;/code\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Close Tag - \u0026lt;code\u0026gt;\u0026amp;lt;/div\u0026amp;gt;\u0026lt;/code\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Comment - \u0026lt;code\u0026gt;\u0026amp;lt;!-- ... --\u0026amp;gt;\u0026lt;/code\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;CDATA - \u0026lt;code\u0026gt;\u0026amp;lt;![CDATA[ ... ]]\u0026amp;gt;\u0026lt;/code\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Self-Closing Tag - \u0026lt;code\u0026gt;\u0026amp;lt;div .../\u0026amp;gt;\u0026lt;/code\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Optional Attribute Values - \u0026lt;code\u0026gt;\u0026amp;lt;input checked\u0026amp;gt;\u0026lt;/code\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Unquoted / Quoted Attribute Values - \u0026lt;code\u0026gt;\u0026amp;lt;div style=\u0026apos;...\u0026apos;\u0026amp;gt;\u0026lt;/code\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Single / Double Quotes - \u0026lt;code\u0026gt;\u0026amp;lt;div style=\u0026quot;...\u0026quot;\u0026amp;gt;\u0026lt;/code\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Escaped Quotes - \u0026lt;code\u0026gt;\u0026amp;lt;a title=\u0026apos;John\\\u0026apos;s Story\u0026apos;\u0026amp;gt;\u0026lt;/code\u0026gt;\u0026lt;br\u0026gt;\n\u0026lt;em\u0026gt;(this isn\u0026apos;t really valid HTML, but I\u0026apos;m a nice guy)\u0026lt;/em\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Spaces Around Equals Signs - \u0026lt;code\u0026gt;\u0026amp;lt;a href = \u0026apos;...\u0026apos;\u0026amp;gt;\u0026lt;/code\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Named Captures For Interesting Bits\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\n\u0026lt;p\u0026gt;It\u0026apos;s also pretty good about not triggering on malformed tags, like when you forget a \u0026lt;code\u0026gt;\u0026amp;lt;\u0026lt;/code\u0026gt; or \u0026lt;code\u0026gt;\u0026amp;gt;\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;If your regex flavor supports repeated named captures then you\u0026apos;re golden, but Python \u0026lt;code\u0026gt;re\u0026lt;/code\u0026gt; doesn\u0026apos;t (I know regex does, but I need to use vanilla Python). Here\u0026apos;s what you get:\u0026lt;/p\u0026gt;\n\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;code\u0026gt;content\u0026lt;/code\u0026gt; - All of the content up to the next tag. You could leave this out.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;code\u0026gt;markup\u0026lt;/code\u0026gt; - The entire tag with everything in it.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;code\u0026gt;comment\u0026lt;/code\u0026gt; - If it\u0026apos;s a comment, the comment contents.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;code\u0026gt;cdata\u0026lt;/code\u0026gt; - If it\u0026apos;s a \u0026lt;code\u0026gt;\u0026amp;lt;![CDATA[...]]\u0026amp;gt;\u0026lt;/code\u0026gt;, the CDATA contents.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;code\u0026gt;close_tag\u0026lt;/code\u0026gt; - If it\u0026apos;s a close tag (\u0026lt;code\u0026gt;\u0026amp;lt;/div\u0026amp;gt;\u0026lt;/code\u0026gt;), the tag name.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;code\u0026gt;tag\u0026lt;/code\u0026gt; - If it\u0026apos;s an open tag (\u0026lt;code\u0026gt;\u0026amp;lt;div\u0026amp;gt;\u0026lt;/code\u0026gt;), the tag name.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;code\u0026gt;attributes\u0026lt;/code\u0026gt; - All attributes inside the tag. Use this to get all attributes if you don\u0026apos;t get repeated groups.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;code\u0026gt;attribute\u0026lt;/code\u0026gt; - Repeated, each attribute.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;code\u0026gt;attribute_name\u0026lt;/code\u0026gt; - Repeated, each attribute name.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;code\u0026gt;attribute_value\u0026lt;/code\u0026gt; - Repeated, each attribute value. This includes the quotes if it was quoted.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;code\u0026gt;is_self_closing\u0026lt;/code\u0026gt; - This is \u0026lt;code\u0026gt;/\u0026lt;/code\u0026gt; if it\u0026apos;s a self-closing tag, otherwise nothing.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;code\u0026gt;_q\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;_v\u0026lt;/code\u0026gt; - Ignore these; they\u0026apos;re used internally for backreferences.\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\n\u0026lt;p\u0026gt;If your regex engine doesn\u0026apos;t support repeated named captures, there\u0026apos;s a section called out that you can use to get each attribute. Just run that regex on the \u0026lt;code\u0026gt;attributes\u0026lt;/code\u0026gt; group to get each \u0026lt;code\u0026gt;attribute\u0026lt;/code\u0026gt;, \u0026lt;code\u0026gt;attribute_name\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;attribute_value\u0026lt;/code\u0026gt; out of it.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Demo here: \u0026lt;a href=\u0026quot;https://regex101.com/r/mH8jSu/11\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;https://regex101.com/r/mH8jSu/11\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Regular expressions are not powerful enough for such a language like HTML. Sure, there are some examples where you can use regular expressions. But in general it is not appropriate for parsing.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;You, know...there\u0026apos;s a lot of mentality of you \u0026lt;strong\u0026gt;CAN\u0026apos;T\u0026lt;/strong\u0026gt; do it and I think that everyone on both sides of the fence are right and wrong.  You \u0026lt;strong\u0026gt;CAN\u0026lt;/strong\u0026gt; do it, but it takes a little more processing than just running one regex against it.  Take \u0026lt;a href=\u0026quot;http://bit.ly/1MKKkXh\u0026quot; rel=\u0026quot;nofollow\u0026quot;\u0026gt;this\u0026lt;/a\u0026gt; (I wrote this inside of an hour) as an example.  It assumes the HTML is completely valid, but depending on what language you\u0026apos;re using to apply the aforementioned regex, you could do some fixing of the HTML to make sure that it will succeed.  For example, removing closing tags that are not supposed to be there: \u0026lt;em\u0026gt;\u0026lt;code\u0026gt;\u0026amp;lt;/img\u0026amp;gt;\u0026lt;/code\u0026gt;\u0026lt;/em\u0026gt; for example.  Then, add the closing single HTML forward slash to elements that are missing them, etc.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;I\u0026apos;d use this in the context of writing a library that would allow me to perform HTML element retrieval akin to that of JavaScript\u0026apos;s \u0026lt;code\u0026gt;[x].getElementsByTagName()\u0026lt;/code\u0026gt;, for example.  I\u0026apos;d just splice up the functionality I wrote in the DEFINE section of the regex and use it for stepping inside of a tree of elements, one at time.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;So, will this be the final 100% answer for validating HTML?  No.  But it\u0026apos;s a start and with a little more work, it can be done.  However, trying to do it inside of one regex execution is not practical, nor efficient.\u0026lt;/p\u0026gt;\n    "],"id":298,"title":"Using regular expressions to parse HTML: why not?","content":"\n                \n\u0026lt;p\u0026gt;It seems like every question on stackoverflow where the asker is using regex to grab some information from HTML will inevitably have an \u0026quot;answer\u0026quot; that says not to use regex to parse HTML.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Why not? I\u0026apos;m aware that there are quote-unquote \u0026quot;real\u0026quot; HTML parsers out there like \u0026lt;a href=\u0026quot;http://www.crummy.com/software/BeautifulSoup/\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;Beautiful Soup\u0026lt;/a\u0026gt;, and I\u0026apos;m sure they\u0026apos;re powerful and useful, but if you\u0026apos;re just doing something simple, quick, or dirty, then why bother using something so complicated when a few regex statements will work just fine?\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Moreover, is there just something fundamental that I don\u0026apos;t understand about regex that makes them a bad choice for parsing in general?\u0026lt;/p\u0026gt;\n    ","slug":"using-regular-expressions-to-parse-html:-why-not-1657387543969","postType":"QUESTION","createdAt":"2022-07-09T17:25:43.000Z","updatedAt":"2022-07-09T17:25:43.000Z","tags":[],"relatedQuestions":[]},"randomQuestions":[{"title":"AsyncTask Android example","slug":"asynctask-android-example-1657388127898"},{"title":"How do I use shell variables in an awk script?","slug":"how-do-i-use-shell-variables-in-an-awk-script-1657387754261"},{"title":"How can I sort arrays and data in PHP?","slug":"how-can-i-sort-arrays-and-data-in-php-1657384726665"},{"title":"Split comma-separated strings in a column into separate rows","slug":"split-comma-separated-strings-in-a-column-into-separate-rows-1657387785823"},{"title":"Error: could not find function ... in R","slug":"error:-could-not-find-function-...-in-r-1657388476492"},{"title":"Removing duplicates in lists","slug":"removing-duplicates-in-lists-1657388207448"},{"title":"How to use java.util.Scanner to correctly read user input from System.in and act on it?","slug":"how-to-use-java.util.scanner-to-correctly-read-user-input-from-system.in-and-act-on-it-1657388546306"},{"title":"How can I iterate through two lists in parallel?","slug":"how-can-i-iterate-through-two-lists-in-parallel-1657387278930"},{"title":"How do you parse and process HTML/XML in PHP?","slug":"how-do-you-parse-and-process-htmlxml-in-php-1657384351267"},{"title":"How to remove items from a list while iterating?","slug":"how-to-remove-items-from-a-list-while-iterating-1657384496375"},{"title":"HTTP GET with request body","slug":"http-get-with-request-body-1657387379038"},{"title":"Why aren't variable-length arrays part of the C++ standard?","slug":"why-aren't-variable-length-arrays-part-of-the-c++-standard-1657384712975"},{"title":"Short description of the scoping rules?","slug":"short-description-of-the-scoping-rules-1657384853121"},{"title":"XMLHttpRequest cannot load XXX No 'Access-Control-Allow-Origin' header","slug":"xmlhttprequest-cannot-load-xxx-no-'access-control-allow-origin'-header-1657384758362"},{"title":"Importing files from different folder","slug":"importing-files-from-different-folder-1657388203798"},{"title":"Submit same Partial View called multiple times data to controller?","slug":"submit-same-partial-view-called-multiple-times-data-to-controller-1657387887213"},{"title":"What is the difference between __str__ and __repr__?","slug":"what-is-the-difference-between-__str__-and-__repr__-1657387738760"},{"title":"Using LIMIT within GROUP BY to get N results per group?","slug":"using-limit-within-group-by-to-get-n-results-per-group-1657388324167"},{"title":"What is move semantics?","slug":"what-is-move-semantics-1657387702625"},{"title":"How to return value from an asynchronous callback function? [duplicate]","slug":"how-to-return-value-from-an-asynchronous-callback-function-duplicate-1657387545611"}]},"__N_SSG":true},"page":"/questions/[slug]","query":{"slug":"using-regular-expressions-to-parse-html:-why-not-1657387543969"},"buildId":"xZs8haGjOP63QuDE0kxeX","isFallback":false,"gsp":true,"locale":"en","locales":["en"],"defaultLocale":"en","scriptLoader":[]}</script></body></html>