<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><meta name="twitter:card" content="summary_large_image"/><meta name="twitter:site" content="@solutionschecker.com"/><meta name="twitter:creator" content="@solutionschecker.com"/><meta property="og:url" content="https://solutionschecker.com"/><meta property="og:type" content="website"/><meta property="og:image" content="https://solutionschecker.com/solutions-checker-banner.png"/><meta property="og:image:alt" content="Find the solution to any question. We focus on finding the fastest possible solution for users. Main topics like coding, learning. - solutionschecker.com"/><link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png"/><link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png"/><link rel="manifest" href="/site.webmanifest"/><script type="application/ld+json">{"@context":"https://schema.org","@type":"Organization","logo":"/logo.svg","url":"https://solutionschecker.com"}</script><link name="keywords" content="solutions checker, solution checker, how to, solution for, check for solution, resolve question, what is, what solution for, find solution"/><script type="application/ld+json">{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"item":{"@id":"https://solutionschecker.com","name":"Home"}},{"@type":"ListItem","position":2,"item":{"@id":"https://solutionschecker.com/questions","name":"Questions"}},{"@type":"ListItem","position":3,"item":{"@id":"https://solutionschecker.com/questions/difference-between-sh-and-bash-1657388197713","name":"Questions"}}]}</script><title>Difference between sh and Bash | Solution Checker</title><meta name="robots" content="index,follow"/><meta name="description" content="When writing shell programs, we often use /bin/sh and /bin/bash. I usually use bash, but I don&#x27;t know what&#x27;s the difference between them.
What&#x27;s main difference between Bash and sh?
What do we need to be aware of when programming in Bash and sh?
    "/><meta property="og:title" content="Difference between sh and Bash | Solution Checker"/><meta property="og:description" content="When writing shell programs, we often use /bin/sh and /bin/bash. I usually use bash, but I don&#x27;t know what&#x27;s the difference between them.
What&#x27;s main difference between Bash and sh?
What do we need to be aware of when programming in Bash and sh?
    "/><script type="application/ld+json">{"@context":"https://schema.org","@type":"QAPage","mainEntity":{"name":"Difference between sh and Bash","text":"When writing shell programs, we often use /bin/sh and /bin/bash. I usually use bash, but I don&apos;t know what&apos;s the difference between them.\nWhat&apos;s main difference between Bash and sh?\nWhat do we need to be aware of when programming in Bash and sh?\n    ","answerCount":12,"upVoteCount":500,"suggestedAnswer":[{"text":"What is sh?\nsh (or the Shell Command Language) is a programming language described by the POSIX standard. It has many implementations (ksh88, Dash, ...). Bash can also be considered an implementation of sh (see below).\nBecause sh is a specification, not an implementation, /bin/sh is a symlink (or a hard link) to an actual implementation on most POSIX systems.\nWhat is Bash?\nBash started as an sh-compatible implementation (although it predates the POSIX standard by a few years), but as time passed it has acquired many extensions. Many of these extensions may change the behavior of valid POSIX shell scripts, so by itself Bash is not a valid POSIX shell. Rather, it is a dialect of the POSIX shell language.\nBash supports a --posix switch, which makes it more POSIX-compliant. It also tries to mimic POSIX if invoked as sh.\nsh = bash?\nFor a long time, /bin/sh used to point to /bin/bash on most GNU/Linux systems. As a result, it had almost become safe to ignore the difference between the two. But that started to change recently.\nSome popular examples of systems where /bin/sh does not point to /bin/bash (and on some of which /bin/bash may not even exist) are:\n\nModern Debian and Ubuntu systems, which symlink sh to dash by default;\nBusybox, which is usually run during the Linux system boot time as part of initramfs. It uses the ash shell implementation.\nBSD systems, and in general any non-Linux systems. OpenBSD uses pdksh, a descendant of the KornShell. FreeBSD&apos;s sh is a descendant of the original Unix Bourne shell.  Solaris has its own sh which for a long time was not POSIX-compliant; a free implementation is available from the Heirloom project.\n\nHow can you find out what /bin/sh points to on your system?\nThe complication is that /bin/sh could be a symbolic link or a hard link. If it&apos;s a symbolic link, a portable way to resolve it is:\n% file -h /bin/sh\n/bin/sh: symbolic link to bash\n\nIf it&apos;s a hard link, try\n% find -L /bin -samefile /bin/sh\n/bin/sh\n/bin/bash\n\nIn fact, the -L flag covers both symlinks and hardlinks,\nbut the disadvantage of this method is that it is not portable \nPOSIX does not require find to support the -samefile option, although both GNU find and FreeBSD find support it.\nShebang line\nUltimately, it&apos;s up to you to decide which one to use, by writing the «shebang» line as the very first line of the script.\nE.g.\n#!/bin/sh\n\nwill use sh (and whatever that happens to point to),\n#!/bin/bash\n\nwill use /bin/bash if it&apos;s available (and fail with an error message if it&apos;s not). Of course, you can also specify another implementation, e.g.\n#!/bin/dash\n\nWhich one to use\nFor my own scripts, I prefer sh for the following reasons:\n\nit is standardized\nit is much simpler and easier to learn\nit is portable across POSIX systems  even if they happen not to have bash, they are required to have sh\n\nThere are advantages to using bash as well. Its features make programming more convenient and similar to programming in other modern programming languages. These include things like scoped local variables and arrays. Plain sh is a very minimalistic programming language.\n    ","url":"/questions/[slug]#solution1","@type":"Answer","upvoteCount":0},{"text":"sh: http://man.cx/sh \nBash: http://man.cx/bash\nTL;DR: Bash is a superset of sh with a more elegant syntax and more functionality. It is safe to use a Bash shebang line in almost all cases as it&apos;s quite ubiquitous on modern platforms.\nNB: in some environments, sh is Bash. Check sh --version.\n    ","url":"/questions/[slug]#solution2","@type":"Answer","upvoteCount":0},{"text":"This question has frequently been nominated as a canonical for people who try to use sh and are surprised that it&apos;s not behaving the same as bash.  Here&apos;s a quick rundown of common misunderstandings and pitfalls.\nFirst off, you should understand what to expect.\n\nIf you run your script with sh scriptname, or run it with scriptname and have #!/bin/sh in the shebang line, you should expect POSIX sh behavior.\nIf you run your script with bash scriptname, or run it with scriptname and have #!/bin/bash (or the local equivalent) in the shebang line, you should expect Bash behavior.\n\nHaving a correct shebang and running the script by typing just the script name (possibly with a relative or full path) is generally the preferred solution.  In addition to a correct shebang, this requires the script file to have execute permission (chmod a+x scriptname).\nSo, how do they actually differ?\nBash aims to be backwards-compatible with the Bourne shell and POSIX, but has many additional features. The Bash Reference manual has a section which attempts to enumerate the differences but some common sources of confusion include\n\n[[ is not available in sh (only [ which is more clunky and limited). See also Difference between single and double square brackets in Bash\nsh does not have arrays.\nSome Bash keywords like local, source, function, shopt, let, declare, and select are not portable to sh. (Some sh implementations support e.g. local.)\nBash has many C-style syntax extensions like the three-argument for((i=0;i&lt;=3;i++)) loop, += increment assignment, etc. The $&apos;string\\nwith\\tC\\aescapes&apos; feature is tentatively accepted for POSIX (meaning it works in Bash now, but will not yet be supported by sh on systems which only adhere to the current POSIX specification, and likely will not for some time to come).\nBash supports &lt;&lt;&lt;&apos;here strings&apos;.\nBash has *.{png,jpg} and {0..12} brace expansion.\nBash has extended globbing facilities like ** (globstar) for recursing subdirectories, and extglob for using a different, more versatile wildcard syntax.\n~ refers to $HOME only in Bash (and more generally ~username to the home directory of username).This is in POSIX, but may be missing from some pre-POSIX /bin/sh implementations.\nBash has process substitution with &lt;(cmd) and &gt;(cmd).\nBash has Csh-style convenience redirection aliases like &amp;| for 2&gt;&amp;1 | and &amp;&gt; for &gt; ... 2&gt;&amp;1\nBash supports coprocesses with &lt;&gt; redirection.\nBash features a rich set of expanded non-standard parameter expansions such as ${substring:1:2}, ${variable/pattern/replacement}, case conversion, etc.\nBash has significantly extended facilities for shell arithmetic (though still no floating-point support). There is an obsolescent legacy $[expression] syntax which however should be replaced with POSIX arithmetic $((expression)) syntax. (Some legacy pre-POSIX sh implementations may not support that, though.)\nSeveral built-in commands have options which are not portable, like type -a, printf -v, and the perennial echo -e.\nMagic variables like $RANDOM, $SECONDS, $PIPESTATUS[@] and $FUNCNAME are Bash extensions.\nBash exposes some system facilities as file handles, like /dev/stdin, /dev/fd/&lt;number&gt;, /dev/tcp/&lt;network address&gt;, etc\nSyntactic differences like export variable=value and [ &quot;x&quot; == &quot;y&quot; ] which are not portable (export variable should be separate from variable assignment, and portable string comparison in [ ... ] uses a single equals sign).\nMany, many Bash-only extensions to enable or disable optional behavior and expose internal state of the shell.\nMany, many convenience features for interactive use which however do not affect script behavior.\n\nRemember, this is an abridged listing.  Refer to the reference manual for the full scoop, and http://mywiki.wooledge.org/Bashism for many good workarounds; and/or try http://shellcheck.net/ which warns for many Bash-only features.\nA common error is to have a #!/bin/bash shebang line, but then nevertheless using sh scriptname to actually run the script. This basically disables any Bash-only functionality, so you get syntax errors e.g. for trying to use arrays. (The shebang line is syntactically a comment, so it is simply ignored in this scenario.)\nUnfortunately, Bash will not warn when you try to use these constructs when it is invoked as sh. It doesn&apos;t completely disable all Bash-only functionality, either, so running Bash by invoking it as sh is not a good way to check if your script is properly portable to ash/dash/POSIX sh or variants like Heirloom sh.\nIf you want to check for strict POSIX compliance, try posh\nin its designated POSIX mode\n(which however does not seem to be properly documented).\nAs an aside, the POSIX standardization effort is intended to specify the behavior of various U*x-like platform behaviors, including the shell (sh).\nHowever, this is an evolving document, and so, some implementations adhere to an earlier version of the POSIX specification; furthermore, there are some legacy implementations which didn&apos;t even try to adhere to POSIX.\nThe original Bourne shell had some quirks  which were later straightened out by the POSIX spec, which in large parts is based on ksh88. (Many of the Bash extensions are also innovations from ksh.)\n    ","url":"/questions/[slug]#solution3","@type":"Answer","upvoteCount":0},{"text":"Shell is an interface between a user and OS to access to an operating system&apos;s services. It can be either GUI or CLI (Command Line interface).\n\nsh (Bourne shell) is a shell command-line interpreter, for Unix/Unix-like operating systems. It provides some built-in commands. In scripting language we denote interpreter as #!/bin/sh. It was one most widely supported by other shells like bash (free/open), kash (not free).\n\nBash (Bourne again shell) is a shell replacement for the Bourne shell. Bash is superset of sh. Bash supports sh. POSIX is a set of standards defining how POSIX-compliant systems should work.  Bash is not actually a POSIX compliant shell. In a scripting language we denote the interpreter as #!/bin/bash.\n\nAnalogy:  \n\n\nShell is like an interface or specifications or API.  \nsh is a class which implements the Shell interface.  \nBash is a subclass of the sh. \n\n\n\n    ","url":"/questions/[slug]#solution4","@type":"Answer","upvoteCount":0},{"text":"Post from UNIX.COM\nShell features\nThis table below lists most features that I think would make you choose one shell over another. It is not intended to be a definitive list and does not include every single possible feature for every single possible shell. A feature is only considered to be in a shell if in the version that comes with the operating system, or if it is available as compiled directly from the standard distribution. In particular the C shell specified below is that available on SUNOS 4.*, a considerable number of vendors now ship either tcsh or their own enhanced C shell instead (they don&apos;t always make it obvious that they are shipping tcsh.\nCode:\n                                     sh   csh  ksh  bash tcsh zsh  rc   es\nJob control                          N    Y    Y    Y    Y    Y    N    N\nAliases                              N    Y    Y    Y    Y    Y    N    N\nShell functions                      Y(1) N    Y    Y    N    Y    Y    Y\n&quot;Sensible&quot; Input/Output redirection  Y    N    Y    Y    N    Y    Y    Y\nDirectory stack                      N    Y    Y    Y    Y    Y    F    F\nCommand history                      N    Y    Y    Y    Y    Y    L    L\nCommand line editing                 N    N    Y    Y    Y    Y    L    L\nVi Command line editing              N    N    Y    Y    Y(3) Y    L    L\nEmacs Command line editing           N    N    Y    Y    Y    Y    L    L\nRebindable Command line editing      N    N    N    Y    Y    Y    L    L\nUser name look up                    N    Y    Y    Y    Y    Y    L    L\nLogin/Logout watching                N    N    N    N    Y    Y    F    F\nFilename completion                  N    Y(1) Y    Y    Y    Y    L    L\nUsername completion                  N    Y(2) Y    Y    Y    Y    L    L\nHostname completion                  N    Y(2) Y    Y    Y    Y    L    L\nHistory completion                   N    N    N    Y    Y    Y    L    L\nFully programmable Completion        N    N    N    N    Y    Y    N    N\nMh Mailbox completion                N    N    N    N(4) N(6) N(6) N    N\nCo Processes                         N    N    Y    N    N    Y    N    N\nBuiltin artithmetic evaluation       N    Y    Y    Y    Y    Y    N    N\nCan follow symbolic links invisibly  N    N    Y    Y    Y    Y    N    N\nPeriodic command execution           N    N    N    N    Y    Y    N    N\nCustom Prompt (easily)               N    N    Y    Y    Y    Y    Y    Y\nSun Keyboard Hack                    N    N    N    N    N    Y    N    N\nSpelling Correction                  N    N    N    N    Y    Y    N    N\nProcess Substitution                 N    N    N    Y(2) N    Y    Y    Y\nUnderlying Syntax                    sh   csh  sh   sh   csh  sh   rc   rc\nFreely Available                     N    N    N(5) Y    Y    Y    Y    Y\nChecks Mailbox                       N    Y    Y    Y    Y    Y    F    F\nTty Sanity Checking                  N    N    N    N    Y    Y    N    N\nCan cope with large argument lists   Y    N    Y    Y    Y    Y    Y    Y\nHas non-interactive startup file     N    Y    Y(7) Y(7) Y    Y    N    N\nHas non-login startup file           N    Y    Y(7) Y    Y    Y    N    N\nCan avoid user startup files         N    Y    N    Y    N    Y    Y    Y\nCan specify startup file             N    N    Y    Y    N    N    N    N\nLow level command redefinition       N    N    N    N    N    N    N    Y\nHas anonymous functions              N    N    N    N    N    N    Y    Y\nList Variables                       N    Y    Y    N    Y    Y    Y    Y\nFull signal trap handling            Y    N    Y    Y    N    Y    Y    Y\nFile no clobber ability              N    Y    Y    Y    Y    Y    N    F\nLocal variables                      N    N    Y    Y    N    Y    Y    Y\nLexically scoped variables           N    N    N    N    N    N    N    Y\nExceptions                           N    N    N    N    N    N    N    Y\n\nKey to the table above.\nY      Feature can be done using this shell.\nN      Feature is not present in the shell.\nF      Feature can only be done by using the shells function\nmechanism.\nL      The readline library must be linked into the shell to enable\nthis Feature.\nNotes to the table above\n\nThis feature was not in the original version, but has since become\nalmost standard.\nThis feature is fairly new and so is often not found on many\nversions of the shell, it is gradually making its way into\nstandard distribution.\nThe Vi emulation of this shell is thought by many to be\nincomplete.\nThis feature is not standard but unofficial patches exist to\nperform this.\nA version called &apos;pdksh&apos; is freely available, but does not have\nthe full functionality of the AT&amp;T version.\nThis can be done via the shells programmable completion mechanism.\nOnly by specifying a file via the ENV environment variable.\n\n    ","url":"/questions/[slug]#solution5","@type":"Answer","upvoteCount":0},{"text":"TERMINAL \n\n\nprogram(s) that put a window up\nxterm, rxvt, konsole, kvt, gnome-terminal, nxterm, and eterm.\n\n\nSHELL\n\n\nIs a program that runs in the terminal\nShell is both a command interpreter and a programming language\nShell is simply a macro processor that executes commands. \nMacro processor means functionality where text and symbols are expanded to create larger expressions. \n\n\nSH Vs. BASH\n\nSH\n\n\n(SHell)\nIs a specific shell\na command interpreter and a programming language\nPredecessor of BASH\n\n\nBASH\n\n\n(Bourne-Again SHell)\nIs a specific shell\na command interpreter and a programming language\nHas sh functionality and more\nSuccessor of SH\nBASH is the default SHELL\n\n\nREFERENCE MATERIAL:\n\nSHELL\ngnu.org:\n\n\n  At its base, a shell is simply a macro processor that executes\n  commands. The term macro processor means functionality where text and\n  symbols are expanded to create larger expressions.\n  \n  A Unix shell is both a command interpreter and a programming language.\n  As a command interpreter, the shell provides the user interface to the\n  rich set of GNU utilities. The programming language features allow\n  these utilities to be combined. Files containing commands can be\n  created, and become commands themselves. These new commands have the\n  same status as system commands in directories such as /bin, allowing\n  users or groups to establish custom environments to automate their\n  common tasks.\n  \n  Shells may be used interactively or non-interactively. In interactive\n  mode, they accept input typed from the keyboard. When executing\n  non-interactively, shells execute commands read from a file.\n  \n  A shell allows execution of GNU commands, both synchronously and\n  asynchronously. The shell waits for synchronous commands to complete\n  before accepting more input; asynchronous commands continue to execute\n  in parallel with the shell while it reads and executes additional\n  commands. The redirection constructs permit fine-grained control of\n  the input and output of those commands. Moreover, the shell allows\n  control over the contents of commands environments.\n  \n  Shells also provide a small set of built-in commands (builtins)\n  implementing functionality impossible or inconvenient to obtain via\n  separate utilities. For example, cd, break, continue, and exec cannot\n  be implemented outside of the shell because they directly manipulate\n  the shell itself. The history, getopts, kill, or pwd builtins, among\n  others, could be implemented in separate utilities, but they are more\n  convenient to use as builtin commands. All of the shell builtins are\n  described in subsequent sections.\n  \n  While executing commands is essential, most of the power (and\n  complexity) of shells is due to their embedded programming languages.\n  Like any high-level language, the shell provides variables, flow\n  control constructs, quoting, and functions.\n  \n  Shells offer features geared specifically for interactive use rather\n  than to augment the programming language. These interactive features\n  include job control, command line editing, command history and\n  aliases. Each of these features is described in this manual.\n\n\nBASH gnu.org:\n\n\n  Bash is the shell, or command language interpreter, for the GNU\n  operating system. The name is an acronym for the Bourne-Again SHell,\n  a pun on Stephen Bourne, the author of the direct ancestor of the\n  current Unix shell sh, which appeared in the Seventh Edition Bell Labs\n  Research version of Unix.\n  \n  Bash is largely compatible with sh and incorporates useful features\n  from the Korn shell ksh and the C shell csh. It is intended to be a\n  conformant implementation of the IEEE POSIX Shell and Tools portion of\n  the IEEE POSIX specification (IEEE Standard 1003.1). It offers\n  functional improvements over sh for both interactive and programming\n  use.\n  \n  While the GNU operating system provides other shells, including a\n  version of csh, Bash is the default shell. Like other GNU software,\n  Bash is quite portable. It currently runs on nearly every version of\n  Unix and a few other operating systems - independently-supported ports\n  exist for MS-DOS, OS/2, and Windows platforms.\n\n    ","url":"/questions/[slug]#solution6","@type":"Answer","upvoteCount":0},{"text":"Other answers generally pointed out the difference between Bash and a POSIX shell standard. However, when writing portable shell scripts and being used to Bash syntax, a list of typical bashisms and corresponding pure POSIX solutions is very handy. Such list has been compiled when Ubuntu switched from Bash to Dash as default system shell and can be found here:\nhttps://wiki.ubuntu.com/DashAsBinSh\n\nMoreover, there is a great tool called checkbashisms that checks for bashisms in your script and comes handy when you want to make sure that your script is portable.\n    ","url":"/questions/[slug]#solution7","@type":"Answer","upvoteCount":0},{"text":"bash and sh are two different shells. Basically bash is sh, with more features and better syntax. Most commands work the same, but they are different.Bash (bash) is one of many available (yet the most commonly used) Unix shells. Bash stands for &quot;Bourne Again SHell&quot;,and is a replacement/improvement of the original Bourne shell (sh).\n\nShell scripting is scripting in any shell, whereas Bash scripting is scripting specifically for Bash. In practice, however, &quot;shell script&quot; and &quot;bash script&quot; are often used interchangeably, unless the shell in question is not Bash.\n\nHaving said that, you should realize /bin/sh on most systems will be a symbolic link and will not invoke sh. In Ubuntu /bin/sh used to link to bash, typical behavior on Linux distributions, but now has changed to linking to another shell called dash. I would use bash, as that is pretty much the standard (or at least most common, from my experience). In fact, problems arise when a bash script will use #!/bin/sh because the script-maker assumes the link is to bash when it doesn&apos;t have to be.\n    ","url":"/questions/[slug]#solution8","@type":"Answer","upvoteCount":0},{"text":"They&apos;re nearly identical but bash has more features  sh is (more or less) an older subset of bash.\nsh often means the original Bourne shell, which predates bash (Bourne *again* shell), and was created in 1977.  But, in practice, it may be better to think of it as a highly-cross-compatible shell compliant with the POSIX standard from 1992.\nScripts that start with #!/bin/sh or use the sh shell usually do so for backwards compatibility.  Any unix/linux OS will have an sh shell.  On Ubuntu sh often invokes dash and on MacOS it&apos;s a special POSIX version of bash.  These shells may be preferred for standard-compliant behavior, speed or backwards compatibility.\nbash is newer than the original sh, adds more features, and seeks to be backwards compatible with sh.  sh programs will usually run just fine in bash.  bash is available on nearly all linux/unix machines and usually used by default  with the notable exception of MacOS defaulting to zsh as of Catalina (10.15). FreeBSD, by default, does not come with bash installed.\n    ","url":"/questions/[slug]#solution9","@type":"Answer","upvoteCount":0},{"text":"/bin/sh may or may not invoke the same program as /bin/bash.\n\nsh supports at least the features required by POSIX (assuming a correct implementation). It may support extensions as well.\n\nbash, the &quot;Bourne Again Shell&quot;, implements the features required for sh plus bash-specific extensions. The full set of extensions is too long to describe here, and it varies with new releases. The differences are documented in the bash manual. Type info bash and read the &quot;Bash Features&quot; section (section 6 in the current version), or read the current documentation online.\n    ","url":"/questions/[slug]#solution10","@type":"Answer","upvoteCount":0},{"text":"The differences explained in the easiest way possible:\nAfter having a basic understanding, the other answers will be easier to understand.\nShell - &quot;Shell&quot; is a program, which facilitates the interaction between the user and the operating system (kernel). There are many shell implementations available, like sh, Bash, C shell, Z shell, etc.\nUsing any of the shell programs, we will be able to execute commands that are supported by that shell program.\nBash - It derived from Bourne-again Shell. Using this program, we will be able to execute all the commands specified by the shell. Also, we will be able to execute some commands that are specifically added to this program. Bash has backward compatibility with sh.\nSh - It derived from Bourne Shell. &quot;sh&quot; supports all the commands specified in the shell. It means, using this program, we will be able to execute all the commands specified by Shell.\nFor more information, see:\n\ndash\nBash\n\n    ","url":"/questions/[slug]#solution11","@type":"Answer","upvoteCount":0},{"text":"The Linux operating system offers different types of shell. Though shells have many commands in common, each type has unique features.\nLets study different kind of mostly used shells.\nSh shell:\nSh shell is also known as Bourne shell. Sh shell is the first shell developed for Unix computers by Stephen Bourne at AT&amp;T&apos;s Bell Labs in 1977. It includes many scripting tools.\nBash shell:\nBash shell stands for Bourne Again Shell. Bash shell is the default shell in most Linux distributions and substitute for the Sh shell (the Sh shell will also run in the Bash shell). The Bash shell can execute the vast majority of Sh shell scripts without modification and provide commands line editing feature also.\n    ","url":"/questions/[slug]#solution12","@type":"Answer","upvoteCount":0}],"@type":"Question"}}</script><meta name="next-head-count" content="22"/><link rel="preload" href="/_next/static/css/c116652e2d6f4ad0.css" as="style"/><link rel="stylesheet" href="/_next/static/css/c116652e2d6f4ad0.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-0d1b80a048d4787e.js"></script><script src="/_next/static/chunks/webpack-42cdea76c8170223.js" defer=""></script><script src="/_next/static/chunks/framework-4556c45dd113b893.js" defer=""></script><script src="/_next/static/chunks/main-ccfab947c79712f4.js" defer=""></script><script src="/_next/static/chunks/pages/_app-43d1c35cd6eb9b8f.js" defer=""></script><script src="/_next/static/chunks/294-106ef8570fa99deb.js" defer=""></script><script src="/_next/static/chunks/490-7f0418bb4354ac73.js" defer=""></script><script src="/_next/static/chunks/pages/questions/%5Bslug%5D-50e201fdaa1e0fd1.js" defer=""></script><script src="/_next/static/00bsHgHZki2FteshOatnd/_buildManifest.js" defer=""></script><script src="/_next/static/00bsHgHZki2FteshOatnd/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="wrapper"><header><nav class="bg-white border-gray-200 px-4 lg:px-6 py-2.5 dark:bg-gray-800"><div class="flex flex-wrap justify-between items-center mx-auto max-w-screen-xl"><a class="flex items-center" href="/"><img src="/logo-second.png" class="mr-3 h-6 sm:h-9" alt="Solution Checker Logo"/><h1 class="self-center text-xl font-semibold whitespace-nowrap dark:text-white">Solution Checker</h1></a><div class="flex items-center lg:order-2"><button data-collapse-toggle="mobile-menu-2" type="button" class="inline-flex items-center p-2 ml-1 text-sm text-gray-500 rounded-lg lg:hidden hover:bg-gray-100 focus:outline-none focus:ring-2 focus:ring-gray-200 dark:text-gray-400 dark:hover:bg-gray-700 dark:focus:ring-gray-600" aria-controls="mobile-menu-2" aria-expanded="false"><span class="sr-only">Open main menu</span><svg class="w-6 h-6" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M3 5a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM3 10a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM3 15a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1z" clip-rule="evenodd"></path></svg><svg class="hidden w-6 h-6" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z" clip-rule="evenodd"></path></svg></button></div><div class="hidden justify-between items-center w-full lg:flex lg:w-auto lg:order-1" id="mobile-menu-2"><ul class="flex flex-col mt-4 font-medium lg:flex-row lg:space-x-8 lg:mt-0"><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" aria-current="page" href="/">Home</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/questions?tab=news">Questions</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/post?tab=news">Post</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/questions/difference-between-sh-and-bash-1657388197713#">Coding</a></li></ul></div></div></nav></header><div class="main-content"><div class="question my-5"><div class="flex question-header items-center m-auto justify-center"><div class="rounded-xl w-full border p-5 shadow-md bg-white"><div class="flex w-full items-center justify-between border-b pb-3"><div class="flex items-center space-x-3"><div class="text-lg font-bold text-slate-700"><a href="/questions/difference-between-sh-and-bash-1657388197713"><h1>Difference between sh and Bash</h1></a></div></div><div class="flex flex-wrap h-auto justify-end items-center space-x-8"></div></div><div class="question-content mt-5">
                
<p>When writing shell programs, we often use <code>/bin/sh</code> and <code>/bin/bash</code>. I usually use <code>bash</code>, but I don't know what's the difference between them.</p>
<p>What's main difference between Bash and <code>sh</code>?</p>
<p>What do we need to be aware of when programming in Bash and <code>sh</code>?</p>
    </div></div></div><div class="solution-section"><nav class="flex pagination-solution flex-col justify-end"><h1 class="text-lg font-semibold mb-5">Navigate to solutions: </h1><ul class="inline-flex -space-x-px overflow-auto"><li class="pagination-solution-item"><span data-id="#solution1" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">1</span></li><li class="pagination-solution-item"><span data-id="#solution2" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">2</span></li><li class="pagination-solution-item"><span data-id="#solution3" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">3</span></li><li class="pagination-solution-item"><span data-id="#solution4" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">4</span></li><li class="pagination-solution-item"><span data-id="#solution5" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">5</span></li><li class="pagination-solution-item"><span data-id="#solution6" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">6</span></li><li class="pagination-solution-item"><span data-id="#solution7" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">7</span></li><li class="pagination-solution-item"><span data-id="#solution8" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">8</span></li><li class="pagination-solution-item"><span data-id="#solution9" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">9</span></li><li class="pagination-solution-item"><span data-id="#solution10" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">10</span></li><li class="pagination-solution-item"><span data-id="#solution11" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">11</span></li><li class="pagination-solution-item"><span data-id="#solution12" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">12</span></li></ul></nav><div id="solution1" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 1</h1><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<h1>What is sh?</h1>
<p><code>sh</code> (or the Shell Command Language) is a programming language described by the <a href="http://pubs.opengroup.org/onlinepubs/009695399/utilities/xcu_chap02.html" rel="noreferrer">POSIX standard</a>. It has many implementations (<code>ksh88</code>, <a href="https://en.wikipedia.org/wiki/Almquist_shell#dash:_Ubuntu,_Debian_and_POSIX_compliance_of_Linux_distributions" rel="noreferrer">Dash</a>, ...). Bash can also be considered an implementation of <code>sh</code> (see below).</p>
<p>Because <code>sh</code> is a specification, not an implementation, <code>/bin/sh</code> is a symlink (or a hard link) to an actual implementation on most POSIX systems.</p>
<h1>What is Bash?</h1>
<p>Bash started as an <code>sh</code>-compatible implementation (although it predates the POSIX standard by a few years), but as time passed it has acquired many extensions. Many of these extensions may change the behavior of valid POSIX shell scripts, so by itself Bash is not a valid POSIX shell. Rather, it is a dialect of the POSIX shell language.</p>
<p>Bash supports a <code>--posix</code> switch, which makes it more POSIX-compliant. It also tries to mimic POSIX if invoked as <code>sh</code>.</p>
<h1>sh = bash?</h1>
<p>For a long time, <code>/bin/sh</code> used to point to <code>/bin/bash</code> on most GNU/Linux systems. As a result, it had almost become safe to ignore the difference between the two. But that started to change recently.</p>
<p>Some popular examples of systems where <code>/bin/sh</code> does not point to <code>/bin/bash</code> (and on some of which <code>/bin/bash</code> may not even exist) are:</p>
<ol>
<li>Modern Debian and Ubuntu systems, which symlink <code>sh</code> to <code>dash</code> by default;</li>
<li><a href="https://en.wikipedia.org/wiki/BusyBox" rel="noreferrer">Busybox</a>, which is usually run during the Linux system boot time as part of <code>initramfs</code>. It uses the <a href="https://en.wikipedia.org/wiki/Almquist_shell" rel="noreferrer">ash</a> shell implementation.</li>
<li><a href="https://en.wikipedia.org/wiki/Berkeley_Software_Distribution" rel="noreferrer">BSD</a> systems, and in general any non-Linux systems. <a href="https://en.wikipedia.org/wiki/OpenBSD" rel="noreferrer">OpenBSD</a> uses <code>pdksh</code>, a descendant of the <a href="https://en.wikipedia.org/wiki/KornShell" rel="noreferrer">KornShell</a>. FreeBSD's <code>sh</code> is a descendant of the original Unix Bourne shell.  <a href="https://en.wikipedia.org/wiki/Solaris_%28operating_system%29" rel="noreferrer">Solaris</a> has its own <code>sh</code> which for a long time was not POSIX-compliant; a free implementation is available from the <a href="http://heirloom.sourceforge.net/sh.html" rel="noreferrer">Heirloom project</a>.</li>
</ol>
<p>How can you find out what <code>/bin/sh</code> points to on your system?</p>
<p>The complication is that <code>/bin/sh</code> could be a symbolic link or a hard link. If it's a symbolic link, a <a href="http://pubs.opengroup.org/onlinepubs/9699919799/utilities/file.html" rel="noreferrer">portable</a> way to resolve it is:</p>
<pre class="lang-bash s-code-block"><code class="hljs language-bash">% file -h /bin/sh
/bin/sh: symbolic <span class="hljs-built_in">link</span> to bash
</code></pre>
<p>If it's a hard link, try</p>
<pre class="lang-bash s-code-block"><code class="hljs language-bash">% find -L /bin -samefile /bin/sh
/bin/sh
/bin/bash
</code></pre>
<p>In fact, the <code>-L</code> flag covers both symlinks and hardlinks,
but the disadvantage of this method is that it is not portable 
POSIX <a href="http://pubs.opengroup.org/onlinepubs/9699919799/utilities/find.html" rel="noreferrer">does not require</a> <code>find</code> to support the <code>-samefile</code> option, although both <a href="https://www.gnu.org/software/findutils/manual/html_mono/find.html#Hard-Links" rel="noreferrer">GNU find</a> and <a href="https://www.freebsd.org/cgi/man.cgi?find(1)" rel="noreferrer">FreeBSD find</a> support it.</p>
<h1>Shebang line</h1>
<p>Ultimately, it's up to you to decide which one to use, by writing the «shebang» line as the very first line of the script.</p>
<p>E.g.</p>
<pre class="lang-bash s-code-block"><code class="hljs language-bash"><span class="hljs-meta">#!/bin/sh</span>
</code></pre>
<p>will use <code>sh</code> (and whatever that happens to point to),</p>
<pre class="lang-bash s-code-block"><code class="hljs language-bash"><span class="hljs-meta">#!/bin/bash</span>
</code></pre>
<p>will use <code>/bin/bash</code> if it's available (and fail with an error message if it's not). Of course, you can also specify another implementation, e.g.</p>
<pre class="lang-bash s-code-block"><code class="hljs language-bash"><span class="hljs-meta">#!/bin/dash</span>
</code></pre>
<h1>Which one to use</h1>
<p>For my own scripts, I prefer <code>sh</code> for the following reasons:</p>
<ul>
<li>it is standardized</li>
<li>it is much simpler and easier to learn</li>
<li>it is portable across POSIX systems  even if they happen not to have <code>bash</code>, they are required to have <code>sh</code></li>
</ul>
<p>There are advantages to using <code>bash</code> as well. Its features make programming more convenient and similar to programming in other modern programming languages. These include things like scoped local variables and arrays. Plain <code>sh</code> is a very minimalistic programming language.</p>
    </div></div></div></div><div id="solution2" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 2</h1><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p><code>sh</code>: <a href="http://man.cx/sh" rel="noreferrer">http://man.cx/sh</a> <br>
Bash: <a href="http://man.cx/bash" rel="noreferrer">http://man.cx/bash</a></p>
<p><strong>TL;DR</strong>: Bash is a superset of <code>sh</code> with a more elegant syntax and more functionality. It is safe to use a Bash <a href="https://en.wikipedia.org/wiki/Shebang_(Unix)" rel="noreferrer">shebang</a> line in almost all cases as it's quite ubiquitous on modern platforms.</p>
<p>NB: in some environments, <code>sh</code> <em>is</em> Bash. Check <code>sh --version</code>.</p>
    </div></div></div></div><div id="solution3" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 3</h1><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>This question has frequently been nominated as a canonical for people who try to use <code>sh</code> and are surprised that it's not behaving the same as <code>bash</code>.  Here's a quick rundown of common misunderstandings and pitfalls.</p>
<p>First off, you should understand what to expect.</p>
<ul>
<li>If you run your script with <code>sh scriptname</code>, or run it with <code>scriptname</code> and have <code>#!/bin/sh</code> in the <a href="https://en.wikipedia.org/wiki/Shebang_(Unix)" rel="nofollow noreferrer">shebang</a> line, you should expect POSIX <code>sh</code> behavior.</li>
<li>If you run your script with <code>bash scriptname</code>, or run it with <code>scriptname</code> and have <code>#!/bin/bash</code> (or the local equivalent) in the shebang line, you should expect Bash behavior.</li>
</ul>
<p>Having a correct shebang and running the script by typing just the script name (possibly with a <a href="/questions/31435921/difference-between-and/55342466#55342466">relative or full path</a>) is generally the preferred solution.  In addition to a correct shebang, this requires the script file to have execute permission (<code>chmod a+x scriptname</code>).</p>
<p>So, how do they actually differ?</p>
<p>Bash aims to be backwards-compatible with the Bourne shell and POSIX, but has many additional features. The Bash Reference manual has a <a href="https://www.gnu.org/software/bash/manual/html_node/Major-Differences-From-The-Bourne-Shell.html" rel="nofollow noreferrer">section which attempts to enumerate the differences</a> but some common sources of confusion include</p>
<ul>
<li><code>[[</code> is not available in <code>sh</code> (only <code>[</code> which is more clunky and limited). See also <a href="https://stackoverflow.com/questions/13542832/difference-between-single-and-double-square-brackets-in-bash">Difference between single and double square brackets in Bash</a></li>
<li><code>sh</code> does not have arrays.</li>
<li>Some Bash keywords like <code>local</code>, <code>source</code>, <code>function</code>, <code>shopt</code>, <code>let</code>, <code>declare</code>, and <code>select</code> are not portable to <code>sh</code>. (Some <code>sh</code> implementations support e.g. <code>local</code>.)</li>
<li>Bash has many C-style syntax extensions like the three-argument <code>for((i=0;i&lt;=3;i++))</code> loop, <code>+=</code> increment assignment, etc. The <code>$'string\nwith\tC\aescapes'</code> feature is tentatively <a href="http://austingroupbugs.net/view.php?id=249" rel="nofollow noreferrer">accepted for POSIX</a> (meaning it works in Bash now, but will not yet be supported by <code>sh</code> on systems which only adhere to the current POSIX specification, and likely will not for some time to come).</li>
<li>Bash supports <code>&lt;&lt;&lt;'here strings'</code>.</li>
<li>Bash has <code>*.{png,jpg}</code> and <code>{0..12}</code> brace expansion.</li>
<li>Bash has extended globbing facilities like <code>**</code> (<code>globstar</code>) for recursing subdirectories, and <code>extglob</code> for using a different, <a href="https://www.gnu.org/software/bash/manual/bash.html#Pattern-Matching" rel="nofollow noreferrer">more versatile wildcard syntax.</a></li>
<li><del><code>~</code> refers to <code>$HOME</code> only in Bash (and more generally <code>~username</code> to the home directory of <code>username</code>).</del>This is in POSIX, but may be missing from some pre-POSIX <code>/bin/sh</code> implementations.</li>
<li>Bash has process substitution with <code>&lt;(cmd)</code> and <code>&gt;(cmd)</code>.</li>
<li>Bash has Csh-style convenience redirection aliases like <code>&amp;|</code> for <code>2&gt;&amp;1 |</code> and <code>&amp;&gt;</code> for <code>&gt; ... 2&gt;&amp;1</code></li>
<li>Bash supports coprocesses with <code>&lt;&gt;</code> redirection.</li>
<li>Bash features a rich set of expanded non-standard parameter expansions such as <code>${substring:1:2}</code>, <code>${variable/pattern/replacement}</code>, case conversion, etc.</li>
<li>Bash has significantly extended facilities for shell arithmetic (though still no floating-point support). There is an obsolescent legacy <code>$[expression]</code> syntax which however should be replaced with POSIX arithmetic <code>$((expression))</code> syntax. (Some legacy pre-POSIX <code>sh</code> implementations may not support that, though.)</li>
<li>Several built-in commands have options which are not portable, like <code>type -a</code>, <code>printf -v</code>, and the perennial <code>echo -e</code>.</li>
<li>Magic variables like <code>$RANDOM</code>, <code>$SECONDS</code>, <code>$PIPESTATUS[@]</code> and <code>$FUNCNAME</code> are Bash extensions.</li>
<li>Bash exposes some system facilities as file handles, like <code>/dev/stdin</code>, <code>/dev/fd/&lt;number&gt;</code>, <code>/dev/tcp/&lt;network address&gt;</code>, etc</li>
<li>Syntactic differences like <del><code>export variable=value</code> and</del> <code>[ "x" == "y" ]</code> which are not portable (<del><code>export variable</code> should be separate from variable assignment, and</del> portable string comparison in <code>[ ... ]</code> uses a single equals sign).</li>
<li>Many, many Bash-only extensions to enable or disable optional behavior and expose internal state of the shell.</li>
<li>Many, many convenience features for interactive use which however do not affect script behavior.</li>
</ul>
<p>Remember, this is an abridged listing.  Refer to the reference manual for the full scoop, and <a href="http://mywiki.wooledge.org/Bashism" rel="nofollow noreferrer">http://mywiki.wooledge.org/Bashism</a> for many good workarounds; and/or try <a href="http://shellcheck.net/" rel="nofollow noreferrer">http://shellcheck.net/</a> which warns for many Bash-only features.</p>
<p>A common error is to have a <code>#!/bin/bash</code> shebang line, but then nevertheless using <code>sh scriptname</code> to actually run the script. This basically disables any Bash-only functionality, so you get syntax errors e.g. for trying to use arrays. (The shebang line is syntactically a comment, so it is simply ignored in this scenario.)</p>
<p>Unfortunately, Bash will not warn when you try to use these constructs when it is invoked as <code>sh</code>. It doesn't completely disable <em>all</em> Bash-only functionality, either, so running Bash by invoking it as <code>sh</code> is not a good way to check if your script is properly portable to <a href="https://en.wikipedia.org/wiki/Almquist_shell" rel="nofollow noreferrer"><code>ash</code></a>/<a href="https://en.wikipedia.org/wiki/Almquist_shell#dash:_Ubuntu,_Debian_and_POSIX_compliance_of_Linux_distributions" rel="nofollow noreferrer"><code>dash</code></a>/POSIX <a href="https://pubs.opengroup.org/onlinepubs/9699919799/utilities/sh.html" rel="nofollow noreferrer"><code>sh</code></a> or variants like <a href="http://heirloom.sourceforge.net/sh.html" rel="nofollow noreferrer">Heirloom <code>sh</code></a>.
If you want to check for strict POSIX compliance, try <a href="https://manpages.debian.org/unstable/posh/posh.1.en.html" rel="nofollow noreferrer"><code>posh</code></a>
in its designated POSIX mode
(which however does not seem to be properly documented).</p>
<p>As an aside, the <a href="https://pubs.opengroup.org/onlinepubs/9699919799/" rel="nofollow noreferrer">POSIX</a> standardization effort is intended to specify the behavior of various U*x-like platform behaviors, including the <a href="https://pubs.opengroup.org/onlinepubs/9699919799//idx/shell.html" rel="nofollow noreferrer">shell</a> (<code>sh</code>).
However, this is an evolving document, and so, some implementations adhere to an earlier version of the POSIX specification; furthermore, there are some legacy implementations which didn't even try to adhere to POSIX.
The original Bourne shell had some quirks  which were later straightened out by the POSIX spec, which in large parts is based on <code>ksh88</code>. (Many of the Bash extensions are also innovations from <code>ksh</code>.)</p>
    </div></div></div></div><div id="solution4" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 4</h1><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p><strong>Shell</strong> is an interface between a user and OS to access to an operating system's services. It can be either GUI or CLI (Command Line interface).</p>

<p><strong>sh</strong> (Bourne <strong>sh</strong>ell) is a shell command-line interpreter, for Unix/Unix-like operating systems. It provides some built-in commands. In scripting language we denote interpreter as <code>#!/bin/sh</code>. It was one most widely supported by other shells like bash (free/open), kash (not free).</p>

<p><strong>Bash</strong> (<strong>B</strong>ourne <strong>a</strong>gain <strong>s</strong>hell) is a shell replacement for the Bourne shell. Bash is superset of sh. Bash supports sh. POSIX is a set of standards defining how POSIX-compliant systems should work.  Bash is not actually a POSIX compliant shell. In a scripting language we denote the interpreter as <code>#!/bin/bash</code>.</p>

<p><strong>Analogy:</strong>  </p>

<ul>
<li>Shell is like an interface or specifications or API.  </li>
<li>sh is a class which implements the Shell interface.  </li>
<li>Bash is a subclass of the sh. </li>
</ul>

<p><a href="https://i.stack.imgur.com/8Xvox.jpg" rel="noreferrer"><img src="https://i.stack.imgur.com/8Xvox.jpg" alt="enter image description here"></a></p>
    </div></div></div></div><div id="solution5" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 5</h1><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Post from <a href="http://www.unix.com" rel="nofollow noreferrer">UNIX.COM</a></p>
<p><strong>Shell features</strong></p>
<p>This table below lists most features that I think would make you choose one shell over another. It is not intended to be a definitive list and does not include every single possible feature for every single possible shell. A feature is only considered to be in a shell if in the version that comes with the operating system, or if it is available as compiled directly from the standard distribution. In particular the C shell specified below is that available on SUNOS 4.*, a considerable number of vendors now ship either tcsh or their own enhanced C shell instead (they don't always make it obvious that they are shipping tcsh.</p>
<p><strong>Code:</strong></p>
<pre class="lang-none s-code-block"><code>                                     sh   csh  ksh  bash tcsh zsh  rc   es
Job control                          N    Y    Y    Y    Y    Y    N    N
Aliases                              N    Y    Y    Y    Y    Y    N    N
Shell functions                      Y(1) N    Y    Y    N    Y    Y    Y
"Sensible" Input/Output redirection  Y    N    Y    Y    N    Y    Y    Y
Directory stack                      N    Y    Y    Y    Y    Y    F    F
Command history                      N    Y    Y    Y    Y    Y    L    L
Command line editing                 N    N    Y    Y    Y    Y    L    L
Vi Command line editing              N    N    Y    Y    Y(3) Y    L    L
Emacs Command line editing           N    N    Y    Y    Y    Y    L    L
Rebindable Command line editing      N    N    N    Y    Y    Y    L    L
User name look up                    N    Y    Y    Y    Y    Y    L    L
Login/Logout watching                N    N    N    N    Y    Y    F    F
Filename completion                  N    Y(1) Y    Y    Y    Y    L    L
Username completion                  N    Y(2) Y    Y    Y    Y    L    L
Hostname completion                  N    Y(2) Y    Y    Y    Y    L    L
History completion                   N    N    N    Y    Y    Y    L    L
Fully programmable Completion        N    N    N    N    Y    Y    N    N
Mh Mailbox completion                N    N    N    N(4) N(6) N(6) N    N
Co Processes                         N    N    Y    N    N    Y    N    N
Builtin artithmetic evaluation       N    Y    Y    Y    Y    Y    N    N
Can follow symbolic links invisibly  N    N    Y    Y    Y    Y    N    N
Periodic command execution           N    N    N    N    Y    Y    N    N
Custom Prompt (easily)               N    N    Y    Y    Y    Y    Y    Y
Sun Keyboard Hack                    N    N    N    N    N    Y    N    N
Spelling Correction                  N    N    N    N    Y    Y    N    N
Process Substitution                 N    N    N    Y(2) N    Y    Y    Y
Underlying Syntax                    sh   csh  sh   sh   csh  sh   rc   rc
Freely Available                     N    N    N(5) Y    Y    Y    Y    Y
Checks Mailbox                       N    Y    Y    Y    Y    Y    F    F
Tty Sanity Checking                  N    N    N    N    Y    Y    N    N
Can cope with large argument lists   Y    N    Y    Y    Y    Y    Y    Y
Has non-interactive startup file     N    Y    Y(7) Y(7) Y    Y    N    N
Has non-login startup file           N    Y    Y(7) Y    Y    Y    N    N
Can avoid user startup files         N    Y    N    Y    N    Y    Y    Y
Can specify startup file             N    N    Y    Y    N    N    N    N
Low level command redefinition       N    N    N    N    N    N    N    Y
Has anonymous functions              N    N    N    N    N    N    Y    Y
List Variables                       N    Y    Y    N    Y    Y    Y    Y
Full signal trap handling            Y    N    Y    Y    N    Y    Y    Y
File no clobber ability              N    Y    Y    Y    Y    Y    N    F
Local variables                      N    N    Y    Y    N    Y    Y    Y
Lexically scoped variables           N    N    N    N    N    N    N    Y
Exceptions                           N    N    N    N    N    N    N    Y
</code></pre>
<p><strong>Key to the table above.</strong></p>
<p>Y      Feature can be done using this shell.</p>
<p>N      Feature is not present in the shell.</p>
<p>F      Feature can only be done by using the shells function
mechanism.</p>
<p>L      The readline library must be linked into the shell to enable
this Feature.</p>
<p><strong>Notes to the table above</strong></p>
<ol>
<li>This feature was not in the original version, but has since become
almost standard.</li>
<li>This feature is fairly new and so is often not found on many
versions of the shell, it is gradually making its way into
standard distribution.</li>
<li>The Vi emulation of this shell is thought by many to be
incomplete.</li>
<li>This feature is not standard but unofficial patches exist to
perform this.</li>
<li>A version called 'pdksh' is freely available, but does not have
the full functionality of the AT&amp;T version.</li>
<li>This can be done via the shells programmable completion mechanism.</li>
<li>Only by specifying a file via the ENV environment variable.</li>
</ol>
    </div></div></div></div><div id="solution6" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 6</h1><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p><strong>TERMINAL</strong> </p>

<ul>
<li>program(s) that put a window up</li>
<li>xterm, rxvt, konsole, kvt, gnome-terminal, nxterm, and eterm.</li>
</ul>

<p><strong>SHELL</strong></p>

<ul>
<li>Is a program that runs in the terminal</li>
<li>Shell is both a command interpreter and a programming language</li>
<li>Shell is simply a macro processor that executes commands. </li>
<li>Macro processor means functionality where text and symbols are expanded to create larger expressions. </li>
</ul>

<p><strong>SH Vs. BASH</strong></p>

<p><strong>SH</strong></p>

<ul>
<li>(SHell)</li>
<li>Is a specific shell</li>
<li>a command interpreter and a programming language</li>
<li>Predecessor of BASH</li>
</ul>

<p><strong>BASH</strong></p>

<ul>
<li>(Bourne-Again SHell)</li>
<li>Is a specific shell</li>
<li>a command interpreter and a programming language</li>
<li>Has sh functionality and more</li>
<li>Successor of SH</li>
<li>BASH is the default SHELL</li>
</ul>

<p><strong>REFERENCE MATERIAL:</strong></p>

<p><strong>SHELL</strong>
<a href="https://www.gnu.org/software/bash/manual/html_node/What-is-a-shell_003f.html#What-is-a-shell_003f">gnu.org:</a></p>

<blockquote>
  <p>At its base, a <strong>shell is simply a macro processor</strong> that executes
  commands. The term <strong>macro processor means functionality where text and
  symbols are expanded to create larger expressions.</strong></p>
  
  <p>A Unix <strong>shell is both a command interpreter and a programming language.</strong>
  As a command interpreter, the shell provides the user interface to the
  rich set of GNU utilities. The programming language features allow
  these utilities to be combined. Files containing commands can be
  created, and become commands themselves. These new commands have the
  same status as system commands in directories such as /bin, allowing
  users or groups to establish custom environments to automate their
  common tasks.</p>
  
  <p>Shells may be used interactively or non-interactively. In interactive
  mode, they accept input typed from the keyboard. When executing
  non-interactively, shells execute commands read from a file.</p>
  
  <p>A shell allows execution of GNU commands, both synchronously and
  asynchronously. The shell waits for synchronous commands to complete
  before accepting more input; asynchronous commands continue to execute
  in parallel with the shell while it reads and executes additional
  commands. The redirection constructs permit fine-grained control of
  the input and output of those commands. Moreover, the shell allows
  control over the contents of commands environments.</p>
  
  <p><strong>Shells also provide a small set of built-in commands (builtins)
  implementing functionality impossible or inconvenient to obtain via
  separate utilities</strong>. <strong>For example, cd, break, continue, and exec cannot
  be implemented outside of the shell</strong> because they directly manipulate
  the shell itself. The history, getopts, kill, or pwd builtins, among
  others, could be implemented in separate utilities, but they are more
  convenient to use as builtin commands. All of the shell builtins are
  described in subsequent sections.</p>
  
  <p>While executing commands is essential, <strong>most of the power (and
  complexity) of shells is due to their embedded programming languages.</strong>
  Like any high-level language, the shell provides variables, flow
  control constructs, quoting, and functions.</p>
  
  <p>Shells offer features geared specifically for interactive use rather
  than to augment the programming language. These interactive features
  include job control, command line editing, command history and
  aliases. Each of these features is described in this manual.</p>
</blockquote>

<p><strong>BASH</strong> <a href="https://www.gnu.org/software/bash/manual/html_node/What-is-Bash_003f.html#What-is-Bash_003f">gnu.org:</a></p>

<blockquote>
  <p>Bash is the shell, or command language interpreter, for the GNU
  operating system. The name is an acronym for the Bourne-Again SHell,
  a pun on Stephen Bourne, the author of the direct ancestor of the
  current Unix shell sh, which appeared in the Seventh Edition Bell Labs
  Research version of Unix.</p>
  
  <p>Bash is largely compatible with sh and incorporates useful features
  from the Korn shell ksh and the C shell csh. It is intended to be a
  conformant implementation of the IEEE POSIX Shell and Tools portion of
  the IEEE POSIX specification (IEEE Standard 1003.1). It offers
  functional improvements over sh for both interactive and programming
  use.</p>
  
  <p>While the GNU operating system provides other shells, including a
  version of csh, <strong>Bash is the default shell</strong>. Like other GNU software,
  Bash is quite portable. It currently runs on nearly every version of
  Unix and a few other operating systems - independently-supported ports
  exist for MS-DOS, OS/2, and Windows platforms.</p>
</blockquote>
    </div></div></div></div><div id="solution7" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 7</h1><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Other answers generally pointed out the difference between Bash and a POSIX shell standard. However, when writing portable shell scripts and being used to Bash syntax, a list of typical bashisms and corresponding pure POSIX solutions is very handy. Such list has been compiled when Ubuntu switched from Bash to Dash as default system shell and can be found here:
<a href="https://wiki.ubuntu.com/DashAsBinSh">https://wiki.ubuntu.com/DashAsBinSh</a></p>

<p>Moreover, there is a great tool called <a href="http://manpages.ubuntu.com/manpages/saucy/man1/checkbashisms.1.html">checkbashisms</a> that checks for bashisms in your script and comes handy when you want to make sure that your script is portable.</p>
    </div></div></div></div><div id="solution8" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 8</h1><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>bash and sh are two different shells. Basically bash is sh, with more features and better syntax. Most commands work the same, but they are different.Bash (bash) is one of many available (yet the most commonly used) Unix shells. Bash stands for "Bourne Again SHell",and is a replacement/improvement of the original Bourne shell (sh).</p>

<p>Shell scripting is scripting in any shell, whereas Bash scripting is scripting specifically for Bash. In practice, however, "shell script" and "bash script" are often used interchangeably, unless the shell in question is not Bash.</p>

<p>Having said that, you should realize /bin/sh on most systems will be a symbolic link and will not invoke sh. In Ubuntu /bin/sh used to link to bash, typical behavior on Linux distributions, but now has changed to linking to another shell called dash. I would use bash, as that is pretty much the standard (or at least most common, from my experience). In fact, problems arise when a bash script will use #!/bin/sh because the script-maker assumes the link is to bash when it doesn't have to be.</p>
    </div></div></div></div><div id="solution9" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 9</h1><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p><strong>They're nearly identical but <code>bash</code> has more features</strong>  <code>sh</code> is (more or less) an older subset of <code>bash</code>.</p>
<p><code>sh</code> often means the original <code>Bourne shell</code>, which predates <code>bash</code> (<code>Bourne *again* shell</code>), and was created in 1977.  But, in practice, it may be better to think of it as a highly-cross-compatible shell compliant with the POSIX standard from 1992.</p>
<p>Scripts that start with <code>#!/bin/sh</code> or use the <code>sh</code> shell usually do so for backwards compatibility.  Any unix/linux OS will have an <code>sh</code> shell.  On Ubuntu <code>sh</code> often invokes <code>dash</code> and on MacOS it's a special POSIX version of <code>bash</code>.  These shells may be preferred for standard-compliant behavior, speed or backwards compatibility.</p>
<p><code>bash</code> is newer than the original <code>sh</code>, adds more features, and seeks to be backwards compatible with <code>sh</code>.  <code>sh</code> programs will usually run just fine in <code>bash</code>.  <code>bash</code> is available on nearly all linux/unix machines and usually used by default  with the notable exception of MacOS defaulting to <code>zsh</code> as of Catalina (10.15). FreeBSD, by default, does not come with <code>bash</code> installed.</p>
    </div></div></div></div><div id="solution10" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 10</h1><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p><code>/bin/sh</code> may or may not invoke the same program as <code>/bin/bash</code>.</p>

<p><code>sh</code> supports <em>at least</em> the features <a href="http://pubs.opengroup.org/onlinepubs/9699919799/utilities/sh.html" rel="noreferrer">required by POSIX</a> (assuming a correct implementation). It may support extensions as well.</p>

<p><code>bash</code>, the "Bourne Again Shell", implements the features required for sh plus bash-specific extensions. The full set of extensions is too long to describe here, and it varies with new releases. The differences are documented in the bash manual. Type <code>info bash</code> and read the "Bash Features" section (section 6 in the current version), or read the <a href="https://www.gnu.org/software/bash/manual/html_node/Bash-Features.html" rel="noreferrer">current documentation online</a>.</p>
    </div></div></div></div><div id="solution11" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 11</h1><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p><em>The differences explained in the easiest way possible:</em></p>
<p><em>After having a basic understanding, the other answers will be easier to understand.</em></p>
<p><strong>Shell</strong> - "Shell" is a program, which facilitates the interaction between the user and the operating system (kernel). There are many shell implementations available, like sh, <a href="https://en.wikipedia.org/wiki/Bash_%28Unix_shell%29" rel="nofollow noreferrer">Bash</a>, <a href="https://en.wikipedia.org/wiki/C_shell" rel="nofollow noreferrer">C shell</a>, <a href="https://en.wikipedia.org/wiki/Z_shell" rel="nofollow noreferrer">Z shell</a>, etc.</p>
<p>Using any of the shell programs, we will be able to execute commands that are supported by that shell program.</p>
<p><strong>Bash</strong> - It derived from <strong>B</strong>ourne-<strong>a</strong>gain <strong>Sh</strong>ell. Using this program, we will be able to execute all the commands specified by the shell. Also, we will be able to execute some commands that are specifically added to this program. Bash has backward compatibility with sh.</p>
<p>Sh - It derived from Bourne <strong>Sh</strong>ell. "sh" supports all the commands specified in the shell. It means, using this program, we will be able to execute all the commands specified by Shell.</p>
<p><strong>For more information, see:</strong></p>
<ul>
<li><em><a href="https://man.cx/sh" rel="nofollow noreferrer">dash</a></em></li>
<li><em><a href="https://man.cx/bash" rel="nofollow noreferrer">Bash</a></em></li>
</ul>
    </div></div></div></div><div id="solution12" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 12</h1><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>The Linux operating system offers different types of shell. Though shells have many commands in common, each type has unique features.
Lets study different kind of mostly used shells.</p>
<p><strong>Sh shell:</strong></p>
<p>Sh shell is also known as Bourne shell. Sh shell is the first shell developed for Unix computers by Stephen Bourne at AT&amp;T's Bell Labs in 1977. It includes many scripting tools.</p>
<p><strong>Bash shell:</strong></p>
<p>Bash shell stands for Bourne Again Shell. Bash shell is the default shell in most Linux distributions and substitute for the Sh shell (the Sh shell will also run in the Bash shell). The Bash shell can execute the vast majority of Sh shell scripts without modification and provide commands line editing feature also.</p>
    </div></div></div></div></div></div><div class="widget"><a href="/questions/variables-are-not-behaving-as-expected-1657384865672">Variables are not behaving as expected</a><a href="/questions/why-should-i-not-include-lessbitsstdc++.hgreater-1657384470484">Why should I not #include &lt;bits/stdc++.h&gt;?</a><a href="/questions/order-bars-in-ggplot2-bar-graph-1657388099080">Order Bars in ggplot2 bar graph</a><a href="/questions/how-do-i-pass-data-between-activities-in-android-application-1657384739839">How do I pass data between Activities in Android application?</a><a href="/questions/my-attempt-at-value-initialization-is-interpreted-as-a-function-declaration-and-why-doesn&#x27;t-a-a(())-solve-it-1657388474057">My attempt at value initialization is interpreted as a function declaration, and why doesn&#x27;t A a(()); solve it?</a><a href="/questions/preview-an-image-before-it-is-uploaded-1657388048128">Preview an image before it is uploaded</a><a href="/questions/the-3-different-equals-1657385490242">The 3 different equals</a><a href="/questions/what-are-metaclasses-in-python-1657387811608">What are metaclasses in Python?</a><a href="/questions/determine-whether-two-date-ranges-overlap-1657387924335">Determine Whether Two Date Ranges Overlap</a><a href="/questions/how-to-check-whether-a-string-contains-a-substring-in-javascript-1657388080698">How to check whether a string contains a substring in JavaScript?</a><a href="/questions/collapse-concatenate-aggregate-a-column-to-a-single-comma-separated-string-within-each-group-1657387870901">Collapse / concatenate / aggregate a column to a single comma separated string within each group</a><a href="/questions/how-to-parse-json-in-java-1657384575136">How to parse JSON in Java</a><a href="/questions/why-is-24.0000-not-equal-to-24.0000-in-matlab-1657388376753">Why is 24.0000 not equal to 24.0000 in MATLAB?</a><a href="/questions/why-do-we-always-prefer-using-parameters-in-sql-statements-1657388031476">Why do we always prefer using parameters in SQL statements?</a><a href="/questions/what-is-the-purpose-of-the-var-keyword-and-when-should-i-use-it-(or-omit-it)-1657387525538">What is the purpose of the var keyword and when should I use it (or omit it)?</a><a href="/questions/how-do-i-add-a-delay-in-a-javascript-loop-1657388544679">How do I add a delay in a JavaScript loop?</a><a href="/questions/are-global-variables-thread-safe-in-flask-how-do-i-share-data-between-requests-1657387949951">Are global variables thread-safe in Flask? How do I share data between requests?</a><a href="/questions/how-to-sort-a-multi-dimensional-array-by-value-1657387746110">How to Sort a Multi-dimensional Array by Value</a><a href="/questions/what-is-the-difference-between-a-deep-copy-and-a-shallow-copy-1657388445063">What is the difference between a deep copy and a shallow copy?</a><a href="/questions/how-to-avoid-having-class-data-shared-among-instances-1657387687732">How to avoid having class data shared among instances?</a></div></div><span class="cursor-pointer text-lg p-2" style="position:fixed;bottom:20px;left:20px;background:#000;z-index:2000;color:white">Go go top</span></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"data":{"answer":["\n\u0026lt;h1\u0026gt;What is sh?\u0026lt;/h1\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;code\u0026gt;sh\u0026lt;/code\u0026gt; (or the Shell Command Language) is a programming language described by the \u0026lt;a href=\u0026quot;http://pubs.opengroup.org/onlinepubs/009695399/utilities/xcu_chap02.html\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;POSIX standard\u0026lt;/a\u0026gt;. It has many implementations (\u0026lt;code\u0026gt;ksh88\u0026lt;/code\u0026gt;, \u0026lt;a href=\u0026quot;https://en.wikipedia.org/wiki/Almquist_shell#dash:_Ubuntu,_Debian_and_POSIX_compliance_of_Linux_distributions\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;Dash\u0026lt;/a\u0026gt;, ...). Bash can also be considered an implementation of \u0026lt;code\u0026gt;sh\u0026lt;/code\u0026gt; (see below).\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Because \u0026lt;code\u0026gt;sh\u0026lt;/code\u0026gt; is a specification, not an implementation, \u0026lt;code\u0026gt;/bin/sh\u0026lt;/code\u0026gt; is a symlink (or a hard link) to an actual implementation on most POSIX systems.\u0026lt;/p\u0026gt;\n\u0026lt;h1\u0026gt;What is Bash?\u0026lt;/h1\u0026gt;\n\u0026lt;p\u0026gt;Bash started as an \u0026lt;code\u0026gt;sh\u0026lt;/code\u0026gt;-compatible implementation (although it predates the POSIX standard by a few years), but as time passed it has acquired many extensions. Many of these extensions may change the behavior of valid POSIX shell scripts, so by itself Bash is not a valid POSIX shell. Rather, it is a dialect of the POSIX shell language.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Bash supports a \u0026lt;code\u0026gt;--posix\u0026lt;/code\u0026gt; switch, which makes it more POSIX-compliant. It also tries to mimic POSIX if invoked as \u0026lt;code\u0026gt;sh\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n\u0026lt;h1\u0026gt;sh = bash?\u0026lt;/h1\u0026gt;\n\u0026lt;p\u0026gt;For a long time, \u0026lt;code\u0026gt;/bin/sh\u0026lt;/code\u0026gt; used to point to \u0026lt;code\u0026gt;/bin/bash\u0026lt;/code\u0026gt; on most GNU/Linux systems. As a result, it had almost become safe to ignore the difference between the two. But that started to change recently.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Some popular examples of systems where \u0026lt;code\u0026gt;/bin/sh\u0026lt;/code\u0026gt; does not point to \u0026lt;code\u0026gt;/bin/bash\u0026lt;/code\u0026gt; (and on some of which \u0026lt;code\u0026gt;/bin/bash\u0026lt;/code\u0026gt; may not even exist) are:\u0026lt;/p\u0026gt;\n\u0026lt;ol\u0026gt;\n\u0026lt;li\u0026gt;Modern Debian and Ubuntu systems, which symlink \u0026lt;code\u0026gt;sh\u0026lt;/code\u0026gt; to \u0026lt;code\u0026gt;dash\u0026lt;/code\u0026gt; by default;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;a href=\u0026quot;https://en.wikipedia.org/wiki/BusyBox\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;Busybox\u0026lt;/a\u0026gt;, which is usually run during the Linux system boot time as part of \u0026lt;code\u0026gt;initramfs\u0026lt;/code\u0026gt;. It uses the \u0026lt;a href=\u0026quot;https://en.wikipedia.org/wiki/Almquist_shell\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;ash\u0026lt;/a\u0026gt; shell implementation.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;a href=\u0026quot;https://en.wikipedia.org/wiki/Berkeley_Software_Distribution\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;BSD\u0026lt;/a\u0026gt; systems, and in general any non-Linux systems. \u0026lt;a href=\u0026quot;https://en.wikipedia.org/wiki/OpenBSD\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;OpenBSD\u0026lt;/a\u0026gt; uses \u0026lt;code\u0026gt;pdksh\u0026lt;/code\u0026gt;, a descendant of the \u0026lt;a href=\u0026quot;https://en.wikipedia.org/wiki/KornShell\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;KornShell\u0026lt;/a\u0026gt;. FreeBSD\u0026apos;s \u0026lt;code\u0026gt;sh\u0026lt;/code\u0026gt; is a descendant of the original Unix Bourne shell.  \u0026lt;a href=\u0026quot;https://en.wikipedia.org/wiki/Solaris_%28operating_system%29\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;Solaris\u0026lt;/a\u0026gt; has its own \u0026lt;code\u0026gt;sh\u0026lt;/code\u0026gt; which for a long time was not POSIX-compliant; a free implementation is available from the \u0026lt;a href=\u0026quot;http://heirloom.sourceforge.net/sh.html\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;Heirloom project\u0026lt;/a\u0026gt;.\u0026lt;/li\u0026gt;\n\u0026lt;/ol\u0026gt;\n\u0026lt;p\u0026gt;How can you find out what \u0026lt;code\u0026gt;/bin/sh\u0026lt;/code\u0026gt; points to on your system?\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;The complication is that \u0026lt;code\u0026gt;/bin/sh\u0026lt;/code\u0026gt; could be a symbolic link or a hard link. If it\u0026apos;s a symbolic link, a \u0026lt;a href=\u0026quot;http://pubs.opengroup.org/onlinepubs/9699919799/utilities/file.html\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;portable\u0026lt;/a\u0026gt; way to resolve it is:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-bash s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-bash\u0026quot;\u0026gt;% file -h /bin/sh\n/bin/sh: symbolic \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;link\u0026lt;/span\u0026gt; to bash\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;If it\u0026apos;s a hard link, try\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-bash s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-bash\u0026quot;\u0026gt;% find -L /bin -samefile /bin/sh\n/bin/sh\n/bin/bash\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;In fact, the \u0026lt;code\u0026gt;-L\u0026lt;/code\u0026gt; flag covers both symlinks and hardlinks,\nbut the disadvantage of this method is that it is not portable \nPOSIX \u0026lt;a href=\u0026quot;http://pubs.opengroup.org/onlinepubs/9699919799/utilities/find.html\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;does not require\u0026lt;/a\u0026gt; \u0026lt;code\u0026gt;find\u0026lt;/code\u0026gt; to support the \u0026lt;code\u0026gt;-samefile\u0026lt;/code\u0026gt; option, although both \u0026lt;a href=\u0026quot;https://www.gnu.org/software/findutils/manual/html_mono/find.html#Hard-Links\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;GNU find\u0026lt;/a\u0026gt; and \u0026lt;a href=\u0026quot;https://www.freebsd.org/cgi/man.cgi?find(1)\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;FreeBSD find\u0026lt;/a\u0026gt; support it.\u0026lt;/p\u0026gt;\n\u0026lt;h1\u0026gt;Shebang line\u0026lt;/h1\u0026gt;\n\u0026lt;p\u0026gt;Ultimately, it\u0026apos;s up to you to decide which one to use, by writing the «shebang» line as the very first line of the script.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;E.g.\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-bash s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-bash\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#!/bin/sh\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;will use \u0026lt;code\u0026gt;sh\u0026lt;/code\u0026gt; (and whatever that happens to point to),\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-bash s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-bash\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#!/bin/bash\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;will use \u0026lt;code\u0026gt;/bin/bash\u0026lt;/code\u0026gt; if it\u0026apos;s available (and fail with an error message if it\u0026apos;s not). Of course, you can also specify another implementation, e.g.\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-bash s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-bash\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#!/bin/dash\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;h1\u0026gt;Which one to use\u0026lt;/h1\u0026gt;\n\u0026lt;p\u0026gt;For my own scripts, I prefer \u0026lt;code\u0026gt;sh\u0026lt;/code\u0026gt; for the following reasons:\u0026lt;/p\u0026gt;\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;it is standardized\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;it is much simpler and easier to learn\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;it is portable across POSIX systems  even if they happen not to have \u0026lt;code\u0026gt;bash\u0026lt;/code\u0026gt;, they are required to have \u0026lt;code\u0026gt;sh\u0026lt;/code\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;p\u0026gt;There are advantages to using \u0026lt;code\u0026gt;bash\u0026lt;/code\u0026gt; as well. Its features make programming more convenient and similar to programming in other modern programming languages. These include things like scoped local variables and arrays. Plain \u0026lt;code\u0026gt;sh\u0026lt;/code\u0026gt; is a very minimalistic programming language.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;\u0026lt;code\u0026gt;sh\u0026lt;/code\u0026gt;: \u0026lt;a href=\u0026quot;http://man.cx/sh\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;http://man.cx/sh\u0026lt;/a\u0026gt; \u0026lt;br\u0026gt;\nBash: \u0026lt;a href=\u0026quot;http://man.cx/bash\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;http://man.cx/bash\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;TL;DR\u0026lt;/strong\u0026gt;: Bash is a superset of \u0026lt;code\u0026gt;sh\u0026lt;/code\u0026gt; with a more elegant syntax and more functionality. It is safe to use a Bash \u0026lt;a href=\u0026quot;https://en.wikipedia.org/wiki/Shebang_(Unix)\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;shebang\u0026lt;/a\u0026gt; line in almost all cases as it\u0026apos;s quite ubiquitous on modern platforms.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;NB: in some environments, \u0026lt;code\u0026gt;sh\u0026lt;/code\u0026gt; \u0026lt;em\u0026gt;is\u0026lt;/em\u0026gt; Bash. Check \u0026lt;code\u0026gt;sh --version\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;This question has frequently been nominated as a canonical for people who try to use \u0026lt;code\u0026gt;sh\u0026lt;/code\u0026gt; and are surprised that it\u0026apos;s not behaving the same as \u0026lt;code\u0026gt;bash\u0026lt;/code\u0026gt;.  Here\u0026apos;s a quick rundown of common misunderstandings and pitfalls.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;First off, you should understand what to expect.\u0026lt;/p\u0026gt;\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;If you run your script with \u0026lt;code\u0026gt;sh scriptname\u0026lt;/code\u0026gt;, or run it with \u0026lt;code\u0026gt;scriptname\u0026lt;/code\u0026gt; and have \u0026lt;code\u0026gt;#!/bin/sh\u0026lt;/code\u0026gt; in the \u0026lt;a href=\u0026quot;https://en.wikipedia.org/wiki/Shebang_(Unix)\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;shebang\u0026lt;/a\u0026gt; line, you should expect POSIX \u0026lt;code\u0026gt;sh\u0026lt;/code\u0026gt; behavior.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;If you run your script with \u0026lt;code\u0026gt;bash scriptname\u0026lt;/code\u0026gt;, or run it with \u0026lt;code\u0026gt;scriptname\u0026lt;/code\u0026gt; and have \u0026lt;code\u0026gt;#!/bin/bash\u0026lt;/code\u0026gt; (or the local equivalent) in the shebang line, you should expect Bash behavior.\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;p\u0026gt;Having a correct shebang and running the script by typing just the script name (possibly with a \u0026lt;a href=\u0026quot;/questions/31435921/difference-between-and/55342466#55342466\u0026quot;\u0026gt;relative or full path\u0026lt;/a\u0026gt;) is generally the preferred solution.  In addition to a correct shebang, this requires the script file to have execute permission (\u0026lt;code\u0026gt;chmod a+x scriptname\u0026lt;/code\u0026gt;).\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;So, how do they actually differ?\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Bash aims to be backwards-compatible with the Bourne shell and POSIX, but has many additional features. The Bash Reference manual has a \u0026lt;a href=\u0026quot;https://www.gnu.org/software/bash/manual/html_node/Major-Differences-From-The-Bourne-Shell.html\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;section which attempts to enumerate the differences\u0026lt;/a\u0026gt; but some common sources of confusion include\u0026lt;/p\u0026gt;\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;code\u0026gt;[[\u0026lt;/code\u0026gt; is not available in \u0026lt;code\u0026gt;sh\u0026lt;/code\u0026gt; (only \u0026lt;code\u0026gt;[\u0026lt;/code\u0026gt; which is more clunky and limited). See also \u0026lt;a href=\u0026quot;https://stackoverflow.com/questions/13542832/difference-between-single-and-double-square-brackets-in-bash\u0026quot;\u0026gt;Difference between single and double square brackets in Bash\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;code\u0026gt;sh\u0026lt;/code\u0026gt; does not have arrays.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Some Bash keywords like \u0026lt;code\u0026gt;local\u0026lt;/code\u0026gt;, \u0026lt;code\u0026gt;source\u0026lt;/code\u0026gt;, \u0026lt;code\u0026gt;function\u0026lt;/code\u0026gt;, \u0026lt;code\u0026gt;shopt\u0026lt;/code\u0026gt;, \u0026lt;code\u0026gt;let\u0026lt;/code\u0026gt;, \u0026lt;code\u0026gt;declare\u0026lt;/code\u0026gt;, and \u0026lt;code\u0026gt;select\u0026lt;/code\u0026gt; are not portable to \u0026lt;code\u0026gt;sh\u0026lt;/code\u0026gt;. (Some \u0026lt;code\u0026gt;sh\u0026lt;/code\u0026gt; implementations support e.g. \u0026lt;code\u0026gt;local\u0026lt;/code\u0026gt;.)\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Bash has many C-style syntax extensions like the three-argument \u0026lt;code\u0026gt;for((i=0;i\u0026amp;lt;=3;i++))\u0026lt;/code\u0026gt; loop, \u0026lt;code\u0026gt;+=\u0026lt;/code\u0026gt; increment assignment, etc. The \u0026lt;code\u0026gt;$\u0026apos;string\\nwith\\tC\\aescapes\u0026apos;\u0026lt;/code\u0026gt; feature is tentatively \u0026lt;a href=\u0026quot;http://austingroupbugs.net/view.php?id=249\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;accepted for POSIX\u0026lt;/a\u0026gt; (meaning it works in Bash now, but will not yet be supported by \u0026lt;code\u0026gt;sh\u0026lt;/code\u0026gt; on systems which only adhere to the current POSIX specification, and likely will not for some time to come).\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Bash supports \u0026lt;code\u0026gt;\u0026amp;lt;\u0026amp;lt;\u0026amp;lt;\u0026apos;here strings\u0026apos;\u0026lt;/code\u0026gt;.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Bash has \u0026lt;code\u0026gt;*.{png,jpg}\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;{0..12}\u0026lt;/code\u0026gt; brace expansion.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Bash has extended globbing facilities like \u0026lt;code\u0026gt;**\u0026lt;/code\u0026gt; (\u0026lt;code\u0026gt;globstar\u0026lt;/code\u0026gt;) for recursing subdirectories, and \u0026lt;code\u0026gt;extglob\u0026lt;/code\u0026gt; for using a different, \u0026lt;a href=\u0026quot;https://www.gnu.org/software/bash/manual/bash.html#Pattern-Matching\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;more versatile wildcard syntax.\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;del\u0026gt;\u0026lt;code\u0026gt;~\u0026lt;/code\u0026gt; refers to \u0026lt;code\u0026gt;$HOME\u0026lt;/code\u0026gt; only in Bash (and more generally \u0026lt;code\u0026gt;~username\u0026lt;/code\u0026gt; to the home directory of \u0026lt;code\u0026gt;username\u0026lt;/code\u0026gt;).\u0026lt;/del\u0026gt;This is in POSIX, but may be missing from some pre-POSIX \u0026lt;code\u0026gt;/bin/sh\u0026lt;/code\u0026gt; implementations.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Bash has process substitution with \u0026lt;code\u0026gt;\u0026amp;lt;(cmd)\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;\u0026amp;gt;(cmd)\u0026lt;/code\u0026gt;.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Bash has Csh-style convenience redirection aliases like \u0026lt;code\u0026gt;\u0026amp;amp;|\u0026lt;/code\u0026gt; for \u0026lt;code\u0026gt;2\u0026amp;gt;\u0026amp;amp;1 |\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;\u0026amp;amp;\u0026amp;gt;\u0026lt;/code\u0026gt; for \u0026lt;code\u0026gt;\u0026amp;gt; ... 2\u0026amp;gt;\u0026amp;amp;1\u0026lt;/code\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Bash supports coprocesses with \u0026lt;code\u0026gt;\u0026amp;lt;\u0026amp;gt;\u0026lt;/code\u0026gt; redirection.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Bash features a rich set of expanded non-standard parameter expansions such as \u0026lt;code\u0026gt;${substring:1:2}\u0026lt;/code\u0026gt;, \u0026lt;code\u0026gt;${variable/pattern/replacement}\u0026lt;/code\u0026gt;, case conversion, etc.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Bash has significantly extended facilities for shell arithmetic (though still no floating-point support). There is an obsolescent legacy \u0026lt;code\u0026gt;$[expression]\u0026lt;/code\u0026gt; syntax which however should be replaced with POSIX arithmetic \u0026lt;code\u0026gt;$((expression))\u0026lt;/code\u0026gt; syntax. (Some legacy pre-POSIX \u0026lt;code\u0026gt;sh\u0026lt;/code\u0026gt; implementations may not support that, though.)\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Several built-in commands have options which are not portable, like \u0026lt;code\u0026gt;type -a\u0026lt;/code\u0026gt;, \u0026lt;code\u0026gt;printf -v\u0026lt;/code\u0026gt;, and the perennial \u0026lt;code\u0026gt;echo -e\u0026lt;/code\u0026gt;.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Magic variables like \u0026lt;code\u0026gt;$RANDOM\u0026lt;/code\u0026gt;, \u0026lt;code\u0026gt;$SECONDS\u0026lt;/code\u0026gt;, \u0026lt;code\u0026gt;$PIPESTATUS[@]\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;$FUNCNAME\u0026lt;/code\u0026gt; are Bash extensions.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Bash exposes some system facilities as file handles, like \u0026lt;code\u0026gt;/dev/stdin\u0026lt;/code\u0026gt;, \u0026lt;code\u0026gt;/dev/fd/\u0026amp;lt;number\u0026amp;gt;\u0026lt;/code\u0026gt;, \u0026lt;code\u0026gt;/dev/tcp/\u0026amp;lt;network address\u0026amp;gt;\u0026lt;/code\u0026gt;, etc\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Syntactic differences like \u0026lt;del\u0026gt;\u0026lt;code\u0026gt;export variable=value\u0026lt;/code\u0026gt; and\u0026lt;/del\u0026gt; \u0026lt;code\u0026gt;[ \u0026quot;x\u0026quot; == \u0026quot;y\u0026quot; ]\u0026lt;/code\u0026gt; which are not portable (\u0026lt;del\u0026gt;\u0026lt;code\u0026gt;export variable\u0026lt;/code\u0026gt; should be separate from variable assignment, and\u0026lt;/del\u0026gt; portable string comparison in \u0026lt;code\u0026gt;[ ... ]\u0026lt;/code\u0026gt; uses a single equals sign).\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Many, many Bash-only extensions to enable or disable optional behavior and expose internal state of the shell.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Many, many convenience features for interactive use which however do not affect script behavior.\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;p\u0026gt;Remember, this is an abridged listing.  Refer to the reference manual for the full scoop, and \u0026lt;a href=\u0026quot;http://mywiki.wooledge.org/Bashism\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;http://mywiki.wooledge.org/Bashism\u0026lt;/a\u0026gt; for many good workarounds; and/or try \u0026lt;a href=\u0026quot;http://shellcheck.net/\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;http://shellcheck.net/\u0026lt;/a\u0026gt; which warns for many Bash-only features.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;A common error is to have a \u0026lt;code\u0026gt;#!/bin/bash\u0026lt;/code\u0026gt; shebang line, but then nevertheless using \u0026lt;code\u0026gt;sh scriptname\u0026lt;/code\u0026gt; to actually run the script. This basically disables any Bash-only functionality, so you get syntax errors e.g. for trying to use arrays. (The shebang line is syntactically a comment, so it is simply ignored in this scenario.)\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Unfortunately, Bash will not warn when you try to use these constructs when it is invoked as \u0026lt;code\u0026gt;sh\u0026lt;/code\u0026gt;. It doesn\u0026apos;t completely disable \u0026lt;em\u0026gt;all\u0026lt;/em\u0026gt; Bash-only functionality, either, so running Bash by invoking it as \u0026lt;code\u0026gt;sh\u0026lt;/code\u0026gt; is not a good way to check if your script is properly portable to \u0026lt;a href=\u0026quot;https://en.wikipedia.org/wiki/Almquist_shell\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;\u0026lt;code\u0026gt;ash\u0026lt;/code\u0026gt;\u0026lt;/a\u0026gt;/\u0026lt;a href=\u0026quot;https://en.wikipedia.org/wiki/Almquist_shell#dash:_Ubuntu,_Debian_and_POSIX_compliance_of_Linux_distributions\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;\u0026lt;code\u0026gt;dash\u0026lt;/code\u0026gt;\u0026lt;/a\u0026gt;/POSIX \u0026lt;a href=\u0026quot;https://pubs.opengroup.org/onlinepubs/9699919799/utilities/sh.html\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;\u0026lt;code\u0026gt;sh\u0026lt;/code\u0026gt;\u0026lt;/a\u0026gt; or variants like \u0026lt;a href=\u0026quot;http://heirloom.sourceforge.net/sh.html\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;Heirloom \u0026lt;code\u0026gt;sh\u0026lt;/code\u0026gt;\u0026lt;/a\u0026gt;.\nIf you want to check for strict POSIX compliance, try \u0026lt;a href=\u0026quot;https://manpages.debian.org/unstable/posh/posh.1.en.html\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;\u0026lt;code\u0026gt;posh\u0026lt;/code\u0026gt;\u0026lt;/a\u0026gt;\nin its designated POSIX mode\n(which however does not seem to be properly documented).\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;As an aside, the \u0026lt;a href=\u0026quot;https://pubs.opengroup.org/onlinepubs/9699919799/\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;POSIX\u0026lt;/a\u0026gt; standardization effort is intended to specify the behavior of various U*x-like platform behaviors, including the \u0026lt;a href=\u0026quot;https://pubs.opengroup.org/onlinepubs/9699919799//idx/shell.html\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;shell\u0026lt;/a\u0026gt; (\u0026lt;code\u0026gt;sh\u0026lt;/code\u0026gt;).\nHowever, this is an evolving document, and so, some implementations adhere to an earlier version of the POSIX specification; furthermore, there are some legacy implementations which didn\u0026apos;t even try to adhere to POSIX.\nThe original Bourne shell had some quirks  which were later straightened out by the POSIX spec, which in large parts is based on \u0026lt;code\u0026gt;ksh88\u0026lt;/code\u0026gt;. (Many of the Bash extensions are also innovations from \u0026lt;code\u0026gt;ksh\u0026lt;/code\u0026gt;.)\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Shell\u0026lt;/strong\u0026gt; is an interface between a user and OS to access to an operating system\u0026apos;s services. It can be either GUI or CLI (Command Line interface).\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;sh\u0026lt;/strong\u0026gt; (Bourne \u0026lt;strong\u0026gt;sh\u0026lt;/strong\u0026gt;ell) is a shell command-line interpreter, for Unix/Unix-like operating systems. It provides some built-in commands. In scripting language we denote interpreter as \u0026lt;code\u0026gt;#!/bin/sh\u0026lt;/code\u0026gt;. It was one most widely supported by other shells like bash (free/open), kash (not free).\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Bash\u0026lt;/strong\u0026gt; (\u0026lt;strong\u0026gt;B\u0026lt;/strong\u0026gt;ourne \u0026lt;strong\u0026gt;a\u0026lt;/strong\u0026gt;gain \u0026lt;strong\u0026gt;s\u0026lt;/strong\u0026gt;hell) is a shell replacement for the Bourne shell. Bash is superset of sh. Bash supports sh. POSIX is a set of standards defining how POSIX-compliant systems should work.  Bash is not actually a POSIX compliant shell. In a scripting language we denote the interpreter as \u0026lt;code\u0026gt;#!/bin/bash\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Analogy:\u0026lt;/strong\u0026gt;  \u0026lt;/p\u0026gt;\n\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;Shell is like an interface or specifications or API.  \u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;sh is a class which implements the Shell interface.  \u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Bash is a subclass of the sh. \u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;a href=\u0026quot;https://i.stack.imgur.com/8Xvox.jpg\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;\u0026lt;img src=\u0026quot;https://i.stack.imgur.com/8Xvox.jpg\u0026quot; alt=\u0026quot;enter image description here\u0026quot;\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Post from \u0026lt;a href=\u0026quot;http://www.unix.com\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;UNIX.COM\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Shell features\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;This table below lists most features that I think would make you choose one shell over another. It is not intended to be a definitive list and does not include every single possible feature for every single possible shell. A feature is only considered to be in a shell if in the version that comes with the operating system, or if it is available as compiled directly from the standard distribution. In particular the C shell specified below is that available on SUNOS 4.*, a considerable number of vendors now ship either tcsh or their own enhanced C shell instead (they don\u0026apos;t always make it obvious that they are shipping tcsh.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Code:\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-none s-code-block\u0026quot;\u0026gt;\u0026lt;code\u0026gt;                                     sh   csh  ksh  bash tcsh zsh  rc   es\nJob control                          N    Y    Y    Y    Y    Y    N    N\nAliases                              N    Y    Y    Y    Y    Y    N    N\nShell functions                      Y(1) N    Y    Y    N    Y    Y    Y\n\u0026quot;Sensible\u0026quot; Input/Output redirection  Y    N    Y    Y    N    Y    Y    Y\nDirectory stack                      N    Y    Y    Y    Y    Y    F    F\nCommand history                      N    Y    Y    Y    Y    Y    L    L\nCommand line editing                 N    N    Y    Y    Y    Y    L    L\nVi Command line editing              N    N    Y    Y    Y(3) Y    L    L\nEmacs Command line editing           N    N    Y    Y    Y    Y    L    L\nRebindable Command line editing      N    N    N    Y    Y    Y    L    L\nUser name look up                    N    Y    Y    Y    Y    Y    L    L\nLogin/Logout watching                N    N    N    N    Y    Y    F    F\nFilename completion                  N    Y(1) Y    Y    Y    Y    L    L\nUsername completion                  N    Y(2) Y    Y    Y    Y    L    L\nHostname completion                  N    Y(2) Y    Y    Y    Y    L    L\nHistory completion                   N    N    N    Y    Y    Y    L    L\nFully programmable Completion        N    N    N    N    Y    Y    N    N\nMh Mailbox completion                N    N    N    N(4) N(6) N(6) N    N\nCo Processes                         N    N    Y    N    N    Y    N    N\nBuiltin artithmetic evaluation       N    Y    Y    Y    Y    Y    N    N\nCan follow symbolic links invisibly  N    N    Y    Y    Y    Y    N    N\nPeriodic command execution           N    N    N    N    Y    Y    N    N\nCustom Prompt (easily)               N    N    Y    Y    Y    Y    Y    Y\nSun Keyboard Hack                    N    N    N    N    N    Y    N    N\nSpelling Correction                  N    N    N    N    Y    Y    N    N\nProcess Substitution                 N    N    N    Y(2) N    Y    Y    Y\nUnderlying Syntax                    sh   csh  sh   sh   csh  sh   rc   rc\nFreely Available                     N    N    N(5) Y    Y    Y    Y    Y\nChecks Mailbox                       N    Y    Y    Y    Y    Y    F    F\nTty Sanity Checking                  N    N    N    N    Y    Y    N    N\nCan cope with large argument lists   Y    N    Y    Y    Y    Y    Y    Y\nHas non-interactive startup file     N    Y    Y(7) Y(7) Y    Y    N    N\nHas non-login startup file           N    Y    Y(7) Y    Y    Y    N    N\nCan avoid user startup files         N    Y    N    Y    N    Y    Y    Y\nCan specify startup file             N    N    Y    Y    N    N    N    N\nLow level command redefinition       N    N    N    N    N    N    N    Y\nHas anonymous functions              N    N    N    N    N    N    Y    Y\nList Variables                       N    Y    Y    N    Y    Y    Y    Y\nFull signal trap handling            Y    N    Y    Y    N    Y    Y    Y\nFile no clobber ability              N    Y    Y    Y    Y    Y    N    F\nLocal variables                      N    N    Y    Y    N    Y    Y    Y\nLexically scoped variables           N    N    N    N    N    N    N    Y\nExceptions                           N    N    N    N    N    N    N    Y\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Key to the table above.\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Y      Feature can be done using this shell.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;N      Feature is not present in the shell.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;F      Feature can only be done by using the shells function\nmechanism.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;L      The readline library must be linked into the shell to enable\nthis Feature.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Notes to the table above\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;ol\u0026gt;\n\u0026lt;li\u0026gt;This feature was not in the original version, but has since become\nalmost standard.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;This feature is fairly new and so is often not found on many\nversions of the shell, it is gradually making its way into\nstandard distribution.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;The Vi emulation of this shell is thought by many to be\nincomplete.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;This feature is not standard but unofficial patches exist to\nperform this.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;A version called \u0026apos;pdksh\u0026apos; is freely available, but does not have\nthe full functionality of the AT\u0026amp;amp;T version.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;This can be done via the shells programmable completion mechanism.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Only by specifying a file via the ENV environment variable.\u0026lt;/li\u0026gt;\n\u0026lt;/ol\u0026gt;\n    ","\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;TERMINAL\u0026lt;/strong\u0026gt; \u0026lt;/p\u0026gt;\n\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;program(s) that put a window up\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;xterm, rxvt, konsole, kvt, gnome-terminal, nxterm, and eterm.\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;SHELL\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;Is a program that runs in the terminal\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Shell is both a command interpreter and a programming language\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Shell is simply a macro processor that executes commands. \u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Macro processor means functionality where text and symbols are expanded to create larger expressions. \u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;SH Vs. BASH\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;SH\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;(SHell)\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Is a specific shell\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;a command interpreter and a programming language\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Predecessor of BASH\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;BASH\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;(Bourne-Again SHell)\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Is a specific shell\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;a command interpreter and a programming language\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Has sh functionality and more\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Successor of SH\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;BASH is the default SHELL\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;REFERENCE MATERIAL:\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;SHELL\u0026lt;/strong\u0026gt;\n\u0026lt;a href=\u0026quot;https://www.gnu.org/software/bash/manual/html_node/What-is-a-shell_003f.html#What-is-a-shell_003f\u0026quot;\u0026gt;gnu.org:\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;At its base, a \u0026lt;strong\u0026gt;shell is simply a macro processor\u0026lt;/strong\u0026gt; that executes\n  commands. The term \u0026lt;strong\u0026gt;macro processor means functionality where text and\n  symbols are expanded to create larger expressions.\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n  \n  \u0026lt;p\u0026gt;A Unix \u0026lt;strong\u0026gt;shell is both a command interpreter and a programming language.\u0026lt;/strong\u0026gt;\n  As a command interpreter, the shell provides the user interface to the\n  rich set of GNU utilities. The programming language features allow\n  these utilities to be combined. Files containing commands can be\n  created, and become commands themselves. These new commands have the\n  same status as system commands in directories such as /bin, allowing\n  users or groups to establish custom environments to automate their\n  common tasks.\u0026lt;/p\u0026gt;\n  \n  \u0026lt;p\u0026gt;Shells may be used interactively or non-interactively. In interactive\n  mode, they accept input typed from the keyboard. When executing\n  non-interactively, shells execute commands read from a file.\u0026lt;/p\u0026gt;\n  \n  \u0026lt;p\u0026gt;A shell allows execution of GNU commands, both synchronously and\n  asynchronously. The shell waits for synchronous commands to complete\n  before accepting more input; asynchronous commands continue to execute\n  in parallel with the shell while it reads and executes additional\n  commands. The redirection constructs permit fine-grained control of\n  the input and output of those commands. Moreover, the shell allows\n  control over the contents of commands environments.\u0026lt;/p\u0026gt;\n  \n  \u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Shells also provide a small set of built-in commands (builtins)\n  implementing functionality impossible or inconvenient to obtain via\n  separate utilities\u0026lt;/strong\u0026gt;. \u0026lt;strong\u0026gt;For example, cd, break, continue, and exec cannot\n  be implemented outside of the shell\u0026lt;/strong\u0026gt; because they directly manipulate\n  the shell itself. The history, getopts, kill, or pwd builtins, among\n  others, could be implemented in separate utilities, but they are more\n  convenient to use as builtin commands. All of the shell builtins are\n  described in subsequent sections.\u0026lt;/p\u0026gt;\n  \n  \u0026lt;p\u0026gt;While executing commands is essential, \u0026lt;strong\u0026gt;most of the power (and\n  complexity) of shells is due to their embedded programming languages.\u0026lt;/strong\u0026gt;\n  Like any high-level language, the shell provides variables, flow\n  control constructs, quoting, and functions.\u0026lt;/p\u0026gt;\n  \n  \u0026lt;p\u0026gt;Shells offer features geared specifically for interactive use rather\n  than to augment the programming language. These interactive features\n  include job control, command line editing, command history and\n  aliases. Each of these features is described in this manual.\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;BASH\u0026lt;/strong\u0026gt; \u0026lt;a href=\u0026quot;https://www.gnu.org/software/bash/manual/html_node/What-is-Bash_003f.html#What-is-Bash_003f\u0026quot;\u0026gt;gnu.org:\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;Bash is the shell, or command language interpreter, for the GNU\n  operating system. The name is an acronym for the Bourne-Again SHell,\n  a pun on Stephen Bourne, the author of the direct ancestor of the\n  current Unix shell sh, which appeared in the Seventh Edition Bell Labs\n  Research version of Unix.\u0026lt;/p\u0026gt;\n  \n  \u0026lt;p\u0026gt;Bash is largely compatible with sh and incorporates useful features\n  from the Korn shell ksh and the C shell csh. It is intended to be a\n  conformant implementation of the IEEE POSIX Shell and Tools portion of\n  the IEEE POSIX specification (IEEE Standard 1003.1). It offers\n  functional improvements over sh for both interactive and programming\n  use.\u0026lt;/p\u0026gt;\n  \n  \u0026lt;p\u0026gt;While the GNU operating system provides other shells, including a\n  version of csh, \u0026lt;strong\u0026gt;Bash is the default shell\u0026lt;/strong\u0026gt;. Like other GNU software,\n  Bash is quite portable. It currently runs on nearly every version of\n  Unix and a few other operating systems - independently-supported ports\n  exist for MS-DOS, OS/2, and Windows platforms.\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Other answers generally pointed out the difference between Bash and a POSIX shell standard. However, when writing portable shell scripts and being used to Bash syntax, a list of typical bashisms and corresponding pure POSIX solutions is very handy. Such list has been compiled when Ubuntu switched from Bash to Dash as default system shell and can be found here:\n\u0026lt;a href=\u0026quot;https://wiki.ubuntu.com/DashAsBinSh\u0026quot;\u0026gt;https://wiki.ubuntu.com/DashAsBinSh\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Moreover, there is a great tool called \u0026lt;a href=\u0026quot;http://manpages.ubuntu.com/manpages/saucy/man1/checkbashisms.1.html\u0026quot;\u0026gt;checkbashisms\u0026lt;/a\u0026gt; that checks for bashisms in your script and comes handy when you want to make sure that your script is portable.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;bash and sh are two different shells. Basically bash is sh, with more features and better syntax. Most commands work the same, but they are different.Bash (bash) is one of many available (yet the most commonly used) Unix shells. Bash stands for \u0026quot;Bourne Again SHell\u0026quot;,and is a replacement/improvement of the original Bourne shell (sh).\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Shell scripting is scripting in any shell, whereas Bash scripting is scripting specifically for Bash. In practice, however, \u0026quot;shell script\u0026quot; and \u0026quot;bash script\u0026quot; are often used interchangeably, unless the shell in question is not Bash.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Having said that, you should realize /bin/sh on most systems will be a symbolic link and will not invoke sh. In Ubuntu /bin/sh used to link to bash, typical behavior on Linux distributions, but now has changed to linking to another shell called dash. I would use bash, as that is pretty much the standard (or at least most common, from my experience). In fact, problems arise when a bash script will use #!/bin/sh because the script-maker assumes the link is to bash when it doesn\u0026apos;t have to be.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;They\u0026apos;re nearly identical but \u0026lt;code\u0026gt;bash\u0026lt;/code\u0026gt; has more features\u0026lt;/strong\u0026gt;  \u0026lt;code\u0026gt;sh\u0026lt;/code\u0026gt; is (more or less) an older subset of \u0026lt;code\u0026gt;bash\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;code\u0026gt;sh\u0026lt;/code\u0026gt; often means the original \u0026lt;code\u0026gt;Bourne shell\u0026lt;/code\u0026gt;, which predates \u0026lt;code\u0026gt;bash\u0026lt;/code\u0026gt; (\u0026lt;code\u0026gt;Bourne *again* shell\u0026lt;/code\u0026gt;), and was created in 1977.  But, in practice, it may be better to think of it as a highly-cross-compatible shell compliant with the POSIX standard from 1992.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Scripts that start with \u0026lt;code\u0026gt;#!/bin/sh\u0026lt;/code\u0026gt; or use the \u0026lt;code\u0026gt;sh\u0026lt;/code\u0026gt; shell usually do so for backwards compatibility.  Any unix/linux OS will have an \u0026lt;code\u0026gt;sh\u0026lt;/code\u0026gt; shell.  On Ubuntu \u0026lt;code\u0026gt;sh\u0026lt;/code\u0026gt; often invokes \u0026lt;code\u0026gt;dash\u0026lt;/code\u0026gt; and on MacOS it\u0026apos;s a special POSIX version of \u0026lt;code\u0026gt;bash\u0026lt;/code\u0026gt;.  These shells may be preferred for standard-compliant behavior, speed or backwards compatibility.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;code\u0026gt;bash\u0026lt;/code\u0026gt; is newer than the original \u0026lt;code\u0026gt;sh\u0026lt;/code\u0026gt;, adds more features, and seeks to be backwards compatible with \u0026lt;code\u0026gt;sh\u0026lt;/code\u0026gt;.  \u0026lt;code\u0026gt;sh\u0026lt;/code\u0026gt; programs will usually run just fine in \u0026lt;code\u0026gt;bash\u0026lt;/code\u0026gt;.  \u0026lt;code\u0026gt;bash\u0026lt;/code\u0026gt; is available on nearly all linux/unix machines and usually used by default  with the notable exception of MacOS defaulting to \u0026lt;code\u0026gt;zsh\u0026lt;/code\u0026gt; as of Catalina (10.15). FreeBSD, by default, does not come with \u0026lt;code\u0026gt;bash\u0026lt;/code\u0026gt; installed.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;\u0026lt;code\u0026gt;/bin/sh\u0026lt;/code\u0026gt; may or may not invoke the same program as \u0026lt;code\u0026gt;/bin/bash\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;code\u0026gt;sh\u0026lt;/code\u0026gt; supports \u0026lt;em\u0026gt;at least\u0026lt;/em\u0026gt; the features \u0026lt;a href=\u0026quot;http://pubs.opengroup.org/onlinepubs/9699919799/utilities/sh.html\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;required by POSIX\u0026lt;/a\u0026gt; (assuming a correct implementation). It may support extensions as well.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;code\u0026gt;bash\u0026lt;/code\u0026gt;, the \u0026quot;Bourne Again Shell\u0026quot;, implements the features required for sh plus bash-specific extensions. The full set of extensions is too long to describe here, and it varies with new releases. The differences are documented in the bash manual. Type \u0026lt;code\u0026gt;info bash\u0026lt;/code\u0026gt; and read the \u0026quot;Bash Features\u0026quot; section (section 6 in the current version), or read the \u0026lt;a href=\u0026quot;https://www.gnu.org/software/bash/manual/html_node/Bash-Features.html\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;current documentation online\u0026lt;/a\u0026gt;.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;\u0026lt;em\u0026gt;The differences explained in the easiest way possible:\u0026lt;/em\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;em\u0026gt;After having a basic understanding, the other answers will be easier to understand.\u0026lt;/em\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Shell\u0026lt;/strong\u0026gt; - \u0026quot;Shell\u0026quot; is a program, which facilitates the interaction between the user and the operating system (kernel). There are many shell implementations available, like sh, \u0026lt;a href=\u0026quot;https://en.wikipedia.org/wiki/Bash_%28Unix_shell%29\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;Bash\u0026lt;/a\u0026gt;, \u0026lt;a href=\u0026quot;https://en.wikipedia.org/wiki/C_shell\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;C shell\u0026lt;/a\u0026gt;, \u0026lt;a href=\u0026quot;https://en.wikipedia.org/wiki/Z_shell\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;Z shell\u0026lt;/a\u0026gt;, etc.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Using any of the shell programs, we will be able to execute commands that are supported by that shell program.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Bash\u0026lt;/strong\u0026gt; - It derived from \u0026lt;strong\u0026gt;B\u0026lt;/strong\u0026gt;ourne-\u0026lt;strong\u0026gt;a\u0026lt;/strong\u0026gt;gain \u0026lt;strong\u0026gt;Sh\u0026lt;/strong\u0026gt;ell. Using this program, we will be able to execute all the commands specified by the shell. Also, we will be able to execute some commands that are specifically added to this program. Bash has backward compatibility with sh.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Sh - It derived from Bourne \u0026lt;strong\u0026gt;Sh\u0026lt;/strong\u0026gt;ell. \u0026quot;sh\u0026quot; supports all the commands specified in the shell. It means, using this program, we will be able to execute all the commands specified by Shell.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;For more information, see:\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;em\u0026gt;\u0026lt;a href=\u0026quot;https://man.cx/sh\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;dash\u0026lt;/a\u0026gt;\u0026lt;/em\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;em\u0026gt;\u0026lt;a href=\u0026quot;https://man.cx/bash\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;Bash\u0026lt;/a\u0026gt;\u0026lt;/em\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n    ","\n\u0026lt;p\u0026gt;The Linux operating system offers different types of shell. Though shells have many commands in common, each type has unique features.\nLets study different kind of mostly used shells.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Sh shell:\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Sh shell is also known as Bourne shell. Sh shell is the first shell developed for Unix computers by Stephen Bourne at AT\u0026amp;amp;T\u0026apos;s Bell Labs in 1977. It includes many scripting tools.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Bash shell:\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Bash shell stands for Bourne Again Shell. Bash shell is the default shell in most Linux distributions and substitute for the Sh shell (the Sh shell will also run in the Bash shell). The Bash shell can execute the vast majority of Sh shell scripts without modification and provide commands line editing feature also.\u0026lt;/p\u0026gt;\n    "],"id":499,"title":"Difference between sh and Bash","content":"\n                \n\u0026lt;p\u0026gt;When writing shell programs, we often use \u0026lt;code\u0026gt;/bin/sh\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;/bin/bash\u0026lt;/code\u0026gt;. I usually use \u0026lt;code\u0026gt;bash\u0026lt;/code\u0026gt;, but I don\u0026apos;t know what\u0026apos;s the difference between them.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;What\u0026apos;s main difference between Bash and \u0026lt;code\u0026gt;sh\u0026lt;/code\u0026gt;?\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;What do we need to be aware of when programming in Bash and \u0026lt;code\u0026gt;sh\u0026lt;/code\u0026gt;?\u0026lt;/p\u0026gt;\n    ","slug":"difference-between-sh-and-bash-1657388197713","postType":"QUESTION","createdAt":"2022-07-09T17:36:37.000Z","updatedAt":"2022-07-09T17:36:37.000Z","tags":[],"relatedQuestions":[]},"randomQuestions":[{"title":"Variables are not behaving as expected","slug":"variables-are-not-behaving-as-expected-1657384865672"},{"title":"Why should I not #include \u003cbits/stdc++.h\u003e?","slug":"why-should-i-not-include-lessbitsstdc++.hgreater-1657384470484"},{"title":"Order Bars in ggplot2 bar graph","slug":"order-bars-in-ggplot2-bar-graph-1657388099080"},{"title":"How do I pass data between Activities in Android application?","slug":"how-do-i-pass-data-between-activities-in-android-application-1657384739839"},{"title":"My attempt at value initialization is interpreted as a function declaration, and why doesn't A a(()); solve it?","slug":"my-attempt-at-value-initialization-is-interpreted-as-a-function-declaration-and-why-doesn't-a-a(())-solve-it-1657388474057"},{"title":"Preview an image before it is uploaded","slug":"preview-an-image-before-it-is-uploaded-1657388048128"},{"title":"The 3 different equals","slug":"the-3-different-equals-1657385490242"},{"title":"What are metaclasses in Python?","slug":"what-are-metaclasses-in-python-1657387811608"},{"title":"Determine Whether Two Date Ranges Overlap","slug":"determine-whether-two-date-ranges-overlap-1657387924335"},{"title":"How to check whether a string contains a substring in JavaScript?","slug":"how-to-check-whether-a-string-contains-a-substring-in-javascript-1657388080698"},{"title":"Collapse / concatenate / aggregate a column to a single comma separated string within each group","slug":"collapse-concatenate-aggregate-a-column-to-a-single-comma-separated-string-within-each-group-1657387870901"},{"title":"How to parse JSON in Java","slug":"how-to-parse-json-in-java-1657384575136"},{"title":"Why is 24.0000 not equal to 24.0000 in MATLAB?","slug":"why-is-24.0000-not-equal-to-24.0000-in-matlab-1657388376753"},{"title":"Why do we always prefer using parameters in SQL statements?","slug":"why-do-we-always-prefer-using-parameters-in-sql-statements-1657388031476"},{"title":"What is the purpose of the var keyword and when should I use it (or omit it)?","slug":"what-is-the-purpose-of-the-var-keyword-and-when-should-i-use-it-(or-omit-it)-1657387525538"},{"title":"How do I add a delay in a JavaScript loop?","slug":"how-do-i-add-a-delay-in-a-javascript-loop-1657388544679"},{"title":"Are global variables thread-safe in Flask? How do I share data between requests?","slug":"are-global-variables-thread-safe-in-flask-how-do-i-share-data-between-requests-1657387949951"},{"title":"How to Sort a Multi-dimensional Array by Value","slug":"how-to-sort-a-multi-dimensional-array-by-value-1657387746110"},{"title":"What is the difference between a deep copy and a shallow copy?","slug":"what-is-the-difference-between-a-deep-copy-and-a-shallow-copy-1657388445063"},{"title":"How to avoid having class data shared among instances?","slug":"how-to-avoid-having-class-data-shared-among-instances-1657387687732"}]},"__N_SSG":true},"page":"/questions/[slug]","query":{"slug":"difference-between-sh-and-bash-1657388197713"},"buildId":"00bsHgHZki2FteshOatnd","isFallback":false,"gsp":true,"locale":"en","locales":["en"],"defaultLocale":"en","scriptLoader":[]}</script></body></html>