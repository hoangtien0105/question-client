<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><meta name="twitter:card" content="summary_large_image"/><meta name="twitter:site" content="@solutionschecker.com"/><meta name="twitter:creator" content="@solutionschecker.com"/><meta property="og:url" content="https://solutionschecker.com"/><meta property="og:type" content="website"/><meta property="og:image" content="https://solutionschecker.com/solutions-checker-banner.png"/><meta property="og:image:alt" content="Find the solution to any question. We focus on finding the fastest possible solution for users. Main topics like coding, learning. - solutionschecker.com"/><link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png"/><link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png"/><link rel="manifest" href="/site.webmanifest"/><script type="application/ld+json">{"@context":"https://schema.org","@type":"Organization","logo":"/logo.svg","url":"https://solutionschecker.com"}</script><link name="keywords" content="language-design,default-parameters,least-astonishment,solutions checker, solution checker, how to, solution for, check for solution, resolve question, what is, what solution for, find solution"/><script type="application/ld+json">{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"item":{"@id":"https://solutionschecker.com","name":"Home"}},{"@type":"ListItem","position":2,"item":{"@id":"https://solutionschecker.com/questions","name":"Questions"}},{"@type":"ListItem","position":3,"item":{"@id":"https://solutionschecker.com/questions/&quot;least-astonishment&quot;-and-the-mutable-default-argument-1657384412508","name":"Questions"}}]}</script><title>&quot;Least Astonishment&quot; and the Mutable Default Argument | Solution Checker</title><meta name="robots" content="index,follow"/><meta name="description" content="Anyone tinkering with Python long enough has been bitten (or torn to pieces) by the following issue:
def foo(a=[]):
    a.append(5)
    return a

Python novices would expect this function to always return a list with only one element: [5]. The result is instead very different, and very astonishing (for a novice):
&gt;&gt;&gt; foo()
[5]
&gt;&gt;&gt; foo()
[5, 5]
&gt;&gt;&gt; foo()
[5, 5, 5]
&gt;&gt;&gt; foo()
[5, 5, 5, 5]
&gt;&gt;&gt; foo()

A manager of mine once had his first encounter with this feature, and called it &quot;a dramatic design flaw&quot; of the language. I replied that the behavior had an underlying explanation, and it is indeed very puzzling and unexpected if you don&#x27;t understand the internals. However, I was not able to answer (to myself) the following question: what is the reason for binding the default argument at function definition, and not at function execution? I doubt the experienced behavior has a practical use (who really used static variables in C, without breeding bugs?)
Edit:
Baczek made an interesting example. Together with most of your comments and Utaal&#x27;s in particular, I elaborated further:
&gt;&gt;&gt; def a():
...     print(&quot;a executed&quot;)
...     return []
... 
&gt;&gt;&gt;            
&gt;&gt;&gt; def b(x=a()):
...     x.append(5)
...     print(x)
... 
a executed
&gt;&gt;&gt; b()
[5]
&gt;&gt;&gt; b()
[5, 5]

To me, it seems that the design decision was relative to where to put the scope of parameters: inside the function, or &quot;together&quot; with it?
Doing the binding inside the function would mean that x is effectively bound to the specified default when the function is called, not defined, something that would present a deep flaw: the def line would be &quot;hybrid&quot; in the sense that part of the binding (of the function object) would happen at definition, and part (assignment of default parameters) at function invocation time.
The actual behavior is more consistent: everything of that line gets evaluated when that line is executed, meaning at function definition.
    "/><meta property="og:title" content="&quot;Least Astonishment&quot; and the Mutable Default Argument | Solution Checker"/><meta property="og:description" content="Anyone tinkering with Python long enough has been bitten (or torn to pieces) by the following issue:
def foo(a=[]):
    a.append(5)
    return a

Python novices would expect this function to always return a list with only one element: [5]. The result is instead very different, and very astonishing (for a novice):
&gt;&gt;&gt; foo()
[5]
&gt;&gt;&gt; foo()
[5, 5]
&gt;&gt;&gt; foo()
[5, 5, 5]
&gt;&gt;&gt; foo()
[5, 5, 5, 5]
&gt;&gt;&gt; foo()

A manager of mine once had his first encounter with this feature, and called it &quot;a dramatic design flaw&quot; of the language. I replied that the behavior had an underlying explanation, and it is indeed very puzzling and unexpected if you don&#x27;t understand the internals. However, I was not able to answer (to myself) the following question: what is the reason for binding the default argument at function definition, and not at function execution? I doubt the experienced behavior has a practical use (who really used static variables in C, without breeding bugs?)
Edit:
Baczek made an interesting example. Together with most of your comments and Utaal&#x27;s in particular, I elaborated further:
&gt;&gt;&gt; def a():
...     print(&quot;a executed&quot;)
...     return []
... 
&gt;&gt;&gt;            
&gt;&gt;&gt; def b(x=a()):
...     x.append(5)
...     print(x)
... 
a executed
&gt;&gt;&gt; b()
[5]
&gt;&gt;&gt; b()
[5, 5]

To me, it seems that the design decision was relative to where to put the scope of parameters: inside the function, or &quot;together&quot; with it?
Doing the binding inside the function would mean that x is effectively bound to the specified default when the function is called, not defined, something that would present a deep flaw: the def line would be &quot;hybrid&quot; in the sense that part of the binding (of the function object) would happen at definition, and part (assignment of default parameters) at function invocation time.
The actual behavior is more consistent: everything of that line gets evaluated when that line is executed, meaning at function definition.
    "/><script type="application/ld+json">{"@context":"https://schema.org","@type":"QAPage","mainEntity":{"name":"&quot;Least Astonishment&quot; and the Mutable Default Argument","text":"Anyone tinkering with Python long enough has been bitten (or torn to pieces) by the following issue:\ndef foo(a=[]):\n    a.append(5)\n    return a\n\nPython novices would expect this function to always return a list with only one element: [5]. The result is instead very different, and very astonishing (for a novice):\n&gt;&gt;&gt; foo()\n[5]\n&gt;&gt;&gt; foo()\n[5, 5]\n&gt;&gt;&gt; foo()\n[5, 5, 5]\n&gt;&gt;&gt; foo()\n[5, 5, 5, 5]\n&gt;&gt;&gt; foo()\n\nA manager of mine once had his first encounter with this feature, and called it &quot;a dramatic design flaw&quot; of the language. I replied that the behavior had an underlying explanation, and it is indeed very puzzling and unexpected if you don&apos;t understand the internals. However, I was not able to answer (to myself) the following question: what is the reason for binding the default argument at function definition, and not at function execution? I doubt the experienced behavior has a practical use (who really used static variables in C, without breeding bugs?)\nEdit:\nBaczek made an interesting example. Together with most of your comments and Utaal&apos;s in particular, I elaborated further:\n&gt;&gt;&gt; def a():\n...     print(&quot;a executed&quot;)\n...     return []\n... \n&gt;&gt;&gt;            \n&gt;&gt;&gt; def b(x=a()):\n...     x.append(5)\n...     print(x)\n... \na executed\n&gt;&gt;&gt; b()\n[5]\n&gt;&gt;&gt; b()\n[5, 5]\n\nTo me, it seems that the design decision was relative to where to put the scope of parameters: inside the function, or &quot;together&quot; with it?\nDoing the binding inside the function would mean that x is effectively bound to the specified default when the function is called, not defined, something that would present a deep flaw: the def line would be &quot;hybrid&quot; in the sense that part of the binding (of the function object) would happen at definition, and part (assignment of default parameters) at function invocation time.\nThe actual behavior is more consistent: everything of that line gets evaluated when that line is executed, meaning at function definition.\n    ","answerCount":30,"upVoteCount":500,"suggestedAnswer":[{"text":"Actually, this is not a design flaw, and it is not because of internals or performance. It comes simply from the fact that functions in Python are first-class objects, and not only a piece of code.\nAs soon as you think of it this way, then it completely makes sense: a function is an object being evaluated on its definition; default parameters are kind of &quot;member data&quot; and therefore their state may change from one call to the other - exactly as in any other object.\nIn any case, the effbot (Fredrik Lundh) has a very nice explanation of the reasons for this behavior in Default Parameter Values in Python.\nI found it very clear, and I really suggest reading it for a better knowledge of how function objects work.\n    ","url":"/questions/[slug]#solution1","@type":"Answer","upvoteCount":0},{"text":"Suppose you have the following code\nfruits = (&quot;apples&quot;, &quot;bananas&quot;, &quot;loganberries&quot;)\n\ndef eat(food=fruits):\n    ...\n\nWhen I see the declaration of eat, the least astonishing thing is to think that if the first parameter is not given, that it will be equal to the tuple (&quot;apples&quot;, &quot;bananas&quot;, &quot;loganberries&quot;)\nHowever, suppose later on in the code, I do something like\ndef some_random_function():\n    global fruits\n    fruits = (&quot;blueberries&quot;, &quot;mangos&quot;)\n\nthen if default parameters were bound at function execution rather than function declaration, I would be astonished (in a very bad way) to discover that fruits had been changed. This would be more astonishing IMO than discovering that your foo function above was mutating the list.\nThe real problem lies with mutable variables, and all languages have this problem to some extent. Here&apos;s a question: suppose in Java I have the following code:\nStringBuffer s = new StringBuffer(&quot;Hello World!&quot;);\nMap&lt;StringBuffer,Integer&gt; counts = new HashMap&lt;StringBuffer,Integer&gt;();\ncounts.put(s, 5);\ns.append(&quot;!!!!&quot;);\nSystem.out.println( counts.get(s) );  // does this work?\n\nNow, does my map use the value of the StringBuffer key when it was placed into the map, or does it store the key by reference? Either way, someone is astonished; either the person who tried to get the object out of the Map using a value identical to the one they put it in with, or the person who can&apos;t seem to retrieve their object even though the key they&apos;re using is literally the same object that was used to put it into the map (this is actually why Python doesn&apos;t allow its mutable built-in data types to be used as dictionary keys).\nYour example is a good one of a case where Python newcomers will be surprised and bitten. But I&apos;d argue that if we &quot;fixed&quot; this, then that would only create a different situation where they&apos;d be bitten instead, and that one would be even less intuitive. Moreover, this is always the case when dealing with mutable variables; you always run into cases where someone could intuitively expect one or the opposite behavior depending on what code they&apos;re writing.\nI personally like Python&apos;s current approach: default function arguments are evaluated when the function is defined and that object is always the default. I suppose they could special-case using an empty list, but that kind of special casing would cause even more astonishment, not to mention be backwards incompatible.\n    ","url":"/questions/[slug]#solution2","@type":"Answer","upvoteCount":0},{"text":"The relevant part of the documentation:\n\n\n  Default parameter values are evaluated from left to right when the function definition is executed. This means that the expression is evaluated once, when the function is defined, and that the same pre-computed value is used for each call. This is especially important to understand when a default parameter is a mutable object, such as a list or a dictionary: if the function modifies the object (e.g. by appending an item to a list), the default value is in effect modified. This is generally not what was intended. A way around this is to use None as the default, and explicitly test for it in the body of the function, e.g.:\n\ndef whats_on_the_telly(penguin=None):\n    if penguin is None:\n        penguin = []\n    penguin.append(&quot;property of the zoo&quot;)\n    return penguin\n\n\n    ","url":"/questions/[slug]#solution3","@type":"Answer","upvoteCount":0},{"text":"I know nothing about the Python interpreter inner workings (and I&apos;m not an expert in compilers and interpreters either) so don&apos;t blame me if I propose anything unsensible or impossible.\n\nProvided that python objects are mutable I think that this should be taken into account when designing the default arguments stuff.\nWhen you instantiate a list:\n\na = []\n\n\nyou expect to get a new list referenced by a.\n\nWhy should the a=[] in\n\ndef x(a=[]):\n\n\ninstantiate a new list on function definition and not on invocation?\nIt&apos;s just like you&apos;re asking &quot;if the user doesn&apos;t provide the argument then instantiate a new list and use it as if it was produced by the caller&quot;.\nI think this is ambiguous instead:\n\ndef x(a=datetime.datetime.now()):\n\n\nuser, do you want a to default to the datetime corresponding to when you&apos;re defining or executing x?\nIn this case, as in the previous one, I&apos;ll keep the same behaviour as if the default argument &quot;assignment&quot; was the first instruction of the function (datetime.now() called on function invocation).\nOn the other hand, if the user wanted the definition-time mapping he could write:\n\nb = datetime.datetime.now()\ndef x(a=b):\n\n\nI know, I know: that&apos;s a closure. Alternatively Python might provide a keyword to force definition-time binding:\n\ndef x(static a=b):\n\n    ","url":"/questions/[slug]#solution4","@type":"Answer","upvoteCount":0},{"text":"Well, the reason is quite simply that bindings are done when code is executed, and the function definition is executed, well... when the functions is defined.\n\nCompare this:\n\nclass BananaBunch:\n    bananas = []\n\n    def addBanana(self, banana):\n        self.bananas.append(banana)\n\n\nThis code suffers from the exact same unexpected happenstance. bananas is a class attribute, and hence, when you add things to it, it&apos;s added to all instances of that class. The reason is exactly the same.\n\nIt&apos;s just &quot;How It Works&quot;, and making it work differently in the function case would probably be complicated, and in the class case likely impossible, or at least slow down object instantiation a lot, as you would have to keep the class code around and execute it when objects are created.\n\nYes, it is unexpected. But once the penny drops, it fits in perfectly with how Python works in general. In fact, it&apos;s a good teaching aid, and once you understand why this happens, you&apos;ll grok python much better.\n\nThat said it should feature prominently in any good Python tutorial. Because as you mention, everyone runs into this problem sooner or later.\n    ","url":"/questions/[slug]#solution5","@type":"Answer","upvoteCount":0},{"text":"Why don&apos;t you introspect?\n\nI&apos;m really surprised no one has performed the insightful introspection offered by Python (2 and 3 apply) on callables. \n\nGiven a simple little function func defined as:\n\n&gt;&gt;&gt; def func(a = []):\n...    a.append(5)\n\n\nWhen Python encounters it, the first thing it will do is compile it in order to create a code object for this function. While this compilation step is done, Python evaluates* and then stores the default arguments (an empty list [] here) in the function object itself. As the top answer mentioned: the list a can now be considered a member of the function func.\n\nSo, let&apos;s do some introspection, a before and after to examine how the list gets expanded inside the function object. I&apos;m using Python 3.x for this, for Python 2 the same applies (use __defaults__ or func_defaults in Python 2; yes, two names for the same thing).\n\nFunction Before Execution:\n\n&gt;&gt;&gt; def func(a = []):\n...     a.append(5)\n...     \n\n\nAfter Python executes this definition it will take any default parameters specified (a = [] here) and cram them in the __defaults__ attribute for the function object (relevant section: Callables):     \n\n&gt;&gt;&gt; func.__defaults__\n([],)\n\n\nO.k, so an empty list as the single entry in __defaults__, just as expected. \n\nFunction After Execution:\n\nLet&apos;s now execute this function:\n\n&gt;&gt;&gt; func()\n\n\nNow, let&apos;s see those __defaults__ again: \n\n&gt;&gt;&gt; func.__defaults__\n([5],)\n\n\nAstonished? The value inside the object changes! Consecutive calls to the function will now simply append to that embedded list object:\n\n&gt;&gt;&gt; func(); func(); func()\n&gt;&gt;&gt; func.__defaults__\n([5, 5, 5, 5],)\n\n\nSo, there you have it, the reason why this &apos;flaw&apos; happens, is because default arguments are part of the function object. There&apos;s nothing weird going on here, it&apos;s all just a bit surprising.\n\nThe common solution to combat this is to use None as the default and then initialize in the function body:\n\ndef func(a = None):\n    # or: a = [] if a is None else a\n    if a is None:\n        a = []\n\n\nSince the function body is executed anew each time, you always get a fresh new empty list if no argument was passed for a.\n\n\n\nTo further verify that the list in __defaults__ is the same as that used in the function func you can just change your function to return the id of the list a used inside the function body. Then, compare it to the list in __defaults__ (position [0] in __defaults__) and you&apos;ll see how these are indeed refering to the same list instance:\n\n&gt;&gt;&gt; def func(a = []): \n...     a.append(5)\n...     return id(a)\n&gt;&gt;&gt;\n&gt;&gt;&gt; id(func.__defaults__[0]) == func()\nTrue\n\n\nAll with the power of introspection! \n\n\n\n* To verify that Python evaluates the default arguments during compilation of the function, try executing the following:\n\ndef bar(a=input(&apos;Did you just see me without calling the function?&apos;)): \n    pass  # use raw_input in Py2\n\n\nas you&apos;ll notice, input() is called before the process of building the function and binding it to the name bar is made.\n    ","url":"/questions/[slug]#solution6","@type":"Answer","upvoteCount":0},{"text":"I used to think that creating the objects at runtime would be the better approach.  I&apos;m less certain now, since you do lose some useful features, though it may be worth it regardless simply to prevent newbie confusion.  The disadvantages of doing so are:\n\n1. Performance\n\ndef foo(arg=something_expensive_to_compute())):\n    ...\n\n\nIf call-time evaluation is used, then the expensive function is called every time your function is used without an argument.  You&apos;d either pay an expensive price on each call, or need to manually cache the value externally, polluting your namespace and adding verbosity.\n\n2. Forcing bound parameters\n\nA useful trick is to bind parameters of a lambda to the current binding of a variable when the lambda is created.  For example:\n\nfuncs = [ lambda i=i: i for i in range(10)]\n\n\nThis returns a list of functions that return 0,1,2,3... respectively.  If the behaviour is changed, they will instead bind i to the call-time value of i, so you would get a list of functions that all returned 9.\n\nThe only way to implement this otherwise would be to create a further closure with the i bound, ie:\n\ndef make_func(i): return lambda: i\nfuncs = [make_func(i) for i in range(10)]\n\n\n3. Introspection\n\nConsider the code:\n\ndef foo(a=&apos;test&apos;, b=100, c=[]):\n   print a,b,c\n\n\nWe can get information about the arguments and defaults using the inspect module, which \n\n&gt;&gt;&gt; inspect.getargspec(foo)\n([&apos;a&apos;, &apos;b&apos;, &apos;c&apos;], None, None, (&apos;test&apos;, 100, []))\n\n\nThis information is very useful for things like document generation, metaprogramming, decorators etc.\n\nNow, suppose the behaviour of defaults could be changed so that this is the equivalent of:\n\n_undefined = object()  # sentinel value\n\ndef foo(a=_undefined, b=_undefined, c=_undefined)\n    if a is _undefined: a=&apos;test&apos;\n    if b is _undefined: b=100\n    if c is _undefined: c=[]\n\n\nHowever, we&apos;ve lost the ability to introspect, and see what the default arguments are.  Because the objects haven&apos;t been constructed, we can&apos;t ever get hold of them without actually calling the function.  The best we could do is to store off the source code and return that as a string.\n    ","url":"/questions/[slug]#solution7","@type":"Answer","upvoteCount":0},{"text":"5 points in defense of Python\n\nSimplicity: The behavior is simple in the following sense:\nMost people fall into this trap only once, not several times.\n\nConsistency: Python always passes objects, not names.\nThe default parameter is, obviously, part of the function\nheading (not the function body). It therefore ought to be evaluated\nat module load time (and only at module load time, unless nested), not\nat function call time.\n\nUsefulness: As Frederik Lundh points out in his explanation\nof &quot;Default Parameter Values in Python&quot;, the\ncurrent behavior can be quite useful for advanced programming.\n(Use sparingly.)\n\nSufficient documentation: In the most basic Python documentation,\nthe tutorial, the issue is loudly announced as\nan &quot;Important warning&quot; in the first subsection of Section\n&quot;More on Defining Functions&quot;.\nThe warning even uses boldface,\nwhich is rarely applied outside of headings.\nRTFM: Read the fine manual.\n\nMeta-learning: Falling into the trap is actually a very\nhelpful moment (at least if you are a reflective learner),\nbecause you will subsequently better understand the point\n&quot;Consistency&quot; above and that will\nteach you a great deal about Python.\n\n\n    ","url":"/questions/[slug]#solution8","@type":"Answer","upvoteCount":0},{"text":"This behavior is easy explained by:\n\n\nfunction (class etc.) declaration is executed only once, creating all default value objects\neverything is passed by reference\n\n\nSo:\n\ndef x(a=0, b=[], c=[], d=0):\n    a = a + 1\n    b = b + [1]\n    c.append(1)\n    print a, b, c\n\n\n\na doesn&apos;t change - every assignment call creates new int object - new object is printed\nb doesn&apos;t change - new array is build from default value and printed\nc changes - operation is performed on same object - and it is printed\n\n    ","url":"/questions/[slug]#solution9","@type":"Answer","upvoteCount":0},{"text":"1)  The so-called problem of &quot;Mutable Default Argument&quot; is in general a special example demonstrating that:\n&quot;All functions with this problem suffer also from similar side effect problem on the actual parameter,&quot;\nThat is against the rules of functional programming, usually undesiderable and should be fixed both together.\n\nExample:\n\ndef foo(a=[]):                 # the same problematic function\n    a.append(5)\n    return a\n\n&gt;&gt;&gt; somevar = [1, 2]           # an example without a default parameter\n&gt;&gt;&gt; foo(somevar)\n[1, 2, 5]\n&gt;&gt;&gt; somevar\n[1, 2, 5]                      # usually expected [1, 2]\n\n\nSolution:  a copy\nAn absolutely safe solution is to copy or deepcopy the input object first and then to do whatever with the copy.\n\ndef foo(a=[]):\n    a = a[:]     # a copy\n    a.append(5)\n    return a     # or everything safe by one line: &quot;return a + [5]&quot;\n\n\nMany builtin mutable types have a copy method like some_dict.copy() or some_set.copy() or can be copied easy like somelist[:] or list(some_list). Every object can be also copied by copy.copy(any_object) or more thorough by copy.deepcopy() (the latter useful if the mutable object is composed from mutable objects). Some objects are fundamentally based on side effects like &quot;file&quot; object and can not be meaningfully reproduced by copy. copying\n\nExample problem for a similar SO question\n\nclass Test(object):            # the original problematic class\n  def __init__(self, var1=[]):\n    self._var1 = var1\n\nsomevar = [1, 2]               # an example without a default parameter\nt1 = Test(somevar)\nt2 = Test(somevar)\nt1._var1.append([1])\nprint somevar                  # [1, 2, [1]] but usually expected [1, 2]\nprint t2._var1                 # [1, 2, [1]] but usually expected [1, 2]\n\n\nIt shouldn&apos;t be neither saved in any public attribute of an instance returned by this function. (Assuming that private attributes of instance should not be modified from outside of this class or subclasses by convention. i.e. _var1 is a private attribute )\n\nConclusion:\nInput parameters objects shouldn&apos;t be modified in place (mutated) nor they should not be binded into an object returned by the function. (If we prefere programming without side effects which is strongly recommended. see Wiki about &quot;side effect&quot; (The first two paragraphs are relevent in this context.)\n.)\n\n2)\nOnly if the side effect on the actual parameter is required but unwanted on the default parameter then the useful solution is def ...(var1=None): if var1 is None: var1 = [] More..\n\n3) In some cases is the mutable behavior of default parameters useful.\n    ","url":"/questions/[slug]#solution10","@type":"Answer","upvoteCount":0},{"text":"What you&apos;re asking is why this:\n\ndef func(a=[], b = 2):\n    pass\n\n\nisn&apos;t internally equivalent to this:\n\ndef func(a=None, b = None):\n    a_default = lambda: []\n    b_default = lambda: 2\n    def actual_func(a=None, b=None):\n        if a is None: a = a_default()\n        if b is None: b = b_default()\n    return actual_func\nfunc = func()\n\n\nexcept for the case of explicitly calling func(None, None), which we&apos;ll ignore.\n\nIn other words, instead of evaluating default parameters, why not store each of them, and evaluate them when the function is called?\n\nOne answer is probably right there--it would effectively turn every function with default parameters into a closure.  Even if it&apos;s all hidden away in the interpreter and not a full-blown closure, the data&apos;s got to be stored somewhere.  It&apos;d be slower and use more memory.\n    ","url":"/questions/[slug]#solution11","@type":"Answer","upvoteCount":0},{"text":"This actually has nothing to do with default values, other than that it often comes up as an unexpected behaviour when you write functions with mutable default values.\n\n&gt;&gt;&gt; def foo(a):\n    a.append(5)\n    print a\n\n&gt;&gt;&gt; a  = [5]\n&gt;&gt;&gt; foo(a)\n[5, 5]\n&gt;&gt;&gt; foo(a)\n[5, 5, 5]\n&gt;&gt;&gt; foo(a)\n[5, 5, 5, 5]\n&gt;&gt;&gt; foo(a)\n[5, 5, 5, 5, 5]\n\n\nNo default values in sight in this code, but you get exactly the same problem.\n\nThe problem is that foo is modifying a mutable variable passed in from the caller, when the caller doesn&apos;t expect this. Code like this would be fine if the function was called something like append_5; then the caller would be calling the function in order to modify the value they pass in, and the behaviour would be expected. But such a function would be very unlikely to take a default argument, and probably wouldn&apos;t return the list (since the caller already has a reference to that list; the one it just passed in).\n\nYour original foo, with a default argument, shouldn&apos;t be modifying a whether it was explicitly passed in or got the default value. Your code should leave mutable arguments alone unless it is clear from the context/name/documentation that the arguments are supposed to be modified. Using mutable values passed in as arguments as local temporaries is an extremely bad idea, whether we&apos;re in Python or not and whether there are default arguments involved or not.\n\nIf you need to destructively manipulate a local temporary in the course of computing something, and you need to start your manipulation from an argument value, you need to make a copy.\n    ","url":"/questions/[slug]#solution12","@type":"Answer","upvoteCount":0},{"text":"Already busy topic, but from what I read here, the following helped me realizing how it&apos;s working internally:\n\ndef bar(a=[]):\n     print id(a)\n     a = a + [1]\n     print id(a)\n     return a\n\n&gt;&gt;&gt; bar()\n4484370232\n4484524224\n[1]\n&gt;&gt;&gt; bar()\n4484370232\n4484524152\n[1]\n&gt;&gt;&gt; bar()\n4484370232 # Never change, this is &apos;class property&apos; of the function\n4484523720 # Always a new object \n[1]\n&gt;&gt;&gt; id(bar.func_defaults[0])\n4484370232\n\n    ","url":"/questions/[slug]#solution13","@type":"Answer","upvoteCount":0},{"text":"Python: The Mutable Default Argument\n\nDefault arguments get evaluated at the time the function is compiled into a function object. When used by the function, multiple times by that function, they are and remain the same object. \n\nWhen they are mutable, when mutated (for example, by adding an element to it) they remain mutated on consecutive calls.\n\nThey stay mutated because they are the same object each time.\n\nEquivalent code:\n\nSince the list is bound to the function when the function object is compiled and instantiated, this:\n\ndef foo(mutable_default_argument=[]): # make a list the default argument\n    &quot;&quot;&quot;function that uses a list&quot;&quot;&quot;\n\n\nis almost exactly equivalent to this:\n\n_a_list = [] # create a list in the globals\n\ndef foo(mutable_default_argument=_a_list): # make it the default argument\n    &quot;&quot;&quot;function that uses a list&quot;&quot;&quot;\n\ndel _a_list # remove globals name binding\n\n\nDemonstration\n\nHere&apos;s a demonstration - you can verify that they are the same object each time they are referenced by \n\n\nseeing that the list is created before the function has finished compiling to a function object,\nobserving that the id is the same each time the list is referenced,\nobserving that the list stays changed when the function that uses it is called a second time,\nobserving the order in which the output is printed from the source (which I conveniently numbered for you):\n\n\nexample.py\n\nprint(&apos;1. Global scope being evaluated&apos;)\n\ndef create_list():\n    &apos;&apos;&apos;noisily create a list for usage as a kwarg&apos;&apos;&apos;\n    l = []\n    print(&apos;3. list being created and returned, id: &apos; + str(id(l)))\n    return l\n\nprint(&apos;2. example_function about to be compiled to an object&apos;)\n\ndef example_function(default_kwarg1=create_list()):\n    print(&apos;appending &quot;a&quot; in default default_kwarg1&apos;)\n    default_kwarg1.append(&quot;a&quot;)\n    print(&apos;list with id: &apos; + str(id(default_kwarg1)) + \n          &apos; - is now: &apos; + repr(default_kwarg1))\n\nprint(&apos;4. example_function compiled: &apos; + repr(example_function))\n\n\nif __name__ == &apos;__main__&apos;:\n    print(&apos;5. calling example_function twice!:&apos;)\n    example_function()\n    example_function()\n\n\nand running it with python example.py:\n\n1. Global scope being evaluated\n2. example_function about to be compiled to an object\n3. list being created and returned, id: 140502758808032\n4. example_function compiled: &lt;function example_function at 0x7fc9590905f0&gt;\n5. calling example_function twice!:\nappending &quot;a&quot; in default default_kwarg1\nlist with id: 140502758808032 - is now: [&apos;a&apos;]\nappending &quot;a&quot; in default default_kwarg1\nlist with id: 140502758808032 - is now: [&apos;a&apos;, &apos;a&apos;]\n\n\nDoes this violate the principle of &quot;Least Astonishment&quot;?\n\nThis order of execution is frequently confusing to new users of Python. If you understand the Python execution model, then it becomes quite expected. \n\nThe usual instruction to new Python users:\n\nBut this is why the usual instruction to new users is to create their default arguments like this instead:\n\ndef example_function_2(default_kwarg=None):\n    if default_kwarg is None:\n        default_kwarg = []\n\n\nThis uses the None singleton as a sentinel object to tell the function whether or not we&apos;ve gotten an argument other than the default. If we get no argument, then we actually want to use a new empty list, [], as the default.\n\nAs the tutorial section on control flow says:\n\n\n  If you dont want the default to be shared between subsequent calls,\n  you can write the function like this instead:\n\ndef f(a, L=None):\n    if L is None:\n        L = []\n    L.append(a)\n    return L\n\n\n    ","url":"/questions/[slug]#solution14","@type":"Answer","upvoteCount":0},{"text":"The shortest answer would probably be &quot;definition is execution&quot;, therefore the whole argument makes no strict sense. As a more contrived example, you may cite this:\n\ndef a(): return []\n\ndef b(x=a()):\n    print x\n\n\nHopefully it&apos;s enough to show that not executing the default argument expressions at the execution time of the def statement isn&apos;t easy or doesn&apos;t make sense, or both.\n\nI agree it&apos;s a gotcha when you try to use default constructors, though.\n    ","url":"/questions/[slug]#solution15","@type":"Answer","upvoteCount":0},{"text":"It&apos;s a performance optimization.  As a result of this functionality, which of these two function calls do you think is faster?\n\ndef print_tuple(some_tuple=(1,2,3)):\n    print some_tuple\n\nprint_tuple()        #1\nprint_tuple((1,2,3)) #2\n\n\nI&apos;ll give you a hint.  Here&apos;s the disassembly (see http://docs.python.org/library/dis.html):\n\n#1\n\n0 LOAD_GLOBAL              0 (print_tuple)\n3 CALL_FUNCTION            0\n6 POP_TOP\n7 LOAD_CONST               0 (None)\n10 RETURN_VALUE\n\n\n#2\n\n 0 LOAD_GLOBAL              0 (print_tuple)\n 3 LOAD_CONST               4 ((1, 2, 3))\n 6 CALL_FUNCTION            1\n 9 POP_TOP\n10 LOAD_CONST               0 (None)\n13 RETURN_VALUE\n\n\n\n  I doubt the experienced behavior has a practical use (who really used static variables in C, without breeding bugs ?)\n\n\nAs you can see, there is a performance benefit when using immutable default arguments.  This can make a difference if it&apos;s a frequently called function or the default argument takes a long time to construct.  Also, bear in mind that Python isn&apos;t C.  In C you have constants that are pretty much free.  In Python you don&apos;t have this benefit.\n    ","url":"/questions/[slug]#solution16","@type":"Answer","upvoteCount":0},{"text":"This behavior is not surprising if you take the following into consideration:\n\nThe behavior of read-only class attributes upon assignment attempts, and that\nFunctions are objects (explained well in the accepted answer).\n\nThe role of (2) has been covered extensively in this thread. (1) is likely the astonishment causing factor, as this behavior is not &quot;intuitive&quot; when coming from other languages.\n(1) is described in the Python tutorial on classes. In an attempt to assign a value to a read-only class attribute:\n\n...all variables found outside of the innermost scope are\nread-only (an attempt to write to such a variable will simply create a\nnew local variable in the innermost scope, leaving the identically\nnamed outer variable unchanged).\n\nLook back to the original example and consider the above points:\ndef foo(a=[]):\n    a.append(5)\n    return a\n\nHere foo is an object and a is an attribute of foo (available at foo.func_defs[0]). Since a is a list, a is mutable and is thus a read-write attribute of foo. It is initialized to the empty list as specified by the signature when the function is instantiated, and is available for reading and writing as long as the function object exists.\nCalling foo without overriding a default uses that default&apos;s value from foo.func_defs. In this case, foo.func_defs[0] is used for a within function object&apos;s code scope. Changes to a change foo.func_defs[0], which is part of the foo object and persists between execution of the code in foo.\nNow, compare this to the example from the documentation on emulating the default argument behavior of other languages, such that the function signature defaults are used every time the function is executed:\ndef foo(a, L=None):\n    if L is None:\n        L = []\n    L.append(a)\n    return L\n\nTaking (1) and (2) into account, one can see why this accomplishes the desired behavior:\n\nWhen the foo function object is instantiated, foo.func_defs[0] is set to None, an immutable object.\nWhen the function is executed with defaults (with no parameter specified for L in the function call), foo.func_defs[0] (None) is available in the local scope as L.\nUpon L = [], the assignment cannot succeed at foo.func_defs[0], because that attribute is read-only.\nPer (1), a new local variable also named L is created in the local scope and used for the remainder of the function call. foo.func_defs[0] thus remains unchanged for future invocations of foo.\n\n    ","url":"/questions/[slug]#solution17","@type":"Answer","upvoteCount":0},{"text":"A simple workaround using None\n\n&gt;&gt;&gt; def bar(b, data=None):\n...     data = data or []\n...     data.append(b)\n...     return data\n... \n&gt;&gt;&gt; bar(3)\n[3]\n&gt;&gt;&gt; bar(3)\n[3]\n&gt;&gt;&gt; bar(3)\n[3]\n&gt;&gt;&gt; bar(3, [34])\n[34, 3]\n&gt;&gt;&gt; bar(3, [34])\n[34, 3]\n\n    ","url":"/questions/[slug]#solution18","@type":"Answer","upvoteCount":0},{"text":"It may be true that:\n\n\nSomeone is using every language/library feature, and\nSwitching the behavior here would be ill-advised, but\n\n\nit is entirely consistent to hold to both of the features above and still make another point:\n\n\nIt is a confusing feature and it is unfortunate in Python.\n\n\nThe other answers, or at least some of them either make points 1 and 2 but not 3, or make point 3 and downplay points 1 and 2. But all three are true.\n\nIt may be true that switching horses in midstream here would be asking for significant breakage, and that there could be more problems created by changing Python to intuitively handle Stefano&apos;s opening snippet. And it may be true that someone who knew Python internals well could explain a minefield of consequences. However,\n\nThe existing behavior is not Pythonic, and Python is successful because very little about the language violates the principle of least astonishment anywhere near this badly. It is a real problem, whether or not it would be wise to uproot it. It is a design flaw. If you understand the language much better by trying to trace out the behavior, I can say that C++ does all of this and more; you learn a lot by navigating, for instance, subtle pointer errors. But this is not Pythonic: people who care about Python enough to persevere in the face of this behavior are people who are drawn to the language because Python has far fewer surprises than other language. Dabblers and the curious become Pythonistas when they are astonished at how little time it takes to get something working--not because of a design fl--I mean, hidden logic puzzle--that cuts against the intuitions of programmers who are drawn to Python because it Just Works.\n    ","url":"/questions/[slug]#solution19","@type":"Answer","upvoteCount":0},{"text":"I am going to demonstrate an alternative structure to pass a default list value to a function (it works equally well with dictionaries).  \n\nAs others have extensively commented, the list parameter is bound to the function when it is defined as opposed to when it is executed.  Because lists and dictionaries are mutable, any alteration to this parameter will affect other calls to this function.  As a result, subsequent calls to the function will receive this shared list which may have been altered by any other calls to the function.  Worse yet, two parameters are using this function&apos;s shared parameter at the same time oblivious to the changes made by the other.\n\nWrong Method (probably...):\n\ndef foo(list_arg=[5]):\n    return list_arg\n\na = foo()\na.append(6)\n&gt;&gt;&gt; a\n[5, 6]\n\nb = foo()\nb.append(7)\n# The value of 6 appended to variable &apos;a&apos; is now part of the list held by &apos;b&apos;.\n&gt;&gt;&gt; b\n[5, 6, 7]  \n\n# Although &apos;a&apos; is expecting to receive 6 (the last element it appended to the list),\n# it actually receives the last element appended to the shared list.\n# It thus receives the value 7 previously appended by &apos;b&apos;.\n&gt;&gt;&gt; a.pop()             \n7\n\n\nYou can verify that they are one and the same object by using id:\n\n&gt;&gt;&gt; id(a)\n5347866528\n\n&gt;&gt;&gt; id(b)\n5347866528\n\n\nPer Brett Slatkin&apos;s &quot;Effective Python: 59 Specific Ways to Write Better Python&quot;, Item 20: Use None and Docstrings to specify dynamic default arguments (p. 48)\n\n\n  The convention for achieving the desired result in Python is to\n  provide a default value of None and to document the actual behaviour\n  in the docstring.\n\n\nThis implementation ensures that each call to the function either receives the default list or else the list passed to the function.\n\nPreferred Method:\n\ndef foo(list_arg=None):\n   &quot;&quot;&quot;\n   :param list_arg:  A list of input values. \n                     If none provided, used a list with a default value of 5.\n   &quot;&quot;&quot;\n   if not list_arg:\n       list_arg = [5]\n   return list_arg\n\na = foo()\na.append(6)\n&gt;&gt;&gt; a\n[5, 6]\n\nb = foo()\nb.append(7)\n&gt;&gt;&gt; b\n[5, 7]\n\nc = foo([10])\nc.append(11)\n&gt;&gt;&gt; c\n[10, 11]\n\n\nThere may be legitimate use cases for the &apos;Wrong Method&apos; whereby the programmer intended the default list parameter to be shared, but this is more likely the exception than the rule.\n    ","url":"/questions/[slug]#solution20","@type":"Answer","upvoteCount":0},{"text":"The solutions here are:\n\n\nUse None as your default value (or a nonce object), and switch on that to create your values at runtime; or\nUse a lambda as your default parameter, and call it within a try block to get the default value (this is the sort of thing that lambda abstraction is for).\n\n\nThe second option is nice because users of the function can pass in a callable, which may be already existing (such as a type)\n    ","url":"/questions/[slug]#solution21","@type":"Answer","upvoteCount":0},{"text":"You can get round this by replacing the object (and therefore the tie with the scope):\n\ndef foo(a=[]):\n    a = list(a)\n    a.append(5)\n    return a\n\n\nUgly, but it works.\n    ","url":"/questions/[slug]#solution22","@type":"Answer","upvoteCount":0},{"text":"When we do this:\n\ndef foo(a=[]):\n    ...\n\n\n... we assign the argument a to an unnamed list, if the caller does not pass the value of a.\n\nTo make things simpler for this discussion, let&apos;s temporarily give the unnamed list a name. How about pavlo ?\n\ndef foo(a=pavlo):\n   ...\n\n\nAt any time, if the caller doesn&apos;t tell us what a is, we reuse pavlo.\n\nIf pavlo is mutable (modifiable), and foo ends up modifying it, an effect we notice the next time foo is called without specifying a.\n\nSo this is what you see (Remember, pavlo is initialized to []):\n\n &gt;&gt;&gt; foo()\n [5]\n\n\nNow, pavlo is [5].\n\nCalling foo() again modifies pavlo again:\n\n&gt;&gt;&gt; foo()\n[5, 5]\n\n\nSpecifying a when calling foo() ensures pavlo is not touched.\n\n&gt;&gt;&gt; ivan = [1, 2, 3, 4]\n&gt;&gt;&gt; foo(a=ivan)\n[1, 2, 3, 4, 5]\n&gt;&gt;&gt; ivan\n[1, 2, 3, 4, 5]\n\n\nSo, pavlo is still [5, 5].\n\n&gt;&gt;&gt; foo()\n[5, 5, 5]\n\n    ","url":"/questions/[slug]#solution23","@type":"Answer","upvoteCount":0},{"text":"I sometimes exploit this behavior as an alternative to the following pattern:\n\nsingleton = None\n\ndef use_singleton():\n    global singleton\n\n    if singleton is None:\n        singleton = _make_singleton()\n\n    return singleton.use_me()\n\n\nIf singleton is only used by use_singleton, I like the following pattern as a replacement:\n\n# _make_singleton() is called only once when the def is executed\ndef use_singleton(singleton=_make_singleton()):\n    return singleton.use_me()\n\n\nI&apos;ve used this for instantiating client classes that access external resources, and also for creating dicts or lists for memoization.\n\nSince I don&apos;t think this pattern is well known, I do put a short comment in to guard against future misunderstandings.\n    ","url":"/questions/[slug]#solution24","@type":"Answer","upvoteCount":0},{"text":"Every other answer explains why this is actually a nice and desired behavior, or why you shouldn&apos;t be needing this anyway. Mine is for those stubborn ones who want to exercise their right to bend the language to their will, not the other way around.\nWe will &quot;fix&quot; this behavior with a decorator that will copy the default value instead of reusing the same instance for each positional argument left at its default value.\n\nimport inspect\nfrom copy import deepcopy  # copy would fail on deep arguments like nested dicts\n\ndef sanify(function):\n    def wrapper(*a, **kw):\n        # store the default values\n        defaults = inspect.getargspec(function).defaults # for python2\n        # construct a new argument list\n        new_args = []\n        for i, arg in enumerate(defaults):\n            # allow passing positional arguments\n            if i in range(len(a)):\n                new_args.append(a[i])\n            else:\n                # copy the value\n                new_args.append(deepcopy(arg))\n        return function(*new_args, **kw)\n    return wrapper\n\nNow let&apos;s redefine our function using this decorator:\n@sanify\ndef foo(a=[]):\n    a.append(5)\n    return a\n\nfoo() # &apos;[5]&apos;\nfoo() # &apos;[5]&apos; -- as desired\n\nThis is particularly neat for functions that take multiple arguments. Compare:\n# the &apos;correct&apos; approach\ndef bar(a=None, b=None, c=None):\n    if a is None:\n        a = []\n    if b is None:\n        b = []\n    if c is None:\n        c = []\n    # finally do the actual work\n\nwith\n# the nasty decorator hack\n@sanify\ndef bar(a=[], b=[], c=[]):\n    # wow, works right out of the box!\n\nIt&apos;s important to note that the above solution breaks if you try to use keyword args, like so:\nfoo(a=[4])\n\nThe decorator could be adjusted to allow for that, but we leave this as an exercise for the reader ;)\n    ","url":"/questions/[slug]#solution25","@type":"Answer","upvoteCount":0},{"text":"This &quot;bug&quot; gave me a lot of overtime work hours! But I&apos;m beginning to see a potential use of it (but I would have liked it to be at the execution time, still)\n\nI&apos;m gonna give you what I see as a useful example.\n\ndef example(errors=[]):\n    # statements\n    # Something went wrong\n    mistake = True\n    if mistake:\n        tryToFixIt(errors)\n        # Didn&apos;t work.. let&apos;s try again\n        tryToFixItAnotherway(errors)\n        # This time it worked\n    return errors\n\ndef tryToFixIt(err):\n    err.append(&apos;Attempt to fix it&apos;)\n\ndef tryToFixItAnotherway(err):\n    err.append(&apos;Attempt to fix it by another way&apos;)\n\ndef main():\n    for item in range(2):\n        errors = example()\n    print &apos;\\n&apos;.join(errors)\n\nmain()\n\n\nprints the following\n\nAttempt to fix it\nAttempt to fix it by another way\nAttempt to fix it\nAttempt to fix it by another way\n\n    ","url":"/questions/[slug]#solution26","@type":"Answer","upvoteCount":0},{"text":"This is not a design flaw. Anyone who trips over this is doing something wrong.\n\nThere are 3 cases I see where you might run into this problem:\n\n\nYou intend to modify the argument as a side effect of the function. In this case it never makes sense to have a default argument. The only exception is when you&apos;re abusing the argument list to have function attributes, e.g. cache={}, and you wouldn&apos;t be expected to call the function with an actual argument at all.\nYou intend to leave the argument unmodified, but you accidentally did modify it. That&apos;s a bug, fix it.\nYou intend to modify the argument for use inside the function, but didn&apos;t expect the modification to be viewable outside of the function. In that case you need to make a copy of the argument, whether it was the default or not! Python is not a call-by-value language so it doesn&apos;t make the copy for you, you need to be explicit about it.\n\n\nThe example in the question could fall into category 1 or 3. It&apos;s odd that it both modifies the passed list and returns it; you should pick one or the other.\n    ","url":"/questions/[slug]#solution27","@type":"Answer","upvoteCount":0},{"text":"Just change the function to be:\n\ndef notastonishinganymore(a = []): \n    &apos;&apos;&apos;The name is just a joke :)&apos;&apos;&apos;\n    a = a[:]\n    a.append(5)\n    return a\n\n    ","url":"/questions/[slug]#solution28","@type":"Answer","upvoteCount":0},{"text":"TLDR: Define-time defaults are consistent and strictly more expressive.\n\n\n\nDefining a function affects two scopes: the defining scope containing the function, and the execution  scope contained by the function. While it is pretty clear how blocks map to scopes, the question is where def &lt;name&gt;(&lt;args=defaults&gt;): belongs to:\n\n...                           # defining scope\ndef name(parameter=default):  # ???\n    ...                       # execution scope\n\n\nThe def name part must evaluate in the defining scope - we want name to be available there, after all. Evaluating the function only inside itself would make it inaccessible.\n\nSince parameter is a constant name, we can &quot;evaluate&quot; it at the same time as def name. This also has the advantage it produces the function with a known signature as name(parameter=...):, instead of a bare name(...):.\n\nNow, when to evaluate default?\n\nConsistency already says &quot;at definition&quot;: everything else of def &lt;name&gt;(&lt;args=defaults&gt;): is best evaluated at definition as well. Delaying parts of it would be the astonishing choice.\n\nThe two choices are not equivalent, either: If default is evaluated at definition time, it can still affect execution time. If default is evaluated at execution time, it cannot affect definition time. Choosing &quot;at definition&quot; allows expressing both cases, while choosing &quot;at execution&quot; can express only one:\n\ndef name(parameter=defined):  # set default at definition time\n    ...\n\ndef name(parameter=default):     # delay default until execution time\n    parameter = default if parameter is None else parameter\n    ...\n\n    ","url":"/questions/[slug]#solution29","@type":"Answer","upvoteCount":0},{"text":"I think the answer to this question lies in how python pass data to parameter (pass by value or by reference), not mutability or how python handle the &quot;def&quot; statement.\n\nA brief introduction. First, there are two type of data types in python, one is simple elementary data type, like numbers, and another data type is objects. Second, when passing data to parameters, python pass elementary data type by value, i.e., make a local copy of the value to a local variable, but pass object by reference, i.e., pointers to the object.\n\nAdmitting the above two points, let&apos;s explain what happened to the python code. It&apos;s only because of passing by reference for objects, but has nothing to do with mutable/immutable, or arguably the fact that &quot;def&quot; statement is executed only once when it is defined.\n\n[] is an object, so python pass the reference of [] to a, i.e., a is only a pointer to [] which lies in memory as an object. There is only one copy of [] with, however, many references to it. For the first foo(), the list [] is changed to 1 by append method. But Note that there is only one copy of the list object and this object now becomes 1. When running the second foo(), what effbot webpage says (items is not evaluated any more) is wrong. a is evaluated to be the list object, although now the content of the object is 1. This is the effect of passing by reference! The result of foo(3) can be easily derived in the same way.\n\nTo further validate my answer, let&apos;s take a look at two additional codes.\n\n====== No. 2 ========\n\ndef foo(x, items=None):\n    if items is None:\n        items = []\n    items.append(x)\n    return items\n\nfoo(1)  #return [1]\nfoo(2)  #return [2]\nfoo(3)  #return [3]\n\n\n[] is an object, so is None (the former is mutable while the latter is immutable. But the mutability has nothing to do with the question). None is somewhere in the space but we know it&apos;s there and there is only one copy of None there. So every time foo is invoked, items is evaluated (as opposed to some answer that it is only evaluated once) to be None, to be clear, the reference (or the address) of None. Then in the foo, item is changed to [], i.e., points to another object which has a different address. \n\n====== No. 3 =======\n\ndef foo(x, items=[]):\n    items.append(x)\n    return items\n\nfoo(1)    # returns [1]\nfoo(2,[]) # returns [2]\nfoo(3)    # returns [1,3]\n\n\nThe invocation of foo(1) make items point to a list object [] with an address, say, 11111111. the content of the list is changed to 1 in the foo function in the sequel, but the address is not changed, still 11111111. Then foo(2,[]) is coming. Although the [] in foo(2,[]) has the same content as the default parameter [] when calling foo(1), their address are different! Since we provide the parameter explicitly, items has to take the address of this new [], say 2222222, and return it after making some change. Now foo(3) is executed. since only x is provided, items has to take its default value again. What&apos;s the default value? It is set when defining the foo function: the list object located in 11111111. So the items is evaluated to be the address 11111111 having an element 1. The list located at 2222222 also contains one element 2, but it is not pointed by items any more. Consequently, An append of 3 will make items [1,3]. \n\nFrom the above explanations, we can see that the effbot webpage recommended in the accepted answer failed to give a relevant answer to this question. What is more, I think a point in the effbot webpage is wrong. I think the code regarding the UI.Button is correct:\n\nfor i in range(10):\n    def callback():\n        print &quot;clicked button&quot;, i\n    UI.Button(&quot;button %s&quot; % i, callback)\n\n\nEach button can hold a distinct callback function which will display different value of i. I can provide an example to show this:\n\nx=[]\nfor i in range(10):\n    def callback():\n        print(i)\n    x.append(callback) \n\n\nIf we execute x[7]() we&apos;ll get 7 as expected, and x[9]() will gives 9, another value of i.\n    ","url":"/questions/[slug]#solution30","@type":"Answer","upvoteCount":0}],"@type":"Question"}}</script><meta name="next-head-count" content="22"/><link rel="preload" href="/_next/static/css/c116652e2d6f4ad0.css" as="style"/><link rel="stylesheet" href="/_next/static/css/c116652e2d6f4ad0.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-0d1b80a048d4787e.js"></script><script src="/_next/static/chunks/webpack-42cdea76c8170223.js" defer=""></script><script src="/_next/static/chunks/framework-4556c45dd113b893.js" defer=""></script><script src="/_next/static/chunks/main-ccfab947c79712f4.js" defer=""></script><script src="/_next/static/chunks/pages/_app-43d1c35cd6eb9b8f.js" defer=""></script><script src="/_next/static/chunks/294-106ef8570fa99deb.js" defer=""></script><script src="/_next/static/chunks/490-7f0418bb4354ac73.js" defer=""></script><script src="/_next/static/chunks/pages/questions/%5Bslug%5D-50e201fdaa1e0fd1.js" defer=""></script><script src="/_next/static/00bsHgHZki2FteshOatnd/_buildManifest.js" defer=""></script><script src="/_next/static/00bsHgHZki2FteshOatnd/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="wrapper"><header><nav class="bg-white border-gray-200 px-4 lg:px-6 py-2.5 dark:bg-gray-800"><div class="flex flex-wrap justify-between items-center mx-auto max-w-screen-xl"><a class="flex items-center" href="/"><img src="/logo-second.png" class="mr-3 h-6 sm:h-9" alt="Solution Checker Logo"/><h1 class="self-center text-xl font-semibold whitespace-nowrap dark:text-white">Solution Checker</h1></a><div class="flex items-center lg:order-2"><button data-collapse-toggle="mobile-menu-2" type="button" class="inline-flex items-center p-2 ml-1 text-sm text-gray-500 rounded-lg lg:hidden hover:bg-gray-100 focus:outline-none focus:ring-2 focus:ring-gray-200 dark:text-gray-400 dark:hover:bg-gray-700 dark:focus:ring-gray-600" aria-controls="mobile-menu-2" aria-expanded="false"><span class="sr-only">Open main menu</span><svg class="w-6 h-6" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M3 5a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM3 10a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM3 15a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1z" clip-rule="evenodd"></path></svg><svg class="hidden w-6 h-6" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z" clip-rule="evenodd"></path></svg></button></div><div class="hidden justify-between items-center w-full lg:flex lg:w-auto lg:order-1" id="mobile-menu-2"><ul class="flex flex-col mt-4 font-medium lg:flex-row lg:space-x-8 lg:mt-0"><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" aria-current="page" href="/">Home</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/questions?tab=news">Questions</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/post?tab=news">Post</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/questions/%22least-astonishment%22-and-the-mutable-default-argument-1657384412508#">Coding</a></li></ul></div></div></nav></header><div class="main-content"><div class="question my-5"><div class="flex question-header items-center m-auto justify-center"><div class="rounded-xl w-full border p-5 shadow-md bg-white"><div class="flex w-full items-center justify-between border-b pb-3"><div class="flex items-center space-x-3"><div class="text-lg font-bold text-slate-700"><a href="/questions/%22least-astonishment%22-and-the-mutable-default-argument-1657384412508"><h1>&quot;Least Astonishment&quot; and the Mutable Default Argument</h1></a></div></div><div class="flex flex-wrap h-auto justify-end items-center space-x-8"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold" href="/questions/tag/language-design">language-design</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold" href="/questions/tag/default-parameters">default-parameters</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold" href="/questions/tag/least-astonishment">least-astonishment</a></div></div><div class="question-content mt-5">
                
<p>Anyone tinkering with Python long enough has been bitten (or torn to pieces) by the following issue:</p>
<pre class="lang-py s-code-block"><code class="hljs language-python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">a=[]</span>):
    a.append(<span class="hljs-number">5</span>)
    <span class="hljs-keyword">return</span> a
</code></pre>
<p>Python novices would expect this function to always return a list with only one element: <code>[5]</code>. The result is instead very different, and very astonishing (for a novice):</p>
<pre class="lang-py s-code-block"><code class="hljs language-python"><span class="hljs-meta">&gt;&gt;&gt; </span>foo()
[<span class="hljs-number">5</span>]
<span class="hljs-meta">&gt;&gt;&gt; </span>foo()
[<span class="hljs-number">5</span>, <span class="hljs-number">5</span>]
<span class="hljs-meta">&gt;&gt;&gt; </span>foo()
[<span class="hljs-number">5</span>, <span class="hljs-number">5</span>, <span class="hljs-number">5</span>]
<span class="hljs-meta">&gt;&gt;&gt; </span>foo()
[<span class="hljs-number">5</span>, <span class="hljs-number">5</span>, <span class="hljs-number">5</span>, <span class="hljs-number">5</span>]
<span class="hljs-meta">&gt;&gt;&gt; </span>foo()
</code></pre>
<p>A manager of mine once had his first encounter with this feature, and called it "a dramatic design flaw" of the language. I replied that the behavior had an underlying explanation, and it is indeed very puzzling and unexpected if you don't understand the internals. However, I was not able to answer (to myself) the following question: what is the reason for binding the default argument at function definition, and not at function execution? I doubt the experienced behavior has a practical use (who really used static variables in C, without breeding bugs?)</p>
<p><strong>Edit</strong>:</p>
<p><a href="https://stackoverflow.com/a/1137164/7487335">Baczek made an interesting example</a>. Together with most of your comments and <a href="https://stackoverflow.com/a/1134623/7487335">Utaal's in particular</a>, I elaborated further:</p>
<pre class="lang-py s-code-block"><code class="hljs language-python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">def</span> <span class="hljs-title function_">a</span>():
<span class="hljs-meta">... </span>    <span class="hljs-built_in">print</span>(<span class="hljs-string">"a executed"</span>)
<span class="hljs-meta">... </span>    <span class="hljs-keyword">return</span> []
<span class="hljs-meta">... </span>
<span class="hljs-meta">&gt;&gt;&gt; </span>           
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">def</span> <span class="hljs-title function_">b</span>(<span class="hljs-params">x=a(<span class="hljs-params"></span>)</span>):
<span class="hljs-meta">... </span>    x.append(<span class="hljs-number">5</span>)
<span class="hljs-meta">... </span>    <span class="hljs-built_in">print</span>(x)
<span class="hljs-meta">... </span>
a executed
<span class="hljs-meta">&gt;&gt;&gt; </span>b()
[<span class="hljs-number">5</span>]
<span class="hljs-meta">&gt;&gt;&gt; </span>b()
[<span class="hljs-number">5</span>, <span class="hljs-number">5</span>]
</code></pre>
<p>To me, it seems that the design decision was relative to where to put the scope of parameters: inside the function, or "together" with it?</p>
<p>Doing the binding inside the function would mean that <code>x</code> is effectively bound to the specified default when the function is called, not defined, something that would present a deep flaw: the <code>def</code> line would be "hybrid" in the sense that part of the binding (of the function object) would happen at definition, and part (assignment of default parameters) at function invocation time.</p>
<p>The actual behavior is more consistent: everything of that line gets evaluated when that line is executed, meaning at function definition.</p>
    </div></div></div><div class="solution-section"><nav class="flex pagination-solution flex-col justify-end"><h1 class="text-lg font-semibold mb-5">Navigate to solutions: </h1><ul class="inline-flex -space-x-px overflow-auto"><li class="pagination-solution-item"><span data-id="#solution1" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">1</span></li><li class="pagination-solution-item"><span data-id="#solution2" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">2</span></li><li class="pagination-solution-item"><span data-id="#solution3" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">3</span></li><li class="pagination-solution-item"><span data-id="#solution4" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">4</span></li><li class="pagination-solution-item"><span data-id="#solution5" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">5</span></li><li class="pagination-solution-item"><span data-id="#solution6" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">6</span></li><li class="pagination-solution-item"><span data-id="#solution7" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">7</span></li><li class="pagination-solution-item"><span data-id="#solution8" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">8</span></li><li class="pagination-solution-item"><span data-id="#solution9" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">9</span></li><li class="pagination-solution-item"><span data-id="#solution10" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">10</span></li><li class="pagination-solution-item"><span data-id="#solution11" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">11</span></li><li class="pagination-solution-item"><span data-id="#solution12" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">12</span></li><li class="pagination-solution-item"><span data-id="#solution13" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">13</span></li><li class="pagination-solution-item"><span data-id="#solution14" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">14</span></li><li class="pagination-solution-item"><span data-id="#solution15" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">15</span></li><li class="pagination-solution-item"><span data-id="#solution16" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">16</span></li><li class="pagination-solution-item"><span data-id="#solution17" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">17</span></li><li class="pagination-solution-item"><span data-id="#solution18" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">18</span></li><li class="pagination-solution-item"><span data-id="#solution19" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">19</span></li><li class="pagination-solution-item"><span data-id="#solution20" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">20</span></li><li class="pagination-solution-item"><span data-id="#solution21" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">21</span></li><li class="pagination-solution-item"><span data-id="#solution22" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">22</span></li><li class="pagination-solution-item"><span data-id="#solution23" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">23</span></li><li class="pagination-solution-item"><span data-id="#solution24" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">24</span></li><li class="pagination-solution-item"><span data-id="#solution25" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">25</span></li><li class="pagination-solution-item"><span data-id="#solution26" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">26</span></li><li class="pagination-solution-item"><span data-id="#solution27" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">27</span></li><li class="pagination-solution-item"><span data-id="#solution28" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">28</span></li><li class="pagination-solution-item"><span data-id="#solution29" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">29</span></li><li class="pagination-solution-item"><span data-id="#solution30" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">30</span></li></ul></nav><div id="solution1" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 1</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/language-design">language-design</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/default-parameters">default-parameters</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/least-astonishment">least-astonishment</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Actually, this is not a design flaw, and it is not because of internals or performance. It comes simply from the fact that functions in Python are first-class objects, and not only a piece of code.</p>
<p>As soon as you think of it this way, then it completely makes sense: a function is an object being evaluated on its definition; default parameters are kind of "member data" and therefore their state may change from one call to the other - exactly as in any other object.</p>
<p>In any case, the effbot (Fredrik Lundh) has a very nice explanation of the reasons for this behavior in <a href="https://web.archive.org/web/20200221224620id_/http://effbot.org/zone/default-values.htm" rel="noreferrer">Default Parameter Values in Python</a>.
I found it very clear, and I really suggest reading it for a better knowledge of how function objects work.</p>
    </div></div></div></div><div id="solution2" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 2</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/language-design">language-design</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/default-parameters">default-parameters</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/least-astonishment">least-astonishment</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Suppose you have the following code</p>
<pre class="lang-py s-code-block"><code class="hljs language-python">fruits = (<span class="hljs-string">"apples"</span>, <span class="hljs-string">"bananas"</span>, <span class="hljs-string">"loganberries"</span>)

<span class="hljs-keyword">def</span> <span class="hljs-title function_">eat</span>(<span class="hljs-params">food=fruits</span>):
    ...
</code></pre>
<p>When I see the declaration of eat, the least astonishing thing is to think that if the first parameter is not given, that it will be equal to the tuple <code>("apples", "bananas", "loganberries")</code></p>
<p>However, suppose later on in the code, I do something like</p>
<pre class="lang-py s-code-block"><code class="hljs language-python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">some_random_function</span>():
    <span class="hljs-keyword">global</span> fruits
    fruits = (<span class="hljs-string">"blueberries"</span>, <span class="hljs-string">"mangos"</span>)
</code></pre>
<p>then if default parameters were bound at function execution rather than function declaration, I would be astonished (in a very bad way) to discover that fruits had been changed. This would be more astonishing IMO than discovering that your <code>foo</code> function above was mutating the list.</p>
<p>The real problem lies with mutable variables, and all languages have this problem to some extent. Here's a question: suppose in Java I have the following code:</p>
<pre class="lang-java s-code-block"><code class="hljs language-java"><span class="hljs-type">StringBuffer</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuffer</span>(<span class="hljs-string">"Hello World!"</span>);
Map&lt;StringBuffer,Integer&gt; counts = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;StringBuffer,Integer&gt;();
counts.put(s, <span class="hljs-number">5</span>);
s.append(<span class="hljs-string">"!!!!"</span>);
System.out.println( counts.get(s) );  <span class="hljs-comment">// does this work?</span>
</code></pre>
<p>Now, does my map use the value of the <code>StringBuffer</code> key when it was placed into the map, or does it store the key by reference? Either way, someone is astonished; either the person who tried to get the object out of the <code>Map</code> using a value identical to the one they put it in with, or the person who can't seem to retrieve their object even though the key they're using is literally the same object that was used to put it into the map (this is actually why Python doesn't allow its mutable built-in data types to be used as dictionary keys).</p>
<p>Your example is a good one of a case where Python newcomers will be surprised and bitten. But I'd argue that if we "fixed" this, then that would only create a different situation where they'd be bitten instead, and that one would be even less intuitive. Moreover, this is always the case when dealing with mutable variables; you always run into cases where someone could intuitively expect one or the opposite behavior depending on what code they're writing.</p>
<p>I personally like Python's current approach: default function arguments are evaluated when the function is defined and that object is always the default. I suppose they could special-case using an empty list, but that kind of special casing would cause even more astonishment, not to mention be backwards incompatible.</p>
    </div></div></div></div><div id="solution3" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 3</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/language-design">language-design</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/default-parameters">default-parameters</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/least-astonishment">least-astonishment</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>The relevant part of the <a href="http://docs.python.org/reference/compound_stmts.html#function-definitions" rel="noreferrer">documentation</a>:</p>

<blockquote>
  <p><strong>Default parameter values are evaluated from left to right when the function definition is executed.</strong> This means that the expression is evaluated once, when the function is defined, and that the same pre-computed value is used for each call. This is especially important to understand when a default parameter is a mutable object, such as a list or a dictionary: if the function modifies the object (e.g. by appending an item to a list), the default value is in effect modified. This is generally not what was intended. A way around this is to use <code>None</code> as the default, and explicitly test for it in the body of the function, e.g.:</p>

<pre class="lang-py s-code-block"><code class="hljs language-python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">whats_on_the_telly</span>(<span class="hljs-params">penguin=<span class="hljs-literal">None</span></span>):
    <span class="hljs-keyword">if</span> penguin <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:
        penguin = []
    penguin.append(<span class="hljs-string">"property of the zoo"</span>)
    <span class="hljs-keyword">return</span> penguin
</code></pre>
</blockquote>
    </div></div></div></div><div id="solution4" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 4</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/language-design">language-design</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/default-parameters">default-parameters</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/least-astonishment">least-astonishment</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>I know nothing about the Python interpreter inner workings (and I'm not an expert in compilers and interpreters either) so don't blame me if I propose anything unsensible or impossible.</p>

<p>Provided that python objects <strong>are mutable</strong> I think that this should be taken into account when designing the default arguments stuff.
When you instantiate a list:</p>

<pre class="lang-py s-code-block"><code class="hljs language-python">a = []
</code></pre>

<p>you expect to get a <strong>new</strong> list referenced by <code>a</code>.</p>

<p>Why should the <code>a=[]</code> in</p>

<pre class="lang-py s-code-block"><code class="hljs language-python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">x</span>(<span class="hljs-params">a=[]</span>):
</code></pre>

<p>instantiate a new list on function definition and not on invocation?
It's just like you're asking "if the user doesn't provide the argument then <em>instantiate</em> a new list and use it as if it was produced by the caller".
I think this is ambiguous instead:</p>

<pre class="lang-py s-code-block"><code class="hljs language-python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">x</span>(<span class="hljs-params">a=datetime.datetime.now(<span class="hljs-params"></span>)</span>):
</code></pre>

<p>user, do you want <code>a</code> to default to the datetime corresponding to when you're defining or executing <code>x</code>?
In this case, as in the previous one, I'll keep the same behaviour as if the default argument "assignment" was the first instruction of the function (<code>datetime.now()</code> called on function invocation).
On the other hand, if the user wanted the definition-time mapping he could write:</p>

<pre class="lang-py s-code-block"><code class="hljs language-python">b = datetime.datetime.now()
<span class="hljs-keyword">def</span> <span class="hljs-title function_">x</span>(<span class="hljs-params">a=b</span>):
</code></pre>

<p>I know, I know: that's a closure. Alternatively Python might provide a keyword to force definition-time binding:</p>

<pre class="lang-py s-code-block"><code class="hljs language-python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">x</span>(<span class="hljs-params">static a=b</span>):
</code></pre>
    </div></div></div></div><div id="solution5" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 5</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/language-design">language-design</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/default-parameters">default-parameters</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/least-astonishment">least-astonishment</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Well, the reason is quite simply that bindings are done when code is executed, and the function definition is executed, well... when the functions is defined.</p>

<p>Compare this:</p>

<pre class="lang-py s-code-block"><code class="hljs language-python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">BananaBunch</span>:
    bananas = []

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">addBanana</span>(<span class="hljs-params">self, banana</span>):
        self.bananas.append(banana)
</code></pre>

<p>This code suffers from the exact same unexpected happenstance. bananas is a class attribute, and hence, when you add things to it, it's added to all instances of that class. The reason is exactly the same.</p>

<p>It's just "How It Works", and making it work differently in the function case would probably be complicated, and in the class case likely impossible, or at least slow down object instantiation a lot, as you would have to keep the class code around and execute it when objects are created.</p>

<p>Yes, it is unexpected. But once the penny drops, it fits in perfectly with how Python works in general. In fact, it's a good teaching aid, and once you understand why this happens, you'll grok python much better.</p>

<p>That said it should feature prominently in any good Python tutorial. Because as you mention, everyone runs into this problem sooner or later.</p>
    </div></div></div></div><div id="solution6" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 6</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/language-design">language-design</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/default-parameters">default-parameters</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/least-astonishment">least-astonishment</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<h2>Why don't you introspect?</h2>

<p>I'm <em>really</em> surprised no one has performed the insightful introspection offered by Python (<code>2</code> and <code>3</code> apply) on callables. </p>

<p>Given a simple little function <code>func</code> defined as:</p>

<pre class="lang-py s-code-block"><code class="hljs language-python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">def</span> <span class="hljs-title function_">func</span>(<span class="hljs-params">a = []</span>):
<span class="hljs-meta">... </span>   a.append(<span class="hljs-number">5</span>)
</code></pre>

<p>When Python encounters it, the first thing it will do is compile it in order to create a <code>code</code> object for this function. While this compilation step is done, <em>Python <strong>evaluates</strong>* and then <strong>stores</strong> the default arguments (an empty list <code>[]</code> here) in the function object itself</em>. As the top answer mentioned: the list <code>a</code> can now be considered a <em>member</em> of the function <code>func</code>.</p>

<p>So, let's do some introspection, a before and after to examine how the list gets expanded <strong>inside</strong> the function object. I'm using <code>Python 3.x</code> for this, for Python 2 the same applies (use <code>__defaults__</code> or <code>func_defaults</code> in Python 2; yes, two names for the same thing).</p>

<h3>Function Before Execution:</h3>

<pre class="lang-py s-code-block"><code class="hljs language-python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">def</span> <span class="hljs-title function_">func</span>(<span class="hljs-params">a = []</span>):
<span class="hljs-meta">... </span>    a.append(<span class="hljs-number">5</span>)
<span class="hljs-meta">... </span>    
</code></pre>

<p>After Python executes this definition it will take any default parameters specified (<code>a = []</code> here) and <a href="https://docs.python.org/3/reference/datamodel.html#the-standard-type-hierarchy" rel="noreferrer">cram them in the <code>__defaults__</code> attribute for the function object</a> (relevant section: Callables):     </p>

<pre class="lang-py s-code-block"><code class="hljs language-python"><span class="hljs-meta">&gt;&gt;&gt; </span>func.__defaults__
([],)
</code></pre>

<p>O.k, so an empty list as the single entry in <code>__defaults__</code>, just as expected. </p>

<h3>Function After Execution:</h3>

<p>Let's now execute this function:</p>

<pre class="lang-py s-code-block"><code class="hljs language-python"><span class="hljs-meta">&gt;&gt;&gt; </span>func()
</code></pre>

<p>Now, let's see those <code>__defaults__</code> again: </p>

<pre class="lang-py s-code-block"><code class="hljs language-python"><span class="hljs-meta">&gt;&gt;&gt; </span>func.__defaults__
([<span class="hljs-number">5</span>],)
</code></pre>

<p><em>Astonished?</em> The value inside the object changes! Consecutive calls to the function will now simply append to that embedded <code>list</code> object:</p>

<pre class="lang-py s-code-block"><code class="hljs language-python"><span class="hljs-meta">&gt;&gt;&gt; </span>func(); func(); func()
<span class="hljs-meta">&gt;&gt;&gt; </span>func.__defaults__
([<span class="hljs-number">5</span>, <span class="hljs-number">5</span>, <span class="hljs-number">5</span>, <span class="hljs-number">5</span>],)
</code></pre>

<p>So, there you have it, the reason why this <em>'flaw'</em> happens, is because default arguments are part of the function object. There's nothing weird going on here, it's all just a bit surprising.</p>

<p>The common solution to combat this is to use <code>None</code> as the default and then initialize in the function body:</p>

<pre class="lang-py s-code-block"><code class="hljs language-python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">func</span>(<span class="hljs-params">a = <span class="hljs-literal">None</span></span>):
    <span class="hljs-comment"># or: a = [] if a is None else a</span>
    <span class="hljs-keyword">if</span> a <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:
        a = []
</code></pre>

<p>Since the function body is executed anew each time, you always get a fresh new empty list if no argument was passed for <code>a</code>.</p>

<hr>

<p>To further verify that the list in <code>__defaults__</code> is the same as that used in the function <code>func</code> you can just change your function to return the <code>id</code> of the list <code>a</code> used inside the function body. Then, compare it to the list in <code>__defaults__</code> (position <code>[0]</code> in <code>__defaults__</code>) and you'll see how these are indeed refering to the same list instance:</p>

<pre class="lang-py s-code-block"><code class="hljs language-python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">def</span> <span class="hljs-title function_">func</span>(<span class="hljs-params">a = []</span>): 
<span class="hljs-meta">... </span>    a.append(<span class="hljs-number">5</span>)
<span class="hljs-meta">... </span>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">id</span>(a)
&gt;&gt;&gt;
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">id</span>(func.__defaults__[<span class="hljs-number">0</span>]) == func()
<span class="hljs-literal">True</span>
</code></pre>

<p>All with the power of introspection! </p>

<hr>

<p><sup>*</sup> To verify that Python evaluates the default arguments during compilation of the function, try executing the following:</p>

<pre class="lang-py s-code-block"><code class="hljs language-python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">bar</span>(<span class="hljs-params">a=<span class="hljs-built_in">input</span>(<span class="hljs-params"><span class="hljs-string">'Did you just see me without calling the function?'</span></span>)</span>): 
    <span class="hljs-keyword">pass</span>  <span class="hljs-comment"># use raw_input in Py2</span>
</code></pre>

<p>as you'll notice, <code>input()</code> is called before the process of building the function and binding it to the name <code>bar</code> is made.</p>
    </div></div></div></div><div id="solution7" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 7</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/language-design">language-design</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/default-parameters">default-parameters</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/least-astonishment">least-astonishment</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>I used to think that creating the objects at runtime would be the better approach.  I'm less certain now, since you do lose some useful features, though it may be worth it regardless simply to prevent newbie confusion.  The disadvantages of doing so are:</p>

<p><strong>1. Performance</strong></p>

<pre class="lang-py s-code-block"><code class="hljs language-python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">arg=something_expensive_to_compute(<span class="hljs-params"></span>)</span>)):
    ...
</code></pre>

<p>If call-time evaluation is used, then the expensive function is called every time your function is used without an argument.  You'd either pay an expensive price on each call, or need to manually cache the value externally, polluting your namespace and adding verbosity.</p>

<p><strong>2. Forcing bound parameters</strong></p>

<p>A useful trick is to bind parameters of a lambda to the <em>current</em> binding of a variable when the lambda is created.  For example:</p>

<pre class="lang-py s-code-block"><code class="hljs language-python">funcs = [ <span class="hljs-keyword">lambda</span> i=i: i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>)]
</code></pre>

<p>This returns a list of functions that return 0,1,2,3... respectively.  If the behaviour is changed, they will instead bind <code>i</code> to the <em>call-time</em> value of i, so you would get a list of functions that all returned <code>9</code>.</p>

<p>The only way to implement this otherwise would be to create a further closure with the i bound, ie:</p>

<pre class="lang-py s-code-block"><code class="hljs language-python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">make_func</span>(<span class="hljs-params">i</span>): <span class="hljs-keyword">return</span> <span class="hljs-keyword">lambda</span>: i
funcs = [make_func(i) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>)]
</code></pre>

<p><strong>3. Introspection</strong></p>

<p>Consider the code:</p>

<pre class="lang-py s-code-block"><code class="hljs language-python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">a=<span class="hljs-string">'test'</span>, b=<span class="hljs-number">100</span>, c=[]</span>):
   <span class="hljs-built_in">print</span> a,b,c
</code></pre>

<p>We can get information about the arguments and defaults using the <code>inspect</code> module, which </p>

<pre class="lang-py s-code-block"><code class="hljs language-python"><span class="hljs-meta">&gt;&gt;&gt; </span>inspect.getargspec(foo)
([<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'c'</span>], <span class="hljs-literal">None</span>, <span class="hljs-literal">None</span>, (<span class="hljs-string">'test'</span>, <span class="hljs-number">100</span>, []))
</code></pre>

<p>This information is very useful for things like document generation, metaprogramming, decorators etc.</p>

<p>Now, suppose the behaviour of defaults could be changed so that this is the equivalent of:</p>

<pre class="lang-py s-code-block"><code class="hljs language-python">_undefined = <span class="hljs-built_in">object</span>()  <span class="hljs-comment"># sentinel value</span>

<span class="hljs-keyword">def</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">a=_undefined, b=_undefined, c=_undefined</span>)
    <span class="hljs-keyword">if</span> a <span class="hljs-keyword">is</span> _undefined: a=<span class="hljs-string">'test'</span>
    <span class="hljs-keyword">if</span> b <span class="hljs-keyword">is</span> _undefined: b=<span class="hljs-number">100</span>
    <span class="hljs-keyword">if</span> c <span class="hljs-keyword">is</span> _undefined: c=[]
</code></pre>

<p>However, we've lost the ability to introspect, and see what the default arguments <em>are</em>.  Because the objects haven't been constructed, we can't ever get hold of them without actually calling the function.  The best we could do is to store off the source code and return that as a string.</p>
    </div></div></div></div><div id="solution8" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 8</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/language-design">language-design</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/default-parameters">default-parameters</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/least-astonishment">least-astonishment</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<h1>5 points in defense of Python</h1>
<ol>
<li><p><strong>Simplicity</strong>: The behavior is simple in the following sense:
Most people fall into this trap only once, not several times.</p>
</li>
<li><p><strong>Consistency</strong>: Python <em>always</em> passes objects, not names.
The default parameter is, obviously, part of the function
heading (not the function body). It therefore ought to be evaluated
at module load time (and only at module load time, unless nested), not
at function call time.</p>
</li>
<li><p><strong>Usefulness</strong>: As Frederik Lundh points out in his explanation
of <a href="https://web.archive.org/web/20201112004749/http://effbot.org/zone/default-values.htm" rel="noreferrer">"Default Parameter Values in Python"</a>, the
current behavior can be quite useful for advanced programming.
(Use sparingly.)</p>
</li>
<li><p><strong>Sufficient documentation</strong>: In the most basic Python documentation,
the tutorial, the issue is loudly announced as
an <strong>"Important warning"</strong> in the <em>first</em> subsection of Section
<a href="https://docs.python.org/3/tutorial/controlflow.html#default-argument-values" rel="noreferrer">"More on Defining Functions"</a>.
The warning even uses boldface,
which is rarely applied outside of headings.
RTFM: Read the fine manual.</p>
</li>
<li><p><strong>Meta-learning</strong>: Falling into the trap is actually a very
helpful moment (at least if you are a reflective learner),
because you will subsequently better understand the point
"Consistency" above and that will
teach you a great deal about Python.</p>
</li>
</ol>
    </div></div></div></div><div id="solution9" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 9</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/language-design">language-design</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/default-parameters">default-parameters</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/least-astonishment">least-astonishment</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>This behavior is easy explained by:</p>

<ol>
<li>function (class etc.) declaration is executed only once, creating all default value objects</li>
<li>everything is passed by reference</li>
</ol>

<p>So:</p>

<pre class="lang-py s-code-block"><code class="hljs language-python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">x</span>(<span class="hljs-params">a=<span class="hljs-number">0</span>, b=[], c=[], d=<span class="hljs-number">0</span></span>):
    a = a + <span class="hljs-number">1</span>
    b = b + [<span class="hljs-number">1</span>]
    c.append(<span class="hljs-number">1</span>)
    <span class="hljs-built_in">print</span> a, b, c
</code></pre>

<ol>
<li><code>a</code> doesn't change - every assignment call creates new int object - new object is printed</li>
<li><code>b</code> doesn't change - new array is build from default value and printed</li>
<li><code>c</code> changes - operation is performed on same object - and it is printed</li>
</ol>
    </div></div></div></div><div id="solution10" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 10</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/language-design">language-design</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/default-parameters">default-parameters</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/least-astonishment">least-astonishment</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>1)  The so-called problem of "Mutable Default Argument" is in general a special example demonstrating that:<br>
"All functions with this problem <strong>suffer also from similar side effect problem on the actual parameter</strong>,"<br>
That is against the rules of functional programming, usually undesiderable and should be fixed both together.</p>

<p>Example:</p>

<pre class="lang-py s-code-block"><code class="hljs language-python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">a=[]</span>):                 <span class="hljs-comment"># the same problematic function</span>
    a.append(<span class="hljs-number">5</span>)
    <span class="hljs-keyword">return</span> a

<span class="hljs-meta">&gt;&gt;&gt; </span>somevar = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>]           <span class="hljs-comment"># an example without a default parameter</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>foo(somevar)
[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">5</span>]
<span class="hljs-meta">&gt;&gt;&gt; </span>somevar
[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">5</span>]                      <span class="hljs-comment"># usually expected [1, 2]</span>
</code></pre>

<p><strong>Solution</strong>:  a <strong>copy</strong><br>
An absolutely safe solution is to <strong><code>copy</code></strong> or <strong><code>deepcopy</code></strong> the input object first and then to do whatever with the copy.</p>

<pre class="lang-py s-code-block"><code class="hljs language-python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">a=[]</span>):
    a = a[:]     <span class="hljs-comment"># a copy</span>
    a.append(<span class="hljs-number">5</span>)
    <span class="hljs-keyword">return</span> a     <span class="hljs-comment"># or everything safe by one line: "return a + [5]"</span>
</code></pre>

<p>Many builtin mutable types have a copy method like <code>some_dict.copy()</code> or <code>some_set.copy()</code> or can be copied easy like <code>somelist[:]</code> or <code>list(some_list)</code>. Every object can be also copied by <code>copy.copy(any_object)</code> or more thorough by <code>copy.deepcopy()</code> (the latter useful if the mutable object is composed from mutable objects). Some objects are fundamentally based on side effects like "file" object and can not be meaningfully reproduced by copy. <a href="http://effbot.org/pyfaq/how-do-i-copy-an-object-in-python.htm" rel="noreferrer">copying</a></p>

<p>Example problem for <a href="https://stackoverflow.com/q/13484107/448474">a similar SO question</a></p>

<pre class="lang-py s-code-block"><code class="hljs language-python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span>(<span class="hljs-title class_ inherited__">object</span>):            <span class="hljs-comment"># the original problematic class</span>
  <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, var1=[]</span>):
    self._var1 = var1

somevar = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>]               <span class="hljs-comment"># an example without a default parameter</span>
t1 = Test(somevar)
t2 = Test(somevar)
t1._var1.append([<span class="hljs-number">1</span>])
<span class="hljs-built_in">print</span> somevar                  <span class="hljs-comment"># [1, 2, [1]] but usually expected [1, 2]</span>
<span class="hljs-built_in">print</span> t2._var1                 <span class="hljs-comment"># [1, 2, [1]] but usually expected [1, 2]</span>
</code></pre>

<p>It shouldn't be neither saved in any <em>public</em> attribute of an instance returned by this function. (Assuming that <em>private</em> attributes of instance should not be modified from outside of this class or subclasses by convention. i.e. <code>_var1</code> is a private attribute )</p>

<p>Conclusion:<br>
Input parameters objects shouldn't be modified in place (mutated) nor they should not be binded into an object returned by the function. (If we prefere programming without side effects which is strongly recommended. see <a href="http://en.wikipedia.org/wiki/Side_effect_%28computer_science%29" rel="noreferrer">Wiki about "side effect"</a> (The first two paragraphs are relevent in this context.)
.)</p>

<p>2)<br>
Only if the side effect on the actual parameter is required but unwanted on the default parameter then the useful solution is <code>def ...(var1=None):</code> <code>if var1 is None:</code> <code>var1 = []</code> <a href="http://effbot.org/zone/default-values.htm#what-to-do-instead" rel="noreferrer">More..</a></p>

<p>3) In some cases is <a href="http://effbot.org/zone/default-values.htm#valid-uses-for-mutable-defaults" rel="noreferrer">the mutable behavior of default parameters useful</a>.</p>
    </div></div></div></div><div id="solution11" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 11</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/language-design">language-design</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/default-parameters">default-parameters</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/least-astonishment">least-astonishment</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>What you're asking is why this:</p>

<pre class="lang-py s-code-block"><code class="hljs language-python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">func</span>(<span class="hljs-params">a=[], b = <span class="hljs-number">2</span></span>):
    <span class="hljs-keyword">pass</span>
</code></pre>

<p>isn't internally equivalent to this:</p>

<pre class="lang-py s-code-block"><code class="hljs language-python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">func</span>(<span class="hljs-params">a=<span class="hljs-literal">None</span>, b = <span class="hljs-literal">None</span></span>):
    a_default = <span class="hljs-keyword">lambda</span>: []
    b_default = <span class="hljs-keyword">lambda</span>: <span class="hljs-number">2</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">actual_func</span>(<span class="hljs-params">a=<span class="hljs-literal">None</span>, b=<span class="hljs-literal">None</span></span>):
        <span class="hljs-keyword">if</span> a <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>: a = a_default()
        <span class="hljs-keyword">if</span> b <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>: b = b_default()
    <span class="hljs-keyword">return</span> actual_func
func = func()
</code></pre>

<p>except for the case of explicitly calling func(None, None), which we'll ignore.</p>

<p>In other words, instead of evaluating default parameters, why not store each of them, and evaluate them when the function is called?</p>

<p>One answer is probably right there--it would effectively turn every function with default parameters into a closure.  Even if it's all hidden away in the interpreter and not a full-blown closure, the data's got to be stored somewhere.  It'd be slower and use more memory.</p>
    </div></div></div></div><div id="solution12" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 12</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/language-design">language-design</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/default-parameters">default-parameters</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/least-astonishment">least-astonishment</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>This actually has nothing to do with default values, other than that it often comes up as an unexpected behaviour when you write functions with mutable default values.</p>

<pre class="lang-py s-code-block"><code class="hljs language-python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">def</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">a</span>):
    a.append(<span class="hljs-number">5</span>)
    <span class="hljs-built_in">print</span> a

<span class="hljs-meta">&gt;&gt;&gt; </span>a  = [<span class="hljs-number">5</span>]
<span class="hljs-meta">&gt;&gt;&gt; </span>foo(a)
[<span class="hljs-number">5</span>, <span class="hljs-number">5</span>]
<span class="hljs-meta">&gt;&gt;&gt; </span>foo(a)
[<span class="hljs-number">5</span>, <span class="hljs-number">5</span>, <span class="hljs-number">5</span>]
<span class="hljs-meta">&gt;&gt;&gt; </span>foo(a)
[<span class="hljs-number">5</span>, <span class="hljs-number">5</span>, <span class="hljs-number">5</span>, <span class="hljs-number">5</span>]
<span class="hljs-meta">&gt;&gt;&gt; </span>foo(a)
[<span class="hljs-number">5</span>, <span class="hljs-number">5</span>, <span class="hljs-number">5</span>, <span class="hljs-number">5</span>, <span class="hljs-number">5</span>]
</code></pre>

<p>No default values in sight in this code, but you get exactly the same problem.</p>

<p>The problem is that <code>foo</code> is <em>modifying</em> a mutable variable passed in from the caller, when the caller doesn't expect this. Code like this would be fine if the function was called something like <code>append_5</code>; then the caller would be calling the function in order to modify the value they pass in, and the behaviour would be expected. But such a function would be very unlikely to take a default argument, and probably wouldn't return the list (since the caller already has a reference to that list; the one it just passed in).</p>

<p>Your original <code>foo</code>, with a default argument, shouldn't be modifying <code>a</code> whether it was explicitly passed in or got the default value. Your code should leave mutable arguments alone unless it is clear from the context/name/documentation that the arguments are supposed to be modified. Using mutable values passed in as arguments as local temporaries is an extremely bad idea, whether we're in Python or not and whether there are default arguments involved or not.</p>

<p>If you need to destructively manipulate a local temporary in the course of computing something, and you need to start your manipulation from an argument value, you need to make a copy.</p>
    </div></div></div></div><div id="solution13" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 13</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/language-design">language-design</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/default-parameters">default-parameters</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/least-astonishment">least-astonishment</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Already busy topic, but from what I read here, the following helped me realizing how it's working internally:</p>

<pre class="lang-py s-code-block"><code class="hljs language-python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">bar</span>(<span class="hljs-params">a=[]</span>):
     <span class="hljs-built_in">print</span> <span class="hljs-built_in">id</span>(a)
     a = a + [<span class="hljs-number">1</span>]
     <span class="hljs-built_in">print</span> <span class="hljs-built_in">id</span>(a)
     <span class="hljs-keyword">return</span> a

<span class="hljs-meta">&gt;&gt;&gt; </span>bar()
<span class="hljs-number">4484370232</span>
<span class="hljs-number">4484524224</span>
[<span class="hljs-number">1</span>]
<span class="hljs-meta">&gt;&gt;&gt; </span>bar()
<span class="hljs-number">4484370232</span>
<span class="hljs-number">4484524152</span>
[<span class="hljs-number">1</span>]
<span class="hljs-meta">&gt;&gt;&gt; </span>bar()
<span class="hljs-number">4484370232</span> <span class="hljs-comment"># Never change, this is 'class property' of the function</span>
<span class="hljs-number">4484523720</span> <span class="hljs-comment"># Always a new object </span>
[<span class="hljs-number">1</span>]
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">id</span>(bar.func_defaults[<span class="hljs-number">0</span>])
<span class="hljs-number">4484370232</span>
</code></pre>
    </div></div></div></div><div id="solution14" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 14</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/language-design">language-design</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/default-parameters">default-parameters</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/least-astonishment">least-astonishment</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<h1>Python: The Mutable Default Argument</h1>

<p>Default arguments get evaluated at the time the function is compiled into a function object. When used by the function, multiple times by that function, they are and remain the same object. </p>

<p>When they are mutable, when mutated (for example, by adding an element to it) they remain mutated on consecutive calls.</p>

<p>They stay mutated because they are the same object each time.</p>

<h2>Equivalent code:</h2>

<p>Since the list is bound to the function when the function object is compiled and instantiated, this:</p>

<pre class="lang-py s-code-block"><code class="hljs language-python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">mutable_default_argument=[]</span>): <span class="hljs-comment"># make a list the default argument</span>
    <span class="hljs-string">"""function that uses a list"""</span>
</code></pre>

<p>is almost exactly equivalent to this:</p>

<pre class="lang-py s-code-block"><code class="hljs language-python">_a_list = [] <span class="hljs-comment"># create a list in the globals</span>

<span class="hljs-keyword">def</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">mutable_default_argument=_a_list</span>): <span class="hljs-comment"># make it the default argument</span>
    <span class="hljs-string">"""function that uses a list"""</span>

<span class="hljs-keyword">del</span> _a_list <span class="hljs-comment"># remove globals name binding</span>
</code></pre>

<h2>Demonstration</h2>

<p>Here's a demonstration - you can verify that they are the same object each time they are referenced by </p>

<ul>
<li>seeing that the list is created before the function has finished compiling to a function object,</li>
<li>observing that the id is the same each time the list is referenced,</li>
<li>observing that the list stays changed when the function that uses it is called a second time,</li>
<li>observing the order in which the output is printed from the source (which I conveniently numbered for you):</li>
</ul>

<p><code>example.py</code></p>

<pre class="lang-py s-code-block"><code class="hljs language-python"><span class="hljs-built_in">print</span>(<span class="hljs-string">'1. Global scope being evaluated'</span>)

<span class="hljs-keyword">def</span> <span class="hljs-title function_">create_list</span>():
    <span class="hljs-string">'''noisily create a list for usage as a kwarg'''</span>
    l = []
    <span class="hljs-built_in">print</span>(<span class="hljs-string">'3. list being created and returned, id: '</span> + <span class="hljs-built_in">str</span>(<span class="hljs-built_in">id</span>(l)))
    <span class="hljs-keyword">return</span> l

<span class="hljs-built_in">print</span>(<span class="hljs-string">'2. example_function about to be compiled to an object'</span>)

<span class="hljs-keyword">def</span> <span class="hljs-title function_">example_function</span>(<span class="hljs-params">default_kwarg1=create_list(<span class="hljs-params"></span>)</span>):
    <span class="hljs-built_in">print</span>(<span class="hljs-string">'appending "a" in default default_kwarg1'</span>)
    default_kwarg1.append(<span class="hljs-string">"a"</span>)
    <span class="hljs-built_in">print</span>(<span class="hljs-string">'list with id: '</span> + <span class="hljs-built_in">str</span>(<span class="hljs-built_in">id</span>(default_kwarg1)) + 
          <span class="hljs-string">' - is now: '</span> + <span class="hljs-built_in">repr</span>(default_kwarg1))

<span class="hljs-built_in">print</span>(<span class="hljs-string">'4. example_function compiled: '</span> + <span class="hljs-built_in">repr</span>(example_function))


<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:
    <span class="hljs-built_in">print</span>(<span class="hljs-string">'5. calling example_function twice!:'</span>)
    example_function()
    example_function()
</code></pre>

<p>and running it with <code>python example.py</code>:</p>

<pre class="lang-py s-code-block"><code class="hljs language-python"><span class="hljs-number">1.</span> Global scope being evaluated
<span class="hljs-number">2.</span> example_function about to be compiled to an <span class="hljs-built_in">object</span>
<span class="hljs-number">3.</span> <span class="hljs-built_in">list</span> being created <span class="hljs-keyword">and</span> returned, <span class="hljs-built_in">id</span>: <span class="hljs-number">140502758808032</span>
<span class="hljs-number">4.</span> example_function compiled: &lt;function example_function at <span class="hljs-number">0x7fc9590905f0</span>&gt;
<span class="hljs-number">5.</span> calling example_function twice!:
appending <span class="hljs-string">"a"</span> <span class="hljs-keyword">in</span> default default_kwarg1
<span class="hljs-built_in">list</span> <span class="hljs-keyword">with</span> <span class="hljs-built_in">id</span>: <span class="hljs-number">140502758808032</span> - <span class="hljs-keyword">is</span> now: [<span class="hljs-string">'a'</span>]
appending <span class="hljs-string">"a"</span> <span class="hljs-keyword">in</span> default default_kwarg1
<span class="hljs-built_in">list</span> <span class="hljs-keyword">with</span> <span class="hljs-built_in">id</span>: <span class="hljs-number">140502758808032</span> - <span class="hljs-keyword">is</span> now: [<span class="hljs-string">'a'</span>, <span class="hljs-string">'a'</span>]
</code></pre>

<h2>Does this violate the principle of "Least Astonishment"?</h2>

<p>This order of execution is frequently confusing to new users of Python. If you understand the Python execution model, then it becomes quite expected. </p>

<h2>The usual instruction to new Python users:</h2>

<p>But this is why the usual instruction to new users is to create their default arguments like this instead:</p>

<pre class="lang-py s-code-block"><code class="hljs language-python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">example_function_2</span>(<span class="hljs-params">default_kwarg=<span class="hljs-literal">None</span></span>):
    <span class="hljs-keyword">if</span> default_kwarg <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:
        default_kwarg = []
</code></pre>

<p>This uses the None singleton as a sentinel object to tell the function whether or not we've gotten an argument other than the default. If we get no argument, then we actually want to use a new empty list, <code>[]</code>, as the default.</p>

<p>As the <a href="https://docs.python.org/tutorial/controlflow.html#default-argument-values" rel="noreferrer">tutorial section on control flow</a> says:</p>

<blockquote>
  <p>If you dont want the default to be shared between subsequent calls,
  you can write the function like this instead:</p>

<pre class="lang-py s-code-block"><code class="hljs language-python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">f</span>(<span class="hljs-params">a, L=<span class="hljs-literal">None</span></span>):
    <span class="hljs-keyword">if</span> L <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:
        L = []
    L.append(a)
    <span class="hljs-keyword">return</span> L
</code></pre>
</blockquote>
    </div></div></div></div><div id="solution15" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 15</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/language-design">language-design</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/default-parameters">default-parameters</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/least-astonishment">least-astonishment</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>The shortest answer would probably be "definition is execution", therefore the whole argument makes no strict sense. As a more contrived example, you may cite this:</p>

<pre class="lang-py s-code-block"><code class="hljs language-python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">a</span>(): <span class="hljs-keyword">return</span> []

<span class="hljs-keyword">def</span> <span class="hljs-title function_">b</span>(<span class="hljs-params">x=a(<span class="hljs-params"></span>)</span>):
    <span class="hljs-built_in">print</span> x
</code></pre>

<p>Hopefully it's enough to show that not executing the default argument expressions at the execution time of the <code>def</code> statement isn't easy or doesn't make sense, or both.</p>

<p>I agree it's a gotcha when you try to use default constructors, though.</p>
    </div></div></div></div><div id="solution16" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 16</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/language-design">language-design</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/default-parameters">default-parameters</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/least-astonishment">least-astonishment</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>It's a performance optimization.  As a result of this functionality, which of these two function calls do you think is faster?</p>

<pre class="lang-py s-code-block"><code class="hljs language-python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">print_tuple</span>(<span class="hljs-params">some_tuple=(<span class="hljs-params"><span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span></span>)</span>):
    <span class="hljs-built_in">print</span> some_tuple

print_tuple()        <span class="hljs-comment">#1</span>
print_tuple((<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>)) <span class="hljs-comment">#2</span>
</code></pre>

<p>I'll give you a hint.  Here's the disassembly (see <a href="http://docs.python.org/library/dis.html" rel="noreferrer">http://docs.python.org/library/dis.html</a>):</p>

<h1><code>#</code>1</h1>

<pre class="lang-py s-code-block"><code class="hljs language-python"><span class="hljs-number">0</span> LOAD_GLOBAL              <span class="hljs-number">0</span> (print_tuple)
<span class="hljs-number">3</span> CALL_FUNCTION            <span class="hljs-number">0</span>
<span class="hljs-number">6</span> POP_TOP
<span class="hljs-number">7</span> LOAD_CONST               <span class="hljs-number">0</span> (<span class="hljs-literal">None</span>)
<span class="hljs-number">10</span> RETURN_VALUE
</code></pre>

<h1><code>#</code>2</h1>

<pre class="lang-py s-code-block"><code class="hljs language-python"> <span class="hljs-number">0</span> LOAD_GLOBAL              <span class="hljs-number">0</span> (print_tuple)
 <span class="hljs-number">3</span> LOAD_CONST               <span class="hljs-number">4</span> ((<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>))
 <span class="hljs-number">6</span> CALL_FUNCTION            <span class="hljs-number">1</span>
 <span class="hljs-number">9</span> POP_TOP
<span class="hljs-number">10</span> LOAD_CONST               <span class="hljs-number">0</span> (<span class="hljs-literal">None</span>)
<span class="hljs-number">13</span> RETURN_VALUE
</code></pre>

<blockquote>
  <p>I doubt the experienced behavior has a practical use (who really used static variables in C, without breeding bugs ?)</p>
</blockquote>

<p>As you can see, there <em>is</em> a performance benefit when using immutable default arguments.  This can make a difference if it's a frequently called function or the default argument takes a long time to construct.  Also, bear in mind that Python isn't C.  In C you have constants that are pretty much free.  In Python you don't have this benefit.</p>
    </div></div></div></div><div id="solution17" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 17</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/language-design">language-design</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/default-parameters">default-parameters</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/least-astonishment">least-astonishment</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>This behavior is not surprising if you take the following into consideration:</p>
<ol>
<li>The behavior of read-only class attributes upon assignment attempts, and that</li>
<li>Functions are objects (explained well in the accepted answer).</li>
</ol>
<p>The role of <strong>(2)</strong> has been covered extensively in this thread. <strong>(1)</strong> is likely the astonishment causing factor, as this behavior is not "intuitive" when coming from other languages.</p>
<p><strong>(1)</strong> is described in the Python <a href="http://docs.python.org/tutorial/classes.html" rel="nofollow noreferrer">tutorial on classes</a>. In an attempt to assign a value to a read-only class attribute:</p>
<blockquote>
<p>...all variables found outside of the innermost scope are
read-only (<em><strong>an attempt to write to such a variable will simply create a
new local variable in the innermost scope, leaving the identically
named outer variable unchanged</strong></em>).</p>
</blockquote>
<p>Look back to the original example and consider the above points:</p>
<pre class="lang-py s-code-block"><code class="hljs language-python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">a=[]</span>):
    a.append(<span class="hljs-number">5</span>)
    <span class="hljs-keyword">return</span> a
</code></pre>
<p>Here <code>foo</code> is an object and <code>a</code> is an attribute of <code>foo</code> (available at <code>foo.func_defs[0]</code>). Since <code>a</code> is a list, <code>a</code> is mutable and is thus a read-write attribute of <code>foo</code>. It is initialized to the empty list as specified by the signature when the function is instantiated, and is available for reading and writing as long as the function object exists.</p>
<p>Calling <code>foo</code> without overriding a default uses that default's value from <code>foo.func_defs</code>. In this case, <code>foo.func_defs[0]</code> is used for <code>a</code> within function object's code scope. Changes to <code>a</code> change <code>foo.func_defs[0]</code>, which is part of the <code>foo</code> object and persists between execution of the code in <code>foo</code>.</p>
<p>Now, compare this to the example from the documentation on <a href="http://docs.python.org/tutorial/controlflow.html#default-argument-values" rel="nofollow noreferrer">emulating the default argument behavior of other languages</a>, such that the function signature defaults are used every time the function is executed:</p>
<pre class="lang-py s-code-block"><code class="hljs language-python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">a, L=<span class="hljs-literal">None</span></span>):
    <span class="hljs-keyword">if</span> L <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:
        L = []
    L.append(a)
    <span class="hljs-keyword">return</span> L
</code></pre>
<p>Taking <strong>(1)</strong> and <strong>(2)</strong> into account, one can see why this accomplishes the desired behavior:</p>
<ul>
<li>When the <code>foo</code> function object is instantiated, <code>foo.func_defs[0]</code> is set to <code>None</code>, an immutable object.</li>
<li>When the function is executed with defaults (with no parameter specified for <code>L</code> in the function call), <code>foo.func_defs[0]</code> (<code>None</code>) is available in the local scope as <code>L</code>.</li>
<li>Upon <code>L = []</code>, the assignment cannot succeed at <code>foo.func_defs[0]</code>, because that attribute is read-only.</li>
<li>Per <strong>(1)</strong>, <em><strong>a new local variable also named <code>L</code> is created in the local scope</strong></em> and used for the remainder of the function call. <code>foo.func_defs[0]</code> thus remains unchanged for future invocations of <code>foo</code>.</li>
</ul>
    </div></div></div></div><div id="solution18" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 18</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/language-design">language-design</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/default-parameters">default-parameters</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/least-astonishment">least-astonishment</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>A simple workaround using None</p>

<pre class="lang-py s-code-block"><code class="hljs language-python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">def</span> <span class="hljs-title function_">bar</span>(<span class="hljs-params">b, data=<span class="hljs-literal">None</span></span>):
<span class="hljs-meta">... </span>    data = data <span class="hljs-keyword">or</span> []
<span class="hljs-meta">... </span>    data.append(b)
<span class="hljs-meta">... </span>    <span class="hljs-keyword">return</span> data
<span class="hljs-meta">... </span>
<span class="hljs-meta">&gt;&gt;&gt; </span>bar(<span class="hljs-number">3</span>)
[<span class="hljs-number">3</span>]
<span class="hljs-meta">&gt;&gt;&gt; </span>bar(<span class="hljs-number">3</span>)
[<span class="hljs-number">3</span>]
<span class="hljs-meta">&gt;&gt;&gt; </span>bar(<span class="hljs-number">3</span>)
[<span class="hljs-number">3</span>]
<span class="hljs-meta">&gt;&gt;&gt; </span>bar(<span class="hljs-number">3</span>, [<span class="hljs-number">34</span>])
[<span class="hljs-number">34</span>, <span class="hljs-number">3</span>]
<span class="hljs-meta">&gt;&gt;&gt; </span>bar(<span class="hljs-number">3</span>, [<span class="hljs-number">34</span>])
[<span class="hljs-number">34</span>, <span class="hljs-number">3</span>]
</code></pre>
    </div></div></div></div><div id="solution19" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 19</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/language-design">language-design</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/default-parameters">default-parameters</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/least-astonishment">least-astonishment</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>It may be true that:</p>

<ol>
<li>Someone is using every language/library feature, and</li>
<li>Switching the behavior here would be ill-advised, but</li>
</ol>

<p>it is entirely consistent to hold to both of the features above and still make another point:</p>

<ol start="3">
<li>It is a confusing feature and it is unfortunate in Python.</li>
</ol>

<p>The other answers, or at least some of them either make points 1 and 2 but not 3, or make point 3 and downplay points 1 and 2. <strong>But all three are true.</strong></p>

<p>It may be true that switching horses in midstream here would be asking for significant breakage, and that there could be more problems created by changing Python to intuitively handle Stefano's opening snippet. And it may be true that someone who knew Python internals well could explain a minefield of consequences. <em>However,</em></p>

<p>The existing behavior is not Pythonic, and Python is successful because very little about the language violates the principle of least astonishment anywhere <em>near</em> this badly. It is a real problem, whether or not it would be wise to uproot it. It is a design flaw. If you understand the language much better by trying to trace out the behavior, I can say that C++ does all of this and more; you learn a lot by navigating, for instance, subtle pointer errors. But this is not Pythonic: people who care about Python enough to persevere in the face of this behavior are people who are drawn to the language because Python has far fewer surprises than other language. Dabblers and the curious become Pythonistas when they are astonished at how little time it takes to get something working--not because of a design fl--I mean, hidden logic puzzle--that cuts against the intuitions of programmers who are drawn to Python because it <strong>Just Works</strong>.</p>
    </div></div></div></div><div id="solution20" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 20</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/language-design">language-design</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/default-parameters">default-parameters</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/least-astonishment">least-astonishment</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>I am going to demonstrate an alternative structure to pass a default list value to a function (it works equally well with dictionaries).  </p>

<p>As others have extensively commented, the list parameter is bound to the function when it is defined as opposed to when it is executed.  Because lists and dictionaries are mutable, any alteration to this parameter will affect other calls to this function.  As a result, subsequent calls to the function will receive this shared list which may have been altered by any other calls to the function.  Worse yet, two parameters are using this function's shared parameter at the same time oblivious to the changes made by the other.</p>

<p><strong>Wrong Method (probably...)</strong>:</p>

<pre class="lang-py s-code-block"><code class="hljs language-python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">list_arg=[<span class="hljs-number">5</span>]</span>):
    <span class="hljs-keyword">return</span> list_arg

a = foo()
a.append(<span class="hljs-number">6</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>a
[<span class="hljs-number">5</span>, <span class="hljs-number">6</span>]

b = foo()
b.append(<span class="hljs-number">7</span>)
<span class="hljs-comment"># The value of 6 appended to variable 'a' is now part of the list held by 'b'.</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>b
[<span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>]  

<span class="hljs-comment"># Although 'a' is expecting to receive 6 (the last element it appended to the list),</span>
<span class="hljs-comment"># it actually receives the last element appended to the shared list.</span>
<span class="hljs-comment"># It thus receives the value 7 previously appended by 'b'.</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>a.pop()             
<span class="hljs-number">7</span>
</code></pre>

<p>You can verify that they are one and the same object by using <code>id</code>:</p>

<pre class="lang-py s-code-block"><code class="hljs language-python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">id</span>(a)
<span class="hljs-number">5347866528</span>

<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">id</span>(b)
<span class="hljs-number">5347866528</span>
</code></pre>

<p>Per Brett Slatkin's "Effective Python: 59 Specific Ways to Write Better Python", <em>Item 20: Use <code>None</code> and Docstrings to specify dynamic default arguments</em> (p. 48)</p>

<blockquote>
  <p>The convention for achieving the desired result in Python is to
  provide a default value of <code>None</code> and to document the actual behaviour
  in the docstring.</p>
</blockquote>

<p>This implementation ensures that each call to the function either receives the default list or else the list passed to the function.</p>

<p><strong>Preferred Method</strong>:</p>

<pre class="lang-py s-code-block"><code class="hljs language-python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">list_arg=<span class="hljs-literal">None</span></span>):
   <span class="hljs-string">"""
   :param list_arg:  A list of input values. 
                     If none provided, used a list with a default value of 5.
   """</span>
   <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> list_arg:
       list_arg = [<span class="hljs-number">5</span>]
   <span class="hljs-keyword">return</span> list_arg

a = foo()
a.append(<span class="hljs-number">6</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>a
[<span class="hljs-number">5</span>, <span class="hljs-number">6</span>]

b = foo()
b.append(<span class="hljs-number">7</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>b
[<span class="hljs-number">5</span>, <span class="hljs-number">7</span>]

c = foo([<span class="hljs-number">10</span>])
c.append(<span class="hljs-number">11</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>c
[<span class="hljs-number">10</span>, <span class="hljs-number">11</span>]
</code></pre>

<p>There may be legitimate use cases for the 'Wrong Method' whereby the programmer intended the default list parameter to be shared, but this is more likely the exception than the rule.</p>
    </div></div></div></div><div id="solution21" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 21</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/language-design">language-design</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/default-parameters">default-parameters</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/least-astonishment">least-astonishment</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>The solutions here are:</p>

<ol>
<li>Use <code>None</code> as your default value (or a nonce <code>object</code>), and switch on that to create your values at runtime; or</li>
<li>Use a <code>lambda</code> as your default parameter, and call it within a try block to get the default value (this is the sort of thing that lambda abstraction is for).</li>
</ol>

<p>The second option is nice because users of the function can pass in a callable, which may be already existing (such as a <code>type</code>)</p>
    </div></div></div></div><div id="solution22" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 22</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/language-design">language-design</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/default-parameters">default-parameters</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/least-astonishment">least-astonishment</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>You can get round this by replacing the object (and therefore the tie with the scope):</p>

<pre class="lang-py s-code-block"><code class="hljs language-python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">a=[]</span>):
    a = <span class="hljs-built_in">list</span>(a)
    a.append(<span class="hljs-number">5</span>)
    <span class="hljs-keyword">return</span> a
</code></pre>

<p>Ugly, but it works.</p>
    </div></div></div></div><div id="solution23" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 23</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/language-design">language-design</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/default-parameters">default-parameters</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/least-astonishment">least-astonishment</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>When we do this:</p>

<pre class="lang-py s-code-block"><code class="hljs language-python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">a=[]</span>):
    ...
</code></pre>

<p>... we assign the argument <code>a</code> to an <em>unnamed</em> list, if the caller does not pass the value of a.</p>

<p>To make things simpler for this discussion, let's temporarily give the unnamed list a name. How about <code>pavlo</code> ?</p>

<pre class="lang-py s-code-block"><code class="hljs language-python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">a=pavlo</span>):
   ...
</code></pre>

<p>At any time, if the caller doesn't tell us what <code>a</code> is, we reuse <code>pavlo</code>.</p>

<p>If <code>pavlo</code> is mutable (modifiable), and <code>foo</code> ends up modifying it, an effect we notice the next time <code>foo</code> is called without specifying <code>a</code>.</p>

<p>So this is what you see (Remember, <code>pavlo</code> is initialized to []):</p>

<pre class="lang-py s-code-block"><code class="hljs language-python"> &gt;&gt;&gt; foo()
 [<span class="hljs-number">5</span>]
</code></pre>

<p>Now, <code>pavlo</code> is [5].</p>

<p>Calling <code>foo()</code> again modifies <code>pavlo</code> again:</p>

<pre class="lang-py s-code-block"><code class="hljs language-python"><span class="hljs-meta">&gt;&gt;&gt; </span>foo()
[<span class="hljs-number">5</span>, <span class="hljs-number">5</span>]
</code></pre>

<p>Specifying <code>a</code> when calling <code>foo()</code> ensures <code>pavlo</code> is not touched.</p>

<pre class="lang-py s-code-block"><code class="hljs language-python"><span class="hljs-meta">&gt;&gt;&gt; </span>ivan = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]
<span class="hljs-meta">&gt;&gt;&gt; </span>foo(a=ivan)
[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]
<span class="hljs-meta">&gt;&gt;&gt; </span>ivan
[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]
</code></pre>

<p>So, <code>pavlo</code> is still <code>[5, 5]</code>.</p>

<pre class="lang-py s-code-block"><code class="hljs language-python"><span class="hljs-meta">&gt;&gt;&gt; </span>foo()
[<span class="hljs-number">5</span>, <span class="hljs-number">5</span>, <span class="hljs-number">5</span>]
</code></pre>
    </div></div></div></div><div id="solution24" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 24</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/language-design">language-design</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/default-parameters">default-parameters</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/least-astonishment">least-astonishment</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>I sometimes exploit this behavior as an alternative to the following pattern:</p>

<pre class="lang-py s-code-block"><code class="hljs language-python">singleton = <span class="hljs-literal">None</span>

<span class="hljs-keyword">def</span> <span class="hljs-title function_">use_singleton</span>():
    <span class="hljs-keyword">global</span> singleton

    <span class="hljs-keyword">if</span> singleton <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:
        singleton = _make_singleton()

    <span class="hljs-keyword">return</span> singleton.use_me()
</code></pre>

<p>If <code>singleton</code> is only used by <code>use_singleton</code>, I like the following pattern as a replacement:</p>

<pre class="lang-py s-code-block"><code class="hljs language-python"><span class="hljs-comment"># _make_singleton() is called only once when the def is executed</span>
<span class="hljs-keyword">def</span> <span class="hljs-title function_">use_singleton</span>(<span class="hljs-params">singleton=_make_singleton(<span class="hljs-params"></span>)</span>):
    <span class="hljs-keyword">return</span> singleton.use_me()
</code></pre>

<p>I've used this for instantiating client classes that access external resources, and also for creating dicts or lists for memoization.</p>

<p>Since I don't think this pattern is well known, I do put a short comment in to guard against future misunderstandings.</p>
    </div></div></div></div><div id="solution25" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 25</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/language-design">language-design</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/default-parameters">default-parameters</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/least-astonishment">least-astonishment</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Every other answer explains why this is actually a nice and desired behavior, or why you shouldn't be needing this anyway. Mine is for those stubborn ones who want to exercise their right to bend the language to their will, not the other way around.</p>
<p>We will "fix" this behavior with a decorator that will copy the default value instead of reusing the same instance for each positional argument left at its default value.</p>

<pre class="lang-py s-code-block"><code class="hljs language-python"><span class="hljs-keyword">import</span> inspect
<span class="hljs-keyword">from</span> copy <span class="hljs-keyword">import</span> deepcopy  <span class="hljs-comment"># copy would fail on deep arguments like nested dicts</span>

<span class="hljs-keyword">def</span> <span class="hljs-title function_">sanify</span>(<span class="hljs-params">function</span>):
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">wrapper</span>(<span class="hljs-params">*a, **kw</span>):
        <span class="hljs-comment"># store the default values</span>
        defaults = inspect.getargspec(function).defaults <span class="hljs-comment"># for python2</span>
        <span class="hljs-comment"># construct a new argument list</span>
        new_args = []
        <span class="hljs-keyword">for</span> i, arg <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(defaults):
            <span class="hljs-comment"># allow passing positional arguments</span>
            <span class="hljs-keyword">if</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(a)):
                new_args.append(a[i])
            <span class="hljs-keyword">else</span>:
                <span class="hljs-comment"># copy the value</span>
                new_args.append(deepcopy(arg))
        <span class="hljs-keyword">return</span> function(*new_args, **kw)
    <span class="hljs-keyword">return</span> wrapper
</code></pre>
<p>Now let's redefine our function using this decorator:</p>
<pre class="lang-py s-code-block"><code class="hljs language-python"><span class="hljs-meta">@sanify</span>
<span class="hljs-keyword">def</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">a=[]</span>):
    a.append(<span class="hljs-number">5</span>)
    <span class="hljs-keyword">return</span> a

foo() <span class="hljs-comment"># '[5]'</span>
foo() <span class="hljs-comment"># '[5]' -- as desired</span>
</code></pre>
<p>This is particularly neat for functions that take multiple arguments. Compare:</p>
<pre class="lang-py s-code-block"><code class="hljs language-python"><span class="hljs-comment"># the 'correct' approach</span>
<span class="hljs-keyword">def</span> <span class="hljs-title function_">bar</span>(<span class="hljs-params">a=<span class="hljs-literal">None</span>, b=<span class="hljs-literal">None</span>, c=<span class="hljs-literal">None</span></span>):
    <span class="hljs-keyword">if</span> a <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:
        a = []
    <span class="hljs-keyword">if</span> b <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:
        b = []
    <span class="hljs-keyword">if</span> c <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:
        c = []
    <span class="hljs-comment"># finally do the actual work</span>
</code></pre>
<p>with</p>
<pre class="lang-py s-code-block"><code class="hljs language-python"><span class="hljs-comment"># the nasty decorator hack</span>
<span class="hljs-meta">@sanify</span>
<span class="hljs-keyword">def</span> <span class="hljs-title function_">bar</span>(<span class="hljs-params">a=[], b=[], c=[]</span>):
    <span class="hljs-comment"># wow, works right out of the box!</span>
</code></pre>
<p>It's important to note that the above solution breaks if you try to use keyword args, like so:</p>
<pre class="lang-py s-code-block"><code class="hljs language-python">foo(a=[<span class="hljs-number">4</span>])
</code></pre>
<p>The decorator could be adjusted to allow for that, but we leave this as an exercise for the reader ;)</p>
    </div></div></div></div><div id="solution26" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 26</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/language-design">language-design</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/default-parameters">default-parameters</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/least-astonishment">least-astonishment</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>This "bug" gave me a lot of overtime work hours! But I'm beginning to see a potential use of it (but I would have liked it to be at the execution time, still)</p>

<p>I'm gonna give you what I see as a useful example.</p>

<pre class="lang-py s-code-block"><code class="hljs language-python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">example</span>(<span class="hljs-params">errors=[]</span>):
    <span class="hljs-comment"># statements</span>
    <span class="hljs-comment"># Something went wrong</span>
    mistake = <span class="hljs-literal">True</span>
    <span class="hljs-keyword">if</span> mistake:
        tryToFixIt(errors)
        <span class="hljs-comment"># Didn't work.. let's try again</span>
        tryToFixItAnotherway(errors)
        <span class="hljs-comment"># This time it worked</span>
    <span class="hljs-keyword">return</span> errors

<span class="hljs-keyword">def</span> <span class="hljs-title function_">tryToFixIt</span>(<span class="hljs-params">err</span>):
    err.append(<span class="hljs-string">'Attempt to fix it'</span>)

<span class="hljs-keyword">def</span> <span class="hljs-title function_">tryToFixItAnotherway</span>(<span class="hljs-params">err</span>):
    err.append(<span class="hljs-string">'Attempt to fix it by another way'</span>)

<span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>():
    <span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">2</span>):
        errors = example()
    <span class="hljs-built_in">print</span> <span class="hljs-string">'\n'</span>.join(errors)

main()
</code></pre>

<p>prints the following</p>

<pre class="lang-py s-code-block"><code class="hljs language-python">Attempt to fix it
Attempt to fix it by another way
Attempt to fix it
Attempt to fix it by another way
</code></pre>
    </div></div></div></div><div id="solution27" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 27</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/language-design">language-design</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/default-parameters">default-parameters</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/least-astonishment">least-astonishment</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p><em>This is not a design flaw</em>. Anyone who trips over this is doing something wrong.</p>

<p>There are 3 cases I see where you might run into this problem:</p>

<ol>
<li>You intend to modify the argument as a side effect of the function. In this case it <em>never makes sense</em> to have a default argument. The only exception is when you're abusing the argument list to have function attributes, e.g. <code>cache={}</code>, and you wouldn't be expected to call the function with an actual argument at all.</li>
<li>You intend to leave the argument unmodified, but you accidentally <em>did</em> modify it. That's a bug, fix it.</li>
<li>You intend to modify the argument for use inside the function, but didn't expect the modification to be viewable outside of the function. In that case you need to make a <em>copy</em> of the argument, whether it was the default or not! Python is not a call-by-value language so it doesn't make the copy for you, you need to be explicit about it.</li>
</ol>

<p>The example in the question could fall into category 1 or 3. It's odd that it both modifies the passed list and returns it; you should pick one or the other.</p>
    </div></div></div></div><div id="solution28" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 28</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/language-design">language-design</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/default-parameters">default-parameters</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/least-astonishment">least-astonishment</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Just change the function to be:</p>

<pre class="lang-py s-code-block"><code class="hljs language-python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">notastonishinganymore</span>(<span class="hljs-params">a = []</span>): 
    <span class="hljs-string">'''The name is just a joke :)'''</span>
    a = a[:]
    a.append(<span class="hljs-number">5</span>)
    <span class="hljs-keyword">return</span> a
</code></pre>
    </div></div></div></div><div id="solution29" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 29</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/language-design">language-design</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/default-parameters">default-parameters</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/least-astonishment">least-astonishment</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>TLDR: Define-time defaults are consistent and strictly more expressive.</p>

<hr>

<p>Defining a function affects two scopes: the defining scope <em>containing</em> the function, and the execution  scope <em>contained by</em> the function. While it is pretty clear how blocks map to scopes, the question is where <code>def &lt;name&gt;(&lt;args=defaults&gt;):</code> belongs to:</p>

<pre class="lang-py s-code-block"><code class="hljs language-python"><span class="hljs-meta">... </span>                          <span class="hljs-comment"># defining scope</span>
<span class="hljs-keyword">def</span> <span class="hljs-title function_">name</span>(<span class="hljs-params">parameter=default</span>):  <span class="hljs-comment"># ???</span>
    ...                       <span class="hljs-comment"># execution scope</span>
</code></pre>

<p>The <code>def name</code> part <strong>must</strong> evaluate in the defining scope - we want <code>name</code> to be available there, after all. Evaluating the function only inside itself would make it inaccessible.</p>

<p>Since <code>parameter</code> is a constant name, we can "evaluate" it at the same time as <code>def name</code>. This also has the advantage it produces the function with a known signature as <code>name(parameter=...):</code>, instead of a bare <code>name(...):</code>.</p>

<p>Now, when to evaluate <code>default</code>?</p>

<p>Consistency already says "at definition": everything else of <code>def &lt;name&gt;(&lt;args=defaults&gt;):</code> is best evaluated at definition as well. Delaying parts of it would be the astonishing choice.</p>

<p>The two choices are not equivalent, either: If <code>default</code> is evaluated at definition time, it <em>can still</em> affect execution time. If <code>default</code> is evaluated at execution time, it <em>cannot</em> affect definition time. Choosing "at definition" allows expressing both cases, while choosing "at execution" can express only one:</p>

<pre class="lang-py s-code-block"><code class="hljs language-python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">name</span>(<span class="hljs-params">parameter=defined</span>):  <span class="hljs-comment"># set default at definition time</span>
    ...

<span class="hljs-keyword">def</span> <span class="hljs-title function_">name</span>(<span class="hljs-params">parameter=default</span>):     <span class="hljs-comment"># delay default until execution time</span>
    parameter = default <span class="hljs-keyword">if</span> parameter <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">else</span> parameter
    ...
</code></pre>
    </div></div></div></div><div id="solution30" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 30</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/language-design">language-design</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/default-parameters">default-parameters</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/least-astonishment">least-astonishment</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>I think the answer to this question lies in how python pass data to parameter (pass by value or by reference), not mutability or how python handle the "def" statement.</p>

<p>A brief introduction. First, there are two type of data types in python, one is simple elementary data type, like numbers, and another data type is objects. Second, when passing data to parameters, python pass elementary data type by value, i.e., make a local copy of the value to a local variable, but pass object by reference, i.e., pointers to the object.</p>

<p>Admitting the above two points, let's explain what happened to the python code. It's only because of passing by reference for objects, but has nothing to do with mutable/immutable, or arguably the fact that "def" statement is executed only once when it is defined.</p>

<p>[] is an object, so python pass the reference of [] to <code>a</code>, i.e., <code>a</code> is only a pointer to [] which lies in memory as an object. There is only one copy of [] with, however, many references to it. For the first foo(), the list [] is changed to <a href="http://effbot.org/zone/default-values.htm" rel="noreferrer">1</a> by append method. But Note that there is only one copy of the list object and this object now becomes <a href="http://effbot.org/zone/default-values.htm" rel="noreferrer">1</a>. When running the second foo(), what effbot webpage says (items is not evaluated any more) is wrong. <code>a</code> is evaluated to be the list object, although now the content of the object is <a href="http://effbot.org/zone/default-values.htm" rel="noreferrer">1</a>. This is the effect of passing by reference! The result of foo(3) can be easily derived in the same way.</p>

<p>To further validate my answer, let's take a look at two additional codes.</p>

<p>====== No. 2 ========</p>

<pre class="lang-py s-code-block"><code class="hljs language-python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">x, items=<span class="hljs-literal">None</span></span>):
    <span class="hljs-keyword">if</span> items <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:
        items = []
    items.append(x)
    <span class="hljs-keyword">return</span> items

foo(<span class="hljs-number">1</span>)  <span class="hljs-comment">#return [1]</span>
foo(<span class="hljs-number">2</span>)  <span class="hljs-comment">#return [2]</span>
foo(<span class="hljs-number">3</span>)  <span class="hljs-comment">#return [3]</span>
</code></pre>

<p><code>[]</code> is an object, so is <code>None</code> (the former is mutable while the latter is immutable. But the mutability has nothing to do with the question). None is somewhere in the space but we know it's there and there is only one copy of None there. So every time foo is invoked, items is evaluated (as opposed to some answer that it is only evaluated once) to be None, to be clear, the reference (or the address) of None. Then in the foo, item is changed to [], i.e., points to another object which has a different address. </p>

<p>====== No. 3 =======</p>

<pre class="lang-py s-code-block"><code class="hljs language-python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">x, items=[]</span>):
    items.append(x)
    <span class="hljs-keyword">return</span> items

foo(<span class="hljs-number">1</span>)    <span class="hljs-comment"># returns [1]</span>
foo(<span class="hljs-number">2</span>,[]) <span class="hljs-comment"># returns [2]</span>
foo(<span class="hljs-number">3</span>)    <span class="hljs-comment"># returns [1,3]</span>
</code></pre>

<p>The invocation of foo(1) make items point to a list object [] with an address, say, 11111111. the content of the list is changed to <a href="http://effbot.org/zone/default-values.htm" rel="noreferrer">1</a> in the foo function in the sequel, but the address is not changed, still 11111111. Then foo(2,[]) is coming. Although the [] in foo(2,[]) has the same content as the default parameter [] when calling foo(1), their address are different! Since we provide the parameter explicitly, <code>items</code> has to take the address of this new <code>[]</code>, say 2222222, and return it after making some change. Now foo(3) is executed. since only <code>x</code> is provided, items has to take its default value again. What's the default value? It is set when defining the foo function: the list object located in 11111111. So the items is evaluated to be the address 11111111 having an element 1. The list located at 2222222 also contains one element 2, but it is not pointed by items any more. Consequently, An append of 3 will make <code>items</code> [1,3]. </p>

<p>From the above explanations, we can see that the <a href="http://effbot.org/zone/default-values.htm" rel="noreferrer">effbot</a> webpage recommended in the accepted answer failed to give a relevant answer to this question. What is more, I think a point in the effbot webpage is wrong. I think the code regarding the UI.Button is correct:</p>

<pre class="lang-py s-code-block"><code class="hljs language-python"><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>):
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">callback</span>():
        <span class="hljs-built_in">print</span> <span class="hljs-string">"clicked button"</span>, i
    UI.Button(<span class="hljs-string">"button %s"</span> % i, callback)
</code></pre>

<p>Each button can hold a distinct callback function which will display different value of <code>i</code>. I can provide an example to show this:</p>

<pre class="lang-py s-code-block"><code class="hljs language-python">x=[]
<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>):
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">callback</span>():
        <span class="hljs-built_in">print</span>(i)
    x.append(callback) 
</code></pre>

<p>If we execute <code>x[7]()</code> we'll get 7 as expected, and <code>x[9]()</code> will gives 9, another value of <code>i</code>.</p>
    </div></div></div></div></div></div><div class="widget"><a href="/questions/get-the-data-received-in-a-flask-request-1657387804432">Get the data received in a Flask request</a><a href="/questions/parameterize-an-sql-in-clause-1657387536064">Parameterize an SQL IN clause</a><a href="/questions/how-to-sum-a-variable-by-group-1657384838148">How to sum a variable by group</a><a href="/questions/how-to-create-a-generic-array-in-java-1657387532298">How to create a generic array in Java?</a><a href="/questions/how-can-i-remove-a-specific-item-from-an-array-1657387552077">How can I remove a specific item from an array?</a><a href="/questions/javascript-infamous-loop-issue-duplicate-1657387498530">Javascript infamous Loop issue? [duplicate]</a><a href="/questions/what-is-a-raw-type-and-why-shouldn&#x27;t-we-use-it-1657384481079">What is a raw type and why shouldn&#x27;t we use it?</a><a href="/questions/how-do-i-make-a-flat-list-out-of-a-list-of-lists-1657384500439">How do I make a flat list out of a list of lists?</a><a href="/questions/event.preventdefault()-vs.-return-false-1657387458377">event.preventDefault() vs. return false</a><a href="/questions/what-is-a-clearfix-1657387337825">What is a clearfix?</a><a href="/questions/why-can&#x27;t-an-element-with-a-z-index-value-cover-its-child-1657387707187">Why can&#x27;t an element with a z-index value cover its child?</a><a href="/questions/syntax-error-due-to-using-a-reserved-word-as-a-table-or-column-name-in-mysql-1657384689274">Syntax error due to using a reserved word as a table or column name in MySQL</a><a href="/questions/what-is-the-scope-of-variables-in-javascript-1657384464291">What is the scope of variables in JavaScript?</a><a href="/questions/why-is-the-gets-function-so-dangerous-that-it-should-not-be-used-1657384544362">Why is the gets function so dangerous that it should not be used?</a><a href="/questions/what-is-the-difference-between-public-protected-package-private-and-private-in-java-1657387376262">What is the difference between public, protected, package-private and private in Java?</a><a href="/questions/default-constructor-with-empty-brackets-1657388246967">Default constructor with empty brackets</a><a href="/questions/safely-turning-a-json-string-into-an-object-1657388194824">Safely turning a JSON string into an object</a><a href="/questions/transitions-on-the-css-display-property-1657387761601">Transitions on the CSS display property</a><a href="/questions/why-does-the-order-in-which-libraries-are-linked-sometimes-cause-errors-in-gcc-1657387609554">Why does the order in which libraries are linked sometimes cause errors in GCC?</a><a href="/questions/srand()-why-call-it-only-once-1657387794760">srand()  why call it only once?</a></div></div><span class="cursor-pointer text-lg p-2" style="position:fixed;bottom:20px;left:20px;background:#000;z-index:2000;color:white">Go go top</span></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"data":{"answer":["\n\u0026lt;p\u0026gt;Actually, this is not a design flaw, and it is not because of internals or performance. It comes simply from the fact that functions in Python are first-class objects, and not only a piece of code.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;As soon as you think of it this way, then it completely makes sense: a function is an object being evaluated on its definition; default parameters are kind of \u0026quot;member data\u0026quot; and therefore their state may change from one call to the other - exactly as in any other object.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;In any case, the effbot (Fredrik Lundh) has a very nice explanation of the reasons for this behavior in \u0026lt;a href=\u0026quot;https://web.archive.org/web/20200221224620id_/http://effbot.org/zone/default-values.htm\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;Default Parameter Values in Python\u0026lt;/a\u0026gt;.\nI found it very clear, and I really suggest reading it for a better knowledge of how function objects work.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Suppose you have the following code\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;fruits = (\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;apples\u0026quot;\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;bananas\u0026quot;\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;loganberries\u0026quot;\u0026lt;/span\u0026gt;)\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;def\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;eat\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;food=fruits\u0026lt;/span\u0026gt;):\n    ...\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;When I see the declaration of eat, the least astonishing thing is to think that if the first parameter is not given, that it will be equal to the tuple \u0026lt;code\u0026gt;(\u0026quot;apples\u0026quot;, \u0026quot;bananas\u0026quot;, \u0026quot;loganberries\u0026quot;)\u0026lt;/code\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;However, suppose later on in the code, I do something like\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;def\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;some_random_function\u0026lt;/span\u0026gt;():\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;global\u0026lt;/span\u0026gt; fruits\n    fruits = (\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;blueberries\u0026quot;\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;mangos\u0026quot;\u0026lt;/span\u0026gt;)\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;then if default parameters were bound at function execution rather than function declaration, I would be astonished (in a very bad way) to discover that fruits had been changed. This would be more astonishing IMO than discovering that your \u0026lt;code\u0026gt;foo\u0026lt;/code\u0026gt; function above was mutating the list.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;The real problem lies with mutable variables, and all languages have this problem to some extent. Here\u0026apos;s a question: suppose in Java I have the following code:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-java s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-java\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;StringBuffer\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;s\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;StringBuffer\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Hello World!\u0026quot;\u0026lt;/span\u0026gt;);\nMap\u0026amp;lt;StringBuffer,Integer\u0026amp;gt; counts = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;HashMap\u0026lt;/span\u0026gt;\u0026amp;lt;StringBuffer,Integer\u0026amp;gt;();\ncounts.put(s, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;5\u0026lt;/span\u0026gt;);\ns.append(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;!!!!\u0026quot;\u0026lt;/span\u0026gt;);\nSystem.out.println( counts.get(s) );  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// does this work?\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;Now, does my map use the value of the \u0026lt;code\u0026gt;StringBuffer\u0026lt;/code\u0026gt; key when it was placed into the map, or does it store the key by reference? Either way, someone is astonished; either the person who tried to get the object out of the \u0026lt;code\u0026gt;Map\u0026lt;/code\u0026gt; using a value identical to the one they put it in with, or the person who can\u0026apos;t seem to retrieve their object even though the key they\u0026apos;re using is literally the same object that was used to put it into the map (this is actually why Python doesn\u0026apos;t allow its mutable built-in data types to be used as dictionary keys).\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Your example is a good one of a case where Python newcomers will be surprised and bitten. But I\u0026apos;d argue that if we \u0026quot;fixed\u0026quot; this, then that would only create a different situation where they\u0026apos;d be bitten instead, and that one would be even less intuitive. Moreover, this is always the case when dealing with mutable variables; you always run into cases where someone could intuitively expect one or the opposite behavior depending on what code they\u0026apos;re writing.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;I personally like Python\u0026apos;s current approach: default function arguments are evaluated when the function is defined and that object is always the default. I suppose they could special-case using an empty list, but that kind of special casing would cause even more astonishment, not to mention be backwards incompatible.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;The relevant part of the \u0026lt;a href=\u0026quot;http://docs.python.org/reference/compound_stmts.html#function-definitions\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;documentation\u0026lt;/a\u0026gt;:\u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Default parameter values are evaluated from left to right when the function definition is executed.\u0026lt;/strong\u0026gt; This means that the expression is evaluated once, when the function is defined, and that the same pre-computed value is used for each call. This is especially important to understand when a default parameter is a mutable object, such as a list or a dictionary: if the function modifies the object (e.g. by appending an item to a list), the default value is in effect modified. This is generally not what was intended. A way around this is to use \u0026lt;code\u0026gt;None\u0026lt;/code\u0026gt; as the default, and explicitly test for it in the body of the function, e.g.:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;def\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;whats_on_the_telly\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;penguin=\u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;None\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;):\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; penguin \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;is\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;None\u0026lt;/span\u0026gt;:\n        penguin = []\n    penguin.append(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;property of the zoo\u0026quot;\u0026lt;/span\u0026gt;)\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; penguin\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n    ","\n\u0026lt;p\u0026gt;I know nothing about the Python interpreter inner workings (and I\u0026apos;m not an expert in compilers and interpreters either) so don\u0026apos;t blame me if I propose anything unsensible or impossible.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Provided that python objects \u0026lt;strong\u0026gt;are mutable\u0026lt;/strong\u0026gt; I think that this should be taken into account when designing the default arguments stuff.\nWhen you instantiate a list:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;a = []\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;you expect to get a \u0026lt;strong\u0026gt;new\u0026lt;/strong\u0026gt; list referenced by \u0026lt;code\u0026gt;a\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Why should the \u0026lt;code\u0026gt;a=[]\u0026lt;/code\u0026gt; in\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;def\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;x\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;a=[]\u0026lt;/span\u0026gt;):\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;instantiate a new list on function definition and not on invocation?\nIt\u0026apos;s just like you\u0026apos;re asking \u0026quot;if the user doesn\u0026apos;t provide the argument then \u0026lt;em\u0026gt;instantiate\u0026lt;/em\u0026gt; a new list and use it as if it was produced by the caller\u0026quot;.\nI think this is ambiguous instead:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;def\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;x\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;a=datetime.datetime.now(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;)\u0026lt;/span\u0026gt;):\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;user, do you want \u0026lt;code\u0026gt;a\u0026lt;/code\u0026gt; to default to the datetime corresponding to when you\u0026apos;re defining or executing \u0026lt;code\u0026gt;x\u0026lt;/code\u0026gt;?\nIn this case, as in the previous one, I\u0026apos;ll keep the same behaviour as if the default argument \u0026quot;assignment\u0026quot; was the first instruction of the function (\u0026lt;code\u0026gt;datetime.now()\u0026lt;/code\u0026gt; called on function invocation).\nOn the other hand, if the user wanted the definition-time mapping he could write:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;b = datetime.datetime.now()\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;def\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;x\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;a=b\u0026lt;/span\u0026gt;):\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;I know, I know: that\u0026apos;s a closure. Alternatively Python might provide a keyword to force definition-time binding:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;def\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;x\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;static a=b\u0026lt;/span\u0026gt;):\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Well, the reason is quite simply that bindings are done when code is executed, and the function definition is executed, well... when the functions is defined.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Compare this:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;BananaBunch\u0026lt;/span\u0026gt;:\n    bananas = []\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;def\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;addBanana\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;self, banana\u0026lt;/span\u0026gt;):\n        self.bananas.append(banana)\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;This code suffers from the exact same unexpected happenstance. bananas is a class attribute, and hence, when you add things to it, it\u0026apos;s added to all instances of that class. The reason is exactly the same.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;It\u0026apos;s just \u0026quot;How It Works\u0026quot;, and making it work differently in the function case would probably be complicated, and in the class case likely impossible, or at least slow down object instantiation a lot, as you would have to keep the class code around and execute it when objects are created.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Yes, it is unexpected. But once the penny drops, it fits in perfectly with how Python works in general. In fact, it\u0026apos;s a good teaching aid, and once you understand why this happens, you\u0026apos;ll grok python much better.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;That said it should feature prominently in any good Python tutorial. Because as you mention, everyone runs into this problem sooner or later.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;h2\u0026gt;Why don\u0026apos;t you introspect?\u0026lt;/h2\u0026gt;\n\n\u0026lt;p\u0026gt;I\u0026apos;m \u0026lt;em\u0026gt;really\u0026lt;/em\u0026gt; surprised no one has performed the insightful introspection offered by Python (\u0026lt;code\u0026gt;2\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;3\u0026lt;/code\u0026gt; apply) on callables. \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Given a simple little function \u0026lt;code\u0026gt;func\u0026lt;/code\u0026gt; defined as:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026amp;gt; \u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;def\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;func\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;a = []\u0026lt;/span\u0026gt;):\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;... \u0026lt;/span\u0026gt;   a.append(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;5\u0026lt;/span\u0026gt;)\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;When Python encounters it, the first thing it will do is compile it in order to create a \u0026lt;code\u0026gt;code\u0026lt;/code\u0026gt; object for this function. While this compilation step is done, \u0026lt;em\u0026gt;Python \u0026lt;strong\u0026gt;evaluates\u0026lt;/strong\u0026gt;* and then \u0026lt;strong\u0026gt;stores\u0026lt;/strong\u0026gt; the default arguments (an empty list \u0026lt;code\u0026gt;[]\u0026lt;/code\u0026gt; here) in the function object itself\u0026lt;/em\u0026gt;. As the top answer mentioned: the list \u0026lt;code\u0026gt;a\u0026lt;/code\u0026gt; can now be considered a \u0026lt;em\u0026gt;member\u0026lt;/em\u0026gt; of the function \u0026lt;code\u0026gt;func\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;So, let\u0026apos;s do some introspection, a before and after to examine how the list gets expanded \u0026lt;strong\u0026gt;inside\u0026lt;/strong\u0026gt; the function object. I\u0026apos;m using \u0026lt;code\u0026gt;Python 3.x\u0026lt;/code\u0026gt; for this, for Python 2 the same applies (use \u0026lt;code\u0026gt;__defaults__\u0026lt;/code\u0026gt; or \u0026lt;code\u0026gt;func_defaults\u0026lt;/code\u0026gt; in Python 2; yes, two names for the same thing).\u0026lt;/p\u0026gt;\n\n\u0026lt;h3\u0026gt;Function Before Execution:\u0026lt;/h3\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026amp;gt; \u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;def\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;func\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;a = []\u0026lt;/span\u0026gt;):\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;... \u0026lt;/span\u0026gt;    a.append(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;5\u0026lt;/span\u0026gt;)\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;... \u0026lt;/span\u0026gt;    \n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;After Python executes this definition it will take any default parameters specified (\u0026lt;code\u0026gt;a = []\u0026lt;/code\u0026gt; here) and \u0026lt;a href=\u0026quot;https://docs.python.org/3/reference/datamodel.html#the-standard-type-hierarchy\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;cram them in the \u0026lt;code\u0026gt;__defaults__\u0026lt;/code\u0026gt; attribute for the function object\u0026lt;/a\u0026gt; (relevant section: Callables):     \u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026amp;gt; \u0026lt;/span\u0026gt;func.__defaults__\n([],)\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;O.k, so an empty list as the single entry in \u0026lt;code\u0026gt;__defaults__\u0026lt;/code\u0026gt;, just as expected. \u0026lt;/p\u0026gt;\n\n\u0026lt;h3\u0026gt;Function After Execution:\u0026lt;/h3\u0026gt;\n\n\u0026lt;p\u0026gt;Let\u0026apos;s now execute this function:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026amp;gt; \u0026lt;/span\u0026gt;func()\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Now, let\u0026apos;s see those \u0026lt;code\u0026gt;__defaults__\u0026lt;/code\u0026gt; again: \u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026amp;gt; \u0026lt;/span\u0026gt;func.__defaults__\n([\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;5\u0026lt;/span\u0026gt;],)\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;em\u0026gt;Astonished?\u0026lt;/em\u0026gt; The value inside the object changes! Consecutive calls to the function will now simply append to that embedded \u0026lt;code\u0026gt;list\u0026lt;/code\u0026gt; object:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026amp;gt; \u0026lt;/span\u0026gt;func(); func(); func()\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026amp;gt; \u0026lt;/span\u0026gt;func.__defaults__\n([\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;5\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;5\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;5\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;5\u0026lt;/span\u0026gt;],)\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;So, there you have it, the reason why this \u0026lt;em\u0026gt;\u0026apos;flaw\u0026apos;\u0026lt;/em\u0026gt; happens, is because default arguments are part of the function object. There\u0026apos;s nothing weird going on here, it\u0026apos;s all just a bit surprising.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;The common solution to combat this is to use \u0026lt;code\u0026gt;None\u0026lt;/code\u0026gt; as the default and then initialize in the function body:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;def\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;func\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;a = \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;None\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;):\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;# or: a = [] if a is None else a\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; a \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;is\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;None\u0026lt;/span\u0026gt;:\n        a = []\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Since the function body is executed anew each time, you always get a fresh new empty list if no argument was passed for \u0026lt;code\u0026gt;a\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n\n\u0026lt;hr\u0026gt;\n\n\u0026lt;p\u0026gt;To further verify that the list in \u0026lt;code\u0026gt;__defaults__\u0026lt;/code\u0026gt; is the same as that used in the function \u0026lt;code\u0026gt;func\u0026lt;/code\u0026gt; you can just change your function to return the \u0026lt;code\u0026gt;id\u0026lt;/code\u0026gt; of the list \u0026lt;code\u0026gt;a\u0026lt;/code\u0026gt; used inside the function body. Then, compare it to the list in \u0026lt;code\u0026gt;__defaults__\u0026lt;/code\u0026gt; (position \u0026lt;code\u0026gt;[0]\u0026lt;/code\u0026gt; in \u0026lt;code\u0026gt;__defaults__\u0026lt;/code\u0026gt;) and you\u0026apos;ll see how these are indeed refering to the same list instance:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026amp;gt; \u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;def\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;func\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;a = []\u0026lt;/span\u0026gt;): \n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;... \u0026lt;/span\u0026gt;    a.append(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;5\u0026lt;/span\u0026gt;)\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;... \u0026lt;/span\u0026gt;    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;id\u0026lt;/span\u0026gt;(a)\n\u0026amp;gt;\u0026amp;gt;\u0026amp;gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026amp;gt; \u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;id\u0026lt;/span\u0026gt;(func.__defaults__[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;]) == func()\n\u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;True\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;All with the power of introspection! \u0026lt;/p\u0026gt;\n\n\u0026lt;hr\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;sup\u0026gt;*\u0026lt;/sup\u0026gt; To verify that Python evaluates the default arguments during compilation of the function, try executing the following:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;def\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;bar\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;a=\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;input\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;Did you just see me without calling the function?\u0026apos;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;)\u0026lt;/span\u0026gt;): \n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;pass\u0026lt;/span\u0026gt;  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;# use raw_input in Py2\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;as you\u0026apos;ll notice, \u0026lt;code\u0026gt;input()\u0026lt;/code\u0026gt; is called before the process of building the function and binding it to the name \u0026lt;code\u0026gt;bar\u0026lt;/code\u0026gt; is made.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;I used to think that creating the objects at runtime would be the better approach.  I\u0026apos;m less certain now, since you do lose some useful features, though it may be worth it regardless simply to prevent newbie confusion.  The disadvantages of doing so are:\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;1. Performance\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;def\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;foo\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;arg=something_expensive_to_compute(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;)\u0026lt;/span\u0026gt;)):\n    ...\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;If call-time evaluation is used, then the expensive function is called every time your function is used without an argument.  You\u0026apos;d either pay an expensive price on each call, or need to manually cache the value externally, polluting your namespace and adding verbosity.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;2. Forcing bound parameters\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;A useful trick is to bind parameters of a lambda to the \u0026lt;em\u0026gt;current\u0026lt;/em\u0026gt; binding of a variable when the lambda is created.  For example:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;funcs = [ \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;lambda\u0026lt;/span\u0026gt; i=i: i \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt; i \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;in\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;range\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;10\u0026lt;/span\u0026gt;)]\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;This returns a list of functions that return 0,1,2,3... respectively.  If the behaviour is changed, they will instead bind \u0026lt;code\u0026gt;i\u0026lt;/code\u0026gt; to the \u0026lt;em\u0026gt;call-time\u0026lt;/em\u0026gt; value of i, so you would get a list of functions that all returned \u0026lt;code\u0026gt;9\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;The only way to implement this otherwise would be to create a further closure with the i bound, ie:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;def\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;make_func\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;i\u0026lt;/span\u0026gt;): \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;lambda\u0026lt;/span\u0026gt;: i\nfuncs = [make_func(i) \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt; i \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;in\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;range\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;10\u0026lt;/span\u0026gt;)]\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;3. Introspection\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Consider the code:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;def\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;foo\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;a=\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;test\u0026apos;\u0026lt;/span\u0026gt;, b=\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;100\u0026lt;/span\u0026gt;, c=[]\u0026lt;/span\u0026gt;):\n   \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt; a,b,c\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;We can get information about the arguments and defaults using the \u0026lt;code\u0026gt;inspect\u0026lt;/code\u0026gt; module, which \u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026amp;gt; \u0026lt;/span\u0026gt;inspect.getargspec(foo)\n([\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;a\u0026apos;\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;b\u0026apos;\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;c\u0026apos;\u0026lt;/span\u0026gt;], \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;None\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;None\u0026lt;/span\u0026gt;, (\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;test\u0026apos;\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;100\u0026lt;/span\u0026gt;, []))\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;This information is very useful for things like document generation, metaprogramming, decorators etc.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Now, suppose the behaviour of defaults could be changed so that this is the equivalent of:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;_undefined = \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;object\u0026lt;/span\u0026gt;()  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;# sentinel value\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;def\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;foo\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;a=_undefined, b=_undefined, c=_undefined\u0026lt;/span\u0026gt;)\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; a \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;is\u0026lt;/span\u0026gt; _undefined: a=\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;test\u0026apos;\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; b \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;is\u0026lt;/span\u0026gt; _undefined: b=\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;100\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; c \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;is\u0026lt;/span\u0026gt; _undefined: c=[]\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;However, we\u0026apos;ve lost the ability to introspect, and see what the default arguments \u0026lt;em\u0026gt;are\u0026lt;/em\u0026gt;.  Because the objects haven\u0026apos;t been constructed, we can\u0026apos;t ever get hold of them without actually calling the function.  The best we could do is to store off the source code and return that as a string.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;h1\u0026gt;5 points in defense of Python\u0026lt;/h1\u0026gt;\n\u0026lt;ol\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Simplicity\u0026lt;/strong\u0026gt;: The behavior is simple in the following sense:\nMost people fall into this trap only once, not several times.\u0026lt;/p\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Consistency\u0026lt;/strong\u0026gt;: Python \u0026lt;em\u0026gt;always\u0026lt;/em\u0026gt; passes objects, not names.\nThe default parameter is, obviously, part of the function\nheading (not the function body). It therefore ought to be evaluated\nat module load time (and only at module load time, unless nested), not\nat function call time.\u0026lt;/p\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Usefulness\u0026lt;/strong\u0026gt;: As Frederik Lundh points out in his explanation\nof \u0026lt;a href=\u0026quot;https://web.archive.org/web/20201112004749/http://effbot.org/zone/default-values.htm\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;\u0026quot;Default Parameter Values in Python\u0026quot;\u0026lt;/a\u0026gt;, the\ncurrent behavior can be quite useful for advanced programming.\n(Use sparingly.)\u0026lt;/p\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Sufficient documentation\u0026lt;/strong\u0026gt;: In the most basic Python documentation,\nthe tutorial, the issue is loudly announced as\nan \u0026lt;strong\u0026gt;\u0026quot;Important warning\u0026quot;\u0026lt;/strong\u0026gt; in the \u0026lt;em\u0026gt;first\u0026lt;/em\u0026gt; subsection of Section\n\u0026lt;a href=\u0026quot;https://docs.python.org/3/tutorial/controlflow.html#default-argument-values\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;\u0026quot;More on Defining Functions\u0026quot;\u0026lt;/a\u0026gt;.\nThe warning even uses boldface,\nwhich is rarely applied outside of headings.\nRTFM: Read the fine manual.\u0026lt;/p\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Meta-learning\u0026lt;/strong\u0026gt;: Falling into the trap is actually a very\nhelpful moment (at least if you are a reflective learner),\nbecause you will subsequently better understand the point\n\u0026quot;Consistency\u0026quot; above and that will\nteach you a great deal about Python.\u0026lt;/p\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;/ol\u0026gt;\n    ","\n\u0026lt;p\u0026gt;This behavior is easy explained by:\u0026lt;/p\u0026gt;\n\n\u0026lt;ol\u0026gt;\n\u0026lt;li\u0026gt;function (class etc.) declaration is executed only once, creating all default value objects\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;everything is passed by reference\u0026lt;/li\u0026gt;\n\u0026lt;/ol\u0026gt;\n\n\u0026lt;p\u0026gt;So:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;def\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;x\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;a=\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;, b=[], c=[], d=\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;):\n    a = a + \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;\n    b = b + [\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;]\n    c.append(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;)\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt; a, b, c\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;ol\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;code\u0026gt;a\u0026lt;/code\u0026gt; doesn\u0026apos;t change - every assignment call creates new int object - new object is printed\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;code\u0026gt;b\u0026lt;/code\u0026gt; doesn\u0026apos;t change - new array is build from default value and printed\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;code\u0026gt;c\u0026lt;/code\u0026gt; changes - operation is performed on same object - and it is printed\u0026lt;/li\u0026gt;\n\u0026lt;/ol\u0026gt;\n    ","\n\u0026lt;p\u0026gt;1)  The so-called problem of \u0026quot;Mutable Default Argument\u0026quot; is in general a special example demonstrating that:\u0026lt;br\u0026gt;\n\u0026quot;All functions with this problem \u0026lt;strong\u0026gt;suffer also from similar side effect problem on the actual parameter\u0026lt;/strong\u0026gt;,\u0026quot;\u0026lt;br\u0026gt;\nThat is against the rules of functional programming, usually undesiderable and should be fixed both together.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Example:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;def\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;foo\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;a=[]\u0026lt;/span\u0026gt;):                 \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;# the same problematic function\u0026lt;/span\u0026gt;\n    a.append(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;5\u0026lt;/span\u0026gt;)\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; a\n\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026amp;gt; \u0026lt;/span\u0026gt;somevar = [\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;]           \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;# an example without a default parameter\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026amp;gt; \u0026lt;/span\u0026gt;foo(somevar)\n[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;5\u0026lt;/span\u0026gt;]\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026amp;gt; \u0026lt;/span\u0026gt;somevar\n[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;5\u0026lt;/span\u0026gt;]                      \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;# usually expected [1, 2]\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Solution\u0026lt;/strong\u0026gt;:  a \u0026lt;strong\u0026gt;copy\u0026lt;/strong\u0026gt;\u0026lt;br\u0026gt;\nAn absolutely safe solution is to \u0026lt;strong\u0026gt;\u0026lt;code\u0026gt;copy\u0026lt;/code\u0026gt;\u0026lt;/strong\u0026gt; or \u0026lt;strong\u0026gt;\u0026lt;code\u0026gt;deepcopy\u0026lt;/code\u0026gt;\u0026lt;/strong\u0026gt; the input object first and then to do whatever with the copy.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;def\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;foo\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;a=[]\u0026lt;/span\u0026gt;):\n    a = a[:]     \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;# a copy\u0026lt;/span\u0026gt;\n    a.append(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;5\u0026lt;/span\u0026gt;)\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; a     \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;# or everything safe by one line: \u0026quot;return a + [5]\u0026quot;\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Many builtin mutable types have a copy method like \u0026lt;code\u0026gt;some_dict.copy()\u0026lt;/code\u0026gt; or \u0026lt;code\u0026gt;some_set.copy()\u0026lt;/code\u0026gt; or can be copied easy like \u0026lt;code\u0026gt;somelist[:]\u0026lt;/code\u0026gt; or \u0026lt;code\u0026gt;list(some_list)\u0026lt;/code\u0026gt;. Every object can be also copied by \u0026lt;code\u0026gt;copy.copy(any_object)\u0026lt;/code\u0026gt; or more thorough by \u0026lt;code\u0026gt;copy.deepcopy()\u0026lt;/code\u0026gt; (the latter useful if the mutable object is composed from mutable objects). Some objects are fundamentally based on side effects like \u0026quot;file\u0026quot; object and can not be meaningfully reproduced by copy. \u0026lt;a href=\u0026quot;http://effbot.org/pyfaq/how-do-i-copy-an-object-in-python.htm\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;copying\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Example problem for \u0026lt;a href=\u0026quot;https://stackoverflow.com/q/13484107/448474\u0026quot;\u0026gt;a similar SO question\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Test\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-title class_ inherited__\u0026quot;\u0026gt;object\u0026lt;/span\u0026gt;):            \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;# the original problematic class\u0026lt;/span\u0026gt;\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;def\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;__init__\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;self, var1=[]\u0026lt;/span\u0026gt;):\n    self._var1 = var1\n\nsomevar = [\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;]               \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;# an example without a default parameter\u0026lt;/span\u0026gt;\nt1 = Test(somevar)\nt2 = Test(somevar)\nt1._var1.append([\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;])\n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt; somevar                  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;# [1, 2, [1]] but usually expected [1, 2]\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt; t2._var1                 \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;# [1, 2, [1]] but usually expected [1, 2]\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;It shouldn\u0026apos;t be neither saved in any \u0026lt;em\u0026gt;public\u0026lt;/em\u0026gt; attribute of an instance returned by this function. (Assuming that \u0026lt;em\u0026gt;private\u0026lt;/em\u0026gt; attributes of instance should not be modified from outside of this class or subclasses by convention. i.e. \u0026lt;code\u0026gt;_var1\u0026lt;/code\u0026gt; is a private attribute )\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Conclusion:\u0026lt;br\u0026gt;\nInput parameters objects shouldn\u0026apos;t be modified in place (mutated) nor they should not be binded into an object returned by the function. (If we prefere programming without side effects which is strongly recommended. see \u0026lt;a href=\u0026quot;http://en.wikipedia.org/wiki/Side_effect_%28computer_science%29\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;Wiki about \u0026quot;side effect\u0026quot;\u0026lt;/a\u0026gt; (The first two paragraphs are relevent in this context.)\n.)\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;2)\u0026lt;br\u0026gt;\nOnly if the side effect on the actual parameter is required but unwanted on the default parameter then the useful solution is \u0026lt;code\u0026gt;def ...(var1=None):\u0026lt;/code\u0026gt; \u0026lt;code\u0026gt;if var1 is None:\u0026lt;/code\u0026gt; \u0026lt;code\u0026gt;var1 = []\u0026lt;/code\u0026gt; \u0026lt;a href=\u0026quot;http://effbot.org/zone/default-values.htm#what-to-do-instead\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;More..\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;3) In some cases is \u0026lt;a href=\u0026quot;http://effbot.org/zone/default-values.htm#valid-uses-for-mutable-defaults\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;the mutable behavior of default parameters useful\u0026lt;/a\u0026gt;.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;What you\u0026apos;re asking is why this:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;def\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;func\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;a=[], b = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;):\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;pass\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;isn\u0026apos;t internally equivalent to this:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;def\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;func\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;a=\u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;None\u0026lt;/span\u0026gt;, b = \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;None\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;):\n    a_default = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;lambda\u0026lt;/span\u0026gt;: []\n    b_default = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;lambda\u0026lt;/span\u0026gt;: \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;def\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;actual_func\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;a=\u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;None\u0026lt;/span\u0026gt;, b=\u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;None\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;):\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; a \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;is\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;None\u0026lt;/span\u0026gt;: a = a_default()\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; b \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;is\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;None\u0026lt;/span\u0026gt;: b = b_default()\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; actual_func\nfunc = func()\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;except for the case of explicitly calling func(None, None), which we\u0026apos;ll ignore.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;In other words, instead of evaluating default parameters, why not store each of them, and evaluate them when the function is called?\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;One answer is probably right there--it would effectively turn every function with default parameters into a closure.  Even if it\u0026apos;s all hidden away in the interpreter and not a full-blown closure, the data\u0026apos;s got to be stored somewhere.  It\u0026apos;d be slower and use more memory.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;This actually has nothing to do with default values, other than that it often comes up as an unexpected behaviour when you write functions with mutable default values.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026amp;gt; \u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;def\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;foo\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;a\u0026lt;/span\u0026gt;):\n    a.append(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;5\u0026lt;/span\u0026gt;)\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt; a\n\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026amp;gt; \u0026lt;/span\u0026gt;a  = [\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;5\u0026lt;/span\u0026gt;]\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026amp;gt; \u0026lt;/span\u0026gt;foo(a)\n[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;5\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;5\u0026lt;/span\u0026gt;]\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026amp;gt; \u0026lt;/span\u0026gt;foo(a)\n[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;5\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;5\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;5\u0026lt;/span\u0026gt;]\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026amp;gt; \u0026lt;/span\u0026gt;foo(a)\n[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;5\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;5\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;5\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;5\u0026lt;/span\u0026gt;]\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026amp;gt; \u0026lt;/span\u0026gt;foo(a)\n[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;5\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;5\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;5\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;5\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;5\u0026lt;/span\u0026gt;]\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;No default values in sight in this code, but you get exactly the same problem.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;The problem is that \u0026lt;code\u0026gt;foo\u0026lt;/code\u0026gt; is \u0026lt;em\u0026gt;modifying\u0026lt;/em\u0026gt; a mutable variable passed in from the caller, when the caller doesn\u0026apos;t expect this. Code like this would be fine if the function was called something like \u0026lt;code\u0026gt;append_5\u0026lt;/code\u0026gt;; then the caller would be calling the function in order to modify the value they pass in, and the behaviour would be expected. But such a function would be very unlikely to take a default argument, and probably wouldn\u0026apos;t return the list (since the caller already has a reference to that list; the one it just passed in).\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Your original \u0026lt;code\u0026gt;foo\u0026lt;/code\u0026gt;, with a default argument, shouldn\u0026apos;t be modifying \u0026lt;code\u0026gt;a\u0026lt;/code\u0026gt; whether it was explicitly passed in or got the default value. Your code should leave mutable arguments alone unless it is clear from the context/name/documentation that the arguments are supposed to be modified. Using mutable values passed in as arguments as local temporaries is an extremely bad idea, whether we\u0026apos;re in Python or not and whether there are default arguments involved or not.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;If you need to destructively manipulate a local temporary in the course of computing something, and you need to start your manipulation from an argument value, you need to make a copy.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Already busy topic, but from what I read here, the following helped me realizing how it\u0026apos;s working internally:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;def\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;bar\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;a=[]\u0026lt;/span\u0026gt;):\n     \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;id\u0026lt;/span\u0026gt;(a)\n     a = a + [\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;]\n     \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;id\u0026lt;/span\u0026gt;(a)\n     \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; a\n\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026amp;gt; \u0026lt;/span\u0026gt;bar()\n\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;4484370232\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;4484524224\u0026lt;/span\u0026gt;\n[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;]\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026amp;gt; \u0026lt;/span\u0026gt;bar()\n\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;4484370232\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;4484524152\u0026lt;/span\u0026gt;\n[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;]\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026amp;gt; \u0026lt;/span\u0026gt;bar()\n\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;4484370232\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;# Never change, this is \u0026apos;class property\u0026apos; of the function\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;4484523720\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;# Always a new object \u0026lt;/span\u0026gt;\n[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;]\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026amp;gt; \u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;id\u0026lt;/span\u0026gt;(bar.func_defaults[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;])\n\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;4484370232\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;h1\u0026gt;Python: The Mutable Default Argument\u0026lt;/h1\u0026gt;\n\n\u0026lt;p\u0026gt;Default arguments get evaluated at the time the function is compiled into a function object. When used by the function, multiple times by that function, they are and remain the same object. \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;When they are mutable, when mutated (for example, by adding an element to it) they remain mutated on consecutive calls.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;They stay mutated because they are the same object each time.\u0026lt;/p\u0026gt;\n\n\u0026lt;h2\u0026gt;Equivalent code:\u0026lt;/h2\u0026gt;\n\n\u0026lt;p\u0026gt;Since the list is bound to the function when the function object is compiled and instantiated, this:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;def\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;foo\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;mutable_default_argument=[]\u0026lt;/span\u0026gt;): \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;# make a list the default argument\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;\u0026quot;\u0026quot;function that uses a list\u0026quot;\u0026quot;\u0026quot;\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;is almost exactly equivalent to this:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;_a_list = [] \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;# create a list in the globals\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;def\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;foo\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;mutable_default_argument=_a_list\u0026lt;/span\u0026gt;): \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;# make it the default argument\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;\u0026quot;\u0026quot;function that uses a list\u0026quot;\u0026quot;\u0026quot;\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;del\u0026lt;/span\u0026gt; _a_list \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;# remove globals name binding\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;h2\u0026gt;Demonstration\u0026lt;/h2\u0026gt;\n\n\u0026lt;p\u0026gt;Here\u0026apos;s a demonstration - you can verify that they are the same object each time they are referenced by \u0026lt;/p\u0026gt;\n\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;seeing that the list is created before the function has finished compiling to a function object,\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;observing that the id is the same each time the list is referenced,\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;observing that the list stays changed when the function that uses it is called a second time,\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;observing the order in which the output is printed from the source (which I conveniently numbered for you):\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;code\u0026gt;example.py\u0026lt;/code\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;1. Global scope being evaluated\u0026apos;\u0026lt;/span\u0026gt;)\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;def\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;create_list\u0026lt;/span\u0026gt;():\n    \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;\u0026apos;\u0026apos;noisily create a list for usage as a kwarg\u0026apos;\u0026apos;\u0026apos;\u0026lt;/span\u0026gt;\n    l = []\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;3. list being created and returned, id: \u0026apos;\u0026lt;/span\u0026gt; + \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;str\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;id\u0026lt;/span\u0026gt;(l)))\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; l\n\n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;2. example_function about to be compiled to an object\u0026apos;\u0026lt;/span\u0026gt;)\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;def\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;example_function\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;default_kwarg1=create_list(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;)\u0026lt;/span\u0026gt;):\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;appending \u0026quot;a\u0026quot; in default default_kwarg1\u0026apos;\u0026lt;/span\u0026gt;)\n    default_kwarg1.append(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;a\u0026quot;\u0026lt;/span\u0026gt;)\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;list with id: \u0026apos;\u0026lt;/span\u0026gt; + \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;str\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;id\u0026lt;/span\u0026gt;(default_kwarg1)) + \n          \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos; - is now: \u0026apos;\u0026lt;/span\u0026gt; + \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;repr\u0026lt;/span\u0026gt;(default_kwarg1))\n\n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;4. example_function compiled: \u0026apos;\u0026lt;/span\u0026gt; + \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;repr\u0026lt;/span\u0026gt;(example_function))\n\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; __name__ == \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;__main__\u0026apos;\u0026lt;/span\u0026gt;:\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;5. calling example_function twice!:\u0026apos;\u0026lt;/span\u0026gt;)\n    example_function()\n    example_function()\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;and running it with \u0026lt;code\u0026gt;python example.py\u0026lt;/code\u0026gt;:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1.\u0026lt;/span\u0026gt; Global scope being evaluated\n\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2.\u0026lt;/span\u0026gt; example_function about to be compiled to an \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;object\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3.\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;list\u0026lt;/span\u0026gt; being created \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;and\u0026lt;/span\u0026gt; returned, \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;id\u0026lt;/span\u0026gt;: \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;140502758808032\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;4.\u0026lt;/span\u0026gt; example_function compiled: \u0026amp;lt;function example_function at \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0x7fc9590905f0\u0026lt;/span\u0026gt;\u0026amp;gt;\n\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;5.\u0026lt;/span\u0026gt; calling example_function twice!:\nappending \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;a\u0026quot;\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;in\u0026lt;/span\u0026gt; default default_kwarg1\n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;list\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;with\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;id\u0026lt;/span\u0026gt;: \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;140502758808032\u0026lt;/span\u0026gt; - \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;is\u0026lt;/span\u0026gt; now: [\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;a\u0026apos;\u0026lt;/span\u0026gt;]\nappending \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;a\u0026quot;\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;in\u0026lt;/span\u0026gt; default default_kwarg1\n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;list\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;with\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;id\u0026lt;/span\u0026gt;: \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;140502758808032\u0026lt;/span\u0026gt; - \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;is\u0026lt;/span\u0026gt; now: [\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;a\u0026apos;\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;a\u0026apos;\u0026lt;/span\u0026gt;]\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;h2\u0026gt;Does this violate the principle of \u0026quot;Least Astonishment\u0026quot;?\u0026lt;/h2\u0026gt;\n\n\u0026lt;p\u0026gt;This order of execution is frequently confusing to new users of Python. If you understand the Python execution model, then it becomes quite expected. \u0026lt;/p\u0026gt;\n\n\u0026lt;h2\u0026gt;The usual instruction to new Python users:\u0026lt;/h2\u0026gt;\n\n\u0026lt;p\u0026gt;But this is why the usual instruction to new users is to create their default arguments like this instead:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;def\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;example_function_2\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;default_kwarg=\u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;None\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;):\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; default_kwarg \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;is\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;None\u0026lt;/span\u0026gt;:\n        default_kwarg = []\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;This uses the None singleton as a sentinel object to tell the function whether or not we\u0026apos;ve gotten an argument other than the default. If we get no argument, then we actually want to use a new empty list, \u0026lt;code\u0026gt;[]\u0026lt;/code\u0026gt;, as the default.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;As the \u0026lt;a href=\u0026quot;https://docs.python.org/tutorial/controlflow.html#default-argument-values\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;tutorial section on control flow\u0026lt;/a\u0026gt; says:\u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;If you dont want the default to be shared between subsequent calls,\n  you can write the function like this instead:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;def\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;f\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;a, L=\u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;None\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;):\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; L \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;is\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;None\u0026lt;/span\u0026gt;:\n        L = []\n    L.append(a)\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; L\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n    ","\n\u0026lt;p\u0026gt;The shortest answer would probably be \u0026quot;definition is execution\u0026quot;, therefore the whole argument makes no strict sense. As a more contrived example, you may cite this:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;def\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;a\u0026lt;/span\u0026gt;(): \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; []\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;def\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;b\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;x=a(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;)\u0026lt;/span\u0026gt;):\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt; x\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Hopefully it\u0026apos;s enough to show that not executing the default argument expressions at the execution time of the \u0026lt;code\u0026gt;def\u0026lt;/code\u0026gt; statement isn\u0026apos;t easy or doesn\u0026apos;t make sense, or both.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;I agree it\u0026apos;s a gotcha when you try to use default constructors, though.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;It\u0026apos;s a performance optimization.  As a result of this functionality, which of these two function calls do you think is faster?\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;def\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;print_tuple\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;some_tuple=(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;,\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;,\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;)\u0026lt;/span\u0026gt;):\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt; some_tuple\n\nprint_tuple()        \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;#1\u0026lt;/span\u0026gt;\nprint_tuple((\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;,\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;,\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3\u0026lt;/span\u0026gt;)) \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;#2\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;I\u0026apos;ll give you a hint.  Here\u0026apos;s the disassembly (see \u0026lt;a href=\u0026quot;http://docs.python.org/library/dis.html\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;http://docs.python.org/library/dis.html\u0026lt;/a\u0026gt;):\u0026lt;/p\u0026gt;\n\n\u0026lt;h1\u0026gt;\u0026lt;code\u0026gt;#\u0026lt;/code\u0026gt;1\u0026lt;/h1\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt; LOAD_GLOBAL              \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt; (print_tuple)\n\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3\u0026lt;/span\u0026gt; CALL_FUNCTION            \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;6\u0026lt;/span\u0026gt; POP_TOP\n\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;7\u0026lt;/span\u0026gt; LOAD_CONST               \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt; (\u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;None\u0026lt;/span\u0026gt;)\n\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;10\u0026lt;/span\u0026gt; RETURN_VALUE\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;h1\u0026gt;\u0026lt;code\u0026gt;#\u0026lt;/code\u0026gt;2\u0026lt;/h1\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt; LOAD_GLOBAL              \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt; (print_tuple)\n \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3\u0026lt;/span\u0026gt; LOAD_CONST               \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;4\u0026lt;/span\u0026gt; ((\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3\u0026lt;/span\u0026gt;))\n \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;6\u0026lt;/span\u0026gt; CALL_FUNCTION            \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;\n \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;9\u0026lt;/span\u0026gt; POP_TOP\n\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;10\u0026lt;/span\u0026gt; LOAD_CONST               \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt; (\u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;None\u0026lt;/span\u0026gt;)\n\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;13\u0026lt;/span\u0026gt; RETURN_VALUE\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;I doubt the experienced behavior has a practical use (who really used static variables in C, without breeding bugs ?)\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;p\u0026gt;As you can see, there \u0026lt;em\u0026gt;is\u0026lt;/em\u0026gt; a performance benefit when using immutable default arguments.  This can make a difference if it\u0026apos;s a frequently called function or the default argument takes a long time to construct.  Also, bear in mind that Python isn\u0026apos;t C.  In C you have constants that are pretty much free.  In Python you don\u0026apos;t have this benefit.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;This behavior is not surprising if you take the following into consideration:\u0026lt;/p\u0026gt;\n\u0026lt;ol\u0026gt;\n\u0026lt;li\u0026gt;The behavior of read-only class attributes upon assignment attempts, and that\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Functions are objects (explained well in the accepted answer).\u0026lt;/li\u0026gt;\n\u0026lt;/ol\u0026gt;\n\u0026lt;p\u0026gt;The role of \u0026lt;strong\u0026gt;(2)\u0026lt;/strong\u0026gt; has been covered extensively in this thread. \u0026lt;strong\u0026gt;(1)\u0026lt;/strong\u0026gt; is likely the astonishment causing factor, as this behavior is not \u0026quot;intuitive\u0026quot; when coming from other languages.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;(1)\u0026lt;/strong\u0026gt; is described in the Python \u0026lt;a href=\u0026quot;http://docs.python.org/tutorial/classes.html\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;tutorial on classes\u0026lt;/a\u0026gt;. In an attempt to assign a value to a read-only class attribute:\u0026lt;/p\u0026gt;\n\u0026lt;blockquote\u0026gt;\n\u0026lt;p\u0026gt;...all variables found outside of the innermost scope are\nread-only (\u0026lt;em\u0026gt;\u0026lt;strong\u0026gt;an attempt to write to such a variable will simply create a\nnew local variable in the innermost scope, leaving the identically\nnamed outer variable unchanged\u0026lt;/strong\u0026gt;\u0026lt;/em\u0026gt;).\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\u0026lt;p\u0026gt;Look back to the original example and consider the above points:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;def\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;foo\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;a=[]\u0026lt;/span\u0026gt;):\n    a.append(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;5\u0026lt;/span\u0026gt;)\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; a\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;Here \u0026lt;code\u0026gt;foo\u0026lt;/code\u0026gt; is an object and \u0026lt;code\u0026gt;a\u0026lt;/code\u0026gt; is an attribute of \u0026lt;code\u0026gt;foo\u0026lt;/code\u0026gt; (available at \u0026lt;code\u0026gt;foo.func_defs[0]\u0026lt;/code\u0026gt;). Since \u0026lt;code\u0026gt;a\u0026lt;/code\u0026gt; is a list, \u0026lt;code\u0026gt;a\u0026lt;/code\u0026gt; is mutable and is thus a read-write attribute of \u0026lt;code\u0026gt;foo\u0026lt;/code\u0026gt;. It is initialized to the empty list as specified by the signature when the function is instantiated, and is available for reading and writing as long as the function object exists.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Calling \u0026lt;code\u0026gt;foo\u0026lt;/code\u0026gt; without overriding a default uses that default\u0026apos;s value from \u0026lt;code\u0026gt;foo.func_defs\u0026lt;/code\u0026gt;. In this case, \u0026lt;code\u0026gt;foo.func_defs[0]\u0026lt;/code\u0026gt; is used for \u0026lt;code\u0026gt;a\u0026lt;/code\u0026gt; within function object\u0026apos;s code scope. Changes to \u0026lt;code\u0026gt;a\u0026lt;/code\u0026gt; change \u0026lt;code\u0026gt;foo.func_defs[0]\u0026lt;/code\u0026gt;, which is part of the \u0026lt;code\u0026gt;foo\u0026lt;/code\u0026gt; object and persists between execution of the code in \u0026lt;code\u0026gt;foo\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Now, compare this to the example from the documentation on \u0026lt;a href=\u0026quot;http://docs.python.org/tutorial/controlflow.html#default-argument-values\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;emulating the default argument behavior of other languages\u0026lt;/a\u0026gt;, such that the function signature defaults are used every time the function is executed:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;def\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;foo\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;a, L=\u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;None\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;):\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; L \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;is\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;None\u0026lt;/span\u0026gt;:\n        L = []\n    L.append(a)\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; L\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;Taking \u0026lt;strong\u0026gt;(1)\u0026lt;/strong\u0026gt; and \u0026lt;strong\u0026gt;(2)\u0026lt;/strong\u0026gt; into account, one can see why this accomplishes the desired behavior:\u0026lt;/p\u0026gt;\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;When the \u0026lt;code\u0026gt;foo\u0026lt;/code\u0026gt; function object is instantiated, \u0026lt;code\u0026gt;foo.func_defs[0]\u0026lt;/code\u0026gt; is set to \u0026lt;code\u0026gt;None\u0026lt;/code\u0026gt;, an immutable object.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;When the function is executed with defaults (with no parameter specified for \u0026lt;code\u0026gt;L\u0026lt;/code\u0026gt; in the function call), \u0026lt;code\u0026gt;foo.func_defs[0]\u0026lt;/code\u0026gt; (\u0026lt;code\u0026gt;None\u0026lt;/code\u0026gt;) is available in the local scope as \u0026lt;code\u0026gt;L\u0026lt;/code\u0026gt;.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Upon \u0026lt;code\u0026gt;L = []\u0026lt;/code\u0026gt;, the assignment cannot succeed at \u0026lt;code\u0026gt;foo.func_defs[0]\u0026lt;/code\u0026gt;, because that attribute is read-only.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Per \u0026lt;strong\u0026gt;(1)\u0026lt;/strong\u0026gt;, \u0026lt;em\u0026gt;\u0026lt;strong\u0026gt;a new local variable also named \u0026lt;code\u0026gt;L\u0026lt;/code\u0026gt; is created in the local scope\u0026lt;/strong\u0026gt;\u0026lt;/em\u0026gt; and used for the remainder of the function call. \u0026lt;code\u0026gt;foo.func_defs[0]\u0026lt;/code\u0026gt; thus remains unchanged for future invocations of \u0026lt;code\u0026gt;foo\u0026lt;/code\u0026gt;.\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n    ","\n\u0026lt;p\u0026gt;A simple workaround using None\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026amp;gt; \u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;def\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;bar\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;b, data=\u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;None\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;):\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;... \u0026lt;/span\u0026gt;    data = data \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;or\u0026lt;/span\u0026gt; []\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;... \u0026lt;/span\u0026gt;    data.append(b)\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;... \u0026lt;/span\u0026gt;    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; data\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;... \u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026amp;gt; \u0026lt;/span\u0026gt;bar(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3\u0026lt;/span\u0026gt;)\n[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3\u0026lt;/span\u0026gt;]\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026amp;gt; \u0026lt;/span\u0026gt;bar(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3\u0026lt;/span\u0026gt;)\n[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3\u0026lt;/span\u0026gt;]\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026amp;gt; \u0026lt;/span\u0026gt;bar(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3\u0026lt;/span\u0026gt;)\n[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3\u0026lt;/span\u0026gt;]\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026amp;gt; \u0026lt;/span\u0026gt;bar(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3\u0026lt;/span\u0026gt;, [\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;34\u0026lt;/span\u0026gt;])\n[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;34\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3\u0026lt;/span\u0026gt;]\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026amp;gt; \u0026lt;/span\u0026gt;bar(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3\u0026lt;/span\u0026gt;, [\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;34\u0026lt;/span\u0026gt;])\n[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;34\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3\u0026lt;/span\u0026gt;]\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;It may be true that:\u0026lt;/p\u0026gt;\n\n\u0026lt;ol\u0026gt;\n\u0026lt;li\u0026gt;Someone is using every language/library feature, and\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Switching the behavior here would be ill-advised, but\u0026lt;/li\u0026gt;\n\u0026lt;/ol\u0026gt;\n\n\u0026lt;p\u0026gt;it is entirely consistent to hold to both of the features above and still make another point:\u0026lt;/p\u0026gt;\n\n\u0026lt;ol start=\u0026quot;3\u0026quot;\u0026gt;\n\u0026lt;li\u0026gt;It is a confusing feature and it is unfortunate in Python.\u0026lt;/li\u0026gt;\n\u0026lt;/ol\u0026gt;\n\n\u0026lt;p\u0026gt;The other answers, or at least some of them either make points 1 and 2 but not 3, or make point 3 and downplay points 1 and 2. \u0026lt;strong\u0026gt;But all three are true.\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;It may be true that switching horses in midstream here would be asking for significant breakage, and that there could be more problems created by changing Python to intuitively handle Stefano\u0026apos;s opening snippet. And it may be true that someone who knew Python internals well could explain a minefield of consequences. \u0026lt;em\u0026gt;However,\u0026lt;/em\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;The existing behavior is not Pythonic, and Python is successful because very little about the language violates the principle of least astonishment anywhere \u0026lt;em\u0026gt;near\u0026lt;/em\u0026gt; this badly. It is a real problem, whether or not it would be wise to uproot it. It is a design flaw. If you understand the language much better by trying to trace out the behavior, I can say that C++ does all of this and more; you learn a lot by navigating, for instance, subtle pointer errors. But this is not Pythonic: people who care about Python enough to persevere in the face of this behavior are people who are drawn to the language because Python has far fewer surprises than other language. Dabblers and the curious become Pythonistas when they are astonished at how little time it takes to get something working--not because of a design fl--I mean, hidden logic puzzle--that cuts against the intuitions of programmers who are drawn to Python because it \u0026lt;strong\u0026gt;Just Works\u0026lt;/strong\u0026gt;.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;I am going to demonstrate an alternative structure to pass a default list value to a function (it works equally well with dictionaries).  \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;As others have extensively commented, the list parameter is bound to the function when it is defined as opposed to when it is executed.  Because lists and dictionaries are mutable, any alteration to this parameter will affect other calls to this function.  As a result, subsequent calls to the function will receive this shared list which may have been altered by any other calls to the function.  Worse yet, two parameters are using this function\u0026apos;s shared parameter at the same time oblivious to the changes made by the other.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Wrong Method (probably...)\u0026lt;/strong\u0026gt;:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;def\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;foo\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;list_arg=[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;5\u0026lt;/span\u0026gt;]\u0026lt;/span\u0026gt;):\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; list_arg\n\na = foo()\na.append(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;6\u0026lt;/span\u0026gt;)\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026amp;gt; \u0026lt;/span\u0026gt;a\n[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;5\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;6\u0026lt;/span\u0026gt;]\n\nb = foo()\nb.append(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;7\u0026lt;/span\u0026gt;)\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;# The value of 6 appended to variable \u0026apos;a\u0026apos; is now part of the list held by \u0026apos;b\u0026apos;.\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026amp;gt; \u0026lt;/span\u0026gt;b\n[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;5\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;6\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;7\u0026lt;/span\u0026gt;]  \n\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;# Although \u0026apos;a\u0026apos; is expecting to receive 6 (the last element it appended to the list),\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;# it actually receives the last element appended to the shared list.\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;# It thus receives the value 7 previously appended by \u0026apos;b\u0026apos;.\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026amp;gt; \u0026lt;/span\u0026gt;a.pop()             \n\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;7\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;You can verify that they are one and the same object by using \u0026lt;code\u0026gt;id\u0026lt;/code\u0026gt;:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026amp;gt; \u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;id\u0026lt;/span\u0026gt;(a)\n\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;5347866528\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026amp;gt; \u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;id\u0026lt;/span\u0026gt;(b)\n\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;5347866528\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Per Brett Slatkin\u0026apos;s \u0026quot;Effective Python: 59 Specific Ways to Write Better Python\u0026quot;, \u0026lt;em\u0026gt;Item 20: Use \u0026lt;code\u0026gt;None\u0026lt;/code\u0026gt; and Docstrings to specify dynamic default arguments\u0026lt;/em\u0026gt; (p. 48)\u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;The convention for achieving the desired result in Python is to\n  provide a default value of \u0026lt;code\u0026gt;None\u0026lt;/code\u0026gt; and to document the actual behaviour\n  in the docstring.\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;p\u0026gt;This implementation ensures that each call to the function either receives the default list or else the list passed to the function.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Preferred Method\u0026lt;/strong\u0026gt;:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;def\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;foo\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;list_arg=\u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;None\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;):\n   \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;\u0026quot;\u0026quot;\n   :param list_arg:  A list of input values. \n                     If none provided, used a list with a default value of 5.\n   \u0026quot;\u0026quot;\u0026quot;\u0026lt;/span\u0026gt;\n   \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;not\u0026lt;/span\u0026gt; list_arg:\n       list_arg = [\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;5\u0026lt;/span\u0026gt;]\n   \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; list_arg\n\na = foo()\na.append(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;6\u0026lt;/span\u0026gt;)\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026amp;gt; \u0026lt;/span\u0026gt;a\n[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;5\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;6\u0026lt;/span\u0026gt;]\n\nb = foo()\nb.append(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;7\u0026lt;/span\u0026gt;)\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026amp;gt; \u0026lt;/span\u0026gt;b\n[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;5\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;7\u0026lt;/span\u0026gt;]\n\nc = foo([\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;10\u0026lt;/span\u0026gt;])\nc.append(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;11\u0026lt;/span\u0026gt;)\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026amp;gt; \u0026lt;/span\u0026gt;c\n[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;10\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;11\u0026lt;/span\u0026gt;]\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;There may be legitimate use cases for the \u0026apos;Wrong Method\u0026apos; whereby the programmer intended the default list parameter to be shared, but this is more likely the exception than the rule.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;The solutions here are:\u0026lt;/p\u0026gt;\n\n\u0026lt;ol\u0026gt;\n\u0026lt;li\u0026gt;Use \u0026lt;code\u0026gt;None\u0026lt;/code\u0026gt; as your default value (or a nonce \u0026lt;code\u0026gt;object\u0026lt;/code\u0026gt;), and switch on that to create your values at runtime; or\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Use a \u0026lt;code\u0026gt;lambda\u0026lt;/code\u0026gt; as your default parameter, and call it within a try block to get the default value (this is the sort of thing that lambda abstraction is for).\u0026lt;/li\u0026gt;\n\u0026lt;/ol\u0026gt;\n\n\u0026lt;p\u0026gt;The second option is nice because users of the function can pass in a callable, which may be already existing (such as a \u0026lt;code\u0026gt;type\u0026lt;/code\u0026gt;)\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;You can get round this by replacing the object (and therefore the tie with the scope):\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;def\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;foo\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;a=[]\u0026lt;/span\u0026gt;):\n    a = \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;list\u0026lt;/span\u0026gt;(a)\n    a.append(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;5\u0026lt;/span\u0026gt;)\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; a\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Ugly, but it works.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;When we do this:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;def\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;foo\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;a=[]\u0026lt;/span\u0026gt;):\n    ...\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;... we assign the argument \u0026lt;code\u0026gt;a\u0026lt;/code\u0026gt; to an \u0026lt;em\u0026gt;unnamed\u0026lt;/em\u0026gt; list, if the caller does not pass the value of a.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;To make things simpler for this discussion, let\u0026apos;s temporarily give the unnamed list a name. How about \u0026lt;code\u0026gt;pavlo\u0026lt;/code\u0026gt; ?\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;def\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;foo\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;a=pavlo\u0026lt;/span\u0026gt;):\n   ...\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;At any time, if the caller doesn\u0026apos;t tell us what \u0026lt;code\u0026gt;a\u0026lt;/code\u0026gt; is, we reuse \u0026lt;code\u0026gt;pavlo\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;If \u0026lt;code\u0026gt;pavlo\u0026lt;/code\u0026gt; is mutable (modifiable), and \u0026lt;code\u0026gt;foo\u0026lt;/code\u0026gt; ends up modifying it, an effect we notice the next time \u0026lt;code\u0026gt;foo\u0026lt;/code\u0026gt; is called without specifying \u0026lt;code\u0026gt;a\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;So this is what you see (Remember, \u0026lt;code\u0026gt;pavlo\u0026lt;/code\u0026gt; is initialized to []):\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt; \u0026amp;gt;\u0026amp;gt;\u0026amp;gt; foo()\n [\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;5\u0026lt;/span\u0026gt;]\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Now, \u0026lt;code\u0026gt;pavlo\u0026lt;/code\u0026gt; is [5].\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Calling \u0026lt;code\u0026gt;foo()\u0026lt;/code\u0026gt; again modifies \u0026lt;code\u0026gt;pavlo\u0026lt;/code\u0026gt; again:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026amp;gt; \u0026lt;/span\u0026gt;foo()\n[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;5\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;5\u0026lt;/span\u0026gt;]\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Specifying \u0026lt;code\u0026gt;a\u0026lt;/code\u0026gt; when calling \u0026lt;code\u0026gt;foo()\u0026lt;/code\u0026gt; ensures \u0026lt;code\u0026gt;pavlo\u0026lt;/code\u0026gt; is not touched.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026amp;gt; \u0026lt;/span\u0026gt;ivan = [\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;4\u0026lt;/span\u0026gt;]\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026amp;gt; \u0026lt;/span\u0026gt;foo(a=ivan)\n[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;4\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;5\u0026lt;/span\u0026gt;]\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026amp;gt; \u0026lt;/span\u0026gt;ivan\n[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;4\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;5\u0026lt;/span\u0026gt;]\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;So, \u0026lt;code\u0026gt;pavlo\u0026lt;/code\u0026gt; is still \u0026lt;code\u0026gt;[5, 5]\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026amp;gt; \u0026lt;/span\u0026gt;foo()\n[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;5\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;5\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;5\u0026lt;/span\u0026gt;]\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;I sometimes exploit this behavior as an alternative to the following pattern:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;singleton = \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;None\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;def\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;use_singleton\u0026lt;/span\u0026gt;():\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;global\u0026lt;/span\u0026gt; singleton\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; singleton \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;is\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;None\u0026lt;/span\u0026gt;:\n        singleton = _make_singleton()\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; singleton.use_me()\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;If \u0026lt;code\u0026gt;singleton\u0026lt;/code\u0026gt; is only used by \u0026lt;code\u0026gt;use_singleton\u0026lt;/code\u0026gt;, I like the following pattern as a replacement:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;# _make_singleton() is called only once when the def is executed\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;def\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;use_singleton\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;singleton=_make_singleton(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;)\u0026lt;/span\u0026gt;):\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; singleton.use_me()\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;I\u0026apos;ve used this for instantiating client classes that access external resources, and also for creating dicts or lists for memoization.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Since I don\u0026apos;t think this pattern is well known, I do put a short comment in to guard against future misunderstandings.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Every other answer explains why this is actually a nice and desired behavior, or why you shouldn\u0026apos;t be needing this anyway. Mine is for those stubborn ones who want to exercise their right to bend the language to their will, not the other way around.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;We will \u0026quot;fix\u0026quot; this behavior with a decorator that will copy the default value instead of reusing the same instance for each positional argument left at its default value.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;import\u0026lt;/span\u0026gt; inspect\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;from\u0026lt;/span\u0026gt; copy \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;import\u0026lt;/span\u0026gt; deepcopy  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;# copy would fail on deep arguments like nested dicts\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;def\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;sanify\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt;):\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;def\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;wrapper\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;*a, **kw\u0026lt;/span\u0026gt;):\n        \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;# store the default values\u0026lt;/span\u0026gt;\n        defaults = inspect.getargspec(function).defaults \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;# for python2\u0026lt;/span\u0026gt;\n        \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;# construct a new argument list\u0026lt;/span\u0026gt;\n        new_args = []\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt; i, arg \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;in\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;enumerate\u0026lt;/span\u0026gt;(defaults):\n            \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;# allow passing positional arguments\u0026lt;/span\u0026gt;\n            \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; i \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;in\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;range\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;len\u0026lt;/span\u0026gt;(a)):\n                new_args.append(a[i])\n            \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;else\u0026lt;/span\u0026gt;:\n                \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;# copy the value\u0026lt;/span\u0026gt;\n                new_args.append(deepcopy(arg))\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; function(*new_args, **kw)\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; wrapper\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;Now let\u0026apos;s redefine our function using this decorator:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;@sanify\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;def\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;foo\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;a=[]\u0026lt;/span\u0026gt;):\n    a.append(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;5\u0026lt;/span\u0026gt;)\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; a\n\nfoo() \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;# \u0026apos;[5]\u0026apos;\u0026lt;/span\u0026gt;\nfoo() \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;# \u0026apos;[5]\u0026apos; -- as desired\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;This is particularly neat for functions that take multiple arguments. Compare:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;# the \u0026apos;correct\u0026apos; approach\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;def\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;bar\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;a=\u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;None\u0026lt;/span\u0026gt;, b=\u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;None\u0026lt;/span\u0026gt;, c=\u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;None\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;):\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; a \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;is\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;None\u0026lt;/span\u0026gt;:\n        a = []\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; b \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;is\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;None\u0026lt;/span\u0026gt;:\n        b = []\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; c \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;is\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;None\u0026lt;/span\u0026gt;:\n        c = []\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;# finally do the actual work\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;with\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;# the nasty decorator hack\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;@sanify\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;def\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;bar\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;a=[], b=[], c=[]\u0026lt;/span\u0026gt;):\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;# wow, works right out of the box!\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;It\u0026apos;s important to note that the above solution breaks if you try to use keyword args, like so:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;foo(a=[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;4\u0026lt;/span\u0026gt;])\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;The decorator could be adjusted to allow for that, but we leave this as an exercise for the reader ;)\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;This \u0026quot;bug\u0026quot; gave me a lot of overtime work hours! But I\u0026apos;m beginning to see a potential use of it (but I would have liked it to be at the execution time, still)\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;I\u0026apos;m gonna give you what I see as a useful example.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;def\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;example\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;errors=[]\u0026lt;/span\u0026gt;):\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;# statements\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;# Something went wrong\u0026lt;/span\u0026gt;\n    mistake = \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;True\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; mistake:\n        tryToFixIt(errors)\n        \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;# Didn\u0026apos;t work.. let\u0026apos;s try again\u0026lt;/span\u0026gt;\n        tryToFixItAnotherway(errors)\n        \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;# This time it worked\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; errors\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;def\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;tryToFixIt\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;err\u0026lt;/span\u0026gt;):\n    err.append(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;Attempt to fix it\u0026apos;\u0026lt;/span\u0026gt;)\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;def\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;tryToFixItAnotherway\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;err\u0026lt;/span\u0026gt;):\n    err.append(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;Attempt to fix it by another way\u0026apos;\u0026lt;/span\u0026gt;)\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;def\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;main\u0026lt;/span\u0026gt;():\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt; item \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;in\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;range\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;):\n        errors = example()\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;\\n\u0026apos;\u0026lt;/span\u0026gt;.join(errors)\n\nmain()\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;prints the following\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;Attempt to fix it\nAttempt to fix it by another way\nAttempt to fix it\nAttempt to fix it by another way\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;\u0026lt;em\u0026gt;This is not a design flaw\u0026lt;/em\u0026gt;. Anyone who trips over this is doing something wrong.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;There are 3 cases I see where you might run into this problem:\u0026lt;/p\u0026gt;\n\n\u0026lt;ol\u0026gt;\n\u0026lt;li\u0026gt;You intend to modify the argument as a side effect of the function. In this case it \u0026lt;em\u0026gt;never makes sense\u0026lt;/em\u0026gt; to have a default argument. The only exception is when you\u0026apos;re abusing the argument list to have function attributes, e.g. \u0026lt;code\u0026gt;cache={}\u0026lt;/code\u0026gt;, and you wouldn\u0026apos;t be expected to call the function with an actual argument at all.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;You intend to leave the argument unmodified, but you accidentally \u0026lt;em\u0026gt;did\u0026lt;/em\u0026gt; modify it. That\u0026apos;s a bug, fix it.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;You intend to modify the argument for use inside the function, but didn\u0026apos;t expect the modification to be viewable outside of the function. In that case you need to make a \u0026lt;em\u0026gt;copy\u0026lt;/em\u0026gt; of the argument, whether it was the default or not! Python is not a call-by-value language so it doesn\u0026apos;t make the copy for you, you need to be explicit about it.\u0026lt;/li\u0026gt;\n\u0026lt;/ol\u0026gt;\n\n\u0026lt;p\u0026gt;The example in the question could fall into category 1 or 3. It\u0026apos;s odd that it both modifies the passed list and returns it; you should pick one or the other.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Just change the function to be:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;def\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;notastonishinganymore\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;a = []\u0026lt;/span\u0026gt;): \n    \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;\u0026apos;\u0026apos;The name is just a joke :)\u0026apos;\u0026apos;\u0026apos;\u0026lt;/span\u0026gt;\n    a = a[:]\n    a.append(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;5\u0026lt;/span\u0026gt;)\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; a\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;TLDR: Define-time defaults are consistent and strictly more expressive.\u0026lt;/p\u0026gt;\n\n\u0026lt;hr\u0026gt;\n\n\u0026lt;p\u0026gt;Defining a function affects two scopes: the defining scope \u0026lt;em\u0026gt;containing\u0026lt;/em\u0026gt; the function, and the execution  scope \u0026lt;em\u0026gt;contained by\u0026lt;/em\u0026gt; the function. While it is pretty clear how blocks map to scopes, the question is where \u0026lt;code\u0026gt;def \u0026amp;lt;name\u0026amp;gt;(\u0026amp;lt;args=defaults\u0026amp;gt;):\u0026lt;/code\u0026gt; belongs to:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;... \u0026lt;/span\u0026gt;                          \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;# defining scope\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;def\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;name\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;parameter=default\u0026lt;/span\u0026gt;):  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;# ???\u0026lt;/span\u0026gt;\n    ...                       \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;# execution scope\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;The \u0026lt;code\u0026gt;def name\u0026lt;/code\u0026gt; part \u0026lt;strong\u0026gt;must\u0026lt;/strong\u0026gt; evaluate in the defining scope - we want \u0026lt;code\u0026gt;name\u0026lt;/code\u0026gt; to be available there, after all. Evaluating the function only inside itself would make it inaccessible.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Since \u0026lt;code\u0026gt;parameter\u0026lt;/code\u0026gt; is a constant name, we can \u0026quot;evaluate\u0026quot; it at the same time as \u0026lt;code\u0026gt;def name\u0026lt;/code\u0026gt;. This also has the advantage it produces the function with a known signature as \u0026lt;code\u0026gt;name(parameter=...):\u0026lt;/code\u0026gt;, instead of a bare \u0026lt;code\u0026gt;name(...):\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Now, when to evaluate \u0026lt;code\u0026gt;default\u0026lt;/code\u0026gt;?\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Consistency already says \u0026quot;at definition\u0026quot;: everything else of \u0026lt;code\u0026gt;def \u0026amp;lt;name\u0026amp;gt;(\u0026amp;lt;args=defaults\u0026amp;gt;):\u0026lt;/code\u0026gt; is best evaluated at definition as well. Delaying parts of it would be the astonishing choice.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;The two choices are not equivalent, either: If \u0026lt;code\u0026gt;default\u0026lt;/code\u0026gt; is evaluated at definition time, it \u0026lt;em\u0026gt;can still\u0026lt;/em\u0026gt; affect execution time. If \u0026lt;code\u0026gt;default\u0026lt;/code\u0026gt; is evaluated at execution time, it \u0026lt;em\u0026gt;cannot\u0026lt;/em\u0026gt; affect definition time. Choosing \u0026quot;at definition\u0026quot; allows expressing both cases, while choosing \u0026quot;at execution\u0026quot; can express only one:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;def\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;name\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;parameter=defined\u0026lt;/span\u0026gt;):  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;# set default at definition time\u0026lt;/span\u0026gt;\n    ...\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;def\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;name\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;parameter=default\u0026lt;/span\u0026gt;):     \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;# delay default until execution time\u0026lt;/span\u0026gt;\n    parameter = default \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; parameter \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;is\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;None\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;else\u0026lt;/span\u0026gt; parameter\n    ...\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;I think the answer to this question lies in how python pass data to parameter (pass by value or by reference), not mutability or how python handle the \u0026quot;def\u0026quot; statement.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;A brief introduction. First, there are two type of data types in python, one is simple elementary data type, like numbers, and another data type is objects. Second, when passing data to parameters, python pass elementary data type by value, i.e., make a local copy of the value to a local variable, but pass object by reference, i.e., pointers to the object.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Admitting the above two points, let\u0026apos;s explain what happened to the python code. It\u0026apos;s only because of passing by reference for objects, but has nothing to do with mutable/immutable, or arguably the fact that \u0026quot;def\u0026quot; statement is executed only once when it is defined.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;[] is an object, so python pass the reference of [] to \u0026lt;code\u0026gt;a\u0026lt;/code\u0026gt;, i.e., \u0026lt;code\u0026gt;a\u0026lt;/code\u0026gt; is only a pointer to [] which lies in memory as an object. There is only one copy of [] with, however, many references to it. For the first foo(), the list [] is changed to \u0026lt;a href=\u0026quot;http://effbot.org/zone/default-values.htm\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;1\u0026lt;/a\u0026gt; by append method. But Note that there is only one copy of the list object and this object now becomes \u0026lt;a href=\u0026quot;http://effbot.org/zone/default-values.htm\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;1\u0026lt;/a\u0026gt;. When running the second foo(), what effbot webpage says (items is not evaluated any more) is wrong. \u0026lt;code\u0026gt;a\u0026lt;/code\u0026gt; is evaluated to be the list object, although now the content of the object is \u0026lt;a href=\u0026quot;http://effbot.org/zone/default-values.htm\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;1\u0026lt;/a\u0026gt;. This is the effect of passing by reference! The result of foo(3) can be easily derived in the same way.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;To further validate my answer, let\u0026apos;s take a look at two additional codes.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;====== No. 2 ========\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;def\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;foo\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;x, items=\u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;None\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;):\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; items \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;is\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;None\u0026lt;/span\u0026gt;:\n        items = []\n    items.append(x)\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; items\n\nfoo(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;)  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;#return [1]\u0026lt;/span\u0026gt;\nfoo(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;)  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;#return [2]\u0026lt;/span\u0026gt;\nfoo(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3\u0026lt;/span\u0026gt;)  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;#return [3]\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;code\u0026gt;[]\u0026lt;/code\u0026gt; is an object, so is \u0026lt;code\u0026gt;None\u0026lt;/code\u0026gt; (the former is mutable while the latter is immutable. But the mutability has nothing to do with the question). None is somewhere in the space but we know it\u0026apos;s there and there is only one copy of None there. So every time foo is invoked, items is evaluated (as opposed to some answer that it is only evaluated once) to be None, to be clear, the reference (or the address) of None. Then in the foo, item is changed to [], i.e., points to another object which has a different address. \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;====== No. 3 =======\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;def\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;foo\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;x, items=[]\u0026lt;/span\u0026gt;):\n    items.append(x)\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; items\n\nfoo(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;)    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;# returns [1]\u0026lt;/span\u0026gt;\nfoo(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;,[]) \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;# returns [2]\u0026lt;/span\u0026gt;\nfoo(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3\u0026lt;/span\u0026gt;)    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;# returns [1,3]\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;The invocation of foo(1) make items point to a list object [] with an address, say, 11111111. the content of the list is changed to \u0026lt;a href=\u0026quot;http://effbot.org/zone/default-values.htm\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;1\u0026lt;/a\u0026gt; in the foo function in the sequel, but the address is not changed, still 11111111. Then foo(2,[]) is coming. Although the [] in foo(2,[]) has the same content as the default parameter [] when calling foo(1), their address are different! Since we provide the parameter explicitly, \u0026lt;code\u0026gt;items\u0026lt;/code\u0026gt; has to take the address of this new \u0026lt;code\u0026gt;[]\u0026lt;/code\u0026gt;, say 2222222, and return it after making some change. Now foo(3) is executed. since only \u0026lt;code\u0026gt;x\u0026lt;/code\u0026gt; is provided, items has to take its default value again. What\u0026apos;s the default value? It is set when defining the foo function: the list object located in 11111111. So the items is evaluated to be the address 11111111 having an element 1. The list located at 2222222 also contains one element 2, but it is not pointed by items any more. Consequently, An append of 3 will make \u0026lt;code\u0026gt;items\u0026lt;/code\u0026gt; [1,3]. \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;From the above explanations, we can see that the \u0026lt;a href=\u0026quot;http://effbot.org/zone/default-values.htm\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;effbot\u0026lt;/a\u0026gt; webpage recommended in the accepted answer failed to give a relevant answer to this question. What is more, I think a point in the effbot webpage is wrong. I think the code regarding the UI.Button is correct:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt; i \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;in\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;range\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;10\u0026lt;/span\u0026gt;):\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;def\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;callback\u0026lt;/span\u0026gt;():\n        \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;clicked button\u0026quot;\u0026lt;/span\u0026gt;, i\n    UI.Button(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;button %s\u0026quot;\u0026lt;/span\u0026gt; % i, callback)\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Each button can hold a distinct callback function which will display different value of \u0026lt;code\u0026gt;i\u0026lt;/code\u0026gt;. I can provide an example to show this:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;x=[]\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt; i \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;in\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;range\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;10\u0026lt;/span\u0026gt;):\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;def\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;callback\u0026lt;/span\u0026gt;():\n        \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt;(i)\n    x.append(callback) \n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;If we execute \u0026lt;code\u0026gt;x[7]()\u0026lt;/code\u0026gt; we\u0026apos;ll get 7 as expected, and \u0026lt;code\u0026gt;x[9]()\u0026lt;/code\u0026gt; will gives 9, another value of \u0026lt;code\u0026gt;i\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n    "],"id":51,"title":"\"Least Astonishment\" and the Mutable Default Argument","content":"\n                \n\u0026lt;p\u0026gt;Anyone tinkering with Python long enough has been bitten (or torn to pieces) by the following issue:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;def\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;foo\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;a=[]\u0026lt;/span\u0026gt;):\n    a.append(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;5\u0026lt;/span\u0026gt;)\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; a\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;Python novices would expect this function to always return a list with only one element: \u0026lt;code\u0026gt;[5]\u0026lt;/code\u0026gt;. The result is instead very different, and very astonishing (for a novice):\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026amp;gt; \u0026lt;/span\u0026gt;foo()\n[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;5\u0026lt;/span\u0026gt;]\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026amp;gt; \u0026lt;/span\u0026gt;foo()\n[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;5\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;5\u0026lt;/span\u0026gt;]\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026amp;gt; \u0026lt;/span\u0026gt;foo()\n[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;5\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;5\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;5\u0026lt;/span\u0026gt;]\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026amp;gt; \u0026lt;/span\u0026gt;foo()\n[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;5\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;5\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;5\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;5\u0026lt;/span\u0026gt;]\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026amp;gt; \u0026lt;/span\u0026gt;foo()\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;A manager of mine once had his first encounter with this feature, and called it \u0026quot;a dramatic design flaw\u0026quot; of the language. I replied that the behavior had an underlying explanation, and it is indeed very puzzling and unexpected if you don\u0026apos;t understand the internals. However, I was not able to answer (to myself) the following question: what is the reason for binding the default argument at function definition, and not at function execution? I doubt the experienced behavior has a practical use (who really used static variables in C, without breeding bugs?)\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Edit\u0026lt;/strong\u0026gt;:\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;a href=\u0026quot;https://stackoverflow.com/a/1137164/7487335\u0026quot;\u0026gt;Baczek made an interesting example\u0026lt;/a\u0026gt;. Together with most of your comments and \u0026lt;a href=\u0026quot;https://stackoverflow.com/a/1134623/7487335\u0026quot;\u0026gt;Utaal\u0026apos;s in particular\u0026lt;/a\u0026gt;, I elaborated further:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026amp;gt; \u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;def\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;a\u0026lt;/span\u0026gt;():\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;... \u0026lt;/span\u0026gt;    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;a executed\u0026quot;\u0026lt;/span\u0026gt;)\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;... \u0026lt;/span\u0026gt;    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; []\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;... \u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026amp;gt; \u0026lt;/span\u0026gt;           \n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026amp;gt; \u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;def\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;b\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;x=a(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;)\u0026lt;/span\u0026gt;):\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;... \u0026lt;/span\u0026gt;    x.append(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;5\u0026lt;/span\u0026gt;)\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;... \u0026lt;/span\u0026gt;    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt;(x)\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;... \u0026lt;/span\u0026gt;\na executed\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026amp;gt; \u0026lt;/span\u0026gt;b()\n[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;5\u0026lt;/span\u0026gt;]\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026amp;gt; \u0026lt;/span\u0026gt;b()\n[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;5\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;5\u0026lt;/span\u0026gt;]\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;To me, it seems that the design decision was relative to where to put the scope of parameters: inside the function, or \u0026quot;together\u0026quot; with it?\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Doing the binding inside the function would mean that \u0026lt;code\u0026gt;x\u0026lt;/code\u0026gt; is effectively bound to the specified default when the function is called, not defined, something that would present a deep flaw: the \u0026lt;code\u0026gt;def\u0026lt;/code\u0026gt; line would be \u0026quot;hybrid\u0026quot; in the sense that part of the binding (of the function object) would happen at definition, and part (assignment of default parameters) at function invocation time.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;The actual behavior is more consistent: everything of that line gets evaluated when that line is executed, meaning at function definition.\u0026lt;/p\u0026gt;\n    ","slug":"\"least-astonishment\"-and-the-mutable-default-argument-1657384412508","postType":"QUESTION","createdAt":"2022-07-09T16:33:32.000Z","updatedAt":"2022-07-09T16:33:32.000Z","tags":[{"id":179,"name":"language-design","slug":"language-design","createdAt":"2022-07-09T16:33:32.000Z","updatedAt":"2022-07-09T16:33:32.000Z","Questions_Tags":{"questionId":51,"tagId":179}},{"id":181,"name":"default-parameters","slug":"default-parameters","createdAt":"2022-07-09T16:33:32.000Z","updatedAt":"2022-07-09T16:33:32.000Z","Questions_Tags":{"questionId":51,"tagId":181}},{"id":182,"name":"least-astonishment","slug":"least-astonishment","createdAt":"2022-07-09T16:33:32.000Z","updatedAt":"2022-07-09T16:33:32.000Z","Questions_Tags":{"questionId":51,"tagId":182}}],"relatedQuestions":[{"title":"\"Least Astonishment\" and the Mutable Default Argument","slug":"\"least-astonishment\"-and-the-mutable-default-argument-1657384412508","tags":[{"name":"language-design","Questions_Tags":{"questionId":51,"tagId":179}},{"name":"default-parameters","Questions_Tags":{"questionId":51,"tagId":181}},{"name":"least-astonishment","Questions_Tags":{"questionId":51,"tagId":182}}]}]},"randomQuestions":[{"title":"Get the data received in a Flask request","slug":"get-the-data-received-in-a-flask-request-1657387804432"},{"title":"Parameterize an SQL IN clause","slug":"parameterize-an-sql-in-clause-1657387536064"},{"title":"How to sum a variable by group","slug":"how-to-sum-a-variable-by-group-1657384838148"},{"title":"How to create a generic array in Java?","slug":"how-to-create-a-generic-array-in-java-1657387532298"},{"title":"How can I remove a specific item from an array?","slug":"how-can-i-remove-a-specific-item-from-an-array-1657387552077"},{"title":"Javascript infamous Loop issue? [duplicate]","slug":"javascript-infamous-loop-issue-duplicate-1657387498530"},{"title":"What is a raw type and why shouldn't we use it?","slug":"what-is-a-raw-type-and-why-shouldn't-we-use-it-1657384481079"},{"title":"How do I make a flat list out of a list of lists?","slug":"how-do-i-make-a-flat-list-out-of-a-list-of-lists-1657384500439"},{"title":"event.preventDefault() vs. return false","slug":"event.preventdefault()-vs.-return-false-1657387458377"},{"title":"What is a clearfix?","slug":"what-is-a-clearfix-1657387337825"},{"title":"Why can't an element with a z-index value cover its child?","slug":"why-can't-an-element-with-a-z-index-value-cover-its-child-1657387707187"},{"title":"Syntax error due to using a reserved word as a table or column name in MySQL","slug":"syntax-error-due-to-using-a-reserved-word-as-a-table-or-column-name-in-mysql-1657384689274"},{"title":"What is the scope of variables in JavaScript?","slug":"what-is-the-scope-of-variables-in-javascript-1657384464291"},{"title":"Why is the gets function so dangerous that it should not be used?","slug":"why-is-the-gets-function-so-dangerous-that-it-should-not-be-used-1657384544362"},{"title":"What is the difference between public, protected, package-private and private in Java?","slug":"what-is-the-difference-between-public-protected-package-private-and-private-in-java-1657387376262"},{"title":"Default constructor with empty brackets","slug":"default-constructor-with-empty-brackets-1657388246967"},{"title":"Safely turning a JSON string into an object","slug":"safely-turning-a-json-string-into-an-object-1657388194824"},{"title":"Transitions on the CSS display property","slug":"transitions-on-the-css-display-property-1657387761601"},{"title":"Why does the order in which libraries are linked sometimes cause errors in GCC?","slug":"why-does-the-order-in-which-libraries-are-linked-sometimes-cause-errors-in-gcc-1657387609554"},{"title":"srand()  why call it only once?","slug":"srand()-why-call-it-only-once-1657387794760"}]},"__N_SSG":true},"page":"/questions/[slug]","query":{"slug":"\"least-astonishment\"-and-the-mutable-default-argument-1657384412508"},"buildId":"00bsHgHZki2FteshOatnd","isFallback":false,"gsp":true,"locale":"en","locales":["en"],"defaultLocale":"en","scriptLoader":[]}</script></body></html>