<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><meta name="twitter:card" content="summary_large_image"/><meta name="twitter:site" content="@solutionschecker.com"/><meta name="twitter:creator" content="@solutionschecker.com"/><meta property="og:url" content="https://solutionschecker.com"/><meta property="og:type" content="website"/><meta property="og:image" content="https://solutionschecker.com/solutions-checker-banner.png"/><meta property="og:image:alt" content="Find the solution to any question. We focus on finding the fastest possible solution for users. Main topics like coding, learning. - solutionschecker.com"/><link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png"/><link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png"/><link rel="manifest" href="/site.webmanifest"/><script type="application/ld+json">{"@context":"https://schema.org","@type":"Organization","logo":"/logo.svg","url":"https://solutionschecker.com"}</script><link name="keywords" content="solutions checker, solution checker, how to, solution for, check for solution, resolve question, what is, what solution for, find solution"/><script type="application/ld+json">{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"item":{"@id":"https://solutionschecker.com","name":"Home"}},{"@type":"ListItem","position":2,"item":{"@id":"https://solutionschecker.com/questions","name":"Questions"}},{"@type":"ListItem","position":3,"item":{"@id":"https://solutionschecker.com/questions/sort-a-maplesskey-valuegreater-by-values-1657387443904","name":"Questions"}}]}</script><title>Sort a Map&lt;Key, Value&gt; by values | Solution Checker</title><meta name="robots" content="index,follow"/><meta name="description" content="I am relatively new to Java, and often find that I need to sort a Map&lt;Key, Value&gt; on the values.

Since the values are not unique, I find myself converting the keySet into an array, and sorting that array through array sort with a custom comparator that sorts on the value associated with the key.

Is there an easier way?
    "/><meta property="og:title" content="Sort a Map&lt;Key, Value&gt; by values | Solution Checker"/><meta property="og:description" content="I am relatively new to Java, and often find that I need to sort a Map&lt;Key, Value&gt; on the values.

Since the values are not unique, I find myself converting the keySet into an array, and sorting that array through array sort with a custom comparator that sorts on the value associated with the key.

Is there an easier way?
    "/><script type="application/ld+json">{"@context":"https://schema.org","@type":"QAPage","mainEntity":{"name":"Sort a Map&lt;Key, Value&gt; by values","text":"I am relatively new to Java, and often find that I need to sort a Map&lt;Key, Value&gt; on the values.\n\nSince the values are not unique, I find myself converting the keySet into an array, and sorting that array through array sort with a custom comparator that sorts on the value associated with the key.\n\nIs there an easier way?\n    ","answerCount":30,"upVoteCount":500,"suggestedAnswer":[{"text":"Here&apos;s a generic-friendly version:\n\npublic class MapUtil {\n    public static &lt;K, V extends Comparable&lt;? super V&gt;&gt; Map&lt;K, V&gt; sortByValue(Map&lt;K, V&gt; map) {\n        List&lt;Entry&lt;K, V&gt;&gt; list = new ArrayList&lt;&gt;(map.entrySet());\n        list.sort(Entry.comparingByValue());\n\n        Map&lt;K, V&gt; result = new LinkedHashMap&lt;&gt;();\n        for (Entry&lt;K, V&gt; entry : list) {\n            result.put(entry.getKey(), entry.getValue());\n        }\n\n        return result;\n    }\n}\n\n    ","url":"/questions/[slug]#solution1","@type":"Answer","upvoteCount":0},{"text":"Important note:\nThis code can break in multiple ways. If you intend to use the code provided, be sure to read the comments as well to be aware of the implications. For example, values can no longer be retrieved by their key. (get always returns null.)\n\nIt seems much easier than all of the foregoing. Use a TreeMap as follows:\npublic class Testing {\n    public static void main(String[] args) {\n        HashMap&lt;String, Double&gt; map = new HashMap&lt;String, Double&gt;();\n        ValueComparator bvc = new ValueComparator(map);\n        TreeMap&lt;String, Double&gt; sorted_map = new TreeMap&lt;String, Double&gt;(bvc);\n\n        map.put(&quot;A&quot;, 99.5);\n        map.put(&quot;B&quot;, 67.4);\n        map.put(&quot;C&quot;, 67.4);\n        map.put(&quot;D&quot;, 67.3);\n\n        System.out.println(&quot;unsorted map: &quot; + map);\n        sorted_map.putAll(map);\n        System.out.println(&quot;results: &quot; + sorted_map);\n    }\n}\n\nclass ValueComparator implements Comparator&lt;String&gt; {\n    Map&lt;String, Double&gt; base;\n\n    public ValueComparator(Map&lt;String, Double&gt; base) {\n        this.base = base;\n    }\n\n    // Note: this comparator imposes orderings that are inconsistent with\n    // equals.\n    public int compare(String a, String b) {\n        if (base.get(a) &gt;= base.get(b)) {\n            return -1;\n        } else {\n            return 1;\n        } // returning 0 would merge keys\n    }\n}\n\nOutput:\nunsorted map: {D=67.3, A=99.5, B=67.4, C=67.4}\nresults: {D=67.3, B=67.4, C=67.4, A=99.5}\n\n    ","url":"/questions/[slug]#solution2","@type":"Answer","upvoteCount":0},{"text":"Java 8 offers a new answer: convert the entries into a stream, and use the comparator combinators from Map.Entry:\nStream&lt;Map.Entry&lt;K,V&gt;&gt; sorted =\n    map.entrySet().stream()\n       .sorted(Map.Entry.comparingByValue());\n\nThis will let you consume the entries sorted in ascending order of value.  If you want descending value, simply reverse the comparator:\nStream&lt;Map.Entry&lt;K,V&gt;&gt; sorted =\n    map.entrySet().stream()\n       .sorted(Collections.reverseOrder(Map.Entry.comparingByValue()));\n\nIf the values are not comparable, you can pass an explicit comparator:\nStream&lt;Map.Entry&lt;K,V&gt;&gt; sorted =\n    map.entrySet().stream()\n       .sorted(Map.Entry.comparingByValue(comparator));\n\nYou can then proceed to use other stream operations to consume the data. For example, if you want the top 10 in a new map:\nMap&lt;K,V&gt; topTen =\n    map.entrySet().stream()\n       .sorted(Map.Entry.comparingByValue(Comparator.reverseOrder()))\n       .limit(10)\n       .collect(Collectors.toMap(\n          Map.Entry::getKey, Map.Entry::getValue, (e1, e2) -&gt; e1, LinkedHashMap::new));\n\nThe LinkedHashMap seen above iterates entries in the order in which they were inserted.\nOr print to System.out:\nmap.entrySet().stream()\n   .sorted(Map.Entry.comparingByValue())\n   .forEach(System.out::println);\n\n    ","url":"/questions/[slug]#solution3","@type":"Answer","upvoteCount":0},{"text":"Three 1-line answers...\n\nI would use Google Collections Guava to do this - if your values are Comparable then you can use\n\nvalueComparator = Ordering.natural().onResultOf(Functions.forMap(map))\n\n\nWhich will create a function (object) for the map [that takes any of the keys as input, returning the respective value], and then apply natural (comparable) ordering to them [the values].\n\nIf they&apos;re not comparable, then you&apos;ll need to do something along the lines of\n\nvalueComparator = Ordering.from(comparator).onResultOf(Functions.forMap(map)) \n\n\nThese may be applied to a TreeMap (as Ordering extends Comparator), or a LinkedHashMap after some sorting\n\nNB: If you are going to use a TreeMap, remember that if a comparison == 0, then the item is already in the list (which will happen if you have multiple values that compare the same).  To alleviate this, you could add your key to the comparator like so (presuming that your keys and values are Comparable):\n\nvalueComparator = Ordering.natural().onResultOf(Functions.forMap(map)).compound(Ordering.natural())\n\n\n= Apply natural ordering to the value mapped by the key, and compound that with the natural ordering of the key\n\nNote that this will still not work if your keys compare to 0, but this should be sufficient for most comparable items (as hashCode, equals and compareTo are often in sync...)\n\nSee Ordering.onResultOf() and Functions.forMap().\n\nImplementation\n\nSo now that we&apos;ve got a comparator that does what we want, we need to get a result from it. \n\nmap = ImmutableSortedMap.copyOf(myOriginalMap, valueComparator);\n\n\nNow this will most likely work work, but:\n\n\nneeds to be done given a complete finished map\nDon&apos;t try the comparators above on a TreeMap; there&apos;s no point trying to compare an inserted key when it doesn&apos;t have a value until after the put, i.e., it will break really fast\n\n\nPoint 1 is a bit of a deal-breaker for me; google collections is incredibly lazy (which is good: you can do pretty much every operation in an instant; the real work is done when you start using the result), and this requires copying a whole map!\n\n&quot;Full&quot; answer/Live sorted map by values\n\nDon&apos;t worry though; if you were obsessed enough with having a &quot;live&quot; map sorted in this manner, you could solve not one but both(!) of the above issues with something crazy like the following:\n\nNote: This has changed significantly in June 2012 - the previous code could never work: an internal HashMap is required to lookup the values without creating an infinite loop between the TreeMap.get() -&gt; compare() and compare() -&gt; get()\n\nimport static org.junit.Assert.assertEquals;\n\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.TreeMap;\n\nimport com.google.common.base.Functions;\nimport com.google.common.collect.Ordering;\n\nclass ValueComparableMap&lt;K extends Comparable&lt;K&gt;,V&gt; extends TreeMap&lt;K,V&gt; {\n    //A map for doing lookups on the keys for comparison so we don&apos;t get infinite loops\n    private final Map&lt;K, V&gt; valueMap;\n\n    ValueComparableMap(final Ordering&lt;? super V&gt; partialValueOrdering) {\n        this(partialValueOrdering, new HashMap&lt;K,V&gt;());\n    }\n\n    private ValueComparableMap(Ordering&lt;? super V&gt; partialValueOrdering,\n            HashMap&lt;K, V&gt; valueMap) {\n        super(partialValueOrdering //Apply the value ordering\n                .onResultOf(Functions.forMap(valueMap)) //On the result of getting the value for the key from the map\n                .compound(Ordering.natural())); //as well as ensuring that the keys don&apos;t get clobbered\n        this.valueMap = valueMap;\n    }\n\n    public V put(K k, V v) {\n        if (valueMap.containsKey(k)){\n            //remove the key in the sorted set before adding the key again\n            remove(k);\n        }\n        valueMap.put(k,v); //To get &quot;real&quot; unsorted values for the comparator\n        return super.put(k, v); //Put it in value order\n    }\n\n    public static void main(String[] args){\n        TreeMap&lt;String, Integer&gt; map = new ValueComparableMap&lt;String, Integer&gt;(Ordering.natural());\n        map.put(&quot;a&quot;, 5);\n        map.put(&quot;b&quot;, 1);\n        map.put(&quot;c&quot;, 3);\n        assertEquals(&quot;b&quot;,map.firstKey());\n        assertEquals(&quot;a&quot;,map.lastKey());\n        map.put(&quot;d&quot;,0);\n        assertEquals(&quot;d&quot;,map.firstKey());\n        //ensure it&apos;s still a map (by overwriting a key, but with a new value) \n        map.put(&quot;d&quot;, 2);\n        assertEquals(&quot;b&quot;, map.firstKey());\n        //Ensure multiple values do not clobber keys\n        map.put(&quot;e&quot;, 2);\n        assertEquals(5, map.size());\n        assertEquals(2, (int) map.get(&quot;e&quot;));\n        assertEquals(2, (int) map.get(&quot;d&quot;));\n    }\n }\n\n\nWhen we put, we ensure that the hash map has the value for the comparator, and then put to the TreeSet for sorting. But before that we check the hash map to see that the key is not actually a duplicate. Also, the comparator that we create will also include the key so that duplicate values don&apos;t delete the non-duplicate keys (due to == comparison).\nThese 2 items are vital for ensuring the map contract is kept; if you think you don&apos;t want that, then you&apos;re almost at the point of reversing the map entirely (to Map&lt;V,K&gt;).\n\nThe constructor would need to be called as \n\n new ValueComparableMap(Ordering.natural());\n //or\n new ValueComparableMap(Ordering.from(comparator));\n\n    ","url":"/questions/[slug]#solution4","@type":"Answer","upvoteCount":0},{"text":"From http://www.programmersheaven.com/download/49349/download.aspx\n\nprivate static &lt;K, V&gt; Map&lt;K, V&gt; sortByValue(Map&lt;K, V&gt; map) {\n    List&lt;Entry&lt;K, V&gt;&gt; list = new LinkedList&lt;&gt;(map.entrySet());\n    Collections.sort(list, new Comparator&lt;Object&gt;() {\n        @SuppressWarnings(&quot;unchecked&quot;)\n        public int compare(Object o1, Object o2) {\n            return ((Comparable&lt;V&gt;) ((Map.Entry&lt;K, V&gt;) (o1)).getValue()).compareTo(((Map.Entry&lt;K, V&gt;) (o2)).getValue());\n        }\n    });\n\n    Map&lt;K, V&gt; result = new LinkedHashMap&lt;&gt;();\n    for (Iterator&lt;Entry&lt;K, V&gt;&gt; it = list.iterator(); it.hasNext();) {\n        Map.Entry&lt;K, V&gt; entry = (Map.Entry&lt;K, V&gt;) it.next();\n        result.put(entry.getKey(), entry.getValue());\n    }\n\n    return result;\n}\n\n    ","url":"/questions/[slug]#solution5","@type":"Answer","upvoteCount":0},{"text":"With Java 8, you can use the streams api to do it in a significantly less verbose way:\n\nMap&lt;K, V&gt; sortedMap = map.entrySet().stream()\n                         .sorted(Entry.comparingByValue())\n                         .collect(Collectors.toMap(Entry::getKey, Entry::getValue, (e1, e2) -&gt; e1, LinkedHashMap::new));\n\n    ","url":"/questions/[slug]#solution6","@type":"Answer","upvoteCount":0},{"text":"Sorting the keys requires the Comparator to look up each value for each comparison. A more scalable solution would use the entrySet directly, since then the value would be immediately available for each comparison (although I haven&apos;t backed this up by numbers).\n\nHere&apos;s a generic version of such a thing:\n\npublic static &lt;K, V extends Comparable&lt;? super V&gt;&gt; List&lt;K&gt; getKeysSortedByValue(Map&lt;K, V&gt; map) {\n    final int size = map.size();\n    final List&lt;Map.Entry&lt;K, V&gt;&gt; list = new ArrayList&lt;Map.Entry&lt;K, V&gt;&gt;(size);\n    list.addAll(map.entrySet());\n    final ValueComparator&lt;V&gt; cmp = new ValueComparator&lt;V&gt;();\n    Collections.sort(list, cmp);\n    final List&lt;K&gt; keys = new ArrayList&lt;K&gt;(size);\n    for (int i = 0; i &lt; size; i++) {\n        keys.set(i, list.get(i).getKey());\n    }\n    return keys;\n}\n\nprivate static final class ValueComparator&lt;V extends Comparable&lt;? super V&gt;&gt;\n                                     implements Comparator&lt;Map.Entry&lt;?, V&gt;&gt; {\n    public int compare(Map.Entry&lt;?, V&gt; o1, Map.Entry&lt;?, V&gt; o2) {\n        return o1.getValue().compareTo(o2.getValue());\n    }\n}\n\n\nThere are ways to lessen memory rotation for the above solution. The first ArrayList created could for instance be re-used as a return value; this would require suppression of some generics warnings, but it might be worth it for re-usable library code. Also,  the Comparator does not have to be re-allocated at every invocation.\n\nHere&apos;s a more efficient albeit less appealing version:\n\npublic static &lt;K, V extends Comparable&lt;? super V&gt;&gt; List&lt;K&gt; getKeysSortedByValue2(Map&lt;K, V&gt; map) {\n    final int size = map.size();\n    final List reusedList = new ArrayList(size);\n    final List&lt;Map.Entry&lt;K, V&gt;&gt; meView = reusedList;\n    meView.addAll(map.entrySet());\n    Collections.sort(meView, SINGLE);\n    final List&lt;K&gt; keyView = reusedList;\n    for (int i = 0; i &lt; size; i++) {\n        keyView.set(i, meView.get(i).getKey());\n    }\n    return keyView;\n}\n\nprivate static final Comparator SINGLE = new ValueComparator();\n\n\nFinally, if you need to continously access the sorted information (rather than just sorting it once in a while), you can use an additional multi map. Let me know if you need more details...\n    ","url":"/questions/[slug]#solution7","@type":"Answer","upvoteCount":0},{"text":"The commons-collections library contains a solution called TreeBidiMap. Or, you could have a look at the Google Collections API. It has TreeMultimap which you could use.\n\nAnd if you don&apos;t want to use these framework... they come with source code.\n    ","url":"/questions/[slug]#solution8","@type":"Answer","upvoteCount":0},{"text":"I&apos;ve looked at the given answers, but a lot of them are more complicated than needed or remove map elements when several keys have same value.\n\nHere is a solution that I think fits better:\n\npublic static &lt;K, V extends Comparable&lt;V&gt;&gt; Map&lt;K, V&gt; sortByValues(final Map&lt;K, V&gt; map) {\n    Comparator&lt;K&gt; valueComparator =  new Comparator&lt;K&gt;() {\n        public int compare(K k1, K k2) {\n            int compare = map.get(k2).compareTo(map.get(k1));\n            if (compare == 0) return 1;\n            else return compare;\n        }\n    };\n    Map&lt;K, V&gt; sortedByValues = new TreeMap&lt;K, V&gt;(valueComparator);\n    sortedByValues.putAll(map);\n    return sortedByValues;\n}\n\n\nNote that the map is sorted from the highest value to the lowest.\n    ","url":"/questions/[slug]#solution9","@type":"Answer","upvoteCount":0},{"text":"Given Map\n\n   Map&lt;String, Integer&gt; wordCounts = new HashMap&lt;&gt;();\n    wordCounts.put(&quot;USA&quot;, 100);\n    wordCounts.put(&quot;jobs&quot;, 200);\n    wordCounts.put(&quot;software&quot;, 50);\n    wordCounts.put(&quot;technology&quot;, 70);\n    wordCounts.put(&quot;opportunity&quot;, 200);\n\n\nSort the map based on the value in ascending order\n\nMap&lt;String,Integer&gt;  sortedMap =  wordCounts.entrySet().\n                                                stream().\n                                                sorted(Map.Entry.comparingByValue()).\n        collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue, (e1, e2) -&gt; e1, LinkedHashMap::new));\n    System.out.println(sortedMap);\n\n\nSort the map based on value in desending order\n\nMap&lt;String,Integer&gt;  sortedMapReverseOrder =  wordCounts.entrySet().\n            stream().\n            sorted(Map.Entry.comparingByValue(Comparator.reverseOrder())).\n            collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue, (e1, e2) -&gt; e1, LinkedHashMap::new));\n    System.out.println(sortedMapReverseOrder);\n\n\nOutput:\n\n{software=50, technology=70, USA=100, jobs=200, opportunity=200}\n\n{jobs=200, opportunity=200, USA=100, technology=70, software=50}\n    ","url":"/questions/[slug]#solution10","@type":"Answer","upvoteCount":0},{"text":"To accomplish this with the new features in Java 8:\n\nimport static java.util.Map.Entry.comparingByValue;\nimport static java.util.stream.Collectors.toList;\n\n&lt;K, V&gt; List&lt;Entry&lt;K, V&gt;&gt; sort(Map&lt;K, V&gt; map, Comparator&lt;? super V&gt; comparator) {\n    return map.entrySet().stream().sorted(comparingByValue(comparator)).collect(toList());\n}\n\n\nThe entries are ordered by their values using the given comparator. Alternatively, if your values are mutually comparable, no explicit comparator is needed:\n\n&lt;K, V extends Comparable&lt;? super V&gt;&gt; List&lt;Entry&lt;K, V&gt;&gt; sort(Map&lt;K, V&gt; map) {\n    return map.entrySet().stream().sorted(comparingByValue()).collect(toList());\n}\n\n\nThe returned list is a snapshot of the given map at the time this method is called, so neither will reflect subsequent changes to the other. For a live iterable view of the map:\n\n&lt;K, V extends Comparable&lt;? super V&gt;&gt; Iterable&lt;Entry&lt;K, V&gt;&gt; sort(Map&lt;K, V&gt; map) {\n    return () -&gt; map.entrySet().stream().sorted(comparingByValue()).iterator();\n}\n\n\nThe returned iterable creates a fresh snapshot of the given map each time it&apos;s iterated, so barring concurrent modification, it will always reflect the current state of the map.\n    ","url":"/questions/[slug]#solution11","@type":"Answer","upvoteCount":0},{"text":"Create customized comparator and use it while creating new TreeMap object.\n\nclass MyComparator implements Comparator&lt;Object&gt; {\n\n    Map&lt;String, Integer&gt; map;\n\n    public MyComparator(Map&lt;String, Integer&gt; map) {\n        this.map = map;\n    }\n\n    public int compare(Object o1, Object o2) {\n\n        if (map.get(o2) == map.get(o1))\n            return 1;\n        else\n            return ((Integer) map.get(o2)).compareTo((Integer)     \n                                                            map.get(o1));\n\n    }\n}\n\n\nUse the below code in your main func\n\n    Map&lt;String, Integer&gt; lMap = new HashMap&lt;String, Integer&gt;();\n    lMap.put(&quot;A&quot;, 35);\n    lMap.put(&quot;B&quot;, 75);\n    lMap.put(&quot;C&quot;, 50);\n    lMap.put(&quot;D&quot;, 50);\n\n    MyComparator comparator = new MyComparator(lMap);\n\n    Map&lt;String, Integer&gt; newMap = new TreeMap&lt;String, Integer&gt;(comparator);\n    newMap.putAll(lMap);\n    System.out.println(newMap);\n\n\nOutput:\n\n{B=75, D=50, C=50, A=35}\n\n    ","url":"/questions/[slug]#solution12","@type":"Answer","upvoteCount":0},{"text":"While I agree that the constant need to sort a map is probably a smell, I think the following code is the easiest way to do it without using a different data structure.\n\npublic class MapUtilities {\n\npublic static &lt;K, V extends Comparable&lt;V&gt;&gt; List&lt;Entry&lt;K, V&gt;&gt; sortByValue(Map&lt;K, V&gt; map) {\n    List&lt;Entry&lt;K, V&gt;&gt; entries = new ArrayList&lt;Entry&lt;K, V&gt;&gt;(map.entrySet());\n    Collections.sort(entries, new ByValue&lt;K, V&gt;());\n    return entries;\n}\n\nprivate static class ByValue&lt;K, V extends Comparable&lt;V&gt;&gt; implements Comparator&lt;Entry&lt;K, V&gt;&gt; {\n    public int compare(Entry&lt;K, V&gt; o1, Entry&lt;K, V&gt; o2) {\n        return o1.getValue().compareTo(o2.getValue());\n    }\n}\n\n\n}\n\nAnd here is an embarrassingly incomplete unit test:\n\npublic class MapUtilitiesTest extends TestCase {\npublic void testSorting() {\n    HashMap&lt;String, Integer&gt; map = new HashMap&lt;String, Integer&gt;();\n    map.put(&quot;One&quot;, 1);\n    map.put(&quot;Two&quot;, 2);\n    map.put(&quot;Three&quot;, 3);\n\n    List&lt;Map.Entry&lt;String, Integer&gt;&gt; sorted = MapUtilities.sortByValue(map);\n    assertEquals(&quot;First&quot;, &quot;One&quot;, sorted.get(0).getKey());\n    assertEquals(&quot;Second&quot;, &quot;Two&quot;, sorted.get(1).getKey());\n    assertEquals(&quot;Third&quot;, &quot;Three&quot;, sorted.get(2).getKey());\n}\n\n\n}\n\nThe result is a sorted list of Map.Entry objects, from which you can obtain the keys and values.\n    ","url":"/questions/[slug]#solution13","@type":"Answer","upvoteCount":0},{"text":"Use a generic comparator such as:\nfinal class MapValueComparator&lt;K,V extends Comparable&lt;V&gt;&gt; implements Comparator&lt;K&gt; {\n    private final Map&lt;K,V&gt; map;\n    \n    private MapValueComparator() {\n        super();\n    }\n    \n    public MapValueComparator(Map&lt;K,V&gt; map) {\n        this();\n        this.map = map;\n    }\n        \n    public int compare(K o1, K o2) {\n        return map.get(o1).compareTo(map.get(o2));\n    }\n}\n\n    ","url":"/questions/[slug]#solution14","@type":"Answer","upvoteCount":0},{"text":"The answer voted for the most does not work when you have 2 items that equals.\nthe TreeMap leaves equal values out.\n\nthe exmaple:\nunsorted map\n\nkey/value: D/67.3\nkey/value: A/99.5\nkey/value: B/67.4\nkey/value: C/67.5\nkey/value: E/99.5\n\n\nresults\n\nkey/value: A/99.5\nkey/value: C/67.5\nkey/value: B/67.4\nkey/value: D/67.3\n\n\nSo leaves out E!!\n\nFor me it worked fine to adjust the comparator, if it equals do not return 0 but -1.\n\nin the example:\n\n\n  \n    class ValueComparator implements Comparator {\n    \n    Map base;\n      public ValueComparator(Map base) {\n          this.base = base;\n      }\n    \n    public int compare(Object a, Object b) {\n\nif((Double)base.get(a) &lt; (Double)base.get(b)) {\n  return 1;\n} else if((Double)base.get(a) == (Double)base.get(b)) {\n  return -1;\n} else {\n  return -1;\n}\n\n    \n    }\n    }\n  \n\n\nnow it returns:\n\nunsorted map:\n\nkey/value: D/67.3\nkey/value: A/99.5\nkey/value: B/67.4\nkey/value: C/67.5\nkey/value: E/99.5\n\n\nresults:\n\nkey/value: A/99.5\nkey/value: E/99.5\nkey/value: C/67.5\nkey/value: B/67.4\nkey/value: D/67.3\n\n\nas a response to Aliens (2011 nov. 22):\nI Am using this solution for a map of Integer Id&apos;s and names, but the idea is the same, so might be the code above is not correct (I will write it in a test and give you the correct code), this is the code for a Map sorting, based on the solution above:\n\npackage nl.iamit.util;\n\nimport java.util.Comparator;\nimport java.util.Map;\n\npublic class Comparators {\n\n\n    public static class MapIntegerStringComparator implements Comparator {\n\n        Map&lt;Integer, String&gt; base;\n\n        public MapIntegerStringComparator(Map&lt;Integer, String&gt; base) {\n            this.base = base;\n        }\n\n        public int compare(Object a, Object b) {\n\n            int compare = ((String) base.get(a))\n                    .compareTo((String) base.get(b));\n            if (compare == 0) {\n                return -1;\n            }\n            return compare;\n        }\n    }\n\n\n}\n\n\nand this is the test class (I just tested it, and this works for the Integer, String Map:\n\npackage test.nl.iamit.util;\n\nimport java.util.HashMap;\nimport java.util.TreeMap;\nimport nl.iamit.util.Comparators;\nimport org.junit.Test;\nimport static org.junit.Assert.assertArrayEquals;\n\npublic class TestComparators {\n\n\n    @Test\n    public void testMapIntegerStringComparator(){\n        HashMap&lt;Integer, String&gt; unSoretedMap = new HashMap&lt;Integer, String&gt;();\n        Comparators.MapIntegerStringComparator bvc = new Comparators.MapIntegerStringComparator(\n                unSoretedMap);\n        TreeMap&lt;Integer, String&gt; sorted_map = new TreeMap&lt;Integer, String&gt;(bvc);\n        //the testdata:\n        unSoretedMap.put(new Integer(1), &quot;E&quot;);\n        unSoretedMap.put(new Integer(2), &quot;A&quot;);\n        unSoretedMap.put(new Integer(3), &quot;E&quot;);\n        unSoretedMap.put(new Integer(4), &quot;B&quot;);\n        unSoretedMap.put(new Integer(5), &quot;F&quot;);\n\n        sorted_map.putAll(unSoretedMap);\n\n        Object[] targetKeys={new Integer(2),new Integer(4),new Integer(3),new Integer(1),new Integer(5) };\n        Object[] currecntKeys=sorted_map.keySet().toArray();\n\n        assertArrayEquals(targetKeys,currecntKeys);\n    }\n}\n\n\nhere is the code for the Comparator of a Map:\n\npublic static class MapStringDoubleComparator implements Comparator {\n\n    Map&lt;String, Double&gt; base;\n\n    public MapStringDoubleComparator(Map&lt;String, Double&gt; base) {\n        this.base = base;\n    }\n\n    //note if you want decending in stead of ascending, turn around 1 and -1\n    public int compare(Object a, Object b) {\n        if ((Double) base.get(a) == (Double) base.get(b)) {\n            return 0;\n        } else if((Double) base.get(a) &lt; (Double) base.get(b)) {\n            return -1;\n        }else{\n            return 1;\n        }\n    }\n}\n\n\nand this is the testcase for this:\n\n@Test\npublic void testMapStringDoubleComparator(){\n    HashMap&lt;String, Double&gt; unSoretedMap = new HashMap&lt;String, Double&gt;();\n    Comparators.MapStringDoubleComparator bvc = new Comparators.MapStringDoubleComparator(\n            unSoretedMap);\n    TreeMap&lt;String, Double&gt; sorted_map = new TreeMap&lt;String, Double&gt;(bvc);\n    //the testdata:\n    unSoretedMap.put(&quot;D&quot;,new Double(67.3));\n    unSoretedMap.put(&quot;A&quot;,new Double(99.5));\n    unSoretedMap.put(&quot;B&quot;,new Double(67.4));\n    unSoretedMap.put(&quot;C&quot;,new Double(67.5));\n    unSoretedMap.put(&quot;E&quot;,new Double(99.5));\n\n    sorted_map.putAll(unSoretedMap);\n\n    Object[] targetKeys={&quot;D&quot;,&quot;B&quot;,&quot;C&quot;,&quot;E&quot;,&quot;A&quot;};\n    Object[] currecntKeys=sorted_map.keySet().toArray();\n\n    assertArrayEquals(targetKeys,currecntKeys);\n}\n\n\nof cource you can make this a lot more generic, but I just needed it for 1 case (the Map)\n    ","url":"/questions/[slug]#solution15","@type":"Answer","upvoteCount":0},{"text":"Instead of using Collections.sort as some do I&apos;d suggest using Arrays.sort. Actually what Collections.sort does is something like this:\n\npublic static &lt;T extends Comparable&lt;? super T&gt;&gt; void sort(List&lt;T&gt; list) {\n    Object[] a = list.toArray();\n    Arrays.sort(a);\n    ListIterator&lt;T&gt; i = list.listIterator();\n    for (int j=0; j&lt;a.length; j++) {\n        i.next();\n        i.set((T)a[j]);\n    }\n}\n\n\nIt just calls toArray on the list and then uses Arrays.sort. This way all the map entries will be copied three times: once from the map to the temporary list (be it a LinkedList or ArrayList), then to the temporary array and finally to the new map.\n\nMy solution ommits this one step as it does not create unnecessary LinkedList. Here is the code, generic-friendly and performance-optimal:\n\npublic static &lt;K, V extends Comparable&lt;? super V&gt;&gt; Map&lt;K, V&gt; sortByValue(Map&lt;K, V&gt; map) \n{\n    @SuppressWarnings(&quot;unchecked&quot;)\n    Map.Entry&lt;K,V&gt;[] array = map.entrySet().toArray(new Map.Entry[map.size()]);\n\n    Arrays.sort(array, new Comparator&lt;Map.Entry&lt;K, V&gt;&gt;() \n    {\n        public int compare(Map.Entry&lt;K, V&gt; e1, Map.Entry&lt;K, V&gt; e2) \n        {\n            return e1.getValue().compareTo(e2.getValue());\n        }\n    });\n\n    Map&lt;K, V&gt; result = new LinkedHashMap&lt;K, V&gt;();\n    for (Map.Entry&lt;K, V&gt; entry : array)\n        result.put(entry.getKey(), entry.getValue());\n\n    return result;\n}\n\n    ","url":"/questions/[slug]#solution16","@type":"Answer","upvoteCount":0},{"text":"This is a variation of Anthony&apos;s answer, which doesn&apos;t work if there are duplicate values:\n\npublic static &lt;K, V extends Comparable&lt;V&gt;&gt; Map&lt;K, V&gt; sortMapByValues(final Map&lt;K, V&gt; map) {\n    Comparator&lt;K&gt; valueComparator =  new Comparator&lt;K&gt;() {\n        public int compare(K k1, K k2) {\n            final V v1 = map.get(k1);\n            final V v2 = map.get(k2);\n\n            /* Not sure how to handle nulls ... */\n            if (v1 == null) {\n                return (v2 == null) ? 0 : 1;\n            }\n\n            int compare = v2.compareTo(v1);\n            if (compare != 0)\n            {\n                return compare;\n            }\n            else\n            {\n                Integer h1 = k1.hashCode();\n                Integer h2 = k2.hashCode();\n                return h2.compareTo(h1);\n            }\n        }\n    };\n    Map&lt;K, V&gt; sortedByValues = new TreeMap&lt;K, V&gt;(valueComparator);\n    sortedByValues.putAll(map);\n    return sortedByValues;\n}\n\n\nNote that it&apos;s rather up in the air how to handle nulls. \n\nOne important advantage of this approach is that it actually returns a Map, unlike some of the other solutions offered here.\n    ","url":"/questions/[slug]#solution17","@type":"Answer","upvoteCount":0},{"text":"Best Approach\n\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.Map.Entry; \n\npublic class OrderByValue {\n\n  public static void main(String a[]){\n    Map&lt;String, Integer&gt; map = new HashMap&lt;String, Integer&gt;();\n    map.put(&quot;java&quot;, 20);\n    map.put(&quot;C++&quot;, 45);\n    map.put(&quot;Unix&quot;, 67);\n    map.put(&quot;MAC&quot;, 26);\n    map.put(&quot;Why this kolavari&quot;, 93);\n    Set&lt;Entry&lt;String, Integer&gt;&gt; set = map.entrySet();\n    List&lt;Entry&lt;String, Integer&gt;&gt; list = new ArrayList&lt;Entry&lt;String, Integer&gt;&gt;(set);\n    Collections.sort( list, new Comparator&lt;Map.Entry&lt;String, Integer&gt;&gt;()\n    {\n        public int compare( Map.Entry&lt;String, Integer&gt; o1, Map.Entry&lt;String, Integer&gt; o2 )\n        {\n            return (o1.getValue()).compareTo( o2.getValue() );//Ascending order\n            //return (o2.getValue()).compareTo( o1.getValue() );//Descending order\n        }\n    } );\n    for(Map.Entry&lt;String, Integer&gt; entry:list){\n        System.out.println(entry.getKey()+&quot; ==== &quot;+entry.getValue());\n    }\n  }}\n\n\nOutput\n\njava ==== 20\n\nMAC ==== 26\n\nC++ ==== 45\n\nUnix ==== 67\n\nWhy this kolavari ==== 93\n\n    ","url":"/questions/[slug]#solution18","@type":"Answer","upvoteCount":0},{"text":"Late Entry.\n\nWith the advent of Java-8, we can use streams for data manipulation in a very easy/succinct way. You can use streams to sort the map entries by value and create a LinkedHashMap which preserves insertion-order iteration.\n\nEg:\n\nLinkedHashMap sortedByValueMap = map.entrySet().stream()\n                .sorted(comparing(Entry&lt;Key,Value&gt;::getValue).thenComparing(Entry::getKey))     //first sorting by Value, then sorting by Key(entries with same value)\n                .collect(LinkedHashMap::new,(map,entry) -&gt; map.put(entry.getKey(),entry.getValue()),LinkedHashMap::putAll);\n\n\n\n\nFor reverse ordering, replace:\n\ncomparing(Entry&lt;Key,Value&gt;::getValue).thenComparing(Entry::getKey)\n\n\nwith\n\ncomparing(Entry&lt;Key,Value&gt;::getValue).thenComparing(Entry::getKey).reversed()\n\n    ","url":"/questions/[slug]#solution19","@type":"Answer","upvoteCount":0},{"text":"Major problem. If you use the first answer (Google takes you here), change the comparator to add an equal clause, otherwise you cannot get values from the sorted_map by keys:\n\npublic int compare(String a, String b) {\n        if (base.get(a) &gt; base.get(b)) {\n            return 1;\n        } else if (base.get(a) &lt; base.get(b)){\n            return -1;\n        } \n\n        return 0;\n        // returning 0 would merge keys\n    }\n\n    ","url":"/questions/[slug]#solution20","@type":"Answer","upvoteCount":0},{"text":"There are a lot of answers for this question already, but none provided me what I was looking for, a map implementation that returns keys and entries sorted by the associated value, and maintains this property as keys and values are modified in the map. Two other questions ask for this specifically. \n\nI cooked up a generic friendly example that solves this use case. This implementation does not honor all of the contracts of the Map interface, such as reflecting value changes and removals in the sets return from keySet() and entrySet() in the original object. I felt such a solution would be too large to include in a Stack Overflow answer. If I manage to create a more complete implementation, perhaps I will post it to Github and then to it link in an updated version of this answer.\n\nimport java.util.*;\n\n/**\n * A map where {@link #keySet()} and {@link #entrySet()} return sets ordered\n * by associated values based on the the comparator provided at construction\n * time. The order of two or more keys with identical values is not defined.\n * &lt;p&gt;\n * Several contracts of the Map interface are not satisfied by this minimal\n * implementation.\n */\npublic class ValueSortedMap&lt;K, V&gt; extends HashMap&lt;K, V&gt; {\n    protected Map&lt;V, Collection&lt;K&gt;&gt; valueToKeysMap;\n\n    // uses natural order of value object, if any\n    public ValueSortedMap() {\n        this((Comparator&lt;? super V&gt;) null);\n    }\n\n    public ValueSortedMap(Comparator&lt;? super V&gt; valueComparator) {\n        this.valueToKeysMap = new TreeMap&lt;V, Collection&lt;K&gt;&gt;(valueComparator);\n    }\n\n    public boolean containsValue(Object o) {\n        return valueToKeysMap.containsKey(o);\n    }\n\n    public V put(K k, V v) {\n        V oldV = null;\n        if (containsKey(k)) {\n            oldV = get(k);\n            valueToKeysMap.get(oldV).remove(k);\n        }\n        super.put(k, v);\n        if (!valueToKeysMap.containsKey(v)) {\n            Collection&lt;K&gt; keys = new ArrayList&lt;K&gt;();\n            keys.add(k);\n            valueToKeysMap.put(v, keys);\n        } else {\n            valueToKeysMap.get(v).add(k);\n        }\n        return oldV;\n    }\n\n    public void putAll(Map&lt;? extends K, ? extends V&gt; m) {\n        for (Map.Entry&lt;? extends K, ? extends V&gt; e : m.entrySet())\n            put(e.getKey(), e.getValue());\n    }\n\n    public V remove(Object k) {\n        V oldV = null;\n        if (containsKey(k)) {\n            oldV = get(k);\n            super.remove(k);\n            valueToKeysMap.get(oldV).remove(k);\n        }\n        return oldV;\n    }\n\n    public void clear() {\n        super.clear();\n        valueToKeysMap.clear();\n    }\n\n    public Set&lt;K&gt; keySet() {\n        LinkedHashSet&lt;K&gt; ret = new LinkedHashSet&lt;K&gt;(size());\n        for (V v : valueToKeysMap.keySet()) {\n            Collection&lt;K&gt; keys = valueToKeysMap.get(v);\n            ret.addAll(keys);\n        }\n        return ret;\n    }\n\n    public Set&lt;Map.Entry&lt;K, V&gt;&gt; entrySet() {\n        LinkedHashSet&lt;Map.Entry&lt;K, V&gt;&gt; ret = new LinkedHashSet&lt;Map.Entry&lt;K, V&gt;&gt;(size());\n        for (Collection&lt;K&gt; keys : valueToKeysMap.values()) {\n            for (final K k : keys) {\n                final V v = get(k);\n                ret.add(new Map.Entry&lt;K,V&gt;() {\n                    public K getKey() {\n                        return k;\n                    }\n\n                    public V getValue() {\n                        return v;\n                    }\n\n                    public V setValue(V v) {\n                        throw new UnsupportedOperationException();\n                    }\n                });\n            }\n        }\n        return ret;\n    }\n}\n\n    ","url":"/questions/[slug]#solution21","@type":"Answer","upvoteCount":0},{"text":"Simple way to sort any map in Java 8 and above\nMap&lt;String, Object&gt; mapToSort = new HashMap&lt;&gt;();\n\nList&lt;Map.Entry&lt;String, Object&gt;&gt; list = new LinkedList&lt;&gt;(mapToSort.entrySet());\n\nCollections.sort(list, Comparator.comparing(o -&gt; o.getValue().getAttribute()));\n\nHashMap&lt;String, Object&gt; sortedMap = new LinkedHashMap&lt;&gt;();\nfor (Map.Entry&lt;String, Object&gt; map : list) {\n   sortedMap.put(map.getKey(), map.getValue());\n}\n\nif you are using Java 7 and below\nMap&lt;String, Object&gt; mapToSort = new HashMap&lt;&gt;();\n\nList&lt;Map.Entry&lt;String, Object&gt;&gt; list = new LinkedList&lt;&gt;(mapToSort.entrySet());\n\nCollections.sort(list, new Comparator&lt;Map.Entry&lt;String, Object&gt;&gt;() {\n    @Override\n    public int compare(Map.Entry&lt;String, Object&gt; o1, Map.Entry&lt;String, Object&gt; o2) {\n       return o1.getValue().getAttribute().compareTo(o2.getValue().getAttribute());      \n    }\n});\n\nHashMap&lt;String, Object&gt; sortedMap = new LinkedHashMap&lt;&gt;();\nfor (Map.Entry&lt;String, Object&gt; map : list) {\n   sortedMap.put(map.getKey(), map.getValue());\n}\n\n    ","url":"/questions/[slug]#solution22","@type":"Answer","upvoteCount":0},{"text":"Depending on the context, using java.util.LinkedHashMap&lt;T&gt; which rememebers the order in which items are placed into the map.  Otherwise, if you need to sort values based on their natural ordering, I would recommend maintaining a separate List which can be sorted via Collections.sort().\n    ","url":"/questions/[slug]#solution23","@type":"Answer","upvoteCount":0},{"text":"Afaik the most cleaner way is utilizing collections to sort map on value:\n\nMap&lt;String, Long&gt; map = new HashMap&lt;String, Long&gt;();\n// populate with data to sort on Value\n// use datastructure designed for sorting\n\nQueue queue = new PriorityQueue( map.size(), new MapComparable() );\nqueue.addAll( map.entrySet() );\n\n// get a sorted map\nLinkedHashMap&lt;String, Long&gt; linkedMap = new LinkedHashMap&lt;String, Long&gt;();\n\nfor (Map.Entry&lt;String, Long&gt; entry; (entry = queue.poll())!=null;) {\n    linkedMap.put(entry.getKey(), entry.getValue());\n}\n\npublic static class MapComparable implements Comparator&lt;Map.Entry&lt;String, Long&gt;&gt;{\n\n  public int compare(Entry&lt;String, Long&gt; e1, Entry&lt;String, Long&gt; e2) {\n    return e1.getValue().compareTo(e2.getValue());\n  }\n}\n\n    ","url":"/questions/[slug]#solution24","@type":"Answer","upvoteCount":0},{"text":"Since TreeMap&lt;&gt; does not work for values that can be equal, I used this:\n\nprivate &lt;K, V extends Comparable&lt;? super V&gt;&gt; List&lt;Entry&lt;K, V&gt;&gt; sort(Map&lt;K, V&gt; map)     {\n    List&lt;Map.Entry&lt;K, V&gt;&gt; list = new LinkedList&lt;Map.Entry&lt;K, V&gt;&gt;(map.entrySet());\n    Collections.sort(list, new Comparator&lt;Map.Entry&lt;K, V&gt;&gt;() {\n        public int compare(Map.Entry&lt;K, V&gt; o1, Map.Entry&lt;K, V&gt; o2) {\n            return o1.getValue().compareTo(o2.getValue());\n        }\n    });\n\n    return list;\n}\n\n\nYou might want to put list in a LinkedHashMap, but if you&apos;re only going to iterate over it right away, that&apos;s superfluous...\n    ","url":"/questions/[slug]#solution25","@type":"Answer","upvoteCount":0},{"text":"This is just too complicated. Maps were not supposed to do such job as sorting them by Value. The easiest way is to create your own Class so it fits your requirement.\n\nIn example lower you are supposed to add TreeMap a comparator at place where * is. But by java API it gives comparator only keys, not values. All of examples stated here is based on 2 Maps. One Hash and one new Tree. Which is odd.\n\nThe example:\n\nMap&lt;Driver driver, Float time&gt; map = new TreeMap&lt;Driver driver, Float time&gt;(*);\n\n\nSo change the map into a set this way:\n\nResultComparator rc = new ResultComparator();\nSet&lt;Results&gt; set = new TreeSet&lt;Results&gt;(rc);\n\n\nYou will create class Results,\n\npublic class Results {\n    private Driver driver;\n    private Float time;\n\n    public Results(Driver driver, Float time) {\n        this.driver = driver;\n        this.time = time;\n    }\n\n    public Float getTime() {\n        return time;\n    }\n\n    public void setTime(Float time) {\n        this.time = time;\n    }\n\n    public Driver getDriver() {\n        return driver;\n    }\n\n    public void setDriver (Driver driver) {\n        this.driver = driver;\n    }\n}\n\n\nand the Comparator class:\n\npublic class ResultsComparator implements Comparator&lt;Results&gt; {\n    public int compare(Results t, Results t1) {\n        if (t.getTime() &lt; t1.getTime()) {\n            return 1;\n        } else if (t.getTime() == t1.getTime()) {\n            return 0;\n        } else {\n            return -1;\n        }\n    }\n}\n\n\nThis way you can easily add more dependencies.\n\nAnd as the last point I&apos;ll add simple iterator:\n\nIterator it = set.iterator();\nwhile (it.hasNext()) {\n    Results r = (Results)it.next();\n    System.out.println( r.getDriver().toString\n        //or whatever that is related to Driver class -getName() getSurname()\n        + &quot; &quot;\n        + r.getTime()\n        );\n}\n\n    ","url":"/questions/[slug]#solution26","@type":"Answer","upvoteCount":0},{"text":"Based on @devinmoore code, a map sorting methods using generics and supporting both ascending and descending ordering.\n\n/**\n * Sort a map by it&apos;s keys in ascending order. \n *  \n * @return new instance of {@link LinkedHashMap} contained sorted entries of supplied map.\n * @author Maxim Veksler\n */\npublic static &lt;K, V&gt; LinkedHashMap&lt;K, V&gt; sortMapByKey(final Map&lt;K, V&gt; map) {\n    return sortMapByKey(map, SortingOrder.ASCENDING);\n}\n\n/**\n * Sort a map by it&apos;s values in ascending order.\n *  \n * @return new instance of {@link LinkedHashMap} contained sorted entries of supplied map.\n * @author Maxim Veksler\n */\npublic static &lt;K, V&gt; LinkedHashMap&lt;K, V&gt; sortMapByValue(final Map&lt;K, V&gt; map) {\n    return sortMapByValue(map, SortingOrder.ASCENDING);\n}\n\n/**\n * Sort a map by it&apos;s keys.\n *  \n * @param sortingOrder {@link SortingOrder} enum specifying requested sorting order. \n * @return new instance of {@link LinkedHashMap} contained sorted entries of supplied map.\n * @author Maxim Veksler\n */\npublic static &lt;K, V&gt; LinkedHashMap&lt;K, V&gt; sortMapByKey(final Map&lt;K, V&gt; map, final SortingOrder sortingOrder) {\n    Comparator&lt;Map.Entry&lt;K, V&gt;&gt; comparator = new Comparator&lt;Entry&lt;K,V&gt;&gt;() {\n        public int compare(Entry&lt;K, V&gt; o1, Entry&lt;K, V&gt; o2) {\n            return comparableCompare(o1.getKey(), o2.getKey(), sortingOrder);\n        }\n    };\n\n    return sortMap(map, comparator);\n}\n\n/**\n * Sort a map by it&apos;s values.\n *  \n * @param sortingOrder {@link SortingOrder} enum specifying requested sorting order. \n * @return new instance of {@link LinkedHashMap} contained sorted entries of supplied map.\n * @author Maxim Veksler\n */\npublic static &lt;K, V&gt; LinkedHashMap&lt;K, V&gt; sortMapByValue(final Map&lt;K, V&gt; map, final SortingOrder sortingOrder) {\n    Comparator&lt;Map.Entry&lt;K, V&gt;&gt; comparator = new Comparator&lt;Entry&lt;K,V&gt;&gt;() {\n        public int compare(Entry&lt;K, V&gt; o1, Entry&lt;K, V&gt; o2) {\n            return comparableCompare(o1.getValue(), o2.getValue(), sortingOrder);\n        }\n    };\n\n    return sortMap(map, comparator);\n}\n\n@SuppressWarnings(&quot;unchecked&quot;)\nprivate static &lt;T&gt; int comparableCompare(T o1, T o2, SortingOrder sortingOrder) {\n    int compare = ((Comparable&lt;T&gt;)o1).compareTo(o2);\n\n    switch (sortingOrder) {\n    case ASCENDING:\n        return compare;\n    case DESCENDING:\n        return (-1) * compare;\n    }\n\n    return 0;\n}\n\n/**\n * Sort a map by supplied comparator logic.\n *  \n * @return new instance of {@link LinkedHashMap} contained sorted entries of supplied map.\n * @author Maxim Veksler\n */\npublic static &lt;K, V&gt; LinkedHashMap&lt;K, V&gt; sortMap(final Map&lt;K, V&gt; map, final Comparator&lt;Map.Entry&lt;K, V&gt;&gt; comparator) {\n    // Convert the map into a list of key,value pairs.\n    List&lt;Map.Entry&lt;K, V&gt;&gt; mapEntries = new LinkedList&lt;Map.Entry&lt;K, V&gt;&gt;(map.entrySet());\n\n    // Sort the converted list according to supplied comparator.\n    Collections.sort(mapEntries, comparator);\n\n    // Build a new ordered map, containing the same entries as the old map.  \n    LinkedHashMap&lt;K, V&gt; result = new LinkedHashMap&lt;K, V&gt;(map.size() + (map.size() / 20));\n    for(Map.Entry&lt;K, V&gt; entry : mapEntries) {\n        // We iterate on the mapEntries list which is sorted by the comparator putting new entries into \n        // the targeted result which is a sorted map. \n        result.put(entry.getKey(), entry.getValue());\n    }\n\n    return result;\n}\n\n/**\n * Sorting order enum, specifying request result sort behavior.\n * @author Maxim Veksler\n *\n */\npublic static enum SortingOrder {\n    /**\n     * Resulting sort will be from smaller to biggest.\n     */\n    ASCENDING,\n    /**\n     * Resulting sort will be from biggest to smallest.\n     */\n    DESCENDING\n}\n\n    ","url":"/questions/[slug]#solution27","@type":"Answer","upvoteCount":0},{"text":"Here is an OO solution (i.e., doesn&apos;t use static methods):\n\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.LinkedList;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\n\npublic class SortableValueMap&lt;K, V extends Comparable&lt;V&gt;&gt;\n  extends LinkedHashMap&lt;K, V&gt; {\n  public SortableValueMap() { }\n\n  public SortableValueMap( Map&lt;K, V&gt; map ) {\n    super( map );\n  }\n\n  public void sortByValue() {\n    List&lt;Map.Entry&lt;K, V&gt;&gt; list = new LinkedList&lt;Map.Entry&lt;K, V&gt;&gt;( entrySet() );\n\n    Collections.sort( list, new Comparator&lt;Map.Entry&lt;K, V&gt;&gt;() {\n      public int compare( Map.Entry&lt;K, V&gt; entry1, Map.Entry&lt;K, V&gt; entry2 ) {\n        return entry1.getValue().compareTo( entry2.getValue() );\n      }\n    });\n\n    clear();\n\n    for( Map.Entry&lt;K, V&gt; entry : list ) {\n      put( entry.getKey(), entry.getValue() );\n    }\n  }\n\n  private static void print( String text, Map&lt;String, Double&gt; map ) {\n    System.out.println( text );\n\n    for( String key : map.keySet() ) {\n      System.out.println( &quot;key/value: &quot; + key + &quot;/&quot; + map.get( key ) );\n    }\n  }\n\n  public static void main( String[] args ) {\n    SortableValueMap&lt;String, Double&gt; map =\n      new SortableValueMap&lt;String, Double&gt;();\n\n    map.put( &quot;A&quot;, 67.5 );\n    map.put( &quot;B&quot;, 99.5 );\n    map.put( &quot;C&quot;, 82.4 );\n    map.put( &quot;D&quot;, 42.0 );\n\n    print( &quot;Unsorted map&quot;, map );\n    map.sortByValue();\n    print( &quot;Sorted map&quot;, map );\n  }\n}\n\n\nHereby donated to the public domain.\n    ","url":"/questions/[slug]#solution28","@type":"Answer","upvoteCount":0},{"text":"Some simple changes in order to have a sorted map with pairs that have duplicate values. In the compare method (class ValueComparator) when values are equal do not return 0 but return the result of comparing the 2 keys. Keys are distinct in a map so you succeed to keep duplicate values (which are sorted by keys by the way). So the above example could be modified like this:\n\n    public int compare(Object a, Object b) {\n\n        if((Double)base.get(a) &lt; (Double)base.get(b)) {\n          return 1;\n        } else if((Double)base.get(a) == (Double)base.get(b)) {\n          return ((String)a).compareTo((String)b);\n        } else {\n          return -1;\n        }\n      }\n    }\n\n    ","url":"/questions/[slug]#solution29","@type":"Answer","upvoteCount":0},{"text":"For sure the solution of Stephen is really great, but for those who can&apos;t use Guava:\n\nHere&apos;s my solution for sorting by value a map.\nThis solution handle the case where there are twice the same value etc...\n\n// If you want to sort a map by value, and if there can be twice the same value:\n\n// here is your original map\nMap&lt;String,Integer&gt; mapToSortByValue = new HashMap&lt;String, Integer&gt;();\nmapToSortByValue.put(&quot;A&quot;, 3);\nmapToSortByValue.put(&quot;B&quot;, 1);\nmapToSortByValue.put(&quot;C&quot;, 3);\nmapToSortByValue.put(&quot;D&quot;, 5);\nmapToSortByValue.put(&quot;E&quot;, -1);\nmapToSortByValue.put(&quot;F&quot;, 1000);\nmapToSortByValue.put(&quot;G&quot;, 79);\nmapToSortByValue.put(&quot;H&quot;, 15);\n\n// Sort all the map entries by value\nSet&lt;Map.Entry&lt;String,Integer&gt;&gt; set = new TreeSet&lt;Map.Entry&lt;String,Integer&gt;&gt;(\n        new Comparator&lt;Map.Entry&lt;String,Integer&gt;&gt;(){\n            @Override\n            public int compare(Map.Entry&lt;String,Integer&gt; obj1, Map.Entry&lt;String,Integer&gt; obj2) {\n                Integer val1 = obj1.getValue();\n                Integer val2 = obj2.getValue();\n                // DUPLICATE VALUE CASE\n                // If the values are equals, we can&apos;t return 0 because the 2 entries would be considered\n                // as equals and one of them would be deleted (because we use a set, no duplicate, remember!)\n                int compareValues = val1.compareTo(val2);\n                if ( compareValues == 0 ) {\n                    String key1 = obj1.getKey();\n                    String key2 = obj2.getKey();\n                    int compareKeys = key1.compareTo(key2);\n                    if ( compareKeys == 0 ) {\n                        // what you return here will tell us if you keep REAL KEY-VALUE duplicates in your set\n                        // if you want to, do whatever you want but do not return 0 (but don&apos;t break the comparator contract!)\n                        return 0;\n                    }\n                    return compareKeys;\n                }\n                return compareValues;\n            }\n        }\n);\nset.addAll(mapToSortByValue.entrySet());\n\n\n// OK NOW OUR SET IS SORTED COOL!!!!\n\n// And there&apos;s nothing more to do: the entries are sorted by value!\nfor ( Map.Entry&lt;String,Integer&gt; entry : set ) {\n    System.out.println(&quot;Set entries: &quot; + entry.getKey() + &quot; -&gt; &quot; + entry.getValue());\n}\n\n\n\n\n// But if you add them to an hashmap\nMap&lt;String,Integer&gt; myMap = new HashMap&lt;String,Integer&gt;();\n// When iterating over the set the order is still good in the println...\nfor ( Map.Entry&lt;String,Integer&gt; entry : set ) {\n    System.out.println(&quot;Added to result map entries: &quot; + entry.getKey() + &quot; &quot; + entry.getValue());\n    myMap.put(entry.getKey(), entry.getValue());\n}\n\n// But once they are in the hashmap, the order is not kept!\nfor ( Integer value : myMap.values() ) {\n    System.out.println(&quot;Result map values: &quot; + value);\n}\n// Also this way doesn&apos;t work:\n// Logic because the entryset is a hashset for hashmaps and not a treeset\n// (and even if it was a treeset, it would be on the keys only)\nfor ( Map.Entry&lt;String,Integer&gt; entry : myMap.entrySet() ) {\n    System.out.println(&quot;Result map entries: &quot; + entry.getKey() + &quot; -&gt; &quot; + entry.getValue());\n}\n\n\n// CONCLUSION:\n// If you want to iterate on a map ordered by value, you need to remember:\n// 1) Maps are only sorted by keys, so you can&apos;t sort them directly by value\n// 2) So you simply CAN&apos;T return a map to a sortMapByValue function\n// 3) You can&apos;t reverse the keys and the values because you have duplicate values\n//    This also means you can&apos;t neither use Guava/Commons bidirectionnal treemaps or stuff like that\n\n// SOLUTIONS\n// So you can:\n// 1) only sort the values which is easy, but you loose the key/value link (since you have duplicate values)\n// 2) sort the map entries, but don&apos;t forget to handle the duplicate value case (like i did)\n// 3) if you really need to return a map, use a LinkedHashMap which keep the insertion order\n\n\nThe exec:\nhttp://www.ideone.com/dq3Lu\n\nThe output:\n\nSet entries: E -&gt; -1\nSet entries: B -&gt; 1\nSet entries: A -&gt; 3\nSet entries: C -&gt; 3\nSet entries: D -&gt; 5\nSet entries: H -&gt; 15\nSet entries: G -&gt; 79\nSet entries: F -&gt; 1000\nAdded to result map entries: E -1\nAdded to result map entries: B 1\nAdded to result map entries: A 3\nAdded to result map entries: C 3\nAdded to result map entries: D 5\nAdded to result map entries: H 15\nAdded to result map entries: G 79\nAdded to result map entries: F 1000\nResult map values: 5\nResult map values: -1\nResult map values: 1000\nResult map values: 79\nResult map values: 3\nResult map values: 1\nResult map values: 3\nResult map values: 15\nResult map entries: D -&gt; 5\nResult map entries: E -&gt; -1\nResult map entries: F -&gt; 1000\nResult map entries: G -&gt; 79\nResult map entries: A -&gt; 3\nResult map entries: B -&gt; 1\nResult map entries: C -&gt; 3\nResult map entries: H -&gt; 15\n\n\nHope it will help some folks\n    ","url":"/questions/[slug]#solution30","@type":"Answer","upvoteCount":0}],"@type":"Question"}}</script><meta name="next-head-count" content="22"/><link rel="preload" href="/_next/static/css/4f7b2847abfe82c6.css" as="style"/><link rel="stylesheet" href="/_next/static/css/4f7b2847abfe82c6.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-0d1b80a048d4787e.js"></script><script src="/_next/static/chunks/webpack-42cdea76c8170223.js" defer=""></script><script src="/_next/static/chunks/framework-4556c45dd113b893.js" defer=""></script><script src="/_next/static/chunks/main-ccfab947c79712f4.js" defer=""></script><script src="/_next/static/chunks/pages/_app-c0d2dcb5e85faf18.js" defer=""></script><script src="/_next/static/chunks/294-106ef8570fa99deb.js" defer=""></script><script src="/_next/static/chunks/490-7f0418bb4354ac73.js" defer=""></script><script src="/_next/static/chunks/pages/questions/%5Bslug%5D-50e201fdaa1e0fd1.js" defer=""></script><script src="/_next/static/eGqQHYKGZKE-nXShFn8wX/_buildManifest.js" defer=""></script><script src="/_next/static/eGqQHYKGZKE-nXShFn8wX/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="wrapper"><header><nav class="bg-white border-gray-200 px-4 lg:px-6 py-2.5 dark:bg-gray-800"><div class="flex flex-wrap justify-between items-center mx-auto max-w-screen-xl"><a class="flex items-center" href="/"><img src="/logo-second.png" class="mr-3 h-6 sm:h-9" alt="Solution Checker Logo"/><h1 class="self-center text-xl font-semibold whitespace-nowrap dark:text-white">Solution Checker</h1></a><div class="flex items-center lg:order-2"><button data-collapse-toggle="mobile-menu-2" type="button" class="inline-flex items-center p-2 ml-1 text-sm text-gray-500 rounded-lg lg:hidden hover:bg-gray-100 focus:outline-none focus:ring-2 focus:ring-gray-200 dark:text-gray-400 dark:hover:bg-gray-700 dark:focus:ring-gray-600" aria-controls="mobile-menu-2" aria-expanded="false"><span class="sr-only">Open main menu</span><svg class="w-6 h-6" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M3 5a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM3 10a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM3 15a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1z" clip-rule="evenodd"></path></svg><svg class="hidden w-6 h-6" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z" clip-rule="evenodd"></path></svg></button></div><div class="hidden justify-between items-center w-full lg:flex lg:w-auto lg:order-1" id="mobile-menu-2"><ul class="flex flex-col mt-4 font-medium lg:flex-row lg:space-x-8 lg:mt-0"><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" aria-current="page" href="/">Home</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/questions?tab=news">Questions</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/post?tab=news">Post</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/questions/sort-a-maplesskey-valuegreater-by-values-1657387443904#">Coding</a></li></ul></div></div></nav></header><div class="main-content"><div class="question my-5"><div class="flex question-header items-center m-auto justify-center"><div class="rounded-xl w-full border p-5 shadow-md bg-white"><div class="flex w-full items-center justify-between border-b pb-3"><div class="flex items-center space-x-3"><div class="text-lg font-bold text-slate-700"><a href="/questions/sort-a-maplesskey-valuegreater-by-values-1657387443904"><h1>Sort a Map&lt;Key, Value&gt; by values</h1></a></div></div><div class="flex flex-wrap h-auto justify-end items-center space-x-8"></div></div><div class="question-content mt-5">
                
<p>I am relatively new to Java, and often find that I need to sort a <code>Map&lt;Key, Value&gt;</code> on the values.</p>

<p>Since the values are not unique, I find myself converting the <code>keySet</code> into an <code>array</code>, and sorting that array through <strong>array sort</strong> with a <strong>custom comparator</strong> that sorts on the value associated with the key.</p>

<p>Is there an easier way?</p>
    </div></div></div><div class="solution-section"><nav class="flex pagination-solution flex-col justify-end"><h1 class="text-lg font-semibold mb-5">Navigate to solutions: </h1><ul class="inline-flex -space-x-px overflow-auto"><li class="pagination-solution-item"><span data-id="#solution1" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">1</span></li><li class="pagination-solution-item"><span data-id="#solution2" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">2</span></li><li class="pagination-solution-item"><span data-id="#solution3" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">3</span></li><li class="pagination-solution-item"><span data-id="#solution4" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">4</span></li><li class="pagination-solution-item"><span data-id="#solution5" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">5</span></li><li class="pagination-solution-item"><span data-id="#solution6" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">6</span></li><li class="pagination-solution-item"><span data-id="#solution7" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">7</span></li><li class="pagination-solution-item"><span data-id="#solution8" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">8</span></li><li class="pagination-solution-item"><span data-id="#solution9" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">9</span></li><li class="pagination-solution-item"><span data-id="#solution10" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">10</span></li><li class="pagination-solution-item"><span data-id="#solution11" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">11</span></li><li class="pagination-solution-item"><span data-id="#solution12" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">12</span></li><li class="pagination-solution-item"><span data-id="#solution13" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">13</span></li><li class="pagination-solution-item"><span data-id="#solution14" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">14</span></li><li class="pagination-solution-item"><span data-id="#solution15" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">15</span></li><li class="pagination-solution-item"><span data-id="#solution16" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">16</span></li><li class="pagination-solution-item"><span data-id="#solution17" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">17</span></li><li class="pagination-solution-item"><span data-id="#solution18" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">18</span></li><li class="pagination-solution-item"><span data-id="#solution19" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">19</span></li><li class="pagination-solution-item"><span data-id="#solution20" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">20</span></li><li class="pagination-solution-item"><span data-id="#solution21" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">21</span></li><li class="pagination-solution-item"><span data-id="#solution22" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">22</span></li><li class="pagination-solution-item"><span data-id="#solution23" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">23</span></li><li class="pagination-solution-item"><span data-id="#solution24" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">24</span></li><li class="pagination-solution-item"><span data-id="#solution25" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">25</span></li><li class="pagination-solution-item"><span data-id="#solution26" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">26</span></li><li class="pagination-solution-item"><span data-id="#solution27" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">27</span></li><li class="pagination-solution-item"><span data-id="#solution28" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">28</span></li><li class="pagination-solution-item"><span data-id="#solution29" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">29</span></li><li class="pagination-solution-item"><span data-id="#solution30" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">30</span></li></ul></nav><div id="solution1" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 1</h1><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Here's a generic-friendly version:</p>

<pre class="lang-java s-code-block"><code class="hljs language-java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MapUtil</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;K, V <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Comparable</span>&lt;? <span class="hljs-built_in">super</span> V&gt;&gt; Map&lt;K, V&gt; <span class="hljs-title function_">sortByValue</span><span class="hljs-params">(Map&lt;K, V&gt; map)</span> {
        List&lt;Entry&lt;K, V&gt;&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(map.entrySet());
        list.sort(Entry.comparingByValue());

        Map&lt;K, V&gt; result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedHashMap</span>&lt;&gt;();
        <span class="hljs-keyword">for</span> (Entry&lt;K, V&gt; entry : list) {
            result.put(entry.getKey(), entry.getValue());
        }

        <span class="hljs-keyword">return</span> result;
    }
}
</code></pre>
    </div></div></div></div><div id="solution2" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 2</h1><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<h3>Important note:</h3>
<p><strong>This code can break in multiple ways.</strong> If you intend to use the code provided, be sure to read the comments as well to be aware of the implications. For example, values can no longer be retrieved by their key. (<code>get</code> always returns <code>null</code>.)</p>
<hr>
<p>It seems much easier than all of the foregoing. Use a TreeMap as follows:</p>
<pre class="lang-java s-code-block"><code class="hljs language-java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Testing</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {
        HashMap&lt;String, Double&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;String, Double&gt;();
        <span class="hljs-type">ValueComparator</span> <span class="hljs-variable">bvc</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ValueComparator</span>(map);
        TreeMap&lt;String, Double&gt; sorted_map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeMap</span>&lt;String, Double&gt;(bvc);

        map.put(<span class="hljs-string">"A"</span>, <span class="hljs-number">99.5</span>);
        map.put(<span class="hljs-string">"B"</span>, <span class="hljs-number">67.4</span>);
        map.put(<span class="hljs-string">"C"</span>, <span class="hljs-number">67.4</span>);
        map.put(<span class="hljs-string">"D"</span>, <span class="hljs-number">67.3</span>);

        System.out.println(<span class="hljs-string">"unsorted map: "</span> + map);
        sorted_map.putAll(map);
        System.out.println(<span class="hljs-string">"results: "</span> + sorted_map);
    }
}

<span class="hljs-keyword">class</span> <span class="hljs-title class_">ValueComparator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Comparator</span>&lt;String&gt; {
    Map&lt;String, Double&gt; base;

    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ValueComparator</span><span class="hljs-params">(Map&lt;String, Double&gt; base)</span> {
        <span class="hljs-built_in">this</span>.base = base;
    }

    <span class="hljs-comment">// Note: this comparator imposes orderings that are inconsistent with</span>
    <span class="hljs-comment">// equals.</span>
    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(String a, String b)</span> {
        <span class="hljs-keyword">if</span> (base.get(a) &gt;= base.get(b)) {
            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
        } <span class="hljs-comment">// returning 0 would merge keys</span>
    }
}
</code></pre>
<p>Output:</p>
<pre class="lang-java s-code-block"><code class="hljs language-java">unsorted map: {D=<span class="hljs-number">67.3</span>, A=<span class="hljs-number">99.5</span>, B=<span class="hljs-number">67.4</span>, C=<span class="hljs-number">67.4</span>}
results: {D=<span class="hljs-number">67.3</span>, B=<span class="hljs-number">67.4</span>, C=<span class="hljs-number">67.4</span>, A=<span class="hljs-number">99.5</span>}
</code></pre>
    </div></div></div></div><div id="solution3" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 3</h1><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Java 8 offers a new answer: convert the entries into a stream, and use the comparator combinators from Map.Entry:</p>
<pre class="lang-java s-code-block"><code class="hljs language-java">Stream&lt;Map.Entry&lt;K,V&gt;&gt; sorted =
    map.entrySet().stream()
       .sorted(Map.Entry.comparingByValue());
</code></pre>
<p>This will let you consume the entries sorted in ascending order of value.  If you want descending value, simply reverse the comparator:</p>
<pre class="lang-java s-code-block"><code class="hljs language-java">Stream&lt;Map.Entry&lt;K,V&gt;&gt; sorted =
    map.entrySet().stream()
       .sorted(Collections.reverseOrder(Map.Entry.comparingByValue()));
</code></pre>
<p>If the values are not comparable, you can pass an explicit comparator:</p>
<pre class="lang-java s-code-block"><code class="hljs language-java">Stream&lt;Map.Entry&lt;K,V&gt;&gt; sorted =
    map.entrySet().stream()
       .sorted(Map.Entry.comparingByValue(comparator));
</code></pre>
<p>You can then proceed to use other stream operations to consume the data. For example, if you want the top 10 in a new map:</p>
<pre class="lang-java s-code-block"><code class="hljs language-java">Map&lt;K,V&gt; topTen =
    map.entrySet().stream()
       .sorted(Map.Entry.comparingByValue(Comparator.reverseOrder()))
       .limit(<span class="hljs-number">10</span>)
       .collect(Collectors.toMap(
          Map.Entry::getKey, Map.Entry::getValue, (e1, e2) -&gt; e1, LinkedHashMap::<span class="hljs-keyword">new</span>));
</code></pre>
<p>The <a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/util/LinkedHashMap.html" rel="nofollow noreferrer"><code>LinkedHashMap</code></a> seen above iterates entries in the order in which they were inserted.</p>
<p>Or print to <code>System.out</code>:</p>
<pre class="lang-java s-code-block"><code class="hljs language-java">map.entrySet().stream()
   .sorted(Map.Entry.comparingByValue())
   .forEach(System.out::println);
</code></pre>
    </div></div></div></div><div id="solution4" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 4</h1><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p><strong>Three 1-line answers...</strong></p>

<p>I would use <s>Google Collections</s> <a href="http://code.google.com/p/guava-libraries/" rel="noreferrer"><strong>Guava</strong></a> to do this - if your values are <code>Comparable</code> then you can use</p>

<pre class="lang-java s-code-block"><code class="hljs language-java">valueComparator = Ordering.natural().onResultOf(Functions.forMap(map))
</code></pre>

<p>Which will create a function (object) for the map [that takes any of the keys as input, returning the respective value], and then apply natural (comparable) ordering to them [the values].</p>

<p>If they're not comparable, then you'll need to do something along the lines of</p>

<pre class="lang-java s-code-block"><code class="hljs language-java">valueComparator = Ordering.from(comparator).onResultOf(Functions.forMap(map)) 
</code></pre>

<p>These may be applied to a TreeMap (as <code>Ordering</code> extends <code>Comparator</code>), or a <a href="https://stackoverflow.com/questions/109383/how-to-sort-a-mapkey-value-on-the-values-in-java/109389#109389">LinkedHashMap after some sorting</a></p>

<p><em>NB</em>: If you are going to use a TreeMap, remember that if a comparison == 0, then the item is already in the list (which will happen if you have multiple values that compare the same).  To alleviate this, you could add your key to the comparator like so (presuming that your keys and values are <code>Comparable</code>):</p>

<pre class="lang-java s-code-block"><code class="hljs language-java">valueComparator = Ordering.natural().onResultOf(Functions.forMap(map)).compound(Ordering.natural())
</code></pre>

<p>= <em>Apply natural ordering to the value mapped by the key, and compound that with the natural ordering of the key</em></p>

<p>Note that this will still not work if your keys compare to 0, but this should be sufficient for most <code>comparable</code> items (as <code>hashCode</code>, <code>equals</code> and <code>compareTo</code> are often in sync...)</p>

<p>See <a href="http://guava-libraries.googlecode.com/svn/trunk/javadoc/com/google/common/collect/Ordering.html#onResultOf(com.google.common.base.Function)" rel="noreferrer">Ordering.onResultOf()</a> and <a href="http://guava-libraries.googlecode.com/svn/trunk/javadoc/com/google/common/base/Functions.html#forMap(java.util.Map)" rel="noreferrer">Functions.forMap()</a>.</p>

<h2>Implementation</h2>

<p>So now that we've got a comparator that does what we want, we need to get a result from it. </p>

<pre class="lang-java s-code-block"><code class="hljs language-java">map = ImmutableSortedMap.copyOf(myOriginalMap, valueComparator);
</code></pre>

<p>Now this will most likely work work, but:</p>

<ol>
<li>needs to be done given a complete finished map</li>
<li>Don't try the comparators above on a <code>TreeMap</code>; there's no point trying to compare an inserted key when it doesn't have a value until after the put, i.e., it will break really fast</li>
</ol>

<p>Point 1 is a bit of a deal-breaker for me; google collections is incredibly lazy (which is good: you can do pretty much every operation in an instant; the real work is done when you start using the result), and this requires copying a <em>whole</em> map!</p>

<h2>"Full" answer/Live sorted map by values</h2>

<p>Don't worry though; if you were obsessed enough with having a "live" map sorted in this manner, you could solve not one but both(!) of the above issues with something crazy like the following:</p>

<p><strong>Note: This has changed significantly in June 2012 - the previous code could never work: an internal HashMap is required to lookup the values without creating an infinite loop between the <code>TreeMap.get()</code> -&gt; <code>compare()</code> and <code>compare()</code> -&gt; <code>get()</code></strong></p>

<pre class="lang-java s-code-block"><code class="hljs language-java"><span class="hljs-keyword">import</span> <span class="hljs-keyword">static</span> org.junit.Assert.assertEquals;

<span class="hljs-keyword">import</span> java.util.HashMap;
<span class="hljs-keyword">import</span> java.util.Map;
<span class="hljs-keyword">import</span> java.util.TreeMap;

<span class="hljs-keyword">import</span> com.google.common.base.Functions;
<span class="hljs-keyword">import</span> com.google.common.collect.Ordering;

<span class="hljs-keyword">class</span> <span class="hljs-title class_">ValueComparableMap</span>&lt;K <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Comparable</span>&lt;K&gt;,V&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">TreeMap</span>&lt;K,V&gt; {
    <span class="hljs-comment">//A map for doing lookups on the keys for comparison so we don't get infinite loops</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Map&lt;K, V&gt; valueMap;

    ValueComparableMap(<span class="hljs-keyword">final</span> Ordering&lt;? <span class="hljs-built_in">super</span> V&gt; partialValueOrdering) {
        <span class="hljs-built_in">this</span>(partialValueOrdering, <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;K,V&gt;());
    }

    <span class="hljs-keyword">private</span> <span class="hljs-title function_">ValueComparableMap</span><span class="hljs-params">(Ordering&lt;? <span class="hljs-built_in">super</span> V&gt; partialValueOrdering,
            HashMap&lt;K, V&gt; valueMap)</span> {
        <span class="hljs-built_in">super</span>(partialValueOrdering <span class="hljs-comment">//Apply the value ordering</span>
                .onResultOf(Functions.forMap(valueMap)) <span class="hljs-comment">//On the result of getting the value for the key from the map</span>
                .compound(Ordering.natural())); <span class="hljs-comment">//as well as ensuring that the keys don't get clobbered</span>
        <span class="hljs-built_in">this</span>.valueMap = valueMap;
    }

    <span class="hljs-keyword">public</span> V <span class="hljs-title function_">put</span><span class="hljs-params">(K k, V v)</span> {
        <span class="hljs-keyword">if</span> (valueMap.containsKey(k)){
            <span class="hljs-comment">//remove the key in the sorted set before adding the key again</span>
            remove(k);
        }
        valueMap.put(k,v); <span class="hljs-comment">//To get "real" unsorted values for the comparator</span>
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>.put(k, v); <span class="hljs-comment">//Put it in value order</span>
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>{
        TreeMap&lt;String, Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ValueComparableMap</span>&lt;String, Integer&gt;(Ordering.natural());
        map.put(<span class="hljs-string">"a"</span>, <span class="hljs-number">5</span>);
        map.put(<span class="hljs-string">"b"</span>, <span class="hljs-number">1</span>);
        map.put(<span class="hljs-string">"c"</span>, <span class="hljs-number">3</span>);
        assertEquals(<span class="hljs-string">"b"</span>,map.firstKey());
        assertEquals(<span class="hljs-string">"a"</span>,map.lastKey());
        map.put(<span class="hljs-string">"d"</span>,<span class="hljs-number">0</span>);
        assertEquals(<span class="hljs-string">"d"</span>,map.firstKey());
        <span class="hljs-comment">//ensure it's still a map (by overwriting a key, but with a new value) </span>
        map.put(<span class="hljs-string">"d"</span>, <span class="hljs-number">2</span>);
        assertEquals(<span class="hljs-string">"b"</span>, map.firstKey());
        <span class="hljs-comment">//Ensure multiple values do not clobber keys</span>
        map.put(<span class="hljs-string">"e"</span>, <span class="hljs-number">2</span>);
        assertEquals(<span class="hljs-number">5</span>, map.size());
        assertEquals(<span class="hljs-number">2</span>, (<span class="hljs-type">int</span>) map.get(<span class="hljs-string">"e"</span>));
        assertEquals(<span class="hljs-number">2</span>, (<span class="hljs-type">int</span>) map.get(<span class="hljs-string">"d"</span>));
    }
 }
</code></pre>

<p>When we put, we ensure that the hash map has the value for the comparator, and then put to the TreeSet for sorting. But before that we check the hash map to see that the key is not actually a duplicate. Also, the comparator that we create will also include the key so that duplicate values don't delete the non-duplicate keys (due to == comparison).
These 2 items are <em>vital</em> for ensuring the map contract is kept; if you think you don't want that, then you're almost at the point of reversing the map entirely (to <code>Map&lt;V,K&gt;</code>).</p>

<p>The constructor would need to be called as </p>

<pre class="lang-java s-code-block"><code class="hljs language-java"> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ValueComparableMap</span>(Ordering.natural());
 <span class="hljs-comment">//or</span>
 <span class="hljs-keyword">new</span> <span class="hljs-title class_">ValueComparableMap</span>(Ordering.from(comparator));
</code></pre>
    </div></div></div></div><div id="solution5" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 5</h1><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>From <a href="http://www.programmersheaven.com/download/49349/download.aspx" rel="noreferrer">http://www.programmersheaven.com/download/49349/download.aspx</a></p>

<pre class="lang-java s-code-block"><code class="hljs language-java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> &lt;K, V&gt; Map&lt;K, V&gt; <span class="hljs-title function_">sortByValue</span><span class="hljs-params">(Map&lt;K, V&gt; map)</span> {
    List&lt;Entry&lt;K, V&gt;&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;(map.entrySet());
    Collections.sort(list, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Comparator</span>&lt;Object&gt;() {
        <span class="hljs-meta">@SuppressWarnings("unchecked")</span>
        <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(Object o1, Object o2)</span> {
            <span class="hljs-keyword">return</span> ((Comparable&lt;V&gt;) ((Map.Entry&lt;K, V&gt;) (o1)).getValue()).compareTo(((Map.Entry&lt;K, V&gt;) (o2)).getValue());
        }
    });

    Map&lt;K, V&gt; result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedHashMap</span>&lt;&gt;();
    <span class="hljs-keyword">for</span> (Iterator&lt;Entry&lt;K, V&gt;&gt; it = list.iterator(); it.hasNext();) {
        Map.Entry&lt;K, V&gt; entry = (Map.Entry&lt;K, V&gt;) it.next();
        result.put(entry.getKey(), entry.getValue());
    }

    <span class="hljs-keyword">return</span> result;
}
</code></pre>
    </div></div></div></div><div id="solution6" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 6</h1><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>With Java 8, you can use the <a href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/package-summary.html" rel="noreferrer">streams api</a> to do it in a significantly less verbose way:</p>

<pre class="lang-java s-code-block"><code class="hljs language-java">Map&lt;K, V&gt; sortedMap = map.entrySet().stream()
                         .sorted(Entry.comparingByValue())
                         .collect(Collectors.toMap(Entry::getKey, Entry::getValue, (e1, e2) -&gt; e1, LinkedHashMap::<span class="hljs-keyword">new</span>));
</code></pre>
    </div></div></div></div><div id="solution7" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 7</h1><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Sorting the keys requires the Comparator to look up each value for each comparison. A more scalable solution would use the entrySet directly, since then the value would be immediately available for each comparison (although I haven't backed this up by numbers).</p>

<p>Here's a generic version of such a thing:</p>

<pre class="lang-java s-code-block"><code class="hljs language-java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;K, V <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Comparable</span>&lt;? <span class="hljs-built_in">super</span> V&gt;&gt; List&lt;K&gt; <span class="hljs-title function_">getKeysSortedByValue</span><span class="hljs-params">(Map&lt;K, V&gt; map)</span> {
    <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> map.size();
    <span class="hljs-keyword">final</span> List&lt;Map.Entry&lt;K, V&gt;&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Map.Entry&lt;K, V&gt;&gt;(size);
    list.addAll(map.entrySet());
    <span class="hljs-keyword">final</span> ValueComparator&lt;V&gt; cmp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ValueComparator</span>&lt;V&gt;();
    Collections.sort(list, cmp);
    <span class="hljs-keyword">final</span> List&lt;K&gt; keys = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;K&gt;(size);
    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; size; i++) {
        keys.set(i, list.get(i).getKey());
    }
    <span class="hljs-keyword">return</span> keys;
}

<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ValueComparator</span>&lt;V <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Comparable</span>&lt;? <span class="hljs-built_in">super</span> V&gt;&gt;
                                     <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Comparator</span>&lt;Map.Entry&lt;?, V&gt;&gt; {
    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(Map.Entry&lt;?, V&gt; o1, Map.Entry&lt;?, V&gt; o2)</span> {
        <span class="hljs-keyword">return</span> o1.getValue().compareTo(o2.getValue());
    }
}
</code></pre>

<p>There are ways to lessen memory rotation for the above solution. The first ArrayList created could for instance be re-used as a return value; this would require suppression of some generics warnings, but it might be worth it for re-usable library code. Also,  the Comparator does not have to be re-allocated at every invocation.</p>

<p>Here's a more efficient albeit less appealing version:</p>

<pre class="lang-java s-code-block"><code class="hljs language-java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;K, V <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Comparable</span>&lt;? <span class="hljs-built_in">super</span> V&gt;&gt; List&lt;K&gt; <span class="hljs-title function_">getKeysSortedByValue2</span><span class="hljs-params">(Map&lt;K, V&gt; map)</span> {
    <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> map.size();
    <span class="hljs-keyword">final</span> <span class="hljs-type">List</span> <span class="hljs-variable">reusedList</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>(size);
    <span class="hljs-keyword">final</span> List&lt;Map.Entry&lt;K, V&gt;&gt; meView = reusedList;
    meView.addAll(map.entrySet());
    Collections.sort(meView, SINGLE);
    <span class="hljs-keyword">final</span> List&lt;K&gt; keyView = reusedList;
    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; size; i++) {
        keyView.set(i, meView.get(i).getKey());
    }
    <span class="hljs-keyword">return</span> keyView;
}

<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Comparator</span> <span class="hljs-variable">SINGLE</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ValueComparator</span>();
</code></pre>

<p>Finally, if you need to continously access the sorted information (rather than just sorting it once in a while), you can use an additional multi map. Let me know if you need more details...</p>
    </div></div></div></div><div id="solution8" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 8</h1><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>The commons-collections library contains a solution called <a href="http://commons.apache.org/collections/api-release/org/apache/commons/collections/bidimap/TreeBidiMap.html" rel="noreferrer">TreeBidiMap</a>. Or, you could have a look at the Google Collections API. It has <a href="http://google-collections.googlecode.com/svn/trunk/javadoc/com/google/common/collect/TreeMultimap.html" rel="noreferrer">TreeMultimap</a> which you could use.</p>

<p>And if you don't want to use these framework... they come with source code.</p>
    </div></div></div></div><div id="solution9" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 9</h1><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>I've looked at the given answers, but a lot of them are more complicated than needed or remove map elements when several keys have same value.</p>

<p>Here is a solution that I think fits better:</p>

<pre class="lang-java s-code-block"><code class="hljs language-java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;K, V <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Comparable</span>&lt;V&gt;&gt; Map&lt;K, V&gt; <span class="hljs-title function_">sortByValues</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Map&lt;K, V&gt; map)</span> {
    Comparator&lt;K&gt; valueComparator =  <span class="hljs-keyword">new</span> <span class="hljs-title class_">Comparator</span>&lt;K&gt;() {
        <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(K k1, K k2)</span> {
            <span class="hljs-type">int</span> <span class="hljs-variable">compare</span> <span class="hljs-operator">=</span> map.get(k2).compareTo(map.get(k1));
            <span class="hljs-keyword">if</span> (compare == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
            <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> compare;
        }
    };
    Map&lt;K, V&gt; sortedByValues = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeMap</span>&lt;K, V&gt;(valueComparator);
    sortedByValues.putAll(map);
    <span class="hljs-keyword">return</span> sortedByValues;
}
</code></pre>

<p>Note that the map is sorted from the highest value to the lowest.</p>
    </div></div></div></div><div id="solution10" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 10</h1><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p><strong>Given Map</strong></p>

<pre class="lang-java s-code-block"><code class="hljs language-java">   Map&lt;String, Integer&gt; wordCounts = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();
    wordCounts.put(<span class="hljs-string">"USA"</span>, <span class="hljs-number">100</span>);
    wordCounts.put(<span class="hljs-string">"jobs"</span>, <span class="hljs-number">200</span>);
    wordCounts.put(<span class="hljs-string">"software"</span>, <span class="hljs-number">50</span>);
    wordCounts.put(<span class="hljs-string">"technology"</span>, <span class="hljs-number">70</span>);
    wordCounts.put(<span class="hljs-string">"opportunity"</span>, <span class="hljs-number">200</span>);
</code></pre>

<p><strong>Sort the map based on the value in ascending order</strong></p>

<pre class="lang-java s-code-block"><code class="hljs language-java">Map&lt;String,Integer&gt;  sortedMap =  wordCounts.entrySet().
                                                stream().
                                                sorted(Map.Entry.comparingByValue()).
        collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue, (e1, e2) -&gt; e1, LinkedHashMap::<span class="hljs-keyword">new</span>));
    System.out.println(sortedMap);
</code></pre>

<p><strong>Sort the map based on value in desending order</strong></p>

<pre class="lang-java s-code-block"><code class="hljs language-java">Map&lt;String,Integer&gt;  sortedMapReverseOrder =  wordCounts.entrySet().
            stream().
            sorted(Map.Entry.comparingByValue(Comparator.reverseOrder())).
            collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue, (e1, e2) -&gt; e1, LinkedHashMap::<span class="hljs-keyword">new</span>));
    System.out.println(sortedMapReverseOrder);
</code></pre>

<p><strong>Output:</strong></p>

<p>{software=50, technology=70, USA=100, jobs=200, opportunity=200}</p>

<p>{jobs=200, opportunity=200, USA=100, technology=70, software=50}</p>
    </div></div></div></div><div id="solution11" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 11</h1><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>To accomplish this with the new features in Java 8:</p>

<pre class="lang-java s-code-block"><code class="hljs language-java"><span class="hljs-keyword">import</span> <span class="hljs-keyword">static</span> java.util.Map.Entry.comparingByValue;
<span class="hljs-keyword">import</span> <span class="hljs-keyword">static</span> java.util.stream.Collectors.toList;

&lt;K, V&gt; List&lt;Entry&lt;K, V&gt;&gt; <span class="hljs-title function_">sort</span><span class="hljs-params">(Map&lt;K, V&gt; map, Comparator&lt;? <span class="hljs-built_in">super</span> V&gt; comparator)</span> {
    <span class="hljs-keyword">return</span> map.entrySet().stream().sorted(comparingByValue(comparator)).collect(toList());
}
</code></pre>

<p>The entries are ordered by their values using the given comparator. Alternatively, if your values are mutually comparable, no explicit comparator is needed:</p>

<pre class="lang-java s-code-block"><code class="hljs language-java">&lt;K, V <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Comparable</span>&lt;? <span class="hljs-built_in">super</span> V&gt;&gt; List&lt;Entry&lt;K, V&gt;&gt; <span class="hljs-title function_">sort</span><span class="hljs-params">(Map&lt;K, V&gt; map)</span> {
    <span class="hljs-keyword">return</span> map.entrySet().stream().sorted(comparingByValue()).collect(toList());
}
</code></pre>

<p>The returned list is a snapshot of the given map at the time this method is called, so neither will reflect subsequent changes to the other. For a live iterable view of the map:</p>

<pre class="lang-java s-code-block"><code class="hljs language-java">&lt;K, V <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Comparable</span>&lt;? <span class="hljs-built_in">super</span> V&gt;&gt; Iterable&lt;Entry&lt;K, V&gt;&gt; <span class="hljs-title function_">sort</span><span class="hljs-params">(Map&lt;K, V&gt; map)</span> {
    <span class="hljs-keyword">return</span> () -&gt; map.entrySet().stream().sorted(comparingByValue()).iterator();
}
</code></pre>

<p>The returned iterable creates a fresh snapshot of the given map each time it's iterated, so barring concurrent modification, it will always reflect the current state of the map.</p>
    </div></div></div></div><div id="solution12" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 12</h1><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Create customized comparator and use it while creating new TreeMap object.</p>

<pre class="lang-java s-code-block"><code class="hljs language-java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyComparator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Comparator</span>&lt;Object&gt; {

    Map&lt;String, Integer&gt; map;

    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MyComparator</span><span class="hljs-params">(Map&lt;String, Integer&gt; map)</span> {
        <span class="hljs-built_in">this</span>.map = map;
    }

    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(Object o1, Object o2)</span> {

        <span class="hljs-keyword">if</span> (map.get(o2) == map.get(o1))
            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
        <span class="hljs-keyword">else</span>
            <span class="hljs-keyword">return</span> ((Integer) map.get(o2)).compareTo((Integer)     
                                                            map.get(o1));

    }
}
</code></pre>

<p>Use the below code in your main func</p>

<pre class="lang-java s-code-block"><code class="hljs language-java">    Map&lt;String, Integer&gt; lMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;String, Integer&gt;();
    lMap.put(<span class="hljs-string">"A"</span>, <span class="hljs-number">35</span>);
    lMap.put(<span class="hljs-string">"B"</span>, <span class="hljs-number">75</span>);
    lMap.put(<span class="hljs-string">"C"</span>, <span class="hljs-number">50</span>);
    lMap.put(<span class="hljs-string">"D"</span>, <span class="hljs-number">50</span>);

    <span class="hljs-type">MyComparator</span> <span class="hljs-variable">comparator</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyComparator</span>(lMap);

    Map&lt;String, Integer&gt; newMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeMap</span>&lt;String, Integer&gt;(comparator);
    newMap.putAll(lMap);
    System.out.println(newMap);
</code></pre>

<p>Output:</p>

<pre class="lang-java s-code-block"><code class="hljs language-java">{B=<span class="hljs-number">75</span>, D=<span class="hljs-number">50</span>, C=<span class="hljs-number">50</span>, A=<span class="hljs-number">35</span>}
</code></pre>
    </div></div></div></div><div id="solution13" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 13</h1><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>While I agree that the constant need to sort a map is probably a smell, I think the following code is the easiest way to do it without using a different data structure.</p>

<pre class="lang-java s-code-block"><code class="hljs language-java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MapUtilities</span> {

<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;K, V <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Comparable</span>&lt;V&gt;&gt; List&lt;Entry&lt;K, V&gt;&gt; <span class="hljs-title function_">sortByValue</span><span class="hljs-params">(Map&lt;K, V&gt; map)</span> {
    List&lt;Entry&lt;K, V&gt;&gt; entries = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Entry&lt;K, V&gt;&gt;(map.entrySet());
    Collections.sort(entries, <span class="hljs-keyword">new</span> <span class="hljs-title class_">ByValue</span>&lt;K, V&gt;());
    <span class="hljs-keyword">return</span> entries;
}

<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ByValue</span>&lt;K, V <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Comparable</span>&lt;V&gt;&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Comparator</span>&lt;Entry&lt;K, V&gt;&gt; {
    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(Entry&lt;K, V&gt; o1, Entry&lt;K, V&gt; o2)</span> {
        <span class="hljs-keyword">return</span> o1.getValue().compareTo(o2.getValue());
    }
}
</code></pre>

<p>}</p>

<p>And here is an embarrassingly incomplete unit test:</p>

<pre class="lang-java s-code-block"><code class="hljs language-java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MapUtilitiesTest</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">TestCase</span> {
<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testSorting</span><span class="hljs-params">()</span> {
    HashMap&lt;String, Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;String, Integer&gt;();
    map.put(<span class="hljs-string">"One"</span>, <span class="hljs-number">1</span>);
    map.put(<span class="hljs-string">"Two"</span>, <span class="hljs-number">2</span>);
    map.put(<span class="hljs-string">"Three"</span>, <span class="hljs-number">3</span>);

    List&lt;Map.Entry&lt;String, Integer&gt;&gt; sorted = MapUtilities.sortByValue(map);
    assertEquals(<span class="hljs-string">"First"</span>, <span class="hljs-string">"One"</span>, sorted.get(<span class="hljs-number">0</span>).getKey());
    assertEquals(<span class="hljs-string">"Second"</span>, <span class="hljs-string">"Two"</span>, sorted.get(<span class="hljs-number">1</span>).getKey());
    assertEquals(<span class="hljs-string">"Third"</span>, <span class="hljs-string">"Three"</span>, sorted.get(<span class="hljs-number">2</span>).getKey());
}
</code></pre>

<p>}</p>

<p>The result is a sorted list of Map.Entry objects, from which you can obtain the keys and values.</p>
    </div></div></div></div><div id="solution14" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 14</h1><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Use a generic comparator such as:</p>
<pre class="lang-java s-code-block"><code class="hljs language-java"><span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MapValueComparator</span>&lt;K,V <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Comparable</span>&lt;V&gt;&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Comparator</span>&lt;K&gt; {
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Map&lt;K,V&gt; map;
    
    <span class="hljs-keyword">private</span> <span class="hljs-title function_">MapValueComparator</span><span class="hljs-params">()</span> {
        <span class="hljs-built_in">super</span>();
    }
    
    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MapValueComparator</span><span class="hljs-params">(Map&lt;K,V&gt; map)</span> {
        <span class="hljs-built_in">this</span>();
        <span class="hljs-built_in">this</span>.map = map;
    }
        
    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(K o1, K o2)</span> {
        <span class="hljs-keyword">return</span> map.get(o1).compareTo(map.get(o2));
    }
}
</code></pre>
    </div></div></div></div><div id="solution15" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 15</h1><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>The answer voted for the most does not work when you have 2 items that equals.
the TreeMap leaves equal values out.</p>

<p>the exmaple:
unsorted map</p>

<pre>key/value: D/67.3
key/value: A/99.5
key/value: B/67.4
key/value: C/67.5
key/value: E/99.5
</pre>

<p>results</p>

<pre>key/value: A/99.5
key/value: C/67.5
key/value: B/67.4
key/value: D/67.3
</pre>

<p>So leaves out E!!</p>

<p>For me it worked fine to adjust the comparator, if it equals do not return 0 but -1.</p>

<p>in the example:</p>

<blockquote>
  <blockquote>
    <p>class ValueComparator implements Comparator {</p>
    
    <p>Map base;
      public ValueComparator(Map base) {
          this.base = base;
      }</p>
    
    <p>public int compare(Object a, Object b) {</p>

<pre class="lang-java s-code-block"><code class="hljs language-java"><span class="hljs-keyword">if</span>((Double)base.get(a) &lt; (Double)base.get(b)) {
  <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>((Double)base.get(a) == (Double)base.get(b)) {
  <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;
} <span class="hljs-keyword">else</span> {
  <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;
}
</code></pre>
    
    <p>}
    }</p>
  </blockquote>
</blockquote>

<p>now it returns:</p>

<p>unsorted map:</p>

<pre>key/value: D/67.3
key/value: A/99.5
key/value: B/67.4
key/value: C/67.5
key/value: E/99.5
</pre>

<p>results:</p>

<pre>key/value: A/99.5
key/value: E/99.5
key/value: C/67.5
key/value: B/67.4
key/value: D/67.3
</pre>

<p>as a response to Aliens (2011 nov. 22):
I Am using this solution for a map of Integer Id's and names, but the idea is the same, so might be the code above is not correct (I will write it in a test and give you the correct code), this is the code for a Map sorting, based on the solution above:</p>

<pre class="lang-java s-code-block"><code class="hljs language-java"><span class="hljs-keyword">package</span> nl.iamit.util;

<span class="hljs-keyword">import</span> java.util.Comparator;
<span class="hljs-keyword">import</span> java.util.Map;

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Comparators</span> {


    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MapIntegerStringComparator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Comparator</span> {

        Map&lt;Integer, String&gt; base;

        <span class="hljs-keyword">public</span> <span class="hljs-title function_">MapIntegerStringComparator</span><span class="hljs-params">(Map&lt;Integer, String&gt; base)</span> {
            <span class="hljs-built_in">this</span>.base = base;
        }

        <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(Object a, Object b)</span> {

            <span class="hljs-type">int</span> <span class="hljs-variable">compare</span> <span class="hljs-operator">=</span> ((String) base.get(a))
                    .compareTo((String) base.get(b));
            <span class="hljs-keyword">if</span> (compare == <span class="hljs-number">0</span>) {
                <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;
            }
            <span class="hljs-keyword">return</span> compare;
        }
    }


}
</code></pre>

<p>and this is the test class (I just tested it, and this works for the Integer, String Map:</p>

<pre class="lang-java s-code-block"><code class="hljs language-java"><span class="hljs-keyword">package</span> test.nl.iamit.util;

<span class="hljs-keyword">import</span> java.util.HashMap;
<span class="hljs-keyword">import</span> java.util.TreeMap;
<span class="hljs-keyword">import</span> nl.iamit.util.Comparators;
<span class="hljs-keyword">import</span> org.junit.Test;
<span class="hljs-keyword">import</span> <span class="hljs-keyword">static</span> org.junit.Assert.assertArrayEquals;

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestComparators</span> {


    <span class="hljs-meta">@Test</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testMapIntegerStringComparator</span><span class="hljs-params">()</span>{
        HashMap&lt;Integer, String&gt; unSoretedMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;Integer, String&gt;();
        Comparators.<span class="hljs-type">MapIntegerStringComparator</span> <span class="hljs-variable">bvc</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Comparators</span>.MapIntegerStringComparator(
                unSoretedMap);
        TreeMap&lt;Integer, String&gt; sorted_map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeMap</span>&lt;Integer, String&gt;(bvc);
        <span class="hljs-comment">//the testdata:</span>
        unSoretedMap.put(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>(<span class="hljs-number">1</span>), <span class="hljs-string">"E"</span>);
        unSoretedMap.put(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>(<span class="hljs-number">2</span>), <span class="hljs-string">"A"</span>);
        unSoretedMap.put(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>(<span class="hljs-number">3</span>), <span class="hljs-string">"E"</span>);
        unSoretedMap.put(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>(<span class="hljs-number">4</span>), <span class="hljs-string">"B"</span>);
        unSoretedMap.put(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>(<span class="hljs-number">5</span>), <span class="hljs-string">"F"</span>);

        sorted_map.putAll(unSoretedMap);

        Object[] targetKeys={<span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>(<span class="hljs-number">2</span>),<span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>(<span class="hljs-number">4</span>),<span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>(<span class="hljs-number">3</span>),<span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>(<span class="hljs-number">1</span>),<span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>(<span class="hljs-number">5</span>) };
        Object[] currecntKeys=sorted_map.keySet().toArray();

        assertArrayEquals(targetKeys,currecntKeys);
    }
}
</code></pre>

<p>here is the code for the Comparator of a Map:</p>

<pre class="lang-java s-code-block"><code class="hljs language-java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MapStringDoubleComparator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Comparator</span> {

    Map&lt;String, Double&gt; base;

    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MapStringDoubleComparator</span><span class="hljs-params">(Map&lt;String, Double&gt; base)</span> {
        <span class="hljs-built_in">this</span>.base = base;
    }

    <span class="hljs-comment">//note if you want decending in stead of ascending, turn around 1 and -1</span>
    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(Object a, Object b)</span> {
        <span class="hljs-keyword">if</span> ((Double) base.get(a) == (Double) base.get(b)) {
            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>((Double) base.get(a) &lt; (Double) base.get(b)) {
            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;
        }<span class="hljs-keyword">else</span>{
            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
        }
    }
}
</code></pre>

<p>and this is the testcase for this:</p>

<pre class="lang-java s-code-block"><code class="hljs language-java"><span class="hljs-meta">@Test</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testMapStringDoubleComparator</span><span class="hljs-params">()</span>{
    HashMap&lt;String, Double&gt; unSoretedMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;String, Double&gt;();
    Comparators.<span class="hljs-type">MapStringDoubleComparator</span> <span class="hljs-variable">bvc</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Comparators</span>.MapStringDoubleComparator(
            unSoretedMap);
    TreeMap&lt;String, Double&gt; sorted_map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeMap</span>&lt;String, Double&gt;(bvc);
    <span class="hljs-comment">//the testdata:</span>
    unSoretedMap.put(<span class="hljs-string">"D"</span>,<span class="hljs-keyword">new</span> <span class="hljs-title class_">Double</span>(<span class="hljs-number">67.3</span>));
    unSoretedMap.put(<span class="hljs-string">"A"</span>,<span class="hljs-keyword">new</span> <span class="hljs-title class_">Double</span>(<span class="hljs-number">99.5</span>));
    unSoretedMap.put(<span class="hljs-string">"B"</span>,<span class="hljs-keyword">new</span> <span class="hljs-title class_">Double</span>(<span class="hljs-number">67.4</span>));
    unSoretedMap.put(<span class="hljs-string">"C"</span>,<span class="hljs-keyword">new</span> <span class="hljs-title class_">Double</span>(<span class="hljs-number">67.5</span>));
    unSoretedMap.put(<span class="hljs-string">"E"</span>,<span class="hljs-keyword">new</span> <span class="hljs-title class_">Double</span>(<span class="hljs-number">99.5</span>));

    sorted_map.putAll(unSoretedMap);

    Object[] targetKeys={<span class="hljs-string">"D"</span>,<span class="hljs-string">"B"</span>,<span class="hljs-string">"C"</span>,<span class="hljs-string">"E"</span>,<span class="hljs-string">"A"</span>};
    Object[] currecntKeys=sorted_map.keySet().toArray();

    assertArrayEquals(targetKeys,currecntKeys);
}
</code></pre>

<p>of cource you can make this a lot more generic, but I just needed it for 1 case (the Map)</p>
    </div></div></div></div><div id="solution16" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 16</h1><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Instead of using <code>Collections.sort</code> as some do I'd suggest using <code>Arrays.sort</code>. Actually what <code>Collections.sort</code> does is something like this:</p>

<pre class="lang-java s-code-block"><code class="hljs language-java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Comparable</span>&lt;? <span class="hljs-built_in">super</span> T&gt;&gt; <span class="hljs-keyword">void</span> <span class="hljs-title function_">sort</span><span class="hljs-params">(List&lt;T&gt; list)</span> {
    Object[] a = list.toArray();
    Arrays.sort(a);
    ListIterator&lt;T&gt; i = list.listIterator();
    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>; j&lt;a.length; j++) {
        i.next();
        i.set((T)a[j]);
    }
}
</code></pre>

<p>It just calls <code>toArray</code> on the list and then uses <code>Arrays.sort</code>. This way all the map entries will be copied three times: once from the map to the temporary list (be it a LinkedList or ArrayList), then to the temporary array and finally to the new map.</p>

<p>My solution ommits this one step as it does not create unnecessary LinkedList. Here is the code, generic-friendly and performance-optimal:</p>

<pre class="lang-java s-code-block"><code class="hljs language-java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;K, V <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Comparable</span>&lt;? <span class="hljs-built_in">super</span> V&gt;&gt; Map&lt;K, V&gt; <span class="hljs-title function_">sortByValue</span><span class="hljs-params">(Map&lt;K, V&gt; map)</span> 
{
    <span class="hljs-meta">@SuppressWarnings("unchecked")</span>
    Map.Entry&lt;K,V&gt;[] array = map.entrySet().toArray(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>.Entry[map.size()]);

    Arrays.sort(array, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Comparator</span>&lt;Map.Entry&lt;K, V&gt;&gt;() 
    {
        <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(Map.Entry&lt;K, V&gt; e1, Map.Entry&lt;K, V&gt; e2)</span> 
        {
            <span class="hljs-keyword">return</span> e1.getValue().compareTo(e2.getValue());
        }
    });

    Map&lt;K, V&gt; result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedHashMap</span>&lt;K, V&gt;();
    <span class="hljs-keyword">for</span> (Map.Entry&lt;K, V&gt; entry : array)
        result.put(entry.getKey(), entry.getValue());

    <span class="hljs-keyword">return</span> result;
}
</code></pre>
    </div></div></div></div><div id="solution17" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 17</h1><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>This is a variation of Anthony's answer, which doesn't work if there are duplicate values:</p>

<pre class="lang-java s-code-block"><code class="hljs language-java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;K, V <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Comparable</span>&lt;V&gt;&gt; Map&lt;K, V&gt; <span class="hljs-title function_">sortMapByValues</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Map&lt;K, V&gt; map)</span> {
    Comparator&lt;K&gt; valueComparator =  <span class="hljs-keyword">new</span> <span class="hljs-title class_">Comparator</span>&lt;K&gt;() {
        <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(K k1, K k2)</span> {
            <span class="hljs-keyword">final</span> <span class="hljs-type">V</span> <span class="hljs-variable">v1</span> <span class="hljs-operator">=</span> map.get(k1);
            <span class="hljs-keyword">final</span> <span class="hljs-type">V</span> <span class="hljs-variable">v2</span> <span class="hljs-operator">=</span> map.get(k2);

            <span class="hljs-comment">/* Not sure how to handle nulls ... */</span>
            <span class="hljs-keyword">if</span> (v1 == <span class="hljs-literal">null</span>) {
                <span class="hljs-keyword">return</span> (v2 == <span class="hljs-literal">null</span>) ? <span class="hljs-number">0</span> : <span class="hljs-number">1</span>;
            }

            <span class="hljs-type">int</span> <span class="hljs-variable">compare</span> <span class="hljs-operator">=</span> v2.compareTo(v1);
            <span class="hljs-keyword">if</span> (compare != <span class="hljs-number">0</span>)
            {
                <span class="hljs-keyword">return</span> compare;
            }
            <span class="hljs-keyword">else</span>
            {
                <span class="hljs-type">Integer</span> <span class="hljs-variable">h1</span> <span class="hljs-operator">=</span> k1.hashCode();
                <span class="hljs-type">Integer</span> <span class="hljs-variable">h2</span> <span class="hljs-operator">=</span> k2.hashCode();
                <span class="hljs-keyword">return</span> h2.compareTo(h1);
            }
        }
    };
    Map&lt;K, V&gt; sortedByValues = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeMap</span>&lt;K, V&gt;(valueComparator);
    sortedByValues.putAll(map);
    <span class="hljs-keyword">return</span> sortedByValues;
}
</code></pre>

<p>Note that it's rather up in the air how to handle nulls. </p>

<p>One important advantage of this approach is that it actually returns a Map, unlike some of the other solutions offered here.</p>
    </div></div></div></div><div id="solution18" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 18</h1><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p><strong>Best Approach</strong></p>

<pre class="lang-java s-code-block"><code class="hljs language-java"><span class="hljs-keyword">import</span> java.util.ArrayList;
<span class="hljs-keyword">import</span> java.util.Collections;
<span class="hljs-keyword">import</span> java.util.Comparator;
<span class="hljs-keyword">import</span> java.util.HashMap;
<span class="hljs-keyword">import</span> java.util.List;
<span class="hljs-keyword">import</span> java.util.Map;
<span class="hljs-keyword">import</span> java.util.Set;
<span class="hljs-keyword">import</span> java.util.Map.Entry; 

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OrderByValue</span> {

  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String a[])</span>{
    Map&lt;String, Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;String, Integer&gt;();
    map.put(<span class="hljs-string">"java"</span>, <span class="hljs-number">20</span>);
    map.put(<span class="hljs-string">"C++"</span>, <span class="hljs-number">45</span>);
    map.put(<span class="hljs-string">"Unix"</span>, <span class="hljs-number">67</span>);
    map.put(<span class="hljs-string">"MAC"</span>, <span class="hljs-number">26</span>);
    map.put(<span class="hljs-string">"Why this kolavari"</span>, <span class="hljs-number">93</span>);
    Set&lt;Entry&lt;String, Integer&gt;&gt; set = map.entrySet();
    List&lt;Entry&lt;String, Integer&gt;&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Entry&lt;String, Integer&gt;&gt;(set);
    Collections.sort( list, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Comparator</span>&lt;Map.Entry&lt;String, Integer&gt;&gt;()
    {
        <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">( Map.Entry&lt;String, Integer&gt; o1, Map.Entry&lt;String, Integer&gt; o2 )</span>
        {
            <span class="hljs-keyword">return</span> (o1.getValue()).compareTo( o2.getValue() );<span class="hljs-comment">//Ascending order</span>
            <span class="hljs-comment">//return (o2.getValue()).compareTo( o1.getValue() );//Descending order</span>
        }
    } );
    <span class="hljs-keyword">for</span>(Map.Entry&lt;String, Integer&gt; entry:list){
        System.out.println(entry.getKey()+<span class="hljs-string">" ==== "</span>+entry.getValue());
    }
  }}
</code></pre>

<p><strong>Output</strong></p>

<pre class="lang-java s-code-block"><code class="hljs language-java">java ==== <span class="hljs-number">20</span>

MAC ==== <span class="hljs-number">26</span>

C++ ==== <span class="hljs-number">45</span>

Unix ==== <span class="hljs-number">67</span>

Why <span class="hljs-type">this</span> <span class="hljs-variable">kolavari</span> <span class="hljs-operator">=</span>=== <span class="hljs-number">93</span>
</code></pre>
    </div></div></div></div><div id="solution19" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 19</h1><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Late Entry.</p>

<p>With the advent of Java-8, we can use streams for data manipulation in a very easy/succinct way. You can use streams to sort the map entries by value and create a <a href="https://docs.oracle.com/javase/8/docs/api/java/util/LinkedHashMap.html" rel="noreferrer">LinkedHashMap</a> which preserves <em>insertion-order</em> iteration.</p>

<p>Eg:</p>

<pre class="lang-java s-code-block"><code class="hljs language-java"><span class="hljs-type">LinkedHashMap</span> <span class="hljs-variable">sortedByValueMap</span> <span class="hljs-operator">=</span> map.entrySet().stream()
                .sorted(comparing(Entry&lt;Key,Value&gt;::getValue).thenComparing(Entry::getKey))     <span class="hljs-comment">//first sorting by Value, then sorting by Key(entries with same value)</span>
                .collect(LinkedHashMap::<span class="hljs-keyword">new</span>,(map,entry) -&gt; map.put(entry.getKey(),entry.getValue()),LinkedHashMap::putAll);
</code></pre>

<hr>

<p>For reverse ordering, replace:</p>

<pre class="lang-java s-code-block"><code class="hljs language-java">comparing(Entry&lt;Key,Value&gt;::getValue).thenComparing(Entry::getKey)
</code></pre>

<p>with</p>

<pre class="lang-java s-code-block"><code class="hljs language-java">comparing(Entry&lt;Key,Value&gt;::getValue).thenComparing(Entry::getKey).reversed()
</code></pre>
    </div></div></div></div><div id="solution20" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 20</h1><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Major problem. If you use the first answer (Google takes you here), change the comparator to add an equal clause, otherwise you cannot get values from the sorted_map by keys:</p>

<pre class="lang-java s-code-block"><code class="hljs language-java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(String a, String b)</span> {
        <span class="hljs-keyword">if</span> (base.get(a) &gt; base.get(b)) {
            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (base.get(a) &lt; base.get(b)){
            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;
        } 

        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
        <span class="hljs-comment">// returning 0 would merge keys</span>
    }
</code></pre>
    </div></div></div></div><div id="solution21" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 21</h1><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>There are a lot of answers for this question already, but none provided me what I was looking for, a map implementation that returns keys and entries sorted by the associated value, and maintains this property as keys and values are modified in the map. Two <a href="https://stackoverflow.com/q/13108887/1760575">other</a> <a href="https://stackoverflow.com/q/7465369/1760575">questions</a> ask for this specifically. </p>

<p>I cooked up a generic friendly example that solves this use case. This implementation does not honor all of the contracts of the Map interface, such as reflecting value changes and removals in the sets return from keySet() and entrySet() in the original object. I felt such a solution would be too large to include in a Stack Overflow answer. If I manage to create a more complete implementation, perhaps I will post it to Github and then to it link in an updated version of this answer.</p>

<pre class="lang-java s-code-block"><code class="hljs language-java"><span class="hljs-keyword">import</span> java.util.*;

<span class="hljs-comment">/**
 * A map where {<span class="hljs-doctag">@link</span> #keySet()} and {<span class="hljs-doctag">@link</span> #entrySet()} return sets ordered
 * by associated values based on the the comparator provided at construction
 * time. The order of two or more keys with identical values is not defined.
 * &lt;p&gt;
 * Several contracts of the Map interface are not satisfied by this minimal
 * implementation.
 */</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ValueSortedMap</span>&lt;K, V&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">HashMap</span>&lt;K, V&gt; {
    <span class="hljs-keyword">protected</span> Map&lt;V, Collection&lt;K&gt;&gt; valueToKeysMap;

    <span class="hljs-comment">// uses natural order of value object, if any</span>
    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ValueSortedMap</span><span class="hljs-params">()</span> {
        <span class="hljs-built_in">this</span>((Comparator&lt;? <span class="hljs-built_in">super</span> V&gt;) <span class="hljs-literal">null</span>);
    }

    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ValueSortedMap</span><span class="hljs-params">(Comparator&lt;? <span class="hljs-built_in">super</span> V&gt; valueComparator)</span> {
        <span class="hljs-built_in">this</span>.valueToKeysMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeMap</span>&lt;V, Collection&lt;K&gt;&gt;(valueComparator);
    }

    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">containsValue</span><span class="hljs-params">(Object o)</span> {
        <span class="hljs-keyword">return</span> valueToKeysMap.containsKey(o);
    }

    <span class="hljs-keyword">public</span> V <span class="hljs-title function_">put</span><span class="hljs-params">(K k, V v)</span> {
        <span class="hljs-type">V</span> <span class="hljs-variable">oldV</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;
        <span class="hljs-keyword">if</span> (containsKey(k)) {
            oldV = get(k);
            valueToKeysMap.get(oldV).remove(k);
        }
        <span class="hljs-built_in">super</span>.put(k, v);
        <span class="hljs-keyword">if</span> (!valueToKeysMap.containsKey(v)) {
            Collection&lt;K&gt; keys = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;K&gt;();
            keys.add(k);
            valueToKeysMap.put(v, keys);
        } <span class="hljs-keyword">else</span> {
            valueToKeysMap.get(v).add(k);
        }
        <span class="hljs-keyword">return</span> oldV;
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">putAll</span><span class="hljs-params">(Map&lt;? extends K, ? extends V&gt; m)</span> {
        <span class="hljs-keyword">for</span> (Map.Entry&lt;? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">K</span>, ? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">V</span>&gt; e : m.entrySet())
            put(e.getKey(), e.getValue());
    }

    <span class="hljs-keyword">public</span> V <span class="hljs-title function_">remove</span><span class="hljs-params">(Object k)</span> {
        <span class="hljs-type">V</span> <span class="hljs-variable">oldV</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;
        <span class="hljs-keyword">if</span> (containsKey(k)) {
            oldV = get(k);
            <span class="hljs-built_in">super</span>.remove(k);
            valueToKeysMap.get(oldV).remove(k);
        }
        <span class="hljs-keyword">return</span> oldV;
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">clear</span><span class="hljs-params">()</span> {
        <span class="hljs-built_in">super</span>.clear();
        valueToKeysMap.clear();
    }

    <span class="hljs-keyword">public</span> Set&lt;K&gt; <span class="hljs-title function_">keySet</span><span class="hljs-params">()</span> {
        LinkedHashSet&lt;K&gt; ret = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedHashSet</span>&lt;K&gt;(size());
        <span class="hljs-keyword">for</span> (V v : valueToKeysMap.keySet()) {
            Collection&lt;K&gt; keys = valueToKeysMap.get(v);
            ret.addAll(keys);
        }
        <span class="hljs-keyword">return</span> ret;
    }

    <span class="hljs-keyword">public</span> Set&lt;Map.Entry&lt;K, V&gt;&gt; entrySet() {
        LinkedHashSet&lt;Map.Entry&lt;K, V&gt;&gt; ret = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedHashSet</span>&lt;Map.Entry&lt;K, V&gt;&gt;(size());
        <span class="hljs-keyword">for</span> (Collection&lt;K&gt; keys : valueToKeysMap.values()) {
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">final</span> K k : keys) {
                <span class="hljs-keyword">final</span> <span class="hljs-type">V</span> <span class="hljs-variable">v</span> <span class="hljs-operator">=</span> get(k);
                ret.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>.Entry&lt;K,V&gt;() {
                    <span class="hljs-keyword">public</span> K <span class="hljs-title function_">getKey</span><span class="hljs-params">()</span> {
                        <span class="hljs-keyword">return</span> k;
                    }

                    <span class="hljs-keyword">public</span> V <span class="hljs-title function_">getValue</span><span class="hljs-params">()</span> {
                        <span class="hljs-keyword">return</span> v;
                    }

                    <span class="hljs-keyword">public</span> V <span class="hljs-title function_">setValue</span><span class="hljs-params">(V v)</span> {
                        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UnsupportedOperationException</span>();
                    }
                });
            }
        }
        <span class="hljs-keyword">return</span> ret;
    }
}
</code></pre>
    </div></div></div></div><div id="solution22" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 22</h1><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Simple way to sort any map in Java 8 and above</p>
<pre class="lang-java s-code-block"><code class="hljs language-java">Map&lt;String, Object&gt; mapToSort = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();

List&lt;Map.Entry&lt;String, Object&gt;&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;(mapToSort.entrySet());

Collections.sort(list, Comparator.comparing(o -&gt; o.getValue().getAttribute()));

HashMap&lt;String, Object&gt; sortedMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedHashMap</span>&lt;&gt;();
<span class="hljs-keyword">for</span> (Map.Entry&lt;String, Object&gt; map : list) {
   sortedMap.put(map.getKey(), map.getValue());
}
</code></pre>
<p>if you are using Java 7 and below</p>
<pre class="lang-java s-code-block"><code class="hljs language-java">Map&lt;String, Object&gt; mapToSort = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();

List&lt;Map.Entry&lt;String, Object&gt;&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;(mapToSort.entrySet());

Collections.sort(list, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Comparator</span>&lt;Map.Entry&lt;String, Object&gt;&gt;() {
    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(Map.Entry&lt;String, Object&gt; o1, Map.Entry&lt;String, Object&gt; o2)</span> {
       <span class="hljs-keyword">return</span> o1.getValue().getAttribute().compareTo(o2.getValue().getAttribute());      
    }
});

HashMap&lt;String, Object&gt; sortedMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedHashMap</span>&lt;&gt;();
<span class="hljs-keyword">for</span> (Map.Entry&lt;String, Object&gt; map : list) {
   sortedMap.put(map.getKey(), map.getValue());
}
</code></pre>
    </div></div></div></div><div id="solution23" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 23</h1><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Depending on the context, using <code>java.util.LinkedHashMap&lt;T&gt;</code> which rememebers the order in which items are placed into the map.  Otherwise, if you need to sort values based on their natural ordering, I would recommend maintaining a separate List which can be sorted via <code>Collections.sort()</code>.</p>
    </div></div></div></div><div id="solution24" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 24</h1><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Afaik the most cleaner way is utilizing collections to sort map on value:</p>

<pre class="lang-java s-code-block"><code class="hljs language-java">Map&lt;String, Long&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;String, Long&gt;();
<span class="hljs-comment">// populate with data to sort on Value</span>
<span class="hljs-comment">// use datastructure designed for sorting</span>

<span class="hljs-type">Queue</span> <span class="hljs-variable">queue</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>( map.size(), <span class="hljs-keyword">new</span> <span class="hljs-title class_">MapComparable</span>() );
queue.addAll( map.entrySet() );

<span class="hljs-comment">// get a sorted map</span>
LinkedHashMap&lt;String, Long&gt; linkedMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedHashMap</span>&lt;String, Long&gt;();

<span class="hljs-keyword">for</span> (Map.Entry&lt;String, Long&gt; entry; (entry = queue.poll())!=<span class="hljs-literal">null</span>;) {
    linkedMap.put(entry.getKey(), entry.getValue());
}

<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MapComparable</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Comparator</span>&lt;Map.Entry&lt;String, Long&gt;&gt;{

  <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(Entry&lt;String, Long&gt; e1, Entry&lt;String, Long&gt; e2)</span> {
    <span class="hljs-keyword">return</span> e1.getValue().compareTo(e2.getValue());
  }
}
</code></pre>
    </div></div></div></div><div id="solution25" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 25</h1><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Since <strong><em>TreeMap&lt;&gt; does not work</em></strong> for values that can be equal, I used this:</p>

<pre class="lang-java s-code-block"><code class="hljs language-java"><span class="hljs-keyword">private</span> &lt;K, V <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Comparable</span>&lt;? <span class="hljs-built_in">super</span> V&gt;&gt; List&lt;Entry&lt;K, V&gt;&gt; <span class="hljs-title function_">sort</span><span class="hljs-params">(Map&lt;K, V&gt; map)</span>     {
    List&lt;Map.Entry&lt;K, V&gt;&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;Map.Entry&lt;K, V&gt;&gt;(map.entrySet());
    Collections.sort(list, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Comparator</span>&lt;Map.Entry&lt;K, V&gt;&gt;() {
        <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(Map.Entry&lt;K, V&gt; o1, Map.Entry&lt;K, V&gt; o2)</span> {
            <span class="hljs-keyword">return</span> o1.getValue().compareTo(o2.getValue());
        }
    });

    <span class="hljs-keyword">return</span> list;
}
</code></pre>

<p>You might want to put <strong><em>list</em></strong> in a <strong><em>LinkedHashMap</em></strong>, but if you're only going to iterate over it right away, that's superfluous...</p>
    </div></div></div></div><div id="solution26" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 26</h1><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>This is just too complicated. Maps were not supposed to do such job as sorting them by Value. The easiest way is to create your own Class so it fits your requirement.</p>

<p>In example lower you are supposed to add TreeMap a comparator at place where * is. But by java API it gives comparator only keys, not values. All of examples stated here is based on 2 Maps. One Hash and one new Tree. Which is odd.</p>

<p>The example:</p>

<pre class="lang-java s-code-block"><code class="hljs language-java">Map&lt;Driver driver, Float time&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeMap</span>&lt;Driver driver, Float time&gt;(*);
</code></pre>

<p>So change the map into a set this way:</p>

<pre class="lang-java s-code-block"><code class="hljs language-java"><span class="hljs-type">ResultComparator</span> <span class="hljs-variable">rc</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ResultComparator</span>();
Set&lt;Results&gt; set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeSet</span>&lt;Results&gt;(rc);
</code></pre>

<p>You will create class <code>Results</code>,</p>

<pre class="lang-java s-code-block"><code class="hljs language-java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Results</span> {
    <span class="hljs-keyword">private</span> Driver driver;
    <span class="hljs-keyword">private</span> Float time;

    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Results</span><span class="hljs-params">(Driver driver, Float time)</span> {
        <span class="hljs-built_in">this</span>.driver = driver;
        <span class="hljs-built_in">this</span>.time = time;
    }

    <span class="hljs-keyword">public</span> Float <span class="hljs-title function_">getTime</span><span class="hljs-params">()</span> {
        <span class="hljs-keyword">return</span> time;
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setTime</span><span class="hljs-params">(Float time)</span> {
        <span class="hljs-built_in">this</span>.time = time;
    }

    <span class="hljs-keyword">public</span> Driver <span class="hljs-title function_">getDriver</span><span class="hljs-params">()</span> {
        <span class="hljs-keyword">return</span> driver;
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setDriver</span> <span class="hljs-params">(Driver driver)</span> {
        <span class="hljs-built_in">this</span>.driver = driver;
    }
}
</code></pre>

<p>and the Comparator class:</p>

<pre class="lang-java s-code-block"><code class="hljs language-java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ResultsComparator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Comparator</span>&lt;Results&gt; {
    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(Results t, Results t1)</span> {
        <span class="hljs-keyword">if</span> (t.getTime() &lt; t1.getTime()) {
            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (t.getTime() == t1.getTime()) {
            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;
        }
    }
}
</code></pre>

<p>This way you can easily add more dependencies.</p>

<p>And as the last point I'll add simple iterator:</p>

<pre class="lang-java s-code-block"><code class="hljs language-java"><span class="hljs-type">Iterator</span> <span class="hljs-variable">it</span> <span class="hljs-operator">=</span> set.iterator();
<span class="hljs-keyword">while</span> (it.hasNext()) {
    <span class="hljs-type">Results</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> (Results)it.next();
    System.out.println( r.getDriver().toString
        <span class="hljs-comment">//or whatever that is related to Driver class -getName() getSurname()</span>
        + <span class="hljs-string">" "</span>
        + r.getTime()
        );
}
</code></pre>
    </div></div></div></div><div id="solution27" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 27</h1><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Based on @devinmoore code, a map sorting methods using generics and supporting both ascending and descending ordering.</p>

<pre class="lang-java s-code-block"><code class="hljs language-java"><span class="hljs-comment">/**
 * Sort a map by it's keys in ascending order. 
 *  
 * <span class="hljs-doctag">@return</span> new instance of {<span class="hljs-doctag">@link</span> LinkedHashMap} contained sorted entries of supplied map.
 * <span class="hljs-doctag">@author</span> Maxim Veksler
 */</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;K, V&gt; LinkedHashMap&lt;K, V&gt; <span class="hljs-title function_">sortMapByKey</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Map&lt;K, V&gt; map)</span> {
    <span class="hljs-keyword">return</span> sortMapByKey(map, SortingOrder.ASCENDING);
}

<span class="hljs-comment">/**
 * Sort a map by it's values in ascending order.
 *  
 * <span class="hljs-doctag">@return</span> new instance of {<span class="hljs-doctag">@link</span> LinkedHashMap} contained sorted entries of supplied map.
 * <span class="hljs-doctag">@author</span> Maxim Veksler
 */</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;K, V&gt; LinkedHashMap&lt;K, V&gt; <span class="hljs-title function_">sortMapByValue</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Map&lt;K, V&gt; map)</span> {
    <span class="hljs-keyword">return</span> sortMapByValue(map, SortingOrder.ASCENDING);
}

<span class="hljs-comment">/**
 * Sort a map by it's keys.
 *  
 * <span class="hljs-doctag">@param</span> sortingOrder {<span class="hljs-doctag">@link</span> SortingOrder} enum specifying requested sorting order. 
 * <span class="hljs-doctag">@return</span> new instance of {<span class="hljs-doctag">@link</span> LinkedHashMap} contained sorted entries of supplied map.
 * <span class="hljs-doctag">@author</span> Maxim Veksler
 */</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;K, V&gt; LinkedHashMap&lt;K, V&gt; <span class="hljs-title function_">sortMapByKey</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Map&lt;K, V&gt; map, <span class="hljs-keyword">final</span> SortingOrder sortingOrder)</span> {
    Comparator&lt;Map.Entry&lt;K, V&gt;&gt; comparator = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Comparator</span>&lt;Entry&lt;K,V&gt;&gt;() {
        <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(Entry&lt;K, V&gt; o1, Entry&lt;K, V&gt; o2)</span> {
            <span class="hljs-keyword">return</span> comparableCompare(o1.getKey(), o2.getKey(), sortingOrder);
        }
    };

    <span class="hljs-keyword">return</span> sortMap(map, comparator);
}

<span class="hljs-comment">/**
 * Sort a map by it's values.
 *  
 * <span class="hljs-doctag">@param</span> sortingOrder {<span class="hljs-doctag">@link</span> SortingOrder} enum specifying requested sorting order. 
 * <span class="hljs-doctag">@return</span> new instance of {<span class="hljs-doctag">@link</span> LinkedHashMap} contained sorted entries of supplied map.
 * <span class="hljs-doctag">@author</span> Maxim Veksler
 */</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;K, V&gt; LinkedHashMap&lt;K, V&gt; <span class="hljs-title function_">sortMapByValue</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Map&lt;K, V&gt; map, <span class="hljs-keyword">final</span> SortingOrder sortingOrder)</span> {
    Comparator&lt;Map.Entry&lt;K, V&gt;&gt; comparator = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Comparator</span>&lt;Entry&lt;K,V&gt;&gt;() {
        <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(Entry&lt;K, V&gt; o1, Entry&lt;K, V&gt; o2)</span> {
            <span class="hljs-keyword">return</span> comparableCompare(o1.getValue(), o2.getValue(), sortingOrder);
        }
    };

    <span class="hljs-keyword">return</span> sortMap(map, comparator);
}

<span class="hljs-meta">@SuppressWarnings("unchecked")</span>
<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-type">int</span> <span class="hljs-title function_">comparableCompare</span><span class="hljs-params">(T o1, T o2, SortingOrder sortingOrder)</span> {
    <span class="hljs-type">int</span> <span class="hljs-variable">compare</span> <span class="hljs-operator">=</span> ((Comparable&lt;T&gt;)o1).compareTo(o2);

    <span class="hljs-keyword">switch</span> (sortingOrder) {
    <span class="hljs-keyword">case</span> ASCENDING:
        <span class="hljs-keyword">return</span> compare;
    <span class="hljs-keyword">case</span> DESCENDING:
        <span class="hljs-keyword">return</span> (-<span class="hljs-number">1</span>) * compare;
    }

    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}

<span class="hljs-comment">/**
 * Sort a map by supplied comparator logic.
 *  
 * <span class="hljs-doctag">@return</span> new instance of {<span class="hljs-doctag">@link</span> LinkedHashMap} contained sorted entries of supplied map.
 * <span class="hljs-doctag">@author</span> Maxim Veksler
 */</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;K, V&gt; LinkedHashMap&lt;K, V&gt; <span class="hljs-title function_">sortMap</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Map&lt;K, V&gt; map, <span class="hljs-keyword">final</span> Comparator&lt;Map.Entry&lt;K, V&gt;&gt; comparator)</span> {
    <span class="hljs-comment">// Convert the map into a list of key,value pairs.</span>
    List&lt;Map.Entry&lt;K, V&gt;&gt; mapEntries = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;Map.Entry&lt;K, V&gt;&gt;(map.entrySet());

    <span class="hljs-comment">// Sort the converted list according to supplied comparator.</span>
    Collections.sort(mapEntries, comparator);

    <span class="hljs-comment">// Build a new ordered map, containing the same entries as the old map.  </span>
    LinkedHashMap&lt;K, V&gt; result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedHashMap</span>&lt;K, V&gt;(map.size() + (map.size() / <span class="hljs-number">20</span>));
    <span class="hljs-keyword">for</span>(Map.Entry&lt;K, V&gt; entry : mapEntries) {
        <span class="hljs-comment">// We iterate on the mapEntries list which is sorted by the comparator putting new entries into </span>
        <span class="hljs-comment">// the targeted result which is a sorted map. </span>
        result.put(entry.getKey(), entry.getValue());
    }

    <span class="hljs-keyword">return</span> result;
}

<span class="hljs-comment">/**
 * Sorting order enum, specifying request result sort behavior.
 * <span class="hljs-doctag">@author</span> Maxim Veksler
 *
 */</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">enum</span> <span class="hljs-title class_">SortingOrder</span> {
    <span class="hljs-comment">/**
     * Resulting sort will be from smaller to biggest.
     */</span>
    ASCENDING,
    <span class="hljs-comment">/**
     * Resulting sort will be from biggest to smallest.
     */</span>
    DESCENDING
}
</code></pre>
    </div></div></div></div><div id="solution28" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 28</h1><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Here is an OO solution (i.e., doesn't use <code>static</code> methods):</p>

<pre class="lang-java s-code-block"><code class="hljs language-java"><span class="hljs-keyword">import</span> java.util.Collections;
<span class="hljs-keyword">import</span> java.util.Comparator;
<span class="hljs-keyword">import</span> java.util.HashMap;
<span class="hljs-keyword">import</span> java.util.Iterator;
<span class="hljs-keyword">import</span> java.util.LinkedList;
<span class="hljs-keyword">import</span> java.util.LinkedHashMap;
<span class="hljs-keyword">import</span> java.util.List;
<span class="hljs-keyword">import</span> java.util.Map;

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SortableValueMap</span>&lt;K, V <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Comparable</span>&lt;V&gt;&gt;
  <span class="hljs-keyword">extends</span> <span class="hljs-title class_">LinkedHashMap</span>&lt;K, V&gt; {
  <span class="hljs-keyword">public</span> <span class="hljs-title function_">SortableValueMap</span><span class="hljs-params">()</span> { }

  <span class="hljs-keyword">public</span> <span class="hljs-title function_">SortableValueMap</span><span class="hljs-params">( Map&lt;K, V&gt; map )</span> {
    <span class="hljs-built_in">super</span>( map );
  }

  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sortByValue</span><span class="hljs-params">()</span> {
    List&lt;Map.Entry&lt;K, V&gt;&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;Map.Entry&lt;K, V&gt;&gt;( entrySet() );

    Collections.sort( list, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Comparator</span>&lt;Map.Entry&lt;K, V&gt;&gt;() {
      <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">( Map.Entry&lt;K, V&gt; entry1, Map.Entry&lt;K, V&gt; entry2 )</span> {
        <span class="hljs-keyword">return</span> entry1.getValue().compareTo( entry2.getValue() );
      }
    });

    clear();

    <span class="hljs-keyword">for</span>( Map.Entry&lt;K, V&gt; entry : list ) {
      put( entry.getKey(), entry.getValue() );
    }
  }

  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">print</span><span class="hljs-params">( String text, Map&lt;String, Double&gt; map )</span> {
    System.out.println( text );

    <span class="hljs-keyword">for</span>( String key : map.keySet() ) {
      System.out.println( <span class="hljs-string">"key/value: "</span> + key + <span class="hljs-string">"/"</span> + map.get( key ) );
    }
  }

  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">( String[] args )</span> {
    SortableValueMap&lt;String, Double&gt; map =
      <span class="hljs-keyword">new</span> <span class="hljs-title class_">SortableValueMap</span>&lt;String, Double&gt;();

    map.put( <span class="hljs-string">"A"</span>, <span class="hljs-number">67.5</span> );
    map.put( <span class="hljs-string">"B"</span>, <span class="hljs-number">99.5</span> );
    map.put( <span class="hljs-string">"C"</span>, <span class="hljs-number">82.4</span> );
    map.put( <span class="hljs-string">"D"</span>, <span class="hljs-number">42.0</span> );

    print( <span class="hljs-string">"Unsorted map"</span>, map );
    map.sortByValue();
    print( <span class="hljs-string">"Sorted map"</span>, map );
  }
}
</code></pre>

<p>Hereby donated to the public domain.</p>
    </div></div></div></div><div id="solution29" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 29</h1><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Some simple changes in order to have a sorted map with pairs that have duplicate values. In the compare method (class ValueComparator) when values are equal do not return 0 but return the result of comparing the 2 keys. Keys are distinct in a map so you succeed to keep duplicate values (which are sorted by keys by the way). So the above example could be modified like this:</p>

<pre class="lang-java s-code-block"><code class="hljs language-java">    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(Object a, Object b)</span> {

        <span class="hljs-keyword">if</span>((Double)base.get(a) &lt; (Double)base.get(b)) {
          <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>((Double)base.get(a) == (Double)base.get(b)) {
          <span class="hljs-keyword">return</span> ((String)a).compareTo((String)b);
        } <span class="hljs-keyword">else</span> {
          <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;
        }
      }
    }
</code></pre>
    </div></div></div></div><div id="solution30" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 30</h1><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>For sure the solution of Stephen is really great, but for those who can't use Guava:</p>

<p>Here's my solution for sorting by value a map.
This solution handle the case where there are twice the same value etc...</p>

<pre class="lang-java s-code-block"><code class="hljs language-java"><span class="hljs-comment">// If you want to sort a map by value, and if there can be twice the same value:</span>

<span class="hljs-comment">// here is your original map</span>
Map&lt;String,Integer&gt; mapToSortByValue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;String, Integer&gt;();
mapToSortByValue.put(<span class="hljs-string">"A"</span>, <span class="hljs-number">3</span>);
mapToSortByValue.put(<span class="hljs-string">"B"</span>, <span class="hljs-number">1</span>);
mapToSortByValue.put(<span class="hljs-string">"C"</span>, <span class="hljs-number">3</span>);
mapToSortByValue.put(<span class="hljs-string">"D"</span>, <span class="hljs-number">5</span>);
mapToSortByValue.put(<span class="hljs-string">"E"</span>, -<span class="hljs-number">1</span>);
mapToSortByValue.put(<span class="hljs-string">"F"</span>, <span class="hljs-number">1000</span>);
mapToSortByValue.put(<span class="hljs-string">"G"</span>, <span class="hljs-number">79</span>);
mapToSortByValue.put(<span class="hljs-string">"H"</span>, <span class="hljs-number">15</span>);

<span class="hljs-comment">// Sort all the map entries by value</span>
Set&lt;Map.Entry&lt;String,Integer&gt;&gt; set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeSet</span>&lt;Map.Entry&lt;String,Integer&gt;&gt;(
        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Comparator</span>&lt;Map.Entry&lt;String,Integer&gt;&gt;(){
            <span class="hljs-meta">@Override</span>
            <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(Map.Entry&lt;String,Integer&gt; obj1, Map.Entry&lt;String,Integer&gt; obj2)</span> {
                <span class="hljs-type">Integer</span> <span class="hljs-variable">val1</span> <span class="hljs-operator">=</span> obj1.getValue();
                <span class="hljs-type">Integer</span> <span class="hljs-variable">val2</span> <span class="hljs-operator">=</span> obj2.getValue();
                <span class="hljs-comment">// DUPLICATE VALUE CASE</span>
                <span class="hljs-comment">// If the values are equals, we can't return 0 because the 2 entries would be considered</span>
                <span class="hljs-comment">// as equals and one of them would be deleted (because we use a set, no duplicate, remember!)</span>
                <span class="hljs-type">int</span> <span class="hljs-variable">compareValues</span> <span class="hljs-operator">=</span> val1.compareTo(val2);
                <span class="hljs-keyword">if</span> ( compareValues == <span class="hljs-number">0</span> ) {
                    <span class="hljs-type">String</span> <span class="hljs-variable">key1</span> <span class="hljs-operator">=</span> obj1.getKey();
                    <span class="hljs-type">String</span> <span class="hljs-variable">key2</span> <span class="hljs-operator">=</span> obj2.getKey();
                    <span class="hljs-type">int</span> <span class="hljs-variable">compareKeys</span> <span class="hljs-operator">=</span> key1.compareTo(key2);
                    <span class="hljs-keyword">if</span> ( compareKeys == <span class="hljs-number">0</span> ) {
                        <span class="hljs-comment">// what you return here will tell us if you keep REAL KEY-VALUE duplicates in your set</span>
                        <span class="hljs-comment">// if you want to, do whatever you want but do not return 0 (but don't break the comparator contract!)</span>
                        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
                    }
                    <span class="hljs-keyword">return</span> compareKeys;
                }
                <span class="hljs-keyword">return</span> compareValues;
            }
        }
);
set.addAll(mapToSortByValue.entrySet());


<span class="hljs-comment">// OK NOW OUR SET IS SORTED COOL!!!!</span>

<span class="hljs-comment">// And there's nothing more to do: the entries are sorted by value!</span>
<span class="hljs-keyword">for</span> ( Map.Entry&lt;String,Integer&gt; entry : set ) {
    System.out.println(<span class="hljs-string">"Set entries: "</span> + entry.getKey() + <span class="hljs-string">" -&gt; "</span> + entry.getValue());
}




<span class="hljs-comment">// But if you add them to an hashmap</span>
Map&lt;String,Integer&gt; myMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;String,Integer&gt;();
<span class="hljs-comment">// When iterating over the set the order is still good in the println...</span>
<span class="hljs-keyword">for</span> ( Map.Entry&lt;String,Integer&gt; entry : set ) {
    System.out.println(<span class="hljs-string">"Added to result map entries: "</span> + entry.getKey() + <span class="hljs-string">" "</span> + entry.getValue());
    myMap.put(entry.getKey(), entry.getValue());
}

<span class="hljs-comment">// But once they are in the hashmap, the order is not kept!</span>
<span class="hljs-keyword">for</span> ( Integer value : myMap.values() ) {
    System.out.println(<span class="hljs-string">"Result map values: "</span> + value);
}
<span class="hljs-comment">// Also this way doesn't work:</span>
<span class="hljs-comment">// Logic because the entryset is a hashset for hashmaps and not a treeset</span>
<span class="hljs-comment">// (and even if it was a treeset, it would be on the keys only)</span>
<span class="hljs-keyword">for</span> ( Map.Entry&lt;String,Integer&gt; entry : myMap.entrySet() ) {
    System.out.println(<span class="hljs-string">"Result map entries: "</span> + entry.getKey() + <span class="hljs-string">" -&gt; "</span> + entry.getValue());
}


<span class="hljs-comment">// CONCLUSION:</span>
<span class="hljs-comment">// If you want to iterate on a map ordered by value, you need to remember:</span>
<span class="hljs-comment">// 1) Maps are only sorted by keys, so you can't sort them directly by value</span>
<span class="hljs-comment">// 2) So you simply CAN'T return a map to a sortMapByValue function</span>
<span class="hljs-comment">// 3) You can't reverse the keys and the values because you have duplicate values</span>
<span class="hljs-comment">//    This also means you can't neither use Guava/Commons bidirectionnal treemaps or stuff like that</span>

<span class="hljs-comment">// SOLUTIONS</span>
<span class="hljs-comment">// So you can:</span>
<span class="hljs-comment">// 1) only sort the values which is easy, but you loose the key/value link (since you have duplicate values)</span>
<span class="hljs-comment">// 2) sort the map entries, but don't forget to handle the duplicate value case (like i did)</span>
<span class="hljs-comment">// 3) if you really need to return a map, use a LinkedHashMap which keep the insertion order</span>
</code></pre>

<p>The exec:
<a href="http://www.ideone.com/dq3Lu" rel="nofollow">http://www.ideone.com/dq3Lu</a></p>

<p>The output:</p>

<pre class="lang-java s-code-block"><code class="hljs language-java">Set entries: E -&gt; -<span class="hljs-number">1</span>
Set entries: B -&gt; <span class="hljs-number">1</span>
Set entries: A -&gt; <span class="hljs-number">3</span>
Set entries: C -&gt; <span class="hljs-number">3</span>
Set entries: D -&gt; <span class="hljs-number">5</span>
Set entries: H -&gt; <span class="hljs-number">15</span>
Set entries: G -&gt; <span class="hljs-number">79</span>
Set entries: F -&gt; <span class="hljs-number">1000</span>
Added to result map entries: E -<span class="hljs-number">1</span>
Added to result map entries: B <span class="hljs-number">1</span>
Added to result map entries: A <span class="hljs-number">3</span>
Added to result map entries: C <span class="hljs-number">3</span>
Added to result map entries: D <span class="hljs-number">5</span>
Added to result map entries: H <span class="hljs-number">15</span>
Added to result map entries: G <span class="hljs-number">79</span>
Added to result map entries: F <span class="hljs-number">1000</span>
Result map values: <span class="hljs-number">5</span>
Result map values: -<span class="hljs-number">1</span>
Result map values: <span class="hljs-number">1000</span>
Result map values: <span class="hljs-number">79</span>
Result map values: <span class="hljs-number">3</span>
Result map values: <span class="hljs-number">1</span>
Result map values: <span class="hljs-number">3</span>
Result map values: <span class="hljs-number">15</span>
Result map entries: D -&gt; <span class="hljs-number">5</span>
Result map entries: E -&gt; -<span class="hljs-number">1</span>
Result map entries: F -&gt; <span class="hljs-number">1000</span>
Result map entries: G -&gt; <span class="hljs-number">79</span>
Result map entries: A -&gt; <span class="hljs-number">3</span>
Result map entries: B -&gt; <span class="hljs-number">1</span>
Result map entries: C -&gt; <span class="hljs-number">3</span>
Result map entries: H -&gt; <span class="hljs-number">15</span>
</code></pre>

<p>Hope it will help some folks</p>
    </div></div></div></div></div></div><div class="widget"><a href="/questions/sorting-an-array-of-objects-by-property-values-1657387447490">Sorting an array of objects by property values</a><a href="/questions/selenium-wait-until-element-is-present-visible-and-interactable-1657384820071">Selenium - wait until element is present, visible and interactable</a><a href="/questions/undefined-unspecified-and-implementation-defined-behavior-1657384516085">Undefined, unspecified and implementation-defined behavior</a><a href="/questions/why-is-processing-a-sorted-array-faster-than-processing-an-unsorted-array-1657385497444">Why is processing a sorted array faster than processing an unsorted array?</a><a href="/questions/how-do-javascript-closures-work-1657384418555">How do JavaScript closures work?</a><a href="/questions/can-you-provide-some-examples-of-why-it-is-hard-to-parse-xml-and-html-with-a-regex-closed-1657388410824">Can you provide some examples of why it is hard to parse XML and HTML with a regex? [closed]</a><a href="/questions/how-do-i-list-all-files-of-a-directory-1657388340404">How do I list all files of a directory?</a><a href="/questions/test-for-existence-of-nested-javascript-object-key-1657387935411">Test for existence of nested JavaScript object key</a><a href="/questions/commandbuttoncommandlinkajax-actionlistener-method-not-invoked-or-input-value-not-setupdated-1657384667519">commandButton/commandLink/ajax action/listener method not invoked or input value not set/updated</a><a href="/questions/how-do-i-copy-to-the-clipboard-in-javascript-1657385501223">How do I copy to the clipboard in JavaScript?</a><a href="/questions/why-aren&#x27;t-variable-length-arrays-part-of-the-c++-standard-1657384712975">Why aren&#x27;t variable-length arrays part of the C++ standard?</a><a href="/questions/how-do-i-create-variable-variables-1657384387679">How do I create variable variables?</a><a href="/questions/sort-a-maplesskey-valuegreater-by-values-1657387443904">Sort a Map&lt;Key, Value&gt; by values</a><a href="/questions/daylight-saving-time-and-time-zone-best-practices-closed-1657387973687">Daylight saving time and time zone best practices [closed]</a><a href="/questions/providing-white-space-in-a-swing-gui-1657384734588">Providing white space in a Swing GUI</a><a href="/questions/understanding-slicing-1657384397680">Understanding slicing</a><a href="/questions/what-to-do-regular-expression-pattern-doesn&#x27;t-match-anywhere-in-string-1657388095896">What to do Regular expression pattern doesn&#x27;t match anywhere in string?</a><a href="/questions/what-and-where-are-the-stack-and-heap-1657387415361">What and where are the stack and heap?</a><a href="/questions/how-to-use-threetenabp-in-android-project-1657384345704">How to use ThreeTenABP in Android Project</a><a href="/questions/why-jsf-calls-getters-multiple-times-1657388244489">Why JSF calls getters multiple times</a></div></div><span class="cursor-pointer text-lg p-2" style="position:fixed;bottom:20px;left:20px;background:#000;z-index:2000;color:white">Go go top</span></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"data":{"answer":["\n\u0026lt;p\u0026gt;Here\u0026apos;s a generic-friendly version:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-java s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-java\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;MapUtil\u0026lt;/span\u0026gt; {\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;static\u0026lt;/span\u0026gt; \u0026amp;lt;K, V \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;extends\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Comparable\u0026lt;/span\u0026gt;\u0026amp;lt;? \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;super\u0026lt;/span\u0026gt; V\u0026amp;gt;\u0026amp;gt; Map\u0026amp;lt;K, V\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;sortByValue\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(Map\u0026amp;lt;K, V\u0026amp;gt; map)\u0026lt;/span\u0026gt; {\n        List\u0026amp;lt;Entry\u0026amp;lt;K, V\u0026amp;gt;\u0026amp;gt; list = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;ArrayList\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026amp;gt;(map.entrySet());\n        list.sort(Entry.comparingByValue());\n\n        Map\u0026amp;lt;K, V\u0026amp;gt; result = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;LinkedHashMap\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026amp;gt;();\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt; (Entry\u0026amp;lt;K, V\u0026amp;gt; entry : list) {\n            result.put(entry.getKey(), entry.getValue());\n        }\n\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; result;\n    }\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;h3\u0026gt;Important note:\u0026lt;/h3\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;This code can break in multiple ways.\u0026lt;/strong\u0026gt; If you intend to use the code provided, be sure to read the comments as well to be aware of the implications. For example, values can no longer be retrieved by their key. (\u0026lt;code\u0026gt;get\u0026lt;/code\u0026gt; always returns \u0026lt;code\u0026gt;null\u0026lt;/code\u0026gt;.)\u0026lt;/p\u0026gt;\n\u0026lt;hr\u0026gt;\n\u0026lt;p\u0026gt;It seems much easier than all of the foregoing. Use a TreeMap as follows:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-java s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-java\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Testing\u0026lt;/span\u0026gt; {\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;static\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;main\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(String[] args)\u0026lt;/span\u0026gt; {\n        HashMap\u0026amp;lt;String, Double\u0026amp;gt; map = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;HashMap\u0026lt;/span\u0026gt;\u0026amp;lt;String, Double\u0026amp;gt;();\n        \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;ValueComparator\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;bvc\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;ValueComparator\u0026lt;/span\u0026gt;(map);\n        TreeMap\u0026amp;lt;String, Double\u0026amp;gt; sorted_map = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;TreeMap\u0026lt;/span\u0026gt;\u0026amp;lt;String, Double\u0026amp;gt;(bvc);\n\n        map.put(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;A\u0026quot;\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;99.5\u0026lt;/span\u0026gt;);\n        map.put(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;B\u0026quot;\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;67.4\u0026lt;/span\u0026gt;);\n        map.put(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;C\u0026quot;\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;67.4\u0026lt;/span\u0026gt;);\n        map.put(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;D\u0026quot;\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;67.3\u0026lt;/span\u0026gt;);\n\n        System.out.println(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;unsorted map: \u0026quot;\u0026lt;/span\u0026gt; + map);\n        sorted_map.putAll(map);\n        System.out.println(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;results: \u0026quot;\u0026lt;/span\u0026gt; + sorted_map);\n    }\n}\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;ValueComparator\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;implements\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Comparator\u0026lt;/span\u0026gt;\u0026amp;lt;String\u0026amp;gt; {\n    Map\u0026amp;lt;String, Double\u0026amp;gt; base;\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;ValueComparator\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(Map\u0026amp;lt;String, Double\u0026amp;gt; base)\u0026lt;/span\u0026gt; {\n        \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;this\u0026lt;/span\u0026gt;.base = base;\n    }\n\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Note: this comparator imposes orderings that are inconsistent with\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// equals.\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;compare\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(String a, String b)\u0026lt;/span\u0026gt; {\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (base.get(a) \u0026amp;gt;= base.get(b)) {\n            \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; -\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;;\n        } \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;else\u0026lt;/span\u0026gt; {\n            \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;;\n        } \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// returning 0 would merge keys\u0026lt;/span\u0026gt;\n    }\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;Output:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-java s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-java\u0026quot;\u0026gt;unsorted map: {D=\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;67.3\u0026lt;/span\u0026gt;, A=\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;99.5\u0026lt;/span\u0026gt;, B=\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;67.4\u0026lt;/span\u0026gt;, C=\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;67.4\u0026lt;/span\u0026gt;}\nresults: {D=\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;67.3\u0026lt;/span\u0026gt;, B=\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;67.4\u0026lt;/span\u0026gt;, C=\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;67.4\u0026lt;/span\u0026gt;, A=\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;99.5\u0026lt;/span\u0026gt;}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Java 8 offers a new answer: convert the entries into a stream, and use the comparator combinators from Map.Entry:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-java s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-java\u0026quot;\u0026gt;Stream\u0026amp;lt;Map.Entry\u0026amp;lt;K,V\u0026amp;gt;\u0026amp;gt; sorted =\n    map.entrySet().stream()\n       .sorted(Map.Entry.comparingByValue());\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;This will let you consume the entries sorted in ascending order of value.  If you want descending value, simply reverse the comparator:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-java s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-java\u0026quot;\u0026gt;Stream\u0026amp;lt;Map.Entry\u0026amp;lt;K,V\u0026amp;gt;\u0026amp;gt; sorted =\n    map.entrySet().stream()\n       .sorted(Collections.reverseOrder(Map.Entry.comparingByValue()));\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;If the values are not comparable, you can pass an explicit comparator:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-java s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-java\u0026quot;\u0026gt;Stream\u0026amp;lt;Map.Entry\u0026amp;lt;K,V\u0026amp;gt;\u0026amp;gt; sorted =\n    map.entrySet().stream()\n       .sorted(Map.Entry.comparingByValue(comparator));\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;You can then proceed to use other stream operations to consume the data. For example, if you want the top 10 in a new map:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-java s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-java\u0026quot;\u0026gt;Map\u0026amp;lt;K,V\u0026amp;gt; topTen =\n    map.entrySet().stream()\n       .sorted(Map.Entry.comparingByValue(Comparator.reverseOrder()))\n       .limit(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;10\u0026lt;/span\u0026gt;)\n       .collect(Collectors.toMap(\n          Map.Entry::getKey, Map.Entry::getValue, (e1, e2) -\u0026amp;gt; e1, LinkedHashMap::\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt;));\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;The \u0026lt;a href=\u0026quot;https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/util/LinkedHashMap.html\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;\u0026lt;code\u0026gt;LinkedHashMap\u0026lt;/code\u0026gt;\u0026lt;/a\u0026gt; seen above iterates entries in the order in which they were inserted.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Or print to \u0026lt;code\u0026gt;System.out\u0026lt;/code\u0026gt;:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-java s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-java\u0026quot;\u0026gt;map.entrySet().stream()\n   .sorted(Map.Entry.comparingByValue())\n   .forEach(System.out::println);\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Three 1-line answers...\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;I would use \u0026lt;s\u0026gt;Google Collections\u0026lt;/s\u0026gt; \u0026lt;a href=\u0026quot;http://code.google.com/p/guava-libraries/\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;\u0026lt;strong\u0026gt;Guava\u0026lt;/strong\u0026gt;\u0026lt;/a\u0026gt; to do this - if your values are \u0026lt;code\u0026gt;Comparable\u0026lt;/code\u0026gt; then you can use\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-java s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-java\u0026quot;\u0026gt;valueComparator = Ordering.natural().onResultOf(Functions.forMap(map))\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Which will create a function (object) for the map [that takes any of the keys as input, returning the respective value], and then apply natural (comparable) ordering to them [the values].\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;If they\u0026apos;re not comparable, then you\u0026apos;ll need to do something along the lines of\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-java s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-java\u0026quot;\u0026gt;valueComparator = Ordering.from(comparator).onResultOf(Functions.forMap(map)) \n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;These may be applied to a TreeMap (as \u0026lt;code\u0026gt;Ordering\u0026lt;/code\u0026gt; extends \u0026lt;code\u0026gt;Comparator\u0026lt;/code\u0026gt;), or a \u0026lt;a href=\u0026quot;https://stackoverflow.com/questions/109383/how-to-sort-a-mapkey-value-on-the-values-in-java/109389#109389\u0026quot;\u0026gt;LinkedHashMap after some sorting\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;em\u0026gt;NB\u0026lt;/em\u0026gt;: If you are going to use a TreeMap, remember that if a comparison == 0, then the item is already in the list (which will happen if you have multiple values that compare the same).  To alleviate this, you could add your key to the comparator like so (presuming that your keys and values are \u0026lt;code\u0026gt;Comparable\u0026lt;/code\u0026gt;):\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-java s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-java\u0026quot;\u0026gt;valueComparator = Ordering.natural().onResultOf(Functions.forMap(map)).compound(Ordering.natural())\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;= \u0026lt;em\u0026gt;Apply natural ordering to the value mapped by the key, and compound that with the natural ordering of the key\u0026lt;/em\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Note that this will still not work if your keys compare to 0, but this should be sufficient for most \u0026lt;code\u0026gt;comparable\u0026lt;/code\u0026gt; items (as \u0026lt;code\u0026gt;hashCode\u0026lt;/code\u0026gt;, \u0026lt;code\u0026gt;equals\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;compareTo\u0026lt;/code\u0026gt; are often in sync...)\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;See \u0026lt;a href=\u0026quot;http://guava-libraries.googlecode.com/svn/trunk/javadoc/com/google/common/collect/Ordering.html#onResultOf(com.google.common.base.Function)\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;Ordering.onResultOf()\u0026lt;/a\u0026gt; and \u0026lt;a href=\u0026quot;http://guava-libraries.googlecode.com/svn/trunk/javadoc/com/google/common/base/Functions.html#forMap(java.util.Map)\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;Functions.forMap()\u0026lt;/a\u0026gt;.\u0026lt;/p\u0026gt;\n\n\u0026lt;h2\u0026gt;Implementation\u0026lt;/h2\u0026gt;\n\n\u0026lt;p\u0026gt;So now that we\u0026apos;ve got a comparator that does what we want, we need to get a result from it. \u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-java s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-java\u0026quot;\u0026gt;map = ImmutableSortedMap.copyOf(myOriginalMap, valueComparator);\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Now this will most likely work work, but:\u0026lt;/p\u0026gt;\n\n\u0026lt;ol\u0026gt;\n\u0026lt;li\u0026gt;needs to be done given a complete finished map\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Don\u0026apos;t try the comparators above on a \u0026lt;code\u0026gt;TreeMap\u0026lt;/code\u0026gt;; there\u0026apos;s no point trying to compare an inserted key when it doesn\u0026apos;t have a value until after the put, i.e., it will break really fast\u0026lt;/li\u0026gt;\n\u0026lt;/ol\u0026gt;\n\n\u0026lt;p\u0026gt;Point 1 is a bit of a deal-breaker for me; google collections is incredibly lazy (which is good: you can do pretty much every operation in an instant; the real work is done when you start using the result), and this requires copying a \u0026lt;em\u0026gt;whole\u0026lt;/em\u0026gt; map!\u0026lt;/p\u0026gt;\n\n\u0026lt;h2\u0026gt;\u0026quot;Full\u0026quot; answer/Live sorted map by values\u0026lt;/h2\u0026gt;\n\n\u0026lt;p\u0026gt;Don\u0026apos;t worry though; if you were obsessed enough with having a \u0026quot;live\u0026quot; map sorted in this manner, you could solve not one but both(!) of the above issues with something crazy like the following:\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Note: This has changed significantly in June 2012 - the previous code could never work: an internal HashMap is required to lookup the values without creating an infinite loop between the \u0026lt;code\u0026gt;TreeMap.get()\u0026lt;/code\u0026gt; -\u0026amp;gt; \u0026lt;code\u0026gt;compare()\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;compare()\u0026lt;/code\u0026gt; -\u0026amp;gt; \u0026lt;code\u0026gt;get()\u0026lt;/code\u0026gt;\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-java s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-java\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;import\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;static\u0026lt;/span\u0026gt; org.junit.Assert.assertEquals;\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;import\u0026lt;/span\u0026gt; java.util.HashMap;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;import\u0026lt;/span\u0026gt; java.util.Map;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;import\u0026lt;/span\u0026gt; java.util.TreeMap;\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;import\u0026lt;/span\u0026gt; com.google.common.base.Functions;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;import\u0026lt;/span\u0026gt; com.google.common.collect.Ordering;\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;ValueComparableMap\u0026lt;/span\u0026gt;\u0026amp;lt;K \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;extends\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Comparable\u0026lt;/span\u0026gt;\u0026amp;lt;K\u0026amp;gt;,V\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;extends\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;TreeMap\u0026lt;/span\u0026gt;\u0026amp;lt;K,V\u0026amp;gt; {\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//A map for doing lookups on the keys for comparison so we don\u0026apos;t get infinite loops\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;private\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;final\u0026lt;/span\u0026gt; Map\u0026amp;lt;K, V\u0026amp;gt; valueMap;\n\n    ValueComparableMap(\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;final\u0026lt;/span\u0026gt; Ordering\u0026amp;lt;? \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;super\u0026lt;/span\u0026gt; V\u0026amp;gt; partialValueOrdering) {\n        \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;this\u0026lt;/span\u0026gt;(partialValueOrdering, \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;HashMap\u0026lt;/span\u0026gt;\u0026amp;lt;K,V\u0026amp;gt;());\n    }\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;private\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;ValueComparableMap\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(Ordering\u0026amp;lt;? \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;super\u0026lt;/span\u0026gt; V\u0026amp;gt; partialValueOrdering,\n            HashMap\u0026amp;lt;K, V\u0026amp;gt; valueMap)\u0026lt;/span\u0026gt; {\n        \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;super\u0026lt;/span\u0026gt;(partialValueOrdering \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//Apply the value ordering\u0026lt;/span\u0026gt;\n                .onResultOf(Functions.forMap(valueMap)) \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//On the result of getting the value for the key from the map\u0026lt;/span\u0026gt;\n                .compound(Ordering.natural())); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//as well as ensuring that the keys don\u0026apos;t get clobbered\u0026lt;/span\u0026gt;\n        \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;this\u0026lt;/span\u0026gt;.valueMap = valueMap;\n    }\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; V \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;put\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(K k, V v)\u0026lt;/span\u0026gt; {\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (valueMap.containsKey(k)){\n            \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//remove the key in the sorted set before adding the key again\u0026lt;/span\u0026gt;\n            remove(k);\n        }\n        valueMap.put(k,v); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//To get \u0026quot;real\u0026quot; unsorted values for the comparator\u0026lt;/span\u0026gt;\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;super\u0026lt;/span\u0026gt;.put(k, v); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//Put it in value order\u0026lt;/span\u0026gt;\n    }\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;static\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;main\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(String[] args)\u0026lt;/span\u0026gt;{\n        TreeMap\u0026amp;lt;String, Integer\u0026amp;gt; map = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;ValueComparableMap\u0026lt;/span\u0026gt;\u0026amp;lt;String, Integer\u0026amp;gt;(Ordering.natural());\n        map.put(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;a\u0026quot;\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;5\u0026lt;/span\u0026gt;);\n        map.put(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;b\u0026quot;\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;);\n        map.put(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;c\u0026quot;\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3\u0026lt;/span\u0026gt;);\n        assertEquals(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;b\u0026quot;\u0026lt;/span\u0026gt;,map.firstKey());\n        assertEquals(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;a\u0026quot;\u0026lt;/span\u0026gt;,map.lastKey());\n        map.put(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;d\u0026quot;\u0026lt;/span\u0026gt;,\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;);\n        assertEquals(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;d\u0026quot;\u0026lt;/span\u0026gt;,map.firstKey());\n        \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//ensure it\u0026apos;s still a map (by overwriting a key, but with a new value) \u0026lt;/span\u0026gt;\n        map.put(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;d\u0026quot;\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;);\n        assertEquals(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;b\u0026quot;\u0026lt;/span\u0026gt;, map.firstKey());\n        \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//Ensure multiple values do not clobber keys\u0026lt;/span\u0026gt;\n        map.put(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;e\u0026quot;\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;);\n        assertEquals(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;5\u0026lt;/span\u0026gt;, map.size());\n        assertEquals(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;, (\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;) map.get(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;e\u0026quot;\u0026lt;/span\u0026gt;));\n        assertEquals(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;, (\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;) map.get(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;d\u0026quot;\u0026lt;/span\u0026gt;));\n    }\n }\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;When we put, we ensure that the hash map has the value for the comparator, and then put to the TreeSet for sorting. But before that we check the hash map to see that the key is not actually a duplicate. Also, the comparator that we create will also include the key so that duplicate values don\u0026apos;t delete the non-duplicate keys (due to == comparison).\nThese 2 items are \u0026lt;em\u0026gt;vital\u0026lt;/em\u0026gt; for ensuring the map contract is kept; if you think you don\u0026apos;t want that, then you\u0026apos;re almost at the point of reversing the map entirely (to \u0026lt;code\u0026gt;Map\u0026amp;lt;V,K\u0026amp;gt;\u0026lt;/code\u0026gt;).\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;The constructor would need to be called as \u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-java s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-java\u0026quot;\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;ValueComparableMap\u0026lt;/span\u0026gt;(Ordering.natural());\n \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//or\u0026lt;/span\u0026gt;\n \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;ValueComparableMap\u0026lt;/span\u0026gt;(Ordering.from(comparator));\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;From \u0026lt;a href=\u0026quot;http://www.programmersheaven.com/download/49349/download.aspx\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;http://www.programmersheaven.com/download/49349/download.aspx\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-java s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-java\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;private\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;static\u0026lt;/span\u0026gt; \u0026amp;lt;K, V\u0026amp;gt; Map\u0026amp;lt;K, V\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;sortByValue\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(Map\u0026amp;lt;K, V\u0026amp;gt; map)\u0026lt;/span\u0026gt; {\n    List\u0026amp;lt;Entry\u0026amp;lt;K, V\u0026amp;gt;\u0026amp;gt; list = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;LinkedList\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026amp;gt;(map.entrySet());\n    Collections.sort(list, \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Comparator\u0026lt;/span\u0026gt;\u0026amp;lt;Object\u0026amp;gt;() {\n        \u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;@SuppressWarnings(\u0026quot;unchecked\u0026quot;)\u0026lt;/span\u0026gt;\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;compare\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(Object o1, Object o2)\u0026lt;/span\u0026gt; {\n            \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; ((Comparable\u0026amp;lt;V\u0026amp;gt;) ((Map.Entry\u0026amp;lt;K, V\u0026amp;gt;) (o1)).getValue()).compareTo(((Map.Entry\u0026amp;lt;K, V\u0026amp;gt;) (o2)).getValue());\n        }\n    });\n\n    Map\u0026amp;lt;K, V\u0026amp;gt; result = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;LinkedHashMap\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026amp;gt;();\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt; (Iterator\u0026amp;lt;Entry\u0026amp;lt;K, V\u0026amp;gt;\u0026amp;gt; it = list.iterator(); it.hasNext();) {\n        Map.Entry\u0026amp;lt;K, V\u0026amp;gt; entry = (Map.Entry\u0026amp;lt;K, V\u0026amp;gt;) it.next();\n        result.put(entry.getKey(), entry.getValue());\n    }\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; result;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;With Java 8, you can use the \u0026lt;a href=\u0026quot;https://docs.oracle.com/javase/8/docs/api/java/util/stream/package-summary.html\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;streams api\u0026lt;/a\u0026gt; to do it in a significantly less verbose way:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-java s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-java\u0026quot;\u0026gt;Map\u0026amp;lt;K, V\u0026amp;gt; sortedMap = map.entrySet().stream()\n                         .sorted(Entry.comparingByValue())\n                         .collect(Collectors.toMap(Entry::getKey, Entry::getValue, (e1, e2) -\u0026amp;gt; e1, LinkedHashMap::\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt;));\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Sorting the keys requires the Comparator to look up each value for each comparison. A more scalable solution would use the entrySet directly, since then the value would be immediately available for each comparison (although I haven\u0026apos;t backed this up by numbers).\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Here\u0026apos;s a generic version of such a thing:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-java s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-java\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;static\u0026lt;/span\u0026gt; \u0026amp;lt;K, V \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;extends\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Comparable\u0026lt;/span\u0026gt;\u0026amp;lt;? \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;super\u0026lt;/span\u0026gt; V\u0026amp;gt;\u0026amp;gt; List\u0026amp;lt;K\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;getKeysSortedByValue\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(Map\u0026amp;lt;K, V\u0026amp;gt; map)\u0026lt;/span\u0026gt; {\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;final\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;size\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; map.size();\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;final\u0026lt;/span\u0026gt; List\u0026amp;lt;Map.Entry\u0026amp;lt;K, V\u0026amp;gt;\u0026amp;gt; list = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;ArrayList\u0026lt;/span\u0026gt;\u0026amp;lt;Map.Entry\u0026amp;lt;K, V\u0026amp;gt;\u0026amp;gt;(size);\n    list.addAll(map.entrySet());\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;final\u0026lt;/span\u0026gt; ValueComparator\u0026amp;lt;V\u0026amp;gt; cmp = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;ValueComparator\u0026lt;/span\u0026gt;\u0026amp;lt;V\u0026amp;gt;();\n    Collections.sort(list, cmp);\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;final\u0026lt;/span\u0026gt; List\u0026amp;lt;K\u0026amp;gt; keys = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;ArrayList\u0026lt;/span\u0026gt;\u0026amp;lt;K\u0026amp;gt;(size);\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt; (\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;i\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;; i \u0026amp;lt; size; i++) {\n        keys.set(i, list.get(i).getKey());\n    }\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; keys;\n}\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;private\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;static\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;final\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;ValueComparator\u0026lt;/span\u0026gt;\u0026amp;lt;V \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;extends\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Comparable\u0026lt;/span\u0026gt;\u0026amp;lt;? \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;super\u0026lt;/span\u0026gt; V\u0026amp;gt;\u0026amp;gt;\n                                     \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;implements\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Comparator\u0026lt;/span\u0026gt;\u0026amp;lt;Map.Entry\u0026amp;lt;?, V\u0026amp;gt;\u0026amp;gt; {\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;compare\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(Map.Entry\u0026amp;lt;?, V\u0026amp;gt; o1, Map.Entry\u0026amp;lt;?, V\u0026amp;gt; o2)\u0026lt;/span\u0026gt; {\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; o1.getValue().compareTo(o2.getValue());\n    }\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;There are ways to lessen memory rotation for the above solution. The first ArrayList created could for instance be re-used as a return value; this would require suppression of some generics warnings, but it might be worth it for re-usable library code. Also,  the Comparator does not have to be re-allocated at every invocation.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Here\u0026apos;s a more efficient albeit less appealing version:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-java s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-java\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;static\u0026lt;/span\u0026gt; \u0026amp;lt;K, V \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;extends\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Comparable\u0026lt;/span\u0026gt;\u0026amp;lt;? \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;super\u0026lt;/span\u0026gt; V\u0026amp;gt;\u0026amp;gt; List\u0026amp;lt;K\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;getKeysSortedByValue2\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(Map\u0026amp;lt;K, V\u0026amp;gt; map)\u0026lt;/span\u0026gt; {\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;final\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;size\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; map.size();\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;final\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;List\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;reusedList\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;ArrayList\u0026lt;/span\u0026gt;(size);\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;final\u0026lt;/span\u0026gt; List\u0026amp;lt;Map.Entry\u0026amp;lt;K, V\u0026amp;gt;\u0026amp;gt; meView = reusedList;\n    meView.addAll(map.entrySet());\n    Collections.sort(meView, SINGLE);\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;final\u0026lt;/span\u0026gt; List\u0026amp;lt;K\u0026amp;gt; keyView = reusedList;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt; (\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;i\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;; i \u0026amp;lt; size; i++) {\n        keyView.set(i, meView.get(i).getKey());\n    }\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; keyView;\n}\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;private\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;static\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;final\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;Comparator\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;SINGLE\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;ValueComparator\u0026lt;/span\u0026gt;();\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Finally, if you need to continously access the sorted information (rather than just sorting it once in a while), you can use an additional multi map. Let me know if you need more details...\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;The commons-collections library contains a solution called \u0026lt;a href=\u0026quot;http://commons.apache.org/collections/api-release/org/apache/commons/collections/bidimap/TreeBidiMap.html\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;TreeBidiMap\u0026lt;/a\u0026gt;. Or, you could have a look at the Google Collections API. It has \u0026lt;a href=\u0026quot;http://google-collections.googlecode.com/svn/trunk/javadoc/com/google/common/collect/TreeMultimap.html\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;TreeMultimap\u0026lt;/a\u0026gt; which you could use.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;And if you don\u0026apos;t want to use these framework... they come with source code.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;I\u0026apos;ve looked at the given answers, but a lot of them are more complicated than needed or remove map elements when several keys have same value.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Here is a solution that I think fits better:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-java s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-java\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;static\u0026lt;/span\u0026gt; \u0026amp;lt;K, V \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;extends\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Comparable\u0026lt;/span\u0026gt;\u0026amp;lt;V\u0026amp;gt;\u0026amp;gt; Map\u0026amp;lt;K, V\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;sortByValues\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;final\u0026lt;/span\u0026gt; Map\u0026amp;lt;K, V\u0026amp;gt; map)\u0026lt;/span\u0026gt; {\n    Comparator\u0026amp;lt;K\u0026amp;gt; valueComparator =  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Comparator\u0026lt;/span\u0026gt;\u0026amp;lt;K\u0026amp;gt;() {\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;compare\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(K k1, K k2)\u0026lt;/span\u0026gt; {\n            \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;compare\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; map.get(k2).compareTo(map.get(k1));\n            \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (compare == \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;) \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;;\n            \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;else\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; compare;\n        }\n    };\n    Map\u0026amp;lt;K, V\u0026amp;gt; sortedByValues = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;TreeMap\u0026lt;/span\u0026gt;\u0026amp;lt;K, V\u0026amp;gt;(valueComparator);\n    sortedByValues.putAll(map);\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; sortedByValues;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Note that the map is sorted from the highest value to the lowest.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Given Map\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-java s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-java\u0026quot;\u0026gt;   Map\u0026amp;lt;String, Integer\u0026amp;gt; wordCounts = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;HashMap\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026amp;gt;();\n    wordCounts.put(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;USA\u0026quot;\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;100\u0026lt;/span\u0026gt;);\n    wordCounts.put(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;jobs\u0026quot;\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;200\u0026lt;/span\u0026gt;);\n    wordCounts.put(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;software\u0026quot;\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;50\u0026lt;/span\u0026gt;);\n    wordCounts.put(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;technology\u0026quot;\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;70\u0026lt;/span\u0026gt;);\n    wordCounts.put(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;opportunity\u0026quot;\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;200\u0026lt;/span\u0026gt;);\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Sort the map based on the value in ascending order\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-java s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-java\u0026quot;\u0026gt;Map\u0026amp;lt;String,Integer\u0026amp;gt;  sortedMap =  wordCounts.entrySet().\n                                                stream().\n                                                sorted(Map.Entry.comparingByValue()).\n        collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue, (e1, e2) -\u0026amp;gt; e1, LinkedHashMap::\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt;));\n    System.out.println(sortedMap);\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Sort the map based on value in desending order\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-java s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-java\u0026quot;\u0026gt;Map\u0026amp;lt;String,Integer\u0026amp;gt;  sortedMapReverseOrder =  wordCounts.entrySet().\n            stream().\n            sorted(Map.Entry.comparingByValue(Comparator.reverseOrder())).\n            collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue, (e1, e2) -\u0026amp;gt; e1, LinkedHashMap::\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt;));\n    System.out.println(sortedMapReverseOrder);\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Output:\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;{software=50, technology=70, USA=100, jobs=200, opportunity=200}\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;{jobs=200, opportunity=200, USA=100, technology=70, software=50}\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;To accomplish this with the new features in Java 8:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-java s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-java\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;import\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;static\u0026lt;/span\u0026gt; java.util.Map.Entry.comparingByValue;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;import\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;static\u0026lt;/span\u0026gt; java.util.stream.Collectors.toList;\n\n\u0026amp;lt;K, V\u0026amp;gt; List\u0026amp;lt;Entry\u0026amp;lt;K, V\u0026amp;gt;\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;sort\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(Map\u0026amp;lt;K, V\u0026amp;gt; map, Comparator\u0026amp;lt;? \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;super\u0026lt;/span\u0026gt; V\u0026amp;gt; comparator)\u0026lt;/span\u0026gt; {\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; map.entrySet().stream().sorted(comparingByValue(comparator)).collect(toList());\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;The entries are ordered by their values using the given comparator. Alternatively, if your values are mutually comparable, no explicit comparator is needed:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-java s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-java\u0026quot;\u0026gt;\u0026amp;lt;K, V \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;extends\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Comparable\u0026lt;/span\u0026gt;\u0026amp;lt;? \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;super\u0026lt;/span\u0026gt; V\u0026amp;gt;\u0026amp;gt; List\u0026amp;lt;Entry\u0026amp;lt;K, V\u0026amp;gt;\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;sort\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(Map\u0026amp;lt;K, V\u0026amp;gt; map)\u0026lt;/span\u0026gt; {\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; map.entrySet().stream().sorted(comparingByValue()).collect(toList());\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;The returned list is a snapshot of the given map at the time this method is called, so neither will reflect subsequent changes to the other. For a live iterable view of the map:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-java s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-java\u0026quot;\u0026gt;\u0026amp;lt;K, V \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;extends\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Comparable\u0026lt;/span\u0026gt;\u0026amp;lt;? \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;super\u0026lt;/span\u0026gt; V\u0026amp;gt;\u0026amp;gt; Iterable\u0026amp;lt;Entry\u0026amp;lt;K, V\u0026amp;gt;\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;sort\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(Map\u0026amp;lt;K, V\u0026amp;gt; map)\u0026lt;/span\u0026gt; {\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; () -\u0026amp;gt; map.entrySet().stream().sorted(comparingByValue()).iterator();\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;The returned iterable creates a fresh snapshot of the given map each time it\u0026apos;s iterated, so barring concurrent modification, it will always reflect the current state of the map.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Create customized comparator and use it while creating new TreeMap object.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-java s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-java\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;MyComparator\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;implements\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Comparator\u0026lt;/span\u0026gt;\u0026amp;lt;Object\u0026amp;gt; {\n\n    Map\u0026amp;lt;String, Integer\u0026amp;gt; map;\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;MyComparator\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(Map\u0026amp;lt;String, Integer\u0026amp;gt; map)\u0026lt;/span\u0026gt; {\n        \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;this\u0026lt;/span\u0026gt;.map = map;\n    }\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;compare\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(Object o1, Object o2)\u0026lt;/span\u0026gt; {\n\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (map.get(o2) == map.get(o1))\n            \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;;\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;else\u0026lt;/span\u0026gt;\n            \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; ((Integer) map.get(o2)).compareTo((Integer)     \n                                                            map.get(o1));\n\n    }\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Use the below code in your main func\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-java s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-java\u0026quot;\u0026gt;    Map\u0026amp;lt;String, Integer\u0026amp;gt; lMap = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;HashMap\u0026lt;/span\u0026gt;\u0026amp;lt;String, Integer\u0026amp;gt;();\n    lMap.put(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;A\u0026quot;\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;35\u0026lt;/span\u0026gt;);\n    lMap.put(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;B\u0026quot;\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;75\u0026lt;/span\u0026gt;);\n    lMap.put(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;C\u0026quot;\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;50\u0026lt;/span\u0026gt;);\n    lMap.put(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;D\u0026quot;\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;50\u0026lt;/span\u0026gt;);\n\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;MyComparator\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;comparator\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;MyComparator\u0026lt;/span\u0026gt;(lMap);\n\n    Map\u0026amp;lt;String, Integer\u0026amp;gt; newMap = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;TreeMap\u0026lt;/span\u0026gt;\u0026amp;lt;String, Integer\u0026amp;gt;(comparator);\n    newMap.putAll(lMap);\n    System.out.println(newMap);\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Output:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-java s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-java\u0026quot;\u0026gt;{B=\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;75\u0026lt;/span\u0026gt;, D=\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;50\u0026lt;/span\u0026gt;, C=\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;50\u0026lt;/span\u0026gt;, A=\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;35\u0026lt;/span\u0026gt;}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;While I agree that the constant need to sort a map is probably a smell, I think the following code is the easiest way to do it without using a different data structure.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-java s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-java\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;MapUtilities\u0026lt;/span\u0026gt; {\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;static\u0026lt;/span\u0026gt; \u0026amp;lt;K, V \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;extends\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Comparable\u0026lt;/span\u0026gt;\u0026amp;lt;V\u0026amp;gt;\u0026amp;gt; List\u0026amp;lt;Entry\u0026amp;lt;K, V\u0026amp;gt;\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;sortByValue\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(Map\u0026amp;lt;K, V\u0026amp;gt; map)\u0026lt;/span\u0026gt; {\n    List\u0026amp;lt;Entry\u0026amp;lt;K, V\u0026amp;gt;\u0026amp;gt; entries = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;ArrayList\u0026lt;/span\u0026gt;\u0026amp;lt;Entry\u0026amp;lt;K, V\u0026amp;gt;\u0026amp;gt;(map.entrySet());\n    Collections.sort(entries, \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;ByValue\u0026lt;/span\u0026gt;\u0026amp;lt;K, V\u0026amp;gt;());\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; entries;\n}\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;private\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;static\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;ByValue\u0026lt;/span\u0026gt;\u0026amp;lt;K, V \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;extends\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Comparable\u0026lt;/span\u0026gt;\u0026amp;lt;V\u0026amp;gt;\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;implements\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Comparator\u0026lt;/span\u0026gt;\u0026amp;lt;Entry\u0026amp;lt;K, V\u0026amp;gt;\u0026amp;gt; {\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;compare\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(Entry\u0026amp;lt;K, V\u0026amp;gt; o1, Entry\u0026amp;lt;K, V\u0026amp;gt; o2)\u0026lt;/span\u0026gt; {\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; o1.getValue().compareTo(o2.getValue());\n    }\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;}\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;And here is an embarrassingly incomplete unit test:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-java s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-java\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;MapUtilitiesTest\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;extends\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;TestCase\u0026lt;/span\u0026gt; {\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;testSorting\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt; {\n    HashMap\u0026amp;lt;String, Integer\u0026amp;gt; map = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;HashMap\u0026lt;/span\u0026gt;\u0026amp;lt;String, Integer\u0026amp;gt;();\n    map.put(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;One\u0026quot;\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;);\n    map.put(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Two\u0026quot;\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;);\n    map.put(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Three\u0026quot;\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3\u0026lt;/span\u0026gt;);\n\n    List\u0026amp;lt;Map.Entry\u0026amp;lt;String, Integer\u0026amp;gt;\u0026amp;gt; sorted = MapUtilities.sortByValue(map);\n    assertEquals(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;First\u0026quot;\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;One\u0026quot;\u0026lt;/span\u0026gt;, sorted.get(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;).getKey());\n    assertEquals(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Second\u0026quot;\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Two\u0026quot;\u0026lt;/span\u0026gt;, sorted.get(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;).getKey());\n    assertEquals(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Third\u0026quot;\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Three\u0026quot;\u0026lt;/span\u0026gt;, sorted.get(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;).getKey());\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;}\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;The result is a sorted list of Map.Entry objects, from which you can obtain the keys and values.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Use a generic comparator such as:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-java s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-java\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;final\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;MapValueComparator\u0026lt;/span\u0026gt;\u0026amp;lt;K,V \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;extends\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Comparable\u0026lt;/span\u0026gt;\u0026amp;lt;V\u0026amp;gt;\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;implements\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Comparator\u0026lt;/span\u0026gt;\u0026amp;lt;K\u0026amp;gt; {\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;private\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;final\u0026lt;/span\u0026gt; Map\u0026amp;lt;K,V\u0026amp;gt; map;\n    \n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;private\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;MapValueComparator\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt; {\n        \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;super\u0026lt;/span\u0026gt;();\n    }\n    \n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;MapValueComparator\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(Map\u0026amp;lt;K,V\u0026amp;gt; map)\u0026lt;/span\u0026gt; {\n        \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;this\u0026lt;/span\u0026gt;();\n        \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;this\u0026lt;/span\u0026gt;.map = map;\n    }\n        \n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;compare\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(K o1, K o2)\u0026lt;/span\u0026gt; {\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; map.get(o1).compareTo(map.get(o2));\n    }\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;The answer voted for the most does not work when you have 2 items that equals.\nthe TreeMap leaves equal values out.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;the exmaple:\nunsorted map\u0026lt;/p\u0026gt;\n\n\u0026lt;pre\u0026gt;key/value: D/67.3\nkey/value: A/99.5\nkey/value: B/67.4\nkey/value: C/67.5\nkey/value: E/99.5\n\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;results\u0026lt;/p\u0026gt;\n\n\u0026lt;pre\u0026gt;key/value: A/99.5\nkey/value: C/67.5\nkey/value: B/67.4\nkey/value: D/67.3\n\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;So leaves out E!!\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;For me it worked fine to adjust the comparator, if it equals do not return 0 but -1.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;in the example:\u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;blockquote\u0026gt;\n    \u0026lt;p\u0026gt;class ValueComparator implements Comparator {\u0026lt;/p\u0026gt;\n    \n    \u0026lt;p\u0026gt;Map base;\n      public ValueComparator(Map base) {\n          this.base = base;\n      }\u0026lt;/p\u0026gt;\n    \n    \u0026lt;p\u0026gt;public int compare(Object a, Object b) {\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-java s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-java\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt;((Double)base.get(a) \u0026amp;lt; (Double)base.get(b)) {\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;;\n} \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;else\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt;((Double)base.get(a) == (Double)base.get(b)) {\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; -\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;;\n} \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;else\u0026lt;/span\u0026gt; {\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; -\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    \n    \u0026lt;p\u0026gt;}\n    }\u0026lt;/p\u0026gt;\n  \u0026lt;/blockquote\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;p\u0026gt;now it returns:\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;unsorted map:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre\u0026gt;key/value: D/67.3\nkey/value: A/99.5\nkey/value: B/67.4\nkey/value: C/67.5\nkey/value: E/99.5\n\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;results:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre\u0026gt;key/value: A/99.5\nkey/value: E/99.5\nkey/value: C/67.5\nkey/value: B/67.4\nkey/value: D/67.3\n\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;as a response to Aliens (2011 nov. 22):\nI Am using this solution for a map of Integer Id\u0026apos;s and names, but the idea is the same, so might be the code above is not correct (I will write it in a test and give you the correct code), this is the code for a Map sorting, based on the solution above:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-java s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-java\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;package\u0026lt;/span\u0026gt; nl.iamit.util;\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;import\u0026lt;/span\u0026gt; java.util.Comparator;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;import\u0026lt;/span\u0026gt; java.util.Map;\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Comparators\u0026lt;/span\u0026gt; {\n\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;static\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;MapIntegerStringComparator\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;implements\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Comparator\u0026lt;/span\u0026gt; {\n\n        Map\u0026amp;lt;Integer, String\u0026amp;gt; base;\n\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;MapIntegerStringComparator\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(Map\u0026amp;lt;Integer, String\u0026amp;gt; base)\u0026lt;/span\u0026gt; {\n            \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;this\u0026lt;/span\u0026gt;.base = base;\n        }\n\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;compare\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(Object a, Object b)\u0026lt;/span\u0026gt; {\n\n            \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;compare\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; ((String) base.get(a))\n                    .compareTo((String) base.get(b));\n            \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (compare == \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;) {\n                \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; -\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;;\n            }\n            \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; compare;\n        }\n    }\n\n\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;and this is the test class (I just tested it, and this works for the Integer, String Map:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-java s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-java\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;package\u0026lt;/span\u0026gt; test.nl.iamit.util;\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;import\u0026lt;/span\u0026gt; java.util.HashMap;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;import\u0026lt;/span\u0026gt; java.util.TreeMap;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;import\u0026lt;/span\u0026gt; nl.iamit.util.Comparators;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;import\u0026lt;/span\u0026gt; org.junit.Test;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;import\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;static\u0026lt;/span\u0026gt; org.junit.Assert.assertArrayEquals;\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;TestComparators\u0026lt;/span\u0026gt; {\n\n\n    \u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;@Test\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;testMapIntegerStringComparator\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt;{\n        HashMap\u0026amp;lt;Integer, String\u0026amp;gt; unSoretedMap = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;HashMap\u0026lt;/span\u0026gt;\u0026amp;lt;Integer, String\u0026amp;gt;();\n        Comparators.\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;MapIntegerStringComparator\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;bvc\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Comparators\u0026lt;/span\u0026gt;.MapIntegerStringComparator(\n                unSoretedMap);\n        TreeMap\u0026amp;lt;Integer, String\u0026amp;gt; sorted_map = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;TreeMap\u0026lt;/span\u0026gt;\u0026amp;lt;Integer, String\u0026amp;gt;(bvc);\n        \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//the testdata:\u0026lt;/span\u0026gt;\n        unSoretedMap.put(\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Integer\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;), \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;E\u0026quot;\u0026lt;/span\u0026gt;);\n        unSoretedMap.put(\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Integer\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;), \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;A\u0026quot;\u0026lt;/span\u0026gt;);\n        unSoretedMap.put(\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Integer\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3\u0026lt;/span\u0026gt;), \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;E\u0026quot;\u0026lt;/span\u0026gt;);\n        unSoretedMap.put(\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Integer\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;4\u0026lt;/span\u0026gt;), \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;B\u0026quot;\u0026lt;/span\u0026gt;);\n        unSoretedMap.put(\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Integer\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;5\u0026lt;/span\u0026gt;), \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;F\u0026quot;\u0026lt;/span\u0026gt;);\n\n        sorted_map.putAll(unSoretedMap);\n\n        Object[] targetKeys={\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Integer\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;),\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Integer\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;4\u0026lt;/span\u0026gt;),\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Integer\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3\u0026lt;/span\u0026gt;),\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Integer\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;),\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Integer\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;5\u0026lt;/span\u0026gt;) };\n        Object[] currecntKeys=sorted_map.keySet().toArray();\n\n        assertArrayEquals(targetKeys,currecntKeys);\n    }\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;here is the code for the Comparator of a Map:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-java s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-java\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;static\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;MapStringDoubleComparator\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;implements\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Comparator\u0026lt;/span\u0026gt; {\n\n    Map\u0026amp;lt;String, Double\u0026amp;gt; base;\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;MapStringDoubleComparator\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(Map\u0026amp;lt;String, Double\u0026amp;gt; base)\u0026lt;/span\u0026gt; {\n        \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;this\u0026lt;/span\u0026gt;.base = base;\n    }\n\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//note if you want decending in stead of ascending, turn around 1 and -1\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;compare\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(Object a, Object b)\u0026lt;/span\u0026gt; {\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; ((Double) base.get(a) == (Double) base.get(b)) {\n            \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;;\n        } \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;else\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt;((Double) base.get(a) \u0026amp;lt; (Double) base.get(b)) {\n            \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; -\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;;\n        }\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;else\u0026lt;/span\u0026gt;{\n            \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;;\n        }\n    }\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;and this is the testcase for this:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-java s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-java\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;@Test\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;testMapStringDoubleComparator\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt;{\n    HashMap\u0026amp;lt;String, Double\u0026amp;gt; unSoretedMap = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;HashMap\u0026lt;/span\u0026gt;\u0026amp;lt;String, Double\u0026amp;gt;();\n    Comparators.\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;MapStringDoubleComparator\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;bvc\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Comparators\u0026lt;/span\u0026gt;.MapStringDoubleComparator(\n            unSoretedMap);\n    TreeMap\u0026amp;lt;String, Double\u0026amp;gt; sorted_map = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;TreeMap\u0026lt;/span\u0026gt;\u0026amp;lt;String, Double\u0026amp;gt;(bvc);\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//the testdata:\u0026lt;/span\u0026gt;\n    unSoretedMap.put(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;D\u0026quot;\u0026lt;/span\u0026gt;,\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Double\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;67.3\u0026lt;/span\u0026gt;));\n    unSoretedMap.put(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;A\u0026quot;\u0026lt;/span\u0026gt;,\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Double\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;99.5\u0026lt;/span\u0026gt;));\n    unSoretedMap.put(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;B\u0026quot;\u0026lt;/span\u0026gt;,\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Double\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;67.4\u0026lt;/span\u0026gt;));\n    unSoretedMap.put(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;C\u0026quot;\u0026lt;/span\u0026gt;,\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Double\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;67.5\u0026lt;/span\u0026gt;));\n    unSoretedMap.put(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;E\u0026quot;\u0026lt;/span\u0026gt;,\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Double\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;99.5\u0026lt;/span\u0026gt;));\n\n    sorted_map.putAll(unSoretedMap);\n\n    Object[] targetKeys={\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;D\u0026quot;\u0026lt;/span\u0026gt;,\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;B\u0026quot;\u0026lt;/span\u0026gt;,\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;C\u0026quot;\u0026lt;/span\u0026gt;,\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;E\u0026quot;\u0026lt;/span\u0026gt;,\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;A\u0026quot;\u0026lt;/span\u0026gt;};\n    Object[] currecntKeys=sorted_map.keySet().toArray();\n\n    assertArrayEquals(targetKeys,currecntKeys);\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;of cource you can make this a lot more generic, but I just needed it for 1 case (the Map)\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Instead of using \u0026lt;code\u0026gt;Collections.sort\u0026lt;/code\u0026gt; as some do I\u0026apos;d suggest using \u0026lt;code\u0026gt;Arrays.sort\u0026lt;/code\u0026gt;. Actually what \u0026lt;code\u0026gt;Collections.sort\u0026lt;/code\u0026gt; does is something like this:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-java s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-java\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;static\u0026lt;/span\u0026gt; \u0026amp;lt;T \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;extends\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Comparable\u0026lt;/span\u0026gt;\u0026amp;lt;? \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;super\u0026lt;/span\u0026gt; T\u0026amp;gt;\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;sort\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(List\u0026amp;lt;T\u0026amp;gt; list)\u0026lt;/span\u0026gt; {\n    Object[] a = list.toArray();\n    Arrays.sort(a);\n    ListIterator\u0026amp;lt;T\u0026amp;gt; i = list.listIterator();\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt; (\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; j=\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;; j\u0026amp;lt;a.length; j++) {\n        i.next();\n        i.set((T)a[j]);\n    }\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;It just calls \u0026lt;code\u0026gt;toArray\u0026lt;/code\u0026gt; on the list and then uses \u0026lt;code\u0026gt;Arrays.sort\u0026lt;/code\u0026gt;. This way all the map entries will be copied three times: once from the map to the temporary list (be it a LinkedList or ArrayList), then to the temporary array and finally to the new map.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;My solution ommits this one step as it does not create unnecessary LinkedList. Here is the code, generic-friendly and performance-optimal:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-java s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-java\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;static\u0026lt;/span\u0026gt; \u0026amp;lt;K, V \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;extends\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Comparable\u0026lt;/span\u0026gt;\u0026amp;lt;? \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;super\u0026lt;/span\u0026gt; V\u0026amp;gt;\u0026amp;gt; Map\u0026amp;lt;K, V\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;sortByValue\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(Map\u0026amp;lt;K, V\u0026amp;gt; map)\u0026lt;/span\u0026gt; \n{\n    \u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;@SuppressWarnings(\u0026quot;unchecked\u0026quot;)\u0026lt;/span\u0026gt;\n    Map.Entry\u0026amp;lt;K,V\u0026amp;gt;[] array = map.entrySet().toArray(\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Map\u0026lt;/span\u0026gt;.Entry[map.size()]);\n\n    Arrays.sort(array, \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Comparator\u0026lt;/span\u0026gt;\u0026amp;lt;Map.Entry\u0026amp;lt;K, V\u0026amp;gt;\u0026amp;gt;() \n    {\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;compare\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(Map.Entry\u0026amp;lt;K, V\u0026amp;gt; e1, Map.Entry\u0026amp;lt;K, V\u0026amp;gt; e2)\u0026lt;/span\u0026gt; \n        {\n            \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; e1.getValue().compareTo(e2.getValue());\n        }\n    });\n\n    Map\u0026amp;lt;K, V\u0026amp;gt; result = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;LinkedHashMap\u0026lt;/span\u0026gt;\u0026amp;lt;K, V\u0026amp;gt;();\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt; (Map.Entry\u0026amp;lt;K, V\u0026amp;gt; entry : array)\n        result.put(entry.getKey(), entry.getValue());\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; result;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;This is a variation of Anthony\u0026apos;s answer, which doesn\u0026apos;t work if there are duplicate values:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-java s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-java\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;static\u0026lt;/span\u0026gt; \u0026amp;lt;K, V \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;extends\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Comparable\u0026lt;/span\u0026gt;\u0026amp;lt;V\u0026amp;gt;\u0026amp;gt; Map\u0026amp;lt;K, V\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;sortMapByValues\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;final\u0026lt;/span\u0026gt; Map\u0026amp;lt;K, V\u0026amp;gt; map)\u0026lt;/span\u0026gt; {\n    Comparator\u0026amp;lt;K\u0026amp;gt; valueComparator =  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Comparator\u0026lt;/span\u0026gt;\u0026amp;lt;K\u0026amp;gt;() {\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;compare\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(K k1, K k2)\u0026lt;/span\u0026gt; {\n            \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;final\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;V\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;v1\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; map.get(k1);\n            \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;final\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;V\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;v2\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; map.get(k2);\n\n            \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;/* Not sure how to handle nulls ... */\u0026lt;/span\u0026gt;\n            \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (v1 == \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;null\u0026lt;/span\u0026gt;) {\n                \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; (v2 == \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;null\u0026lt;/span\u0026gt;) ? \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt; : \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;;\n            }\n\n            \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;compare\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; v2.compareTo(v1);\n            \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (compare != \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;)\n            {\n                \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; compare;\n            }\n            \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;else\u0026lt;/span\u0026gt;\n            {\n                \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;Integer\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;h1\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; k1.hashCode();\n                \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;Integer\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;h2\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; k2.hashCode();\n                \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; h2.compareTo(h1);\n            }\n        }\n    };\n    Map\u0026amp;lt;K, V\u0026amp;gt; sortedByValues = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;TreeMap\u0026lt;/span\u0026gt;\u0026amp;lt;K, V\u0026amp;gt;(valueComparator);\n    sortedByValues.putAll(map);\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; sortedByValues;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Note that it\u0026apos;s rather up in the air how to handle nulls. \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;One important advantage of this approach is that it actually returns a Map, unlike some of the other solutions offered here.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Best Approach\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-java s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-java\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;import\u0026lt;/span\u0026gt; java.util.ArrayList;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;import\u0026lt;/span\u0026gt; java.util.Collections;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;import\u0026lt;/span\u0026gt; java.util.Comparator;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;import\u0026lt;/span\u0026gt; java.util.HashMap;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;import\u0026lt;/span\u0026gt; java.util.List;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;import\u0026lt;/span\u0026gt; java.util.Map;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;import\u0026lt;/span\u0026gt; java.util.Set;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;import\u0026lt;/span\u0026gt; java.util.Map.Entry; \n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;OrderByValue\u0026lt;/span\u0026gt; {\n\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;static\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;main\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(String a[])\u0026lt;/span\u0026gt;{\n    Map\u0026amp;lt;String, Integer\u0026amp;gt; map = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;HashMap\u0026lt;/span\u0026gt;\u0026amp;lt;String, Integer\u0026amp;gt;();\n    map.put(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;java\u0026quot;\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;20\u0026lt;/span\u0026gt;);\n    map.put(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;C++\u0026quot;\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;45\u0026lt;/span\u0026gt;);\n    map.put(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Unix\u0026quot;\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;67\u0026lt;/span\u0026gt;);\n    map.put(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;MAC\u0026quot;\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;26\u0026lt;/span\u0026gt;);\n    map.put(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Why this kolavari\u0026quot;\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;93\u0026lt;/span\u0026gt;);\n    Set\u0026amp;lt;Entry\u0026amp;lt;String, Integer\u0026amp;gt;\u0026amp;gt; set = map.entrySet();\n    List\u0026amp;lt;Entry\u0026amp;lt;String, Integer\u0026amp;gt;\u0026amp;gt; list = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;ArrayList\u0026lt;/span\u0026gt;\u0026amp;lt;Entry\u0026amp;lt;String, Integer\u0026amp;gt;\u0026amp;gt;(set);\n    Collections.sort( list, \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Comparator\u0026lt;/span\u0026gt;\u0026amp;lt;Map.Entry\u0026amp;lt;String, Integer\u0026amp;gt;\u0026amp;gt;()\n    {\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;compare\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;( Map.Entry\u0026amp;lt;String, Integer\u0026amp;gt; o1, Map.Entry\u0026amp;lt;String, Integer\u0026amp;gt; o2 )\u0026lt;/span\u0026gt;\n        {\n            \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; (o1.getValue()).compareTo( o2.getValue() );\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//Ascending order\u0026lt;/span\u0026gt;\n            \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//return (o2.getValue()).compareTo( o1.getValue() );//Descending order\u0026lt;/span\u0026gt;\n        }\n    } );\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt;(Map.Entry\u0026amp;lt;String, Integer\u0026amp;gt; entry:list){\n        System.out.println(entry.getKey()+\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot; ==== \u0026quot;\u0026lt;/span\u0026gt;+entry.getValue());\n    }\n  }}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Output\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-java s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-java\u0026quot;\u0026gt;java ==== \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;20\u0026lt;/span\u0026gt;\n\nMAC ==== \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;26\u0026lt;/span\u0026gt;\n\nC++ ==== \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;45\u0026lt;/span\u0026gt;\n\nUnix ==== \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;67\u0026lt;/span\u0026gt;\n\nWhy \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;this\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;kolavari\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt;=== \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;93\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Late Entry.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;With the advent of Java-8, we can use streams for data manipulation in a very easy/succinct way. You can use streams to sort the map entries by value and create a \u0026lt;a href=\u0026quot;https://docs.oracle.com/javase/8/docs/api/java/util/LinkedHashMap.html\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;LinkedHashMap\u0026lt;/a\u0026gt; which preserves \u0026lt;em\u0026gt;insertion-order\u0026lt;/em\u0026gt; iteration.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Eg:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-java s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-java\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;LinkedHashMap\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;sortedByValueMap\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; map.entrySet().stream()\n                .sorted(comparing(Entry\u0026amp;lt;Key,Value\u0026amp;gt;::getValue).thenComparing(Entry::getKey))     \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//first sorting by Value, then sorting by Key(entries with same value)\u0026lt;/span\u0026gt;\n                .collect(LinkedHashMap::\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt;,(map,entry) -\u0026amp;gt; map.put(entry.getKey(),entry.getValue()),LinkedHashMap::putAll);\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;hr\u0026gt;\n\n\u0026lt;p\u0026gt;For reverse ordering, replace:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-java s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-java\u0026quot;\u0026gt;comparing(Entry\u0026amp;lt;Key,Value\u0026amp;gt;::getValue).thenComparing(Entry::getKey)\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;with\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-java s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-java\u0026quot;\u0026gt;comparing(Entry\u0026amp;lt;Key,Value\u0026amp;gt;::getValue).thenComparing(Entry::getKey).reversed()\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Major problem. If you use the first answer (Google takes you here), change the comparator to add an equal clause, otherwise you cannot get values from the sorted_map by keys:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-java s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-java\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;compare\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(String a, String b)\u0026lt;/span\u0026gt; {\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (base.get(a) \u0026amp;gt; base.get(b)) {\n            \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;;\n        } \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;else\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (base.get(a) \u0026amp;lt; base.get(b)){\n            \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; -\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;;\n        } \n\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;;\n        \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// returning 0 would merge keys\u0026lt;/span\u0026gt;\n    }\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;There are a lot of answers for this question already, but none provided me what I was looking for, a map implementation that returns keys and entries sorted by the associated value, and maintains this property as keys and values are modified in the map. Two \u0026lt;a href=\u0026quot;https://stackoverflow.com/q/13108887/1760575\u0026quot;\u0026gt;other\u0026lt;/a\u0026gt; \u0026lt;a href=\u0026quot;https://stackoverflow.com/q/7465369/1760575\u0026quot;\u0026gt;questions\u0026lt;/a\u0026gt; ask for this specifically. \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;I cooked up a generic friendly example that solves this use case. This implementation does not honor all of the contracts of the Map interface, such as reflecting value changes and removals in the sets return from keySet() and entrySet() in the original object. I felt such a solution would be too large to include in a Stack Overflow answer. If I manage to create a more complete implementation, perhaps I will post it to Github and then to it link in an updated version of this answer.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-java s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-java\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;import\u0026lt;/span\u0026gt; java.util.*;\n\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;/**\n * A map where {\u0026lt;span class=\u0026quot;hljs-doctag\u0026quot;\u0026gt;@link\u0026lt;/span\u0026gt; #keySet()} and {\u0026lt;span class=\u0026quot;hljs-doctag\u0026quot;\u0026gt;@link\u0026lt;/span\u0026gt; #entrySet()} return sets ordered\n * by associated values based on the the comparator provided at construction\n * time. The order of two or more keys with identical values is not defined.\n * \u0026amp;lt;p\u0026amp;gt;\n * Several contracts of the Map interface are not satisfied by this minimal\n * implementation.\n */\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;ValueSortedMap\u0026lt;/span\u0026gt;\u0026amp;lt;K, V\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;extends\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;HashMap\u0026lt;/span\u0026gt;\u0026amp;lt;K, V\u0026amp;gt; {\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;protected\u0026lt;/span\u0026gt; Map\u0026amp;lt;V, Collection\u0026amp;lt;K\u0026amp;gt;\u0026amp;gt; valueToKeysMap;\n\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// uses natural order of value object, if any\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;ValueSortedMap\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt; {\n        \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;this\u0026lt;/span\u0026gt;((Comparator\u0026amp;lt;? \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;super\u0026lt;/span\u0026gt; V\u0026amp;gt;) \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;null\u0026lt;/span\u0026gt;);\n    }\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;ValueSortedMap\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(Comparator\u0026amp;lt;? \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;super\u0026lt;/span\u0026gt; V\u0026amp;gt; valueComparator)\u0026lt;/span\u0026gt; {\n        \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;this\u0026lt;/span\u0026gt;.valueToKeysMap = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;TreeMap\u0026lt;/span\u0026gt;\u0026amp;lt;V, Collection\u0026amp;lt;K\u0026amp;gt;\u0026amp;gt;(valueComparator);\n    }\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;boolean\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;containsValue\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(Object o)\u0026lt;/span\u0026gt; {\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; valueToKeysMap.containsKey(o);\n    }\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; V \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;put\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(K k, V v)\u0026lt;/span\u0026gt; {\n        \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;V\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;oldV\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;null\u0026lt;/span\u0026gt;;\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (containsKey(k)) {\n            oldV = get(k);\n            valueToKeysMap.get(oldV).remove(k);\n        }\n        \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;super\u0026lt;/span\u0026gt;.put(k, v);\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (!valueToKeysMap.containsKey(v)) {\n            Collection\u0026amp;lt;K\u0026amp;gt; keys = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;ArrayList\u0026lt;/span\u0026gt;\u0026amp;lt;K\u0026amp;gt;();\n            keys.add(k);\n            valueToKeysMap.put(v, keys);\n        } \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;else\u0026lt;/span\u0026gt; {\n            valueToKeysMap.get(v).add(k);\n        }\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; oldV;\n    }\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;putAll\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(Map\u0026amp;lt;? extends K, ? extends V\u0026amp;gt; m)\u0026lt;/span\u0026gt; {\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt; (Map.Entry\u0026amp;lt;? \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;extends\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;K\u0026lt;/span\u0026gt;, ? \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;extends\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;V\u0026lt;/span\u0026gt;\u0026amp;gt; e : m.entrySet())\n            put(e.getKey(), e.getValue());\n    }\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; V \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;remove\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(Object k)\u0026lt;/span\u0026gt; {\n        \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;V\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;oldV\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;null\u0026lt;/span\u0026gt;;\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (containsKey(k)) {\n            oldV = get(k);\n            \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;super\u0026lt;/span\u0026gt;.remove(k);\n            valueToKeysMap.get(oldV).remove(k);\n        }\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; oldV;\n    }\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;clear\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt; {\n        \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;super\u0026lt;/span\u0026gt;.clear();\n        valueToKeysMap.clear();\n    }\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; Set\u0026amp;lt;K\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;keySet\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt; {\n        LinkedHashSet\u0026amp;lt;K\u0026amp;gt; ret = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;LinkedHashSet\u0026lt;/span\u0026gt;\u0026amp;lt;K\u0026amp;gt;(size());\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt; (V v : valueToKeysMap.keySet()) {\n            Collection\u0026amp;lt;K\u0026amp;gt; keys = valueToKeysMap.get(v);\n            ret.addAll(keys);\n        }\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; ret;\n    }\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; Set\u0026amp;lt;Map.Entry\u0026amp;lt;K, V\u0026amp;gt;\u0026amp;gt; entrySet() {\n        LinkedHashSet\u0026amp;lt;Map.Entry\u0026amp;lt;K, V\u0026amp;gt;\u0026amp;gt; ret = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;LinkedHashSet\u0026lt;/span\u0026gt;\u0026amp;lt;Map.Entry\u0026amp;lt;K, V\u0026amp;gt;\u0026amp;gt;(size());\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt; (Collection\u0026amp;lt;K\u0026amp;gt; keys : valueToKeysMap.values()) {\n            \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt; (\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;final\u0026lt;/span\u0026gt; K k : keys) {\n                \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;final\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;V\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;v\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; get(k);\n                ret.add(\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Map\u0026lt;/span\u0026gt;.Entry\u0026amp;lt;K,V\u0026amp;gt;() {\n                    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; K \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;getKey\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt; {\n                        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; k;\n                    }\n\n                    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; V \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;getValue\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt; {\n                        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; v;\n                    }\n\n                    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; V \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;setValue\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(V v)\u0026lt;/span\u0026gt; {\n                        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;throw\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;UnsupportedOperationException\u0026lt;/span\u0026gt;();\n                    }\n                });\n            }\n        }\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; ret;\n    }\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Simple way to sort any map in Java 8 and above\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-java s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-java\u0026quot;\u0026gt;Map\u0026amp;lt;String, Object\u0026amp;gt; mapToSort = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;HashMap\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026amp;gt;();\n\nList\u0026amp;lt;Map.Entry\u0026amp;lt;String, Object\u0026amp;gt;\u0026amp;gt; list = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;LinkedList\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026amp;gt;(mapToSort.entrySet());\n\nCollections.sort(list, Comparator.comparing(o -\u0026amp;gt; o.getValue().getAttribute()));\n\nHashMap\u0026amp;lt;String, Object\u0026amp;gt; sortedMap = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;LinkedHashMap\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026amp;gt;();\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt; (Map.Entry\u0026amp;lt;String, Object\u0026amp;gt; map : list) {\n   sortedMap.put(map.getKey(), map.getValue());\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;if you are using Java 7 and below\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-java s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-java\u0026quot;\u0026gt;Map\u0026amp;lt;String, Object\u0026amp;gt; mapToSort = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;HashMap\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026amp;gt;();\n\nList\u0026amp;lt;Map.Entry\u0026amp;lt;String, Object\u0026amp;gt;\u0026amp;gt; list = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;LinkedList\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026amp;gt;(mapToSort.entrySet());\n\nCollections.sort(list, \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Comparator\u0026lt;/span\u0026gt;\u0026amp;lt;Map.Entry\u0026amp;lt;String, Object\u0026amp;gt;\u0026amp;gt;() {\n    \u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;@Override\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;compare\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(Map.Entry\u0026amp;lt;String, Object\u0026amp;gt; o1, Map.Entry\u0026amp;lt;String, Object\u0026amp;gt; o2)\u0026lt;/span\u0026gt; {\n       \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; o1.getValue().getAttribute().compareTo(o2.getValue().getAttribute());      \n    }\n});\n\nHashMap\u0026amp;lt;String, Object\u0026amp;gt; sortedMap = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;LinkedHashMap\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026amp;gt;();\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt; (Map.Entry\u0026amp;lt;String, Object\u0026amp;gt; map : list) {\n   sortedMap.put(map.getKey(), map.getValue());\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Depending on the context, using \u0026lt;code\u0026gt;java.util.LinkedHashMap\u0026amp;lt;T\u0026amp;gt;\u0026lt;/code\u0026gt; which rememebers the order in which items are placed into the map.  Otherwise, if you need to sort values based on their natural ordering, I would recommend maintaining a separate List which can be sorted via \u0026lt;code\u0026gt;Collections.sort()\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Afaik the most cleaner way is utilizing collections to sort map on value:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-java s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-java\u0026quot;\u0026gt;Map\u0026amp;lt;String, Long\u0026amp;gt; map = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;HashMap\u0026lt;/span\u0026gt;\u0026amp;lt;String, Long\u0026amp;gt;();\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// populate with data to sort on Value\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// use datastructure designed for sorting\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;Queue\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;queue\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;PriorityQueue\u0026lt;/span\u0026gt;( map.size(), \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;MapComparable\u0026lt;/span\u0026gt;() );\nqueue.addAll( map.entrySet() );\n\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// get a sorted map\u0026lt;/span\u0026gt;\nLinkedHashMap\u0026amp;lt;String, Long\u0026amp;gt; linkedMap = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;LinkedHashMap\u0026lt;/span\u0026gt;\u0026amp;lt;String, Long\u0026amp;gt;();\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt; (Map.Entry\u0026amp;lt;String, Long\u0026amp;gt; entry; (entry = queue.poll())!=\u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;null\u0026lt;/span\u0026gt;;) {\n    linkedMap.put(entry.getKey(), entry.getValue());\n}\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;static\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;MapComparable\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;implements\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Comparator\u0026lt;/span\u0026gt;\u0026amp;lt;Map.Entry\u0026amp;lt;String, Long\u0026amp;gt;\u0026amp;gt;{\n\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;compare\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(Entry\u0026amp;lt;String, Long\u0026amp;gt; e1, Entry\u0026amp;lt;String, Long\u0026amp;gt; e2)\u0026lt;/span\u0026gt; {\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; e1.getValue().compareTo(e2.getValue());\n  }\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Since \u0026lt;strong\u0026gt;\u0026lt;em\u0026gt;TreeMap\u0026amp;lt;\u0026amp;gt; does not work\u0026lt;/em\u0026gt;\u0026lt;/strong\u0026gt; for values that can be equal, I used this:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-java s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-java\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;private\u0026lt;/span\u0026gt; \u0026amp;lt;K, V \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;extends\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Comparable\u0026lt;/span\u0026gt;\u0026amp;lt;? \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;super\u0026lt;/span\u0026gt; V\u0026amp;gt;\u0026amp;gt; List\u0026amp;lt;Entry\u0026amp;lt;K, V\u0026amp;gt;\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;sort\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(Map\u0026amp;lt;K, V\u0026amp;gt; map)\u0026lt;/span\u0026gt;     {\n    List\u0026amp;lt;Map.Entry\u0026amp;lt;K, V\u0026amp;gt;\u0026amp;gt; list = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;LinkedList\u0026lt;/span\u0026gt;\u0026amp;lt;Map.Entry\u0026amp;lt;K, V\u0026amp;gt;\u0026amp;gt;(map.entrySet());\n    Collections.sort(list, \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Comparator\u0026lt;/span\u0026gt;\u0026amp;lt;Map.Entry\u0026amp;lt;K, V\u0026amp;gt;\u0026amp;gt;() {\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;compare\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(Map.Entry\u0026amp;lt;K, V\u0026amp;gt; o1, Map.Entry\u0026amp;lt;K, V\u0026amp;gt; o2)\u0026lt;/span\u0026gt; {\n            \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; o1.getValue().compareTo(o2.getValue());\n        }\n    });\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; list;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;You might want to put \u0026lt;strong\u0026gt;\u0026lt;em\u0026gt;list\u0026lt;/em\u0026gt;\u0026lt;/strong\u0026gt; in a \u0026lt;strong\u0026gt;\u0026lt;em\u0026gt;LinkedHashMap\u0026lt;/em\u0026gt;\u0026lt;/strong\u0026gt;, but if you\u0026apos;re only going to iterate over it right away, that\u0026apos;s superfluous...\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;This is just too complicated. Maps were not supposed to do such job as sorting them by Value. The easiest way is to create your own Class so it fits your requirement.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;In example lower you are supposed to add TreeMap a comparator at place where * is. But by java API it gives comparator only keys, not values. All of examples stated here is based on 2 Maps. One Hash and one new Tree. Which is odd.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;The example:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-java s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-java\u0026quot;\u0026gt;Map\u0026amp;lt;Driver driver, Float time\u0026amp;gt; map = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;TreeMap\u0026lt;/span\u0026gt;\u0026amp;lt;Driver driver, Float time\u0026amp;gt;(*);\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;So change the map into a set this way:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-java s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-java\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;ResultComparator\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;rc\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;ResultComparator\u0026lt;/span\u0026gt;();\nSet\u0026amp;lt;Results\u0026amp;gt; set = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;TreeSet\u0026lt;/span\u0026gt;\u0026amp;lt;Results\u0026amp;gt;(rc);\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;You will create class \u0026lt;code\u0026gt;Results\u0026lt;/code\u0026gt;,\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-java s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-java\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Results\u0026lt;/span\u0026gt; {\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;private\u0026lt;/span\u0026gt; Driver driver;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;private\u0026lt;/span\u0026gt; Float time;\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;Results\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(Driver driver, Float time)\u0026lt;/span\u0026gt; {\n        \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;this\u0026lt;/span\u0026gt;.driver = driver;\n        \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;this\u0026lt;/span\u0026gt;.time = time;\n    }\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; Float \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;getTime\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt; {\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; time;\n    }\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;setTime\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(Float time)\u0026lt;/span\u0026gt; {\n        \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;this\u0026lt;/span\u0026gt;.time = time;\n    }\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; Driver \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;getDriver\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt; {\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; driver;\n    }\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;setDriver\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(Driver driver)\u0026lt;/span\u0026gt; {\n        \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;this\u0026lt;/span\u0026gt;.driver = driver;\n    }\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;and the Comparator class:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-java s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-java\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;ResultsComparator\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;implements\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Comparator\u0026lt;/span\u0026gt;\u0026amp;lt;Results\u0026amp;gt; {\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;compare\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(Results t, Results t1)\u0026lt;/span\u0026gt; {\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (t.getTime() \u0026amp;lt; t1.getTime()) {\n            \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;;\n        } \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;else\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (t.getTime() == t1.getTime()) {\n            \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;;\n        } \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;else\u0026lt;/span\u0026gt; {\n            \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; -\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;;\n        }\n    }\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;This way you can easily add more dependencies.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;And as the last point I\u0026apos;ll add simple iterator:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-java s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-java\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;Iterator\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;it\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; set.iterator();\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;while\u0026lt;/span\u0026gt; (it.hasNext()) {\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;Results\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;r\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; (Results)it.next();\n    System.out.println( r.getDriver().toString\n        \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//or whatever that is related to Driver class -getName() getSurname()\u0026lt;/span\u0026gt;\n        + \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot; \u0026quot;\u0026lt;/span\u0026gt;\n        + r.getTime()\n        );\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Based on @devinmoore code, a map sorting methods using generics and supporting both ascending and descending ordering.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-java s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-java\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;/**\n * Sort a map by it\u0026apos;s keys in ascending order. \n *  \n * \u0026lt;span class=\u0026quot;hljs-doctag\u0026quot;\u0026gt;@return\u0026lt;/span\u0026gt; new instance of {\u0026lt;span class=\u0026quot;hljs-doctag\u0026quot;\u0026gt;@link\u0026lt;/span\u0026gt; LinkedHashMap} contained sorted entries of supplied map.\n * \u0026lt;span class=\u0026quot;hljs-doctag\u0026quot;\u0026gt;@author\u0026lt;/span\u0026gt; Maxim Veksler\n */\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;static\u0026lt;/span\u0026gt; \u0026amp;lt;K, V\u0026amp;gt; LinkedHashMap\u0026amp;lt;K, V\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;sortMapByKey\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;final\u0026lt;/span\u0026gt; Map\u0026amp;lt;K, V\u0026amp;gt; map)\u0026lt;/span\u0026gt; {\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; sortMapByKey(map, SortingOrder.ASCENDING);\n}\n\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;/**\n * Sort a map by it\u0026apos;s values in ascending order.\n *  \n * \u0026lt;span class=\u0026quot;hljs-doctag\u0026quot;\u0026gt;@return\u0026lt;/span\u0026gt; new instance of {\u0026lt;span class=\u0026quot;hljs-doctag\u0026quot;\u0026gt;@link\u0026lt;/span\u0026gt; LinkedHashMap} contained sorted entries of supplied map.\n * \u0026lt;span class=\u0026quot;hljs-doctag\u0026quot;\u0026gt;@author\u0026lt;/span\u0026gt; Maxim Veksler\n */\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;static\u0026lt;/span\u0026gt; \u0026amp;lt;K, V\u0026amp;gt; LinkedHashMap\u0026amp;lt;K, V\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;sortMapByValue\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;final\u0026lt;/span\u0026gt; Map\u0026amp;lt;K, V\u0026amp;gt; map)\u0026lt;/span\u0026gt; {\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; sortMapByValue(map, SortingOrder.ASCENDING);\n}\n\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;/**\n * Sort a map by it\u0026apos;s keys.\n *  \n * \u0026lt;span class=\u0026quot;hljs-doctag\u0026quot;\u0026gt;@param\u0026lt;/span\u0026gt; sortingOrder {\u0026lt;span class=\u0026quot;hljs-doctag\u0026quot;\u0026gt;@link\u0026lt;/span\u0026gt; SortingOrder} enum specifying requested sorting order. \n * \u0026lt;span class=\u0026quot;hljs-doctag\u0026quot;\u0026gt;@return\u0026lt;/span\u0026gt; new instance of {\u0026lt;span class=\u0026quot;hljs-doctag\u0026quot;\u0026gt;@link\u0026lt;/span\u0026gt; LinkedHashMap} contained sorted entries of supplied map.\n * \u0026lt;span class=\u0026quot;hljs-doctag\u0026quot;\u0026gt;@author\u0026lt;/span\u0026gt; Maxim Veksler\n */\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;static\u0026lt;/span\u0026gt; \u0026amp;lt;K, V\u0026amp;gt; LinkedHashMap\u0026amp;lt;K, V\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;sortMapByKey\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;final\u0026lt;/span\u0026gt; Map\u0026amp;lt;K, V\u0026amp;gt; map, \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;final\u0026lt;/span\u0026gt; SortingOrder sortingOrder)\u0026lt;/span\u0026gt; {\n    Comparator\u0026amp;lt;Map.Entry\u0026amp;lt;K, V\u0026amp;gt;\u0026amp;gt; comparator = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Comparator\u0026lt;/span\u0026gt;\u0026amp;lt;Entry\u0026amp;lt;K,V\u0026amp;gt;\u0026amp;gt;() {\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;compare\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(Entry\u0026amp;lt;K, V\u0026amp;gt; o1, Entry\u0026amp;lt;K, V\u0026amp;gt; o2)\u0026lt;/span\u0026gt; {\n            \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; comparableCompare(o1.getKey(), o2.getKey(), sortingOrder);\n        }\n    };\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; sortMap(map, comparator);\n}\n\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;/**\n * Sort a map by it\u0026apos;s values.\n *  \n * \u0026lt;span class=\u0026quot;hljs-doctag\u0026quot;\u0026gt;@param\u0026lt;/span\u0026gt; sortingOrder {\u0026lt;span class=\u0026quot;hljs-doctag\u0026quot;\u0026gt;@link\u0026lt;/span\u0026gt; SortingOrder} enum specifying requested sorting order. \n * \u0026lt;span class=\u0026quot;hljs-doctag\u0026quot;\u0026gt;@return\u0026lt;/span\u0026gt; new instance of {\u0026lt;span class=\u0026quot;hljs-doctag\u0026quot;\u0026gt;@link\u0026lt;/span\u0026gt; LinkedHashMap} contained sorted entries of supplied map.\n * \u0026lt;span class=\u0026quot;hljs-doctag\u0026quot;\u0026gt;@author\u0026lt;/span\u0026gt; Maxim Veksler\n */\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;static\u0026lt;/span\u0026gt; \u0026amp;lt;K, V\u0026amp;gt; LinkedHashMap\u0026amp;lt;K, V\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;sortMapByValue\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;final\u0026lt;/span\u0026gt; Map\u0026amp;lt;K, V\u0026amp;gt; map, \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;final\u0026lt;/span\u0026gt; SortingOrder sortingOrder)\u0026lt;/span\u0026gt; {\n    Comparator\u0026amp;lt;Map.Entry\u0026amp;lt;K, V\u0026amp;gt;\u0026amp;gt; comparator = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Comparator\u0026lt;/span\u0026gt;\u0026amp;lt;Entry\u0026amp;lt;K,V\u0026amp;gt;\u0026amp;gt;() {\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;compare\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(Entry\u0026amp;lt;K, V\u0026amp;gt; o1, Entry\u0026amp;lt;K, V\u0026amp;gt; o2)\u0026lt;/span\u0026gt; {\n            \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; comparableCompare(o1.getValue(), o2.getValue(), sortingOrder);\n        }\n    };\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; sortMap(map, comparator);\n}\n\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;@SuppressWarnings(\u0026quot;unchecked\u0026quot;)\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;private\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;static\u0026lt;/span\u0026gt; \u0026amp;lt;T\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;comparableCompare\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(T o1, T o2, SortingOrder sortingOrder)\u0026lt;/span\u0026gt; {\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;compare\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; ((Comparable\u0026amp;lt;T\u0026amp;gt;)o1).compareTo(o2);\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;switch\u0026lt;/span\u0026gt; (sortingOrder) {\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;case\u0026lt;/span\u0026gt; ASCENDING:\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; compare;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;case\u0026lt;/span\u0026gt; DESCENDING:\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; (-\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;) * compare;\n    }\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;;\n}\n\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;/**\n * Sort a map by supplied comparator logic.\n *  \n * \u0026lt;span class=\u0026quot;hljs-doctag\u0026quot;\u0026gt;@return\u0026lt;/span\u0026gt; new instance of {\u0026lt;span class=\u0026quot;hljs-doctag\u0026quot;\u0026gt;@link\u0026lt;/span\u0026gt; LinkedHashMap} contained sorted entries of supplied map.\n * \u0026lt;span class=\u0026quot;hljs-doctag\u0026quot;\u0026gt;@author\u0026lt;/span\u0026gt; Maxim Veksler\n */\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;static\u0026lt;/span\u0026gt; \u0026amp;lt;K, V\u0026amp;gt; LinkedHashMap\u0026amp;lt;K, V\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;sortMap\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;final\u0026lt;/span\u0026gt; Map\u0026amp;lt;K, V\u0026amp;gt; map, \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;final\u0026lt;/span\u0026gt; Comparator\u0026amp;lt;Map.Entry\u0026amp;lt;K, V\u0026amp;gt;\u0026amp;gt; comparator)\u0026lt;/span\u0026gt; {\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Convert the map into a list of key,value pairs.\u0026lt;/span\u0026gt;\n    List\u0026amp;lt;Map.Entry\u0026amp;lt;K, V\u0026amp;gt;\u0026amp;gt; mapEntries = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;LinkedList\u0026lt;/span\u0026gt;\u0026amp;lt;Map.Entry\u0026amp;lt;K, V\u0026amp;gt;\u0026amp;gt;(map.entrySet());\n\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Sort the converted list according to supplied comparator.\u0026lt;/span\u0026gt;\n    Collections.sort(mapEntries, comparator);\n\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Build a new ordered map, containing the same entries as the old map.  \u0026lt;/span\u0026gt;\n    LinkedHashMap\u0026amp;lt;K, V\u0026amp;gt; result = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;LinkedHashMap\u0026lt;/span\u0026gt;\u0026amp;lt;K, V\u0026amp;gt;(map.size() + (map.size() / \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;20\u0026lt;/span\u0026gt;));\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt;(Map.Entry\u0026amp;lt;K, V\u0026amp;gt; entry : mapEntries) {\n        \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// We iterate on the mapEntries list which is sorted by the comparator putting new entries into \u0026lt;/span\u0026gt;\n        \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// the targeted result which is a sorted map. \u0026lt;/span\u0026gt;\n        result.put(entry.getKey(), entry.getValue());\n    }\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; result;\n}\n\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;/**\n * Sorting order enum, specifying request result sort behavior.\n * \u0026lt;span class=\u0026quot;hljs-doctag\u0026quot;\u0026gt;@author\u0026lt;/span\u0026gt; Maxim Veksler\n *\n */\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;static\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;enum\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;SortingOrder\u0026lt;/span\u0026gt; {\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;/**\n     * Resulting sort will be from smaller to biggest.\n     */\u0026lt;/span\u0026gt;\n    ASCENDING,\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;/**\n     * Resulting sort will be from biggest to smallest.\n     */\u0026lt;/span\u0026gt;\n    DESCENDING\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Here is an OO solution (i.e., doesn\u0026apos;t use \u0026lt;code\u0026gt;static\u0026lt;/code\u0026gt; methods):\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-java s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-java\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;import\u0026lt;/span\u0026gt; java.util.Collections;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;import\u0026lt;/span\u0026gt; java.util.Comparator;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;import\u0026lt;/span\u0026gt; java.util.HashMap;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;import\u0026lt;/span\u0026gt; java.util.Iterator;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;import\u0026lt;/span\u0026gt; java.util.LinkedList;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;import\u0026lt;/span\u0026gt; java.util.LinkedHashMap;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;import\u0026lt;/span\u0026gt; java.util.List;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;import\u0026lt;/span\u0026gt; java.util.Map;\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;SortableValueMap\u0026lt;/span\u0026gt;\u0026amp;lt;K, V \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;extends\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Comparable\u0026lt;/span\u0026gt;\u0026amp;lt;V\u0026amp;gt;\u0026amp;gt;\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;extends\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;LinkedHashMap\u0026lt;/span\u0026gt;\u0026amp;lt;K, V\u0026amp;gt; {\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;SortableValueMap\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt; { }\n\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;SortableValueMap\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;( Map\u0026amp;lt;K, V\u0026amp;gt; map )\u0026lt;/span\u0026gt; {\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;super\u0026lt;/span\u0026gt;( map );\n  }\n\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;sortByValue\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt; {\n    List\u0026amp;lt;Map.Entry\u0026amp;lt;K, V\u0026amp;gt;\u0026amp;gt; list = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;LinkedList\u0026lt;/span\u0026gt;\u0026amp;lt;Map.Entry\u0026amp;lt;K, V\u0026amp;gt;\u0026amp;gt;( entrySet() );\n\n    Collections.sort( list, \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Comparator\u0026lt;/span\u0026gt;\u0026amp;lt;Map.Entry\u0026amp;lt;K, V\u0026amp;gt;\u0026amp;gt;() {\n      \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;compare\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;( Map.Entry\u0026amp;lt;K, V\u0026amp;gt; entry1, Map.Entry\u0026amp;lt;K, V\u0026amp;gt; entry2 )\u0026lt;/span\u0026gt; {\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; entry1.getValue().compareTo( entry2.getValue() );\n      }\n    });\n\n    clear();\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt;( Map.Entry\u0026amp;lt;K, V\u0026amp;gt; entry : list ) {\n      put( entry.getKey(), entry.getValue() );\n    }\n  }\n\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;private\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;static\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;( String text, Map\u0026amp;lt;String, Double\u0026amp;gt; map )\u0026lt;/span\u0026gt; {\n    System.out.println( text );\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt;( String key : map.keySet() ) {\n      System.out.println( \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;key/value: \u0026quot;\u0026lt;/span\u0026gt; + key + \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;/\u0026quot;\u0026lt;/span\u0026gt; + map.get( key ) );\n    }\n  }\n\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;static\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;main\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;( String[] args )\u0026lt;/span\u0026gt; {\n    SortableValueMap\u0026amp;lt;String, Double\u0026amp;gt; map =\n      \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;SortableValueMap\u0026lt;/span\u0026gt;\u0026amp;lt;String, Double\u0026amp;gt;();\n\n    map.put( \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;A\u0026quot;\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;67.5\u0026lt;/span\u0026gt; );\n    map.put( \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;B\u0026quot;\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;99.5\u0026lt;/span\u0026gt; );\n    map.put( \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;C\u0026quot;\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;82.4\u0026lt;/span\u0026gt; );\n    map.put( \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;D\u0026quot;\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;42.0\u0026lt;/span\u0026gt; );\n\n    print( \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Unsorted map\u0026quot;\u0026lt;/span\u0026gt;, map );\n    map.sortByValue();\n    print( \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Sorted map\u0026quot;\u0026lt;/span\u0026gt;, map );\n  }\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Hereby donated to the public domain.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Some simple changes in order to have a sorted map with pairs that have duplicate values. In the compare method (class ValueComparator) when values are equal do not return 0 but return the result of comparing the 2 keys. Keys are distinct in a map so you succeed to keep duplicate values (which are sorted by keys by the way). So the above example could be modified like this:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-java s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-java\u0026quot;\u0026gt;    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;compare\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(Object a, Object b)\u0026lt;/span\u0026gt; {\n\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt;((Double)base.get(a) \u0026amp;lt; (Double)base.get(b)) {\n          \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;;\n        } \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;else\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt;((Double)base.get(a) == (Double)base.get(b)) {\n          \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; ((String)a).compareTo((String)b);\n        } \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;else\u0026lt;/span\u0026gt; {\n          \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; -\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;;\n        }\n      }\n    }\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;For sure the solution of Stephen is really great, but for those who can\u0026apos;t use Guava:\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Here\u0026apos;s my solution for sorting by value a map.\nThis solution handle the case where there are twice the same value etc...\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-java s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-java\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// If you want to sort a map by value, and if there can be twice the same value:\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// here is your original map\u0026lt;/span\u0026gt;\nMap\u0026amp;lt;String,Integer\u0026amp;gt; mapToSortByValue = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;HashMap\u0026lt;/span\u0026gt;\u0026amp;lt;String, Integer\u0026amp;gt;();\nmapToSortByValue.put(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;A\u0026quot;\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3\u0026lt;/span\u0026gt;);\nmapToSortByValue.put(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;B\u0026quot;\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;);\nmapToSortByValue.put(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;C\u0026quot;\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3\u0026lt;/span\u0026gt;);\nmapToSortByValue.put(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;D\u0026quot;\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;5\u0026lt;/span\u0026gt;);\nmapToSortByValue.put(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;E\u0026quot;\u0026lt;/span\u0026gt;, -\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;);\nmapToSortByValue.put(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;F\u0026quot;\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1000\u0026lt;/span\u0026gt;);\nmapToSortByValue.put(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;G\u0026quot;\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;79\u0026lt;/span\u0026gt;);\nmapToSortByValue.put(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;H\u0026quot;\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;15\u0026lt;/span\u0026gt;);\n\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Sort all the map entries by value\u0026lt;/span\u0026gt;\nSet\u0026amp;lt;Map.Entry\u0026amp;lt;String,Integer\u0026amp;gt;\u0026amp;gt; set = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;TreeSet\u0026lt;/span\u0026gt;\u0026amp;lt;Map.Entry\u0026amp;lt;String,Integer\u0026amp;gt;\u0026amp;gt;(\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Comparator\u0026lt;/span\u0026gt;\u0026amp;lt;Map.Entry\u0026amp;lt;String,Integer\u0026amp;gt;\u0026amp;gt;(){\n            \u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;@Override\u0026lt;/span\u0026gt;\n            \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;compare\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(Map.Entry\u0026amp;lt;String,Integer\u0026amp;gt; obj1, Map.Entry\u0026amp;lt;String,Integer\u0026amp;gt; obj2)\u0026lt;/span\u0026gt; {\n                \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;Integer\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;val1\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; obj1.getValue();\n                \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;Integer\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;val2\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; obj2.getValue();\n                \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// DUPLICATE VALUE CASE\u0026lt;/span\u0026gt;\n                \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// If the values are equals, we can\u0026apos;t return 0 because the 2 entries would be considered\u0026lt;/span\u0026gt;\n                \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// as equals and one of them would be deleted (because we use a set, no duplicate, remember!)\u0026lt;/span\u0026gt;\n                \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;compareValues\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; val1.compareTo(val2);\n                \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; ( compareValues == \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt; ) {\n                    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;String\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;key1\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; obj1.getKey();\n                    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;String\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;key2\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; obj2.getKey();\n                    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;compareKeys\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; key1.compareTo(key2);\n                    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; ( compareKeys == \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt; ) {\n                        \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// what you return here will tell us if you keep REAL KEY-VALUE duplicates in your set\u0026lt;/span\u0026gt;\n                        \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// if you want to, do whatever you want but do not return 0 (but don\u0026apos;t break the comparator contract!)\u0026lt;/span\u0026gt;\n                        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;;\n                    }\n                    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; compareKeys;\n                }\n                \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; compareValues;\n            }\n        }\n);\nset.addAll(mapToSortByValue.entrySet());\n\n\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// OK NOW OUR SET IS SORTED COOL!!!!\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// And there\u0026apos;s nothing more to do: the entries are sorted by value!\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt; ( Map.Entry\u0026amp;lt;String,Integer\u0026amp;gt; entry : set ) {\n    System.out.println(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Set entries: \u0026quot;\u0026lt;/span\u0026gt; + entry.getKey() + \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot; -\u0026amp;gt; \u0026quot;\u0026lt;/span\u0026gt; + entry.getValue());\n}\n\n\n\n\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// But if you add them to an hashmap\u0026lt;/span\u0026gt;\nMap\u0026amp;lt;String,Integer\u0026amp;gt; myMap = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;HashMap\u0026lt;/span\u0026gt;\u0026amp;lt;String,Integer\u0026amp;gt;();\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// When iterating over the set the order is still good in the println...\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt; ( Map.Entry\u0026amp;lt;String,Integer\u0026amp;gt; entry : set ) {\n    System.out.println(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Added to result map entries: \u0026quot;\u0026lt;/span\u0026gt; + entry.getKey() + \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot; \u0026quot;\u0026lt;/span\u0026gt; + entry.getValue());\n    myMap.put(entry.getKey(), entry.getValue());\n}\n\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// But once they are in the hashmap, the order is not kept!\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt; ( Integer value : myMap.values() ) {\n    System.out.println(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Result map values: \u0026quot;\u0026lt;/span\u0026gt; + value);\n}\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Also this way doesn\u0026apos;t work:\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Logic because the entryset is a hashset for hashmaps and not a treeset\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// (and even if it was a treeset, it would be on the keys only)\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt; ( Map.Entry\u0026amp;lt;String,Integer\u0026amp;gt; entry : myMap.entrySet() ) {\n    System.out.println(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Result map entries: \u0026quot;\u0026lt;/span\u0026gt; + entry.getKey() + \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot; -\u0026amp;gt; \u0026quot;\u0026lt;/span\u0026gt; + entry.getValue());\n}\n\n\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// CONCLUSION:\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// If you want to iterate on a map ordered by value, you need to remember:\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// 1) Maps are only sorted by keys, so you can\u0026apos;t sort them directly by value\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// 2) So you simply CAN\u0026apos;T return a map to a sortMapByValue function\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// 3) You can\u0026apos;t reverse the keys and the values because you have duplicate values\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//    This also means you can\u0026apos;t neither use Guava/Commons bidirectionnal treemaps or stuff like that\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// SOLUTIONS\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// So you can:\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// 1) only sort the values which is easy, but you loose the key/value link (since you have duplicate values)\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// 2) sort the map entries, but don\u0026apos;t forget to handle the duplicate value case (like i did)\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// 3) if you really need to return a map, use a LinkedHashMap which keep the insertion order\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;The exec:\n\u0026lt;a href=\u0026quot;http://www.ideone.com/dq3Lu\u0026quot; rel=\u0026quot;nofollow\u0026quot;\u0026gt;http://www.ideone.com/dq3Lu\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;The output:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-java s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-java\u0026quot;\u0026gt;Set entries: E -\u0026amp;gt; -\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;\nSet entries: B -\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;\nSet entries: A -\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3\u0026lt;/span\u0026gt;\nSet entries: C -\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3\u0026lt;/span\u0026gt;\nSet entries: D -\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;5\u0026lt;/span\u0026gt;\nSet entries: H -\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;15\u0026lt;/span\u0026gt;\nSet entries: G -\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;79\u0026lt;/span\u0026gt;\nSet entries: F -\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1000\u0026lt;/span\u0026gt;\nAdded to result map entries: E -\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;\nAdded to result map entries: B \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;\nAdded to result map entries: A \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3\u0026lt;/span\u0026gt;\nAdded to result map entries: C \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3\u0026lt;/span\u0026gt;\nAdded to result map entries: D \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;5\u0026lt;/span\u0026gt;\nAdded to result map entries: H \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;15\u0026lt;/span\u0026gt;\nAdded to result map entries: G \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;79\u0026lt;/span\u0026gt;\nAdded to result map entries: F \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1000\u0026lt;/span\u0026gt;\nResult map values: \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;5\u0026lt;/span\u0026gt;\nResult map values: -\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;\nResult map values: \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1000\u0026lt;/span\u0026gt;\nResult map values: \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;79\u0026lt;/span\u0026gt;\nResult map values: \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3\u0026lt;/span\u0026gt;\nResult map values: \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;\nResult map values: \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3\u0026lt;/span\u0026gt;\nResult map values: \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;15\u0026lt;/span\u0026gt;\nResult map entries: D -\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;5\u0026lt;/span\u0026gt;\nResult map entries: E -\u0026amp;gt; -\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;\nResult map entries: F -\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1000\u0026lt;/span\u0026gt;\nResult map entries: G -\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;79\u0026lt;/span\u0026gt;\nResult map entries: A -\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3\u0026lt;/span\u0026gt;\nResult map entries: B -\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;\nResult map entries: C -\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3\u0026lt;/span\u0026gt;\nResult map entries: H -\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;15\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Hope it will help some folks\u0026lt;/p\u0026gt;\n    "],"id":260,"title":"Sort a Map\u003cKey, Value\u003e by values","content":"\n                \n\u0026lt;p\u0026gt;I am relatively new to Java, and often find that I need to sort a \u0026lt;code\u0026gt;Map\u0026amp;lt;Key, Value\u0026amp;gt;\u0026lt;/code\u0026gt; on the values.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Since the values are not unique, I find myself converting the \u0026lt;code\u0026gt;keySet\u0026lt;/code\u0026gt; into an \u0026lt;code\u0026gt;array\u0026lt;/code\u0026gt;, and sorting that array through \u0026lt;strong\u0026gt;array sort\u0026lt;/strong\u0026gt; with a \u0026lt;strong\u0026gt;custom comparator\u0026lt;/strong\u0026gt; that sorts on the value associated with the key.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Is there an easier way?\u0026lt;/p\u0026gt;\n    ","slug":"sort-a-maplesskey-valuegreater-by-values-1657387443904","postType":"QUESTION","createdAt":"2022-07-09T17:24:03.000Z","updatedAt":"2022-07-09T17:24:03.000Z","tags":[],"relatedQuestions":[]},"randomQuestions":[{"title":"Sorting an array of objects by property values","slug":"sorting-an-array-of-objects-by-property-values-1657387447490"},{"title":"Selenium - wait until element is present, visible and interactable","slug":"selenium-wait-until-element-is-present-visible-and-interactable-1657384820071"},{"title":"Undefined, unspecified and implementation-defined behavior","slug":"undefined-unspecified-and-implementation-defined-behavior-1657384516085"},{"title":"Why is processing a sorted array faster than processing an unsorted array?","slug":"why-is-processing-a-sorted-array-faster-than-processing-an-unsorted-array-1657385497444"},{"title":"How do JavaScript closures work?","slug":"how-do-javascript-closures-work-1657384418555"},{"title":"Can you provide some examples of why it is hard to parse XML and HTML with a regex? [closed]","slug":"can-you-provide-some-examples-of-why-it-is-hard-to-parse-xml-and-html-with-a-regex-closed-1657388410824"},{"title":"How do I list all files of a directory?","slug":"how-do-i-list-all-files-of-a-directory-1657388340404"},{"title":"Test for existence of nested JavaScript object key","slug":"test-for-existence-of-nested-javascript-object-key-1657387935411"},{"title":"commandButton/commandLink/ajax action/listener method not invoked or input value not set/updated","slug":"commandbuttoncommandlinkajax-actionlistener-method-not-invoked-or-input-value-not-setupdated-1657384667519"},{"title":"How do I copy to the clipboard in JavaScript?","slug":"how-do-i-copy-to-the-clipboard-in-javascript-1657385501223"},{"title":"Why aren't variable-length arrays part of the C++ standard?","slug":"why-aren't-variable-length-arrays-part-of-the-c++-standard-1657384712975"},{"title":"How do I create variable variables?","slug":"how-do-i-create-variable-variables-1657384387679"},{"title":"Sort a Map\u003cKey, Value\u003e by values","slug":"sort-a-maplesskey-valuegreater-by-values-1657387443904"},{"title":"Daylight saving time and time zone best practices [closed]","slug":"daylight-saving-time-and-time-zone-best-practices-closed-1657387973687"},{"title":"Providing white space in a Swing GUI","slug":"providing-white-space-in-a-swing-gui-1657384734588"},{"title":"Understanding slicing","slug":"understanding-slicing-1657384397680"},{"title":"What to do Regular expression pattern doesn't match anywhere in string?","slug":"what-to-do-regular-expression-pattern-doesn't-match-anywhere-in-string-1657388095896"},{"title":"What and where are the stack and heap?","slug":"what-and-where-are-the-stack-and-heap-1657387415361"},{"title":"How to use ThreeTenABP in Android Project","slug":"how-to-use-threetenabp-in-android-project-1657384345704"},{"title":"Why JSF calls getters multiple times","slug":"why-jsf-calls-getters-multiple-times-1657388244489"}]},"__N_SSG":true},"page":"/questions/[slug]","query":{"slug":"sort-a-maplesskey-valuegreater-by-values-1657387443904"},"buildId":"eGqQHYKGZKE-nXShFn8wX","isFallback":false,"gsp":true,"locale":"en","locales":["en"],"defaultLocale":"en","scriptLoader":[]}</script></body></html>