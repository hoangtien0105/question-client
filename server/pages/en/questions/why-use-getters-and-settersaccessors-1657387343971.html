<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><meta name="twitter:card" content="summary_large_image"/><meta name="twitter:site" content="@solutionschecker.com"/><meta name="twitter:creator" content="@solutionschecker.com"/><meta property="og:url" content="https://solutionschecker.com"/><meta property="og:type" content="website"/><meta property="og:image" content="https://solutionschecker.com/solutions-checker-banner.png"/><meta property="og:image:alt" content="Find solution for coding, HTML, CSS, JAVASCRIPT, MYSQL, PHP, PYTHON,... quickly. - solutionschecker.com"/><script type="application/ld+json">{"@context":"https://schema.org","@type":"Organization","logo":"/logo.svg","url":"https://solutionschecker.com"}</script><title>Why use getters and setters/accessors? | Solutions Checker</title><meta name="robots" content="index,follow"/><meta name="description" content="What&#x27;s the advantage of using getters and setters - that only get and set - instead of simply using public fields for those variables?

If getters and setters are ever doing more than just the simple get/set, I can figure this one out very quickly, but I&#x27;m not 100% clear on how:

public String foo;


is any worse than:

private String foo;
public void setFoo(String foo) { this.foo = foo; }
public String getFoo() { return foo; }


Whereas the former takes a lot less boilerplate code.
    "/><meta property="og:title" content="Why use getters and setters/accessors? | Solutions Checker"/><meta property="og:description" content="What&#x27;s the advantage of using getters and setters - that only get and set - instead of simply using public fields for those variables?

If getters and setters are ever doing more than just the simple get/set, I can figure this one out very quickly, but I&#x27;m not 100% clear on how:

public String foo;


is any worse than:

private String foo;
public void setFoo(String foo) { this.foo = foo; }
public String getFoo() { return foo; }


Whereas the former takes a lot less boilerplate code.
    "/><script type="application/ld+json">{"@context":"https://schema.org","@type":"QAPage","mainEntity":{"name":"Why use getters and setters/accessors?","text":"What&apos;s the advantage of using getters and setters - that only get and set - instead of simply using public fields for those variables?\n\nIf getters and setters are ever doing more than just the simple get/set, I can figure this one out very quickly, but I&apos;m not 100% clear on how:\n\npublic String foo;\n\n\nis any worse than:\n\nprivate String foo;\npublic void setFoo(String foo) { this.foo = foo; }\npublic String getFoo() { return foo; }\n\n\nWhereas the former takes a lot less boilerplate code.\n    ","answerCount":30,"upVoteCount":500,"suggestedAnswer":[{"text":"There are actually many good reasons to consider using accessors rather than directly exposing fields of a class - beyond just the argument of encapsulation and making future changes easier. \n\nHere are the some of the reasons I am aware of:\n\n\nEncapsulation of behavior associated with getting or setting the property - this allows additional functionality (like validation) to be added more easily later.\nHiding the internal representation of the property while exposing a property using an alternative representation.\nInsulating your public interface from change - allowing the public interface to remain constant while the implementation changes without affecting existing consumers.\nControlling the lifetime and memory management (disposal) semantics of the property - particularly important in non-managed memory environments (like C++ or Objective-C).\nProviding a debugging interception point for when a property changes at runtime - debugging when and where a property changed to a particular value can be quite difficult without this in some languages.\nImproved interoperability with libraries that are designed to operate against property getter/setters - Mocking, Serialization, and WPF come to mind.\nAllowing inheritors to change the semantics of how the property behaves and is exposed by overriding the getter/setter methods.\nAllowing the getter/setter to be passed around as lambda expressions rather than values.\nGetters and setters can allow different access levels - for example the get may be public, but the set could be protected.\n\n    ","url":"/questions/[slug]#solution1","@type":"Answer","upvoteCount":0},{"text":"Because 2 weeks (months, years) from now when you realize that your setter needs to do more than just set the value, you&apos;ll also realize that the property has been used directly in 238 other classes :-)\n    ","url":"/questions/[slug]#solution2","@type":"Answer","upvoteCount":0},{"text":"A public field is not worse than a getter/setter pair that does nothing except returning the field and assigning to it. First, it&apos;s clear that (in most languages) there is no functional difference. Any difference must be in other factors, like maintainability or readability.\n\nAn oft-mentioned advantage of getter/setter pairs, isn&apos;t. There&apos;s this claim that you can change the implementation and your clients don&apos;t have to be recompiled. Supposedly, setters let you add functionality like validation later on and your clients don&apos;t even need to know about it. However, adding validation to a setter is a change to its preconditions, a violation of the previous contract, which was, quite simply, &quot;you can put anything in here, and you can get that same thing later from the getter&quot;.\n\nSo, now that you broke the contract, changing every file in the codebase is something you should want to do, not avoid. If you avoid it you&apos;re making the assumption that all the code assumed the contract for those methods was different.\n\nIf that should not have been the contract, then the interface was allowing clients to put the object in invalid states. That&apos;s the exact opposite of encapsulation If that field could not really be set to anything from the start, why wasn&apos;t the validation there from the start?\n\nThis same argument applies to other supposed advantages of these pass-through getter/setter pairs: if you later decide to change the value being set, you&apos;re breaking the contract. If you override the default functionality in a derived class, in a way beyond a few harmless modifications (like logging or other non-observable behaviour), you&apos;re breaking the contract of the base class. That is a violation of the Liskov Substitutability Principle, which is seen as one of the tenets of OO.\n\nIf a class has these dumb getters and setters for every field, then it is a class that has no invariants whatsoever, no contract. Is that really object-oriented design? If all the class has is those getters and setters, it&apos;s just a dumb data holder, and dumb data holders should look like dumb data holders:\n\nclass Foo {\npublic:\n    int DaysLeft;\n    int ContestantNumber;\n};\n\n\nAdding pass-through getter/setter pairs to such a class adds no value. Other classes should provide meaningful operations, not just operations that fields already provide. That&apos;s how you can define and maintain useful invariants.\n\n\n  Client: &quot;What can I do with an object of this class?&quot;\n  Designer: &quot;You can read and write several variables.&quot;\n  Client: &quot;Oh... cool, I guess?&quot;\n\n\nThere are reasons to use getters and setters, but if those reasons don&apos;t exist, making getter/setter pairs in the name of false encapsulation gods is not a good thing. Valid reasons to make getters or setters include the things often mentioned as the potential changes you can make later, like validation or different internal representations. Or maybe the value should be readable by clients but not writable (for example, reading the size of a dictionary), so a simple getter is a nice choice. But those reasons should be there when you make the choice, and not just as a potential thing you may want later. This is an instance of YAGNI (You Ain&apos;t Gonna Need It).\n    ","url":"/questions/[slug]#solution3","@type":"Answer","upvoteCount":0},{"text":"Lots of people talk about the advantages of getters and setters but I want to play devil&apos;s advocate. Right now I&apos;m debugging a very large program where the programmers decided to make everything getters and setters. That might seem nice, but its a reverse-engineering nightmare.\n\nSay you&apos;re looking through hundreds of lines of code and you come across this:\n\nperson.name = &quot;Joe&quot;;\n\n\nIt&apos;s a beautifully simply piece of code until you realize its a setter. Now, you follow that setter and find that it also sets person.firstName, person.lastName, person.isHuman, person.hasReallyCommonFirstName, and calls person.update(), which sends a query out to the database, etc. Oh, that&apos;s where your memory leak was occurring.\n\nUnderstanding a local piece of code at first glance is an important property of good readability that getters and setters tend to break. That is why I try to avoid them when I can, and minimize what they do when I use them.\n    ","url":"/questions/[slug]#solution4","@type":"Answer","upvoteCount":0},{"text":"In a pure object-oriented world getters and setters is a terrible anti-pattern. Read this article: Getters/Setters. Evil. Period. In a nutshell, they encourage programmers to think about objects as of data structures, and this type of thinking is pure procedural (like in COBOL or C). In an object-oriented language there are no data structures, but only objects that expose behavior (not attributes/properties!)\n\nYou may find more about them in Section 3.5 of Elegant Objects (my book about object-oriented programming).\n    ","url":"/questions/[slug]#solution5","@type":"Answer","upvoteCount":0},{"text":"There are many reasons. My favorite one is when you need to change the behavior or regulate what you can set on a variable. For instance, lets say you had a setSpeed(int speed) method. But you want that you can only set a maximum speed of 100. You would do something like:\n\npublic void setSpeed(int speed) {\n  if ( speed &gt; 100 ) {\n    this.speed = 100;\n  } else {\n    this.speed = speed;\n  }\n}\n\n\nNow what if EVERYWHERE in your code you were using the public field and then you realized you need the above requirement? Have fun hunting down every usage of the public field instead of just modifying your setter.\n\nMy 2 cents :)\n    ","url":"/questions/[slug]#solution6","@type":"Answer","upvoteCount":0},{"text":"One advantage of accessors and mutators is that you can perform validation.\n\nFor example, if foo was public, I could easily set it to null and then someone else could try to call a method on the object. But it&apos;s not there anymore! With a setFoo method, I could ensure that foo was never set to null.\n\nAccessors and mutators also allow for encapsulation - if you aren&apos;t supposed to see the value once its set (perhaps it&apos;s set in the constructor and then used by methods, but never supposed to be changed), it will never been seen by anyone. But if you can allow other classes to see or change it, you can provide the proper accessor and/or mutator.\n    ","url":"/questions/[slug]#solution7","@type":"Answer","upvoteCount":0},{"text":"Depends on your language.  You&apos;ve tagged this &quot;object-oriented&quot; rather than &quot;Java&quot;, so I&apos;d like to point out that ChssPly76&apos;s answer is language-dependent.  In Python, for instance, there is no reason to use getters and setters.  If you need to change the behavior, you can use a property, which wraps a getter and setter around basic attribute access.  Something like this:\n class Simple(object):\n   def _get_value(self):\n       return self._value -1\n\n   def _set_value(self, new_value):\n       self._value = new_value + 1\n\n   def _del_value(self):\n       self.old_values.append(self._value)\n       del self._value\n\n   value = property(_get_value, _set_value, _del_value)\n\n    ","url":"/questions/[slug]#solution8","@type":"Answer","upvoteCount":0},{"text":"Thanks, that really clarified my thinking. Now here is (almost) 10 (almost) good reasons NOT to use getters and setters:\n\n\nWhen you realize you need to do more than just set and get the value, you can just make the field private, which will instantly tell you where you&apos;ve directly accessed it.\nAny validation you perform in there can only be context free, which validation rarely is in practice.\nYou can change the value being set - this is an absolute nightmare when the caller passes you a value that they [shock horror] want you to store AS IS.\nYou can hide the internal representation - fantastic, so you&apos;re making sure that all these operations are symmetrical right?\nYou&apos;ve insulated your public interface from changes under the sheets - if you were designing an interface and weren&apos;t sure whether direct access to something was OK, then you should have kept designing.\nSome libraries expect this, but not many - reflection, serialization, mock objects all work just fine with public fields.\nInheriting this class, you can override default functionality - in other words you can REALLY confuse callers by not only hiding the implementation but making it inconsistent.\n\n\nThe last three I&apos;m just leaving (N/A or D/C)...\n    ","url":"/questions/[slug]#solution9","@type":"Answer","upvoteCount":0},{"text":"Well i just want to add that even if sometimes they are necessary for the encapsulation and security of your variables/objects, if we want to code a real Object Oriented Program, then we need to STOP OVERUSING THE ACCESSORS, cause sometimes we depend a lot on them when is not really necessary and that makes almost the same as if we put the variables public.\n    ","url":"/questions/[slug]#solution10","@type":"Answer","upvoteCount":0},{"text":"EDIT: I answered this question because there are a bunch of people learning programming asking this, and most of the answers are very technically competent, but they&apos;re not as easy to understand if you&apos;re a newbie. We were all newbies, so I thought I&apos;d try my hand at a more newbie friendly answer.\n\nThe two main ones are polymorphism, and validation. Even if it&apos;s just a stupid data structure.\n\nLet&apos;s say we have this simple class:\n\npublic class Bottle {\n  public int amountOfWaterMl;\n  public int capacityMl;\n}\n\n\nA very simple class that holds how much liquid is in it, and what its capacity is (in milliliters).\n\nWhat happens when I do:\n\nBottle bot = new Bottle();\nbot.amountOfWaterMl = 1500;\nbot.capacityMl = 1000;\n\n\nWell, you wouldn&apos;t expect that to work, right?\nYou want there to be some kind of sanity check. And worse, what if I never specified the maximum capacity? Oh dear, we have a problem.\n\nBut there&apos;s another problem too. What if bottles were just one type of container? What if we had several containers, all with capacities and amounts of liquid filled? If we could just make an interface, we could let the rest of our program accept that interface, and bottles, jerrycans and all sorts of stuff would just work interchangably. Wouldn&apos;t that be better? Since interfaces demand methods, this is also a good thing.\n\nWe&apos;d end up with something like:\n\npublic interface LiquidContainer {\n  public int getAmountMl();\n  public void setAmountMl(int amountMl);\n  public int getCapacityMl();\n}\n\n\nGreat! And now we just change Bottle to this:\n\npublic class Bottle extends LiquidContainer {\n  private int capacityMl;\n  private int amountFilledMl;\n\n  public Bottle(int capacityMl, int amountFilledMl) {\n    this.capacityMl = capacityMl;\n    this.amountFilledMl = amountFilledMl;\n    checkNotOverFlow();\n  }\n\n  public int getAmountMl() {\n    return amountFilledMl;\n  }\n\n  public void setAmountMl(int amountMl) {\n     this.amountFilled = amountMl;\n     checkNotOverFlow();\n  }\n  public int getCapacityMl() {\n    return capacityMl;\n  }\n\n  private void checkNotOverFlow() {\n    if(amountOfWaterMl &gt; capacityMl) {\n      throw new BottleOverflowException();\n    }\n}\n\n\nI&apos;ll leave the definition of the BottleOverflowException as an exercise to the reader.\n\nNow notice how much more robust this is. We can deal with any type of container in our code now by accepting LiquidContainer instead of Bottle. And how these bottles deal with this sort of stuff can all differ. You can have bottles that write their state to disk when it changes, or bottles that save on SQL databases or GNU knows what else.\n\nAnd all these can have different ways to handle various whoopsies. The Bottle just checks and if it&apos;s overflowing it throws a RuntimeException. But that might be the wrong thing to do. \n(There is a useful discussion to be had about error handling, but I&apos;m keeping it very simple here on purpose. People in comments will likely point out the flaws of this simplistic approach. ;) )\n\nAnd yes, it seems like we go from a very simple idea to getting much better answers quickly.\n\nPlease note also that you can&apos;t change the capacity of a bottle. It&apos;s now set in stone. You could do this with an int by declaring it final. But if this was a list, you could empty it, add new things to it, and so on. You can&apos;t limit the access to touching the innards.\n\nThere&apos;s also the third thing that not everyone has addressed: getters and setters use method calls. That means that they look like normal methods everywhere else does. Instead of having weird specific syntax for DTOs and stuff, you have the same thing everywhere.\n    ","url":"/questions/[slug]#solution11","@type":"Answer","upvoteCount":0},{"text":"I know it&apos;s a bit late, but I think there are some people who are interested in performance.\n\nI&apos;ve done a little performance test. I wrote a class &quot;NumberHolder&quot; which, well, holds an Integer. You can either read that Integer by using the getter method\nanInstance.getNumber() or by directly accessing the number by using anInstance.number. My programm reads the number 1,000,000,000 times, via both ways. That process is repeated five times and the time is printed. I&apos;ve got the following result:\n\nTime 1: 953ms, Time 2: 741ms\nTime 1: 655ms, Time 2: 743ms\nTime 1: 656ms, Time 2: 634ms\nTime 1: 637ms, Time 2: 629ms\nTime 1: 633ms, Time 2: 625ms\n\n\n(Time 1 is the direct way, Time 2 is the getter)\n\nYou see, the getter is (almost) always a bit faster. Then I tried with different numbers of cycles. Instead of 1 million, I used 10 million and 0.1 million.\nThe results:\n\n10 million cycles: \n\nTime 1: 6382ms, Time 2: 6351ms\nTime 1: 6363ms, Time 2: 6351ms\nTime 1: 6350ms, Time 2: 6363ms\nTime 1: 6353ms, Time 2: 6357ms\nTime 1: 6348ms, Time 2: 6354ms\n\n\nWith 10 million cycles, the times are almost the same.\nHere are 100 thousand (0.1 million) cycles:\n\nTime 1: 77ms, Time 2: 73ms\nTime 1: 94ms, Time 2: 65ms\nTime 1: 67ms, Time 2: 63ms\nTime 1: 65ms, Time 2: 65ms\nTime 1: 66ms, Time 2: 63ms\n\n\nAlso with different amounts of cycles, the getter is a little bit faster than the regular way. I hope this helped you.\n    ","url":"/questions/[slug]#solution12","@type":"Answer","upvoteCount":0},{"text":"We use getters and setters:\n\n\nfor reusability\nto perform validation in later stages of programming\n\n\nGetter and setter methods are public interfaces to access private class members.\n\n\n\nEncapsulation mantra\n\nThe encapsulation mantra is to make fields private and methods public.\n\n\n  Getter Methods: We can get access to private variables.\n  \n  Setter Methods: We can modify private fields.\n\n\nEven though the getter and setter methods do not add new functionality, we can change our mind come back later to make that method\n\n\nbetter;\nsafer; and\nfaster.\n\n\n\n\nAnywhere a value can be used, a method that returns that value can be added. Instead of:\n\nint x = 1000 - 500\n\n\nuse\n\nint x = 1000 - class_name.getValue();\n\n\n\n\nIn layman&apos;s terms\n\n\n\nSuppose we need to store the details of this Person. This Person has the fields name, age and sex. Doing this involves creating methods for name, age and sex. Now if we need create another person, it becomes necessary to create the methods for name, age, sex all over again.\n\nInstead of doing this, we can create a bean class(Person) with getter and setter methods.  So tomorrow we can just create objects of this Bean class(Person class) whenever we need to add a new person (see the figure). Thus we are reusing the fields and methods of bean class, which is much better.\n    ","url":"/questions/[slug]#solution13","@type":"Answer","upvoteCount":0},{"text":"I spent quite a while thinking this over for the Java case, and I believe the real reasons are:\n\n\nCode to the interface, not the implementation\nInterfaces only specify methods, not fields\n\n\nIn other words, the only way you can specify a field in an interface is by providing a method for writing a new value and a method for reading the current value.  \n\nThose methods are the infamous getter and setter....\n    ","url":"/questions/[slug]#solution14","@type":"Answer","upvoteCount":0},{"text":"Don&apos;t use getters setters unless needed for your current delivery I.e. Don&apos;t think too much about what would happen in the future, if any thing to be changed its a change request in most of the production applications, systems.\n\nThink simple, easy, add complexity when needed.\n\nI would not take advantage of ignorance of business owners of deep technical know how just because I think it&apos;s correct or I like the approach.\n\nI have massive system written without getters setters only with access modifiers and some methods to validate n perform biz logic. If you absolutely needed the. Use anything.\n    ","url":"/questions/[slug]#solution15","@type":"Answer","upvoteCount":0},{"text":"It can be useful for lazy-loading.  Say the object in question is stored in a database, and you don&apos;t want to go get it unless you need it.  If the object is retrieved by a getter, then the internal object can be null until somebody asks for it, then you can go get it on the first call to the getter.\n\nI had a base page class in a project that was handed to me that was loading some data from a couple different web service calls, but the data in those web service calls wasn&apos;t always used in all child pages.  Web services, for all of the benefits, pioneer new definitions of &quot;slow&quot;, so you don&apos;t want to make a web service call if you don&apos;t have to.\n\nI moved from public fields to getters, and now the getters check the cache, and if it&apos;s not there call the web service.  So with a little wrapping, a lot of web service calls were prevented.\n\nSo the getter saves me from trying to figure out, on each child page, what I will need.  If I need it, I call the getter, and it goes to find it for me if I don&apos;t already have it.\n\n    protected YourType _yourName = null;\n    public YourType YourName{\n      get\n      {\n        if (_yourName == null)\n        {\n          _yourName = new YourType();\n          return _yourName;\n        }\n      }\n    }\n\n    ","url":"/questions/[slug]#solution16","@type":"Answer","upvoteCount":0},{"text":"One aspect I missed in the answers so far, the access specification:\n\n\nfor members you have only one access specification for both setting and getting\nfor setters and getters you can fine tune it and define it separately\n\n    ","url":"/questions/[slug]#solution17","@type":"Answer","upvoteCount":0},{"text":"In languages which don&apos;t support &quot;properties&quot; (C++, Java) or require recompilation of clients when changing fields to properties (C#), using get/set methods is easier to modify. For example, adding validation logic to a setFoo method will not require changing the public interface of a class.\n\nIn languages which support &quot;real&quot; properties (Python, Ruby, maybe Smalltalk?) there is no point to get/set methods.\n    ","url":"/questions/[slug]#solution18","@type":"Answer","upvoteCount":0},{"text":"One of the basic principals of OO design: Encapsulation!\n\nIt gives you many benefits, one of which being that you can change the implementation of the getter/setter behind the scenes but any consumer of that value will continue to work as long as the data type remains the same.\n    ","url":"/questions/[slug]#solution19","@type":"Answer","upvoteCount":0},{"text":"You should use getters and setters when:\n\n\nYou&apos;re dealing with something that is conceptually an attribute, but:\n\nYour language doesn&apos;t have properties (or some similar mechanism, like Tcl&apos;s variable traces), or\nYour language&apos;s property support isn&apos;t sufficient for this use case, or\nYour language&apos;s (or sometimes your framework&apos;s) idiomatic conventions encourage getters or setters for this use case.\n\n\n\nSo this is very rarely a general OO question; it&apos;s a language-specific question, with different answers for different languages (and different use cases).\n\n\n\nFrom an OO theory point of view, getters and setters are useless. The interface of your class is what it does, not what its state is. (If not, you&apos;ve written the wrong class.) In very simple cases, where what a class does is just, e.g., represent a point in rectangular coordinates,* the attributes are part of the interface; getters and setters just cloud that. But in anything but very simple cases, neither the attributes nor getters and setters are part of the interface.\n\nPut another way: If you believe that consumers of your class shouldn&apos;t even know that you have a spam attribute, much less be able to change it willy-nilly, then giving them a set_spam method is the last thing you want to do.\n\n* Even for that simple class, you may not necessarily want to allow setting the x and y values. If this is really a class, shouldn&apos;t it have methods like translate, rotate, etc.? If it&apos;s only a class because your language doesn&apos;t have records/structs/named tuples, then this isn&apos;t really a question of OO\n\n\n\nBut nobody is ever doing general OO design. They&apos;re doing design, and implementation, in a specific language. And in some languages, getters and setters are far from useless.\n\nIf your language doesn&apos;t have properties, then the only way to represent something that&apos;s conceptually an attribute, but is actually computed, or validated, etc., is through getters and setters.\n\nEven if your language does have properties, there may be cases where they&apos;re insufficient or inappropriate. For example, if you want to allow subclasses to control the semantics of an attribute, in languages without dynamic access, a subclass can&apos;t substitute a computed property for an attribute.\n\nAs for the &quot;what if I want to change my implementation later?&quot; question (which is repeated multiple times in different wording in both the OP&apos;s question and the accepted answer): If it really is a pure implementation change, and you started with an attribute, you can change it to a property without affecting the interface. Unless, of course, your language doesn&apos;t support that. So this is really just the same case again.\n\nAlso, it&apos;s important to follow the idioms of the language (or framework) you&apos;re using. If you write beautiful Ruby-style code in C#, any experienced C# developer other than you is going to have trouble reading it, and that&apos;s bad. Some languages have stronger cultures around their conventions than others.and it may not be a coincidence that Java and Python, which are on opposite ends of the spectrum for how idiomatic getters are, happen to have two of the strongest cultures.\n\nBeyond human readers, there will be libraries and tools that expect you to follow the conventions, and make your life harder if you don&apos;t. Hooking Interface Builder widgets to anything but ObjC properties, or using certain Java mocking libraries without getters, is just making your life more difficult. If the tools are important to you, don&apos;t fight them.\n    ","url":"/questions/[slug]#solution20","@type":"Answer","upvoteCount":0},{"text":"From a object orientation design standpoint both alternatives can be damaging to the maintenance of the code by weakening the encapsulation of the classes. For a discussion you can look into this excellent article: http://typicalprogrammer.com/?p=23 \n    ","url":"/questions/[slug]#solution21","@type":"Answer","upvoteCount":0},{"text":"Code evolves.  private is great for when you need data member protection.  Eventually all classes should be sort of &quot;miniprograms&quot; that have a well-defined interface that you can&apos;t just screw with the internals of.\n\nThat said, software development isn&apos;t about setting down that final version of the class as if you&apos;re pressing some cast iron statue on the first try.  While you&apos;re working with it, code is more like clay.  It evolves as you develop it and learn more about the problem domain you are solving.  During development classes may interact with each other than they should (dependency you plan to factor out), merge together, or split apart.  So I think the debate boils down to people not wanting to religiously write\n\nint getVar() const { return var ; }\n\n\nSo you have:\n\ndoSomething( obj-&gt;getVar() ) ;\n\n\nInstead of\n\ndoSomething( obj-&gt;var ) ;\n\n\nNot only is getVar() visually noisy, it gives this illusion that gettingVar() is somehow a more complex process than it really is.  How you (as the class writer) regard the sanctity of var is particularly confusing to a user of your class if it has a passthru setter -- then it looks like you&apos;re putting up these gates to &quot;protect&quot; something you insist is valuable, (the sanctity of var) but yet even you concede var&apos;s protection isn&apos;t worth much by the ability for anyone to just come in and set var to whatever value they want, without you even peeking at what they are doing.\n\nSo I program as follows (assuming an &quot;agile&quot; type approach -- ie when I write code not knowing exactly what it will be doing/don&apos;t have time or experience to plan an elaborate waterfall style interface set):\n\n1) Start with all public members for basic objects with data and behavior.  This is why in all my C++ &quot;example&quot; code you&apos;ll notice me using struct instead of class everywhere.\n\n2) When an object&apos;s internal behavior for a data member becomes complex enough, (for example, it likes to keep an internal std::list in some kind of order), accessor type functions are written.  Because I&apos;m programming by myself, I don&apos;t always set the member private right away, but somewhere down the evolution of the class the member will be &quot;promoted&quot; to either protected or private.\n\n3) Classes that are fully fleshed out and have strict rules about their internals (ie they know exactly what they are doing, and you are not to &quot;fuck&quot; (technical term) with its internals) are given the class designation, default private members, and only a select few members are allowed to be public.\n\nI find this approach allows me to avoid sitting there and religiously writing getter/setters when a lot of data members get migrated out, shifted around, etc. during the early stages of a class&apos;s evolution.\n    ","url":"/questions/[slug]#solution22","@type":"Answer","upvoteCount":0},{"text":"There is a good reason to consider using accessors is there is no property inheritance. See next example:\n\npublic class TestPropertyOverride {\n    public static class A {\n        public int i = 0;\n\n        public void add() {\n            i++;\n        }\n\n        public int getI() {\n            return i;\n        }\n    }\n\n    public static class B extends A {\n        public int i = 2;\n\n        @Override\n        public void add() {\n            i = i + 2;\n        }\n\n        @Override\n        public int getI() {\n            return i;\n        }\n    }\n\n    public static void main(String[] args) {\n        A a = new B();\n        System.out.println(a.i);\n        a.add();\n        System.out.println(a.i);\n        System.out.println(a.getI());\n    }\n}\n\n\nOutput:\n\n0\n0\n4\n\n    ","url":"/questions/[slug]#solution23","@type":"Answer","upvoteCount":0},{"text":"Getters and setters are used to implement two of the fundamental aspects of Object Oriented Programming which are: \n\n\nAbstraction\nEncapsulation\n\n\nSuppose we have an Employee class:\n\npackage com.highmark.productConfig.types;\n\npublic class Employee {\n\n    private String firstName;\n    private String middleName;\n    private String lastName;\n\n    public String getFirstName() {\n      return firstName;\n    }\n    public void setFirstName(String firstName) {\n       this.firstName = firstName;\n    }\n    public String getMiddleName() {\n        return middleName;\n    }\n    public void setMiddleName(String middleName) {\n         this.middleName = middleName;\n    }\n    public String getLastName() {\n        return lastName;\n    }\n    public void setLastName(String lastName) {\n        this.lastName = lastName;\n    }\n\n    public String getFullName(){\n        return this.getFirstName() + this.getMiddleName() +  this.getLastName();\n    }\n }\n\n\nHere the implementation details of Full Name is hidden from the user and is not accessible directly to the user, unlike a public attribute.   \n    ","url":"/questions/[slug]#solution24","@type":"Answer","upvoteCount":0},{"text":"If you don&apos;t require any validations and not even need to maintain state i.e. one property depends on another so we need to maintain the state when one is change. You can keep it simple by making field public and not using getter and setters.\nI think OOPs complicates things as the program grows it becomes nightmare for developer to scale.\nA simple example; we generate c++ headers from xml. The header contains simple field which does not require any validations. But still as in OOPS accessor  are fashion we generates them  as following.\nconst Filed&amp; getfield() const\nField&amp; getField() \nvoid setfield(const Field&amp; field){...} \n\nwhich is very verbose and is not required. a simple\nstruct \n{\n   Field field;\n};\n\nis enough and readable.\nFunctional programming don&apos;t have the concept of data hiding they even don&apos;t require it as they do not mutate the data.\n    ","url":"/questions/[slug]#solution25","@type":"Answer","upvoteCount":0},{"text":"Getter and setter methods are accessor methods, meaning that they are generally a public interface to change private class members. You use getter and setter methods to define a property. You access getter and setter methods as properties outside the class, even though you define them within the class as methods. Those properties outside the class can have a different name from the property name in the class.\n\nThere are some advantages to using getter and setter methods, such as the ability to let you create members with sophisticated functionality that you can access like properties. They also let you create read-only and write-only properties.\n\nEven though getter and setter methods are useful, you should be careful not to overuse them because, among other issues, they can make code maintenance more difficult in certain situations. Also, they provide access to your class implementation, like public members. OOP practice discourages direct access to properties within a class.\n\nWhen you write classes, you are always encouraged to make as many as possible of your instance variables private and add getter and setter methods accordingly. This is because there are several times when you may not want to let users change certain variables within your classes. For example, if you have a private static method that tracks the number of instances created for a specific class, you don&apos;t want a user to modify that counter using code. Only the constructor statement should increment that variable whenever it&apos;s called. In this situation, you might create a private instance variable and allow a getter method only for the counter variable, which means users are able to retrieve the current value only by using the getter method, and they won&apos;t be able to set new values using the setter method. Creating a getter without a setter is a simple way of making certain variables in your class read-only.\n    ","url":"/questions/[slug]#solution26","@type":"Answer","upvoteCount":0},{"text":"There is a difference between DataStructure and Object.\nDatastructure should expose its innards and not behavior.\nAn Object should not expose its innards but it should expose its behavior, which is also known as the Law of Demeter\nMostly DTOs are considered more of a datastructure and not Object. They should only expose their data and not behavior. Having Setter/Getter in DataStructure will expose behavior instead of data inside it. This further increases the chance of violation of Law of Demeter.\nUncle Bob in his book Clean code explained the Law of Demeter.\n\nThere is a well-known heuristic called the Law of Demeter that says a\nmodule should not know about the innards of the objects it\nmanipulates. As we saw in the last section, objects hide their data\nand expose operations. This means that an object should not expose its\ninternal structure through accessors because to do so is to expose,\nrather than to hide, its internal structure.\nMore precisely, the Law of Demeter says that a method f of a class C\nshould only call the methods of these:\n\nC\nAn object created by f\nAn object passed as an argument to f\nAn object held in an instance variable of C\n\nThe method should not invoke methods on objects that are returned by any of the allowed functions.\nIn other words, talk to friends, not to strangers.\n\nSo according this, example of LoD violation is:\nfinal String outputDir = ctxt.getOptions().getScratchDir().getAbsolutePath();\n\nHere, the function should call the method of its immediate friend which is ctxt here, It should not call the method of its immediate friend&apos;s friend. but this rule doesn&apos;t apply to data structure. so here if ctxt, option, scratchDir are  datastructure then why to wrap their internal data with some behavior and doing a violation of LoD.\nInstead, we can do something like this.\nfinal String outputDir = ctxt.options.scratchDir.absolutePath;\n\nThis fulfills our needs and doesn&apos;t even violate LoD.\nInspired by Clean Code by Robert C. Martin(Uncle Bob)\n    ","url":"/questions/[slug]#solution27","@type":"Answer","upvoteCount":0},{"text":"Additionally, this is to &quot;future-proof&quot; your class. In particular, changing from a field to a property is an ABI break, so if you do later decide that you need more logic than just &quot;set/get the field&quot;, then you need to break ABI, which of course creates problems for anything else already compiled against your class.\n    ","url":"/questions/[slug]#solution28","@type":"Answer","upvoteCount":0},{"text":"One other use (in languages that support properties) is that setters and getters can imply that an operation is non-trivial.  Typically, you want to avoid doing anything that&apos;s computationally expensive in a property.\n    ","url":"/questions/[slug]#solution29","@type":"Answer","upvoteCount":0},{"text":"One relatively modern advantage of getters/setters is that is makes it easier to browse code in tagged (indexed) code editors. E.g. If you want to see who sets a member, you can open the call hierarchy of the setter.\n\nOn the other hand, if the member is public, the tools don&apos;t make it possible to filter read/write access to the member. So you have to trudge though all uses of the member.\n    ","url":"/questions/[slug]#solution30","@type":"Answer","upvoteCount":0}],"@type":"Question"}}</script><meta name="next-head-count" content="16"/><link rel="preload" href="/_next/static/css/08bcc42a26fe5c92.css" as="style"/><link rel="stylesheet" href="/_next/static/css/08bcc42a26fe5c92.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-0d1b80a048d4787e.js"></script><script src="/_next/static/chunks/webpack-42cdea76c8170223.js" defer=""></script><script src="/_next/static/chunks/framework-4556c45dd113b893.js" defer=""></script><script src="/_next/static/chunks/main-ccfab947c79712f4.js" defer=""></script><script src="/_next/static/chunks/pages/_app-08d1a634dea6705e.js" defer=""></script><script src="/_next/static/chunks/29107295-fbcfe2172188e46f.js" defer=""></script><script src="/_next/static/chunks/150-b06815e21c943e0d.js" defer=""></script><script src="/_next/static/chunks/490-7f0418bb4354ac73.js" defer=""></script><script src="/_next/static/chunks/108-87de33c23337ff53.js" defer=""></script><script src="/_next/static/chunks/pages/questions/%5Bslug%5D-79a1437acf654019.js" defer=""></script><script src="/_next/static/TQ2eYlCSdocSK-hq6gkM0/_buildManifest.js" defer=""></script><script src="/_next/static/TQ2eYlCSdocSK-hq6gkM0/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="wrapper"><header><nav class="bg-white border-gray-200 px-4 lg:px-6 py-2.5 dark:bg-gray-800"><div class="flex flex-wrap justify-between items-center mx-auto max-w-screen-xl"><a class="flex items-center" href="/"><img src="/logo-second.png" class="mr-3 h-6 sm:h-9" alt="Solution Checker Logo"/><h4 class="self-center text-xl font-semibold whitespace-nowrap dark:text-white">Solution Checker</h4></a><div class="flex items-center lg:order-2"><button data-collapse-toggle="mobile-menu-2" type="button" class="inline-flex items-center p-2 ml-1 text-sm text-gray-500 rounded-lg lg:hidden hover:bg-gray-100 focus:outline-none focus:ring-2 focus:ring-gray-200 dark:text-gray-400 dark:hover:bg-gray-700 dark:focus:ring-gray-600" aria-controls="mobile-menu-2" aria-expanded="false"><span class="sr-only">Open main menu</span><svg class="w-6 h-6" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M3 5a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM3 10a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM3 15a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1z" clip-rule="evenodd"></path></svg><svg class="hidden w-6 h-6" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z" clip-rule="evenodd"></path></svg></button></div><div class="hidden justify-between items-center w-full lg:flex lg:w-auto lg:order-1" id="mobile-menu-2"><ul class="flex flex-col mt-4 font-medium lg:flex-row lg:space-x-8 lg:mt-0"><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" aria-current="page" href="/">Home</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/questions?tab=news">Questions</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/post?tab=news">Post</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/questions/why-use-getters-and-settersaccessors-1657387343971#">Coding</a></li></ul></div></div></nav></header><div class="main-content"><div class="question my-5"><div class="flex question-header items-center m-auto justify-center"><div class="rounded-xl w-full border p-5 shadow-md bg-white"><div class="flex w-full items-center justify-between border-b pb-3"><div class="flex items-center space-x-3"><div class="text-lg font-bold text-slate-700"><a href="/questions/why-use-getters-and-settersaccessors-1657387343971"><h1>Why use getters and setters/accessors?</h1></a></div></div><div class="flex flex-wrap h-auto justify-end items-center space-x-8"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold" href="/questions/tag/setter">setter</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold" href="/questions/tag/getter">getter</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold" href="/questions/tag/abstraction">abstraction</a></div></div><div class="question-content mt-5">
                
<p>What's the advantage of using getters and setters - that only get and set - instead of simply using public fields for those variables?</p>

<p>If getters and setters are ever doing more than just the simple get/set, I can figure this one out very quickly, but I'm not 100% clear on how:</p>

<pre class="lang-java s-code-block"><code class="hljs language-java"><span class="hljs-keyword">public</span> String foo;
</code></pre>

<p>is any worse than:</p>

<pre class="lang-java s-code-block"><code class="hljs language-java"><span class="hljs-keyword">private</span> String foo;
<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setFoo</span><span class="hljs-params">(String foo)</span> { <span class="hljs-built_in">this</span>.foo = foo; }
<span class="hljs-keyword">public</span> String <span class="hljs-title function_">getFoo</span><span class="hljs-params">()</span> { <span class="hljs-keyword">return</span> foo; }
</code></pre>

<p>Whereas the former takes a lot less boilerplate code.</p>
    </div></div></div><div class="solution-section"><nav class="flex pagination-solution flex-col justify-end"><ul class="inline-flex -space-x-px overflow-auto"><li class="pagination-solution-item"><span data-id="#solution1" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">1</span></li><li class="pagination-solution-item"><span data-id="#solution2" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">2</span></li><li class="pagination-solution-item"><span data-id="#solution3" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">3</span></li><li class="pagination-solution-item"><span data-id="#solution4" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">4</span></li><li class="pagination-solution-item"><span data-id="#solution5" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">5</span></li><li class="pagination-solution-item"><span data-id="#solution6" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">6</span></li><li class="pagination-solution-item"><span data-id="#solution7" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">7</span></li><li class="pagination-solution-item"><span data-id="#solution8" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">8</span></li><li class="pagination-solution-item"><span data-id="#solution9" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">9</span></li><li class="pagination-solution-item"><span data-id="#solution10" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">10</span></li><li class="pagination-solution-item"><span data-id="#solution11" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">11</span></li><li class="pagination-solution-item"><span data-id="#solution12" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">12</span></li><li class="pagination-solution-item"><span data-id="#solution13" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">13</span></li><li class="pagination-solution-item"><span data-id="#solution14" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">14</span></li><li class="pagination-solution-item"><span data-id="#solution15" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">15</span></li><li class="pagination-solution-item"><span data-id="#solution16" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">16</span></li><li class="pagination-solution-item"><span data-id="#solution17" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">17</span></li><li class="pagination-solution-item"><span data-id="#solution18" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">18</span></li><li class="pagination-solution-item"><span data-id="#solution19" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">19</span></li><li class="pagination-solution-item"><span data-id="#solution20" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">20</span></li><li class="pagination-solution-item"><span data-id="#solution21" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">21</span></li><li class="pagination-solution-item"><span data-id="#solution22" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">22</span></li><li class="pagination-solution-item"><span data-id="#solution23" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">23</span></li><li class="pagination-solution-item"><span data-id="#solution24" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">24</span></li><li class="pagination-solution-item"><span data-id="#solution25" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">25</span></li><li class="pagination-solution-item"><span data-id="#solution26" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">26</span></li><li class="pagination-solution-item"><span data-id="#solution27" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">27</span></li><li class="pagination-solution-item"><span data-id="#solution28" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">28</span></li><li class="pagination-solution-item"><span data-id="#solution29" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">29</span></li><li class="pagination-solution-item"><span data-id="#solution30" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">30</span></li></ul></nav><div id="solution1" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 1</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/setter">setter</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/getter">getter</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/abstraction">abstraction</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p><strong>There are actually <em>many good reasons</em> to consider using accessors</strong> rather than directly exposing fields of a class - beyond just the argument of encapsulation and making future changes easier. </p>

<p><em>Here are the some of the reasons I am aware of:</em></p>

<ul>
<li>Encapsulation of behavior associated with getting or setting the property - this allows additional functionality (like validation) to be added more easily later.</li>
<li>Hiding the internal representation of the property while exposing a property using an alternative representation.</li>
<li>Insulating your public interface from change - allowing the public interface to remain constant while the implementation changes without affecting existing consumers.</li>
<li>Controlling the lifetime and memory management (disposal) semantics of the property - particularly important in non-managed memory environments (like C++ or Objective-C).</li>
<li>Providing a debugging interception point for when a property changes at runtime - debugging when and where a property changed to a particular value can be quite difficult without this in some languages.</li>
<li>Improved interoperability with libraries that are designed to operate against property getter/setters - Mocking, Serialization, and WPF come to mind.</li>
<li>Allowing inheritors to change the semantics of how the property behaves and is exposed by overriding the getter/setter methods.</li>
<li>Allowing the getter/setter to be passed around as lambda expressions rather than values.</li>
<li>Getters and setters can allow different access levels - for example the get may be public, but the set could be protected.</li>
</ul>
    </div></div></div></div><div id="solution2" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 2</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/setter">setter</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/getter">getter</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/abstraction">abstraction</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Because 2 weeks (months, years) from now when you realize that your setter needs to do <strong>more</strong> than just set the value, you'll also realize that the property has been used directly in 238 other classes :-)</p>
    </div></div></div></div><div id="solution3" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 3</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/setter">setter</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/getter">getter</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/abstraction">abstraction</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>A public field is not worse than a getter/setter pair that does nothing except returning the field and assigning to it. First, it's clear that (in most languages) there is no functional difference. Any difference must be in other factors, like maintainability or readability.</p>

<p>An oft-mentioned advantage of getter/setter pairs, isn't. There's this claim that you can change the implementation and your clients don't have to be recompiled. Supposedly, setters let you add functionality like validation later on and your clients don't even need to know about it. However, adding validation to a setter is a change to its preconditions, <strong>a violation of the previous contract</strong>, which was, quite simply, "you can put anything in here, and you can get that same thing later from the getter".</p>

<p>So, now that you broke the contract, changing every file in the codebase is something you should want to do, not avoid. If you avoid it you're making the assumption that all the code assumed the contract for those methods was different.</p>

<p>If that should not have been the contract, then the interface was allowing clients to put the object in invalid states. <em>That's the exact opposite of encapsulation</em> If that field could not really be set to anything from the start, why wasn't the validation there from the start?</p>

<p>This same argument applies to other supposed advantages of these pass-through getter/setter pairs: if you later decide to change the value being set, you're breaking the contract. If you override the default functionality in a derived class, in a way beyond a few harmless modifications (like logging or other non-observable behaviour), you're breaking the contract of the base class. That is a violation of the Liskov Substitutability Principle, which is seen as one of the tenets of OO.</p>

<p>If a class has these dumb getters and setters for every field, then it is a class that has no invariants whatsoever, <em>no contract</em>. Is that really object-oriented design? If all the class has is those getters and setters, it's just a dumb data holder, and dumb data holders should look like dumb data holders:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Foo</span> {
<span class="hljs-keyword">public</span>:
    <span class="hljs-type">int</span> DaysLeft;
    <span class="hljs-type">int</span> ContestantNumber;
};
</code></pre>

<p>Adding pass-through getter/setter pairs to such a class adds no value. Other classes should provide meaningful operations, not just operations that fields already provide. That's how you can define and maintain useful invariants.</p>

<blockquote>
  <p><strong>Client</strong>: "What can I do with an object of this class?"<br>
  <strong>Designer</strong>: "You can read and write several variables."<br>
  <strong>Client</strong>: "Oh... cool, I guess?"</p>
</blockquote>

<p>There are reasons to use getters and setters, but if those reasons don't exist, making getter/setter pairs in the name of false encapsulation gods is not a good thing. Valid reasons to make getters or setters include the things often mentioned as the potential changes you can make later, like validation or different internal representations. Or maybe the value should be readable by clients but not writable (for example, reading the size of a dictionary), so a simple getter is a nice choice. But those reasons should be there when you make the choice, and not just as a potential thing you may want later. This is an instance of YAGNI (<em>You Ain't Gonna Need It</em>).</p>
    </div></div></div></div><div id="solution4" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 4</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/setter">setter</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/getter">getter</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/abstraction">abstraction</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Lots of people talk about the advantages of getters and setters but I want to play devil's advocate. Right now I'm debugging a very large program where the programmers decided to make everything getters and setters. That might seem nice, but its a reverse-engineering nightmare.</p>

<p>Say you're looking through hundreds of lines of code and you come across this:</p>

<pre class="lang-java s-code-block"><code class="hljs language-java">person.name = <span class="hljs-string">"Joe"</span>;
</code></pre>

<p>It's a beautifully simply piece of code until you realize its a setter. Now, you follow that setter and find that it also sets person.firstName, person.lastName, person.isHuman, person.hasReallyCommonFirstName, and calls person.update(), which sends a query out to the database, etc. Oh, that's where your memory leak was occurring.</p>

<p>Understanding a local piece of code at first glance is an important property of good readability that getters and setters tend to break. That is why I try to avoid them when I can, and minimize what they do when I use them.</p>
    </div></div></div></div><div id="solution5" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 5</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/setter">setter</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/getter">getter</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/abstraction">abstraction</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>In a pure object-oriented world getters and setters is a <strong>terrible anti-pattern</strong>. Read this article: <a href="http://www.yegor256.com/2014/09/16/getters-and-setters-are-evil.html" rel="noreferrer">Getters/Setters. Evil. Period</a>. In a nutshell, they encourage programmers to think about objects as of data structures, and this type of thinking is pure procedural (like in COBOL or C). In an object-oriented language there are no data structures, but only objects that expose behavior (not attributes/properties!)</p>

<p>You may find more about them in Section 3.5 of <a href="https://www.yegor256.com/elegant-objects.html" rel="noreferrer">Elegant Objects</a> (my book about object-oriented programming).</p>
    </div></div></div></div><div id="solution6" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 6</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/setter">setter</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/getter">getter</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/abstraction">abstraction</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>There are many reasons. My favorite one is when you need to change the behavior or regulate what you can set on a variable. For instance, lets say you had a setSpeed(int speed) method. But you want that you can only set a maximum speed of 100. You would do something like:</p>

<pre class="lang-java s-code-block"><code class="hljs language-java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setSpeed</span><span class="hljs-params">(<span class="hljs-type">int</span> speed)</span> {
  <span class="hljs-keyword">if</span> ( speed &gt; <span class="hljs-number">100</span> ) {
    <span class="hljs-built_in">this</span>.speed = <span class="hljs-number">100</span>;
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-built_in">this</span>.speed = speed;
  }
}
</code></pre>

<p>Now what if EVERYWHERE in your code you were using the public field and then you realized you need the above requirement? Have fun hunting down every usage of the public field instead of just modifying your setter.</p>

<p>My 2 cents :)</p>
    </div></div></div></div><div id="solution7" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 7</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/setter">setter</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/getter">getter</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/abstraction">abstraction</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>One advantage of accessors and mutators is that you can perform validation.</p>

<p>For example, if <code>foo</code> was public, I could easily set it to <code>null</code> and then someone else could try to call a method on the object. But it's not there anymore! With a <code>setFoo</code> method, I could ensure that <code>foo</code> was never set to <code>null</code>.</p>

<p>Accessors and mutators also allow for encapsulation - if you aren't supposed to see the value once its set (perhaps it's set in the constructor and then used by methods, but never supposed to be changed), it will never been seen by anyone. But if you can allow other classes to see or change it, you can provide the proper accessor and/or mutator.</p>
    </div></div></div></div><div id="solution8" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 8</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/setter">setter</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/getter">getter</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/abstraction">abstraction</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Depends on your language.  You've tagged this "object-oriented" rather than "Java", so I'd like to point out that ChssPly76's answer is language-dependent.  In Python, for instance, there is no reason to use getters and setters.  If you need to change the behavior, you can use a property, which wraps a getter and setter around basic attribute access.  Something like this:</p>
<pre class="lang-py s-code-block"><code class="hljs language-python"> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Simple</span>(<span class="hljs-title class_ inherited__">object</span>):
   <span class="hljs-keyword">def</span> <span class="hljs-title function_">_get_value</span>(<span class="hljs-params">self</span>):
       <span class="hljs-keyword">return</span> self._value -<span class="hljs-number">1</span>

   <span class="hljs-keyword">def</span> <span class="hljs-title function_">_set_value</span>(<span class="hljs-params">self, new_value</span>):
       self._value = new_value + <span class="hljs-number">1</span>

   <span class="hljs-keyword">def</span> <span class="hljs-title function_">_del_value</span>(<span class="hljs-params">self</span>):
       self.old_values.append(self._value)
       <span class="hljs-keyword">del</span> self._value

   value = <span class="hljs-built_in">property</span>(_get_value, _set_value, _del_value)
</code></pre>
    </div></div></div></div><div id="solution9" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 9</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/setter">setter</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/getter">getter</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/abstraction">abstraction</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Thanks, that really clarified my thinking. Now here is (almost) 10 (almost) good reasons NOT to use getters and setters:</p>

<ol>
<li>When you realize you need to do more than just set and get the value, you can just make the field private, which will instantly tell you where you've directly accessed it.<br></li>
<li>Any validation you perform in there can only be context free, which validation rarely is in practice.<br></li>
<li>You can change the value being set - this is an absolute nightmare when the caller passes you a value that they [shock horror] want you to store AS IS.<br></li>
<li>You can hide the internal representation - fantastic, so you're making sure that all these operations are symmetrical right?<br></li>
<li>You've insulated your public interface from changes under the sheets - if you were designing an interface and weren't sure whether direct access to something was OK, then you should have kept designing.<br></li>
<li>Some libraries expect this, but not many - reflection, serialization, mock objects all work just fine with public fields.<br></li>
<li>Inheriting this class, you can override default functionality - in other words you can REALLY confuse callers by not only hiding the implementation but making it inconsistent.<br></li>
</ol>

<p>The last three I'm just leaving (N/A or D/C)...</p>
    </div></div></div></div><div id="solution10" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 10</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/setter">setter</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/getter">getter</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/abstraction">abstraction</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Well i just want to add that even if sometimes they are necessary for the encapsulation and security of your variables/objects, if we want to code a real Object Oriented Program, then we need to <strong><a href="http://www.javaworld.com/javaworld/jw-09-2003/jw-0905-toolbox.html?page=1">STOP OVERUSING THE ACCESSORS</a></strong>, cause sometimes we depend a lot on them when is not really necessary and that makes almost the same as if we put the variables public.</p>
    </div></div></div></div><div id="solution11" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 11</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/setter">setter</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/getter">getter</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/abstraction">abstraction</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>EDIT: I answered this question because there are a bunch of people learning programming asking this, and most of the answers are very technically competent, but they're not as easy to understand if you're a newbie. We were all newbies, so I thought I'd try my hand at a more newbie friendly answer.</p>

<p>The two main ones are polymorphism, and validation. Even if it's just a stupid data structure.</p>

<p>Let's say we have this simple class:</p>

<pre class="lang-java s-code-block"><code class="hljs language-java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Bottle</span> {
  <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> amountOfWaterMl;
  <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> capacityMl;
}
</code></pre>

<p>A very simple class that holds how much liquid is in it, and what its capacity is (in milliliters).</p>

<p>What happens when I do:</p>

<pre class="lang-java s-code-block"><code class="hljs language-java"><span class="hljs-type">Bottle</span> <span class="hljs-variable">bot</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Bottle</span>();
bot.amountOfWaterMl = <span class="hljs-number">1500</span>;
bot.capacityMl = <span class="hljs-number">1000</span>;
</code></pre>

<p>Well, you wouldn't expect that to work, right?
You want there to be some kind of sanity check. And worse, what if I never specified the maximum capacity? Oh dear, we have a problem.</p>

<p>But there's another problem too. What if bottles were just one type of container? What if we had several containers, all with capacities and amounts of liquid filled? If we could just make an interface, we could let the rest of our program accept that interface, and bottles, jerrycans and all sorts of stuff would just work interchangably. Wouldn't that be better? Since interfaces demand methods, this is also a good thing.</p>

<p>We'd end up with something like:</p>

<pre class="lang-java s-code-block"><code class="hljs language-java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">LiquidContainer</span> {
  <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getAmountMl</span><span class="hljs-params">()</span>;
  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setAmountMl</span><span class="hljs-params">(<span class="hljs-type">int</span> amountMl)</span>;
  <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getCapacityMl</span><span class="hljs-params">()</span>;
}
</code></pre>

<p>Great! And now we just change Bottle to this:</p>

<pre class="lang-java s-code-block"><code class="hljs language-java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Bottle</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">LiquidContainer</span> {
  <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> capacityMl;
  <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> amountFilledMl;

  <span class="hljs-keyword">public</span> <span class="hljs-title function_">Bottle</span><span class="hljs-params">(<span class="hljs-type">int</span> capacityMl, <span class="hljs-type">int</span> amountFilledMl)</span> {
    <span class="hljs-built_in">this</span>.capacityMl = capacityMl;
    <span class="hljs-built_in">this</span>.amountFilledMl = amountFilledMl;
    checkNotOverFlow();
  }

  <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getAmountMl</span><span class="hljs-params">()</span> {
    <span class="hljs-keyword">return</span> amountFilledMl;
  }

  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setAmountMl</span><span class="hljs-params">(<span class="hljs-type">int</span> amountMl)</span> {
     <span class="hljs-built_in">this</span>.amountFilled = amountMl;
     checkNotOverFlow();
  }
  <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getCapacityMl</span><span class="hljs-params">()</span> {
    <span class="hljs-keyword">return</span> capacityMl;
  }

  <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">checkNotOverFlow</span><span class="hljs-params">()</span> {
    <span class="hljs-keyword">if</span>(amountOfWaterMl &gt; capacityMl) {
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BottleOverflowException</span>();
    }
}
</code></pre>

<p>I'll leave the definition of the BottleOverflowException as an exercise to the reader.</p>

<p>Now notice how much more robust this is. We can deal with any type of container in our code now by accepting LiquidContainer instead of Bottle. And how these bottles deal with this sort of stuff can all differ. You can have bottles that write their state to disk when it changes, or bottles that save on SQL databases or GNU knows what else.</p>

<p>And all these can have different ways to handle various whoopsies. The Bottle just checks and if it's overflowing it throws a RuntimeException. But that might be the wrong thing to do. 
(There is a useful discussion to be had about error handling, but I'm keeping it very simple here on purpose. People in comments will likely point out the flaws of this simplistic approach. ;) )</p>

<p>And yes, it seems like we go from a very simple idea to getting much better answers quickly.</p>

<p>Please note also that you can't change the capacity of a bottle. It's now set in stone. You could do this with an int by declaring it final. But if this was a list, you could empty it, add new things to it, and so on. You can't limit the access to touching the innards.</p>

<p>There's also the third thing that not everyone has addressed: getters and setters use method calls. That means that they look like normal methods everywhere else does. Instead of having weird specific syntax for DTOs and stuff, you have the same thing everywhere.</p>
    </div></div></div></div><div id="solution12" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 12</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/setter">setter</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/getter">getter</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/abstraction">abstraction</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>I know it's a bit late, but I think there are some people who are interested in performance.</p>

<p>I've done a little performance test. I wrote a class "NumberHolder" which, well, holds an Integer. You can either read that Integer by using the getter method
<code>anInstance.getNumber()</code> or by directly accessing the number by using <code>anInstance.number</code>. My programm reads the number 1,000,000,000 times, via both ways. That process is repeated five times and the time is printed. I've got the following result:</p>

<pre class="lang-java s-code-block"><code class="hljs language-java">Time <span class="hljs-number">1</span>: 953ms, Time <span class="hljs-number">2</span>: 741ms
Time <span class="hljs-number">1</span>: 655ms, Time <span class="hljs-number">2</span>: 743ms
Time <span class="hljs-number">1</span>: 656ms, Time <span class="hljs-number">2</span>: 634ms
Time <span class="hljs-number">1</span>: 637ms, Time <span class="hljs-number">2</span>: 629ms
Time <span class="hljs-number">1</span>: 633ms, Time <span class="hljs-number">2</span>: 625ms
</code></pre>

<p>(Time 1 is the direct way, Time 2 is the getter)</p>

<p>You see, the getter is (almost) always a bit faster. Then I tried with different numbers of cycles. Instead of 1 million, I used 10 million and 0.1 million.
The results:</p>

<p>10 million cycles: </p>

<pre class="lang-java s-code-block"><code class="hljs language-java">Time <span class="hljs-number">1</span>: 6382ms, Time <span class="hljs-number">2</span>: 6351ms
Time <span class="hljs-number">1</span>: 6363ms, Time <span class="hljs-number">2</span>: 6351ms
Time <span class="hljs-number">1</span>: 6350ms, Time <span class="hljs-number">2</span>: 6363ms
Time <span class="hljs-number">1</span>: 6353ms, Time <span class="hljs-number">2</span>: 6357ms
Time <span class="hljs-number">1</span>: 6348ms, Time <span class="hljs-number">2</span>: 6354ms
</code></pre>

<p>With 10 million cycles, the times are almost the same.
Here are 100 thousand (0.1 million) cycles:</p>

<pre class="lang-java s-code-block"><code class="hljs language-java">Time <span class="hljs-number">1</span>: 77ms, Time <span class="hljs-number">2</span>: 73ms
Time <span class="hljs-number">1</span>: 94ms, Time <span class="hljs-number">2</span>: 65ms
Time <span class="hljs-number">1</span>: 67ms, Time <span class="hljs-number">2</span>: 63ms
Time <span class="hljs-number">1</span>: 65ms, Time <span class="hljs-number">2</span>: 65ms
Time <span class="hljs-number">1</span>: 66ms, Time <span class="hljs-number">2</span>: 63ms
</code></pre>

<p>Also with different amounts of cycles, the getter is a little bit faster than the regular way. I hope this helped you.</p>
    </div></div></div></div><div id="solution13" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 13</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/setter">setter</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/getter">getter</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/abstraction">abstraction</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<h2>We use getters and setters:</h2>

<ul>
<li>for reusability</li>
<li>to perform validation in later stages of programming</li>
</ul>

<p>Getter and setter methods are public interfaces to access private class members.</p>

<hr>

<h2>Encapsulation mantra</h2>

<p>The encapsulation mantra is to make fields private and methods public.</p>

<blockquote>
  <p><strong>Getter Methods:</strong> <em>We can get access to private variables.</em></p>
  
  <p><strong>Setter Methods:</strong> <em>We can modify private fields.</em></p>
</blockquote>

<p>Even though the getter and setter methods do not add new functionality, we can change our mind come back later to make that method</p>

<ul>
<li>better;</li>
<li>safer; and</li>
<li>faster.</li>
</ul>

<hr>

<p>Anywhere a value can be used, a method that returns that value can be added. Instead of:</p>

<pre class="lang-java s-code-block"><code class="hljs language-java"><span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> <span class="hljs-number">1000</span> - <span class="hljs-number">500</span>
</code></pre>

<p>use</p>

<pre class="lang-java s-code-block"><code class="hljs language-java"><span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> <span class="hljs-number">1000</span> - class_name.getValue();
</code></pre>

<hr>

<h2>In layman's terms</h2>

<p><img src="https://i.stack.imgur.com/2lgj0.png" alt="Representation of &quot;Person&quot; class"></p>

<p>Suppose we need to store the details of this <code>Person</code>. This <code>Person</code> has the fields <code>name</code>, <code>age</code> and <code>sex</code>. Doing this involves creating methods for <code>name</code>, <code>age</code> and <code>sex</code>. Now if we need create another person, it becomes necessary to create the methods for <code>name</code>, <code>age</code>, <code>sex</code> all over again.</p>

<p>Instead of doing this, we can create a bean <code>class(Person)</code> with getter and setter methods.  So tomorrow we can just create objects of this Bean <code>class(Person class)</code> whenever we need to add a new person (see the figure). Thus we are reusing the fields and methods of bean class, which is much better.</p>
    </div></div></div></div><div id="solution14" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 14</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/setter">setter</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/getter">getter</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/abstraction">abstraction</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>I spent quite a while thinking this over for the Java case, and I believe the real reasons are:</p>

<ol>
<li><strong>Code to the interface, not the implementation</strong></li>
<li><strong>Interfaces only specify methods, not fields</strong></li>
</ol>

<p>In other words, the only way you can specify a field in an interface is by providing a method for writing a new value and a method for reading the current value.  </p>

<p>Those methods are the infamous getter and setter....</p>
    </div></div></div></div><div id="solution15" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 15</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/setter">setter</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/getter">getter</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/abstraction">abstraction</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Don't use getters setters unless needed for your current delivery I.e. Don't think too much about what would happen in the future, if any thing to be changed its a change request in most of the production applications, systems.</p>

<p>Think simple, easy, add complexity when needed.</p>

<p>I would not take advantage of ignorance of business owners of deep technical know how just because I think it's correct or I like the approach.</p>

<p>I have massive system written without getters setters only with access modifiers and some methods to validate n perform biz logic. If you absolutely needed the. Use anything.</p>
    </div></div></div></div><div id="solution16" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 16</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/setter">setter</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/getter">getter</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/abstraction">abstraction</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>It can be useful for lazy-loading.  Say the object in question is stored in a database, and you don't want to go get it unless you need it.  If the object is retrieved by a getter, then the internal object can be null until somebody asks for it, then you can go get it on the first call to the getter.</p>

<p>I had a base page class in a project that was handed to me that was loading some data from a couple different web service calls, but the data in those web service calls wasn't always used in all child pages.  Web services, for all of the benefits, pioneer new definitions of "slow", so you don't want to make a web service call if you don't have to.</p>

<p>I moved from public fields to getters, and now the getters check the cache, and if it's not there call the web service.  So with a little wrapping, a lot of web service calls were prevented.</p>

<p>So the getter saves me from trying to figure out, on each child page, what I will need.  If I need it, I call the getter, and it goes to find it for me if I don't already have it.</p>

<pre class="lang-java s-code-block"><code class="hljs language-java">    <span class="hljs-keyword">protected</span> <span class="hljs-type">YourType</span> <span class="hljs-variable">_yourName</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;
    <span class="hljs-keyword">public</span> YourType YourName{
      get
      {
        <span class="hljs-keyword">if</span> (_yourName == <span class="hljs-literal">null</span>)
        {
          _yourName = <span class="hljs-keyword">new</span> <span class="hljs-title class_">YourType</span>();
          <span class="hljs-keyword">return</span> _yourName;
        }
      }
    }
</code></pre>
    </div></div></div></div><div id="solution17" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 17</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/setter">setter</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/getter">getter</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/abstraction">abstraction</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>One aspect I missed in the answers so far, the access specification:</p>

<ul>
<li>for members you have only one access specification for both setting and getting</li>
<li>for setters and getters you can fine tune it and define it separately</li>
</ul>
    </div></div></div></div><div id="solution18" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 18</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/setter">setter</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/getter">getter</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/abstraction">abstraction</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>In languages which don't support "properties" (C++, Java) or require recompilation of clients when changing fields to properties (C#), using get/set methods is easier to modify. For example, adding validation logic to a setFoo method will not require changing the public interface of a class.</p>

<p>In languages which support "real" properties (Python, Ruby, maybe Smalltalk?) there is no point to get/set methods.</p>
    </div></div></div></div><div id="solution19" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 19</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/setter">setter</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/getter">getter</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/abstraction">abstraction</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>One of the basic principals of OO design: <strong>Encapsulation!</strong></p>

<p>It gives you many benefits, one of which being that you can change the implementation of the getter/setter behind the scenes but any consumer of that value will continue to work as long as the data type remains the same.</p>
    </div></div></div></div><div id="solution20" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 20</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/setter">setter</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/getter">getter</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/abstraction">abstraction</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>You should use getters and setters when:</p>

<ul>
<li>You're dealing with something that is conceptually an attribute, but:
<ul>
<li>Your language doesn't have properties (or some similar mechanism, like Tcl's variable traces), or</li>
<li>Your language's property support isn't sufficient for this use case, or</li>
<li>Your language's (or sometimes your framework's) idiomatic conventions encourage getters or setters for this use case.</li>
</ul></li>
</ul>

<p>So this is very rarely a general OO question; it's a language-specific question, with different answers for different languages (and different use cases).</p>

<hr>

<p>From an OO theory point of view, getters and setters are useless. The interface of your class is what it does, not what its state is. (If not, you've written the wrong class.) In very simple cases, where what a class does is just, e.g., represent a point in rectangular coordinates,* the attributes are part of the interface; getters and setters just cloud that. But in anything but very simple cases, neither the attributes nor getters and setters are part of the interface.</p>

<p>Put another way: If you believe that consumers of your class shouldn't even know that you have a <code>spam</code> attribute, much less be able to change it willy-nilly, then giving them a <code>set_spam</code> method is the last thing you want to do.</p>

<p><sub>* Even for that simple class, you may not necessarily want to allow setting the <code>x</code> and <code>y</code> values. If this is really a class, shouldn't it have methods like <code>translate</code>, <code>rotate</code>, etc.? If it's only a class because your language doesn't have records/structs/named tuples, then this isn't really a question of OO</sub></p>

<hr>

<p>But nobody is ever doing general OO design. They're doing design, and implementation, in a specific language. And in some languages, getters and setters are far from useless.</p>

<p>If your language doesn't have properties, then the only way to represent something that's conceptually an attribute, but is actually computed, or validated, etc., is through getters and setters.</p>

<p>Even if your language does have properties, there may be cases where they're insufficient or inappropriate. For example, if you want to allow subclasses to control the semantics of an attribute, in languages without dynamic access, a subclass can't substitute a computed property for an attribute.</p>

<p>As for the "what if I want to change my implementation later?" question (which is repeated multiple times in different wording in both the OP's question and the accepted answer): If it really is a pure implementation change, and you started with an attribute, you can change it to a property without affecting the interface. Unless, of course, your language doesn't support that. So this is really just the same case again.</p>

<p>Also, it's important to follow the idioms of the language (or framework) you're using. If you write beautiful Ruby-style code in C#, any experienced C# developer other than you is going to have trouble reading it, and that's bad. Some languages have stronger cultures around their conventions than others.and it may not be a coincidence that Java and Python, which are on opposite ends of the spectrum for how idiomatic getters are, happen to have two of the strongest cultures.</p>

<p>Beyond human readers, there will be libraries and tools that expect you to follow the conventions, and make your life harder if you don't. Hooking Interface Builder widgets to anything but ObjC properties, or using certain Java mocking libraries without getters, is just making your life more difficult. If the tools are important to you, don't fight them.</p>
    </div></div></div></div><div id="solution21" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 21</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/setter">setter</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/getter">getter</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/abstraction">abstraction</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>From a object orientation design standpoint both alternatives can be damaging to the maintenance of the code by weakening the encapsulation of the classes. For a discussion you can look into this excellent article: <a href="http://typicalprogrammer.com/?p=23" rel="noreferrer">http://typicalprogrammer.com/?p=23</a> </p>
    </div></div></div></div><div id="solution22" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 22</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/setter">setter</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/getter">getter</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/abstraction">abstraction</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Code <em>evolves</em>.  <code>private</code> is great for when <em>you need data member protection</em>.  Eventually all classes should be sort of "miniprograms" that have a well-defined interface <em>that you can't just screw with the internals of</em>.</p>

<p>That said, <em>software development</em> isn't about setting down that final version of the class as if you're pressing some cast iron statue on the first try.  While you're working with it, code is more like clay.  <strong>It evolves</strong> as you develop it and learn more about the problem domain you are solving.  During development classes may interact with each other than they should (dependency you plan to factor out), merge together, or split apart.  So I think the debate boils down to people not wanting to religiously write</p>

<pre class="lang-java s-code-block"><code class="hljs language-java"><span class="hljs-type">int</span> <span class="hljs-title function_">getVar</span><span class="hljs-params">()</span> const { <span class="hljs-keyword">return</span> <span class="hljs-keyword">var</span> ; }
</code></pre>

<p>So you have:</p>

<pre class="lang-java s-code-block"><code class="hljs language-java">doSomething( obj-&gt;getVar() ) ;
</code></pre>

<p>Instead of</p>

<pre class="lang-java s-code-block"><code class="hljs language-java">doSomething( obj-&gt;<span class="hljs-keyword">var</span> ) ;
</code></pre>

<p>Not only is <code>getVar()</code> visually noisy, it gives this illusion that <code>gettingVar()</code> is somehow a more complex process than it really is.  How you (as the class writer) regard the sanctity of <code>var</code> is particularly confusing to a user of your class if it has a passthru setter -- then it looks like you're putting up these gates to "protect" something you insist is valuable, (the sanctity of <code>var</code>) but yet even you concede <code>var</code>'s protection isn't worth much by the ability for anyone to just come in and <code>set</code> <code>var</code> to whatever value they want, without you even peeking at what they are doing.</p>

<p>So I program as follows (assuming an "agile" type approach -- ie when I write code not knowing <em>exactly</em> what it will be doing/don't have time or experience to plan an elaborate waterfall style interface set):</p>

<p>1) Start with all public members for basic objects with data and behavior.  This is why in all my C++ "example" code you'll notice me using <code>struct</code> instead of <code>class</code> everywhere.</p>

<p>2) When an object's internal behavior for a data member becomes complex enough, (for example, it likes to keep an internal <code>std::list</code> in some kind of order), accessor type functions are written.  Because I'm programming by myself, I don't always set the member <code>private</code> right away, but somewhere down the evolution of the class the member will be "promoted" to either <code>protected</code> or <code>private</code>.</p>

<p>3) Classes that are fully fleshed out and have strict rules about their internals (ie <em>they</em> know exactly what they are doing, and you are not to "fuck" (technical term) with its internals) are given the <code>class</code> designation, default private members, and only a select few members are allowed to be <code>public</code>.</p>

<p>I find this approach allows me to avoid sitting there and religiously writing getter/setters when a lot of data members get migrated out, shifted around, etc. during the early stages of a class's evolution.</p>
    </div></div></div></div><div id="solution23" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 23</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/setter">setter</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/getter">getter</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/abstraction">abstraction</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>There is a good reason to consider using accessors is there is no property inheritance. See next example:</p>

<pre class="lang-java s-code-block"><code class="hljs language-java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestPropertyOverride</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> {
        <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;

        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">()</span> {
            i++;
        }

        <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getI</span><span class="hljs-params">()</span> {
            <span class="hljs-keyword">return</span> i;
        }
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">A</span> {
        <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;

        <span class="hljs-meta">@Override</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">()</span> {
            i = i + <span class="hljs-number">2</span>;
        }

        <span class="hljs-meta">@Override</span>
        <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getI</span><span class="hljs-params">()</span> {
            <span class="hljs-keyword">return</span> i;
        }
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {
        <span class="hljs-type">A</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">B</span>();
        System.out.println(a.i);
        a.add();
        System.out.println(a.i);
        System.out.println(a.getI());
    }
}
</code></pre>

<p>Output:</p>

<pre class="lang-java s-code-block"><code class="hljs language-java"><span class="hljs-number">0</span>
<span class="hljs-number">0</span>
<span class="hljs-number">4</span>
</code></pre>
    </div></div></div></div><div id="solution24" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 24</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/setter">setter</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/getter">getter</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/abstraction">abstraction</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p><strong>Getters</strong> and <strong>setters</strong> are used to implement two of the fundamental aspects of Object Oriented Programming which are: </p>

<ol>
<li>Abstraction</li>
<li>Encapsulation</li>
</ol>

<p>Suppose we have an Employee class:</p>

<pre class="lang-java s-code-block"><code class="hljs language-java"><span class="hljs-keyword">package</span> com.highmark.productConfig.types;

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Employee</span> {

    <span class="hljs-keyword">private</span> String firstName;
    <span class="hljs-keyword">private</span> String middleName;
    <span class="hljs-keyword">private</span> String lastName;

    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getFirstName</span><span class="hljs-params">()</span> {
      <span class="hljs-keyword">return</span> firstName;
    }
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setFirstName</span><span class="hljs-params">(String firstName)</span> {
       <span class="hljs-built_in">this</span>.firstName = firstName;
    }
    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getMiddleName</span><span class="hljs-params">()</span> {
        <span class="hljs-keyword">return</span> middleName;
    }
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setMiddleName</span><span class="hljs-params">(String middleName)</span> {
         <span class="hljs-built_in">this</span>.middleName = middleName;
    }
    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getLastName</span><span class="hljs-params">()</span> {
        <span class="hljs-keyword">return</span> lastName;
    }
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setLastName</span><span class="hljs-params">(String lastName)</span> {
        <span class="hljs-built_in">this</span>.lastName = lastName;
    }

    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getFullName</span><span class="hljs-params">()</span>{
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.getFirstName() + <span class="hljs-built_in">this</span>.getMiddleName() +  <span class="hljs-built_in">this</span>.getLastName();
    }
 }
</code></pre>

<p>Here the implementation details of Full Name is hidden from the user and is not accessible directly to the user, unlike a public attribute.   </p>
    </div></div></div></div><div id="solution25" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 25</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/setter">setter</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/getter">getter</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/abstraction">abstraction</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>If you don't require any validations and not even need to maintain state i.e. one property depends on another so we need to maintain the state when one is change. You can keep it simple by making field public and not using getter and setters.</p>
<p>I think OOPs complicates things as the program grows it becomes nightmare for developer to scale.</p>
<p>A simple example; we generate c++ headers from xml. The header contains simple field which does not require any validations. But still as in OOPS accessor  are fashion we generates them  as following.</p>
<pre class="lang-java s-code-block"><code class="hljs language-java">const Filed&amp; getfield() const
Field&amp; getField() 
<span class="hljs-keyword">void</span> <span class="hljs-title function_">setfield</span><span class="hljs-params">(const Field&amp; field)</span>{...} 
</code></pre>
<p>which is very verbose and is not required. a simple</p>
<pre class="lang-java s-code-block"><code class="hljs language-java">struct 
{
   Field field;
};
</code></pre>
<p>is enough and readable.
Functional programming don't have the concept of data hiding they even don't require it as they do not mutate the data.</p>
    </div></div></div></div><div id="solution26" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 26</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/setter">setter</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/getter">getter</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/abstraction">abstraction</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Getter and setter methods are accessor methods, meaning that they are generally a public interface to change private class members. You use getter and setter methods to define a property. You access getter and setter methods as properties outside the class, even though you define them within the class as methods. Those properties outside the class can have a different name from the property name in the class.</p>

<p>There are some advantages to using getter and setter methods, such as the ability to let you create members with sophisticated functionality that you can access like properties. They also let you create read-only and write-only properties.</p>

<p>Even though getter and setter methods are useful, you should be careful not to overuse them because, among other issues, they can make code maintenance more difficult in certain situations. Also, they provide access to your class implementation, like public members. OOP practice discourages direct access to properties within a class.</p>

<p>When you write classes, you are always encouraged to make as many as possible of your instance variables private and add getter and setter methods accordingly. This is because there are several times when you may not want to let users change certain variables within your classes. For example, if you have a private static method that tracks the number of instances created for a specific class, you don't want a user to modify that counter using code. Only the constructor statement should increment that variable whenever it's called. In this situation, you might create a private instance variable and allow a getter method only for the counter variable, which means users are able to retrieve the current value only by using the getter method, and they won't be able to set new values using the setter method. Creating a getter without a setter is a simple way of making certain variables in your class read-only.</p>
    </div></div></div></div><div id="solution27" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 27</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/setter">setter</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/getter">getter</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/abstraction">abstraction</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>There is a difference between DataStructure and Object.</p>
<p>Datastructure should expose its innards and not behavior.</p>
<p>An Object should not expose its innards but it should expose its behavior, which is also known as the Law of Demeter</p>
<p>Mostly DTOs are considered more of a datastructure and not Object. They should only expose their data and not behavior. Having Setter/Getter in DataStructure will expose behavior instead of data inside it. This further increases the chance of violation of <strong>Law of Demeter</strong>.</p>
<p>Uncle Bob in his book Clean code explained the Law of Demeter.</p>
<blockquote>
<p>There is a well-known heuristic called the Law of Demeter that says a
module should not know about the innards of the objects it
manipulates. As we saw in the last section, objects hide their data
and expose operations. This means that an object should not expose its
internal structure through accessors because to do so is to expose,
rather than to hide, its internal structure.</p>
<p>More precisely, the Law of Demeter says that a method f of a class C
should only call the methods of these:</p>
<ul>
<li>C</li>
<li>An object created by f</li>
<li>An object passed as an argument to f</li>
<li>An object held in an instance variable of C</li>
</ul>
<p>The method should not invoke methods on objects that are returned by any of the allowed functions.
In other words, talk to friends, not to strangers.</p>
</blockquote>
<p>So according this, example of LoD violation is:</p>
<pre class="lang-java s-code-block"><code class="hljs language-java"><span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">outputDir</span> <span class="hljs-operator">=</span> ctxt.getOptions().getScratchDir().getAbsolutePath();
</code></pre>
<p>Here, the function should call the method of its immediate friend which is ctxt here, It should not call the method of its immediate friend's friend. but this rule doesn't apply to data structure. so here if ctxt, option, scratchDir are  datastructure then why to wrap their internal data with some behavior and doing a violation of LoD.</p>
<p>Instead, we can do something like this.</p>
<pre class="lang-java s-code-block"><code class="hljs language-java"><span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">outputDir</span> <span class="hljs-operator">=</span> ctxt.options.scratchDir.absolutePath;
</code></pre>
<p>This fulfills our needs and doesn't even violate LoD.</p>
<p>Inspired by Clean Code by Robert C. Martin(Uncle Bob)</p>
    </div></div></div></div><div id="solution28" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 28</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/setter">setter</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/getter">getter</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/abstraction">abstraction</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Additionally, this is to "future-proof" your class. In particular, changing from a field to a property is an ABI break, so if you do later decide that you need more logic than just "set/get the field", then you need to break ABI, which of course creates problems for anything else already compiled against your class.</p>
    </div></div></div></div><div id="solution29" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 29</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/setter">setter</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/getter">getter</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/abstraction">abstraction</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>One other use (in languages that support properties) is that setters and getters can imply that an operation is non-trivial.  Typically, you want to avoid doing anything that's computationally expensive in a property.</p>
    </div></div></div></div><div id="solution30" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 30</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/setter">setter</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/getter">getter</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/abstraction">abstraction</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>One relatively modern advantage of getters/setters is that is makes it easier to browse code in tagged (indexed) code editors. E.g. If you want to see who sets a member, you can open the call hierarchy of the setter.</p>

<p>On the other hand, if the member is public, the tools don't make it possible to filter read/write access to the member. So you have to trudge though all uses of the member.</p>
    </div></div></div></div></div></div><div class="widget"><a href="/questions/the-definitive-guide-to-form-based-website-authentication-closed-1657388456475">The definitive guide to form-based website authentication [closed]</a><a href="/questions/mysql-error-1093-can&#x27;t-specify-target-table-for-update-in-from-clause-1657388078961">MySQL Error 1093 - Can&#x27;t specify target table for update in FROM clause</a><a href="/questions/how-do-i-split-a-delimited-string-so-i-can-access-individual-items-1657388042385">How do I split a delimited string so I can access individual items?</a><a href="/questions/list-of-lists-changes-reflected-across-sublists-unexpectedly-1657384393720">List of lists changes reflected across sublists unexpectedly</a><a href="/questions/what-is-a-lambda-expression-in-c++11-1657387999252">What is a lambda expression in C++11?</a><a href="/questions/how-can-i-validate-an-email-address-using-a-regular-expression-1657384549233">How can I validate an email address using a regular expression?</a><a href="/questions/safely-turning-a-json-string-into-an-object-1657388194824">Safely turning a JSON string into an object</a><a href="/questions/dynamically-select-data-frame-columns-using-dollar-and-a-character-value-1657387836662">Dynamically select data frame columns using $ and a character value</a><a href="/questions/why-should-there-be-spaces-around-&#x27;&#x27;-and-&#x27;&#x27;-in-bash-1657387984122">Why should there be spaces around &#x27;[&#x27; and &#x27;]&#x27; in Bash?</a><a href="/questions/what-is-the-difference-between-__str__-and-__repr__-1657387738760">What is the difference between __str__ and __repr__?</a><a href="/questions/what-is-the-strict-aliasing-rule-1657384742852">What is the strict aliasing rule?</a><a href="/questions/efficiently-convert-rows-to-columns-in-sql-server-1657387919213">Efficiently convert rows to columns in sql server</a><a href="/questions/is-there-any-way-to-kill-a-thread-1657387859831">Is there any way to kill a Thread?</a><a href="/questions/how-do-javascript-closures-work-1657384418555">How do JavaScript closures work?</a><a href="/questions/the-3-different-equals-1657385490242">The 3 different equals</a><a href="/questions/big-o-how-do-you-calculateapproximate-it-1657387856392">Big O, how do you calculate/approximate it?</a><a href="/questions/how-do-i-pandas-group-by-to-get-sum-1657387908708">How do I Pandas group-by to get sum?</a><a href="/questions/xmlhttprequest-cannot-load-xxx-no-&#x27;access-control-allow-origin&#x27;-header-1657384758362">XMLHttpRequest cannot load XXX No &#x27;Access-Control-Allow-Origin&#x27; header</a><a href="/questions/javascript-infamous-loop-issue-duplicate-1657387498530">Javascript infamous Loop issue? [duplicate]</a><a href="/questions/is-floating-point-math-broken-1657384238910">Is floating point math broken?</a></div></div><span class="cursor-pointer text-lg p-2" style="position:fixed;bottom:20px;left:20px;background:#000;z-index:2000;color:white">Go go top</span></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"data":{"answer":["\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;There are actually \u0026lt;em\u0026gt;many good reasons\u0026lt;/em\u0026gt; to consider using accessors\u0026lt;/strong\u0026gt; rather than directly exposing fields of a class - beyond just the argument of encapsulation and making future changes easier. \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;em\u0026gt;Here are the some of the reasons I am aware of:\u0026lt;/em\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;Encapsulation of behavior associated with getting or setting the property - this allows additional functionality (like validation) to be added more easily later.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Hiding the internal representation of the property while exposing a property using an alternative representation.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Insulating your public interface from change - allowing the public interface to remain constant while the implementation changes without affecting existing consumers.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Controlling the lifetime and memory management (disposal) semantics of the property - particularly important in non-managed memory environments (like C++ or Objective-C).\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Providing a debugging interception point for when a property changes at runtime - debugging when and where a property changed to a particular value can be quite difficult without this in some languages.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Improved interoperability with libraries that are designed to operate against property getter/setters - Mocking, Serialization, and WPF come to mind.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Allowing inheritors to change the semantics of how the property behaves and is exposed by overriding the getter/setter methods.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Allowing the getter/setter to be passed around as lambda expressions rather than values.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Getters and setters can allow different access levels - for example the get may be public, but the set could be protected.\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Because 2 weeks (months, years) from now when you realize that your setter needs to do \u0026lt;strong\u0026gt;more\u0026lt;/strong\u0026gt; than just set the value, you\u0026apos;ll also realize that the property has been used directly in 238 other classes :-)\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;A public field is not worse than a getter/setter pair that does nothing except returning the field and assigning to it. First, it\u0026apos;s clear that (in most languages) there is no functional difference. Any difference must be in other factors, like maintainability or readability.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;An oft-mentioned advantage of getter/setter pairs, isn\u0026apos;t. There\u0026apos;s this claim that you can change the implementation and your clients don\u0026apos;t have to be recompiled. Supposedly, setters let you add functionality like validation later on and your clients don\u0026apos;t even need to know about it. However, adding validation to a setter is a change to its preconditions, \u0026lt;strong\u0026gt;a violation of the previous contract\u0026lt;/strong\u0026gt;, which was, quite simply, \u0026quot;you can put anything in here, and you can get that same thing later from the getter\u0026quot;.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;So, now that you broke the contract, changing every file in the codebase is something you should want to do, not avoid. If you avoid it you\u0026apos;re making the assumption that all the code assumed the contract for those methods was different.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;If that should not have been the contract, then the interface was allowing clients to put the object in invalid states. \u0026lt;em\u0026gt;That\u0026apos;s the exact opposite of encapsulation\u0026lt;/em\u0026gt; If that field could not really be set to anything from the start, why wasn\u0026apos;t the validation there from the start?\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;This same argument applies to other supposed advantages of these pass-through getter/setter pairs: if you later decide to change the value being set, you\u0026apos;re breaking the contract. If you override the default functionality in a derived class, in a way beyond a few harmless modifications (like logging or other non-observable behaviour), you\u0026apos;re breaking the contract of the base class. That is a violation of the Liskov Substitutability Principle, which is seen as one of the tenets of OO.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;If a class has these dumb getters and setters for every field, then it is a class that has no invariants whatsoever, \u0026lt;em\u0026gt;no contract\u0026lt;/em\u0026gt;. Is that really object-oriented design? If all the class has is those getters and setters, it\u0026apos;s just a dumb data holder, and dumb data holders should look like dumb data holders:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Foo\u0026lt;/span\u0026gt; {\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt;:\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; DaysLeft;\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; ContestantNumber;\n};\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Adding pass-through getter/setter pairs to such a class adds no value. Other classes should provide meaningful operations, not just operations that fields already provide. That\u0026apos;s how you can define and maintain useful invariants.\u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Client\u0026lt;/strong\u0026gt;: \u0026quot;What can I do with an object of this class?\u0026quot;\u0026lt;br\u0026gt;\n  \u0026lt;strong\u0026gt;Designer\u0026lt;/strong\u0026gt;: \u0026quot;You can read and write several variables.\u0026quot;\u0026lt;br\u0026gt;\n  \u0026lt;strong\u0026gt;Client\u0026lt;/strong\u0026gt;: \u0026quot;Oh... cool, I guess?\u0026quot;\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;p\u0026gt;There are reasons to use getters and setters, but if those reasons don\u0026apos;t exist, making getter/setter pairs in the name of false encapsulation gods is not a good thing. Valid reasons to make getters or setters include the things often mentioned as the potential changes you can make later, like validation or different internal representations. Or maybe the value should be readable by clients but not writable (for example, reading the size of a dictionary), so a simple getter is a nice choice. But those reasons should be there when you make the choice, and not just as a potential thing you may want later. This is an instance of YAGNI (\u0026lt;em\u0026gt;You Ain\u0026apos;t Gonna Need It\u0026lt;/em\u0026gt;).\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Lots of people talk about the advantages of getters and setters but I want to play devil\u0026apos;s advocate. Right now I\u0026apos;m debugging a very large program where the programmers decided to make everything getters and setters. That might seem nice, but its a reverse-engineering nightmare.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Say you\u0026apos;re looking through hundreds of lines of code and you come across this:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-java s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-java\u0026quot;\u0026gt;person.name = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Joe\u0026quot;\u0026lt;/span\u0026gt;;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;It\u0026apos;s a beautifully simply piece of code until you realize its a setter. Now, you follow that setter and find that it also sets person.firstName, person.lastName, person.isHuman, person.hasReallyCommonFirstName, and calls person.update(), which sends a query out to the database, etc. Oh, that\u0026apos;s where your memory leak was occurring.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Understanding a local piece of code at first glance is an important property of good readability that getters and setters tend to break. That is why I try to avoid them when I can, and minimize what they do when I use them.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;In a pure object-oriented world getters and setters is a \u0026lt;strong\u0026gt;terrible anti-pattern\u0026lt;/strong\u0026gt;. Read this article: \u0026lt;a href=\u0026quot;http://www.yegor256.com/2014/09/16/getters-and-setters-are-evil.html\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;Getters/Setters. Evil. Period\u0026lt;/a\u0026gt;. In a nutshell, they encourage programmers to think about objects as of data structures, and this type of thinking is pure procedural (like in COBOL or C). In an object-oriented language there are no data structures, but only objects that expose behavior (not attributes/properties!)\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;You may find more about them in Section 3.5 of \u0026lt;a href=\u0026quot;https://www.yegor256.com/elegant-objects.html\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;Elegant Objects\u0026lt;/a\u0026gt; (my book about object-oriented programming).\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;There are many reasons. My favorite one is when you need to change the behavior or regulate what you can set on a variable. For instance, lets say you had a setSpeed(int speed) method. But you want that you can only set a maximum speed of 100. You would do something like:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-java s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-java\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;setSpeed\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; speed)\u0026lt;/span\u0026gt; {\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; ( speed \u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;100\u0026lt;/span\u0026gt; ) {\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;this\u0026lt;/span\u0026gt;.speed = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;100\u0026lt;/span\u0026gt;;\n  } \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;else\u0026lt;/span\u0026gt; {\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;this\u0026lt;/span\u0026gt;.speed = speed;\n  }\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Now what if EVERYWHERE in your code you were using the public field and then you realized you need the above requirement? Have fun hunting down every usage of the public field instead of just modifying your setter.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;My 2 cents :)\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;One advantage of accessors and mutators is that you can perform validation.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;For example, if \u0026lt;code\u0026gt;foo\u0026lt;/code\u0026gt; was public, I could easily set it to \u0026lt;code\u0026gt;null\u0026lt;/code\u0026gt; and then someone else could try to call a method on the object. But it\u0026apos;s not there anymore! With a \u0026lt;code\u0026gt;setFoo\u0026lt;/code\u0026gt; method, I could ensure that \u0026lt;code\u0026gt;foo\u0026lt;/code\u0026gt; was never set to \u0026lt;code\u0026gt;null\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Accessors and mutators also allow for encapsulation - if you aren\u0026apos;t supposed to see the value once its set (perhaps it\u0026apos;s set in the constructor and then used by methods, but never supposed to be changed), it will never been seen by anyone. But if you can allow other classes to see or change it, you can provide the proper accessor and/or mutator.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Depends on your language.  You\u0026apos;ve tagged this \u0026quot;object-oriented\u0026quot; rather than \u0026quot;Java\u0026quot;, so I\u0026apos;d like to point out that ChssPly76\u0026apos;s answer is language-dependent.  In Python, for instance, there is no reason to use getters and setters.  If you need to change the behavior, you can use a property, which wraps a getter and setter around basic attribute access.  Something like this:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-py s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-python\u0026quot;\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Simple\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-title class_ inherited__\u0026quot;\u0026gt;object\u0026lt;/span\u0026gt;):\n   \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;def\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;_get_value\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;self\u0026lt;/span\u0026gt;):\n       \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; self._value -\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;\n\n   \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;def\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;_set_value\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;self, new_value\u0026lt;/span\u0026gt;):\n       self._value = new_value + \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;\n\n   \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;def\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;_del_value\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;self\u0026lt;/span\u0026gt;):\n       self.old_values.append(self._value)\n       \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;del\u0026lt;/span\u0026gt; self._value\n\n   value = \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;property\u0026lt;/span\u0026gt;(_get_value, _set_value, _del_value)\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Thanks, that really clarified my thinking. Now here is (almost) 10 (almost) good reasons NOT to use getters and setters:\u0026lt;/p\u0026gt;\n\n\u0026lt;ol\u0026gt;\n\u0026lt;li\u0026gt;When you realize you need to do more than just set and get the value, you can just make the field private, which will instantly tell you where you\u0026apos;ve directly accessed it.\u0026lt;br\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Any validation you perform in there can only be context free, which validation rarely is in practice.\u0026lt;br\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;You can change the value being set - this is an absolute nightmare when the caller passes you a value that they [shock horror] want you to store AS IS.\u0026lt;br\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;You can hide the internal representation - fantastic, so you\u0026apos;re making sure that all these operations are symmetrical right?\u0026lt;br\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;You\u0026apos;ve insulated your public interface from changes under the sheets - if you were designing an interface and weren\u0026apos;t sure whether direct access to something was OK, then you should have kept designing.\u0026lt;br\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Some libraries expect this, but not many - reflection, serialization, mock objects all work just fine with public fields.\u0026lt;br\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Inheriting this class, you can override default functionality - in other words you can REALLY confuse callers by not only hiding the implementation but making it inconsistent.\u0026lt;br\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;/ol\u0026gt;\n\n\u0026lt;p\u0026gt;The last three I\u0026apos;m just leaving (N/A or D/C)...\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Well i just want to add that even if sometimes they are necessary for the encapsulation and security of your variables/objects, if we want to code a real Object Oriented Program, then we need to \u0026lt;strong\u0026gt;\u0026lt;a href=\u0026quot;http://www.javaworld.com/javaworld/jw-09-2003/jw-0905-toolbox.html?page=1\u0026quot;\u0026gt;STOP OVERUSING THE ACCESSORS\u0026lt;/a\u0026gt;\u0026lt;/strong\u0026gt;, cause sometimes we depend a lot on them when is not really necessary and that makes almost the same as if we put the variables public.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;EDIT: I answered this question because there are a bunch of people learning programming asking this, and most of the answers are very technically competent, but they\u0026apos;re not as easy to understand if you\u0026apos;re a newbie. We were all newbies, so I thought I\u0026apos;d try my hand at a more newbie friendly answer.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;The two main ones are polymorphism, and validation. Even if it\u0026apos;s just a stupid data structure.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Let\u0026apos;s say we have this simple class:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-java s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-java\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Bottle\u0026lt;/span\u0026gt; {\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; amountOfWaterMl;\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; capacityMl;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;A very simple class that holds how much liquid is in it, and what its capacity is (in milliliters).\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;What happens when I do:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-java s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-java\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;Bottle\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;bot\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Bottle\u0026lt;/span\u0026gt;();\nbot.amountOfWaterMl = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1500\u0026lt;/span\u0026gt;;\nbot.capacityMl = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1000\u0026lt;/span\u0026gt;;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Well, you wouldn\u0026apos;t expect that to work, right?\nYou want there to be some kind of sanity check. And worse, what if I never specified the maximum capacity? Oh dear, we have a problem.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;But there\u0026apos;s another problem too. What if bottles were just one type of container? What if we had several containers, all with capacities and amounts of liquid filled? If we could just make an interface, we could let the rest of our program accept that interface, and bottles, jerrycans and all sorts of stuff would just work interchangably. Wouldn\u0026apos;t that be better? Since interfaces demand methods, this is also a good thing.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;We\u0026apos;d end up with something like:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-java s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-java\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;interface\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;LiquidContainer\u0026lt;/span\u0026gt; {\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;getAmountMl\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt;;\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;setAmountMl\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; amountMl)\u0026lt;/span\u0026gt;;\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;getCapacityMl\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt;;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Great! And now we just change Bottle to this:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-java s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-java\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Bottle\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;extends\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;LiquidContainer\u0026lt;/span\u0026gt; {\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;private\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; capacityMl;\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;private\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; amountFilledMl;\n\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;Bottle\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; capacityMl, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; amountFilledMl)\u0026lt;/span\u0026gt; {\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;this\u0026lt;/span\u0026gt;.capacityMl = capacityMl;\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;this\u0026lt;/span\u0026gt;.amountFilledMl = amountFilledMl;\n    checkNotOverFlow();\n  }\n\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;getAmountMl\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt; {\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; amountFilledMl;\n  }\n\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;setAmountMl\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; amountMl)\u0026lt;/span\u0026gt; {\n     \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;this\u0026lt;/span\u0026gt;.amountFilled = amountMl;\n     checkNotOverFlow();\n  }\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;getCapacityMl\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt; {\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; capacityMl;\n  }\n\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;private\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;checkNotOverFlow\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt; {\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt;(amountOfWaterMl \u0026amp;gt; capacityMl) {\n      \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;throw\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;BottleOverflowException\u0026lt;/span\u0026gt;();\n    }\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;I\u0026apos;ll leave the definition of the BottleOverflowException as an exercise to the reader.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Now notice how much more robust this is. We can deal with any type of container in our code now by accepting LiquidContainer instead of Bottle. And how these bottles deal with this sort of stuff can all differ. You can have bottles that write their state to disk when it changes, or bottles that save on SQL databases or GNU knows what else.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;And all these can have different ways to handle various whoopsies. The Bottle just checks and if it\u0026apos;s overflowing it throws a RuntimeException. But that might be the wrong thing to do. \n(There is a useful discussion to be had about error handling, but I\u0026apos;m keeping it very simple here on purpose. People in comments will likely point out the flaws of this simplistic approach. ;) )\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;And yes, it seems like we go from a very simple idea to getting much better answers quickly.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Please note also that you can\u0026apos;t change the capacity of a bottle. It\u0026apos;s now set in stone. You could do this with an int by declaring it final. But if this was a list, you could empty it, add new things to it, and so on. You can\u0026apos;t limit the access to touching the innards.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;There\u0026apos;s also the third thing that not everyone has addressed: getters and setters use method calls. That means that they look like normal methods everywhere else does. Instead of having weird specific syntax for DTOs and stuff, you have the same thing everywhere.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;I know it\u0026apos;s a bit late, but I think there are some people who are interested in performance.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;I\u0026apos;ve done a little performance test. I wrote a class \u0026quot;NumberHolder\u0026quot; which, well, holds an Integer. You can either read that Integer by using the getter method\n\u0026lt;code\u0026gt;anInstance.getNumber()\u0026lt;/code\u0026gt; or by directly accessing the number by using \u0026lt;code\u0026gt;anInstance.number\u0026lt;/code\u0026gt;. My programm reads the number 1,000,000,000 times, via both ways. That process is repeated five times and the time is printed. I\u0026apos;ve got the following result:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-java s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-java\u0026quot;\u0026gt;Time \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;: 953ms, Time \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;: 741ms\nTime \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;: 655ms, Time \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;: 743ms\nTime \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;: 656ms, Time \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;: 634ms\nTime \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;: 637ms, Time \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;: 629ms\nTime \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;: 633ms, Time \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;: 625ms\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;(Time 1 is the direct way, Time 2 is the getter)\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;You see, the getter is (almost) always a bit faster. Then I tried with different numbers of cycles. Instead of 1 million, I used 10 million and 0.1 million.\nThe results:\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;10 million cycles: \u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-java s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-java\u0026quot;\u0026gt;Time \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;: 6382ms, Time \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;: 6351ms\nTime \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;: 6363ms, Time \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;: 6351ms\nTime \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;: 6350ms, Time \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;: 6363ms\nTime \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;: 6353ms, Time \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;: 6357ms\nTime \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;: 6348ms, Time \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;: 6354ms\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;With 10 million cycles, the times are almost the same.\nHere are 100 thousand (0.1 million) cycles:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-java s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-java\u0026quot;\u0026gt;Time \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;: 77ms, Time \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;: 73ms\nTime \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;: 94ms, Time \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;: 65ms\nTime \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;: 67ms, Time \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;: 63ms\nTime \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;: 65ms, Time \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;: 65ms\nTime \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;: 66ms, Time \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;: 63ms\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Also with different amounts of cycles, the getter is a little bit faster than the regular way. I hope this helped you.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;h2\u0026gt;We use getters and setters:\u0026lt;/h2\u0026gt;\n\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;for reusability\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;to perform validation in later stages of programming\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\n\u0026lt;p\u0026gt;Getter and setter methods are public interfaces to access private class members.\u0026lt;/p\u0026gt;\n\n\u0026lt;hr\u0026gt;\n\n\u0026lt;h2\u0026gt;Encapsulation mantra\u0026lt;/h2\u0026gt;\n\n\u0026lt;p\u0026gt;The encapsulation mantra is to make fields private and methods public.\u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Getter Methods:\u0026lt;/strong\u0026gt; \u0026lt;em\u0026gt;We can get access to private variables.\u0026lt;/em\u0026gt;\u0026lt;/p\u0026gt;\n  \n  \u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Setter Methods:\u0026lt;/strong\u0026gt; \u0026lt;em\u0026gt;We can modify private fields.\u0026lt;/em\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;p\u0026gt;Even though the getter and setter methods do not add new functionality, we can change our mind come back later to make that method\u0026lt;/p\u0026gt;\n\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;better;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;safer; and\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;faster.\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\n\u0026lt;hr\u0026gt;\n\n\u0026lt;p\u0026gt;Anywhere a value can be used, a method that returns that value can be added. Instead of:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-java s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-java\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;x\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1000\u0026lt;/span\u0026gt; - \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;500\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;use\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-java s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-java\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;x\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1000\u0026lt;/span\u0026gt; - class_name.getValue();\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;hr\u0026gt;\n\n\u0026lt;h2\u0026gt;In layman\u0026apos;s terms\u0026lt;/h2\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;img src=\u0026quot;https://i.stack.imgur.com/2lgj0.png\u0026quot; alt=\u0026quot;Representation of \u0026amp;quot;Person\u0026amp;quot; class\u0026quot;\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Suppose we need to store the details of this \u0026lt;code\u0026gt;Person\u0026lt;/code\u0026gt;. This \u0026lt;code\u0026gt;Person\u0026lt;/code\u0026gt; has the fields \u0026lt;code\u0026gt;name\u0026lt;/code\u0026gt;, \u0026lt;code\u0026gt;age\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;sex\u0026lt;/code\u0026gt;. Doing this involves creating methods for \u0026lt;code\u0026gt;name\u0026lt;/code\u0026gt;, \u0026lt;code\u0026gt;age\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;sex\u0026lt;/code\u0026gt;. Now if we need create another person, it becomes necessary to create the methods for \u0026lt;code\u0026gt;name\u0026lt;/code\u0026gt;, \u0026lt;code\u0026gt;age\u0026lt;/code\u0026gt;, \u0026lt;code\u0026gt;sex\u0026lt;/code\u0026gt; all over again.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Instead of doing this, we can create a bean \u0026lt;code\u0026gt;class(Person)\u0026lt;/code\u0026gt; with getter and setter methods.  So tomorrow we can just create objects of this Bean \u0026lt;code\u0026gt;class(Person class)\u0026lt;/code\u0026gt; whenever we need to add a new person (see the figure). Thus we are reusing the fields and methods of bean class, which is much better.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;I spent quite a while thinking this over for the Java case, and I believe the real reasons are:\u0026lt;/p\u0026gt;\n\n\u0026lt;ol\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;strong\u0026gt;Code to the interface, not the implementation\u0026lt;/strong\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;strong\u0026gt;Interfaces only specify methods, not fields\u0026lt;/strong\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;/ol\u0026gt;\n\n\u0026lt;p\u0026gt;In other words, the only way you can specify a field in an interface is by providing a method for writing a new value and a method for reading the current value.  \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Those methods are the infamous getter and setter....\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Don\u0026apos;t use getters setters unless needed for your current delivery I.e. Don\u0026apos;t think too much about what would happen in the future, if any thing to be changed its a change request in most of the production applications, systems.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Think simple, easy, add complexity when needed.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;I would not take advantage of ignorance of business owners of deep technical know how just because I think it\u0026apos;s correct or I like the approach.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;I have massive system written without getters setters only with access modifiers and some methods to validate n perform biz logic. If you absolutely needed the. Use anything.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;It can be useful for lazy-loading.  Say the object in question is stored in a database, and you don\u0026apos;t want to go get it unless you need it.  If the object is retrieved by a getter, then the internal object can be null until somebody asks for it, then you can go get it on the first call to the getter.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;I had a base page class in a project that was handed to me that was loading some data from a couple different web service calls, but the data in those web service calls wasn\u0026apos;t always used in all child pages.  Web services, for all of the benefits, pioneer new definitions of \u0026quot;slow\u0026quot;, so you don\u0026apos;t want to make a web service call if you don\u0026apos;t have to.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;I moved from public fields to getters, and now the getters check the cache, and if it\u0026apos;s not there call the web service.  So with a little wrapping, a lot of web service calls were prevented.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;So the getter saves me from trying to figure out, on each child page, what I will need.  If I need it, I call the getter, and it goes to find it for me if I don\u0026apos;t already have it.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-java s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-java\u0026quot;\u0026gt;    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;protected\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;YourType\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;_yourName\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;null\u0026lt;/span\u0026gt;;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; YourType YourName{\n      get\n      {\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (_yourName == \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;null\u0026lt;/span\u0026gt;)\n        {\n          _yourName = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;YourType\u0026lt;/span\u0026gt;();\n          \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; _yourName;\n        }\n      }\n    }\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;One aspect I missed in the answers so far, the access specification:\u0026lt;/p\u0026gt;\n\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;for members you have only one access specification for both setting and getting\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;for setters and getters you can fine tune it and define it separately\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n    ","\n\u0026lt;p\u0026gt;In languages which don\u0026apos;t support \u0026quot;properties\u0026quot; (C++, Java) or require recompilation of clients when changing fields to properties (C#), using get/set methods is easier to modify. For example, adding validation logic to a setFoo method will not require changing the public interface of a class.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;In languages which support \u0026quot;real\u0026quot; properties (Python, Ruby, maybe Smalltalk?) there is no point to get/set methods.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;One of the basic principals of OO design: \u0026lt;strong\u0026gt;Encapsulation!\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;It gives you many benefits, one of which being that you can change the implementation of the getter/setter behind the scenes but any consumer of that value will continue to work as long as the data type remains the same.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;You should use getters and setters when:\u0026lt;/p\u0026gt;\n\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;You\u0026apos;re dealing with something that is conceptually an attribute, but:\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;Your language doesn\u0026apos;t have properties (or some similar mechanism, like Tcl\u0026apos;s variable traces), or\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Your language\u0026apos;s property support isn\u0026apos;t sufficient for this use case, or\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Your language\u0026apos;s (or sometimes your framework\u0026apos;s) idiomatic conventions encourage getters or setters for this use case.\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\n\u0026lt;p\u0026gt;So this is very rarely a general OO question; it\u0026apos;s a language-specific question, with different answers for different languages (and different use cases).\u0026lt;/p\u0026gt;\n\n\u0026lt;hr\u0026gt;\n\n\u0026lt;p\u0026gt;From an OO theory point of view, getters and setters are useless. The interface of your class is what it does, not what its state is. (If not, you\u0026apos;ve written the wrong class.) In very simple cases, where what a class does is just, e.g., represent a point in rectangular coordinates,* the attributes are part of the interface; getters and setters just cloud that. But in anything but very simple cases, neither the attributes nor getters and setters are part of the interface.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Put another way: If you believe that consumers of your class shouldn\u0026apos;t even know that you have a \u0026lt;code\u0026gt;spam\u0026lt;/code\u0026gt; attribute, much less be able to change it willy-nilly, then giving them a \u0026lt;code\u0026gt;set_spam\u0026lt;/code\u0026gt; method is the last thing you want to do.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;sub\u0026gt;* Even for that simple class, you may not necessarily want to allow setting the \u0026lt;code\u0026gt;x\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;y\u0026lt;/code\u0026gt; values. If this is really a class, shouldn\u0026apos;t it have methods like \u0026lt;code\u0026gt;translate\u0026lt;/code\u0026gt;, \u0026lt;code\u0026gt;rotate\u0026lt;/code\u0026gt;, etc.? If it\u0026apos;s only a class because your language doesn\u0026apos;t have records/structs/named tuples, then this isn\u0026apos;t really a question of OO\u0026lt;/sub\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;hr\u0026gt;\n\n\u0026lt;p\u0026gt;But nobody is ever doing general OO design. They\u0026apos;re doing design, and implementation, in a specific language. And in some languages, getters and setters are far from useless.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;If your language doesn\u0026apos;t have properties, then the only way to represent something that\u0026apos;s conceptually an attribute, but is actually computed, or validated, etc., is through getters and setters.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Even if your language does have properties, there may be cases where they\u0026apos;re insufficient or inappropriate. For example, if you want to allow subclasses to control the semantics of an attribute, in languages without dynamic access, a subclass can\u0026apos;t substitute a computed property for an attribute.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;As for the \u0026quot;what if I want to change my implementation later?\u0026quot; question (which is repeated multiple times in different wording in both the OP\u0026apos;s question and the accepted answer): If it really is a pure implementation change, and you started with an attribute, you can change it to a property without affecting the interface. Unless, of course, your language doesn\u0026apos;t support that. So this is really just the same case again.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Also, it\u0026apos;s important to follow the idioms of the language (or framework) you\u0026apos;re using. If you write beautiful Ruby-style code in C#, any experienced C# developer other than you is going to have trouble reading it, and that\u0026apos;s bad. Some languages have stronger cultures around their conventions than others.and it may not be a coincidence that Java and Python, which are on opposite ends of the spectrum for how idiomatic getters are, happen to have two of the strongest cultures.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Beyond human readers, there will be libraries and tools that expect you to follow the conventions, and make your life harder if you don\u0026apos;t. Hooking Interface Builder widgets to anything but ObjC properties, or using certain Java mocking libraries without getters, is just making your life more difficult. If the tools are important to you, don\u0026apos;t fight them.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;From a object orientation design standpoint both alternatives can be damaging to the maintenance of the code by weakening the encapsulation of the classes. For a discussion you can look into this excellent article: \u0026lt;a href=\u0026quot;http://typicalprogrammer.com/?p=23\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;http://typicalprogrammer.com/?p=23\u0026lt;/a\u0026gt; \u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Code \u0026lt;em\u0026gt;evolves\u0026lt;/em\u0026gt;.  \u0026lt;code\u0026gt;private\u0026lt;/code\u0026gt; is great for when \u0026lt;em\u0026gt;you need data member protection\u0026lt;/em\u0026gt;.  Eventually all classes should be sort of \u0026quot;miniprograms\u0026quot; that have a well-defined interface \u0026lt;em\u0026gt;that you can\u0026apos;t just screw with the internals of\u0026lt;/em\u0026gt;.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;That said, \u0026lt;em\u0026gt;software development\u0026lt;/em\u0026gt; isn\u0026apos;t about setting down that final version of the class as if you\u0026apos;re pressing some cast iron statue on the first try.  While you\u0026apos;re working with it, code is more like clay.  \u0026lt;strong\u0026gt;It evolves\u0026lt;/strong\u0026gt; as you develop it and learn more about the problem domain you are solving.  During development classes may interact with each other than they should (dependency you plan to factor out), merge together, or split apart.  So I think the debate boils down to people not wanting to religiously write\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-java s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-java\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;getVar\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt; const { \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; ; }\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;So you have:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-java s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-java\u0026quot;\u0026gt;doSomething( obj-\u0026amp;gt;getVar() ) ;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Instead of\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-java s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-java\u0026quot;\u0026gt;doSomething( obj-\u0026amp;gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; ) ;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Not only is \u0026lt;code\u0026gt;getVar()\u0026lt;/code\u0026gt; visually noisy, it gives this illusion that \u0026lt;code\u0026gt;gettingVar()\u0026lt;/code\u0026gt; is somehow a more complex process than it really is.  How you (as the class writer) regard the sanctity of \u0026lt;code\u0026gt;var\u0026lt;/code\u0026gt; is particularly confusing to a user of your class if it has a passthru setter -- then it looks like you\u0026apos;re putting up these gates to \u0026quot;protect\u0026quot; something you insist is valuable, (the sanctity of \u0026lt;code\u0026gt;var\u0026lt;/code\u0026gt;) but yet even you concede \u0026lt;code\u0026gt;var\u0026lt;/code\u0026gt;\u0026apos;s protection isn\u0026apos;t worth much by the ability for anyone to just come in and \u0026lt;code\u0026gt;set\u0026lt;/code\u0026gt; \u0026lt;code\u0026gt;var\u0026lt;/code\u0026gt; to whatever value they want, without you even peeking at what they are doing.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;So I program as follows (assuming an \u0026quot;agile\u0026quot; type approach -- ie when I write code not knowing \u0026lt;em\u0026gt;exactly\u0026lt;/em\u0026gt; what it will be doing/don\u0026apos;t have time or experience to plan an elaborate waterfall style interface set):\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;1) Start with all public members for basic objects with data and behavior.  This is why in all my C++ \u0026quot;example\u0026quot; code you\u0026apos;ll notice me using \u0026lt;code\u0026gt;struct\u0026lt;/code\u0026gt; instead of \u0026lt;code\u0026gt;class\u0026lt;/code\u0026gt; everywhere.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;2) When an object\u0026apos;s internal behavior for a data member becomes complex enough, (for example, it likes to keep an internal \u0026lt;code\u0026gt;std::list\u0026lt;/code\u0026gt; in some kind of order), accessor type functions are written.  Because I\u0026apos;m programming by myself, I don\u0026apos;t always set the member \u0026lt;code\u0026gt;private\u0026lt;/code\u0026gt; right away, but somewhere down the evolution of the class the member will be \u0026quot;promoted\u0026quot; to either \u0026lt;code\u0026gt;protected\u0026lt;/code\u0026gt; or \u0026lt;code\u0026gt;private\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;3) Classes that are fully fleshed out and have strict rules about their internals (ie \u0026lt;em\u0026gt;they\u0026lt;/em\u0026gt; know exactly what they are doing, and you are not to \u0026quot;fuck\u0026quot; (technical term) with its internals) are given the \u0026lt;code\u0026gt;class\u0026lt;/code\u0026gt; designation, default private members, and only a select few members are allowed to be \u0026lt;code\u0026gt;public\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;I find this approach allows me to avoid sitting there and religiously writing getter/setters when a lot of data members get migrated out, shifted around, etc. during the early stages of a class\u0026apos;s evolution.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;There is a good reason to consider using accessors is there is no property inheritance. See next example:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-java s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-java\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;TestPropertyOverride\u0026lt;/span\u0026gt; {\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;static\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;A\u0026lt;/span\u0026gt; {\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;i\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;;\n\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;add\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt; {\n            i++;\n        }\n\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;getI\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt; {\n            \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; i;\n        }\n    }\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;static\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;B\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;extends\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;A\u0026lt;/span\u0026gt; {\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;i\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;;\n\n        \u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;@Override\u0026lt;/span\u0026gt;\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;add\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt; {\n            i = i + \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;;\n        }\n\n        \u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;@Override\u0026lt;/span\u0026gt;\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;getI\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt; {\n            \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; i;\n        }\n    }\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;static\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;main\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(String[] args)\u0026lt;/span\u0026gt; {\n        \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;A\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;a\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;B\u0026lt;/span\u0026gt;();\n        System.out.println(a.i);\n        a.add();\n        System.out.println(a.i);\n        System.out.println(a.getI());\n    }\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Output:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-java s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-java\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;4\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Getters\u0026lt;/strong\u0026gt; and \u0026lt;strong\u0026gt;setters\u0026lt;/strong\u0026gt; are used to implement two of the fundamental aspects of Object Oriented Programming which are: \u0026lt;/p\u0026gt;\n\n\u0026lt;ol\u0026gt;\n\u0026lt;li\u0026gt;Abstraction\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Encapsulation\u0026lt;/li\u0026gt;\n\u0026lt;/ol\u0026gt;\n\n\u0026lt;p\u0026gt;Suppose we have an Employee class:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-java s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-java\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;package\u0026lt;/span\u0026gt; com.highmark.productConfig.types;\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Employee\u0026lt;/span\u0026gt; {\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;private\u0026lt;/span\u0026gt; String firstName;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;private\u0026lt;/span\u0026gt; String middleName;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;private\u0026lt;/span\u0026gt; String lastName;\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; String \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;getFirstName\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt; {\n      \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; firstName;\n    }\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;setFirstName\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(String firstName)\u0026lt;/span\u0026gt; {\n       \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;this\u0026lt;/span\u0026gt;.firstName = firstName;\n    }\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; String \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;getMiddleName\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt; {\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; middleName;\n    }\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;setMiddleName\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(String middleName)\u0026lt;/span\u0026gt; {\n         \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;this\u0026lt;/span\u0026gt;.middleName = middleName;\n    }\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; String \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;getLastName\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt; {\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; lastName;\n    }\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;setLastName\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(String lastName)\u0026lt;/span\u0026gt; {\n        \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;this\u0026lt;/span\u0026gt;.lastName = lastName;\n    }\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; String \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;getFullName\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt;{\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;this\u0026lt;/span\u0026gt;.getFirstName() + \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;this\u0026lt;/span\u0026gt;.getMiddleName() +  \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;this\u0026lt;/span\u0026gt;.getLastName();\n    }\n }\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Here the implementation details of Full Name is hidden from the user and is not accessible directly to the user, unlike a public attribute.   \u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;If you don\u0026apos;t require any validations and not even need to maintain state i.e. one property depends on another so we need to maintain the state when one is change. You can keep it simple by making field public and not using getter and setters.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;I think OOPs complicates things as the program grows it becomes nightmare for developer to scale.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;A simple example; we generate c++ headers from xml. The header contains simple field which does not require any validations. But still as in OOPS accessor  are fashion we generates them  as following.\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-java s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-java\u0026quot;\u0026gt;const Filed\u0026amp;amp; getfield() const\nField\u0026amp;amp; getField() \n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;setfield\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(const Field\u0026amp;amp; field)\u0026lt;/span\u0026gt;{...} \n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;which is very verbose and is not required. a simple\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-java s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-java\u0026quot;\u0026gt;struct \n{\n   Field field;\n};\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;is enough and readable.\nFunctional programming don\u0026apos;t have the concept of data hiding they even don\u0026apos;t require it as they do not mutate the data.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Getter and setter methods are accessor methods, meaning that they are generally a public interface to change private class members. You use getter and setter methods to define a property. You access getter and setter methods as properties outside the class, even though you define them within the class as methods. Those properties outside the class can have a different name from the property name in the class.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;There are some advantages to using getter and setter methods, such as the ability to let you create members with sophisticated functionality that you can access like properties. They also let you create read-only and write-only properties.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Even though getter and setter methods are useful, you should be careful not to overuse them because, among other issues, they can make code maintenance more difficult in certain situations. Also, they provide access to your class implementation, like public members. OOP practice discourages direct access to properties within a class.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;When you write classes, you are always encouraged to make as many as possible of your instance variables private and add getter and setter methods accordingly. This is because there are several times when you may not want to let users change certain variables within your classes. For example, if you have a private static method that tracks the number of instances created for a specific class, you don\u0026apos;t want a user to modify that counter using code. Only the constructor statement should increment that variable whenever it\u0026apos;s called. In this situation, you might create a private instance variable and allow a getter method only for the counter variable, which means users are able to retrieve the current value only by using the getter method, and they won\u0026apos;t be able to set new values using the setter method. Creating a getter without a setter is a simple way of making certain variables in your class read-only.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;There is a difference between DataStructure and Object.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Datastructure should expose its innards and not behavior.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;An Object should not expose its innards but it should expose its behavior, which is also known as the Law of Demeter\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Mostly DTOs are considered more of a datastructure and not Object. They should only expose their data and not behavior. Having Setter/Getter in DataStructure will expose behavior instead of data inside it. This further increases the chance of violation of \u0026lt;strong\u0026gt;Law of Demeter\u0026lt;/strong\u0026gt;.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Uncle Bob in his book Clean code explained the Law of Demeter.\u0026lt;/p\u0026gt;\n\u0026lt;blockquote\u0026gt;\n\u0026lt;p\u0026gt;There is a well-known heuristic called the Law of Demeter that says a\nmodule should not know about the innards of the objects it\nmanipulates. As we saw in the last section, objects hide their data\nand expose operations. This means that an object should not expose its\ninternal structure through accessors because to do so is to expose,\nrather than to hide, its internal structure.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;More precisely, the Law of Demeter says that a method f of a class C\nshould only call the methods of these:\u0026lt;/p\u0026gt;\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;C\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;An object created by f\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;An object passed as an argument to f\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;An object held in an instance variable of C\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;p\u0026gt;The method should not invoke methods on objects that are returned by any of the allowed functions.\nIn other words, talk to friends, not to strangers.\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\u0026lt;p\u0026gt;So according this, example of LoD violation is:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-java s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-java\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;final\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;String\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;outputDir\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; ctxt.getOptions().getScratchDir().getAbsolutePath();\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;Here, the function should call the method of its immediate friend which is ctxt here, It should not call the method of its immediate friend\u0026apos;s friend. but this rule doesn\u0026apos;t apply to data structure. so here if ctxt, option, scratchDir are  datastructure then why to wrap their internal data with some behavior and doing a violation of LoD.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Instead, we can do something like this.\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-java s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-java\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;final\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;String\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;outputDir\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; ctxt.options.scratchDir.absolutePath;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;This fulfills our needs and doesn\u0026apos;t even violate LoD.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Inspired by Clean Code by Robert C. Martin(Uncle Bob)\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Additionally, this is to \u0026quot;future-proof\u0026quot; your class. In particular, changing from a field to a property is an ABI break, so if you do later decide that you need more logic than just \u0026quot;set/get the field\u0026quot;, then you need to break ABI, which of course creates problems for anything else already compiled against your class.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;One other use (in languages that support properties) is that setters and getters can imply that an operation is non-trivial.  Typically, you want to avoid doing anything that\u0026apos;s computationally expensive in a property.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;One relatively modern advantage of getters/setters is that is makes it easier to browse code in tagged (indexed) code editors. E.g. If you want to see who sets a member, you can open the call hierarchy of the setter.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;On the other hand, if the member is public, the tools don\u0026apos;t make it possible to filter read/write access to the member. So you have to trudge though all uses of the member.\u0026lt;/p\u0026gt;\n    "],"id":229,"title":"Why use getters and setters/accessors?","content":"\n                \n\u0026lt;p\u0026gt;What\u0026apos;s the advantage of using getters and setters - that only get and set - instead of simply using public fields for those variables?\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;If getters and setters are ever doing more than just the simple get/set, I can figure this one out very quickly, but I\u0026apos;m not 100% clear on how:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-java s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-java\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; String foo;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;is any worse than:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-java s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-java\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;private\u0026lt;/span\u0026gt; String foo;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;setFoo\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(String foo)\u0026lt;/span\u0026gt; { \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;this\u0026lt;/span\u0026gt;.foo = foo; }\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; String \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;getFoo\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt; { \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; foo; }\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Whereas the former takes a lot less boilerplate code.\u0026lt;/p\u0026gt;\n    ","slug":"why-use-getters-and-settersaccessors-1657387343971","postType":"QUESTION","createdAt":"2022-07-09T17:22:23.000Z","updatedAt":"2022-07-09T17:22:23.000Z","tags":[{"id":1547,"name":"setter","slug":"setter","createdAt":"2022-07-09T17:22:24.000Z","updatedAt":"2022-07-09T17:22:24.000Z","Questions_Tags":{"questionId":229,"tagId":1547}},{"id":1548,"name":"getter","slug":"getter","createdAt":"2022-07-09T17:22:24.000Z","updatedAt":"2022-07-09T17:22:24.000Z","Questions_Tags":{"questionId":229,"tagId":1548}},{"id":1549,"name":"abstraction","slug":"abstraction","createdAt":"2022-07-09T17:22:24.000Z","updatedAt":"2022-07-09T17:22:24.000Z","Questions_Tags":{"questionId":229,"tagId":1549}}],"relatedQuestions":[{"title":"Why use getters and setters/accessors?","slug":"why-use-getters-and-settersaccessors-1657387343971","tags":[{"name":"setter","Questions_Tags":{"questionId":229,"tagId":1547}},{"name":"getter","Questions_Tags":{"questionId":229,"tagId":1548}},{"name":"abstraction","Questions_Tags":{"questionId":229,"tagId":1549}}]}]},"randomQuestions":[{"title":"The definitive guide to form-based website authentication [closed]","slug":"the-definitive-guide-to-form-based-website-authentication-closed-1657388456475"},{"title":"MySQL Error 1093 - Can't specify target table for update in FROM clause","slug":"mysql-error-1093-can't-specify-target-table-for-update-in-from-clause-1657388078961"},{"title":"How do I split a delimited string so I can access individual items?","slug":"how-do-i-split-a-delimited-string-so-i-can-access-individual-items-1657388042385"},{"title":"List of lists changes reflected across sublists unexpectedly","slug":"list-of-lists-changes-reflected-across-sublists-unexpectedly-1657384393720"},{"title":"What is a lambda expression in C++11?","slug":"what-is-a-lambda-expression-in-c++11-1657387999252"},{"title":"How can I validate an email address using a regular expression?","slug":"how-can-i-validate-an-email-address-using-a-regular-expression-1657384549233"},{"title":"Safely turning a JSON string into an object","slug":"safely-turning-a-json-string-into-an-object-1657388194824"},{"title":"Dynamically select data frame columns using $ and a character value","slug":"dynamically-select-data-frame-columns-using-dollar-and-a-character-value-1657387836662"},{"title":"Why should there be spaces around '[' and ']' in Bash?","slug":"why-should-there-be-spaces-around-''-and-''-in-bash-1657387984122"},{"title":"What is the difference between __str__ and __repr__?","slug":"what-is-the-difference-between-__str__-and-__repr__-1657387738760"},{"title":"What is the strict aliasing rule?","slug":"what-is-the-strict-aliasing-rule-1657384742852"},{"title":"Efficiently convert rows to columns in sql server","slug":"efficiently-convert-rows-to-columns-in-sql-server-1657387919213"},{"title":"Is there any way to kill a Thread?","slug":"is-there-any-way-to-kill-a-thread-1657387859831"},{"title":"How do JavaScript closures work?","slug":"how-do-javascript-closures-work-1657384418555"},{"title":"The 3 different equals","slug":"the-3-different-equals-1657385490242"},{"title":"Big O, how do you calculate/approximate it?","slug":"big-o-how-do-you-calculateapproximate-it-1657387856392"},{"title":"How do I Pandas group-by to get sum?","slug":"how-do-i-pandas-group-by-to-get-sum-1657387908708"},{"title":"XMLHttpRequest cannot load XXX No 'Access-Control-Allow-Origin' header","slug":"xmlhttprequest-cannot-load-xxx-no-'access-control-allow-origin'-header-1657384758362"},{"title":"Javascript infamous Loop issue? [duplicate]","slug":"javascript-infamous-loop-issue-duplicate-1657387498530"},{"title":"Is floating point math broken?","slug":"is-floating-point-math-broken-1657384238910"}]},"__N_SSG":true},"page":"/questions/[slug]","query":{"slug":"why-use-getters-and-settersaccessors-1657387343971"},"buildId":"TQ2eYlCSdocSK-hq6gkM0","isFallback":false,"gsp":true,"locale":"en","locales":["en"],"defaultLocale":"en","scriptLoader":[]}</script></body></html>