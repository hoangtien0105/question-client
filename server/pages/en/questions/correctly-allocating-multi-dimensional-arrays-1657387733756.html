<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><meta name="twitter:card" content="summary_large_image"/><meta name="twitter:site" content="@solutionschecker.com"/><meta name="twitter:creator" content="@solutionschecker.com"/><meta property="og:url" content="https://solutionschecker.com"/><meta property="og:type" content="website"/><meta property="og:image" content="https://solutionschecker.com/solutions-checker-banner.png"/><meta property="og:image:alt" content="Find the solution to any question. We focus on finding the fastest possible solution for users. Main topics like coding, learning. - solutionschecker.com"/><link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png"/><link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png"/><link rel="manifest" href="/site.webmanifest"/><script type="application/ld+json">{"@context":"https://schema.org","@type":"Organization","logo":"/logo.svg","url":"https://solutionschecker.com"}</script><link name="keywords" content="dynamic-arrays,dynamic-allocation,solutions checker, solution checker, how to, solution for, check for solution, resolve question, what is, what solution for, find solution"/><script type="application/ld+json">{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"item":{"@id":"https://solutionschecker.com","name":"Home"}},{"@type":"ListItem","position":2,"item":{"@id":"https://solutionschecker.com/questions","name":"Questions"}},{"@type":"ListItem","position":3,"item":{"@id":"https://solutionschecker.com/questions/correctly-allocating-multi-dimensional-arrays-1657387733756","name":"Questions"}}]}</script><title>Correctly allocating multi-dimensional arrays | Solution Checker</title><meta name="robots" content="index,follow"/><meta name="description" content="The intent of this question is to provide a reference about how to correctly allocate multi-dimensional arrays dynamically in C. This is a topic often misunderstood and poorly explained even in some C programming books. Therefore even seasoned C programmers struggle to get it right. 



I have been taught from my programming teacher/book/tutorial that the correct way to dynamically allocate a multi-dimensional array is by using pointer-to-pointers. 

However, several high rep users on SO now tell me that this is wrong and bad practice. They say that pointer-to-pointers are not arrays, that I am not actually allocating arrays and that my code is needlessly slow. 

This is how I was taught to allocate multi-dimensional arrays:

#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;assert.h&gt;

int** arr_alloc (size_t x, size_t y)
{
  int** pp = malloc(sizeof(*pp) * x);
  assert(pp != NULL);
  for(size_t i=0; i&lt;x; i++)
  {
    pp[i] = malloc(sizeof(**pp) * y);
    assert(pp[i] != NULL);
  }

  return pp;
}

int** arr_fill (int** pp, size_t x, size_t y)
{
  for(size_t i=0; i&lt;x; i++)
  {
    for(size_t j=0; j&lt;y; j++)
    {
      pp[i][j] = (int)j + 1;
    }
  }

  return pp;
}

void arr_print (int** pp, size_t x, size_t y)
{
  for(size_t i=0; i&lt;x; i++)
  {
    for(size_t j=0; j&lt;y; j++)
    {
      printf(&quot;%d &quot;, pp[i][j]);
    }
    printf(&quot;\n&quot;);
  }
}

void arr_free (int** pp, size_t x, size_t y)
{
  (void) y;

  for(size_t i=0; i&lt;x; i++)
  {
    free(pp[i]);
    pp[i] = NULL;
  }
  free(pp);
  pp = NULL;
}


int main (void)
{
  size_t x = 2;
  size_t y = 3;
  int** pp;

  pp = arr_alloc(x, y);
  pp = arr_fill(pp, x, y);
  arr_print(pp, x, y);
  arr_free(pp, x, y);

  return 0;
}


Output

1 2 3
1 2 3


This code works just fine! How could it be wrong?
    "/><meta property="og:title" content="Correctly allocating multi-dimensional arrays | Solution Checker"/><meta property="og:description" content="The intent of this question is to provide a reference about how to correctly allocate multi-dimensional arrays dynamically in C. This is a topic often misunderstood and poorly explained even in some C programming books. Therefore even seasoned C programmers struggle to get it right. 



I have been taught from my programming teacher/book/tutorial that the correct way to dynamically allocate a multi-dimensional array is by using pointer-to-pointers. 

However, several high rep users on SO now tell me that this is wrong and bad practice. They say that pointer-to-pointers are not arrays, that I am not actually allocating arrays and that my code is needlessly slow. 

This is how I was taught to allocate multi-dimensional arrays:

#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;assert.h&gt;

int** arr_alloc (size_t x, size_t y)
{
  int** pp = malloc(sizeof(*pp) * x);
  assert(pp != NULL);
  for(size_t i=0; i&lt;x; i++)
  {
    pp[i] = malloc(sizeof(**pp) * y);
    assert(pp[i] != NULL);
  }

  return pp;
}

int** arr_fill (int** pp, size_t x, size_t y)
{
  for(size_t i=0; i&lt;x; i++)
  {
    for(size_t j=0; j&lt;y; j++)
    {
      pp[i][j] = (int)j + 1;
    }
  }

  return pp;
}

void arr_print (int** pp, size_t x, size_t y)
{
  for(size_t i=0; i&lt;x; i++)
  {
    for(size_t j=0; j&lt;y; j++)
    {
      printf(&quot;%d &quot;, pp[i][j]);
    }
    printf(&quot;\n&quot;);
  }
}

void arr_free (int** pp, size_t x, size_t y)
{
  (void) y;

  for(size_t i=0; i&lt;x; i++)
  {
    free(pp[i]);
    pp[i] = NULL;
  }
  free(pp);
  pp = NULL;
}


int main (void)
{
  size_t x = 2;
  size_t y = 3;
  int** pp;

  pp = arr_alloc(x, y);
  pp = arr_fill(pp, x, y);
  arr_print(pp, x, y);
  arr_free(pp, x, y);

  return 0;
}


Output

1 2 3
1 2 3


This code works just fine! How could it be wrong?
    "/><script type="application/ld+json">{"@context":"https://schema.org","@type":"QAPage","mainEntity":{"name":"Correctly allocating multi-dimensional arrays","text":"The intent of this question is to provide a reference about how to correctly allocate multi-dimensional arrays dynamically in C. This is a topic often misunderstood and poorly explained even in some C programming books. Therefore even seasoned C programmers struggle to get it right. \n\n\n\nI have been taught from my programming teacher/book/tutorial that the correct way to dynamically allocate a multi-dimensional array is by using pointer-to-pointers. \n\nHowever, several high rep users on SO now tell me that this is wrong and bad practice. They say that pointer-to-pointers are not arrays, that I am not actually allocating arrays and that my code is needlessly slow. \n\nThis is how I was taught to allocate multi-dimensional arrays:\n\n#include &lt;stdlib.h&gt;\n#include &lt;stdio.h&gt;\n#include &lt;assert.h&gt;\n\nint** arr_alloc (size_t x, size_t y)\n{\n  int** pp = malloc(sizeof(*pp) * x);\n  assert(pp != NULL);\n  for(size_t i=0; i&lt;x; i++)\n  {\n    pp[i] = malloc(sizeof(**pp) * y);\n    assert(pp[i] != NULL);\n  }\n\n  return pp;\n}\n\nint** arr_fill (int** pp, size_t x, size_t y)\n{\n  for(size_t i=0; i&lt;x; i++)\n  {\n    for(size_t j=0; j&lt;y; j++)\n    {\n      pp[i][j] = (int)j + 1;\n    }\n  }\n\n  return pp;\n}\n\nvoid arr_print (int** pp, size_t x, size_t y)\n{\n  for(size_t i=0; i&lt;x; i++)\n  {\n    for(size_t j=0; j&lt;y; j++)\n    {\n      printf(&quot;%d &quot;, pp[i][j]);\n    }\n    printf(&quot;\\n&quot;);\n  }\n}\n\nvoid arr_free (int** pp, size_t x, size_t y)\n{\n  (void) y;\n\n  for(size_t i=0; i&lt;x; i++)\n  {\n    free(pp[i]);\n    pp[i] = NULL;\n  }\n  free(pp);\n  pp = NULL;\n}\n\n\nint main (void)\n{\n  size_t x = 2;\n  size_t y = 3;\n  int** pp;\n\n  pp = arr_alloc(x, y);\n  pp = arr_fill(pp, x, y);\n  arr_print(pp, x, y);\n  arr_free(pp, x, y);\n\n  return 0;\n}\n\n\nOutput\n\n1 2 3\n1 2 3\n\n\nThis code works just fine! How could it be wrong?\n    ","answerCount":2,"upVoteCount":500,"suggestedAnswer":[{"text":"In order to answer the question, we should first clear up some concepts. What is an array and how can it be used? And what is the code in the question, if not an array?\n\n\n\nWhat is an array?\n\nThe formal definition of an array is found in the C standard, ISO 9899:2011 6.2.5/20 Types.\n\n\n  An array type describes a contiguously allocated non-empty set of\n  objects with a particular member object type, called the element type.\n\n\nIn plain English, an array is a collection of items of the same type allocated contiguously, in adjacent memory cells. \n\nFor example an array of 3 integers int arr[3] = {1,2,3}; would be allocated in memory like this:\n\n+-------+-------+-------+\n|       |       |       |\n|   1   |   2   |   3   |\n|       |       |       |\n+-------+-------+-------+\n\n\nSo what about the formal definition of a multi-dimensional array? Actually, it is the very same definition as cited above. It applies recursively. \n\nIf we would allocate a 2D array, int arr[2][3] = { {1,2,3}, {1,2,3} }; it would get allocated in memory like this:\n\n+-------+-------+-------+-------+-------+-------+\n|       |       |       |       |       |       |\n|   1   |   2   |   3   |   1   |   2   |   3   |\n|       |       |       |       |       |       |\n+-------+-------+-------+-------+-------+-------+\n\n\nWhat we have in this example is actually an array of arrays. An array which has 2 items, each of them an array of 3 integers. \n\n\n\nAn array is a type like any other\n\nArrays in C often follow the same type system as regular variables. As shown above, you can have an array of arrays, like you can have an array of any other type. \n\nYou can also apply the same kind of pointer arithmetic on n-dimensional arrays as on plain one-dimensional arrays. With a regular one-dimensional arrays, applying pointer arithmetic should be trivial:\n\nint arr[3] = {1,2,3};\nint* ptr = arr; // integer pointer to the first element.\n\nfor(size_t i=0; i&lt;3; i++)\n{\n  printf(&quot;%d &quot;, *ptr); // print contents.\n  ptr++; // set pointer to point at the next element.\n}\n\n\nThis was made possible through &quot;array decay&quot;. When arr was used inside an expression, it &quot;decayed&quot; into a pointer to the first element.\n\nSimilarly, we can use the very same kind of pointer arithmetic to iterate through an array of arrays, by using an array pointer:\n\nint arr[2][3] = { {1,2,3}, {1,2,3} };\nint (*ptr)[3] = arr; // int array pointer to the first element, which is an int[3] array.\n\nfor(size_t i=0; i&lt;2; i++)\n{\n  printf(&quot;%d %d %d\\n&quot;, (*ptr)[0], (*ptr)[1], (*ptr)[2]); // print contents\n  ptr++; // set pointer to point at the next element\n}\n\n\nAgain there was array decay. The variable arr which was of type int [2][3] decayed into a pointer to the first element. The first element was an int [3] and a pointer to such an element is declared as int(*)[3] - an array pointer.\n\nUnderstanding array pointers and array decay is necessary in order to work with multi-dimensional arrays.\n\n\n\nThere are more cases where arrays behave just like regular variables. The sizeof operator works just the same for (non-VLA) arrays as for regular variables. Examples for a 32 bit system:\n\nint x; printf(&quot;%zu&quot;, sizeof(x)); prints 4.\nint arr[3] = {1,2,3}; printf(&quot;%zu&quot;, sizeof(arr)); prints 12 (3*4=12)\nint arr[2][3] = { {1,2,3}, {1,2,3} }; printf(&quot;%zu&quot;, sizeof(arr)); prints 24 (2*3*4=24)\n\n\n\nLike any other type, arrays can be used with library functions and generic APIs. Since arrays fulfil the requirement of being allocated contiguously, we can for example safely copy them with memcpy:\n\nint arr_a[3] = {1,2,3};\nint arr_b[3];\nmemcpy(arr_b, arr_a, sizeof(arr_a));\n\n\nContiguous allocation is also the reason why other similar standard library functions like memset, strcpy, bsearch and qsort work. They are designed to work on arrays allocated contiguously. So if you have a multi-dimensional array, you can efficiently search it and sort it with bsearch and qsort, saving you the fuss of implementing binary search and quick sort yourself and thereby re-inventing the wheel for every project.\n\nAll of the above consistencies between arrays and other types is a very good thing that we want to take advantage of, particularly when doing generic programming.\n\n\n\nWhat is the pointer-to-pointer thing, if not an array?\n\nNow to get back to the code in the question, which used a different syntax with a pointer-to-pointer. There is nothing mysterious about it. It is a pointer to pointer to type, no more no less. It is not an array. It is not a 2D array. Strictly speaking, it cannot be used to point at an array, nor can it be used to point at a 2D array.\n\nA pointer-to-pointer can however be used to point at the first element of an array of pointers, instead of pointing at the array as whole. And that is how it is used in the question - as a way to &quot;emulate&quot; an array pointer. In the question, it is used to point at an array of 2 pointers. And then each of the 2 pointers is used to point at an array of 3 integers.\n\nThis is known as a look-up table, which is a kind of abstract data type (ADT), which is something different from the lower level concept of plain arrays. The main difference is how the look-up table is allocated:\n\n+------------+\n|            |\n| 0x12340000 |\n|            |\n+------------+\n      |\n      |\n      v\n+------------+     +-------+-------+-------+\n|            |     |       |       |       |\n| 0x22223333 |----&gt;|   1   |   2   |   3   |\n|            |     |       |       |       |\n+------------+     +-------+-------+-------+\n|            | \n| 0xAAAABBBB |--+\n|            |  | \n+------------+  |  \n                |\n                |  +-------+-------+-------+\n                |  |       |       |       |\n                +-&gt;|   1   |   2   |   3   |\n                   |       |       |       |\n                   +-------+-------+-------+\n\n\nThe 32 bit addresses in this example are made-up. The 0x12340000 box represents the pointer-to-pointer. It contains an address 0x12340000 to the first item in an array of pointers. Each pointer in that array in turn, contains an address pointing at the first item in an array of integers. \n\nAnd here is where the problems start.\n\n\n\nProblems with the look-up table version\n\nThe look-up table is scattered all over the heap memory. It is not contiguously allocated memory in adjacent cells, because each call to malloc() gives a new memory area, not necessarily located adjacently to the others. This in turn gives us lots of problems:\n\n\nWe can&apos;t use pointer arithmetic as expected. While we can use a form of pointer arithmetic to index and access the items in the look-up table, we can&apos;t do so using array pointers.\nWe can&apos;t use the sizeof operator. Used on the pointer-to-pointer, it would give us the size of a pointer-to-pointer. Used to the first item pointed at, it would give us the size of a pointer. Neither of them is the size of an array.\nWe can&apos;t use standard library functions that excepts an array type (memcpy, memset, strcpy, bsearch, qsort and so on). All such functions assume to get arrays as input, with data allocated contiguously. Calling them with our look-up table as parameter would result in undefined behavior bugs, such as program crashes.\nRepeated calls of malloc to allocate several segments leads to heap fragmentation, which in turn results in poor use of RAM memory.\nSince the memory is scattered, the CPU cannot utilize cache memory when iterating through the look-up table. Efficient use of the data cache requires a contiguous chunk of memory which is iterated through from top to bottom. This means that the look-up table, by design, has significantly slower access time than a real multi-dimensional array. \nFor each call to malloc(), the library code managing the heap has to calculate where there is free space. Similarly for each call to free(), there is overhead code which has to be executed. Therefore, as few calls to these functions as possible is often preferable, for the sake of performance.\n\n\n\n\nAre look-up tables all bad?\n\nAs we can see, there are a lot of problems with pointer-based look-up tables. But they aren&apos;t all bad, it is a tool like any other. It just has to be used for the right purpose. If you are looking for a multi-dimensional array, which should be used as an array, look-up tables are clearly the wrong tool. But they can be used for other purposes.\n\nA look-up table is the right choice when you need all dimensions to have completely variable sizes, individually. Such a container can be handy when for example creating a list of C strings. It is then often justified to take the above mentioned execution speed performance loss in order to save memory.\n\nAlso, the look-up table has the advantage that you can re-alloce parts of the table in run-time without the need to re-allocate a whole multi-dimensional array. If this is something that needs to be done frequently, the look-up table might even outperform the multi-dimensional array in terms of execution speed. For example, similar look-up tables can be used when implementing a chained hash table.\n\n\n\nHow to properly allocate a multi-dimensional array dynamically then?\n\nThe easiest form in modern C is to simply use a variable-length array (VLA). int array[x][y]; where x and y are variables given values in run-time, prior array declaration. However, VLAs have local scope and do not persist throughout the duration of the program - they have automatic storage duration. So while VLAs may be convenient and fast to use for temporary arrays, it is not an universal replacement to the look-up table in the question.\n\nTo truly allocate a multi-dimensional array dynamically, so that it gets allocated storage duration, we have to use malloc()/calloc()/realloc(). I&apos;ll give   one example below.\n\nIn modern C, you would use array pointers to a VLA. You can use such pointers even when no actual VLA is present in the program. The benefit of using them over a plain type* or a void* is increased type-safety. Using a pointer to a VLA also allows you to pass the array dimensions as parameters to the function using the array, making it both variable and type safe at once.\n\nUnfortunately, in order to use the benefits of having a pointer to VLA, we can&apos;t return that pointer as a function result. So if we need to return a pointer to the array to the caller, it must be passed as a parameter (for the reasons described in Dynamic memory access only works inside function). This is fine practice in C, but makes the code a bit hard to read. It would look something like this:\n\nvoid arr_alloc (size_t x, size_t y, int(**aptr)[x][y])\n{\n  *aptr = malloc( sizeof(int[x][y]) ); // allocate a true 2D array\n  assert(*aptr != NULL);\n}\n\n\nWhile this syntax with a pointer to an array pointer might look a bit strange and intimidating, it doesn&apos;t get more complex than this even if we add more dimensions:\n\nvoid arr_alloc (size_t x, size_t y, size_t z, int(**aptr)[x][y][z])\n{\n  *aptr = malloc( sizeof(int[x][y][z]) ); // allocate a true 3D array\n  assert(*aptr != NULL);\n}\n\n\nNow compare that code with the code for adding one more dimension to the look-up table version:\n\n/* Bad. Don&apos;t write code like this! */\nint*** arr_alloc (size_t x, size_t y, size_t z)\n{\n  int*** ppp = malloc(sizeof(*ppp) * x);\n  assert(ppp != NULL);\n  for(size_t i=0; i&lt;x; i++)\n  {\n    ppp[i] = malloc(sizeof(**ppp) * y);\n    assert(ppp[i] != NULL);\n    for(size_t j=0; j&lt;y; j++)\n    {\n      ppp[i][j] = malloc(sizeof(***ppp) * z);\n      assert(ppp[i][j] != NULL);\n    }\n  }\n\n  return ppp;\n}\n\n\nNow that is one unreadble mess of &quot;three-star programming&quot;. And lets not even consider 4 dimensions...\n\n\n\nThe full code of a version using true 2D arrays\n\n#include &lt;stdlib.h&gt;\n#include &lt;stdio.h&gt;\n#include &lt;assert.h&gt;\n\nvoid arr_alloc (size_t x, size_t y, int(**aptr)[x][y])\n{\n  *aptr = malloc( sizeof(int[x][y]) ); // allocate a true 2D array\n  assert(*aptr != NULL);\n}\n\nvoid arr_fill (size_t x, size_t y, int array[x][y])\n{\n  for(size_t i=0; i&lt;x; i++)\n  {\n    for(size_t j=0; j&lt;y; j++)\n    {\n      array[i][j] = (int)j + 1;\n    }\n  }\n}\n\nvoid arr_print (size_t x, size_t y, int array[x][y])\n{\n  for(size_t i=0; i&lt;x; i++)\n  {\n    for(size_t j=0; j&lt;y; j++)\n    {\n      printf(&quot;%d &quot;, array[i][j]);\n    }\n    printf(&quot;\\n&quot;);\n  }\n}\n\nint main (void)\n{\n  size_t x = 2;\n  size_t y = 3;\n  int (*aptr)[x][y];\n\n  arr_alloc(x, y, &amp;aptr);\n  arr_fill(x, y, *aptr);\n  arr_print(x, y, *aptr);\n  free(aptr); // free the whole 2D array\n\n  return 0;\n}\n\n    ","url":"/questions/[slug]#solution1","@type":"Answer","upvoteCount":0},{"text":"C doesn&apos;t have multidimensional arrays (as a primitive data type). But you could have arrays of arrays (or of other aggregates) and arrays of pointers.\n\nA possible approach is to reason with some abstract data type (perhaps using flexible array members, which is one implementation trick, and you could use other approaches) like in this answer.\n\nWe can&apos;t suggest any abstract data type, because that depends on the text of your homework, which we don&apos;t have. You need to design your abstract data type (on a piece of paper), and later to implement it.\n\nOnce you have listed (on a paper or on a board) all the operations needed on your ADT, implementing them is straightforward.\n\n\n  This code works just fine! How could it be wrong?\n\n\nThat sentence is inconsistent (wrong w.r.t. what specifications?) ...\n\nI recommend to compile with all warnings and debug info (e.g. with gcc -Wall -Wextra -g with GCC), to improve your code till you get no warnings, to use the debugger gdb (to understand what is happening in your program) and other tools like valgrind.\n    ","url":"/questions/[slug]#solution2","@type":"Answer","upvoteCount":0}],"@type":"Question"}}</script><meta name="next-head-count" content="22"/><link rel="preload" href="/_next/static/css/4f7b2847abfe82c6.css" as="style"/><link rel="stylesheet" href="/_next/static/css/4f7b2847abfe82c6.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-0d1b80a048d4787e.js"></script><script src="/_next/static/chunks/webpack-42cdea76c8170223.js" defer=""></script><script src="/_next/static/chunks/framework-4556c45dd113b893.js" defer=""></script><script src="/_next/static/chunks/main-ccfab947c79712f4.js" defer=""></script><script src="/_next/static/chunks/pages/_app-c0d2dcb5e85faf18.js" defer=""></script><script src="/_next/static/chunks/294-106ef8570fa99deb.js" defer=""></script><script src="/_next/static/chunks/490-7f0418bb4354ac73.js" defer=""></script><script src="/_next/static/chunks/pages/questions/%5Bslug%5D-50e201fdaa1e0fd1.js" defer=""></script><script src="/_next/static/eGqQHYKGZKE-nXShFn8wX/_buildManifest.js" defer=""></script><script src="/_next/static/eGqQHYKGZKE-nXShFn8wX/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="wrapper"><header><nav class="bg-white border-gray-200 px-4 lg:px-6 py-2.5 dark:bg-gray-800"><div class="flex flex-wrap justify-between items-center mx-auto max-w-screen-xl"><a class="flex items-center" href="/"><img src="/logo-second.png" class="mr-3 h-6 sm:h-9" alt="Solution Checker Logo"/><h1 class="self-center text-xl font-semibold whitespace-nowrap dark:text-white">Solution Checker</h1></a><div class="flex items-center lg:order-2"><button data-collapse-toggle="mobile-menu-2" type="button" class="inline-flex items-center p-2 ml-1 text-sm text-gray-500 rounded-lg lg:hidden hover:bg-gray-100 focus:outline-none focus:ring-2 focus:ring-gray-200 dark:text-gray-400 dark:hover:bg-gray-700 dark:focus:ring-gray-600" aria-controls="mobile-menu-2" aria-expanded="false"><span class="sr-only">Open main menu</span><svg class="w-6 h-6" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M3 5a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM3 10a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM3 15a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1z" clip-rule="evenodd"></path></svg><svg class="hidden w-6 h-6" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z" clip-rule="evenodd"></path></svg></button></div><div class="hidden justify-between items-center w-full lg:flex lg:w-auto lg:order-1" id="mobile-menu-2"><ul class="flex flex-col mt-4 font-medium lg:flex-row lg:space-x-8 lg:mt-0"><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" aria-current="page" href="/">Home</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/questions?tab=news">Questions</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/post?tab=news">Post</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/questions/correctly-allocating-multi-dimensional-arrays-1657387733756#">Coding</a></li></ul></div></div></nav></header><div class="main-content"><div class="question my-5"><div class="flex question-header items-center m-auto justify-center"><div class="rounded-xl w-full border p-5 shadow-md bg-white"><div class="flex w-full items-center justify-between border-b pb-3"><div class="flex items-center space-x-3"><div class="text-lg font-bold text-slate-700"><a href="/questions/correctly-allocating-multi-dimensional-arrays-1657387733756"><h1>Correctly allocating multi-dimensional arrays</h1></a></div></div><div class="flex flex-wrap h-auto justify-end items-center space-x-8"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold" href="/questions/tag/dynamic-arrays">dynamic-arrays</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold" href="/questions/tag/dynamic-allocation">dynamic-allocation</a></div></div><div class="question-content mt-5">
                
<p><em>The intent of this question is to provide a reference about how to correctly allocate multi-dimensional arrays dynamically in C. This is a topic often misunderstood and poorly explained even in some C programming books. Therefore even seasoned C programmers struggle to get it right.</em> </p>

<hr>

<p>I have been taught from my programming teacher/book/tutorial that the correct way to dynamically allocate a multi-dimensional array is by using pointer-to-pointers. </p>

<p>However, several high rep users on SO now tell me that this is wrong and bad practice. They say that pointer-to-pointers are not arrays, that I am not actually allocating arrays and that my code is needlessly slow. </p>

<p>This is how I was taught to allocate multi-dimensional arrays:</p>

<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;assert.h&gt;</span></span>

<span class="hljs-type">int</span>** <span class="hljs-title function_">arr_alloc</span> <span class="hljs-params">(<span class="hljs-type">size_t</span> x, <span class="hljs-type">size_t</span> y)</span>
{
  <span class="hljs-type">int</span>** pp = <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(*pp) * x);
  assert(pp != <span class="hljs-literal">NULL</span>);
  <span class="hljs-keyword">for</span>(<span class="hljs-type">size_t</span> i=<span class="hljs-number">0</span>; i&lt;x; i++)
  {
    pp[i] = <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(**pp) * y);
    assert(pp[i] != <span class="hljs-literal">NULL</span>);
  }

  <span class="hljs-keyword">return</span> pp;
}

<span class="hljs-type">int</span>** <span class="hljs-title function_">arr_fill</span> <span class="hljs-params">(<span class="hljs-type">int</span>** pp, <span class="hljs-type">size_t</span> x, <span class="hljs-type">size_t</span> y)</span>
{
  <span class="hljs-keyword">for</span>(<span class="hljs-type">size_t</span> i=<span class="hljs-number">0</span>; i&lt;x; i++)
  {
    <span class="hljs-keyword">for</span>(<span class="hljs-type">size_t</span> j=<span class="hljs-number">0</span>; j&lt;y; j++)
    {
      pp[i][j] = (<span class="hljs-type">int</span>)j + <span class="hljs-number">1</span>;
    }
  }

  <span class="hljs-keyword">return</span> pp;
}

<span class="hljs-type">void</span> <span class="hljs-title function_">arr_print</span> <span class="hljs-params">(<span class="hljs-type">int</span>** pp, <span class="hljs-type">size_t</span> x, <span class="hljs-type">size_t</span> y)</span>
{
  <span class="hljs-keyword">for</span>(<span class="hljs-type">size_t</span> i=<span class="hljs-number">0</span>; i&lt;x; i++)
  {
    <span class="hljs-keyword">for</span>(<span class="hljs-type">size_t</span> j=<span class="hljs-number">0</span>; j&lt;y; j++)
    {
      <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d "</span>, pp[i][j]);
    }
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);
  }
}

<span class="hljs-type">void</span> <span class="hljs-title function_">arr_free</span> <span class="hljs-params">(<span class="hljs-type">int</span>** pp, <span class="hljs-type">size_t</span> x, <span class="hljs-type">size_t</span> y)</span>
{
  (<span class="hljs-type">void</span>) y;

  <span class="hljs-keyword">for</span>(<span class="hljs-type">size_t</span> i=<span class="hljs-number">0</span>; i&lt;x; i++)
  {
    <span class="hljs-built_in">free</span>(pp[i]);
    pp[i] = <span class="hljs-literal">NULL</span>;
  }
  <span class="hljs-built_in">free</span>(pp);
  pp = <span class="hljs-literal">NULL</span>;
}


<span class="hljs-type">int</span> <span class="hljs-title function_">main</span> <span class="hljs-params">(<span class="hljs-type">void</span>)</span>
{
  <span class="hljs-type">size_t</span> x = <span class="hljs-number">2</span>;
  <span class="hljs-type">size_t</span> y = <span class="hljs-number">3</span>;
  <span class="hljs-type">int</span>** pp;

  pp = arr_alloc(x, y);
  pp = arr_fill(pp, x, y);
  arr_print(pp, x, y);
  arr_free(pp, x, y);

  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>

<p>Output</p>

<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span>
<span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span>
</code></pre>

<p>This code works just fine! How could it be wrong?</p>
    </div></div></div><div class="solution-section"><nav class="flex pagination-solution flex-col justify-end"><h1 class="text-lg font-semibold mb-5">Navigate to solutions: </h1><ul class="inline-flex -space-x-px overflow-auto"><li class="pagination-solution-item"><span data-id="#solution1" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">1</span></li><li class="pagination-solution-item"><span data-id="#solution2" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">2</span></li></ul></nav><div id="solution1" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 1</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/dynamic-arrays">dynamic-arrays</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/dynamic-allocation">dynamic-allocation</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>In order to answer the question, we should first clear up some concepts. What is an array and how can it be used? And what is the code in the question, if not an array?</p>

<hr>

<p><strong>What is an array?</strong></p>

<p>The formal definition of an array is found in the C standard, <em>ISO 9899:2011 6.2.5/20 Types</em>.</p>

<blockquote>
  <p>An array type describes a contiguously allocated non-empty set of
  objects with a particular member object type, called the element type.</p>
</blockquote>

<p>In plain English, an array is a collection of items of the same type allocated contiguously, in adjacent memory cells. </p>

<p>For example an array of 3 integers <code>int arr[3] = {1,2,3};</code> would be allocated in memory like this:</p>

<pre class="lang-c s-code-block"><code class="hljs language-c">+-------+-------+-------+
|       |       |       |
|   <span class="hljs-number">1</span>   |   <span class="hljs-number">2</span>   |   <span class="hljs-number">3</span>   |
|       |       |       |
+-------+-------+-------+
</code></pre>

<p>So what about the formal definition of a multi-dimensional array? Actually, it is the very same definition as cited above. It applies recursively. </p>

<p>If we would allocate a 2D array, <code>int arr[2][3] = { {1,2,3}, {1,2,3} };</code> it would get allocated in memory like this:</p>

<pre class="lang-c s-code-block"><code class="hljs language-c">+-------+-------+-------+-------+-------+-------+
|       |       |       |       |       |       |
|   <span class="hljs-number">1</span>   |   <span class="hljs-number">2</span>   |   <span class="hljs-number">3</span>   |   <span class="hljs-number">1</span>   |   <span class="hljs-number">2</span>   |   <span class="hljs-number">3</span>   |
|       |       |       |       |       |       |
+-------+-------+-------+-------+-------+-------+
</code></pre>

<p>What we have in this example is actually an array of arrays. An array which has 2 items, each of them an array of 3 integers. </p>

<hr>

<p><strong>An array is a type like any other</strong></p>

<p>Arrays in C often follow the same type system as regular variables. As shown above, you can have an array of arrays, like you can have an array of any other type. </p>

<p>You can also apply the same kind of pointer arithmetic on <em>n</em>-dimensional arrays as on plain one-dimensional arrays. With a regular one-dimensional arrays, applying pointer arithmetic should be trivial:</p>

<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-type">int</span> arr[<span class="hljs-number">3</span>] = {<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>};
<span class="hljs-type">int</span>* ptr = arr; <span class="hljs-comment">// integer pointer to the first element.</span>

<span class="hljs-keyword">for</span>(<span class="hljs-type">size_t</span> i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">3</span>; i++)
{
  <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d "</span>, *ptr); <span class="hljs-comment">// print contents.</span>
  ptr++; <span class="hljs-comment">// set pointer to point at the next element.</span>
}
</code></pre>

<p>This was made possible through "array decay". When <code>arr</code> was used inside an expression, it "decayed" into a pointer to the first element.</p>

<p>Similarly, we can use the very same kind of pointer arithmetic to iterate through an array of arrays, by using an <em>array pointer</em>:</p>

<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-type">int</span> arr[<span class="hljs-number">2</span>][<span class="hljs-number">3</span>] = { {<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>}, {<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>} };
<span class="hljs-type">int</span> (*ptr)[<span class="hljs-number">3</span>] = arr; <span class="hljs-comment">// int array pointer to the first element, which is an int[3] array.</span>

<span class="hljs-keyword">for</span>(<span class="hljs-type">size_t</span> i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">2</span>; i++)
{
  <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d %d %d\n"</span>, (*ptr)[<span class="hljs-number">0</span>], (*ptr)[<span class="hljs-number">1</span>], (*ptr)[<span class="hljs-number">2</span>]); <span class="hljs-comment">// print contents</span>
  ptr++; <span class="hljs-comment">// set pointer to point at the next element</span>
}
</code></pre>

<p>Again there was array decay. The variable <code>arr</code> which was of type <code>int [2][3]</code> decayed into a pointer to the first element. The first element was an <code>int [3]</code> and a pointer to such an element is declared as <code>int(*)[3]</code> - an array pointer.</p>

<p>Understanding array pointers and array decay is necessary in order to work with multi-dimensional arrays.</p>

<hr>

<p>There are more cases where arrays behave just like regular variables. The <code>sizeof</code> operator works just the same for (non-VLA) arrays as for regular variables. Examples for a 32 bit system:</p>

<p><code>int x; printf("%zu", sizeof(x));</code> prints <code>4</code>.<br>
<code>int arr[3] = {1,2,3}; printf("%zu", sizeof(arr));</code> prints <code>12</code> (3*4=12)<br>
<code>int arr[2][3] = { {1,2,3}, {1,2,3} }; printf("%zu", sizeof(arr));</code> prints <code>24</code> (2*3*4=24)</p>

<hr>

<p>Like any other type, arrays can be used with library functions and generic APIs. Since arrays fulfil the requirement of being allocated contiguously, we can for example safely copy them with <code>memcpy</code>:</p>

<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-type">int</span> arr_a[<span class="hljs-number">3</span>] = {<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>};
<span class="hljs-type">int</span> arr_b[<span class="hljs-number">3</span>];
<span class="hljs-built_in">memcpy</span>(arr_b, arr_a, <span class="hljs-keyword">sizeof</span>(arr_a));
</code></pre>

<p>Contiguous allocation is also the reason why other similar standard library functions like <code>memset</code>, <code>strcpy</code>, <code>bsearch</code> and <code>qsort</code> work. They are designed to work on arrays allocated contiguously. So if you have a multi-dimensional array, you can efficiently search it and sort it with <code>bsearch</code> and <code>qsort</code>, saving you the fuss of implementing binary search and quick sort yourself and thereby re-inventing the wheel for every project.</p>

<p>All of the above consistencies between arrays and other types is a very good thing that we want to take advantage of, particularly when doing generic programming.</p>

<hr>

<p><strong>What is the pointer-to-pointer thing, if not an array?</strong></p>

<p>Now to get back to the code in the question, which used a different syntax with a pointer-to-pointer. There is nothing mysterious about it. It is a pointer to pointer to type, no more no less. It is not an array. It is not a 2D array. Strictly speaking, it cannot be used to point at an array, nor can it be used to point at a 2D array.</p>

<p>A pointer-to-pointer can however be used to point at the first element of an array of pointers, instead of pointing at the array as whole. And that is how it is used in the question - as a way to "emulate" an array pointer. In the question, it is used to point at an array of 2 pointers. And then each of the 2 pointers is used to point at an array of 3 integers.</p>

<p>This is known as a look-up table, which is a kind of abstract data type (ADT), which is something different from the lower level concept of plain arrays. The main difference is how the look-up table is allocated:</p>

<pre class="lang-c s-code-block"><code class="hljs language-c">+------------+
|            |
| <span class="hljs-number">0x12340000</span> |
|            |
+------------+
      |
      |
      v
+------------+     +-------+-------+-------+
|            |     |       |       |       |
| <span class="hljs-number">0x22223333</span> |----&gt;|   <span class="hljs-number">1</span>   |   <span class="hljs-number">2</span>   |   <span class="hljs-number">3</span>   |
|            |     |       |       |       |
+------------+     +-------+-------+-------+
|            | 
| <span class="hljs-number">0xAAAABBBB</span> |--+
|            |  | 
+------------+  |  
                |
                |  +-------+-------+-------+
                |  |       |       |       |
                +-&gt;|   <span class="hljs-number">1</span>   |   <span class="hljs-number">2</span>   |   <span class="hljs-number">3</span>   |
                   |       |       |       |
                   +-------+-------+-------+
</code></pre>

<p>The 32 bit addresses in this example are made-up. The <code>0x12340000</code> box represents the pointer-to-pointer. It contains an address <code>0x12340000</code> to the first item in an array of pointers. Each pointer in that array in turn, contains an address pointing at the first item in an array of integers. </p>

<p>And here is where the problems start.</p>

<hr>

<p><strong>Problems with the look-up table version</strong></p>

<p>The look-up table is scattered all over the heap memory. It is not contiguously allocated memory in adjacent cells, because each call to <code>malloc()</code> gives a new memory area, not necessarily located adjacently to the others. This in turn gives us lots of problems:</p>

<ul>
<li><p>We can't use pointer arithmetic as expected. While we can use a form of pointer arithmetic to index and access the items in the look-up table, we can't do so using array pointers.</p></li>
<li><p>We can't use the sizeof operator. Used on the pointer-to-pointer, it would give us the size of a pointer-to-pointer. Used to the first item pointed at, it would give us the size of a pointer. Neither of them is the size of an array.</p></li>
<li><p>We can't use standard library functions that excepts an array type (<code>memcpy</code>, <code>memset</code>, <code>strcpy</code>, <code>bsearch</code>, <code>qsort</code> and so on). All such functions assume to get arrays as input, with data allocated contiguously. Calling them with our look-up table as parameter would result in undefined behavior bugs, such as program crashes.</p></li>
<li><p>Repeated calls of <code>malloc</code> to allocate several segments leads to heap <a href="https://stackoverflow.com/questions/3770457/what-is-memory-fragmentation">fragmentation</a>, which in turn results in poor use of RAM memory.</p></li>
<li><p>Since the memory is scattered, the CPU cannot utilize cache memory when iterating through the look-up table. Efficient use of the data cache requires a contiguous chunk of memory which is iterated through from top to bottom. This means that the look-up table, by design, has significantly slower access time than a real multi-dimensional array. </p></li>
<li><p>For each call to <code>malloc()</code>, the library code managing the heap has to calculate where there is free space. Similarly for each call to <code>free()</code>, there is overhead code which has to be executed. Therefore, as few calls to these functions as possible is often preferable, for the sake of performance.</p></li>
</ul>

<hr>

<p><strong>Are look-up tables all bad?</strong></p>

<p>As we can see, there are a lot of problems with pointer-based look-up tables. But they aren't all bad, it is a tool like any other. It just has to be used for the right purpose. If you are looking for a multi-dimensional array, which should be used as an array, look-up tables are clearly the wrong tool. But they can be used for other purposes.</p>

<p>A look-up table is the right choice when you need all dimensions to have completely variable sizes, individually. Such a container can be handy when for example creating a list of C strings. It is then often justified to take the above mentioned execution speed performance loss in order to save memory.</p>

<p>Also, the look-up table has the advantage that you can re-alloce parts of the table in run-time without the need to re-allocate a whole multi-dimensional array. If this is something that needs to be done frequently, the look-up table might even outperform the multi-dimensional array in terms of execution speed. For example, similar look-up tables can be used when implementing a chained hash table.</p>

<hr>

<p><strong>How to properly allocate a multi-dimensional array dynamically then?</strong></p>

<p>The easiest form in modern C is to simply use a variable-length array (VLA). <code>int array[x][y];</code> where <code>x</code> and <code>y</code> are variables given values in run-time, prior array declaration. However, VLAs have local scope and do not persist throughout the duration of the program - they have automatic storage duration. So while VLAs may be convenient and fast to use for temporary arrays, it is not an universal replacement to the look-up table in the question.</p>

<p>To truly allocate a multi-dimensional array dynamically, so that it gets <em>allocated storage duration</em>, we have to use <code>malloc()</code>/<code>calloc()</code>/<code>realloc()</code>. I'll give   one example below.</p>

<p>In modern C, you would use array pointers to a VLA. You can use such pointers even when no actual VLA is present in the program. The benefit of using them over a plain <code>type*</code> or a <code>void*</code> is increased type-safety. Using a pointer to a VLA also allows you to pass the array dimensions as parameters to the function using the array, making it both variable and type safe at once.</p>

<p>Unfortunately, in order to use the benefits of having a pointer to VLA, we can't return that pointer as a function result. So if we need to return a pointer to the array to the caller, it must be passed as a parameter (for the reasons described in <a href="https://stackoverflow.com/questions/39486797/dynamic-memory-access-only-works-inside-function">Dynamic memory access only works inside function</a>). This is fine practice in C, but makes the code a bit hard to read. It would look something like this:</p>

<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-type">void</span> <span class="hljs-title function_">arr_alloc</span> <span class="hljs-params">(<span class="hljs-type">size_t</span> x, <span class="hljs-type">size_t</span> y, <span class="hljs-type">int</span>(**aptr)[x][y])</span>
{
  *aptr = <span class="hljs-built_in">malloc</span>( <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>[x][y]) ); <span class="hljs-comment">// allocate a true 2D array</span>
  assert(*aptr != <span class="hljs-literal">NULL</span>);
}
</code></pre>

<p>While this syntax with <em>a pointer to an array pointer</em> might look a bit strange and intimidating, it doesn't get more complex than this even if we add more dimensions:</p>

<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-type">void</span> <span class="hljs-title function_">arr_alloc</span> <span class="hljs-params">(<span class="hljs-type">size_t</span> x, <span class="hljs-type">size_t</span> y, <span class="hljs-type">size_t</span> z, <span class="hljs-type">int</span>(**aptr)[x][y][z])</span>
{
  *aptr = <span class="hljs-built_in">malloc</span>( <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>[x][y][z]) ); <span class="hljs-comment">// allocate a true 3D array</span>
  assert(*aptr != <span class="hljs-literal">NULL</span>);
}
</code></pre>

<p>Now compare that code with the code for adding one more dimension to the look-up table version:</p>

<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-comment">/* Bad. Don't write code like this! */</span>
<span class="hljs-type">int</span>*** <span class="hljs-title function_">arr_alloc</span> <span class="hljs-params">(<span class="hljs-type">size_t</span> x, <span class="hljs-type">size_t</span> y, <span class="hljs-type">size_t</span> z)</span>
{
  <span class="hljs-type">int</span>*** ppp = <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(*ppp) * x);
  assert(ppp != <span class="hljs-literal">NULL</span>);
  <span class="hljs-keyword">for</span>(<span class="hljs-type">size_t</span> i=<span class="hljs-number">0</span>; i&lt;x; i++)
  {
    ppp[i] = <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(**ppp) * y);
    assert(ppp[i] != <span class="hljs-literal">NULL</span>);
    <span class="hljs-keyword">for</span>(<span class="hljs-type">size_t</span> j=<span class="hljs-number">0</span>; j&lt;y; j++)
    {
      ppp[i][j] = <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(***ppp) * z);
      assert(ppp[i][j] != <span class="hljs-literal">NULL</span>);
    }
  }

  <span class="hljs-keyword">return</span> ppp;
}
</code></pre>

<p>Now <em>that</em> is one unreadble mess of "three-star programming". And lets not even consider 4 dimensions...</p>

<hr>

<p><strong>The full code of a version using true 2D arrays</strong></p>

<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;assert.h&gt;</span></span>

<span class="hljs-type">void</span> <span class="hljs-title function_">arr_alloc</span> <span class="hljs-params">(<span class="hljs-type">size_t</span> x, <span class="hljs-type">size_t</span> y, <span class="hljs-type">int</span>(**aptr)[x][y])</span>
{
  *aptr = <span class="hljs-built_in">malloc</span>( <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>[x][y]) ); <span class="hljs-comment">// allocate a true 2D array</span>
  assert(*aptr != <span class="hljs-literal">NULL</span>);
}

<span class="hljs-type">void</span> <span class="hljs-title function_">arr_fill</span> <span class="hljs-params">(<span class="hljs-type">size_t</span> x, <span class="hljs-type">size_t</span> y, <span class="hljs-type">int</span> <span class="hljs-built_in">array</span>[x][y])</span>
{
  <span class="hljs-keyword">for</span>(<span class="hljs-type">size_t</span> i=<span class="hljs-number">0</span>; i&lt;x; i++)
  {
    <span class="hljs-keyword">for</span>(<span class="hljs-type">size_t</span> j=<span class="hljs-number">0</span>; j&lt;y; j++)
    {
      <span class="hljs-built_in">array</span>[i][j] = (<span class="hljs-type">int</span>)j + <span class="hljs-number">1</span>;
    }
  }
}

<span class="hljs-type">void</span> <span class="hljs-title function_">arr_print</span> <span class="hljs-params">(<span class="hljs-type">size_t</span> x, <span class="hljs-type">size_t</span> y, <span class="hljs-type">int</span> <span class="hljs-built_in">array</span>[x][y])</span>
{
  <span class="hljs-keyword">for</span>(<span class="hljs-type">size_t</span> i=<span class="hljs-number">0</span>; i&lt;x; i++)
  {
    <span class="hljs-keyword">for</span>(<span class="hljs-type">size_t</span> j=<span class="hljs-number">0</span>; j&lt;y; j++)
    {
      <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d "</span>, <span class="hljs-built_in">array</span>[i][j]);
    }
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);
  }
}

<span class="hljs-type">int</span> <span class="hljs-title function_">main</span> <span class="hljs-params">(<span class="hljs-type">void</span>)</span>
{
  <span class="hljs-type">size_t</span> x = <span class="hljs-number">2</span>;
  <span class="hljs-type">size_t</span> y = <span class="hljs-number">3</span>;
  <span class="hljs-type">int</span> (*aptr)[x][y];

  arr_alloc(x, y, &amp;aptr);
  arr_fill(x, y, *aptr);
  arr_print(x, y, *aptr);
  <span class="hljs-built_in">free</span>(aptr); <span class="hljs-comment">// free the whole 2D array</span>

  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>
    </div></div></div></div><div id="solution2" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 2</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/dynamic-arrays">dynamic-arrays</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/dynamic-allocation">dynamic-allocation</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p><strong>C doesn't have multidimensional arrays</strong> (as a <em>primitive</em> data type). But you could have arrays of arrays (or of other aggregates) and arrays of pointers.</p>

<p>A possible approach is to <strong>reason with some <a href="https://en.wikipedia.org/wiki/Abstract_data_type" rel="nofollow noreferrer">abstract data type</a></strong> (perhaps using <a href="https://en.wikipedia.org/wiki/Flexible_array_member" rel="nofollow noreferrer">flexible array members</a>, which is one implementation trick, and you could use other approaches) like in <a href="https://stackoverflow.com/a/47235897/841108">this answer</a>.</p>

<p>We can't suggest any abstract data type, because that depends on the text of your homework, which we don't have. You need to <strong>design your abstract data type</strong> (on a piece of paper), and later to implement it.</p>

<p>Once you have listed (on a paper or on a board) all the operations needed on your ADT, implementing them is straightforward.</p>

<blockquote>
  <p>This code works just fine! How could it be wrong?</p>
</blockquote>

<p>That sentence is inconsistent (wrong w.r.t. what specifications?) ...</p>

<p>I recommend to compile with all warnings and debug info (e.g. <a href="https://gcc.gnu.org/onlinedocs/gcc/Invoking-GCC.html" rel="nofollow noreferrer">with</a> <code>gcc -Wall -Wextra -g</code> with <a href="https://gcc.gnu.org/" rel="nofollow noreferrer">GCC</a>), to improve your code till you get no warnings, to use the debugger <code>gdb</code> (to understand what is happening in your program) and other tools like <a href="http://valgrind.org/" rel="nofollow noreferrer">valgrind</a>.</p>
    </div></div></div></div></div></div><div class="widget"><a href="/questions/what-is-the-difference-between-json-and-object-literal-notation-1657387515710">What is the difference between JSON and Object Literal Notation?</a><a href="/questions/how-to-generate-a-self-signed-ssl-certificate-using-openssl-closed-1657388298626">How to generate a self-signed SSL certificate using OpenSSL? [closed]</a><a href="/questions/the-definitive-c-book-guide-and-list-1657384747653">The Definitive C Book Guide and List</a><a href="/questions/%22thinking-in-angularjs%22-if-i-have-a-jquery-background-closed-1657384761159">&quot;Thinking in AngularJS&quot; if I have a jQuery background? [closed]</a><a href="/questions/javascript-function-doesn&#x27;t-work-when-link-is-clicked-1657387767488">javascript function doesn&#x27;t work when link is clicked</a><a href="/questions/how-do-i-use-arrays-in-c++-1657387456118">How do I use arrays in C++?</a><a href="/questions/passing-data-between-view-controllers-1657384540021">Passing data between view controllers</a><a href="/questions/why-use-getters-and-settersaccessors-1657387343971">Why use getters and setters/accessors?</a><a href="/questions/download-a-file-by-jquery.ajax-1657388220611">Download a file by jQuery.Ajax</a><a href="/questions/mysql-pivot-row-into-dynamic-number-of-columns-1657387981930">MySQL pivot row into dynamic number of columns</a><a href="/questions/how-to-use-sharedpreferences-in-android-to-store-fetch-and-edit-values-closed-1657387683057">How to use SharedPreferences in Android to store, fetch and edit values [closed]</a><a href="/questions/calling-a-function-of-a-module-by-using-its-name-(a-string)-1657388565656">Calling a function of a module by using its name (a string)</a><a href="/questions/how-to-generate-all-permutations-of-a-list-1657388537371">How to generate all permutations of a list</a><a href="/questions/where-and-why-do-i-have-to-put-the-%22template%22-and-%22typename%22-keywords-1657384467606">Where and why do I have to put the &quot;template&quot; and &quot;typename&quot; keywords?</a><a href="/questions/why-aren&#x27;t-variable-length-arrays-part-of-the-c++-standard-1657384712975">Why aren&#x27;t variable-length arrays part of the C++ standard?</a><a href="/questions/what-is-dependency-injection-1657387953056">What is dependency injection?</a><a href="/questions/arrays-linked-lists-and-other-data-structures-in-cmd.exe-(batch)-script-1657387558484">Arrays, linked lists and other data structures in cmd.exe (batch) script</a><a href="/questions/why-is-using-the-javascript-eval-function-a-bad-idea-1657387485165">Why is using the JavaScript eval function a bad idea?</a><a href="/questions/what-is-the-difference-between-a-deep-copy-and-a-shallow-copy-1657388445063">What is the difference between a deep copy and a shallow copy?</a><a href="/questions/what-is-__init__.py-for-1657388415243">What is __init__.py for?</a></div></div><span class="cursor-pointer text-lg p-2" style="position:fixed;bottom:20px;left:20px;background:#000;z-index:2000;color:white">Go go top</span></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"data":{"answer":["\n\u0026lt;p\u0026gt;In order to answer the question, we should first clear up some concepts. What is an array and how can it be used? And what is the code in the question, if not an array?\u0026lt;/p\u0026gt;\n\n\u0026lt;hr\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;What is an array?\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;The formal definition of an array is found in the C standard, \u0026lt;em\u0026gt;ISO 9899:2011 6.2.5/20 Types\u0026lt;/em\u0026gt;.\u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;An array type describes a contiguously allocated non-empty set of\n  objects with a particular member object type, called the element type.\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;p\u0026gt;In plain English, an array is a collection of items of the same type allocated contiguously, in adjacent memory cells. \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;For example an array of 3 integers \u0026lt;code\u0026gt;int arr[3] = {1,2,3};\u0026lt;/code\u0026gt; would be allocated in memory like this:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;+-------+-------+-------+\n|       |       |       |\n|   \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;   |   \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;   |   \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3\u0026lt;/span\u0026gt;   |\n|       |       |       |\n+-------+-------+-------+\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;So what about the formal definition of a multi-dimensional array? Actually, it is the very same definition as cited above. It applies recursively. \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;If we would allocate a 2D array, \u0026lt;code\u0026gt;int arr[2][3] = { {1,2,3}, {1,2,3} };\u0026lt;/code\u0026gt; it would get allocated in memory like this:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;+-------+-------+-------+-------+-------+-------+\n|       |       |       |       |       |       |\n|   \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;   |   \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;   |   \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3\u0026lt;/span\u0026gt;   |   \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;   |   \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;   |   \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3\u0026lt;/span\u0026gt;   |\n|       |       |       |       |       |       |\n+-------+-------+-------+-------+-------+-------+\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;What we have in this example is actually an array of arrays. An array which has 2 items, each of them an array of 3 integers. \u0026lt;/p\u0026gt;\n\n\u0026lt;hr\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;An array is a type like any other\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Arrays in C often follow the same type system as regular variables. As shown above, you can have an array of arrays, like you can have an array of any other type. \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;You can also apply the same kind of pointer arithmetic on \u0026lt;em\u0026gt;n\u0026lt;/em\u0026gt;-dimensional arrays as on plain one-dimensional arrays. With a regular one-dimensional arrays, applying pointer arithmetic should be trivial:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; arr[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3\u0026lt;/span\u0026gt;] = {\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;,\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;,\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3\u0026lt;/span\u0026gt;};\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;* ptr = arr; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// integer pointer to the first element.\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;size_t\u0026lt;/span\u0026gt; i=\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;; i\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3\u0026lt;/span\u0026gt;; i++)\n{\n  \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;printf\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;%d \u0026quot;\u0026lt;/span\u0026gt;, *ptr); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// print contents.\u0026lt;/span\u0026gt;\n  ptr++; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// set pointer to point at the next element.\u0026lt;/span\u0026gt;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;This was made possible through \u0026quot;array decay\u0026quot;. When \u0026lt;code\u0026gt;arr\u0026lt;/code\u0026gt; was used inside an expression, it \u0026quot;decayed\u0026quot; into a pointer to the first element.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Similarly, we can use the very same kind of pointer arithmetic to iterate through an array of arrays, by using an \u0026lt;em\u0026gt;array pointer\u0026lt;/em\u0026gt;:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; arr[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;][\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3\u0026lt;/span\u0026gt;] = { {\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;,\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;,\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3\u0026lt;/span\u0026gt;}, {\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;,\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;,\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3\u0026lt;/span\u0026gt;} };\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; (*ptr)[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3\u0026lt;/span\u0026gt;] = arr; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// int array pointer to the first element, which is an int[3] array.\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;size_t\u0026lt;/span\u0026gt; i=\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;; i\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;; i++)\n{\n  \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;printf\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;%d %d %d\\n\u0026quot;\u0026lt;/span\u0026gt;, (*ptr)[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;], (*ptr)[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;], (*ptr)[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;]); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// print contents\u0026lt;/span\u0026gt;\n  ptr++; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// set pointer to point at the next element\u0026lt;/span\u0026gt;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Again there was array decay. The variable \u0026lt;code\u0026gt;arr\u0026lt;/code\u0026gt; which was of type \u0026lt;code\u0026gt;int [2][3]\u0026lt;/code\u0026gt; decayed into a pointer to the first element. The first element was an \u0026lt;code\u0026gt;int [3]\u0026lt;/code\u0026gt; and a pointer to such an element is declared as \u0026lt;code\u0026gt;int(*)[3]\u0026lt;/code\u0026gt; - an array pointer.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Understanding array pointers and array decay is necessary in order to work with multi-dimensional arrays.\u0026lt;/p\u0026gt;\n\n\u0026lt;hr\u0026gt;\n\n\u0026lt;p\u0026gt;There are more cases where arrays behave just like regular variables. The \u0026lt;code\u0026gt;sizeof\u0026lt;/code\u0026gt; operator works just the same for (non-VLA) arrays as for regular variables. Examples for a 32 bit system:\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;code\u0026gt;int x; printf(\u0026quot;%zu\u0026quot;, sizeof(x));\u0026lt;/code\u0026gt; prints \u0026lt;code\u0026gt;4\u0026lt;/code\u0026gt;.\u0026lt;br\u0026gt;\n\u0026lt;code\u0026gt;int arr[3] = {1,2,3}; printf(\u0026quot;%zu\u0026quot;, sizeof(arr));\u0026lt;/code\u0026gt; prints \u0026lt;code\u0026gt;12\u0026lt;/code\u0026gt; (3*4=12)\u0026lt;br\u0026gt;\n\u0026lt;code\u0026gt;int arr[2][3] = { {1,2,3}, {1,2,3} }; printf(\u0026quot;%zu\u0026quot;, sizeof(arr));\u0026lt;/code\u0026gt; prints \u0026lt;code\u0026gt;24\u0026lt;/code\u0026gt; (2*3*4=24)\u0026lt;/p\u0026gt;\n\n\u0026lt;hr\u0026gt;\n\n\u0026lt;p\u0026gt;Like any other type, arrays can be used with library functions and generic APIs. Since arrays fulfil the requirement of being allocated contiguously, we can for example safely copy them with \u0026lt;code\u0026gt;memcpy\u0026lt;/code\u0026gt;:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; arr_a[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3\u0026lt;/span\u0026gt;] = {\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;,\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;,\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3\u0026lt;/span\u0026gt;};\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; arr_b[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3\u0026lt;/span\u0026gt;];\n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;memcpy\u0026lt;/span\u0026gt;(arr_b, arr_a, \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;sizeof\u0026lt;/span\u0026gt;(arr_a));\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Contiguous allocation is also the reason why other similar standard library functions like \u0026lt;code\u0026gt;memset\u0026lt;/code\u0026gt;, \u0026lt;code\u0026gt;strcpy\u0026lt;/code\u0026gt;, \u0026lt;code\u0026gt;bsearch\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;qsort\u0026lt;/code\u0026gt; work. They are designed to work on arrays allocated contiguously. So if you have a multi-dimensional array, you can efficiently search it and sort it with \u0026lt;code\u0026gt;bsearch\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;qsort\u0026lt;/code\u0026gt;, saving you the fuss of implementing binary search and quick sort yourself and thereby re-inventing the wheel for every project.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;All of the above consistencies between arrays and other types is a very good thing that we want to take advantage of, particularly when doing generic programming.\u0026lt;/p\u0026gt;\n\n\u0026lt;hr\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;What is the pointer-to-pointer thing, if not an array?\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Now to get back to the code in the question, which used a different syntax with a pointer-to-pointer. There is nothing mysterious about it. It is a pointer to pointer to type, no more no less. It is not an array. It is not a 2D array. Strictly speaking, it cannot be used to point at an array, nor can it be used to point at a 2D array.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;A pointer-to-pointer can however be used to point at the first element of an array of pointers, instead of pointing at the array as whole. And that is how it is used in the question - as a way to \u0026quot;emulate\u0026quot; an array pointer. In the question, it is used to point at an array of 2 pointers. And then each of the 2 pointers is used to point at an array of 3 integers.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;This is known as a look-up table, which is a kind of abstract data type (ADT), which is something different from the lower level concept of plain arrays. The main difference is how the look-up table is allocated:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;+------------+\n|            |\n| \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0x12340000\u0026lt;/span\u0026gt; |\n|            |\n+------------+\n      |\n      |\n      v\n+------------+     +-------+-------+-------+\n|            |     |       |       |       |\n| \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0x22223333\u0026lt;/span\u0026gt; |----\u0026amp;gt;|   \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;   |   \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;   |   \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3\u0026lt;/span\u0026gt;   |\n|            |     |       |       |       |\n+------------+     +-------+-------+-------+\n|            | \n| \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0xAAAABBBB\u0026lt;/span\u0026gt; |--+\n|            |  | \n+------------+  |  \n                |\n                |  +-------+-------+-------+\n                |  |       |       |       |\n                +-\u0026amp;gt;|   \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;   |   \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;   |   \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3\u0026lt;/span\u0026gt;   |\n                   |       |       |       |\n                   +-------+-------+-------+\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;The 32 bit addresses in this example are made-up. The \u0026lt;code\u0026gt;0x12340000\u0026lt;/code\u0026gt; box represents the pointer-to-pointer. It contains an address \u0026lt;code\u0026gt;0x12340000\u0026lt;/code\u0026gt; to the first item in an array of pointers. Each pointer in that array in turn, contains an address pointing at the first item in an array of integers. \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;And here is where the problems start.\u0026lt;/p\u0026gt;\n\n\u0026lt;hr\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Problems with the look-up table version\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;The look-up table is scattered all over the heap memory. It is not contiguously allocated memory in adjacent cells, because each call to \u0026lt;code\u0026gt;malloc()\u0026lt;/code\u0026gt; gives a new memory area, not necessarily located adjacently to the others. This in turn gives us lots of problems:\u0026lt;/p\u0026gt;\n\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;We can\u0026apos;t use pointer arithmetic as expected. While we can use a form of pointer arithmetic to index and access the items in the look-up table, we can\u0026apos;t do so using array pointers.\u0026lt;/p\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;We can\u0026apos;t use the sizeof operator. Used on the pointer-to-pointer, it would give us the size of a pointer-to-pointer. Used to the first item pointed at, it would give us the size of a pointer. Neither of them is the size of an array.\u0026lt;/p\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;We can\u0026apos;t use standard library functions that excepts an array type (\u0026lt;code\u0026gt;memcpy\u0026lt;/code\u0026gt;, \u0026lt;code\u0026gt;memset\u0026lt;/code\u0026gt;, \u0026lt;code\u0026gt;strcpy\u0026lt;/code\u0026gt;, \u0026lt;code\u0026gt;bsearch\u0026lt;/code\u0026gt;, \u0026lt;code\u0026gt;qsort\u0026lt;/code\u0026gt; and so on). All such functions assume to get arrays as input, with data allocated contiguously. Calling them with our look-up table as parameter would result in undefined behavior bugs, such as program crashes.\u0026lt;/p\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;Repeated calls of \u0026lt;code\u0026gt;malloc\u0026lt;/code\u0026gt; to allocate several segments leads to heap \u0026lt;a href=\u0026quot;https://stackoverflow.com/questions/3770457/what-is-memory-fragmentation\u0026quot;\u0026gt;fragmentation\u0026lt;/a\u0026gt;, which in turn results in poor use of RAM memory.\u0026lt;/p\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;Since the memory is scattered, the CPU cannot utilize cache memory when iterating through the look-up table. Efficient use of the data cache requires a contiguous chunk of memory which is iterated through from top to bottom. This means that the look-up table, by design, has significantly slower access time than a real multi-dimensional array. \u0026lt;/p\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;For each call to \u0026lt;code\u0026gt;malloc()\u0026lt;/code\u0026gt;, the library code managing the heap has to calculate where there is free space. Similarly for each call to \u0026lt;code\u0026gt;free()\u0026lt;/code\u0026gt;, there is overhead code which has to be executed. Therefore, as few calls to these functions as possible is often preferable, for the sake of performance.\u0026lt;/p\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\n\u0026lt;hr\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Are look-up tables all bad?\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;As we can see, there are a lot of problems with pointer-based look-up tables. But they aren\u0026apos;t all bad, it is a tool like any other. It just has to be used for the right purpose. If you are looking for a multi-dimensional array, which should be used as an array, look-up tables are clearly the wrong tool. But they can be used for other purposes.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;A look-up table is the right choice when you need all dimensions to have completely variable sizes, individually. Such a container can be handy when for example creating a list of C strings. It is then often justified to take the above mentioned execution speed performance loss in order to save memory.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Also, the look-up table has the advantage that you can re-alloce parts of the table in run-time without the need to re-allocate a whole multi-dimensional array. If this is something that needs to be done frequently, the look-up table might even outperform the multi-dimensional array in terms of execution speed. For example, similar look-up tables can be used when implementing a chained hash table.\u0026lt;/p\u0026gt;\n\n\u0026lt;hr\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;How to properly allocate a multi-dimensional array dynamically then?\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;The easiest form in modern C is to simply use a variable-length array (VLA). \u0026lt;code\u0026gt;int array[x][y];\u0026lt;/code\u0026gt; where \u0026lt;code\u0026gt;x\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;y\u0026lt;/code\u0026gt; are variables given values in run-time, prior array declaration. However, VLAs have local scope and do not persist throughout the duration of the program - they have automatic storage duration. So while VLAs may be convenient and fast to use for temporary arrays, it is not an universal replacement to the look-up table in the question.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;To truly allocate a multi-dimensional array dynamically, so that it gets \u0026lt;em\u0026gt;allocated storage duration\u0026lt;/em\u0026gt;, we have to use \u0026lt;code\u0026gt;malloc()\u0026lt;/code\u0026gt;/\u0026lt;code\u0026gt;calloc()\u0026lt;/code\u0026gt;/\u0026lt;code\u0026gt;realloc()\u0026lt;/code\u0026gt;. I\u0026apos;ll give   one example below.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;In modern C, you would use array pointers to a VLA. You can use such pointers even when no actual VLA is present in the program. The benefit of using them over a plain \u0026lt;code\u0026gt;type*\u0026lt;/code\u0026gt; or a \u0026lt;code\u0026gt;void*\u0026lt;/code\u0026gt; is increased type-safety. Using a pointer to a VLA also allows you to pass the array dimensions as parameters to the function using the array, making it both variable and type safe at once.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Unfortunately, in order to use the benefits of having a pointer to VLA, we can\u0026apos;t return that pointer as a function result. So if we need to return a pointer to the array to the caller, it must be passed as a parameter (for the reasons described in \u0026lt;a href=\u0026quot;https://stackoverflow.com/questions/39486797/dynamic-memory-access-only-works-inside-function\u0026quot;\u0026gt;Dynamic memory access only works inside function\u0026lt;/a\u0026gt;). This is fine practice in C, but makes the code a bit hard to read. It would look something like this:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;arr_alloc\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;size_t\u0026lt;/span\u0026gt; x, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;size_t\u0026lt;/span\u0026gt; y, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;(**aptr)[x][y])\u0026lt;/span\u0026gt;\n{\n  *aptr = \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;malloc\u0026lt;/span\u0026gt;( \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;sizeof\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;[x][y]) ); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// allocate a true 2D array\u0026lt;/span\u0026gt;\n  assert(*aptr != \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;NULL\u0026lt;/span\u0026gt;);\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;While this syntax with \u0026lt;em\u0026gt;a pointer to an array pointer\u0026lt;/em\u0026gt; might look a bit strange and intimidating, it doesn\u0026apos;t get more complex than this even if we add more dimensions:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;arr_alloc\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;size_t\u0026lt;/span\u0026gt; x, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;size_t\u0026lt;/span\u0026gt; y, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;size_t\u0026lt;/span\u0026gt; z, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;(**aptr)[x][y][z])\u0026lt;/span\u0026gt;\n{\n  *aptr = \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;malloc\u0026lt;/span\u0026gt;( \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;sizeof\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;[x][y][z]) ); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// allocate a true 3D array\u0026lt;/span\u0026gt;\n  assert(*aptr != \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;NULL\u0026lt;/span\u0026gt;);\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Now compare that code with the code for adding one more dimension to the look-up table version:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;/* Bad. Don\u0026apos;t write code like this! */\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;*** \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;arr_alloc\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;size_t\u0026lt;/span\u0026gt; x, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;size_t\u0026lt;/span\u0026gt; y, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;size_t\u0026lt;/span\u0026gt; z)\u0026lt;/span\u0026gt;\n{\n  \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;*** ppp = \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;malloc\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;sizeof\u0026lt;/span\u0026gt;(*ppp) * x);\n  assert(ppp != \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;NULL\u0026lt;/span\u0026gt;);\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;size_t\u0026lt;/span\u0026gt; i=\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;; i\u0026amp;lt;x; i++)\n  {\n    ppp[i] = \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;malloc\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;sizeof\u0026lt;/span\u0026gt;(**ppp) * y);\n    assert(ppp[i] != \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;NULL\u0026lt;/span\u0026gt;);\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;size_t\u0026lt;/span\u0026gt; j=\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;; j\u0026amp;lt;y; j++)\n    {\n      ppp[i][j] = \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;malloc\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;sizeof\u0026lt;/span\u0026gt;(***ppp) * z);\n      assert(ppp[i][j] != \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;NULL\u0026lt;/span\u0026gt;);\n    }\n  }\n\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; ppp;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Now \u0026lt;em\u0026gt;that\u0026lt;/em\u0026gt; is one unreadble mess of \u0026quot;three-star programming\u0026quot;. And lets not even consider 4 dimensions...\u0026lt;/p\u0026gt;\n\n\u0026lt;hr\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;The full code of a version using true 2D arrays\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;stdlib.h\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;stdio.h\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;assert.h\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;arr_alloc\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;size_t\u0026lt;/span\u0026gt; x, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;size_t\u0026lt;/span\u0026gt; y, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;(**aptr)[x][y])\u0026lt;/span\u0026gt;\n{\n  *aptr = \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;malloc\u0026lt;/span\u0026gt;( \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;sizeof\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;[x][y]) ); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// allocate a true 2D array\u0026lt;/span\u0026gt;\n  assert(*aptr != \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;NULL\u0026lt;/span\u0026gt;);\n}\n\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;arr_fill\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;size_t\u0026lt;/span\u0026gt; x, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;size_t\u0026lt;/span\u0026gt; y, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;array\u0026lt;/span\u0026gt;[x][y])\u0026lt;/span\u0026gt;\n{\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;size_t\u0026lt;/span\u0026gt; i=\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;; i\u0026amp;lt;x; i++)\n  {\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;size_t\u0026lt;/span\u0026gt; j=\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;; j\u0026amp;lt;y; j++)\n    {\n      \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;array\u0026lt;/span\u0026gt;[i][j] = (\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;)j + \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;;\n    }\n  }\n}\n\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;arr_print\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;size_t\u0026lt;/span\u0026gt; x, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;size_t\u0026lt;/span\u0026gt; y, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;array\u0026lt;/span\u0026gt;[x][y])\u0026lt;/span\u0026gt;\n{\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;size_t\u0026lt;/span\u0026gt; i=\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;; i\u0026amp;lt;x; i++)\n  {\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;size_t\u0026lt;/span\u0026gt; j=\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;; j\u0026amp;lt;y; j++)\n    {\n      \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;printf\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;%d \u0026quot;\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;array\u0026lt;/span\u0026gt;[i][j]);\n    }\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;printf\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;\\n\u0026quot;\u0026lt;/span\u0026gt;);\n  }\n}\n\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;main\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt;)\u0026lt;/span\u0026gt;\n{\n  \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;size_t\u0026lt;/span\u0026gt; x = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;;\n  \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;size_t\u0026lt;/span\u0026gt; y = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3\u0026lt;/span\u0026gt;;\n  \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; (*aptr)[x][y];\n\n  arr_alloc(x, y, \u0026amp;amp;aptr);\n  arr_fill(x, y, *aptr);\n  arr_print(x, y, *aptr);\n  \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;free\u0026lt;/span\u0026gt;(aptr); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// free the whole 2D array\u0026lt;/span\u0026gt;\n\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;C doesn\u0026apos;t have multidimensional arrays\u0026lt;/strong\u0026gt; (as a \u0026lt;em\u0026gt;primitive\u0026lt;/em\u0026gt; data type). But you could have arrays of arrays (or of other aggregates) and arrays of pointers.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;A possible approach is to \u0026lt;strong\u0026gt;reason with some \u0026lt;a href=\u0026quot;https://en.wikipedia.org/wiki/Abstract_data_type\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;abstract data type\u0026lt;/a\u0026gt;\u0026lt;/strong\u0026gt; (perhaps using \u0026lt;a href=\u0026quot;https://en.wikipedia.org/wiki/Flexible_array_member\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;flexible array members\u0026lt;/a\u0026gt;, which is one implementation trick, and you could use other approaches) like in \u0026lt;a href=\u0026quot;https://stackoverflow.com/a/47235897/841108\u0026quot;\u0026gt;this answer\u0026lt;/a\u0026gt;.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;We can\u0026apos;t suggest any abstract data type, because that depends on the text of your homework, which we don\u0026apos;t have. You need to \u0026lt;strong\u0026gt;design your abstract data type\u0026lt;/strong\u0026gt; (on a piece of paper), and later to implement it.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Once you have listed (on a paper or on a board) all the operations needed on your ADT, implementing them is straightforward.\u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;This code works just fine! How could it be wrong?\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;p\u0026gt;That sentence is inconsistent (wrong w.r.t. what specifications?) ...\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;I recommend to compile with all warnings and debug info (e.g. \u0026lt;a href=\u0026quot;https://gcc.gnu.org/onlinedocs/gcc/Invoking-GCC.html\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;with\u0026lt;/a\u0026gt; \u0026lt;code\u0026gt;gcc -Wall -Wextra -g\u0026lt;/code\u0026gt; with \u0026lt;a href=\u0026quot;https://gcc.gnu.org/\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;GCC\u0026lt;/a\u0026gt;), to improve your code till you get no warnings, to use the debugger \u0026lt;code\u0026gt;gdb\u0026lt;/code\u0026gt; (to understand what is happening in your program) and other tools like \u0026lt;a href=\u0026quot;http://valgrind.org/\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;valgrind\u0026lt;/a\u0026gt;.\u0026lt;/p\u0026gt;\n    "],"id":357,"title":"Correctly allocating multi-dimensional arrays","content":"\n                \n\u0026lt;p\u0026gt;\u0026lt;em\u0026gt;The intent of this question is to provide a reference about how to correctly allocate multi-dimensional arrays dynamically in C. This is a topic often misunderstood and poorly explained even in some C programming books. Therefore even seasoned C programmers struggle to get it right.\u0026lt;/em\u0026gt; \u0026lt;/p\u0026gt;\n\n\u0026lt;hr\u0026gt;\n\n\u0026lt;p\u0026gt;I have been taught from my programming teacher/book/tutorial that the correct way to dynamically allocate a multi-dimensional array is by using pointer-to-pointers. \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;However, several high rep users on SO now tell me that this is wrong and bad practice. They say that pointer-to-pointers are not arrays, that I am not actually allocating arrays and that my code is needlessly slow. \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;This is how I was taught to allocate multi-dimensional arrays:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;stdlib.h\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;stdio.h\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;assert.h\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;** \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;arr_alloc\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;size_t\u0026lt;/span\u0026gt; x, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;size_t\u0026lt;/span\u0026gt; y)\u0026lt;/span\u0026gt;\n{\n  \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;** pp = \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;malloc\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;sizeof\u0026lt;/span\u0026gt;(*pp) * x);\n  assert(pp != \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;NULL\u0026lt;/span\u0026gt;);\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;size_t\u0026lt;/span\u0026gt; i=\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;; i\u0026amp;lt;x; i++)\n  {\n    pp[i] = \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;malloc\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;sizeof\u0026lt;/span\u0026gt;(**pp) * y);\n    assert(pp[i] != \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;NULL\u0026lt;/span\u0026gt;);\n  }\n\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; pp;\n}\n\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;** \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;arr_fill\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;** pp, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;size_t\u0026lt;/span\u0026gt; x, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;size_t\u0026lt;/span\u0026gt; y)\u0026lt;/span\u0026gt;\n{\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;size_t\u0026lt;/span\u0026gt; i=\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;; i\u0026amp;lt;x; i++)\n  {\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;size_t\u0026lt;/span\u0026gt; j=\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;; j\u0026amp;lt;y; j++)\n    {\n      pp[i][j] = (\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;)j + \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;;\n    }\n  }\n\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; pp;\n}\n\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;arr_print\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;** pp, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;size_t\u0026lt;/span\u0026gt; x, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;size_t\u0026lt;/span\u0026gt; y)\u0026lt;/span\u0026gt;\n{\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;size_t\u0026lt;/span\u0026gt; i=\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;; i\u0026amp;lt;x; i++)\n  {\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;size_t\u0026lt;/span\u0026gt; j=\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;; j\u0026amp;lt;y; j++)\n    {\n      \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;printf\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;%d \u0026quot;\u0026lt;/span\u0026gt;, pp[i][j]);\n    }\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;printf\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;\\n\u0026quot;\u0026lt;/span\u0026gt;);\n  }\n}\n\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;arr_free\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;** pp, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;size_t\u0026lt;/span\u0026gt; x, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;size_t\u0026lt;/span\u0026gt; y)\u0026lt;/span\u0026gt;\n{\n  (\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt;) y;\n\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;size_t\u0026lt;/span\u0026gt; i=\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;; i\u0026amp;lt;x; i++)\n  {\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;free\u0026lt;/span\u0026gt;(pp[i]);\n    pp[i] = \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;NULL\u0026lt;/span\u0026gt;;\n  }\n  \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;free\u0026lt;/span\u0026gt;(pp);\n  pp = \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;NULL\u0026lt;/span\u0026gt;;\n}\n\n\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;main\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt;)\u0026lt;/span\u0026gt;\n{\n  \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;size_t\u0026lt;/span\u0026gt; x = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;;\n  \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;size_t\u0026lt;/span\u0026gt; y = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3\u0026lt;/span\u0026gt;;\n  \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;** pp;\n\n  pp = arr_alloc(x, y);\n  pp = arr_fill(pp, x, y);\n  arr_print(pp, x, y);\n  arr_free(pp, x, y);\n\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Output\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;This code works just fine! How could it be wrong?\u0026lt;/p\u0026gt;\n    ","slug":"correctly-allocating-multi-dimensional-arrays-1657387733756","postType":"QUESTION","createdAt":"2022-07-09T17:28:53.000Z","updatedAt":"2022-07-09T17:28:53.000Z","tags":[{"id":1996,"name":"dynamic-arrays","slug":"dynamic-arrays","createdAt":"2022-07-09T17:28:53.000Z","updatedAt":"2022-07-09T17:28:53.000Z","Questions_Tags":{"questionId":357,"tagId":1996}},{"id":1997,"name":"dynamic-allocation","slug":"dynamic-allocation","createdAt":"2022-07-09T17:28:53.000Z","updatedAt":"2022-07-09T17:28:53.000Z","Questions_Tags":{"questionId":357,"tagId":1997}}],"relatedQuestions":[{"title":"Correctly allocating multi-dimensional arrays","slug":"correctly-allocating-multi-dimensional-arrays-1657387733756","tags":[{"name":"dynamic-arrays","Questions_Tags":{"questionId":357,"tagId":1996}},{"name":"dynamic-allocation","Questions_Tags":{"questionId":357,"tagId":1997}}]}]},"randomQuestions":[{"title":"What is the difference between JSON and Object Literal Notation?","slug":"what-is-the-difference-between-json-and-object-literal-notation-1657387515710"},{"title":"How to generate a self-signed SSL certificate using OpenSSL? [closed]","slug":"how-to-generate-a-self-signed-ssl-certificate-using-openssl-closed-1657388298626"},{"title":"The Definitive C Book Guide and List","slug":"the-definitive-c-book-guide-and-list-1657384747653"},{"title":"\"Thinking in AngularJS\" if I have a jQuery background? [closed]","slug":"\"thinking-in-angularjs\"-if-i-have-a-jquery-background-closed-1657384761159"},{"title":"javascript function doesn't work when link is clicked","slug":"javascript-function-doesn't-work-when-link-is-clicked-1657387767488"},{"title":"How do I use arrays in C++?","slug":"how-do-i-use-arrays-in-c++-1657387456118"},{"title":"Passing data between view controllers","slug":"passing-data-between-view-controllers-1657384540021"},{"title":"Why use getters and setters/accessors?","slug":"why-use-getters-and-settersaccessors-1657387343971"},{"title":"Download a file by jQuery.Ajax","slug":"download-a-file-by-jquery.ajax-1657388220611"},{"title":"MySQL pivot row into dynamic number of columns","slug":"mysql-pivot-row-into-dynamic-number-of-columns-1657387981930"},{"title":"How to use SharedPreferences in Android to store, fetch and edit values [closed]","slug":"how-to-use-sharedpreferences-in-android-to-store-fetch-and-edit-values-closed-1657387683057"},{"title":"Calling a function of a module by using its name (a string)","slug":"calling-a-function-of-a-module-by-using-its-name-(a-string)-1657388565656"},{"title":"How to generate all permutations of a list","slug":"how-to-generate-all-permutations-of-a-list-1657388537371"},{"title":"Where and why do I have to put the \"template\" and \"typename\" keywords?","slug":"where-and-why-do-i-have-to-put-the-\"template\"-and-\"typename\"-keywords-1657384467606"},{"title":"Why aren't variable-length arrays part of the C++ standard?","slug":"why-aren't-variable-length-arrays-part-of-the-c++-standard-1657384712975"},{"title":"What is dependency injection?","slug":"what-is-dependency-injection-1657387953056"},{"title":"Arrays, linked lists and other data structures in cmd.exe (batch) script","slug":"arrays-linked-lists-and-other-data-structures-in-cmd.exe-(batch)-script-1657387558484"},{"title":"Why is using the JavaScript eval function a bad idea?","slug":"why-is-using-the-javascript-eval-function-a-bad-idea-1657387485165"},{"title":"What is the difference between a deep copy and a shallow copy?","slug":"what-is-the-difference-between-a-deep-copy-and-a-shallow-copy-1657388445063"},{"title":"What is __init__.py for?","slug":"what-is-__init__.py-for-1657388415243"}]},"__N_SSG":true},"page":"/questions/[slug]","query":{"slug":"correctly-allocating-multi-dimensional-arrays-1657387733756"},"buildId":"eGqQHYKGZKE-nXShFn8wX","isFallback":false,"gsp":true,"locale":"en","locales":["en"],"defaultLocale":"en","scriptLoader":[]}</script></body></html>