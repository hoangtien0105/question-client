<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><meta name="twitter:card" content="summary_large_image"/><meta name="twitter:site" content="@solutionschecker.com"/><meta name="twitter:creator" content="@solutionschecker.com"/><meta property="og:url" content="https://solutionschecker.com"/><meta property="og:type" content="website"/><meta property="og:image" content="https://solutionschecker.com/solutions-checker-banner.png"/><meta property="og:image:alt" content="Find the solution to any question. We focus on finding the fastest possible solution for users. Main topics like coding, learning. - solutionschecker.com"/><link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png"/><link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png"/><link rel="manifest" href="/site.webmanifest"/><script type="application/ld+json">{"@context":"https://schema.org","@type":"Organization","logo":"/logo.svg","url":"https://solutionschecker.com"}</script><link name="keywords" content="typename,dependent-name,solutions checker, solution checker, how to, solution for, check for solution, resolve question, what is, what solution for, find solution"/><script type="application/ld+json">{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"item":{"@id":"https://solutionschecker.com","name":"Home"}},{"@type":"ListItem","position":2,"item":{"@id":"https://solutionschecker.com/questions","name":"Questions"}},{"@type":"ListItem","position":3,"item":{"@id":"https://solutionschecker.com/questions/where-and-why-do-i-have-to-put-the-&quot;template&quot;-and-&quot;typename&quot;-keywords-1657384467606","name":"Questions"}}]}</script><title>Where and why do I have to put the &quot;template&quot; and &quot;typename&quot; keywords? | Solution Checker</title><meta name="robots" content="index,follow"/><meta name="description" content="In templates, where and why do I have to put typename and template on dependent names?
What exactly are dependent names anyway?  

I have the following code:

template &lt;typename T, typename Tail&gt; // Tail will be a UnionNode too.
struct UnionNode : public Tail {
    // ...
    template&lt;typename U&gt; struct inUnion {
        // Q: where to add typename/template here?
        typedef Tail::inUnion&lt;U&gt; dummy; 
    };
    template&lt; &gt; struct inUnion&lt;T&gt; {
    };
};
template &lt;typename T&gt; // For the last node Tn.
struct UnionNode&lt;T, void&gt; {
    // ...
    template&lt;typename U&gt; struct inUnion {
        char fail[ -2 + (sizeof(U)%2) ]; // Cannot be instantiated for any U
    };
    template&lt; &gt; struct inUnion&lt;T&gt; {
    };
};


The problem I have is in the typedef Tail::inUnion&lt;U&gt; dummy line. I&#x27;m fairly certain that inUnion is a dependent name, and VC++ is quite right in choking on it.
I also know that I should be able to add template somewhere to tell the compiler that inUnion is a template-id. But where exactly? And should it then assume that inUnion is a class template, i.e. inUnion&lt;U&gt; names a type and not a function?
    "/><meta property="og:title" content="Where and why do I have to put the &quot;template&quot; and &quot;typename&quot; keywords? | Solution Checker"/><meta property="og:description" content="In templates, where and why do I have to put typename and template on dependent names?
What exactly are dependent names anyway?  

I have the following code:

template &lt;typename T, typename Tail&gt; // Tail will be a UnionNode too.
struct UnionNode : public Tail {
    // ...
    template&lt;typename U&gt; struct inUnion {
        // Q: where to add typename/template here?
        typedef Tail::inUnion&lt;U&gt; dummy; 
    };
    template&lt; &gt; struct inUnion&lt;T&gt; {
    };
};
template &lt;typename T&gt; // For the last node Tn.
struct UnionNode&lt;T, void&gt; {
    // ...
    template&lt;typename U&gt; struct inUnion {
        char fail[ -2 + (sizeof(U)%2) ]; // Cannot be instantiated for any U
    };
    template&lt; &gt; struct inUnion&lt;T&gt; {
    };
};


The problem I have is in the typedef Tail::inUnion&lt;U&gt; dummy line. I&#x27;m fairly certain that inUnion is a dependent name, and VC++ is quite right in choking on it.
I also know that I should be able to add template somewhere to tell the compiler that inUnion is a template-id. But where exactly? And should it then assume that inUnion is a class template, i.e. inUnion&lt;U&gt; names a type and not a function?
    "/><script type="application/ld+json">{"@context":"https://schema.org","@type":"QAPage","mainEntity":{"name":"Where and why do I have to put the &quot;template&quot; and &quot;typename&quot; keywords?","text":"In templates, where and why do I have to put typename and template on dependent names?\nWhat exactly are dependent names anyway?  \n\nI have the following code:\n\ntemplate &lt;typename T, typename Tail&gt; // Tail will be a UnionNode too.\nstruct UnionNode : public Tail {\n    // ...\n    template&lt;typename U&gt; struct inUnion {\n        // Q: where to add typename/template here?\n        typedef Tail::inUnion&lt;U&gt; dummy; \n    };\n    template&lt; &gt; struct inUnion&lt;T&gt; {\n    };\n};\ntemplate &lt;typename T&gt; // For the last node Tn.\nstruct UnionNode&lt;T, void&gt; {\n    // ...\n    template&lt;typename U&gt; struct inUnion {\n        char fail[ -2 + (sizeof(U)%2) ]; // Cannot be instantiated for any U\n    };\n    template&lt; &gt; struct inUnion&lt;T&gt; {\n    };\n};\n\n\nThe problem I have is in the typedef Tail::inUnion&lt;U&gt; dummy line. I&apos;m fairly certain that inUnion is a dependent name, and VC++ is quite right in choking on it.\nI also know that I should be able to add template somewhere to tell the compiler that inUnion is a template-id. But where exactly? And should it then assume that inUnion is a class template, i.e. inUnion&lt;U&gt; names a type and not a function?\n    ","answerCount":8,"upVoteCount":500,"suggestedAnswer":[{"text":"(See here also for my C++11 answer)\n\nIn order to parse a C++ program, the compiler needs to know whether certain names are types or not. The following example demonstrates that:\n\nt * f;\n\n\nHow should this be parsed? For many languages a compiler doesn&apos;t need to know the meaning of a name in order to parse and basically know what action a line of code does. In C++, the above however can yield vastly different interpretations depending on what t means. If it&apos;s a type, then it will be a declaration of a pointer f. However if it&apos;s not a type, it will be a multiplication. So the C++ Standard says at paragraph (3/7):\n\n\n  Some names denote types or templates. In general, whenever a name is encountered it is necessary to determine whether that name denotes one of these entities before continuing to parse the program that contains it. The process that determines this is called name lookup.\n\n\nHow will the compiler find out what a name t::x refers to, if t refers to a template type parameter? x could be a static int data member that could be multiplied or could equally well be a nested class or typedef that could yield to a declaration. If a name has this property - that it can&apos;t be looked up until the actual template arguments are known - then it&apos;s called a dependent name (it &quot;depends&quot; on the template parameters). \n\nYou might recommend to just wait till the user instantiates the template: \n\n\n  Let&apos;s wait until the user instantiates the template, and then later find out the real meaning of t::x * f;. \n\n\nThis will work and actually is allowed by the Standard as a possible implementation approach. These compilers basically copy the template&apos;s text into an internal buffer, and only when an instantiation is needed, they parse the template and possibly detect errors in the definition. But instead of bothering the template&apos;s users (poor colleagues!) with errors made by a template&apos;s author, other implementations choose to check templates early on and give errors in the definition as soon as possible, before an instantiation even takes place. \n\nSo there has to be a way to tell the compiler that certain names are types and that certain names aren&apos;t. \n\nThe &quot;typename&quot; keyword\n\nThe answer is: We decide how the compiler should parse this. If t::x is a dependent name, then we need to prefix it by typename to tell the compiler to parse it in a certain way. The Standard says at (14.6/2):\n\n\n  A name used in a template declaration or definition and that is dependent on a template-parameter is\n  assumed not to name a type unless the applicable name lookup finds a type name or the name is qualified\n  by the keyword typename. \n\n\nThere are many names for which typename is not necessary, because the compiler can, with the applicable name lookup in the template definition, figure out how to parse a construct itself - for example with T *f;, when T is a type template parameter. But for t::x * f; to be a declaration, it must be written as typename t::x *f;. If you omit the keyword and the name is taken to be a non-type, but when instantiation finds it denotes a type, the usual error messages are emitted by the compiler. Sometimes, the error consequently is given at definition time:\n\n// t::x is taken as non-type, but as an expression the following misses an\n// operator between the two names or a semicolon separating them.\nt::x f;\n\n\nThe syntax allows typename only before qualified names - it is therefor taken as granted that unqualified names are always known to refer to types if they do so.\n\nA similar gotcha exists for names that denote templates, as hinted at by the introductory text.\n\nThe &quot;template&quot; keyword\n\nRemember the initial quote above and how the Standard requires special handling for templates as well? Let&apos;s take the following innocent-looking example: \n\nboost::function&lt; int() &gt; f;\n\n\nIt might look obvious to a human reader. Not so for the compiler. Imagine the following arbitrary definition of boost::function and f:\n\nnamespace boost { int function = 0; }\nint main() { \n  int f = 0;\n  boost::function&lt; int() &gt; f; \n}\n\n\nThat&apos;s actually a valid expression! It uses the less-than operator to compare boost::function against zero (int()), and then uses the greater-than operator to compare the resulting bool against f. However as you might well know, boost::function in real life is a template, so the compiler knows (14.2/3):\n\n\n  After name lookup (3.4) finds that a name is a template-name, if this name is followed by a &lt;, the &lt; is\n  always taken as the beginning of a template-argument-list and never as a name followed by the less-than\n  operator.\n\n\nNow we are back to the same problem as with typename. What if we can&apos;t know yet whether the name is a template when parsing the code? We will need to insert template immediately before the template name, as specified by 14.2/4. This looks like:\n\nt::template f&lt;int&gt;(); // call a function template\n\n\nTemplate names can not only occur after a :: but also after a -&gt; or . in a class member access. You need to insert the keyword there too:\n\nthis-&gt;template f&lt;int&gt;(); // call a function template\n\n\n\n\nDependencies\n\nFor the people that have thick Standardese books on their shelf and that want to know what exactly I was talking about, I&apos;ll talk a bit about how this is specified in the Standard.\n\nIn template declarations some constructs have different meanings depending on what template arguments you use to instantiate the template: Expressions may have different types or values, variables may have different types or function calls might end up calling different functions. Such constructs are generally said to depend on template parameters.\n\nThe Standard defines precisely the rules by whether a construct is dependent or not. It separates them into logically different groups: One catches types, another catches expressions. Expressions may depend by their value and/or their type. So we have, with typical examples appended:\n\n\nDependent types (e.g: a type template parameter T)\nValue-dependent expressions (e.g: a non-type template parameter N)\nType-dependent expressions (e.g: a cast to a type template parameter (T)0)\n\n\nMost of the rules are intuitive and are built up recursively: For example, a type constructed as T[N] is a dependent type if N is a value-dependent expression or T is a dependent type. The details of this can be read in section (14.6.2/1) for dependent types, (14.6.2.2) for type-dependent expressions and (14.6.2.3) for value-dependent expressions. \n\nDependent names\n\nThe Standard is a bit unclear about what exactly is a dependent name. On a simple read (you know, the principle of least surprise), all it defines as a dependent name is the special case for function names below. But since clearly T::x also needs to be looked up in the instantiation context, it also needs to be a dependent name (fortunately, as of mid C++14 the committee has started to look into how to fix this confusing definition). \n\nTo avoid this problem, I have resorted to a simple interpretation of the Standard text. Of all the constructs that denote dependent types or expressions, a subset of them represent names. Those names are therefore &quot;dependent names&quot;. A name can take different forms - the Standard says:\n\n\n  A name is a use of an identifier (2.11), operator-function-id (13.5), conversion-function-id (12.3.2), or template-id (14.2) that denotes an entity or label (6.6.4, 6.1)\n\n\nAn identifier is just a plain sequence of characters / digits, while the next two are the operator + and operator type form. The last form is template-name &lt;argument list&gt;. All these are names, and by conventional use in the Standard, a name can also include qualifiers that say what namespace or class a name should be looked up in.\n\nA value dependent expression 1 + N is not a name, but N is. The subset of all dependent constructs that are names is called dependent name. Function names, however, may have different meaning in different instantiations of a template, but unfortunately are not caught by this general rule. \n\nDependent function names\n\nNot primarily a concern of this article, but still worth mentioning: Function names are an exception that are handled separately. An identifier function name is dependent not by itself, but by the type dependent argument expressions used in a call. In the example f((T)0), f is a dependent name. In the Standard, this is specified at (14.6.2/1).\n\nAdditional notes and examples\n\nIn enough cases we need both of typename and template. Your code should look like the following\n\ntemplate &lt;typename T, typename Tail&gt;\nstruct UnionNode : public Tail {\n    // ...\n    template&lt;typename U&gt; struct inUnion {\n        typedef typename Tail::template inUnion&lt;U&gt; dummy;\n    };\n    // ...\n};\n\n\nThe keyword template doesn&apos;t always have to appear in the last part of a name. It can appear in the middle before a class name that&apos;s used as a scope, like in the following example\n\ntypename t::template iterator&lt;int&gt;::value_type v;\n\n\nIn some cases, the keywords are forbidden, as detailed below\n\n\nOn the name of a dependent base class you are not allowed to write typename. It&apos;s assumed that the name given is a class type name. This is true for both names in the base-class list and the constructor initializer list:\n\n template &lt;typename T&gt;\n struct derive_from_Has_type : /* typename */ SomeBase&lt;T&gt;::type \n { };\n\nIn using-declarations it&apos;s not possible to use template after the last ::, and the C++ committee said not to work on a solution. \n\n template &lt;typename T&gt;\n struct derive_from_Has_type : SomeBase&lt;T&gt; {\n    using SomeBase&lt;T&gt;::template type; // error\n    using typename SomeBase&lt;T&gt;::type; // typename *is* allowed\n };\n\n\n    ","url":"https://solutionschecker.com/questions/where-and-why-do-i-have-to-put-the-&quot;template&quot;-and-&quot;typename&quot;-keywords-1657384467606#solution1","@type":"Answer","upvoteCount":0},{"text":"C++11\n\nProblem\n\nWhile the rules in C++03 about when you need typename and template are largely reasonable, there is one annoying disadvantage of its formulation\n\ntemplate&lt;typename T&gt;\nstruct A {\n  typedef int result_type;\n\n  void f() {\n    // error, &quot;this&quot; is dependent, &quot;template&quot; keyword needed\n    this-&gt;g&lt;float&gt;();\n\n    // OK\n    g&lt;float&gt;();\n\n    // error, &quot;A&lt;T&gt;&quot; is dependent, &quot;typename&quot; keyword needed\n    A&lt;T&gt;::result_type n1;\n\n    // OK\n    result_type n2; \n  }\n\n  template&lt;typename U&gt;\n  void g();\n};\n\n\nAs can be seen, we need the disambiguation keyword even if the compiler could perfectly figure out itself that A::result_type can only be int (and is hence a type), and this-&gt;g can only be the member template g declared later (even if A is explicitly specialized somewhere, that would not affect the code within that template, so its meaning cannot be affected by a later specialization of A!). \n\nCurrent instantiation\n\nTo improve the situation, in C++11 the language tracks when a type refers to the enclosing template. To know that, the type must have been formed by using a certain form of name, which is its own name (in the above, A, A&lt;T&gt;, ::A&lt;T&gt;). A type referenced by such a name is known to be  the current instantiation. There may be multiple types that are all the current instantiation if the type from which the name is formed is a member/nested class (then, A::NestedClass and A are both current instantiations). \n\nBased on this notion, the language says that CurrentInstantiation::Foo, Foo and CurrentInstantiationTyped-&gt;Foo (such as A *a = this; a-&gt;Foo) are all member of the current instantiation if they are found to be members of a class that is the current instantiation or one of its non-dependent base classes (by just doing the name lookup immediately). \n\nThe keywords typename and template are now not required anymore if the qualifier is a member of the current instantiation. A keypoint here to remember is that A&lt;T&gt; is still a type-dependent name (after all T is also type dependent). But A&lt;T&gt;::result_type is known to be a type - the compiler will &quot;magically&quot; look into this kind of dependent types to figure this out. \n\nstruct B {\n  typedef int result_type;\n};\n\ntemplate&lt;typename T&gt;\nstruct C { }; // could be specialized!\n\ntemplate&lt;typename T&gt;\nstruct D : B, C&lt;T&gt; {\n  void f() {\n    // OK, member of current instantiation!\n    // A::result_type is not dependent: int\n    D::result_type r1;\n\n    // error, not a member of the current instantiation\n    D::questionable_type r2;\n\n    // OK for now - relying on C&lt;T&gt; to provide it\n    // But not a member of the current instantiation\n    typename D::questionable_type r3;        \n  }\n};\n\n\nThat&apos;s impressive, but can we do better? The language even goes further and requires that an implementation again looks up D::result_type when instantiating D::f (even if it found its meaning already at definition time). When now the lookup result differs or results in ambiguity, the program is ill-formed and a diagnostic must be given. Imagine what happens if we defined C like this\n\ntemplate&lt;&gt;\nstruct C&lt;int&gt; {\n  typedef bool result_type;\n  typedef int questionable_type;\n};\n\n\nA compiler is required to catch the error when instantiating D&lt;int&gt;::f. So you get the best of the two worlds: &quot;Delayed&quot; lookup protecting you if you could get in trouble with dependent base classes, and also &quot;Immediate&quot; lookup that frees you from typename and template. \n\nUnknown specializations\n\nIn the code of D, the name typename D::questionable_type is not a member of the current instantiation. Instead the language marks it as a member of an unknown specialization. In particular, this is always the case when you are doing DependentTypeName::Foo or DependentTypedName-&gt;Foo and either the dependent type is not the current instantiation (in which case the compiler can give up and say &quot;we will look later what Foo is) or it is the current instantiation and the name was not found in it or its non-dependent base classes and there are also dependent base classes. \n\nImagine what happens if we had a member function h within the above defined A class template\n\nvoid h() {\n  typename A&lt;T&gt;::questionable_type x;\n}\n\n\nIn C++03, the language allowed to catch this error because there could never be a valid way to instantiate A&lt;T&gt;::h (whatever argument you give to T). In C++11, the language now has a further check to give more reason for compilers to implement this rule. Since A has no dependent base classes, and A declares no member questionable_type, the name A&lt;T&gt;::questionable_type is neither a member of the current instantiation nor a member of an unknown specialization. In that case, there should be no way that that code could validly compile at instantiation time, so the language forbids a name where the qualifier is the current instantiation to be neither a member of an unknown specialization nor a member of the current instantiation (however, this violation is still not required to be diagnosed).\n\nExamples and trivia\n\nYou can try this knowledge on this answer and see whether the above definitions make sense for you on a real-world example (they are repeated slightly less detailed in that answer).  \n\nThe C++11 rules make the following valid C++03 code ill-formed (which was not intended by the C++ committee, but will probably not be fixed)\n\nstruct B { void f(); };\nstruct A : virtual B { void f(); };\n\ntemplate&lt;typename T&gt;\nstruct C : virtual B, T {\n  void g() { this-&gt;f(); }\n};\n\nint main() { \n  C&lt;A&gt; c; c.g(); \n}\n\n\nThis valid C++03 code would bind this-&gt;f to A::f at instantiation time and everything is fine. C++11 however immediately binds it to B::f and requires a double-check when instantiating, checking whether the lookup still matches. However when instantiating C&lt;A&gt;::g, the Dominance Rule applies and lookup will find A::f instead.\n    ","url":"https://solutionschecker.com/questions/where-and-why-do-i-have-to-put-the-&quot;template&quot;-and-&quot;typename&quot;-keywords-1657384467606#solution2","@type":"Answer","upvoteCount":0},{"text":"\nPreface\nThis post is meant to be an easy-to-read alternative to litb&apos;s post.\n\n\nThe underlying purpose is the same; an explanation to &quot;When?&quot; and &quot;Why?&quot; typename and template must be applied.\n\n\nWhat&apos;s the purpose of typename and template?\ntypename and template are usable in circumstances other than when declaring a template.\nThere are certain contexts in C++ where the compiler must explicitly be told how to treat a name, and all these contexts have one thing in common; they depend on at least one template-parameter.\nWe refer to such names, where there can be an ambiguity in interpretation, as; &quot;dependent names&quot;.\nThis post will offer an explanation to the relationship between dependent-names, and the two keywords.\n\nA snippet says more than 1000 words\nTry to explain what is going on in the following function-template, either to yourself, a friend, or perhaps your cat; what is happening in the statement marked (A)?\ntemplate&lt;class T&gt; void f_tmpl () { T::foo * x; /* &lt;-- (A) */ }\n\n\nIt might not be as easy as one thinks, more specifically the result of evaluating (A) heavily depends on the definition of the type passed as template-parameter T.\nDifferent Ts can drastically change the semantics involved.\nstruct X { typedef int       foo;       }; /* (C) --&gt; */ f_tmpl&lt;X&gt; ();\nstruct Y { static  int const foo = 123; }; /* (D) --&gt; */ f_tmpl&lt;Y&gt; ();\n\n\nThe two different scenarios:\n\nIf we instantiate the function-template with type X, as in (C), we will have a declaration of a pointer-to int named x, but;\n\nif we instantiate the template with type Y, as in (D), (A) would instead consist of an expression that calculates the product of 123 multiplied with some already declared variable x.\n\n\n\n\nThe Rationale\nThe C++ Standard cares about our safety and well-being, at least in this case.\nTo prevent an implementation from potentially suffering from nasty surprises, the Standard mandates that we sort out the ambiguity of a dependent-name by explicitly stating the intent anywhere we&apos;d like to treat the name as either a type-name, or a template-id.\nIf nothing is stated, the dependent-name will be considered to be either a variable, or a function.\n\n\nHow to handle dependent names?\nIf this was a Hollywood film, dependent-names would be the disease that spreads through body contact, instantly affects its host to make it confused. Confusion that could, possibly, lead to an ill-formed perso-, erhm.. program.\nA dependent-name is any name that directly, or indirectly, depends on a template-parameter.\n\ntemplate&lt;class T&gt; void g_tmpl () {\n   SomeTrait&lt;T&gt;::type                   foo; // (E), ill-formed\n   SomeTrait&lt;T&gt;::NestedTrait&lt;int&gt;::type bar; // (F), ill-formed\n   foo.data&lt;int&gt; ();                         // (G), ill-formed    \n}\n\nWe have four dependent names in the above snippet:\n\nE)\n\n&quot;type&quot; depends on the instantiation of SomeTrait&lt;T&gt;, which include T, and;\n\n\nF)\n\n&quot;NestedTrait&quot;, which is a template-id, depends on SomeTrait&lt;T&gt;, and;\n&quot;type&quot; at the end of (F) depends on NestedTrait, which depends on SomeTrait&lt;T&gt;, and;\n\n\nG)\n\n&quot;data&quot;, which looks like a member-function template, is indirectly a dependent-name since the type of foo depends on the instantiation of SomeTrait&lt;T&gt;.\n\n\n\nNeither of statement (E), (F) or (G) is valid if the compiler would interpret the dependent-names as variables/functions (which as stated earlier is what happens if we don&apos;t explicitly say otherwise).\n\nThe solution\nTo make g_tmpl have a valid definition we must explicitly tell the compiler that we expect a type in (E), a template-id and a type in (F), and a template-id in (G).\ntemplate&lt;class T&gt; void g_tmpl () {\n   typename SomeTrait&lt;T&gt;::type foo;                            // (G), legal\n   typename SomeTrait&lt;T&gt;::template NestedTrait&lt;int&gt;::type bar; // (H), legal\n   foo.template data&lt;int&gt; ();                                  // (I), legal\n}\n\nEvery time a name denotes a type, all names involved must be either type-names or namespaces, with this in mind it&apos;s quite easy to see that we apply typename at the beginning of our fully qualified name.\ntemplate however, is different in this regard, since there&apos;s no way of coming to a conclusion such as; &quot;oh, this is a template, then this other thing must also be a template&quot;. This means that we apply template directly in front of any name that we&apos;d like to treat as such.\n\n\nCan I just stick the keywords in front of any name?\n\n&quot;Can I just stick typename and template in front of any name? I don&apos;t want to worry about the context in which they appear...&quot; - Some C++ Developer\n\nThe rules in the Standard states that you may apply the keywords as long as you are dealing with a qualified-name (K), but if the name isn&apos;t qualified the application is ill-formed (L).\nnamespace N {\n  template&lt;class T&gt;\n  struct X { };\n}\n\n\n         N::         X&lt;int&gt; a; // ...  legal\ntypename N::template X&lt;int&gt; b; // (K), legal\ntypename template    X&lt;int&gt; c; // (L), ill-formed\n\nNote: Applying typename or template in a context where it is not required is not considered good practice; just because you can do something, doesn&apos;t mean that you should.\n\nAdditionally there are contexts where typename and template are explicitly disallowed:\n\nWhen specifying the bases of which a class inherits\nEvery name written in a derived class&apos;s base-specifier-list is already treated as a type-name, explicitly specifying typename is both ill-formed, and redundant.\n                    // .------- the base-specifier-list\n  template&lt;class T&gt; // v\n  struct Derived      : typename SomeTrait&lt;T&gt;::type /* &lt;- ill-formed */ {\n    ...\n  };\n\n \n\nWhen the template-id is the one being referred to in a derived class&apos;s using-directive\n  struct Base {\n    template&lt;class T&gt;\n    struct type { };\n  };\n\n  struct Derived : Base {\n    using Base::template type; // ill-formed\n    using Base::type;          // legal\n  };\n\n\n\n    ","url":"https://solutionschecker.com/questions/where-and-why-do-i-have-to-put-the-&quot;template&quot;-and-&quot;typename&quot;-keywords-1657384467606#solution3","@type":"Answer","upvoteCount":0},{"text":"\nThis answer is meant to be a rather short and sweet one to answer (part of) the titled question. If you want an answer with more detail that explains why you have to put them there, please go here.\n\n\n\n\nThe general rule for putting the typename keyword is mostly when you&apos;re using a template parameter and you want to access a nested typedef or using-alias, for example:\n\ntemplate&lt;typename T&gt;\nstruct test {\n    using type = T; // no typename required\n    using underlying_type = typename T::type // typename required\n};\n\n\nNote that this also applies for meta functions or things that take generic template parameters too. However, if the template parameter provided is an explicit type then you don&apos;t have to specify typename, for example:\n\ntemplate&lt;typename T&gt;\nstruct test {\n    // typename required\n    using type = typename std::conditional&lt;true, const T&amp;, T&amp;&amp;&gt;::type;\n    // no typename required\n    using integer = std::conditional&lt;true, int, float&gt;::type;\n};\n\n\nThe general rules for adding the template qualifier are mostly similar except they typically involve templated member functions (static or otherwise) of a struct/class that is itself templated, for example:\n\nGiven this struct and function:\n\ntemplate&lt;typename T&gt;\nstruct test {\n    template&lt;typename U&gt;\n    void get() const {\n        std::cout &lt;&lt; &quot;get\\n&quot;;\n    }\n};\n\ntemplate&lt;typename T&gt;\nvoid func(const test&lt;T&gt;&amp; t) {\n    t.get&lt;int&gt;(); // error\n}\n\n\nAttempting to access t.get&lt;int&gt;() from inside the function will result in an error:\n\nmain.cpp:13:11: error: expected primary-expression before &apos;int&apos;\n     t.get&lt;int&gt;();\n           ^\nmain.cpp:13:11: error: expected &apos;;&apos; before &apos;int&apos;\n\n\nThus in this context you would need the template keyword beforehand and call it like so:\n\nt.template get&lt;int&gt;()\n\nThat way the compiler will parse this properly rather than t.get &lt; int.\n    ","url":"https://solutionschecker.com/questions/where-and-why-do-i-have-to-put-the-&quot;template&quot;-and-&quot;typename&quot;-keywords-1657384467606#solution4","@type":"Answer","upvoteCount":0},{"text":"typedef typename Tail::inUnion&lt;U&gt; dummy;\n\n\nHowever, I&apos;m not sure you&apos;re implementation of inUnion is correct. If I understand correctly, this class is not supposed to be instantiated, therefore the &quot;fail&quot; tab will never avtually fails. Maybe it would be better to indicates whether the type is in the union or not with a simple boolean value.\n\ntemplate &lt;typename T, typename TypeList&gt; struct Contains;\n\ntemplate &lt;typename T, typename Head, typename Tail&gt;\nstruct Contains&lt;T, UnionNode&lt;Head, Tail&gt; &gt;\n{\n    enum { result = Contains&lt;T, Tail&gt;::result };\n};\n\ntemplate &lt;typename T, typename Tail&gt;\nstruct Contains&lt;T, UnionNode&lt;T, Tail&gt; &gt;\n{\n    enum { result = true };\n};\n\ntemplate &lt;typename T&gt;\nstruct Contains&lt;T, void&gt;\n{\n    enum { result = false };\n};\n\n\nPS: Have a look at Boost::Variant\n\nPS2: Have a look at typelists, notably in Andrei Alexandrescu&apos;s book: Modern C++ Design\n    ","url":"https://solutionschecker.com/questions/where-and-why-do-i-have-to-put-the-&quot;template&quot;-and-&quot;typename&quot;-keywords-1657384467606#solution5","@type":"Answer","upvoteCount":0},{"text":"C++20 aka C++2a\nAs outlined in this Proposal, C++20 / C++2a has further relaxed the requirements for the typename keyword. In particular, typename may now be omitted in all those places, where syntactically only a type is legal. So, if an unknown token must be a type, C++20 will actually treat it as a type. For backwards compatibility, typename may still be used, though.\nIn particular, most using and typedef declarations can now be written without typename. typename can also be omitted in the declaration of method return types (including trailing return types), in the declaration of method and lambda parameters and in the type argument to static_cast, const_cast, dynamic_cast and reinterpret_cast.\nOne notable exception, where typename is still required, is in the argument list of instantiations of user or library defined templates: Even, if that particular argument was declared to be a type, the typename keyword is still required. So static_cast&lt;A::B&gt;(arg) is legal in C++20, but my_template_class&lt;A::B&gt;(arg) is ill-formed, if A is a dependant scope and my_template_class expects a type.\nA few examples:\nclass A { public: typedef int type; static const int val { 1 }; };\nclass B { public: typedef float type; static const int val { 2 }; };\ntemplate&lt;typename T&gt; class C {};\ntemplate&lt;int I&gt; class D {};\ntemplate&lt;typename T&gt; class X {\n    T::type v;                                  // OK\n    T::type f(T::type arg) { return arg; }      // OK\n    T::type g(double arg) { return static_cast&lt;T::type&gt;(arg); } // OK\n    // C&lt;T::type&gt; c1;                           // error\n    D&lt;T::val&gt; d;                                // OK (as has always been)\n    C&lt;typename T::type&gt; c2;                     // OK (old style)\n    typedef T::type mytype;                     // OK\n    using mytypeagain = T::type;                // OK\n    C&lt;mytype&gt; c3;                               // OK (via typedef / using)\n};\nX&lt;A&gt; xa;\nX&lt;B&gt; xb;\n\n    ","url":"https://solutionschecker.com/questions/where-and-why-do-i-have-to-put-the-&quot;template&quot;-and-&quot;typename&quot;-keywords-1657384467606#solution6","@type":"Answer","upvoteCount":0},{"text":"I am placing JLBorges&apos;s excellent response to a similar question verbatim from cplusplus.com, as it is the most succinct explanation I&apos;ve read on the subject.\n\nIn a template that we write, there are two kinds of names that could be used - dependant names and non- dependant names. A dependant name is a name that depends on a template parameter; a non-dependant name has the same meaning irrespective of what the template parameters are.\nFor example:\ntemplate&lt; typename T &gt; void foo( T&amp; x, std::string str, int count )\n{\n    // these names are looked up during the second phase\n    // when foo is instantiated and the type T is known\n    x.size(); // dependant name (non-type)\n    T::instance_count ; // dependant name (non-type)\n    typename T::iterator i ; // dependant name (type)\n      \n    // during the first phase, \n    // T::instance_count is treated as a non-type (this is the default)\n    // the typename keyword specifies that T::iterator is to be treated as a type.\n\n    // these names are looked up during the first phase\n    std::string::size_type s ; // non-dependant name (type)\n    std::string::npos ; // non-dependant name (non-type)\n    str.empty() ; // non-dependant name (non-type)\n    count ; // non-dependant name (non-type)\n}\n\nWhat a dependant name refers to could be something different for each different instantiation of the template. As a consequence, C++ templates are subject to &quot;two-phase name lookup&quot;. When a template is initially parsed (before any instantiation takes place) the compiler looks up the non-dependent names. When a particular instantiation of the template takes place, the template parameters are known by then, and the compiler looks up dependent names.\nDuring the first phase, the parser needs to know if a dependant name is the name of a type or the name of a non-type. By default, a dependant name is assumed to be the name of a non-type. The typename keyword before a dependant name specifies that it is the name of a type.\n\n\nSummary\nUse the keyword typename only in template declarations and definitions provided you have a qualified name that refers to a type and depends on a template parameter.\n    ","url":"https://solutionschecker.com/questions/where-and-why-do-i-have-to-put-the-&quot;template&quot;-and-&quot;typename&quot;-keywords-1657384467606#solution7","@type":"Answer","upvoteCount":0},{"text":"Dependent name is a name depends on template parameters, we need to instruct compiler in order to compile the template class/function properly before actually instiatiate them.\n\ntypename -&gt; tell compiler the dependent name is an actual type\ntemplate &lt;class T&gt;\nstruct DependentType\n{\n  typename T::type a;\n  using Type=typename T::type;\n};\n\n\n\ntemplate -&gt; tell compiler the dependent name is a template function/class\ntemplate &lt;class T&gt;\nstruct DependentTemplate\n{\n  // template function\n  template &lt;class U&gt;\n  static void func() {}\n\n  // template class\n  template &lt;class U&gt;\n  struct ClassName{};\n};\n\n\ntemplate &lt;class T1, class T2&gt;\nvoid foo()\n{\n  // 3 ways to call a dependent template function\n  DependentTemplate&lt;T1&gt;::template func&lt;T2&gt;();\n  DependentTemplate&lt;T1&gt;().template func&lt;T2&gt;();\n  (new DependentTemplate&lt;T1&gt;())-&gt;template func&lt;T2&gt;();\n\n  // You need both typename and template to reference a dependent template class\n  typename DependentTemplate&lt;T1&gt;::template ClassName&lt;T2&gt; obj;\n  using Type=typename DependentTemplate&lt;T1&gt;::template ClassName&lt;T2&gt;;\n}\n\n\n\n    ","url":"https://solutionschecker.com/questions/where-and-why-do-i-have-to-put-the-&quot;template&quot;-and-&quot;typename&quot;-keywords-1657384467606#solution8","@type":"Answer","upvoteCount":0}],"@type":"Question"}}</script><meta name="next-head-count" content="22"/><script id="google-analytics" data-nscript="beforeInteractive">(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
})(window,document,'script','dataLayer','GTM-NXVLL8B');</script><link rel="preload" href="/_next/static/css/c116652e2d6f4ad0.css" as="style"/><link rel="stylesheet" href="/_next/static/css/c116652e2d6f4ad0.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-0d1b80a048d4787e.js"></script><script src="/_next/static/chunks/webpack-42cdea76c8170223.js" defer=""></script><script src="/_next/static/chunks/framework-4556c45dd113b893.js" defer=""></script><script src="/_next/static/chunks/main-ccfab947c79712f4.js" defer=""></script><script src="/_next/static/chunks/pages/_app-862498b6ec7885c3.js" defer=""></script><script src="/_next/static/chunks/294-106ef8570fa99deb.js" defer=""></script><script src="/_next/static/chunks/490-7f0418bb4354ac73.js" defer=""></script><script src="/_next/static/chunks/pages/questions/%5Bslug%5D-47289857226115f9.js" defer=""></script><script src="/_next/static/xZs8haGjOP63QuDE0kxeX/_buildManifest.js" defer=""></script><script src="/_next/static/xZs8haGjOP63QuDE0kxeX/_ssgManifest.js" defer=""></script></head><body><noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-NXVLL8B"
        height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript><div id="__next"><div class="wrapper"><header><nav class="bg-white border-gray-200 px-4 lg:px-6 py-2.5 dark:bg-gray-800"><div class="flex flex-wrap justify-between items-center mx-auto max-w-screen-xl"><a class="flex items-center" href="/"><img src="/logo-second.png" class="mr-3 h-6 sm:h-9" alt="Solution Checker Logo"/><h1 class="self-center text-xl font-semibold whitespace-nowrap dark:text-white">Solution Checker</h1></a><div class="flex items-center lg:order-2"><button data-collapse-toggle="mobile-menu-2" type="button" class="inline-flex items-center p-2 ml-1 text-sm text-gray-500 rounded-lg lg:hidden hover:bg-gray-100 focus:outline-none focus:ring-2 focus:ring-gray-200 dark:text-gray-400 dark:hover:bg-gray-700 dark:focus:ring-gray-600" aria-controls="mobile-menu-2" aria-expanded="false"><span class="sr-only">Open main menu</span><svg class="w-6 h-6" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M3 5a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM3 10a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM3 15a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1z" clip-rule="evenodd"></path></svg><svg class="hidden w-6 h-6" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z" clip-rule="evenodd"></path></svg></button></div><div class="hidden justify-between items-center w-full lg:flex lg:w-auto lg:order-1" id="mobile-menu-2"><ul class="flex flex-col mt-4 font-medium lg:flex-row lg:space-x-8 lg:mt-0"><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" aria-current="page" href="/">Home</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/questions?tab=news">Questions</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/post?tab=news">Post</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/questions/where-and-why-do-i-have-to-put-the-%22template%22-and-%22typename%22-keywords-1657384467606#">Coding</a></li></ul></div></div></nav></header><div class="main-content"><div class="question my-5"><div class="flex question-header items-center m-auto justify-center"><div class="rounded-xl w-full border p-5 shadow-md bg-white"><div class="flex w-full items-center justify-between border-b pb-3"><div class="flex items-center space-x-3"><div class="text-lg font-bold text-slate-700"><a href="/questions/where-and-why-do-i-have-to-put-the-%22template%22-and-%22typename%22-keywords-1657384467606"><h1>Where and why do I have to put the &quot;template&quot; and &quot;typename&quot; keywords?</h1></a></div></div><div class="flex flex-wrap h-auto justify-end items-center space-x-8"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold" href="/questions/tag/typename">typename</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold" href="/questions/tag/dependent-name">dependent-name</a></div></div><div class="question-content mt-5">
                
<p>In templates, where and why do I have to put <code>typename</code> and <code>template</code> on dependent names?<br>
What exactly are dependent names anyway?  </p>

<p>I have the following code:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> Tail&gt; <span class="hljs-comment">// Tail will be a UnionNode too.</span>
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">UnionNode</span> : <span class="hljs-keyword">public</span> Tail {
    <span class="hljs-comment">// ...</span>
    <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> U&gt; <span class="hljs-keyword">struct</span> <span class="hljs-title class_">inUnion</span> {
        <span class="hljs-comment">// Q: where to add typename/template here?</span>
        <span class="hljs-keyword">typedef</span> Tail::inUnion&lt;U&gt; dummy; 
    };
    <span class="hljs-keyword">template</span>&lt; &gt; <span class="hljs-keyword">struct</span> <span class="hljs-title class_">inUnion</span>&lt;T&gt; {
    };
};
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-comment">// For the last node Tn.</span>
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">UnionNode</span>&lt;T, <span class="hljs-type">void</span>&gt; {
    <span class="hljs-comment">// ...</span>
    <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> U&gt; <span class="hljs-keyword">struct</span> <span class="hljs-title class_">inUnion</span> {
        <span class="hljs-type">char</span> fail[ <span class="hljs-number">-2</span> + (<span class="hljs-built_in">sizeof</span>(U)%<span class="hljs-number">2</span>) ]; <span class="hljs-comment">// Cannot be instantiated for any U</span>
    };
    <span class="hljs-keyword">template</span>&lt; &gt; <span class="hljs-keyword">struct</span> <span class="hljs-title class_">inUnion</span>&lt;T&gt; {
    };
};
</code></pre>

<p>The problem I have is in the <code>typedef Tail::inUnion&lt;U&gt; dummy</code> line. I'm fairly certain that <code>inUnion</code> is a dependent name, and VC++ is quite right in choking on it.<br>
I also know that I should be able to add <code>template</code> somewhere to tell the compiler that inUnion is a template-id. But where exactly? And should it then assume that inUnion is a class template, i.e. <code>inUnion&lt;U&gt;</code> names a type and not a function?</p>
    </div></div></div><div class="solution-section"><nav class="flex pagination-solution flex-col justify-end"><h1 class="text-lg font-semibold mb-5">Navigate to solutions: </h1><ul class="inline-flex -space-x-px overflow-auto"><li class="pagination-solution-item"><span data-id="#solution1" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">1</span></li><li class="pagination-solution-item"><span data-id="#solution2" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">2</span></li><li class="pagination-solution-item"><span data-id="#solution3" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">3</span></li><li class="pagination-solution-item"><span data-id="#solution4" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">4</span></li><li class="pagination-solution-item"><span data-id="#solution5" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">5</span></li><li class="pagination-solution-item"><span data-id="#solution6" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">6</span></li><li class="pagination-solution-item"><span data-id="#solution7" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">7</span></li><li class="pagination-solution-item"><span data-id="#solution8" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">8</span></li></ul></nav><div id="solution1" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 1</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/typename">typename</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/dependent-name">dependent-name</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>(See <a href="https://stackoverflow.com/a/17579889/4561887">here also for my C++11 answer</a>)</p>

<p>In order to parse a C++ program, the compiler needs to know whether certain names are types or not. The following example demonstrates that:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp">t * f;
</code></pre>

<p>How should this be parsed? For many languages a compiler doesn't need to know the meaning of a name in order to parse and basically know what action a line of code does. In C++, the above however can yield vastly different interpretations depending on what <code>t</code> means. If it's a type, then it will be a declaration of a pointer <code>f</code>. However if it's not a type, it will be a multiplication. So the C++ Standard says at paragraph (3/7):</p>

<blockquote>
  <p>Some names denote types or templates. In general, whenever a name is encountered it is necessary to determine whether that name denotes one of these entities before continuing to parse the program that contains it. The process that determines this is called name lookup.</p>
</blockquote>

<p>How will the compiler find out what a name <code>t::x</code> refers to, if <code>t</code> refers to a template type parameter? <code>x</code> could be a static int data member that could be multiplied or could equally well be a nested class or typedef that could yield to a declaration. <strong>If a name has this property - that it can't be looked up until the actual template arguments are known - then it's called a <em>dependent name</em> (it "depends" on the template parameters).</strong> </p>

<p>You might recommend to just wait till the user instantiates the template: </p>

<blockquote>
  <p><em>Let's wait until the user instantiates the template, and then later find out the real meaning of <code>t::x * f;</code>.</em> </p>
</blockquote>

<p>This will work and actually is allowed by the Standard as a possible implementation approach. These compilers basically copy the template's text into an internal buffer, and only when an instantiation is needed, they parse the template and possibly detect errors in the definition. But instead of bothering the template's users (poor colleagues!) with errors made by a template's author, other implementations choose to check templates early on and give errors in the definition as soon as possible, before an instantiation even takes place. </p>

<p>So there has to be a way to tell the compiler that certain names are types and that certain names aren't. </p>

<h2>The "typename" keyword</h2>

<p>The answer is: <em>We</em> decide how the compiler should parse this. If <code>t::x</code> is a dependent name, then we need to prefix it by <code>typename</code> to tell the compiler to parse it in a certain way. The Standard says at (14.6/2):</p>

<blockquote>
  <p>A name used in a template declaration or definition and that is dependent on a template-parameter is
  assumed not to name a type unless the applicable name lookup finds a type name or the name is qualified
  by the keyword typename. </p>
</blockquote>

<p>There are many names for which <code>typename</code> is not necessary, because the compiler can, with the applicable name lookup in the template definition, figure out how to parse a construct itself - for example with <code>T *f;</code>, when <code>T</code> is a type template parameter. But for <code>t::x * f;</code> to be a declaration, it must be written as <code>typename t::x *f;</code>. If you omit the keyword and the name is taken to be a non-type, but when instantiation finds it denotes a type, the usual error messages are emitted by the compiler. Sometimes, the error consequently is given at definition time:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-comment">// t::x is taken as non-type, but as an expression the following misses an</span>
<span class="hljs-comment">// operator between the two names or a semicolon separating them.</span>
t::x f;
</code></pre>

<p><em>The syntax allows <code>typename</code> only before qualified names</em> - it is therefor taken as granted that unqualified names are always known to refer to types if they do so.</p>

<p>A similar gotcha exists for names that denote templates, as hinted at by the introductory text.</p>

<h2>The "template" keyword</h2>

<p>Remember the initial quote above and how the Standard requires special handling for templates as well? Let's take the following innocent-looking example: </p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp">boost::function&lt; <span class="hljs-type">int</span>() &gt; f;
</code></pre>

<p>It might look obvious to a human reader. Not so for the compiler. Imagine the following arbitrary definition of <code>boost::function</code> and <code>f</code>:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-keyword">namespace</span> boost { <span class="hljs-type">int</span> function = <span class="hljs-number">0</span>; }
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{ 
  <span class="hljs-type">int</span> f = <span class="hljs-number">0</span>;
  boost::function&lt; <span class="hljs-type">int</span>() &gt; f; 
}
</code></pre>

<p>That's actually a valid <em>expression</em>! It uses the less-than operator to compare <code>boost::function</code> against zero (<code>int()</code>), and then uses the greater-than operator to compare the resulting <code>bool</code> against <code>f</code>. However as you might well know, <code>boost::function</code> <a href="http://www.boost.org/doc/libs/1_54_0/doc/html/function.html" rel="noreferrer">in real life</a> is a template, so the compiler knows (14.2/3):</p>

<blockquote>
  <p>After name lookup (3.4) finds that a name is a template-name, if this name is followed by a &lt;, the &lt; is
  always taken as the beginning of a template-argument-list and never as a name followed by the less-than
  operator.</p>
</blockquote>

<p>Now we are back to the same problem as with <code>typename</code>. What if we can't know yet whether the name is a template when parsing the code? We will need to insert <code>template</code> immediately before the template name, as specified by <code>14.2/4</code>. This looks like:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp">t::<span class="hljs-keyword">template</span> <span class="hljs-built_in">f</span>&lt;<span class="hljs-type">int</span>&gt;(); <span class="hljs-comment">// call a function template</span>
</code></pre>

<p>Template names can not only occur after a <code>::</code> but also after a <code>-&gt;</code> or <code>.</code> in a class member access. You need to insert the keyword there too:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-keyword">this</span>-&gt;<span class="hljs-keyword">template</span> <span class="hljs-built_in">f</span>&lt;<span class="hljs-type">int</span>&gt;(); <span class="hljs-comment">// call a function template</span>
</code></pre>

<hr>

<h2>Dependencies</h2>

<p>For the people that have thick Standardese books on their shelf and that want to know what exactly I was talking about, I'll talk a bit about how this is specified in the Standard.</p>

<p>In template declarations some constructs have different meanings depending on what template arguments you use to instantiate the template: Expressions may have different types or values, variables may have different types or function calls might end up calling different functions. Such constructs are generally said to <em>depend</em> on template parameters.</p>

<p>The Standard defines precisely the rules by whether a construct is dependent or not. It separates them into logically different groups: One catches types, another catches expressions. Expressions may depend by their value and/or their type. So we have, with typical examples appended:</p>

<ul>
<li>Dependent types (e.g: a type template parameter <code>T</code>)</li>
<li>Value-dependent expressions (e.g: a non-type template parameter <code>N</code>)</li>
<li>Type-dependent expressions (e.g: a cast to a type template parameter <code>(T)0</code>)</li>
</ul>

<p>Most of the rules are intuitive and are built up recursively: For example, a type constructed as <code>T[N]</code> is a dependent type if <code>N</code> is a value-dependent expression or <code>T</code> is a dependent type. The details of this can be read in section <code>(14.6.2/1</code>) for dependent types, <code>(14.6.2.2)</code> for type-dependent expressions and <code>(14.6.2.3)</code> for value-dependent expressions. </p>

<h3>Dependent names</h3>

<p>The Standard is a bit unclear about what <em>exactly</em> is a <em>dependent name</em>. On a simple read (you know, the principle of least surprise), all it defines as a <em>dependent name</em> is the special case for function names below. But since clearly <code>T::x</code> also needs to be looked up in the instantiation context, it also needs to be a dependent name (fortunately, as of mid C++14 the committee has started to look into how to fix this confusing definition). </p>

<p>To avoid this problem, I have resorted to a simple interpretation of the Standard text. Of all the constructs that denote dependent types or expressions, a subset of them represent names. Those names are therefore "dependent names". A name can take different forms - the Standard says:</p>

<blockquote>
  <p>A name is a use of an identifier (2.11), operator-function-id (13.5), conversion-function-id (12.3.2), or template-id (14.2) that denotes an entity or label (6.6.4, 6.1)</p>
</blockquote>

<p>An identifier is just a plain sequence of characters / digits, while the next two are the <code>operator +</code> and <code>operator type</code> form. The last form is <code>template-name &lt;argument list&gt;</code>. All these are names, and by conventional use in the Standard, a name can also include qualifiers that say what namespace or class a name should be looked up in.</p>

<p>A value dependent expression <code>1 + N</code> is not a name, but <code>N</code> is. The subset of all dependent constructs that are names is called <em>dependent name</em>. Function names, however, may have different meaning in different instantiations of a template, but unfortunately are not caught by this general rule. </p>

<h3>Dependent function names</h3>

<p>Not primarily a concern of this article, but still worth mentioning: Function names are an exception that are handled separately. An identifier function name is dependent not by itself, but by the type dependent argument expressions used in a call. In the example <code>f((T)0)</code>, <code>f</code> is a dependent name. In the Standard, this is specified at <code>(14.6.2/1)</code>.</p>

<h2>Additional notes and examples</h2>

<p>In enough cases we need both of <code>typename</code> and <code>template</code>. Your code should look like the following</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> Tail&gt;
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">UnionNode</span> : <span class="hljs-keyword">public</span> Tail {
    <span class="hljs-comment">// ...</span>
    <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> U&gt; <span class="hljs-keyword">struct</span> <span class="hljs-title class_">inUnion</span> {
        <span class="hljs-keyword">typedef</span> <span class="hljs-keyword">typename</span> Tail::<span class="hljs-keyword">template</span> inUnion&lt;U&gt; dummy;
    };
    <span class="hljs-comment">// ...</span>
};
</code></pre>

<p>The keyword <code>template</code> doesn't always have to appear in the last part of a name. It can appear in the middle before a class name that's used as a scope, like in the following example</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-keyword">typename</span> t::<span class="hljs-keyword">template</span> iterator&lt;<span class="hljs-type">int</span>&gt;::value_type v;
</code></pre>

<p>In some cases, the keywords are forbidden, as detailed below</p>

<ul>
<li><p>On the name of a dependent base class you are not allowed to write <code>typename</code>. It's assumed that the name given is a class type name. This is true for both names in the base-class list and the constructor initializer list:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"> <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
 <span class="hljs-keyword">struct</span> <span class="hljs-title class_">derive_from_Has_type</span> : <span class="hljs-comment">/* typename */</span> SomeBase&lt;T&gt;::type 
 { };
</code></pre></li>
<li><p>In using-declarations it's not possible to use <code>template</code> after the last <code>::</code>, and the C++ committee <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_closed.html#109" rel="noreferrer">said</a> not to work on a solution. </p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"> <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
 <span class="hljs-keyword">struct</span> <span class="hljs-title class_">derive_from_Has_type</span> : SomeBase&lt;T&gt; {
    <span class="hljs-keyword">using</span> SomeBase&lt;T&gt;::<span class="hljs-keyword">template</span> type; <span class="hljs-comment">// error</span>
    <span class="hljs-keyword">using</span> <span class="hljs-keyword">typename</span> SomeBase&lt;T&gt;::type; <span class="hljs-comment">// typename *is* allowed</span>
 };
</code></pre></li>
</ul>
    </div></div></div></div><div id="solution2" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 2</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/typename">typename</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/dependent-name">dependent-name</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<h2>C++11</h2>

<h3>Problem</h3>

<p>While the rules in C++03 about when you need <code>typename</code> and <code>template</code> are largely reasonable, there is one annoying disadvantage of its formulation</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">A</span> {
  <span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> result_type;

  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-comment">// error, "this" is dependent, "template" keyword needed</span>
    <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">g</span>&lt;<span class="hljs-type">float</span>&gt;();

    <span class="hljs-comment">// OK</span>
    <span class="hljs-built_in">g</span>&lt;<span class="hljs-type">float</span>&gt;();

    <span class="hljs-comment">// error, "A&lt;T&gt;" is dependent, "typename" keyword needed</span>
    A&lt;T&gt;::result_type n1;

    <span class="hljs-comment">// OK</span>
    result_type n2; 
  }

  <span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> U&gt;
  <span class="hljs-type">void</span> <span class="hljs-title">g</span><span class="hljs-params">()</span></span>;
};
</code></pre>

<p>As can be seen, we need the disambiguation keyword even if the compiler could perfectly figure out itself that <code>A::result_type</code> can only be <code>int</code> (and is hence a type), and <code>this-&gt;g</code> can only be the member template <code>g</code> declared later (even if <code>A</code> is explicitly specialized somewhere, that would not affect the code within that template, so its meaning cannot be affected by a later specialization of <code>A</code>!). </p>

<h3>Current instantiation</h3>

<p>To improve the situation, in C++11 the language tracks when a type refers to the enclosing template. To know that, the type must have been formed by using a certain form of name, which is its own name (in the above, <code>A</code>, <code>A&lt;T&gt;</code>, <code>::A&lt;T&gt;</code>). A type referenced by such a name is known to be  the <em>current instantiation</em>. There may be multiple types that are all the current instantiation if the type from which the name is formed is a member/nested class (then, <code>A::NestedClass</code> and <code>A</code> are both current instantiations). </p>

<p>Based on this notion, the language says that <code>CurrentInstantiation::Foo</code>, <code>Foo</code> and <code>CurrentInstantiationTyped-&gt;Foo</code> (such as <code>A *a = this; a-&gt;Foo</code>) are all <em>member of the current instantiation</em> <strong>if</strong> they are found to be members of a class that is the current instantiation or one of its non-dependent base classes (by just doing the name lookup immediately). </p>

<p>The keywords <code>typename</code> and <code>template</code> are now not required anymore if the qualifier is a member of the current instantiation. A keypoint here to remember is that <code>A&lt;T&gt;</code> is <em>still</em> a type-dependent name (after all <code>T</code> is also type dependent). But <code>A&lt;T&gt;::result_type</code> is known to be a type - the compiler will "magically" look into this kind of dependent types to figure this out. </p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">B</span> {
  <span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> result_type;
};

<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">C</span> { }; <span class="hljs-comment">// could be specialized!</span>

<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">D</span> : B, C&lt;T&gt; {
  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-comment">// OK, member of current instantiation!</span>
    <span class="hljs-comment">// A::result_type is not dependent: int</span>
    D::result_type r1;

    <span class="hljs-comment">// error, not a member of the current instantiation</span>
    D::questionable_type r2;

    <span class="hljs-comment">// OK for now - relying on C&lt;T&gt; to provide it</span>
    <span class="hljs-comment">// But not a member of the current instantiation</span>
    <span class="hljs-keyword">typename</span> D::questionable_type r3;        
  }
};
</code></pre>

<p>That's impressive, but can we do better? The language even goes further and <em>requires</em> that an implementation again looks up <code>D::result_type</code> when instantiating <code>D::f</code> (even if it found its meaning already at definition time). When now the lookup result differs or results in ambiguity, the program is ill-formed and a diagnostic must be given. Imagine what happens if we defined <code>C</code> like this</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-keyword">template</span>&lt;&gt;
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">C</span>&lt;<span class="hljs-type">int</span>&gt; {
  <span class="hljs-keyword">typedef</span> <span class="hljs-type">bool</span> result_type;
  <span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> questionable_type;
};
</code></pre>

<p>A compiler is required to catch the error when instantiating <code>D&lt;int&gt;::f</code>. So you get the best of the two worlds: "Delayed" lookup protecting you if you could get in trouble with dependent base classes, and also "Immediate" lookup that frees you from <code>typename</code> and <code>template</code>. </p>

<h3>Unknown specializations</h3>

<p>In the code of <code>D</code>, the name <code>typename D::questionable_type</code> is not a member of the current instantiation. Instead the language marks it as a <em>member of an unknown specialization</em>. In particular, this is always the case when you are doing <code>DependentTypeName::Foo</code> or <code>DependentTypedName-&gt;Foo</code> and either the dependent type is <em>not</em> the current instantiation (in which case the compiler can give up and say "we will look later what <code>Foo</code> is) or it <em>is</em> the current instantiation and the name was not found in it or its non-dependent base classes and there are also dependent base classes. </p>

<p>Imagine what happens if we had a member function <code>h</code> within the above defined <code>A</code> class template</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">h</span><span class="hljs-params">()</span> </span>{
  <span class="hljs-keyword">typename</span> A&lt;T&gt;::questionable_type x;
}
</code></pre>

<p>In C++03, the language allowed to catch this error because there could never be a valid way to instantiate <code>A&lt;T&gt;::h</code> (whatever argument you give to <code>T</code>). In C++11, the language now has a further check to give more reason for compilers to implement this rule. Since <code>A</code> has no dependent base classes, and <code>A</code> declares no member <code>questionable_type</code>, the name <code>A&lt;T&gt;::questionable_type</code> is <em>neither</em> a member of the current instantiation <em>nor</em> a member of an unknown specialization. In that case, there should be no way that that code could validly compile at instantiation time, so the language forbids a name where the qualifier is the current instantiation to be neither a member of an unknown specialization nor a member of the current instantiation (however, this violation is still not required to be diagnosed).</p>

<h3>Examples and trivia</h3>

<p>You can try this knowledge on <a href="https://stackoverflow.com/a/14005063/34509">this answer</a> and see whether the above definitions make sense for you on a real-world example (they are repeated slightly less detailed in that answer).  </p>

<p>The C++11 rules make the following valid C++03 code ill-formed (which was not intended by the C++ committee, but will probably not be fixed)</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">B</span> { <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span></span>; };
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">A</span> : <span class="hljs-keyword">virtual</span> B { <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span></span>; };

<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">C</span> : <span class="hljs-keyword">virtual</span> B, T {
  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">g</span><span class="hljs-params">()</span> </span>{ <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">f</span>(); }
};

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{ 
  C&lt;A&gt; c; c.<span class="hljs-built_in">g</span>(); 
}
</code></pre>

<p>This valid C++03 code would bind <code>this-&gt;f</code> to <code>A::f</code> at instantiation time and everything is fine. C++11 however immediately binds it to <code>B::f</code> and requires a double-check when instantiating, checking whether the lookup still matches. However when instantiating <code>C&lt;A&gt;::g</code>, the <a href="http://en.wikipedia.org/wiki/Dominance_(C%2B%2B)" rel="noreferrer">Dominance Rule</a> applies and lookup will find <code>A::f</code> instead.</p>
    </div></div></div></div><div id="solution3" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 3</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/typename">typename</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/dependent-name">dependent-name</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<blockquote>
<p><strong>Preface</strong></p>
<p>This post is meant to be an <em>easy-to-read</em> alternative to <a href="https://stackoverflow.com/questions/610245/where-and-why-do-i-have-to-put-the-template-and-typename-keywords/17579889#17579889">litb's post</a>.</p>
</blockquote>
<blockquote>
<p>The underlying purpose is the same; an explanation to "When?" and "Why?" <code>typename</code> and <code>template</code> must be applied.</p>
</blockquote>
<hr>
<h1>What's the purpose of <code>typename</code> and <code>template</code>?</h1>
<p><code>typename</code> and <code>template</code> are usable in circumstances other than when declaring a template.</p>
<p>There are certain contexts in <em>C++</em> where the compiler must explicitly be told how to treat a name, and all these contexts have one thing in common; they depend on at least one <em>template-parameter</em>.</p>
<p>We refer to such names, where there can be an ambiguity in interpretation, as; "<em>dependent names</em>".</p>
<p>This post will offer an explanation to the relationship between <em>dependent-names</em>, and the two keywords.</p>
<hr>
<h2>A snippet says more than 1000 words</h2>
<p>Try to explain what is going on in the following <em>function-template</em>, either to yourself, a friend, or perhaps your cat; what is happening in the statement marked (<em>A</em>)?</p>
<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> T&gt; <span class="hljs-type">void</span> <span class="hljs-title">f_tmpl</span> <span class="hljs-params">()</span> </span>{ T::foo * x; <span class="hljs-comment">/* &lt;-- (A) */</span> }
</code></pre>
<p><sup><br></sup>
It might not be as easy as one thinks, more specifically the result of evaluating (<em>A</em>) heavily <em>depends</em> on the definition of the type passed as template-parameter <code>T</code>.</p>
<p>Different <code>T</code>s can drastically change the semantics involved.</p>
<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">X</span> { <span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span>       foo;       }; <span class="hljs-comment">/* (C) --&gt; */</span> <span class="hljs-built_in">f_tmpl</span>&lt;X&gt; ();
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">Y</span> { <span class="hljs-type">static</span>  <span class="hljs-type">int</span> <span class="hljs-type">const</span> foo = <span class="hljs-number">123</span>; }; <span class="hljs-comment">/* (D) --&gt; */</span> <span class="hljs-built_in">f_tmpl</span>&lt;Y&gt; ();
</code></pre>
<p><sup><br></sup></p>
<p><strong>The two different scenarios</strong>:</p>
<ul>
<li><p>If we instantiate the function-template with type <em>X</em>, as in (<em>C</em>), we will have a declaration of a <em>pointer-to int</em> named <em>x</em>, but;</p>
</li>
<li><p>if we instantiate the template with type <em>Y</em>, as in (<em>D</em>), (<em>A</em>) would instead consist of an expression that calculates the product of <em>123</em> multiplied with some already declared variable <em>x</em>.</p>
</li>
</ul>
<br>
<hr>
<h2>The Rationale</h2>
<p>The C++ Standard cares about our safety and well-being, at least in this case.</p>
<p>To prevent an implementation from potentially suffering from nasty surprises, the Standard mandates that we sort out the ambiguity of a <em>dependent-name</em> by <em>explicitly</em> stating the intent anywhere we'd like to treat the name as either a <em>type-name</em>, or a <em>template-id</em>.</p>
<p>If nothing is stated, the <em>dependent-name</em> will be considered to be either a variable, or a function.</p>
<br>
<hr>
<h2>How to handle dependent names?</h2>
<p>If this was a Hollywood film, <em>dependent-names</em> would be the disease that spreads through body contact, instantly affects its host to make it confused. Confusion that could, possibly, lead to an ill-formed perso-, erhm.. program.</p>
<p>A <em>dependent-name</em> is <strong>any</strong> name that directly, or indirectly, depends on a <em>template-parameter</em>.
<sup><br><br></sup></p>
<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> T&gt; <span class="hljs-type">void</span> <span class="hljs-title">g_tmpl</span> <span class="hljs-params">()</span> </span>{
   SomeTrait&lt;T&gt;::type                   foo; <span class="hljs-comment">// (E), ill-formed</span>
   SomeTrait&lt;T&gt;::NestedTrait&lt;<span class="hljs-type">int</span>&gt;::type bar; <span class="hljs-comment">// (F), ill-formed</span>
   foo.<span class="hljs-built_in">data</span>&lt;<span class="hljs-type">int</span>&gt; ();                         <span class="hljs-comment">// (G), ill-formed    </span>
}
</code></pre>
<p>We have four <em>dependent</em> names in the above snippet:</p>
<ul>
<li><strong>E</strong>)
<ul>
<li><strong>"type"</strong> depends on the instantiation of <code>SomeTrait&lt;T&gt;</code>, which include <code>T</code>, and;</li>
</ul>
</li>
<li><strong>F</strong>)
<ul>
<li><strong>"NestedTrait"</strong>, which is a <em>template-id</em>, depends on <code>SomeTrait&lt;T&gt;</code>, and;</li>
<li><strong>"type"</strong> at the end of (<em>F</em>) depends on <em>NestedTrait</em>, which depends on <code>SomeTrait&lt;T&gt;</code>, and;</li>
</ul>
</li>
<li><strong>G</strong>)
<ul>
<li><strong>"data"</strong>, which looks like a <em>member-function template</em>, is indirectly a <em>dependent-name</em> since the type of <em>foo</em> depends on the instantiation of <code>SomeTrait&lt;T&gt;</code>.</li>
</ul>
</li>
</ul>
<p>Neither of statement (<em>E</em>), (<em>F</em>) or (<em>G</em>) is valid if the compiler would interpret the <em>dependent-names</em> as variables/functions (which as stated earlier is what happens if we don't explicitly say otherwise).
<sup><br><br></sup></p>
<h3>The solution</h3>
<p>To make <code>g_tmpl</code> have a valid definition we must explicitly tell the compiler that we expect a type in (<em>E</em>), a <em>template-id</em> and a <em>type</em> in (<em>F</em>), and a <em>template-id</em> in (<em>G</em>).</p>
<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> T&gt; <span class="hljs-type">void</span> <span class="hljs-title">g_tmpl</span> <span class="hljs-params">()</span> </span>{
   <span class="hljs-keyword">typename</span> SomeTrait&lt;T&gt;::type foo;                            <span class="hljs-comment">// (G), legal</span>
   <span class="hljs-keyword">typename</span> SomeTrait&lt;T&gt;::<span class="hljs-keyword">template</span> NestedTrait&lt;<span class="hljs-type">int</span>&gt;::type bar; <span class="hljs-comment">// (H), legal</span>
   foo.<span class="hljs-keyword">template</span> <span class="hljs-built_in">data</span>&lt;<span class="hljs-type">int</span>&gt; ();                                  <span class="hljs-comment">// (I), legal</span>
}
</code></pre>
<p>Every time a <em>name</em> denotes a type, <strong>all</strong> <em>names</em> involved must be either <em>type-names</em> or <em>namespaces</em>, with this in mind it's quite easy to see that we apply <code>typename</code> at the beginning of our fully <em>qualified name</em>.</p>
<p><code>template</code> however, is different in this regard, since there's no way of coming to a conclusion such as; <em>"oh, this is a template, then this other thing must also be a template"</em>. This means that we apply <code>template</code> directly in front of any <em>name</em> that we'd like to treat as such.</p>
<br>
<hr>
<h2>Can I just stick the <em>keywords</em> in front of any name?</h2>
<blockquote>
<p>"<em>Can I just stick <code>typename</code> and <code>template</code> in front of any name? I don't want to worry about the context in which they appear...</em>" - <code>Some C++ Developer</code></p>
</blockquote>
<p>The rules in the Standard states that you may apply the keywords as long as you are dealing with a <em>qualified-name</em> (<em>K</em>), but if the name isn't <em>qualified</em> the application is ill-formed (<em>L</em>).</p>
<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-keyword">namespace</span> N {
  <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;
  <span class="hljs-keyword">struct</span> <span class="hljs-title class_">X</span> { };
}
</code></pre>
<p><sup></sup></p>
<pre class="lang-cpp s-code-block"><code class="hljs language-cpp">         N::         X&lt;<span class="hljs-type">int</span>&gt; a; <span class="hljs-comment">// ...  legal</span>
<span class="hljs-keyword">typename</span> N::<span class="hljs-keyword">template</span> X&lt;<span class="hljs-type">int</span>&gt; b; <span class="hljs-comment">// (K), legal</span>
<span class="hljs-keyword">typename</span> <span class="hljs-keyword">template</span>    X&lt;<span class="hljs-type">int</span>&gt; c; <span class="hljs-comment">// (L), ill-formed</span>
</code></pre>
<p><sup><strong>Note</strong>: Applying <code>typename</code> or <code>template</code> in a context where it is not required is not considered good practice; just because you can do something, doesn't mean that you should.</sup></p>
<br>
<p>Additionally there are contexts where <code>typename</code> and <code>template</code> are <strong>explicitly</strong> disallowed:</p>
<ul>
<li><p><strong>When specifying the bases of which a class inherits</strong></p>
<p>Every name written in a derived class's <em>base-specifier-list</em> is already treated as a <em>type-name</em>, explicitly specifying <code>typename</code> is both ill-formed, and redundant.</p>
<pre class="lang-cpp s-code-block"><code class="hljs language-cpp">                    <span class="hljs-comment">// .------- the base-specifier-list</span>
  <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt; <span class="hljs-comment">// v</span>
  <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Derived</span>      : <span class="hljs-keyword">typename</span> SomeTrait&lt;T&gt;::type <span class="hljs-comment">/* &lt;- ill-formed */</span> {
    ...
  };
</code></pre>
 <br>
</li>
<li><p><strong>When the <em>template-id</em> is the one being referred to in a derived class's <em>using-directive</em></strong></p>
<pre class="lang-cpp s-code-block"><code class="hljs language-cpp">  <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Base</span> {
    <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;
    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">type</span> { };
  };

  <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Derived</span> : Base {
    <span class="hljs-keyword">using</span> Base::<span class="hljs-keyword">template</span> type; <span class="hljs-comment">// ill-formed</span>
    <span class="hljs-keyword">using</span> Base::type;          <span class="hljs-comment">// legal</span>
  };
</code></pre>
</li>
</ul>
    </div></div></div></div><div id="solution4" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 4</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/typename">typename</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/dependent-name">dependent-name</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p><sub>
<em>This answer is meant to be a rather short and sweet one to answer (part of) the titled question. If you want an answer with more detail that explains why you have to put them there, please go <a href="https://stackoverflow.com/a/613132/1381108">here</a>.</em>
</sub></p>

<hr>

<p>The general rule for putting the <code>typename</code> keyword is mostly when you're using a template parameter and you want to access a nested <code>typedef</code> or using-alias, for example:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">test</span> {
    <span class="hljs-keyword">using</span> type = T; <span class="hljs-comment">// no typename required</span>
    <span class="hljs-keyword">using</span> underlying_type = <span class="hljs-keyword">typename</span> T::type <span class="hljs-comment">// typename required</span>
};
</code></pre>

<p>Note that this also applies for meta functions or things that take generic template parameters too. However, if the template parameter provided is an explicit type then you don't have to specify <code>typename</code>, for example:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">test</span> {
    <span class="hljs-comment">// typename required</span>
    <span class="hljs-keyword">using</span> type = <span class="hljs-keyword">typename</span> std::conditional&lt;<span class="hljs-literal">true</span>, <span class="hljs-type">const</span> T&amp;, T&amp;&amp;&gt;::type;
    <span class="hljs-comment">// no typename required</span>
    <span class="hljs-keyword">using</span> integer = std::conditional&lt;<span class="hljs-literal">true</span>, <span class="hljs-type">int</span>, <span class="hljs-type">float</span>&gt;::type;
};
</code></pre>

<p>The general rules for adding the <code>template</code> qualifier are mostly similar except they typically involve templated member functions (static or otherwise) of a struct/class that is itself templated, for example:</p>

<p>Given this struct and function:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">test</span> {
    <span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> U&gt;
    <span class="hljs-type">void</span> <span class="hljs-title">get</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>{
        std::cout &lt;&lt; <span class="hljs-string">"get\n"</span>;
    }
};

<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">const</span> test&lt;T&gt;&amp; t)</span> </span>{
    t.<span class="hljs-built_in">get</span>&lt;<span class="hljs-type">int</span>&gt;(); <span class="hljs-comment">// error</span>
}
</code></pre>

<p>Attempting to access <code>t.get&lt;int&gt;()</code> from inside the function will result in an error:</p>

<pre class="lang-none s-code-block"><code>main.cpp:13:11: error: expected primary-expression before 'int'
     t.get&lt;int&gt;();
           ^
main.cpp:13:11: error: expected ';' before 'int'
</code></pre>

<p>Thus in this context you would need the <code>template</code> keyword beforehand and call it like so:</p>

<p><code>t.template get&lt;int&gt;()</code></p>

<p>That way the compiler will parse this properly rather than <code>t.get &lt; int</code>.</p>
    </div></div></div></div><div id="solution5" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 5</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/typename">typename</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/dependent-name">dependent-name</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">typename</span> Tail::inUnion&lt;U&gt; dummy;
</code></pre>

<p>However, I'm not sure you're implementation of inUnion is correct. If I understand correctly, this class is not supposed to be instantiated, therefore the "fail" tab will never avtually fails. Maybe it would be better to indicates whether the type is in the union or not with a simple boolean value.</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> TypeList&gt; <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Contains</span>;

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> Head, <span class="hljs-keyword">typename</span> Tail&gt;
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">Contains</span>&lt;T, UnionNode&lt;Head, Tail&gt; &gt;
{
    <span class="hljs-keyword">enum</span> { result = Contains&lt;T, Tail&gt;::result };
};

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> Tail&gt;
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">Contains</span>&lt;T, UnionNode&lt;T, Tail&gt; &gt;
{
    <span class="hljs-keyword">enum</span> { result = <span class="hljs-literal">true</span> };
};

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">Contains</span>&lt;T, <span class="hljs-type">void</span>&gt;
{
    <span class="hljs-keyword">enum</span> { result = <span class="hljs-literal">false</span> };
};
</code></pre>

<p>PS: Have a look at <a href="http://www.boost.org/doc/libs/1_38_0/doc/html/variant.html" rel="noreferrer">Boost::Variant</a></p>

<p>PS2: Have a look at <a href="http://www.ddj.com/cpp/184403813" rel="noreferrer">typelists</a>, notably in Andrei Alexandrescu's book: Modern C++ Design</p>
    </div></div></div></div><div id="solution6" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 6</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/typename">typename</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/dependent-name">dependent-name</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<h2>C++20 aka C++2a</h2>
<p>As outlined in this <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0634r3.html" rel="noreferrer">Proposal</a>, C++20 / C++2a has further relaxed the requirements for the <code>typename</code> keyword. In particular, <code>typename</code> may now be omitted in all those places, where syntactically only a type is legal. So, if an unknown token must be a type, C++20 will actually treat it as a type. For backwards compatibility, <code>typename</code> may still be used, though.</p>
<p>In particular, most <code>using</code> and <code>typedef</code> declarations can now be written without <code>typename</code>. <code>typename</code> can also be omitted in the declaration of method return types (including trailing return types), in the declaration of method and lambda parameters and in the type argument to <code>static_cast</code>, <code>const_cast</code>, <code>dynamic_cast</code> and <code>reinterpret_cast</code>.</p>
<p>One notable exception, where <code>typename</code> is still required, is in the argument list of instantiations of user or library defined templates: Even, if that particular argument was declared to be a type, the <code>typename</code> keyword is still required. So <code>static_cast&lt;A::B&gt;(arg)</code> is legal in C++20, but <code>my_template_class&lt;A::B&gt;(arg)</code> is ill-formed, if A is a dependant scope and <code>my_template_class</code> expects a type.</p>
<p>A few examples:</p>
<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> { <span class="hljs-keyword">public</span>: <span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> type; <span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">int</span> val { <span class="hljs-number">1</span> }; };
<span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> { <span class="hljs-keyword">public</span>: <span class="hljs-keyword">typedef</span> <span class="hljs-type">float</span> type; <span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">int</span> val { <span class="hljs-number">2</span> }; };
<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-keyword">class</span> <span class="hljs-title class_">C</span> {};
<span class="hljs-keyword">template</span>&lt;<span class="hljs-type">int</span> I&gt; <span class="hljs-keyword">class</span> <span class="hljs-title class_">D</span> {};
<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-keyword">class</span> <span class="hljs-title class_">X</span> {
    T::type v;                                  <span class="hljs-comment">// OK</span>
    <span class="hljs-function">T::type <span class="hljs-title">f</span><span class="hljs-params">(T::type arg)</span> </span>{ <span class="hljs-keyword">return</span> arg; }      <span class="hljs-comment">// OK</span>
    <span class="hljs-function">T::type <span class="hljs-title">g</span><span class="hljs-params">(<span class="hljs-type">double</span> arg)</span> </span>{ <span class="hljs-keyword">return</span> <span class="hljs-built_in">static_cast</span>&lt;T::type&gt;(arg); } <span class="hljs-comment">// OK</span>
    <span class="hljs-comment">// C&lt;T::type&gt; c1;                           // error</span>
    D&lt;T::val&gt; d;                                <span class="hljs-comment">// OK (as has always been)</span>
    C&lt;<span class="hljs-keyword">typename</span> T::type&gt; c2;                     <span class="hljs-comment">// OK (old style)</span>
    <span class="hljs-keyword">typedef</span> T::type mytype;                     <span class="hljs-comment">// OK</span>
    <span class="hljs-keyword">using</span> mytypeagain = T::type;                <span class="hljs-comment">// OK</span>
    C&lt;mytype&gt; c3;                               <span class="hljs-comment">// OK (via typedef / using)</span>
};
X&lt;A&gt; xa;
X&lt;B&gt; xb;
</code></pre>
    </div></div></div></div><div id="solution7" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 7</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/typename">typename</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/dependent-name">dependent-name</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>I am placing JLBorges's excellent <a href="http://www.cplusplus.com/forum/general/122765/#msg669061" rel="nofollow noreferrer">response</a> to a similar question verbatim from cplusplus.com, as it is the most succinct explanation I've read on the subject.</p>
<blockquote>
<p>In a template that we write, there are two kinds of names that could be used - dependant names and non- dependant names. A dependant name is a name that depends on a template parameter; a non-dependant name has the same meaning irrespective of what the template parameters are.</p>
<p>For example:</p>
<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt; <span class="hljs-keyword">typename</span> T &gt; <span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">( T&amp; x, std::string str, <span class="hljs-type">int</span> count )</span>
</span>{
    <span class="hljs-comment">// these names are looked up during the second phase</span>
    <span class="hljs-comment">// when foo is instantiated and the type T is known</span>
    x.<span class="hljs-built_in">size</span>(); <span class="hljs-comment">// dependant name (non-type)</span>
    T::instance_count ; <span class="hljs-comment">// dependant name (non-type)</span>
    <span class="hljs-keyword">typename</span> T::iterator i ; <span class="hljs-comment">// dependant name (type)</span>
      
    <span class="hljs-comment">// during the first phase, </span>
    <span class="hljs-comment">// T::instance_count is treated as a non-type (this is the default)</span>
    <span class="hljs-comment">// the typename keyword specifies that T::iterator is to be treated as a type.</span>

    <span class="hljs-comment">// these names are looked up during the first phase</span>
    std::string::size_type s ; <span class="hljs-comment">// non-dependant name (type)</span>
    std::string::npos ; <span class="hljs-comment">// non-dependant name (non-type)</span>
    str.<span class="hljs-built_in">empty</span>() ; <span class="hljs-comment">// non-dependant name (non-type)</span>
    count ; <span class="hljs-comment">// non-dependant name (non-type)</span>
}
</code></pre>
<p>What a dependant name refers to could be something different for each different instantiation of the template. As a consequence, C++ templates are subject to "two-phase name lookup". When a template is initially parsed (before any instantiation takes place) the compiler looks up the non-dependent names. When a particular instantiation of the template takes place, the template parameters are known by then, and the compiler looks up dependent names.</p>
<p>During the first phase, the parser needs to know if a dependant name is the name of a type or the name of a non-type. By default, a dependant name is assumed to be the name of a non-type. The typename keyword before a dependant name specifies that it is the name of a type.</p>
</blockquote>
<hr>
<p><strong>Summary</strong></p>
<p>Use the keyword typename only in template declarations and definitions provided you have a qualified name that refers to a type and depends on a template parameter.</p>
    </div></div></div></div><div id="solution8" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 8</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/typename">typename</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/dependent-name">dependent-name</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Dependent name is a name depends on template parameters, we need to instruct compiler in order to compile the template class/function properly before actually instiatiate them.</p>
<ul>
<li><p>typename -&gt; tell compiler the dependent name is an actual type</p>
<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">DependentType</span>
{
  <span class="hljs-keyword">typename</span> T::type a;
  <span class="hljs-keyword">using</span> Type=<span class="hljs-keyword">typename</span> T::type;
};

</code></pre>
</li>
<li><p>template -&gt; tell compiler the dependent name is a template function/class</p>
<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">DependentTemplate</span>
{
  <span class="hljs-comment">// template function</span>
  <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">U</span>&gt;
  <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span> </span>{}

  <span class="hljs-comment">// template class</span>
  <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">U</span>&gt;
  <span class="hljs-keyword">struct</span> <span class="hljs-title class_">ClassName</span>{};
};


<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T1</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">T2</span>&gt;
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span>
</span>{
  <span class="hljs-comment">// 3 ways to call a dependent template function</span>
  DependentTemplate&lt;T1&gt;::<span class="hljs-keyword">template</span> <span class="hljs-built_in">func</span>&lt;T2&gt;();
  <span class="hljs-built_in">DependentTemplate</span>&lt;T1&gt;().<span class="hljs-keyword">template</span> <span class="hljs-built_in">func</span>&lt;T2&gt;();
  (<span class="hljs-keyword">new</span> <span class="hljs-built_in">DependentTemplate</span>&lt;T1&gt;())-&gt;<span class="hljs-keyword">template</span> <span class="hljs-built_in">func</span>&lt;T2&gt;();

  <span class="hljs-comment">// You need both typename and template to reference a dependent template class</span>
  <span class="hljs-keyword">typename</span> DependentTemplate&lt;T1&gt;::<span class="hljs-keyword">template</span> ClassName&lt;T2&gt; obj;
  <span class="hljs-keyword">using</span> Type=<span class="hljs-keyword">typename</span> DependentTemplate&lt;T1&gt;::<span class="hljs-keyword">template</span> ClassName&lt;T2&gt;;
}
</code></pre>
</li>
</ul>
    </div></div></div></div></div></div><div class="widget"><a href="/questions/how-do-i-determine-the-correct-path-for-fxml-files-css-files-images-and-other-resources-needed-by-my-javafx-application-1657388143988">How do I determine the correct path for FXML files, CSS files, Images, and other resources needed by my JavaFX Application?</a><a href="/questions/why-use-integer-instead-of-long-1657388012352">Why Use Integer Instead of Long?</a><a href="/questions/how-to-access-the-correct-this-inside-a-callback-1657384283261">How to access the correct `this` inside a callback</a><a href="/questions/how-do-i-set-a-variable-to-the-output-of-a-command-in-bash-1657387250909">How do I set a variable to the output of a command in Bash?</a><a href="/questions/mysql-pivot-row-into-dynamic-number-of-columns-1657387981930">MySQL pivot row into dynamic number of columns</a><a href="/questions/how-to-remove-items-from-a-list-while-iterating-1657384496375">How to remove items from a list while iterating?</a><a href="/questions/gui-not-working-after-rewriting-to-mvc-1657388388035">GUI not working after rewriting to MVC</a><a href="/questions/what-is-the-strict-aliasing-rule-1657384742852">What is the strict aliasing rule?</a><a href="/questions/are-&#x27;arrow-functions&#x27;-and-&#x27;functions&#x27;-equivalent-interchangeable-1657384527873">Are &#x27;Arrow Functions&#x27; and &#x27;Functions&#x27; equivalent / interchangeable?</a><a href="/questions/how-do-i-profile-c++-code-running-on-linux-1657384754272">How do I profile C++ code running on Linux?</a><a href="/questions/why-does-date.parse-give-incorrect-results-1657384642821">Why does Date.parse give incorrect results?</a><a href="/questions/javascript-property-access:-dot-notation-vs.-brackets-1657384717494">JavaScript property access: dot notation vs. brackets?</a><a href="/questions/are-dictionaries-ordered-in-python-3.6+-1657387834234">Are dictionaries ordered in Python 3.6+?</a><a href="/questions/how-do-i-use-arrays-in-c++-1657387456118">How do I use arrays in C++?</a><a href="/questions/jquery-ajax-file-upload-1657387368970">jQuery Ajax File Upload</a><a href="/questions/most-efficient-method-to-groupby-on-an-array-of-objects-1657387580538">Most efficient method to groupby on an array of objects</a><a href="/questions/css-selector-for-first-element-with-class-1657388028765">CSS selector for first element with class</a><a href="/questions/how-do-i-format-a-date-in-javascript-1657384649498">How do I format a date in JavaScript?</a><a href="/questions/crash-or-%22segmentation-fault%22-when-data-is-copiedscannedread-to-an-uninitialized-pointer-1657387520581">Crash or &quot;segmentation fault&quot; when data is copied/scanned/read to an uninitialized pointer</a><a href="/questions/what-is-dependency-injection-1657387953056">What is dependency injection?</a></div></div><span class="cursor-pointer text-lg p-2" style="position:fixed;bottom:20px;left:20px;background:#000;z-index:2000;color:white">Go go top</span></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"data":{"answer":["\n\u0026lt;p\u0026gt;(See \u0026lt;a href=\u0026quot;https://stackoverflow.com/a/17579889/4561887\u0026quot;\u0026gt;here also for my C++11 answer\u0026lt;/a\u0026gt;)\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;In order to parse a C++ program, the compiler needs to know whether certain names are types or not. The following example demonstrates that:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;t * f;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;How should this be parsed? For many languages a compiler doesn\u0026apos;t need to know the meaning of a name in order to parse and basically know what action a line of code does. In C++, the above however can yield vastly different interpretations depending on what \u0026lt;code\u0026gt;t\u0026lt;/code\u0026gt; means. If it\u0026apos;s a type, then it will be a declaration of a pointer \u0026lt;code\u0026gt;f\u0026lt;/code\u0026gt;. However if it\u0026apos;s not a type, it will be a multiplication. So the C++ Standard says at paragraph (3/7):\u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;Some names denote types or templates. In general, whenever a name is encountered it is necessary to determine whether that name denotes one of these entities before continuing to parse the program that contains it. The process that determines this is called name lookup.\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;p\u0026gt;How will the compiler find out what a name \u0026lt;code\u0026gt;t::x\u0026lt;/code\u0026gt; refers to, if \u0026lt;code\u0026gt;t\u0026lt;/code\u0026gt; refers to a template type parameter? \u0026lt;code\u0026gt;x\u0026lt;/code\u0026gt; could be a static int data member that could be multiplied or could equally well be a nested class or typedef that could yield to a declaration. \u0026lt;strong\u0026gt;If a name has this property - that it can\u0026apos;t be looked up until the actual template arguments are known - then it\u0026apos;s called a \u0026lt;em\u0026gt;dependent name\u0026lt;/em\u0026gt; (it \u0026quot;depends\u0026quot; on the template parameters).\u0026lt;/strong\u0026gt; \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;You might recommend to just wait till the user instantiates the template: \u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;\u0026lt;em\u0026gt;Let\u0026apos;s wait until the user instantiates the template, and then later find out the real meaning of \u0026lt;code\u0026gt;t::x * f;\u0026lt;/code\u0026gt;.\u0026lt;/em\u0026gt; \u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;p\u0026gt;This will work and actually is allowed by the Standard as a possible implementation approach. These compilers basically copy the template\u0026apos;s text into an internal buffer, and only when an instantiation is needed, they parse the template and possibly detect errors in the definition. But instead of bothering the template\u0026apos;s users (poor colleagues!) with errors made by a template\u0026apos;s author, other implementations choose to check templates early on and give errors in the definition as soon as possible, before an instantiation even takes place. \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;So there has to be a way to tell the compiler that certain names are types and that certain names aren\u0026apos;t. \u0026lt;/p\u0026gt;\n\n\u0026lt;h2\u0026gt;The \u0026quot;typename\u0026quot; keyword\u0026lt;/h2\u0026gt;\n\n\u0026lt;p\u0026gt;The answer is: \u0026lt;em\u0026gt;We\u0026lt;/em\u0026gt; decide how the compiler should parse this. If \u0026lt;code\u0026gt;t::x\u0026lt;/code\u0026gt; is a dependent name, then we need to prefix it by \u0026lt;code\u0026gt;typename\u0026lt;/code\u0026gt; to tell the compiler to parse it in a certain way. The Standard says at (14.6/2):\u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;A name used in a template declaration or definition and that is dependent on a template-parameter is\n  assumed not to name a type unless the applicable name lookup finds a type name or the name is qualified\n  by the keyword typename. \u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;p\u0026gt;There are many names for which \u0026lt;code\u0026gt;typename\u0026lt;/code\u0026gt; is not necessary, because the compiler can, with the applicable name lookup in the template definition, figure out how to parse a construct itself - for example with \u0026lt;code\u0026gt;T *f;\u0026lt;/code\u0026gt;, when \u0026lt;code\u0026gt;T\u0026lt;/code\u0026gt; is a type template parameter. But for \u0026lt;code\u0026gt;t::x * f;\u0026lt;/code\u0026gt; to be a declaration, it must be written as \u0026lt;code\u0026gt;typename t::x *f;\u0026lt;/code\u0026gt;. If you omit the keyword and the name is taken to be a non-type, but when instantiation finds it denotes a type, the usual error messages are emitted by the compiler. Sometimes, the error consequently is given at definition time:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// t::x is taken as non-type, but as an expression the following misses an\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// operator between the two names or a semicolon separating them.\u0026lt;/span\u0026gt;\nt::x f;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;em\u0026gt;The syntax allows \u0026lt;code\u0026gt;typename\u0026lt;/code\u0026gt; only before qualified names\u0026lt;/em\u0026gt; - it is therefor taken as granted that unqualified names are always known to refer to types if they do so.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;A similar gotcha exists for names that denote templates, as hinted at by the introductory text.\u0026lt;/p\u0026gt;\n\n\u0026lt;h2\u0026gt;The \u0026quot;template\u0026quot; keyword\u0026lt;/h2\u0026gt;\n\n\u0026lt;p\u0026gt;Remember the initial quote above and how the Standard requires special handling for templates as well? Let\u0026apos;s take the following innocent-looking example: \u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;boost::function\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;() \u0026amp;gt; f;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;It might look obvious to a human reader. Not so for the compiler. Imagine the following arbitrary definition of \u0026lt;code\u0026gt;boost::function\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;f\u0026lt;/code\u0026gt;:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;namespace\u0026lt;/span\u0026gt; boost { \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; function = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;; }\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;main\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt; \u0026lt;/span\u0026gt;{ \n  \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; f = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;;\n  boost::function\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;() \u0026amp;gt; f; \n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;That\u0026apos;s actually a valid \u0026lt;em\u0026gt;expression\u0026lt;/em\u0026gt;! It uses the less-than operator to compare \u0026lt;code\u0026gt;boost::function\u0026lt;/code\u0026gt; against zero (\u0026lt;code\u0026gt;int()\u0026lt;/code\u0026gt;), and then uses the greater-than operator to compare the resulting \u0026lt;code\u0026gt;bool\u0026lt;/code\u0026gt; against \u0026lt;code\u0026gt;f\u0026lt;/code\u0026gt;. However as you might well know, \u0026lt;code\u0026gt;boost::function\u0026lt;/code\u0026gt; \u0026lt;a href=\u0026quot;http://www.boost.org/doc/libs/1_54_0/doc/html/function.html\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;in real life\u0026lt;/a\u0026gt; is a template, so the compiler knows (14.2/3):\u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;After name lookup (3.4) finds that a name is a template-name, if this name is followed by a \u0026amp;lt;, the \u0026amp;lt; is\n  always taken as the beginning of a template-argument-list and never as a name followed by the less-than\n  operator.\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;p\u0026gt;Now we are back to the same problem as with \u0026lt;code\u0026gt;typename\u0026lt;/code\u0026gt;. What if we can\u0026apos;t know yet whether the name is a template when parsing the code? We will need to insert \u0026lt;code\u0026gt;template\u0026lt;/code\u0026gt; immediately before the template name, as specified by \u0026lt;code\u0026gt;14.2/4\u0026lt;/code\u0026gt;. This looks like:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;t::\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;f\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;\u0026amp;gt;(); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// call a function template\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Template names can not only occur after a \u0026lt;code\u0026gt;::\u0026lt;/code\u0026gt; but also after a \u0026lt;code\u0026gt;-\u0026amp;gt;\u0026lt;/code\u0026gt; or \u0026lt;code\u0026gt;.\u0026lt;/code\u0026gt; in a class member access. You need to insert the keyword there too:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;this\u0026lt;/span\u0026gt;-\u0026amp;gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;f\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;\u0026amp;gt;(); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// call a function template\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;hr\u0026gt;\n\n\u0026lt;h2\u0026gt;Dependencies\u0026lt;/h2\u0026gt;\n\n\u0026lt;p\u0026gt;For the people that have thick Standardese books on their shelf and that want to know what exactly I was talking about, I\u0026apos;ll talk a bit about how this is specified in the Standard.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;In template declarations some constructs have different meanings depending on what template arguments you use to instantiate the template: Expressions may have different types or values, variables may have different types or function calls might end up calling different functions. Such constructs are generally said to \u0026lt;em\u0026gt;depend\u0026lt;/em\u0026gt; on template parameters.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;The Standard defines precisely the rules by whether a construct is dependent or not. It separates them into logically different groups: One catches types, another catches expressions. Expressions may depend by their value and/or their type. So we have, with typical examples appended:\u0026lt;/p\u0026gt;\n\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;Dependent types (e.g: a type template parameter \u0026lt;code\u0026gt;T\u0026lt;/code\u0026gt;)\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Value-dependent expressions (e.g: a non-type template parameter \u0026lt;code\u0026gt;N\u0026lt;/code\u0026gt;)\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Type-dependent expressions (e.g: a cast to a type template parameter \u0026lt;code\u0026gt;(T)0\u0026lt;/code\u0026gt;)\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\n\u0026lt;p\u0026gt;Most of the rules are intuitive and are built up recursively: For example, a type constructed as \u0026lt;code\u0026gt;T[N]\u0026lt;/code\u0026gt; is a dependent type if \u0026lt;code\u0026gt;N\u0026lt;/code\u0026gt; is a value-dependent expression or \u0026lt;code\u0026gt;T\u0026lt;/code\u0026gt; is a dependent type. The details of this can be read in section \u0026lt;code\u0026gt;(14.6.2/1\u0026lt;/code\u0026gt;) for dependent types, \u0026lt;code\u0026gt;(14.6.2.2)\u0026lt;/code\u0026gt; for type-dependent expressions and \u0026lt;code\u0026gt;(14.6.2.3)\u0026lt;/code\u0026gt; for value-dependent expressions. \u0026lt;/p\u0026gt;\n\n\u0026lt;h3\u0026gt;Dependent names\u0026lt;/h3\u0026gt;\n\n\u0026lt;p\u0026gt;The Standard is a bit unclear about what \u0026lt;em\u0026gt;exactly\u0026lt;/em\u0026gt; is a \u0026lt;em\u0026gt;dependent name\u0026lt;/em\u0026gt;. On a simple read (you know, the principle of least surprise), all it defines as a \u0026lt;em\u0026gt;dependent name\u0026lt;/em\u0026gt; is the special case for function names below. But since clearly \u0026lt;code\u0026gt;T::x\u0026lt;/code\u0026gt; also needs to be looked up in the instantiation context, it also needs to be a dependent name (fortunately, as of mid C++14 the committee has started to look into how to fix this confusing definition). \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;To avoid this problem, I have resorted to a simple interpretation of the Standard text. Of all the constructs that denote dependent types or expressions, a subset of them represent names. Those names are therefore \u0026quot;dependent names\u0026quot;. A name can take different forms - the Standard says:\u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;A name is a use of an identifier (2.11), operator-function-id (13.5), conversion-function-id (12.3.2), or template-id (14.2) that denotes an entity or label (6.6.4, 6.1)\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;p\u0026gt;An identifier is just a plain sequence of characters / digits, while the next two are the \u0026lt;code\u0026gt;operator +\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;operator type\u0026lt;/code\u0026gt; form. The last form is \u0026lt;code\u0026gt;template-name \u0026amp;lt;argument list\u0026amp;gt;\u0026lt;/code\u0026gt;. All these are names, and by conventional use in the Standard, a name can also include qualifiers that say what namespace or class a name should be looked up in.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;A value dependent expression \u0026lt;code\u0026gt;1 + N\u0026lt;/code\u0026gt; is not a name, but \u0026lt;code\u0026gt;N\u0026lt;/code\u0026gt; is. The subset of all dependent constructs that are names is called \u0026lt;em\u0026gt;dependent name\u0026lt;/em\u0026gt;. Function names, however, may have different meaning in different instantiations of a template, but unfortunately are not caught by this general rule. \u0026lt;/p\u0026gt;\n\n\u0026lt;h3\u0026gt;Dependent function names\u0026lt;/h3\u0026gt;\n\n\u0026lt;p\u0026gt;Not primarily a concern of this article, but still worth mentioning: Function names are an exception that are handled separately. An identifier function name is dependent not by itself, but by the type dependent argument expressions used in a call. In the example \u0026lt;code\u0026gt;f((T)0)\u0026lt;/code\u0026gt;, \u0026lt;code\u0026gt;f\u0026lt;/code\u0026gt; is a dependent name. In the Standard, this is specified at \u0026lt;code\u0026gt;(14.6.2/1)\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n\n\u0026lt;h2\u0026gt;Additional notes and examples\u0026lt;/h2\u0026gt;\n\n\u0026lt;p\u0026gt;In enough cases we need both of \u0026lt;code\u0026gt;typename\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;template\u0026lt;/code\u0026gt;. Your code should look like the following\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; T, \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; Tail\u0026amp;gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;UnionNode\u0026lt;/span\u0026gt; : \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; Tail {\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// ...\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; U\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;inUnion\u0026lt;/span\u0026gt; {\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typedef\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; Tail::\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt; inUnion\u0026amp;lt;U\u0026amp;gt; dummy;\n    };\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// ...\u0026lt;/span\u0026gt;\n};\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;The keyword \u0026lt;code\u0026gt;template\u0026lt;/code\u0026gt; doesn\u0026apos;t always have to appear in the last part of a name. It can appear in the middle before a class name that\u0026apos;s used as a scope, like in the following example\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; t::\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt; iterator\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;\u0026amp;gt;::value_type v;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;In some cases, the keywords are forbidden, as detailed below\u0026lt;/p\u0026gt;\n\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;On the name of a dependent base class you are not allowed to write \u0026lt;code\u0026gt;typename\u0026lt;/code\u0026gt;. It\u0026apos;s assumed that the name given is a class type name. This is true for both names in the base-class list and the constructor initializer list:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; T\u0026amp;gt;\n \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;derive_from_Has_type\u0026lt;/span\u0026gt; : \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;/* typename */\u0026lt;/span\u0026gt; SomeBase\u0026amp;lt;T\u0026amp;gt;::type \n { };\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;In using-declarations it\u0026apos;s not possible to use \u0026lt;code\u0026gt;template\u0026lt;/code\u0026gt; after the last \u0026lt;code\u0026gt;::\u0026lt;/code\u0026gt;, and the C++ committee \u0026lt;a href=\u0026quot;http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_closed.html#109\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;said\u0026lt;/a\u0026gt; not to work on a solution. \u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; T\u0026amp;gt;\n \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;derive_from_Has_type\u0026lt;/span\u0026gt; : SomeBase\u0026amp;lt;T\u0026amp;gt; {\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;using\u0026lt;/span\u0026gt; SomeBase\u0026amp;lt;T\u0026amp;gt;::\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt; type; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// error\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;using\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; SomeBase\u0026amp;lt;T\u0026amp;gt;::type; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// typename *is* allowed\u0026lt;/span\u0026gt;\n };\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n    ","\n\u0026lt;h2\u0026gt;C++11\u0026lt;/h2\u0026gt;\n\n\u0026lt;h3\u0026gt;Problem\u0026lt;/h3\u0026gt;\n\n\u0026lt;p\u0026gt;While the rules in C++03 about when you need \u0026lt;code\u0026gt;typename\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;template\u0026lt;/code\u0026gt; are largely reasonable, there is one annoying disadvantage of its formulation\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; T\u0026amp;gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;A\u0026lt;/span\u0026gt; {\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typedef\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; result_type;\n\n  \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;f\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt; \u0026lt;/span\u0026gt;{\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// error, \u0026quot;this\u0026quot; is dependent, \u0026quot;template\u0026quot; keyword needed\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;this\u0026lt;/span\u0026gt;-\u0026amp;gt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;g\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;float\u0026lt;/span\u0026gt;\u0026amp;gt;();\n\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// OK\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;g\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;float\u0026lt;/span\u0026gt;\u0026amp;gt;();\n\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// error, \u0026quot;A\u0026amp;lt;T\u0026amp;gt;\u0026quot; is dependent, \u0026quot;typename\u0026quot; keyword needed\u0026lt;/span\u0026gt;\n    A\u0026amp;lt;T\u0026amp;gt;::result_type n1;\n\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// OK\u0026lt;/span\u0026gt;\n    result_type n2; \n  }\n\n  \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; U\u0026amp;gt;\n  \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;g\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;;\n};\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;As can be seen, we need the disambiguation keyword even if the compiler could perfectly figure out itself that \u0026lt;code\u0026gt;A::result_type\u0026lt;/code\u0026gt; can only be \u0026lt;code\u0026gt;int\u0026lt;/code\u0026gt; (and is hence a type), and \u0026lt;code\u0026gt;this-\u0026amp;gt;g\u0026lt;/code\u0026gt; can only be the member template \u0026lt;code\u0026gt;g\u0026lt;/code\u0026gt; declared later (even if \u0026lt;code\u0026gt;A\u0026lt;/code\u0026gt; is explicitly specialized somewhere, that would not affect the code within that template, so its meaning cannot be affected by a later specialization of \u0026lt;code\u0026gt;A\u0026lt;/code\u0026gt;!). \u0026lt;/p\u0026gt;\n\n\u0026lt;h3\u0026gt;Current instantiation\u0026lt;/h3\u0026gt;\n\n\u0026lt;p\u0026gt;To improve the situation, in C++11 the language tracks when a type refers to the enclosing template. To know that, the type must have been formed by using a certain form of name, which is its own name (in the above, \u0026lt;code\u0026gt;A\u0026lt;/code\u0026gt;, \u0026lt;code\u0026gt;A\u0026amp;lt;T\u0026amp;gt;\u0026lt;/code\u0026gt;, \u0026lt;code\u0026gt;::A\u0026amp;lt;T\u0026amp;gt;\u0026lt;/code\u0026gt;). A type referenced by such a name is known to be  the \u0026lt;em\u0026gt;current instantiation\u0026lt;/em\u0026gt;. There may be multiple types that are all the current instantiation if the type from which the name is formed is a member/nested class (then, \u0026lt;code\u0026gt;A::NestedClass\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;A\u0026lt;/code\u0026gt; are both current instantiations). \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Based on this notion, the language says that \u0026lt;code\u0026gt;CurrentInstantiation::Foo\u0026lt;/code\u0026gt;, \u0026lt;code\u0026gt;Foo\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;CurrentInstantiationTyped-\u0026amp;gt;Foo\u0026lt;/code\u0026gt; (such as \u0026lt;code\u0026gt;A *a = this; a-\u0026amp;gt;Foo\u0026lt;/code\u0026gt;) are all \u0026lt;em\u0026gt;member of the current instantiation\u0026lt;/em\u0026gt; \u0026lt;strong\u0026gt;if\u0026lt;/strong\u0026gt; they are found to be members of a class that is the current instantiation or one of its non-dependent base classes (by just doing the name lookup immediately). \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;The keywords \u0026lt;code\u0026gt;typename\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;template\u0026lt;/code\u0026gt; are now not required anymore if the qualifier is a member of the current instantiation. A keypoint here to remember is that \u0026lt;code\u0026gt;A\u0026amp;lt;T\u0026amp;gt;\u0026lt;/code\u0026gt; is \u0026lt;em\u0026gt;still\u0026lt;/em\u0026gt; a type-dependent name (after all \u0026lt;code\u0026gt;T\u0026lt;/code\u0026gt; is also type dependent). But \u0026lt;code\u0026gt;A\u0026amp;lt;T\u0026amp;gt;::result_type\u0026lt;/code\u0026gt; is known to be a type - the compiler will \u0026quot;magically\u0026quot; look into this kind of dependent types to figure this out. \u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;B\u0026lt;/span\u0026gt; {\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typedef\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; result_type;\n};\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; T\u0026amp;gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;C\u0026lt;/span\u0026gt; { }; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// could be specialized!\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; T\u0026amp;gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;D\u0026lt;/span\u0026gt; : B, C\u0026amp;lt;T\u0026amp;gt; {\n  \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;f\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt; \u0026lt;/span\u0026gt;{\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// OK, member of current instantiation!\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// A::result_type is not dependent: int\u0026lt;/span\u0026gt;\n    D::result_type r1;\n\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// error, not a member of the current instantiation\u0026lt;/span\u0026gt;\n    D::questionable_type r2;\n\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// OK for now - relying on C\u0026amp;lt;T\u0026amp;gt; to provide it\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// But not a member of the current instantiation\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; D::questionable_type r3;        \n  }\n};\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;That\u0026apos;s impressive, but can we do better? The language even goes further and \u0026lt;em\u0026gt;requires\u0026lt;/em\u0026gt; that an implementation again looks up \u0026lt;code\u0026gt;D::result_type\u0026lt;/code\u0026gt; when instantiating \u0026lt;code\u0026gt;D::f\u0026lt;/code\u0026gt; (even if it found its meaning already at definition time). When now the lookup result differs or results in ambiguity, the program is ill-formed and a diagnostic must be given. Imagine what happens if we defined \u0026lt;code\u0026gt;C\u0026lt;/code\u0026gt; like this\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026amp;gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;C\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;\u0026amp;gt; {\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typedef\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;bool\u0026lt;/span\u0026gt; result_type;\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typedef\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; questionable_type;\n};\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;A compiler is required to catch the error when instantiating \u0026lt;code\u0026gt;D\u0026amp;lt;int\u0026amp;gt;::f\u0026lt;/code\u0026gt;. So you get the best of the two worlds: \u0026quot;Delayed\u0026quot; lookup protecting you if you could get in trouble with dependent base classes, and also \u0026quot;Immediate\u0026quot; lookup that frees you from \u0026lt;code\u0026gt;typename\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;template\u0026lt;/code\u0026gt;. \u0026lt;/p\u0026gt;\n\n\u0026lt;h3\u0026gt;Unknown specializations\u0026lt;/h3\u0026gt;\n\n\u0026lt;p\u0026gt;In the code of \u0026lt;code\u0026gt;D\u0026lt;/code\u0026gt;, the name \u0026lt;code\u0026gt;typename D::questionable_type\u0026lt;/code\u0026gt; is not a member of the current instantiation. Instead the language marks it as a \u0026lt;em\u0026gt;member of an unknown specialization\u0026lt;/em\u0026gt;. In particular, this is always the case when you are doing \u0026lt;code\u0026gt;DependentTypeName::Foo\u0026lt;/code\u0026gt; or \u0026lt;code\u0026gt;DependentTypedName-\u0026amp;gt;Foo\u0026lt;/code\u0026gt; and either the dependent type is \u0026lt;em\u0026gt;not\u0026lt;/em\u0026gt; the current instantiation (in which case the compiler can give up and say \u0026quot;we will look later what \u0026lt;code\u0026gt;Foo\u0026lt;/code\u0026gt; is) or it \u0026lt;em\u0026gt;is\u0026lt;/em\u0026gt; the current instantiation and the name was not found in it or its non-dependent base classes and there are also dependent base classes. \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Imagine what happens if we had a member function \u0026lt;code\u0026gt;h\u0026lt;/code\u0026gt; within the above defined \u0026lt;code\u0026gt;A\u0026lt;/code\u0026gt; class template\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;h\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt; \u0026lt;/span\u0026gt;{\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; A\u0026amp;lt;T\u0026amp;gt;::questionable_type x;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;In C++03, the language allowed to catch this error because there could never be a valid way to instantiate \u0026lt;code\u0026gt;A\u0026amp;lt;T\u0026amp;gt;::h\u0026lt;/code\u0026gt; (whatever argument you give to \u0026lt;code\u0026gt;T\u0026lt;/code\u0026gt;). In C++11, the language now has a further check to give more reason for compilers to implement this rule. Since \u0026lt;code\u0026gt;A\u0026lt;/code\u0026gt; has no dependent base classes, and \u0026lt;code\u0026gt;A\u0026lt;/code\u0026gt; declares no member \u0026lt;code\u0026gt;questionable_type\u0026lt;/code\u0026gt;, the name \u0026lt;code\u0026gt;A\u0026amp;lt;T\u0026amp;gt;::questionable_type\u0026lt;/code\u0026gt; is \u0026lt;em\u0026gt;neither\u0026lt;/em\u0026gt; a member of the current instantiation \u0026lt;em\u0026gt;nor\u0026lt;/em\u0026gt; a member of an unknown specialization. In that case, there should be no way that that code could validly compile at instantiation time, so the language forbids a name where the qualifier is the current instantiation to be neither a member of an unknown specialization nor a member of the current instantiation (however, this violation is still not required to be diagnosed).\u0026lt;/p\u0026gt;\n\n\u0026lt;h3\u0026gt;Examples and trivia\u0026lt;/h3\u0026gt;\n\n\u0026lt;p\u0026gt;You can try this knowledge on \u0026lt;a href=\u0026quot;https://stackoverflow.com/a/14005063/34509\u0026quot;\u0026gt;this answer\u0026lt;/a\u0026gt; and see whether the above definitions make sense for you on a real-world example (they are repeated slightly less detailed in that answer).  \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;The C++11 rules make the following valid C++03 code ill-formed (which was not intended by the C++ committee, but will probably not be fixed)\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;B\u0026lt;/span\u0026gt; { \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;f\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;; };\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;A\u0026lt;/span\u0026gt; : \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;virtual\u0026lt;/span\u0026gt; B { \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;f\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;; };\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; T\u0026amp;gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;C\u0026lt;/span\u0026gt; : \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;virtual\u0026lt;/span\u0026gt; B, T {\n  \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;g\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt; \u0026lt;/span\u0026gt;{ \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;this\u0026lt;/span\u0026gt;-\u0026amp;gt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;f\u0026lt;/span\u0026gt;(); }\n};\n\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;main\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt; \u0026lt;/span\u0026gt;{ \n  C\u0026amp;lt;A\u0026amp;gt; c; c.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;g\u0026lt;/span\u0026gt;(); \n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;This valid C++03 code would bind \u0026lt;code\u0026gt;this-\u0026amp;gt;f\u0026lt;/code\u0026gt; to \u0026lt;code\u0026gt;A::f\u0026lt;/code\u0026gt; at instantiation time and everything is fine. C++11 however immediately binds it to \u0026lt;code\u0026gt;B::f\u0026lt;/code\u0026gt; and requires a double-check when instantiating, checking whether the lookup still matches. However when instantiating \u0026lt;code\u0026gt;C\u0026amp;lt;A\u0026amp;gt;::g\u0026lt;/code\u0026gt;, the \u0026lt;a href=\u0026quot;http://en.wikipedia.org/wiki/Dominance_(C%2B%2B)\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;Dominance Rule\u0026lt;/a\u0026gt; applies and lookup will find \u0026lt;code\u0026gt;A::f\u0026lt;/code\u0026gt; instead.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;blockquote\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Preface\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;This post is meant to be an \u0026lt;em\u0026gt;easy-to-read\u0026lt;/em\u0026gt; alternative to \u0026lt;a href=\u0026quot;https://stackoverflow.com/questions/610245/where-and-why-do-i-have-to-put-the-template-and-typename-keywords/17579889#17579889\u0026quot;\u0026gt;litb\u0026apos;s post\u0026lt;/a\u0026gt;.\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\u0026lt;blockquote\u0026gt;\n\u0026lt;p\u0026gt;The underlying purpose is the same; an explanation to \u0026quot;When?\u0026quot; and \u0026quot;Why?\u0026quot; \u0026lt;code\u0026gt;typename\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;template\u0026lt;/code\u0026gt; must be applied.\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\u0026lt;hr\u0026gt;\n\u0026lt;h1\u0026gt;What\u0026apos;s the purpose of \u0026lt;code\u0026gt;typename\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;template\u0026lt;/code\u0026gt;?\u0026lt;/h1\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;code\u0026gt;typename\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;template\u0026lt;/code\u0026gt; are usable in circumstances other than when declaring a template.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;There are certain contexts in \u0026lt;em\u0026gt;C++\u0026lt;/em\u0026gt; where the compiler must explicitly be told how to treat a name, and all these contexts have one thing in common; they depend on at least one \u0026lt;em\u0026gt;template-parameter\u0026lt;/em\u0026gt;.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;We refer to such names, where there can be an ambiguity in interpretation, as; \u0026quot;\u0026lt;em\u0026gt;dependent names\u0026lt;/em\u0026gt;\u0026quot;.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;This post will offer an explanation to the relationship between \u0026lt;em\u0026gt;dependent-names\u0026lt;/em\u0026gt;, and the two keywords.\u0026lt;/p\u0026gt;\n\u0026lt;hr\u0026gt;\n\u0026lt;h2\u0026gt;A snippet says more than 1000 words\u0026lt;/h2\u0026gt;\n\u0026lt;p\u0026gt;Try to explain what is going on in the following \u0026lt;em\u0026gt;function-template\u0026lt;/em\u0026gt;, either to yourself, a friend, or perhaps your cat; what is happening in the statement marked (\u0026lt;em\u0026gt;A\u0026lt;/em\u0026gt;)?\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; T\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;f_tmpl\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt; \u0026lt;/span\u0026gt;{ T::foo * x; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;/* \u0026amp;lt;-- (A) */\u0026lt;/span\u0026gt; }\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;sup\u0026gt;\u0026lt;br\u0026gt;\u0026lt;/sup\u0026gt;\nIt might not be as easy as one thinks, more specifically the result of evaluating (\u0026lt;em\u0026gt;A\u0026lt;/em\u0026gt;) heavily \u0026lt;em\u0026gt;depends\u0026lt;/em\u0026gt; on the definition of the type passed as template-parameter \u0026lt;code\u0026gt;T\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Different \u0026lt;code\u0026gt;T\u0026lt;/code\u0026gt;s can drastically change the semantics involved.\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;X\u0026lt;/span\u0026gt; { \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typedef\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;       foo;       }; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;/* (C) --\u0026amp;gt; */\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;f_tmpl\u0026lt;/span\u0026gt;\u0026amp;lt;X\u0026amp;gt; ();\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Y\u0026lt;/span\u0026gt; { \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;static\u0026lt;/span\u0026gt;  \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; foo = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;123\u0026lt;/span\u0026gt;; }; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;/* (D) --\u0026amp;gt; */\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;f_tmpl\u0026lt;/span\u0026gt;\u0026amp;lt;Y\u0026amp;gt; ();\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;sup\u0026gt;\u0026lt;br\u0026gt;\u0026lt;/sup\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;The two different scenarios\u0026lt;/strong\u0026gt;:\u0026lt;/p\u0026gt;\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;If we instantiate the function-template with type \u0026lt;em\u0026gt;X\u0026lt;/em\u0026gt;, as in (\u0026lt;em\u0026gt;C\u0026lt;/em\u0026gt;), we will have a declaration of a \u0026lt;em\u0026gt;pointer-to int\u0026lt;/em\u0026gt; named \u0026lt;em\u0026gt;x\u0026lt;/em\u0026gt;, but;\u0026lt;/p\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;if we instantiate the template with type \u0026lt;em\u0026gt;Y\u0026lt;/em\u0026gt;, as in (\u0026lt;em\u0026gt;D\u0026lt;/em\u0026gt;), (\u0026lt;em\u0026gt;A\u0026lt;/em\u0026gt;) would instead consist of an expression that calculates the product of \u0026lt;em\u0026gt;123\u0026lt;/em\u0026gt; multiplied with some already declared variable \u0026lt;em\u0026gt;x\u0026lt;/em\u0026gt;.\u0026lt;/p\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;br\u0026gt;\n\u0026lt;hr\u0026gt;\n\u0026lt;h2\u0026gt;The Rationale\u0026lt;/h2\u0026gt;\n\u0026lt;p\u0026gt;The C++ Standard cares about our safety and well-being, at least in this case.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;To prevent an implementation from potentially suffering from nasty surprises, the Standard mandates that we sort out the ambiguity of a \u0026lt;em\u0026gt;dependent-name\u0026lt;/em\u0026gt; by \u0026lt;em\u0026gt;explicitly\u0026lt;/em\u0026gt; stating the intent anywhere we\u0026apos;d like to treat the name as either a \u0026lt;em\u0026gt;type-name\u0026lt;/em\u0026gt;, or a \u0026lt;em\u0026gt;template-id\u0026lt;/em\u0026gt;.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;If nothing is stated, the \u0026lt;em\u0026gt;dependent-name\u0026lt;/em\u0026gt; will be considered to be either a variable, or a function.\u0026lt;/p\u0026gt;\n\u0026lt;br\u0026gt;\n\u0026lt;hr\u0026gt;\n\u0026lt;h2\u0026gt;How to handle dependent names?\u0026lt;/h2\u0026gt;\n\u0026lt;p\u0026gt;If this was a Hollywood film, \u0026lt;em\u0026gt;dependent-names\u0026lt;/em\u0026gt; would be the disease that spreads through body contact, instantly affects its host to make it confused. Confusion that could, possibly, lead to an ill-formed perso-, erhm.. program.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;A \u0026lt;em\u0026gt;dependent-name\u0026lt;/em\u0026gt; is \u0026lt;strong\u0026gt;any\u0026lt;/strong\u0026gt; name that directly, or indirectly, depends on a \u0026lt;em\u0026gt;template-parameter\u0026lt;/em\u0026gt;.\n\u0026lt;sup\u0026gt;\u0026lt;br\u0026gt;\u0026lt;br\u0026gt;\u0026lt;/sup\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; T\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;g_tmpl\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt; \u0026lt;/span\u0026gt;{\n   SomeTrait\u0026amp;lt;T\u0026amp;gt;::type                   foo; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// (E), ill-formed\u0026lt;/span\u0026gt;\n   SomeTrait\u0026amp;lt;T\u0026amp;gt;::NestedTrait\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;\u0026amp;gt;::type bar; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// (F), ill-formed\u0026lt;/span\u0026gt;\n   foo.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;data\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;\u0026amp;gt; ();                         \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// (G), ill-formed    \u0026lt;/span\u0026gt;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;We have four \u0026lt;em\u0026gt;dependent\u0026lt;/em\u0026gt; names in the above snippet:\u0026lt;/p\u0026gt;\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;strong\u0026gt;E\u0026lt;/strong\u0026gt;)\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;strong\u0026gt;\u0026quot;type\u0026quot;\u0026lt;/strong\u0026gt; depends on the instantiation of \u0026lt;code\u0026gt;SomeTrait\u0026amp;lt;T\u0026amp;gt;\u0026lt;/code\u0026gt;, which include \u0026lt;code\u0026gt;T\u0026lt;/code\u0026gt;, and;\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;strong\u0026gt;F\u0026lt;/strong\u0026gt;)\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;strong\u0026gt;\u0026quot;NestedTrait\u0026quot;\u0026lt;/strong\u0026gt;, which is a \u0026lt;em\u0026gt;template-id\u0026lt;/em\u0026gt;, depends on \u0026lt;code\u0026gt;SomeTrait\u0026amp;lt;T\u0026amp;gt;\u0026lt;/code\u0026gt;, and;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;strong\u0026gt;\u0026quot;type\u0026quot;\u0026lt;/strong\u0026gt; at the end of (\u0026lt;em\u0026gt;F\u0026lt;/em\u0026gt;) depends on \u0026lt;em\u0026gt;NestedTrait\u0026lt;/em\u0026gt;, which depends on \u0026lt;code\u0026gt;SomeTrait\u0026amp;lt;T\u0026amp;gt;\u0026lt;/code\u0026gt;, and;\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;strong\u0026gt;G\u0026lt;/strong\u0026gt;)\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;strong\u0026gt;\u0026quot;data\u0026quot;\u0026lt;/strong\u0026gt;, which looks like a \u0026lt;em\u0026gt;member-function template\u0026lt;/em\u0026gt;, is indirectly a \u0026lt;em\u0026gt;dependent-name\u0026lt;/em\u0026gt; since the type of \u0026lt;em\u0026gt;foo\u0026lt;/em\u0026gt; depends on the instantiation of \u0026lt;code\u0026gt;SomeTrait\u0026amp;lt;T\u0026amp;gt;\u0026lt;/code\u0026gt;.\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;p\u0026gt;Neither of statement (\u0026lt;em\u0026gt;E\u0026lt;/em\u0026gt;), (\u0026lt;em\u0026gt;F\u0026lt;/em\u0026gt;) or (\u0026lt;em\u0026gt;G\u0026lt;/em\u0026gt;) is valid if the compiler would interpret the \u0026lt;em\u0026gt;dependent-names\u0026lt;/em\u0026gt; as variables/functions (which as stated earlier is what happens if we don\u0026apos;t explicitly say otherwise).\n\u0026lt;sup\u0026gt;\u0026lt;br\u0026gt;\u0026lt;br\u0026gt;\u0026lt;/sup\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;h3\u0026gt;The solution\u0026lt;/h3\u0026gt;\n\u0026lt;p\u0026gt;To make \u0026lt;code\u0026gt;g_tmpl\u0026lt;/code\u0026gt; have a valid definition we must explicitly tell the compiler that we expect a type in (\u0026lt;em\u0026gt;E\u0026lt;/em\u0026gt;), a \u0026lt;em\u0026gt;template-id\u0026lt;/em\u0026gt; and a \u0026lt;em\u0026gt;type\u0026lt;/em\u0026gt; in (\u0026lt;em\u0026gt;F\u0026lt;/em\u0026gt;), and a \u0026lt;em\u0026gt;template-id\u0026lt;/em\u0026gt; in (\u0026lt;em\u0026gt;G\u0026lt;/em\u0026gt;).\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; T\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;g_tmpl\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt; \u0026lt;/span\u0026gt;{\n   \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; SomeTrait\u0026amp;lt;T\u0026amp;gt;::type foo;                            \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// (G), legal\u0026lt;/span\u0026gt;\n   \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; SomeTrait\u0026amp;lt;T\u0026amp;gt;::\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt; NestedTrait\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;\u0026amp;gt;::type bar; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// (H), legal\u0026lt;/span\u0026gt;\n   foo.\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;data\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;\u0026amp;gt; ();                                  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// (I), legal\u0026lt;/span\u0026gt;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;Every time a \u0026lt;em\u0026gt;name\u0026lt;/em\u0026gt; denotes a type, \u0026lt;strong\u0026gt;all\u0026lt;/strong\u0026gt; \u0026lt;em\u0026gt;names\u0026lt;/em\u0026gt; involved must be either \u0026lt;em\u0026gt;type-names\u0026lt;/em\u0026gt; or \u0026lt;em\u0026gt;namespaces\u0026lt;/em\u0026gt;, with this in mind it\u0026apos;s quite easy to see that we apply \u0026lt;code\u0026gt;typename\u0026lt;/code\u0026gt; at the beginning of our fully \u0026lt;em\u0026gt;qualified name\u0026lt;/em\u0026gt;.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;code\u0026gt;template\u0026lt;/code\u0026gt; however, is different in this regard, since there\u0026apos;s no way of coming to a conclusion such as; \u0026lt;em\u0026gt;\u0026quot;oh, this is a template, then this other thing must also be a template\u0026quot;\u0026lt;/em\u0026gt;. This means that we apply \u0026lt;code\u0026gt;template\u0026lt;/code\u0026gt; directly in front of any \u0026lt;em\u0026gt;name\u0026lt;/em\u0026gt; that we\u0026apos;d like to treat as such.\u0026lt;/p\u0026gt;\n\u0026lt;br\u0026gt;\n\u0026lt;hr\u0026gt;\n\u0026lt;h2\u0026gt;Can I just stick the \u0026lt;em\u0026gt;keywords\u0026lt;/em\u0026gt; in front of any name?\u0026lt;/h2\u0026gt;\n\u0026lt;blockquote\u0026gt;\n\u0026lt;p\u0026gt;\u0026quot;\u0026lt;em\u0026gt;Can I just stick \u0026lt;code\u0026gt;typename\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;template\u0026lt;/code\u0026gt; in front of any name? I don\u0026apos;t want to worry about the context in which they appear...\u0026lt;/em\u0026gt;\u0026quot; - \u0026lt;code\u0026gt;Some C++ Developer\u0026lt;/code\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\u0026lt;p\u0026gt;The rules in the Standard states that you may apply the keywords as long as you are dealing with a \u0026lt;em\u0026gt;qualified-name\u0026lt;/em\u0026gt; (\u0026lt;em\u0026gt;K\u0026lt;/em\u0026gt;), but if the name isn\u0026apos;t \u0026lt;em\u0026gt;qualified\u0026lt;/em\u0026gt; the application is ill-formed (\u0026lt;em\u0026gt;L\u0026lt;/em\u0026gt;).\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;namespace\u0026lt;/span\u0026gt; N {\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;T\u0026lt;/span\u0026gt;\u0026amp;gt;\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;X\u0026lt;/span\u0026gt; { };\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;sup\u0026gt;\u0026lt;/sup\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;         N::         X\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;\u0026amp;gt; a; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// ...  legal\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; N::\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt; X\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;\u0026amp;gt; b; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// (K), legal\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt;    X\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;\u0026amp;gt; c; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// (L), ill-formed\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;sup\u0026gt;\u0026lt;strong\u0026gt;Note\u0026lt;/strong\u0026gt;: Applying \u0026lt;code\u0026gt;typename\u0026lt;/code\u0026gt; or \u0026lt;code\u0026gt;template\u0026lt;/code\u0026gt; in a context where it is not required is not considered good practice; just because you can do something, doesn\u0026apos;t mean that you should.\u0026lt;/sup\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;br\u0026gt;\n\u0026lt;p\u0026gt;Additionally there are contexts where \u0026lt;code\u0026gt;typename\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;template\u0026lt;/code\u0026gt; are \u0026lt;strong\u0026gt;explicitly\u0026lt;/strong\u0026gt; disallowed:\u0026lt;/p\u0026gt;\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;When specifying the bases of which a class inherits\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Every name written in a derived class\u0026apos;s \u0026lt;em\u0026gt;base-specifier-list\u0026lt;/em\u0026gt; is already treated as a \u0026lt;em\u0026gt;type-name\u0026lt;/em\u0026gt;, explicitly specifying \u0026lt;code\u0026gt;typename\u0026lt;/code\u0026gt; is both ill-formed, and redundant.\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;                    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// .------- the base-specifier-list\u0026lt;/span\u0026gt;\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;T\u0026lt;/span\u0026gt;\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// v\u0026lt;/span\u0026gt;\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Derived\u0026lt;/span\u0026gt;      : \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; SomeTrait\u0026amp;lt;T\u0026amp;gt;::type \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;/* \u0026amp;lt;- ill-formed */\u0026lt;/span\u0026gt; {\n    ...\n  };\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n \u0026lt;br\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;When the \u0026lt;em\u0026gt;template-id\u0026lt;/em\u0026gt; is the one being referred to in a derived class\u0026apos;s \u0026lt;em\u0026gt;using-directive\u0026lt;/em\u0026gt;\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Base\u0026lt;/span\u0026gt; {\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;T\u0026lt;/span\u0026gt;\u0026amp;gt;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;type\u0026lt;/span\u0026gt; { };\n  };\n\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Derived\u0026lt;/span\u0026gt; : Base {\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;using\u0026lt;/span\u0026gt; Base::\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt; type; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// ill-formed\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;using\u0026lt;/span\u0026gt; Base::type;          \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// legal\u0026lt;/span\u0026gt;\n  };\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n    ","\n\u0026lt;p\u0026gt;\u0026lt;sub\u0026gt;\n\u0026lt;em\u0026gt;This answer is meant to be a rather short and sweet one to answer (part of) the titled question. If you want an answer with more detail that explains why you have to put them there, please go \u0026lt;a href=\u0026quot;https://stackoverflow.com/a/613132/1381108\u0026quot;\u0026gt;here\u0026lt;/a\u0026gt;.\u0026lt;/em\u0026gt;\n\u0026lt;/sub\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;hr\u0026gt;\n\n\u0026lt;p\u0026gt;The general rule for putting the \u0026lt;code\u0026gt;typename\u0026lt;/code\u0026gt; keyword is mostly when you\u0026apos;re using a template parameter and you want to access a nested \u0026lt;code\u0026gt;typedef\u0026lt;/code\u0026gt; or using-alias, for example:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; T\u0026amp;gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;test\u0026lt;/span\u0026gt; {\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;using\u0026lt;/span\u0026gt; type = T; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// no typename required\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;using\u0026lt;/span\u0026gt; underlying_type = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; T::type \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// typename required\u0026lt;/span\u0026gt;\n};\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Note that this also applies for meta functions or things that take generic template parameters too. However, if the template parameter provided is an explicit type then you don\u0026apos;t have to specify \u0026lt;code\u0026gt;typename\u0026lt;/code\u0026gt;, for example:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; T\u0026amp;gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;test\u0026lt;/span\u0026gt; {\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// typename required\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;using\u0026lt;/span\u0026gt; type = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; std::conditional\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;true\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; T\u0026amp;amp;, T\u0026amp;amp;\u0026amp;amp;\u0026amp;gt;::type;\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// no typename required\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;using\u0026lt;/span\u0026gt; integer = std::conditional\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;true\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;float\u0026lt;/span\u0026gt;\u0026amp;gt;::type;\n};\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;The general rules for adding the \u0026lt;code\u0026gt;template\u0026lt;/code\u0026gt; qualifier are mostly similar except they typically involve templated member functions (static or otherwise) of a struct/class that is itself templated, for example:\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Given this struct and function:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; T\u0026amp;gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;test\u0026lt;/span\u0026gt; {\n    \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; U\u0026amp;gt;\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;get\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; \u0026lt;/span\u0026gt;{\n        std::cout \u0026amp;lt;\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;get\\n\u0026quot;\u0026lt;/span\u0026gt;;\n    }\n};\n\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; T\u0026amp;gt;\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;func\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; test\u0026amp;lt;T\u0026amp;gt;\u0026amp;amp; t)\u0026lt;/span\u0026gt; \u0026lt;/span\u0026gt;{\n    t.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;get\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;\u0026amp;gt;(); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// error\u0026lt;/span\u0026gt;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Attempting to access \u0026lt;code\u0026gt;t.get\u0026amp;lt;int\u0026amp;gt;()\u0026lt;/code\u0026gt; from inside the function will result in an error:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-none s-code-block\u0026quot;\u0026gt;\u0026lt;code\u0026gt;main.cpp:13:11: error: expected primary-expression before \u0026apos;int\u0026apos;\n     t.get\u0026amp;lt;int\u0026amp;gt;();\n           ^\nmain.cpp:13:11: error: expected \u0026apos;;\u0026apos; before \u0026apos;int\u0026apos;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Thus in this context you would need the \u0026lt;code\u0026gt;template\u0026lt;/code\u0026gt; keyword beforehand and call it like so:\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;code\u0026gt;t.template get\u0026amp;lt;int\u0026amp;gt;()\u0026lt;/code\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;That way the compiler will parse this properly rather than \u0026lt;code\u0026gt;t.get \u0026amp;lt; int\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typedef\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; Tail::inUnion\u0026amp;lt;U\u0026amp;gt; dummy;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;However, I\u0026apos;m not sure you\u0026apos;re implementation of inUnion is correct. If I understand correctly, this class is not supposed to be instantiated, therefore the \u0026quot;fail\u0026quot; tab will never avtually fails. Maybe it would be better to indicates whether the type is in the union or not with a simple boolean value.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; T, \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; TypeList\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Contains\u0026lt;/span\u0026gt;;\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; T, \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; Head, \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; Tail\u0026amp;gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Contains\u0026lt;/span\u0026gt;\u0026amp;lt;T, UnionNode\u0026amp;lt;Head, Tail\u0026amp;gt; \u0026amp;gt;\n{\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;enum\u0026lt;/span\u0026gt; { result = Contains\u0026amp;lt;T, Tail\u0026amp;gt;::result };\n};\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; T, \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; Tail\u0026amp;gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Contains\u0026lt;/span\u0026gt;\u0026amp;lt;T, UnionNode\u0026amp;lt;T, Tail\u0026amp;gt; \u0026amp;gt;\n{\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;enum\u0026lt;/span\u0026gt; { result = \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;true\u0026lt;/span\u0026gt; };\n};\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; T\u0026amp;gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Contains\u0026lt;/span\u0026gt;\u0026amp;lt;T, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt;\u0026amp;gt;\n{\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;enum\u0026lt;/span\u0026gt; { result = \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;false\u0026lt;/span\u0026gt; };\n};\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;PS: Have a look at \u0026lt;a href=\u0026quot;http://www.boost.org/doc/libs/1_38_0/doc/html/variant.html\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;Boost::Variant\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;PS2: Have a look at \u0026lt;a href=\u0026quot;http://www.ddj.com/cpp/184403813\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;typelists\u0026lt;/a\u0026gt;, notably in Andrei Alexandrescu\u0026apos;s book: Modern C++ Design\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;h2\u0026gt;C++20 aka C++2a\u0026lt;/h2\u0026gt;\n\u0026lt;p\u0026gt;As outlined in this \u0026lt;a href=\u0026quot;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0634r3.html\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;Proposal\u0026lt;/a\u0026gt;, C++20 / C++2a has further relaxed the requirements for the \u0026lt;code\u0026gt;typename\u0026lt;/code\u0026gt; keyword. In particular, \u0026lt;code\u0026gt;typename\u0026lt;/code\u0026gt; may now be omitted in all those places, where syntactically only a type is legal. So, if an unknown token must be a type, C++20 will actually treat it as a type. For backwards compatibility, \u0026lt;code\u0026gt;typename\u0026lt;/code\u0026gt; may still be used, though.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;In particular, most \u0026lt;code\u0026gt;using\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;typedef\u0026lt;/code\u0026gt; declarations can now be written without \u0026lt;code\u0026gt;typename\u0026lt;/code\u0026gt;. \u0026lt;code\u0026gt;typename\u0026lt;/code\u0026gt; can also be omitted in the declaration of method return types (including trailing return types), in the declaration of method and lambda parameters and in the type argument to \u0026lt;code\u0026gt;static_cast\u0026lt;/code\u0026gt;, \u0026lt;code\u0026gt;const_cast\u0026lt;/code\u0026gt;, \u0026lt;code\u0026gt;dynamic_cast\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;reinterpret_cast\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;One notable exception, where \u0026lt;code\u0026gt;typename\u0026lt;/code\u0026gt; is still required, is in the argument list of instantiations of user or library defined templates: Even, if that particular argument was declared to be a type, the \u0026lt;code\u0026gt;typename\u0026lt;/code\u0026gt; keyword is still required. So \u0026lt;code\u0026gt;static_cast\u0026amp;lt;A::B\u0026amp;gt;(arg)\u0026lt;/code\u0026gt; is legal in C++20, but \u0026lt;code\u0026gt;my_template_class\u0026amp;lt;A::B\u0026amp;gt;(arg)\u0026lt;/code\u0026gt; is ill-formed, if A is a dependant scope and \u0026lt;code\u0026gt;my_template_class\u0026lt;/code\u0026gt; expects a type.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;A few examples:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;A\u0026lt;/span\u0026gt; { \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt;: \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typedef\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; type; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;static\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; val { \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt; }; };\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;B\u0026lt;/span\u0026gt; { \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt;: \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typedef\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;float\u0026lt;/span\u0026gt; type; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;static\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; val { \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt; }; };\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; T\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;C\u0026lt;/span\u0026gt; {};\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; I\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;D\u0026lt;/span\u0026gt; {};\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; T\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;X\u0026lt;/span\u0026gt; {\n    T::type v;                                  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// OK\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;T::type \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;f\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(T::type arg)\u0026lt;/span\u0026gt; \u0026lt;/span\u0026gt;{ \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; arg; }      \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// OK\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;T::type \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;g\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;double\u0026lt;/span\u0026gt; arg)\u0026lt;/span\u0026gt; \u0026lt;/span\u0026gt;{ \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;static_cast\u0026lt;/span\u0026gt;\u0026amp;lt;T::type\u0026amp;gt;(arg); } \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// OK\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// C\u0026amp;lt;T::type\u0026amp;gt; c1;                           // error\u0026lt;/span\u0026gt;\n    D\u0026amp;lt;T::val\u0026amp;gt; d;                                \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// OK (as has always been)\u0026lt;/span\u0026gt;\n    C\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; T::type\u0026amp;gt; c2;                     \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// OK (old style)\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typedef\u0026lt;/span\u0026gt; T::type mytype;                     \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// OK\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;using\u0026lt;/span\u0026gt; mytypeagain = T::type;                \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// OK\u0026lt;/span\u0026gt;\n    C\u0026amp;lt;mytype\u0026amp;gt; c3;                               \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// OK (via typedef / using)\u0026lt;/span\u0026gt;\n};\nX\u0026amp;lt;A\u0026amp;gt; xa;\nX\u0026amp;lt;B\u0026amp;gt; xb;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;I am placing JLBorges\u0026apos;s excellent \u0026lt;a href=\u0026quot;http://www.cplusplus.com/forum/general/122765/#msg669061\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;response\u0026lt;/a\u0026gt; to a similar question verbatim from cplusplus.com, as it is the most succinct explanation I\u0026apos;ve read on the subject.\u0026lt;/p\u0026gt;\n\u0026lt;blockquote\u0026gt;\n\u0026lt;p\u0026gt;In a template that we write, there are two kinds of names that could be used - dependant names and non- dependant names. A dependant name is a name that depends on a template parameter; a non-dependant name has the same meaning irrespective of what the template parameters are.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;For example:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt;\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; T \u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;foo\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;( T\u0026amp;amp; x, std::string str, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; count )\u0026lt;/span\u0026gt;\n\u0026lt;/span\u0026gt;{\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// these names are looked up during the second phase\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// when foo is instantiated and the type T is known\u0026lt;/span\u0026gt;\n    x.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;size\u0026lt;/span\u0026gt;(); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// dependant name (non-type)\u0026lt;/span\u0026gt;\n    T::instance_count ; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// dependant name (non-type)\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; T::iterator i ; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// dependant name (type)\u0026lt;/span\u0026gt;\n      \n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// during the first phase, \u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// T::instance_count is treated as a non-type (this is the default)\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// the typename keyword specifies that T::iterator is to be treated as a type.\u0026lt;/span\u0026gt;\n\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// these names are looked up during the first phase\u0026lt;/span\u0026gt;\n    std::string::size_type s ; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// non-dependant name (type)\u0026lt;/span\u0026gt;\n    std::string::npos ; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// non-dependant name (non-type)\u0026lt;/span\u0026gt;\n    str.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;empty\u0026lt;/span\u0026gt;() ; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// non-dependant name (non-type)\u0026lt;/span\u0026gt;\n    count ; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// non-dependant name (non-type)\u0026lt;/span\u0026gt;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;What a dependant name refers to could be something different for each different instantiation of the template. As a consequence, C++ templates are subject to \u0026quot;two-phase name lookup\u0026quot;. When a template is initially parsed (before any instantiation takes place) the compiler looks up the non-dependent names. When a particular instantiation of the template takes place, the template parameters are known by then, and the compiler looks up dependent names.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;During the first phase, the parser needs to know if a dependant name is the name of a type or the name of a non-type. By default, a dependant name is assumed to be the name of a non-type. The typename keyword before a dependant name specifies that it is the name of a type.\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\u0026lt;hr\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Summary\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Use the keyword typename only in template declarations and definitions provided you have a qualified name that refers to a type and depends on a template parameter.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Dependent name is a name depends on template parameters, we need to instruct compiler in order to compile the template class/function properly before actually instiatiate them.\u0026lt;/p\u0026gt;\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;typename -\u0026amp;gt; tell compiler the dependent name is an actual type\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;T\u0026lt;/span\u0026gt;\u0026amp;gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;DependentType\u0026lt;/span\u0026gt;\n{\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; T::type a;\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;using\u0026lt;/span\u0026gt; Type=\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; T::type;\n};\n\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;template -\u0026amp;gt; tell compiler the dependent name is a template function/class\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;T\u0026lt;/span\u0026gt;\u0026amp;gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;DependentTemplate\u0026lt;/span\u0026gt;\n{\n  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// template function\u0026lt;/span\u0026gt;\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;U\u0026lt;/span\u0026gt;\u0026amp;gt;\n  \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;static\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;func\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt; \u0026lt;/span\u0026gt;{}\n\n  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// template class\u0026lt;/span\u0026gt;\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;U\u0026lt;/span\u0026gt;\u0026amp;gt;\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;ClassName\u0026lt;/span\u0026gt;{};\n};\n\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;T1\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;T2\u0026lt;/span\u0026gt;\u0026amp;gt;\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;foo\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt;\n\u0026lt;/span\u0026gt;{\n  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// 3 ways to call a dependent template function\u0026lt;/span\u0026gt;\n  DependentTemplate\u0026amp;lt;T1\u0026amp;gt;::\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;func\u0026lt;/span\u0026gt;\u0026amp;lt;T2\u0026amp;gt;();\n  \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;DependentTemplate\u0026lt;/span\u0026gt;\u0026amp;lt;T1\u0026amp;gt;().\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;func\u0026lt;/span\u0026gt;\u0026amp;lt;T2\u0026amp;gt;();\n  (\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;DependentTemplate\u0026lt;/span\u0026gt;\u0026amp;lt;T1\u0026amp;gt;())-\u0026amp;gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;func\u0026lt;/span\u0026gt;\u0026amp;lt;T2\u0026amp;gt;();\n\n  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// You need both typename and template to reference a dependent template class\u0026lt;/span\u0026gt;\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; DependentTemplate\u0026amp;lt;T1\u0026amp;gt;::\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt; ClassName\u0026amp;lt;T2\u0026amp;gt; obj;\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;using\u0026lt;/span\u0026gt; Type=\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; DependentTemplate\u0026amp;lt;T1\u0026amp;gt;::\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt; ClassName\u0026amp;lt;T2\u0026amp;gt;;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n    "],"id":65,"title":"Where and why do I have to put the \"template\" and \"typename\" keywords?","content":"\n                \n\u0026lt;p\u0026gt;In templates, where and why do I have to put \u0026lt;code\u0026gt;typename\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;template\u0026lt;/code\u0026gt; on dependent names?\u0026lt;br\u0026gt;\nWhat exactly are dependent names anyway?  \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;I have the following code:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; T, \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; Tail\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Tail will be a UnionNode too.\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;UnionNode\u0026lt;/span\u0026gt; : \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; Tail {\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// ...\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; U\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;inUnion\u0026lt;/span\u0026gt; {\n        \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Q: where to add typename/template here?\u0026lt;/span\u0026gt;\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typedef\u0026lt;/span\u0026gt; Tail::inUnion\u0026amp;lt;U\u0026amp;gt; dummy; \n    };\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt;\u0026amp;lt; \u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;inUnion\u0026lt;/span\u0026gt;\u0026amp;lt;T\u0026amp;gt; {\n    };\n};\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; T\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// For the last node Tn.\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;UnionNode\u0026lt;/span\u0026gt;\u0026amp;lt;T, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt;\u0026amp;gt; {\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// ...\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; U\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;inUnion\u0026lt;/span\u0026gt; {\n        \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; fail[ \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;-2\u0026lt;/span\u0026gt; + (\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;sizeof\u0026lt;/span\u0026gt;(U)%\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;) ]; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Cannot be instantiated for any U\u0026lt;/span\u0026gt;\n    };\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt;\u0026amp;lt; \u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;inUnion\u0026lt;/span\u0026gt;\u0026amp;lt;T\u0026amp;gt; {\n    };\n};\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;The problem I have is in the \u0026lt;code\u0026gt;typedef Tail::inUnion\u0026amp;lt;U\u0026amp;gt; dummy\u0026lt;/code\u0026gt; line. I\u0026apos;m fairly certain that \u0026lt;code\u0026gt;inUnion\u0026lt;/code\u0026gt; is a dependent name, and VC++ is quite right in choking on it.\u0026lt;br\u0026gt;\nI also know that I should be able to add \u0026lt;code\u0026gt;template\u0026lt;/code\u0026gt; somewhere to tell the compiler that inUnion is a template-id. But where exactly? And should it then assume that inUnion is a class template, i.e. \u0026lt;code\u0026gt;inUnion\u0026amp;lt;U\u0026amp;gt;\u0026lt;/code\u0026gt; names a type and not a function?\u0026lt;/p\u0026gt;\n    ","slug":"where-and-why-do-i-have-to-put-the-\"template\"-and-\"typename\"-keywords-1657384467606","postType":"QUESTION","createdAt":"2022-07-09T16:34:27.000Z","updatedAt":"2022-07-09T16:34:27.000Z","tags":[{"id":239,"name":"typename","slug":"typename","createdAt":"2022-07-09T16:34:27.000Z","updatedAt":"2022-07-09T16:34:27.000Z","Questions_Tags":{"questionId":65,"tagId":239}},{"id":241,"name":"dependent-name","slug":"dependent-name","createdAt":"2022-07-09T16:34:27.000Z","updatedAt":"2022-07-09T16:34:27.000Z","Questions_Tags":{"questionId":65,"tagId":241}}],"relatedQuestions":[{"title":"Where and why do I have to put the \"template\" and \"typename\" keywords?","slug":"where-and-why-do-i-have-to-put-the-\"template\"-and-\"typename\"-keywords-1657384467606","tags":[{"name":"typename","Questions_Tags":{"questionId":65,"tagId":239}},{"name":"dependent-name","Questions_Tags":{"questionId":65,"tagId":241}}]}]},"randomQuestions":[{"title":"How do I determine the correct path for FXML files, CSS files, Images, and other resources needed by my JavaFX Application?","slug":"how-do-i-determine-the-correct-path-for-fxml-files-css-files-images-and-other-resources-needed-by-my-javafx-application-1657388143988"},{"title":"Why Use Integer Instead of Long?","slug":"why-use-integer-instead-of-long-1657388012352"},{"title":"How to access the correct `this` inside a callback","slug":"how-to-access-the-correct-this-inside-a-callback-1657384283261"},{"title":"How do I set a variable to the output of a command in Bash?","slug":"how-do-i-set-a-variable-to-the-output-of-a-command-in-bash-1657387250909"},{"title":"MySQL pivot row into dynamic number of columns","slug":"mysql-pivot-row-into-dynamic-number-of-columns-1657387981930"},{"title":"How to remove items from a list while iterating?","slug":"how-to-remove-items-from-a-list-while-iterating-1657384496375"},{"title":"GUI not working after rewriting to MVC","slug":"gui-not-working-after-rewriting-to-mvc-1657388388035"},{"title":"What is the strict aliasing rule?","slug":"what-is-the-strict-aliasing-rule-1657384742852"},{"title":"Are 'Arrow Functions' and 'Functions' equivalent / interchangeable?","slug":"are-'arrow-functions'-and-'functions'-equivalent-interchangeable-1657384527873"},{"title":"How do I profile C++ code running on Linux?","slug":"how-do-i-profile-c++-code-running-on-linux-1657384754272"},{"title":"Why does Date.parse give incorrect results?","slug":"why-does-date.parse-give-incorrect-results-1657384642821"},{"title":"JavaScript property access: dot notation vs. brackets?","slug":"javascript-property-access:-dot-notation-vs.-brackets-1657384717494"},{"title":"Are dictionaries ordered in Python 3.6+?","slug":"are-dictionaries-ordered-in-python-3.6+-1657387834234"},{"title":"How do I use arrays in C++?","slug":"how-do-i-use-arrays-in-c++-1657387456118"},{"title":"jQuery Ajax File Upload","slug":"jquery-ajax-file-upload-1657387368970"},{"title":"Most efficient method to groupby on an array of objects","slug":"most-efficient-method-to-groupby-on-an-array-of-objects-1657387580538"},{"title":"CSS selector for first element with class","slug":"css-selector-for-first-element-with-class-1657388028765"},{"title":"How do I format a date in JavaScript?","slug":"how-do-i-format-a-date-in-javascript-1657384649498"},{"title":"Crash or \"segmentation fault\" when data is copied/scanned/read to an uninitialized pointer","slug":"crash-or-\"segmentation-fault\"-when-data-is-copiedscannedread-to-an-uninitialized-pointer-1657387520581"},{"title":"What is dependency injection?","slug":"what-is-dependency-injection-1657387953056"}]},"__N_SSG":true},"page":"/questions/[slug]","query":{"slug":"where-and-why-do-i-have-to-put-the-\"template\"-and-\"typename\"-keywords-1657384467606"},"buildId":"xZs8haGjOP63QuDE0kxeX","isFallback":false,"gsp":true,"locale":"en","locales":["en"],"defaultLocale":"en","scriptLoader":[]}</script></body></html>