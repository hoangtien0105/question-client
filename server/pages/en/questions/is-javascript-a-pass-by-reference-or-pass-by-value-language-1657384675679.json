{"pageProps":{"data":{"answer":["\n&lt;p&gt;It&apos;s interesting in JavaScript. Consider this example:&lt;/p&gt;\n&lt;p&gt;&lt;/p&gt;&lt;div class=&quot;snippet&quot; data-lang=&quot;js&quot; data-hide=&quot;false&quot; data-console=&quot;true&quot; data-babel=&quot;false&quot;&gt;\n&lt;div class=&quot;snippet-code&quot;&gt;\n&lt;pre class=&quot;snippet-code-js lang-js s-code-block&quot;&gt;&lt;code class=&quot;hljs language-javascript&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;changeStuff&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;a, b, c&lt;/span&gt;)\n{\n  a = a * &lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;;\n  b.&lt;span class=&quot;hljs-property&quot;&gt;item&lt;/span&gt; = &lt;span class=&quot;hljs-string&quot;&gt;&quot;changed&quot;&lt;/span&gt;;\n  c = {&lt;span class=&quot;hljs-attr&quot;&gt;item&lt;/span&gt;: &lt;span class=&quot;hljs-string&quot;&gt;&quot;changed&quot;&lt;/span&gt;};\n}\n\n&lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; num = &lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;;\n&lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; obj1 = {&lt;span class=&quot;hljs-attr&quot;&gt;item&lt;/span&gt;: &lt;span class=&quot;hljs-string&quot;&gt;&quot;unchanged&quot;&lt;/span&gt;};\n&lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; obj2 = {&lt;span class=&quot;hljs-attr&quot;&gt;item&lt;/span&gt;: &lt;span class=&quot;hljs-string&quot;&gt;&quot;unchanged&quot;&lt;/span&gt;};\n\n&lt;span class=&quot;hljs-title function_&quot;&gt;changeStuff&lt;/span&gt;(num, obj1, obj2);\n\n&lt;span class=&quot;hljs-variable language_&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;hljs-title function_&quot;&gt;log&lt;/span&gt;(num);\n&lt;span class=&quot;hljs-variable language_&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;hljs-title function_&quot;&gt;log&lt;/span&gt;(obj1.&lt;span class=&quot;hljs-property&quot;&gt;item&lt;/span&gt;);\n&lt;span class=&quot;hljs-variable language_&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;hljs-title function_&quot;&gt;log&lt;/span&gt;(obj2.&lt;span class=&quot;hljs-property&quot;&gt;item&lt;/span&gt;);&lt;/code&gt;&lt;/pre&gt;\n&lt;div class=&quot;snippet-result&quot;&gt;&lt;div class=&quot;snippet-ctas&quot;&gt;&lt;button type=&quot;button&quot; class=&quot;s-btn s-btn__primary&quot;&gt;&lt;span class=&quot;icon-play-white _hover&quot;&gt;&lt;/span&gt;&lt;span&gt; Run code snippet&lt;/span&gt;&lt;/button&gt;&lt;input class=&quot;copySnippet s-btn s-btn__filled&quot; type=&quot;button&quot; value=&quot;Copy snippet to answer&quot; style=&quot;display: none;&quot;&gt;&lt;button type=&quot;button&quot; class=&quot;s-btn hideResults&quot; style=&quot;display: none;&quot;&gt;Hide results&lt;/button&gt;&lt;div class=&quot;popout-code&quot;&gt;&lt;a class=&quot;snippet-expand-link&quot;&gt;Expand snippet&lt;/a&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class=&quot;snippet-result-code&quot; style=&quot;display: none;&quot;&gt;&lt;iframe name=&quot;sif1&quot; sandbox=&quot;allow-forms allow-modals allow-scripts&quot; class=&quot;snippet-box-edit snippet-box-result&quot; frameborder=&quot;0&quot;&gt;&lt;/iframe&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;\n&lt;/div&gt;\n&lt;p&gt;&lt;/p&gt;\n&lt;p&gt;This produces the output:&lt;/p&gt;\n&lt;pre class=&quot;lang-none s-code-block&quot;&gt;&lt;code&gt;10\nchanged\nunchanged\n&lt;/code&gt;&lt;/pre&gt;\n&lt;ul&gt;\n&lt;li&gt;If &lt;code&gt;obj1&lt;/code&gt; was not a reference at all, then changing &lt;code&gt;obj1.item&lt;/code&gt; would have no effect on the &lt;code&gt;obj1&lt;/code&gt; outside of the function.&lt;/li&gt;\n&lt;li&gt;If the argument was a proper reference, then everything would have changed. &lt;code&gt;num&lt;/code&gt; would be &lt;code&gt;100&lt;/code&gt;, and &lt;code&gt;obj2.item&lt;/code&gt; would read &lt;code&gt;&quot;changed&quot;&lt;/code&gt;. Instead, &lt;code&gt;num&lt;/code&gt; stays &lt;code&gt;10&lt;/code&gt; and &lt;code&gt;obj2.item&lt;/code&gt; remains &lt;code&gt;&quot;unchanged&lt;/code&gt;&quot;.&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;Instead, the situation is that the item passed in is passed by value. But the item that is passed by value is &lt;em&gt;itself&lt;/em&gt; a reference.\nTechnically, this is called &lt;a href=&quot;http://en.wikipedia.org/wiki/Evaluation_strategy#Call_by_sharing&quot; rel=&quot;noreferrer&quot;&gt;call-by-sharing&lt;/a&gt;.&lt;/p&gt;\n&lt;p&gt;In practical terms, this means that if you change the parameter itself (as with &lt;code&gt;num&lt;/code&gt; and &lt;code&gt;obj2&lt;/code&gt;), that won&apos;t affect the item that was fed into the parameter. But if you change the &lt;em&gt;internals&lt;/em&gt; of the parameter, that will propagate back up (as with &lt;code&gt;obj1&lt;/code&gt;).&lt;/p&gt;\n    ","\n&lt;p&gt;It&apos;s always pass by value, but for objects the value of the variable is a reference.  Because of this, when you pass an object and change its &lt;em&gt;members&lt;/em&gt;, those changes persist outside of the function.  This makes it &lt;em&gt;look&lt;/em&gt; like pass by reference.  But if you actually change the value of the object variable you will see that the change does not persist, proving it&apos;s really pass by value.&lt;/p&gt;\n\n&lt;p&gt;Example:&lt;/p&gt;\n\n&lt;p&gt;&lt;/p&gt;&lt;div class=&quot;snippet&quot; data-lang=&quot;js&quot; data-hide=&quot;false&quot; data-console=&quot;true&quot; data-babel=&quot;false&quot;&gt;\n&lt;div class=&quot;snippet-code&quot;&gt;\n&lt;pre class=&quot;snippet-code-js lang-js s-code-block&quot;&gt;&lt;code class=&quot;hljs language-javascript&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;changeObject&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;x&lt;/span&gt;) {\n  x = { &lt;span class=&quot;hljs-attr&quot;&gt;member&lt;/span&gt;: &lt;span class=&quot;hljs-string&quot;&gt;&quot;bar&quot;&lt;/span&gt; };\n  &lt;span class=&quot;hljs-variable language_&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;hljs-title function_&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;in changeObject: &quot;&lt;/span&gt; + x.&lt;span class=&quot;hljs-property&quot;&gt;member&lt;/span&gt;);\n}\n\n&lt;span class=&quot;hljs-keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;changeMember&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;x&lt;/span&gt;) {\n  x.&lt;span class=&quot;hljs-property&quot;&gt;member&lt;/span&gt; = &lt;span class=&quot;hljs-string&quot;&gt;&quot;bar&quot;&lt;/span&gt;;\n  &lt;span class=&quot;hljs-variable language_&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;hljs-title function_&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;in changeMember: &quot;&lt;/span&gt; + x.&lt;span class=&quot;hljs-property&quot;&gt;member&lt;/span&gt;);\n}\n\n&lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; x = { &lt;span class=&quot;hljs-attr&quot;&gt;member&lt;/span&gt;: &lt;span class=&quot;hljs-string&quot;&gt;&quot;foo&quot;&lt;/span&gt; };\n\n&lt;span class=&quot;hljs-variable language_&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;hljs-title function_&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;before changeObject: &quot;&lt;/span&gt; + x.&lt;span class=&quot;hljs-property&quot;&gt;member&lt;/span&gt;);\n&lt;span class=&quot;hljs-title function_&quot;&gt;changeObject&lt;/span&gt;(x);\n&lt;span class=&quot;hljs-variable language_&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;hljs-title function_&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;after changeObject: &quot;&lt;/span&gt; + x.&lt;span class=&quot;hljs-property&quot;&gt;member&lt;/span&gt;); &lt;span class=&quot;hljs-comment&quot;&gt;/* change did not persist */&lt;/span&gt;\n\n&lt;span class=&quot;hljs-variable language_&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;hljs-title function_&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;before changeMember: &quot;&lt;/span&gt; + x.&lt;span class=&quot;hljs-property&quot;&gt;member&lt;/span&gt;);\n&lt;span class=&quot;hljs-title function_&quot;&gt;changeMember&lt;/span&gt;(x);\n&lt;span class=&quot;hljs-variable language_&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;hljs-title function_&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;after changeMember: &quot;&lt;/span&gt; + x.&lt;span class=&quot;hljs-property&quot;&gt;member&lt;/span&gt;); &lt;span class=&quot;hljs-comment&quot;&gt;/* change persists */&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;\n&lt;div class=&quot;snippet-result&quot;&gt;&lt;div class=&quot;snippet-ctas&quot;&gt;&lt;button type=&quot;button&quot; class=&quot;s-btn s-btn__primary&quot;&gt;&lt;span class=&quot;icon-play-white _hover&quot;&gt;&lt;/span&gt;&lt;span&gt; Run code snippet&lt;/span&gt;&lt;/button&gt;&lt;input class=&quot;copySnippet s-btn s-btn__filled&quot; type=&quot;button&quot; value=&quot;Copy snippet to answer&quot; style=&quot;display: none;&quot;&gt;&lt;button type=&quot;button&quot; class=&quot;s-btn hideResults&quot; style=&quot;display: none;&quot;&gt;Hide results&lt;/button&gt;&lt;div class=&quot;popout-code&quot;&gt;&lt;a class=&quot;snippet-expand-link&quot;&gt;Expand snippet&lt;/a&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class=&quot;snippet-result-code&quot; style=&quot;display: none;&quot;&gt;&lt;iframe name=&quot;sif2&quot; sandbox=&quot;allow-forms allow-modals allow-scripts&quot; class=&quot;snippet-box-edit snippet-box-result&quot; frameborder=&quot;0&quot;&gt;&lt;/iframe&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;\n&lt;/div&gt;\n&lt;p&gt;&lt;/p&gt;\n\n&lt;p&gt;Output:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-js s-code-block&quot;&gt;&lt;code class=&quot;hljs language-javascript&quot;&gt;before &lt;span class=&quot;hljs-attr&quot;&gt;changeObject&lt;/span&gt;: foo\n&lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;hljs-attr&quot;&gt;changeObject&lt;/span&gt;: bar\nafter &lt;span class=&quot;hljs-attr&quot;&gt;changeObject&lt;/span&gt;: foo\n\nbefore &lt;span class=&quot;hljs-attr&quot;&gt;changeMember&lt;/span&gt;: foo\n&lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;hljs-attr&quot;&gt;changeMember&lt;/span&gt;: bar\nafter &lt;span class=&quot;hljs-attr&quot;&gt;changeMember&lt;/span&gt;: bar\n&lt;/code&gt;&lt;/pre&gt;\n    ","\n&lt;p&gt;The variable doesn&apos;t &quot;hold&quot; the object; it holds a reference. You can assign that reference to another variable, and now both reference the same object. It&apos;s always pass by value (even when that value is a reference...).&lt;/p&gt;\n\n&lt;p&gt;There&apos;s no way to alter the value held by a variable passed as a parameter, which would be possible if JavaScript supported passing by reference.&lt;/p&gt;\n    ","\n&lt;p&gt;My two cents... This is the way I understand it. (Feel free to correct me if I&apos;m wrong)&lt;/p&gt;\n&lt;p&gt;It&apos;s time to throw out everything you know about pass by value / reference.&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;Because in JavaScript, it doesn&apos;t matter whether it&apos;s passed by value or by reference or whatever.\nWhat matters is mutation vs assignment of the parameters passed into a function.&lt;/strong&gt;&lt;/p&gt;\n&lt;p&gt;OK, let me do my best to explain what I mean. Let&apos;s say you have a few objects.&lt;/p&gt;\n&lt;pre class=&quot;lang-js s-code-block&quot;&gt;&lt;code class=&quot;hljs language-javascript&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; object1 = {};\n&lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; object2 = {};\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;What we have done is &quot;assignment&quot;... We&apos;ve assigned 2 separate empty objects to the variables &quot;object1&quot; and &quot;object2&quot;.&lt;/p&gt;\n&lt;p&gt;Now, let&apos;s say that we like object1 better... So, we &quot;assign&quot; a new variable.&lt;/p&gt;\n&lt;pre class=&quot;lang-js s-code-block&quot;&gt;&lt;code class=&quot;hljs language-javascript&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; favoriteObject = object1;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;Next, for whatever reason, we decide that we like object 2 better. So, we do a little re-assignment.&lt;/p&gt;\n&lt;pre class=&quot;lang-js s-code-block&quot;&gt;&lt;code class=&quot;hljs language-javascript&quot;&gt;favoriteObject = object2;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;Nothing happened to object1 or to object2. We haven&apos;t changed any data at all. All we did was re-assign what our favorite object is. It is important to know that object2 and favoriteObject are both assigned to the same object. We can change that object via either of those variables.&lt;/p&gt;\n&lt;pre class=&quot;lang-js s-code-block&quot;&gt;&lt;code class=&quot;hljs language-javascript&quot;&gt;object2.&lt;span class=&quot;hljs-property&quot;&gt;name&lt;/span&gt; = &lt;span class=&quot;hljs-string&quot;&gt;&apos;Fred&apos;&lt;/span&gt;;\n&lt;span class=&quot;hljs-variable language_&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;hljs-title function_&quot;&gt;log&lt;/span&gt;(favoriteObject.&lt;span class=&quot;hljs-property&quot;&gt;name&lt;/span&gt;) &lt;span class=&quot;hljs-comment&quot;&gt;// Logs Fred&lt;/span&gt;\nfavoriteObject.&lt;span class=&quot;hljs-property&quot;&gt;name&lt;/span&gt; = &lt;span class=&quot;hljs-string&quot;&gt;&apos;Joe&apos;&lt;/span&gt;;\n&lt;span class=&quot;hljs-variable language_&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;hljs-title function_&quot;&gt;log&lt;/span&gt;(object2.&lt;span class=&quot;hljs-property&quot;&gt;name&lt;/span&gt;); &lt;span class=&quot;hljs-comment&quot;&gt;// Logs Joe&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;OK, now let&apos;s look at primitives like strings for example&lt;/p&gt;\n&lt;pre class=&quot;lang-js s-code-block&quot;&gt;&lt;code class=&quot;hljs language-javascript&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; string1 = &lt;span class=&quot;hljs-string&quot;&gt;&apos;Hello world&apos;&lt;/span&gt;;\n&lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; string2 = &lt;span class=&quot;hljs-string&quot;&gt;&apos;Goodbye world&apos;&lt;/span&gt;;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;Again, we pick a favorite.&lt;/p&gt;\n&lt;pre class=&quot;lang-js s-code-block&quot;&gt;&lt;code class=&quot;hljs language-javascript&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; favoriteString = string1;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;Both our favoriteString and string1 variables are assigned to &apos;Hello world&apos;. Now, what if we want to change our favoriteString??? What will happen???&lt;/p&gt;\n&lt;pre class=&quot;lang-js s-code-block&quot;&gt;&lt;code class=&quot;hljs language-javascript&quot;&gt;favoriteString = &lt;span class=&quot;hljs-string&quot;&gt;&apos;Hello everyone&apos;&lt;/span&gt;;\n&lt;span class=&quot;hljs-variable language_&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;hljs-title function_&quot;&gt;log&lt;/span&gt;(favoriteString); &lt;span class=&quot;hljs-comment&quot;&gt;// Logs &apos;Hello everyone&apos;&lt;/span&gt;\n&lt;span class=&quot;hljs-variable language_&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;hljs-title function_&quot;&gt;log&lt;/span&gt;(string1); &lt;span class=&quot;hljs-comment&quot;&gt;// Logs &apos;Hello world&apos;&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;Uh oh.... What has happened. We couldn&apos;t change string1 by changing favoriteString... Why?? Because we didn&apos;t &lt;em&gt;change&lt;/em&gt; our string &lt;em&gt;object&lt;/em&gt;. All we did was &quot;RE ASSIGN&quot; the favoriteString &lt;em&gt;variable&lt;/em&gt; to a new string. This essentially disconnected it from string1. In the previous example, when we renamed our object, we didn&apos;t assign anything. (Well, not to the &lt;em&gt;variable itself&lt;/em&gt;, ... we did, however, assign the name property to a new string.) Instead, we mutated the object which keeps the connections between the 2 variables and the underlying objects. (Even if we had wanted to modify or &lt;em&gt;mutate&lt;/em&gt; the string object &lt;em&gt;itself&lt;/em&gt;, we couldn&apos;t have, because strings are actually immutable in JavaScript.)&lt;/p&gt;\n&lt;p&gt;Now, on to functions and passing parameters.... When you call a function, and pass a parameter, what you are essentially doing is an &quot;assignment&quot; to a new variable, and it works exactly the same as if you assigned using the equal (=) sign.&lt;/p&gt;\n&lt;p&gt;Take these examples.&lt;/p&gt;\n&lt;pre class=&quot;lang-js s-code-block&quot;&gt;&lt;code class=&quot;hljs language-javascript&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; myString = &lt;span class=&quot;hljs-string&quot;&gt;&apos;hello&apos;&lt;/span&gt;;\n\n&lt;span class=&quot;hljs-comment&quot;&gt;// Assign to a new variable (just like when you pass to a function)&lt;/span&gt;\n&lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; param1 = myString;\nparam1 = &lt;span class=&quot;hljs-string&quot;&gt;&apos;world&apos;&lt;/span&gt;; &lt;span class=&quot;hljs-comment&quot;&gt;// Re assignment&lt;/span&gt;\n\n&lt;span class=&quot;hljs-variable language_&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;hljs-title function_&quot;&gt;log&lt;/span&gt;(myString); &lt;span class=&quot;hljs-comment&quot;&gt;// Logs &apos;hello&apos;&lt;/span&gt;\n&lt;span class=&quot;hljs-variable language_&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;hljs-title function_&quot;&gt;log&lt;/span&gt;(param1);   &lt;span class=&quot;hljs-comment&quot;&gt;// Logs &apos;world&apos;&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;Now, the same thing, but with a function&lt;/p&gt;\n&lt;pre class=&quot;lang-js s-code-block&quot;&gt;&lt;code class=&quot;hljs language-javascript&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;myFunc&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;param1&lt;/span&gt;) {\n    param1 = &lt;span class=&quot;hljs-string&quot;&gt;&apos;world&apos;&lt;/span&gt;;\n\n    &lt;span class=&quot;hljs-variable language_&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;hljs-title function_&quot;&gt;log&lt;/span&gt;(param1);   &lt;span class=&quot;hljs-comment&quot;&gt;// Logs &apos;world&apos;&lt;/span&gt;\n}\n\n&lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; myString = &lt;span class=&quot;hljs-string&quot;&gt;&apos;hello&apos;&lt;/span&gt;;\n&lt;span class=&quot;hljs-comment&quot;&gt;// Calls myFunc and assigns param1 to myString just like param1 = myString&lt;/span&gt;\n&lt;span class=&quot;hljs-title function_&quot;&gt;myFunc&lt;/span&gt;(myString);\n\n&lt;span class=&quot;hljs-variable language_&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;hljs-title function_&quot;&gt;log&lt;/span&gt;(myString); &lt;span class=&quot;hljs-comment&quot;&gt;// logs &apos;hello&apos;&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;OK, now lets give a few examples using objects instead... first, without the function.&lt;/p&gt;\n&lt;pre class=&quot;lang-js s-code-block&quot;&gt;&lt;code class=&quot;hljs language-javascript&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; myObject = {\n    &lt;span class=&quot;hljs-attr&quot;&gt;firstName&lt;/span&gt;: &lt;span class=&quot;hljs-string&quot;&gt;&apos;Joe&apos;&lt;/span&gt;,\n    &lt;span class=&quot;hljs-attr&quot;&gt;lastName&lt;/span&gt;: &lt;span class=&quot;hljs-string&quot;&gt;&apos;Smith&apos;&lt;/span&gt;\n};\n\n&lt;span class=&quot;hljs-comment&quot;&gt;// Assign to a new variable (just like when you pass to a function)&lt;/span&gt;\n&lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; otherObj = myObject;\n\n&lt;span class=&quot;hljs-comment&quot;&gt;// Let&apos;s mutate our object&lt;/span&gt;\notherObj.&lt;span class=&quot;hljs-property&quot;&gt;firstName&lt;/span&gt; = &lt;span class=&quot;hljs-string&quot;&gt;&apos;Sue&apos;&lt;/span&gt;; &lt;span class=&quot;hljs-comment&quot;&gt;// I guess Joe decided to be a girl&lt;/span&gt;\n\n&lt;span class=&quot;hljs-variable language_&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;hljs-title function_&quot;&gt;log&lt;/span&gt;(myObject.&lt;span class=&quot;hljs-property&quot;&gt;firstName&lt;/span&gt;); &lt;span class=&quot;hljs-comment&quot;&gt;// Logs &apos;Sue&apos;&lt;/span&gt;\n&lt;span class=&quot;hljs-variable language_&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;hljs-title function_&quot;&gt;log&lt;/span&gt;(otherObj.&lt;span class=&quot;hljs-property&quot;&gt;firstName&lt;/span&gt;); &lt;span class=&quot;hljs-comment&quot;&gt;// Logs &apos;Sue&apos;&lt;/span&gt;\n\n&lt;span class=&quot;hljs-comment&quot;&gt;// Now, let&apos;s reassign the variable&lt;/span&gt;\notherObj = {\n    &lt;span class=&quot;hljs-attr&quot;&gt;firstName&lt;/span&gt;: &lt;span class=&quot;hljs-string&quot;&gt;&apos;Jack&apos;&lt;/span&gt;,\n    &lt;span class=&quot;hljs-attr&quot;&gt;lastName&lt;/span&gt;: &lt;span class=&quot;hljs-string&quot;&gt;&apos;Frost&apos;&lt;/span&gt;\n};\n\n&lt;span class=&quot;hljs-comment&quot;&gt;// Now, otherObj and myObject are assigned to 2 very different objects&lt;/span&gt;\n&lt;span class=&quot;hljs-comment&quot;&gt;// And mutating one object has no influence on the other&lt;/span&gt;\n&lt;span class=&quot;hljs-variable language_&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;hljs-title function_&quot;&gt;log&lt;/span&gt;(myObject.&lt;span class=&quot;hljs-property&quot;&gt;firstName&lt;/span&gt;); &lt;span class=&quot;hljs-comment&quot;&gt;// Logs &apos;Sue&apos;&lt;/span&gt;\n&lt;span class=&quot;hljs-variable language_&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;hljs-title function_&quot;&gt;log&lt;/span&gt;(otherObj.&lt;span class=&quot;hljs-property&quot;&gt;firstName&lt;/span&gt;); &lt;span class=&quot;hljs-comment&quot;&gt;// Logs &apos;Jack&apos;;&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;Now, the same thing, but with a function call&lt;/p&gt;\n&lt;pre class=&quot;lang-js s-code-block&quot;&gt;&lt;code class=&quot;hljs language-javascript&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;myFunc&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;otherObj&lt;/span&gt;) {\n\n    &lt;span class=&quot;hljs-comment&quot;&gt;// Let&apos;s mutate our object&lt;/span&gt;\n    otherObj.&lt;span class=&quot;hljs-property&quot;&gt;firstName&lt;/span&gt; = &lt;span class=&quot;hljs-string&quot;&gt;&apos;Sue&apos;&lt;/span&gt;;\n    &lt;span class=&quot;hljs-variable language_&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;hljs-title function_&quot;&gt;log&lt;/span&gt;(otherObj.&lt;span class=&quot;hljs-property&quot;&gt;firstName&lt;/span&gt;); &lt;span class=&quot;hljs-comment&quot;&gt;// Logs &apos;Sue&apos;&lt;/span&gt;\n\n    &lt;span class=&quot;hljs-comment&quot;&gt;// Now let&apos;s re-assign&lt;/span&gt;\n    otherObj = {\n        &lt;span class=&quot;hljs-attr&quot;&gt;firstName&lt;/span&gt;: &lt;span class=&quot;hljs-string&quot;&gt;&apos;Jack&apos;&lt;/span&gt;,\n        &lt;span class=&quot;hljs-attr&quot;&gt;lastName&lt;/span&gt;: &lt;span class=&quot;hljs-string&quot;&gt;&apos;Frost&apos;&lt;/span&gt;\n    };\n    &lt;span class=&quot;hljs-variable language_&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;hljs-title function_&quot;&gt;log&lt;/span&gt;(otherObj.&lt;span class=&quot;hljs-property&quot;&gt;firstName&lt;/span&gt;); &lt;span class=&quot;hljs-comment&quot;&gt;// Logs &apos;Jack&apos;&lt;/span&gt;\n\n    &lt;span class=&quot;hljs-comment&quot;&gt;// Again, otherObj and myObject are assigned to 2 very different objects&lt;/span&gt;\n    &lt;span class=&quot;hljs-comment&quot;&gt;// And mutating one object doesn&apos;t magically mutate the other&lt;/span&gt;\n}\n\n&lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; myObject = {\n    &lt;span class=&quot;hljs-attr&quot;&gt;firstName&lt;/span&gt;: &lt;span class=&quot;hljs-string&quot;&gt;&apos;Joe&apos;&lt;/span&gt;,\n    &lt;span class=&quot;hljs-attr&quot;&gt;lastName&lt;/span&gt;: &lt;span class=&quot;hljs-string&quot;&gt;&apos;Smith&apos;&lt;/span&gt;\n};\n\n&lt;span class=&quot;hljs-comment&quot;&gt;// Calls myFunc and assigns otherObj to myObject just like otherObj = myObject&lt;/span&gt;\n&lt;span class=&quot;hljs-title function_&quot;&gt;myFunc&lt;/span&gt;(myObject);\n\n&lt;span class=&quot;hljs-variable language_&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;hljs-title function_&quot;&gt;log&lt;/span&gt;(myObject.&lt;span class=&quot;hljs-property&quot;&gt;firstName&lt;/span&gt;); &lt;span class=&quot;hljs-comment&quot;&gt;// Logs &apos;Sue&apos;, just like before&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;OK, if you read through this entire post, perhaps you now have a better understanding of how function calls work in JavaScript. It doesn&apos;t matter whether something is passed by reference or by value... What matters is assignment vs mutation.&lt;/p&gt;\n&lt;p&gt;Every time you pass a variable to a function, you are &quot;Assigning&quot; to whatever the name of the parameter variable is, just like if you used the equal (=) sign.&lt;/p&gt;\n&lt;p&gt;Always remember that the equals sign (=) means assignment.\nAlways remember that passing a parameter to a function &lt;em&gt;in JavaScript&lt;/em&gt; also means assignment.\nThey are the same and the 2 variables are connected in exactly the same way (which is to say they aren&apos;t, unless you count that they are assigned to the same object).&lt;/p&gt;\n&lt;p&gt;The only time that &quot;modifying a variable&quot; affects a different variable is when the underlying object is mutated (in which case you haven&apos;t modified the variable, but the object itself.&lt;/p&gt;\n&lt;p&gt;There is no point in making a distinction between objects and primitives, because it works the same exact way as if you didn&apos;t have a function and just used the equal sign to assign to a new variable.&lt;/p&gt;\n&lt;p&gt;The only gotcha is when the name of the variable you pass into the function is the same as the name of the function parameter. When this happens, you have to treat the parameter inside the function as if it was a whole new variable private to the function (because it is)&lt;/p&gt;\n&lt;pre class=&quot;lang-js s-code-block&quot;&gt;&lt;code class=&quot;hljs language-javascript&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;myFunc&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;myString&lt;/span&gt;) {\n    &lt;span class=&quot;hljs-comment&quot;&gt;// myString is private and does not affect the outer variable&lt;/span&gt;\n    myString = &lt;span class=&quot;hljs-string&quot;&gt;&apos;hello&apos;&lt;/span&gt;;\n}\n\n&lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; myString = &lt;span class=&quot;hljs-string&quot;&gt;&apos;test&apos;&lt;/span&gt;;\nmyString = myString; &lt;span class=&quot;hljs-comment&quot;&gt;// Does nothing, myString is still &apos;test&apos;;&lt;/span&gt;\n\n&lt;span class=&quot;hljs-title function_&quot;&gt;myFunc&lt;/span&gt;(myString);\n&lt;span class=&quot;hljs-variable language_&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;hljs-title function_&quot;&gt;log&lt;/span&gt;(myString); &lt;span class=&quot;hljs-comment&quot;&gt;// Logs &apos;test&apos;&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n    ","\n\n&lt;p&gt;These phrases/concepts were originally defined long before JS was created and they don&apos;t accurately describe the semantics for javascript. I think trying to apply them to JS causes more confusion than not.&lt;/p&gt;\n&lt;p&gt;So don&apos;t get hung up on &quot;pass by reference/value&quot;.&lt;/p&gt;\n&lt;p&gt;Consider the following:&lt;/p&gt;\n&lt;ol&gt;\n&lt;li&gt;Variables are &lt;em&gt;pointers&lt;/em&gt; to values.&lt;/li&gt;\n&lt;li&gt;Reassigning a variable merely points that pointer at a new value.&lt;/li&gt;\n&lt;li&gt;Reassigning a variable will never affect other variables that were pointing at that same object because each variable has its own pointer.&lt;/li&gt;\n&lt;/ol&gt;\n&lt;p&gt;So if I had to give it a name I&apos;d say &lt;strong&gt;&quot;pass-by-pointer&quot;&lt;/strong&gt; -- we don&apos;t deal with pointers in JS but the underlying engine does.&lt;/p&gt;\n&lt;br&gt;\n&lt;pre class=&quot;lang-js s-code-block&quot;&gt;&lt;code class=&quot;hljs language-javascript&quot;&gt;&lt;span class=&quot;hljs-comment&quot;&gt;// code&lt;/span&gt;\n&lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; obj = {\n    &lt;span class=&quot;hljs-attr&quot;&gt;name&lt;/span&gt;: &lt;span class=&quot;hljs-string&quot;&gt;&apos;Fred&apos;&lt;/span&gt;,\n    &lt;span class=&quot;hljs-attr&quot;&gt;num&lt;/span&gt;: &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;\n};\n\n&lt;span class=&quot;hljs-comment&quot;&gt;// illustration&lt;/span&gt;\n               &lt;span class=&quot;hljs-string&quot;&gt;&apos;Fred&apos;&lt;/span&gt;\n              /\n             /\n(obj) ---- {}\n             \\\n              \\\n               &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;br&gt;\n&lt;pre class=&quot;lang-js s-code-block&quot;&gt;&lt;code class=&quot;hljs language-javascript&quot;&gt;&lt;span class=&quot;hljs-comment&quot;&gt;// code&lt;/span&gt;\nobj.&lt;span class=&quot;hljs-property&quot;&gt;name&lt;/span&gt; = &lt;span class=&quot;hljs-string&quot;&gt;&apos;George&apos;&lt;/span&gt;;\n\n\n&lt;span class=&quot;hljs-comment&quot;&gt;// illustration&lt;/span&gt;\n                 &lt;span class=&quot;hljs-string&quot;&gt;&apos;Fred&apos;&lt;/span&gt;\n\n\n(obj) ---- {} ----- &lt;span class=&quot;hljs-string&quot;&gt;&apos;George&apos;&lt;/span&gt;\n             \\\n              \\\n               &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;br&gt;\n&lt;pre class=&quot;lang-js s-code-block&quot;&gt;&lt;code class=&quot;hljs language-javascript&quot;&gt;&lt;span class=&quot;hljs-comment&quot;&gt;// code&lt;/span&gt;\nobj = {};\n\n&lt;span class=&quot;hljs-comment&quot;&gt;// illustration&lt;/span&gt;\n                 &lt;span class=&quot;hljs-string&quot;&gt;&apos;Fred&apos;&lt;/span&gt;\n\n\n(obj)      {} ----- &lt;span class=&quot;hljs-string&quot;&gt;&apos;George&apos;&lt;/span&gt;\n  |          \\\n  |           \\\n { }            &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;br&gt;\n&lt;pre class=&quot;lang-js s-code-block&quot;&gt;&lt;code class=&quot;hljs language-javascript&quot;&gt;&lt;span class=&quot;hljs-comment&quot;&gt;// code&lt;/span&gt;\n&lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; obj = {\n    &lt;span class=&quot;hljs-attr&quot;&gt;text&lt;/span&gt;: &lt;span class=&quot;hljs-string&quot;&gt;&apos;Hello world!&apos;&lt;/span&gt;\n};\n\n&lt;span class=&quot;hljs-comment&quot;&gt;/* function parameters get their own pointer to \n * the arguments that are passed in, just like any other variable */&lt;/span&gt;\n&lt;span class=&quot;hljs-title function_&quot;&gt;someFunc&lt;/span&gt;(obj);\n\n\n&lt;span class=&quot;hljs-comment&quot;&gt;// illustration&lt;/span&gt;\n(caller scope)        (someFunc scope)\n           \\             /\n            \\           /\n             \\         /\n              \\       /\n               \\     /\n                 { }\n                  |\n                  |\n                  |\n            &lt;span class=&quot;hljs-string&quot;&gt;&apos;Hello world&apos;&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;Some final comments:&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;The phrases &quot;pass by value/reference&quot; are only used to describe the &lt;em&gt;behavior&lt;/em&gt; of a language, not necessarily the actual underlying implementation. As a result of this abstraction, critical details that are essential for a decent explanation are lost, which inevitably leads to the current situation where a single term doesn&apos;t adequately describe the actual behavior without additional info.&lt;/li&gt;\n&lt;li&gt;It&apos;s tempting to think that &lt;em&gt;primitives&lt;/em&gt; are enforced by special rules while &lt;em&gt;objects&lt;/em&gt; are not, but primitives are simply the end of the pointer chain.&lt;/li&gt;\n&lt;li&gt;As a final example, consider why a common attempt to clear an array doesn&apos;t work as expected.&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;&lt;/p&gt;&lt;div class=&quot;snippet&quot; data-lang=&quot;js&quot; data-hide=&quot;false&quot; data-console=&quot;true&quot; data-babel=&quot;false&quot;&gt;\n&lt;div class=&quot;snippet-code&quot;&gt;\n&lt;pre class=&quot;snippet-code-js lang-js s-code-block&quot;&gt;&lt;code class=&quot;hljs language-javascript&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; a = [&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;];\n&lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; b = a;\n\na = [];\n&lt;span class=&quot;hljs-variable language_&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;hljs-title function_&quot;&gt;log&lt;/span&gt;(b); &lt;span class=&quot;hljs-comment&quot;&gt;// [1,2]&lt;/span&gt;\n&lt;span class=&quot;hljs-comment&quot;&gt;// doesn&apos;t work because `b` is still pointing at the original array&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;\n&lt;div class=&quot;snippet-result&quot;&gt;&lt;div class=&quot;snippet-ctas&quot;&gt;&lt;button type=&quot;button&quot; class=&quot;s-btn s-btn__primary&quot;&gt;&lt;span class=&quot;icon-play-white _hover&quot;&gt;&lt;/span&gt;&lt;span&gt; Run code snippet&lt;/span&gt;&lt;/button&gt;&lt;input class=&quot;copySnippet s-btn s-btn__filled&quot; type=&quot;button&quot; value=&quot;Copy snippet to answer&quot; style=&quot;display: none;&quot;&gt;&lt;button type=&quot;button&quot; class=&quot;s-btn hideResults&quot; style=&quot;display: none;&quot;&gt;Hide results&lt;/button&gt;&lt;div class=&quot;popout-code&quot;&gt;&lt;a class=&quot;snippet-expand-link&quot;&gt;Expand snippet&lt;/a&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class=&quot;snippet-result-code&quot; style=&quot;display: none;&quot;&gt;&lt;iframe name=&quot;sif3&quot; sandbox=&quot;allow-forms allow-modals allow-scripts&quot; class=&quot;snippet-box-edit snippet-box-result&quot; frameborder=&quot;0&quot;&gt;&lt;/iframe&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;\n&lt;/div&gt;\n&lt;p&gt;&lt;/p&gt;\n    ","\n&lt;p&gt;An object outside a function is passed into a function by giving a reference to the outside object.&lt;/p&gt;\n\n&lt;p&gt;When you use that reference to manipulate its object, the object outside is thus affected. However, if inside the function you decided to point the reference to something else, you did not affect the object outside at all, because all you did was re-direct the reference to something else. &lt;/p&gt;\n    ","\n&lt;p&gt;Think of it like this: It&apos;s always pass by value. However, the value of an object is not the object itself, but a reference to that object. &lt;/p&gt;\n\n&lt;p&gt;Here is an example, passing a number (a primitive type)&lt;/p&gt;\n\n&lt;pre class=&quot;lang-js s-code-block&quot;&gt;&lt;code class=&quot;hljs language-javascript&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;changePrimitive&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;val&lt;/span&gt;) {\n    &lt;span class=&quot;hljs-comment&quot;&gt;// At this point there are two &apos;10&apos;s in memory.&lt;/span&gt;\n    &lt;span class=&quot;hljs-comment&quot;&gt;// Changing one won&apos;t affect the other&lt;/span&gt;\n    val = val * &lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;;\n}\n&lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; x = &lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;;\n&lt;span class=&quot;hljs-title function_&quot;&gt;changePrimitive&lt;/span&gt;(x);\n&lt;span class=&quot;hljs-comment&quot;&gt;// x === 10&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Repeating this with an object yields different results:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-js s-code-block&quot;&gt;&lt;code class=&quot;hljs language-javascript&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;changeObject&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;obj&lt;/span&gt;) {\n    &lt;span class=&quot;hljs-comment&quot;&gt;// At this point there are two references (x and obj) in memory,&lt;/span&gt;\n    &lt;span class=&quot;hljs-comment&quot;&gt;// but these both point to the same object.&lt;/span&gt;\n    &lt;span class=&quot;hljs-comment&quot;&gt;// changing the object will change the underlying object that&lt;/span&gt;\n    &lt;span class=&quot;hljs-comment&quot;&gt;// x and obj both hold a reference to.&lt;/span&gt;\n    obj.&lt;span class=&quot;hljs-property&quot;&gt;val&lt;/span&gt; = obj.&lt;span class=&quot;hljs-property&quot;&gt;val&lt;/span&gt; * &lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;;\n}\n&lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; x = { &lt;span class=&quot;hljs-attr&quot;&gt;val&lt;/span&gt;: &lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt; };\n&lt;span class=&quot;hljs-title function_&quot;&gt;changeObject&lt;/span&gt;(x);\n&lt;span class=&quot;hljs-comment&quot;&gt;// x === { val: 100 }&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;One more example:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-js s-code-block&quot;&gt;&lt;code class=&quot;hljs language-javascript&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;changeObject&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;obj&lt;/span&gt;) {\n    &lt;span class=&quot;hljs-comment&quot;&gt;// Again there are two references (x and obj) in memory,&lt;/span&gt;\n    &lt;span class=&quot;hljs-comment&quot;&gt;// these both point to the same object.&lt;/span&gt;\n    &lt;span class=&quot;hljs-comment&quot;&gt;// now we create a completely new object and assign it.&lt;/span&gt;\n    &lt;span class=&quot;hljs-comment&quot;&gt;// obj&apos;s reference now points to the new object.&lt;/span&gt;\n    &lt;span class=&quot;hljs-comment&quot;&gt;// x&apos;s reference doesn&apos;t change.&lt;/span&gt;\n    obj = { &lt;span class=&quot;hljs-attr&quot;&gt;val&lt;/span&gt;: &lt;span class=&quot;hljs-number&quot;&gt;100&lt;/span&gt; };\n}\n&lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; x = { &lt;span class=&quot;hljs-attr&quot;&gt;val&lt;/span&gt;: &lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt; };\n&lt;span class=&quot;hljs-title function_&quot;&gt;changeObject&lt;/span&gt;(x);\n&lt;span class=&quot;hljs-comment&quot;&gt;// x === { val: 10}&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n    ","\n&lt;p&gt;A very detailed explanation about copying, passing and comparing by value and by reference is in &lt;a href=&quot;http://docstore.mik.ua/orelly/webprog/jscript/ch11_02.htm&quot; rel=&quot;noreferrer&quot;&gt;this chapter&lt;/a&gt; of the &lt;em&gt;&quot;JavaScript: The Definitive Guide&quot;&lt;/em&gt; book.&lt;/p&gt;\n&lt;blockquote&gt;\n&lt;p&gt;Before we leave the topic of\nmanipulating objects and arrays by\nreference, we need to clear up a point\nof nomenclature.&lt;/p&gt;\n&lt;p&gt;The phrase &quot;pass by\nreference&quot; can have several meanings.\nTo some readers, the phrase refers to\na function invocation technique that\nallows a function to assign new values\nto its arguments and to have those\nmodified values visible outside the\nfunction. This is not the way the term\nis used in this book.&lt;/p&gt;\n&lt;p&gt;Here, we mean\nsimply that a reference to an object\nor array -- not the object itself --\nis passed to a function. A function\ncan use the reference to modify\nproperties of the object or elements\nof the array. But if the function\noverwrites the reference with a\nreference to a new object or array,\nthat modification is not visible\noutside of the function.&lt;/p&gt;\n&lt;p&gt;Readers\nfamiliar with the other meaning of\nthis term may prefer to say that\nobjects and arrays are passed by\nvalue, but the value that is passed is\nactually a reference rather than the\nobject itself.&lt;/p&gt;\n&lt;/blockquote&gt;\n    ","\n&lt;p&gt;JavaScript is always &lt;em&gt;pass-by-value&lt;/em&gt;; everything is of value type.&lt;/p&gt;\n&lt;p&gt;Objects are values, and member functions of objects are values themselves (remember that functions are first-class objects in JavaScript). Also, regarding the concept that everything in JavaScript is an &lt;em&gt;object&lt;/em&gt;; this is wrong. Strings, symbols, numbers, booleans, nulls, and undefineds are &lt;em&gt;primitives&lt;/em&gt;.&lt;/p&gt;\n&lt;p&gt;On occasion they can leverage some member functions and properties inherited from their base prototypes, but this is only for convenience. It does not mean that they are objects themselves. Try the following for reference:&lt;/p&gt;\n&lt;p&gt;&lt;/p&gt;&lt;div class=&quot;snippet&quot; data-lang=&quot;js&quot; data-hide=&quot;false&quot; data-console=&quot;true&quot; data-babel=&quot;false&quot;&gt;\n&lt;div class=&quot;snippet-code&quot;&gt;\n&lt;pre class=&quot;snippet-code-js lang-js s-code-block&quot;&gt;&lt;code class=&quot;hljs language-javascript&quot;&gt;x = &lt;span class=&quot;hljs-string&quot;&gt;&quot;test&quot;&lt;/span&gt;;\n&lt;span class=&quot;hljs-variable language_&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;hljs-title function_&quot;&gt;log&lt;/span&gt;(x.&lt;span class=&quot;hljs-property&quot;&gt;foo&lt;/span&gt;);\nx.&lt;span class=&quot;hljs-property&quot;&gt;foo&lt;/span&gt; = &lt;span class=&quot;hljs-number&quot;&gt;12&lt;/span&gt;;\n&lt;span class=&quot;hljs-variable language_&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;hljs-title function_&quot;&gt;log&lt;/span&gt;(x.&lt;span class=&quot;hljs-property&quot;&gt;foo&lt;/span&gt;);&lt;/code&gt;&lt;/pre&gt;\n&lt;div class=&quot;snippet-result&quot;&gt;&lt;div class=&quot;snippet-ctas&quot;&gt;&lt;button type=&quot;button&quot; class=&quot;s-btn s-btn__primary&quot;&gt;&lt;span class=&quot;icon-play-white _hover&quot;&gt;&lt;/span&gt;&lt;span&gt; Run code snippet&lt;/span&gt;&lt;/button&gt;&lt;input class=&quot;copySnippet s-btn s-btn__filled&quot; type=&quot;button&quot; value=&quot;Copy snippet to answer&quot; style=&quot;display: none;&quot;&gt;&lt;button type=&quot;button&quot; class=&quot;s-btn hideResults&quot; style=&quot;display: none;&quot;&gt;Hide results&lt;/button&gt;&lt;div class=&quot;popout-code&quot;&gt;&lt;a class=&quot;snippet-expand-link&quot;&gt;Expand snippet&lt;/a&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class=&quot;snippet-result-code&quot; style=&quot;display: none;&quot;&gt;&lt;iframe name=&quot;sif4&quot; sandbox=&quot;allow-forms allow-modals allow-scripts&quot; class=&quot;snippet-box-edit snippet-box-result&quot; frameborder=&quot;0&quot;&gt;&lt;/iframe&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;\n&lt;/div&gt;\n&lt;p&gt;&lt;/p&gt;\n&lt;p&gt;In both &lt;code&gt;console.log&lt;/code&gt; you will find the value to be &lt;code&gt;undefined&lt;/code&gt;.&lt;/p&gt;\n    ","\n&lt;p&gt;In JavaScript, the type of the value &lt;em&gt;solely&lt;/em&gt; controls whether that value will be assigned by &lt;strong&gt;value-copy&lt;/strong&gt; or by &lt;strong&gt;reference-copy&lt;/strong&gt;. &lt;/p&gt;\n\n&lt;p&gt;&lt;em&gt;Primitive values are always assigned/passed by value-copy&lt;/em&gt;: &lt;/p&gt;\n\n&lt;ul&gt;\n&lt;li&gt;&lt;code&gt;null&lt;/code&gt;&lt;/li&gt;\n&lt;li&gt;&lt;code&gt;undefined&lt;/code&gt;&lt;/li&gt;\n&lt;li&gt;string&lt;/li&gt;\n&lt;li&gt;number&lt;/li&gt;\n&lt;li&gt;boolean&lt;/li&gt;\n&lt;li&gt;symbol in &lt;code&gt;ES6&lt;/code&gt;&lt;/li&gt;\n&lt;/ul&gt;\n\n&lt;p&gt;&lt;em&gt;Compound values are always assigned/passed by reference-copy&lt;/em&gt;&lt;/p&gt;\n\n&lt;ul&gt;\n&lt;li&gt;objects &lt;/li&gt;\n&lt;li&gt;arrays&lt;/li&gt;\n&lt;li&gt;function&lt;/li&gt;\n&lt;/ul&gt;\n\n&lt;p&gt;For example&lt;/p&gt;\n\n&lt;pre class=&quot;lang-js s-code-block&quot;&gt;&lt;code class=&quot;hljs language-javascript&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; a = &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;;\n&lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; b = a; &lt;span class=&quot;hljs-comment&quot;&gt;// `b` is always a copy of the value in `a`&lt;/span&gt;\nb++;\na; &lt;span class=&quot;hljs-comment&quot;&gt;// 2&lt;/span&gt;\nb; &lt;span class=&quot;hljs-comment&quot;&gt;// 3&lt;/span&gt;\n\n&lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; c = [&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;];\n&lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; d = c; &lt;span class=&quot;hljs-comment&quot;&gt;// `d` is a reference to the shared `[1,2,3]` value&lt;/span&gt;\nd.&lt;span class=&quot;hljs-title function_&quot;&gt;push&lt;/span&gt;( &lt;span class=&quot;hljs-number&quot;&gt;4&lt;/span&gt; );\nc; &lt;span class=&quot;hljs-comment&quot;&gt;// [1,2,3,4]&lt;/span&gt;\nd; &lt;span class=&quot;hljs-comment&quot;&gt;// [1,2,3,4]&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;In the above snippet, because &lt;code&gt;2&lt;/code&gt; is a scalar primitive, &lt;code&gt;a&lt;/code&gt; holds one initial copy of that value, and &lt;code&gt;b&lt;/code&gt; is assigned another copy of the value. When changing &lt;code&gt;b&lt;/code&gt;, you are in no way changing the value in &lt;code&gt;a&lt;/code&gt;.&lt;/p&gt;\n\n&lt;p&gt;But both &lt;code&gt;c&lt;/code&gt; and &lt;code&gt;d&lt;/code&gt; are separate references to the same shared value &lt;code&gt;[1,2,3]&lt;/code&gt;, which is a compound value. It&apos;s important to note that neither &lt;code&gt;c&lt;/code&gt; nor &lt;code&gt;d&lt;/code&gt; more &quot;owns&quot; the &lt;code&gt;[1,2,3]&lt;/code&gt; value -- both are just equal peer references to the value. So, when using either reference to modify (&lt;code&gt;.push(4)&lt;/code&gt;) the actual shared &lt;code&gt;array&lt;/code&gt; value itself, it&apos;s affecting just the one shared value, and both references will reference the newly modified value &lt;code&gt;[1,2,3,4]&lt;/code&gt;.&lt;/p&gt;\n\n&lt;pre class=&quot;lang-js s-code-block&quot;&gt;&lt;code class=&quot;hljs language-javascript&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; a = [&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;];\n&lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; b = a;\na; &lt;span class=&quot;hljs-comment&quot;&gt;// [1,2,3]&lt;/span&gt;\nb; &lt;span class=&quot;hljs-comment&quot;&gt;// [1,2,3]&lt;/span&gt;\n\n&lt;span class=&quot;hljs-comment&quot;&gt;// later&lt;/span&gt;\nb = [&lt;span class=&quot;hljs-number&quot;&gt;4&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;6&lt;/span&gt;];\na; &lt;span class=&quot;hljs-comment&quot;&gt;// [1,2,3]&lt;/span&gt;\nb; &lt;span class=&quot;hljs-comment&quot;&gt;// [4,5,6]&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;When we make the assignment &lt;code&gt;b = [4,5,6]&lt;/code&gt;, we are doing absolutely nothing to affect where &lt;code&gt;a&lt;/code&gt; is still referencing (&lt;code&gt;[1,2,3]&lt;/code&gt;). To do that, &lt;code&gt;b&lt;/code&gt; would have to be a pointer to &lt;code&gt;a&lt;/code&gt; rather than a reference to the &lt;code&gt;array&lt;/code&gt; -- but no such capability exists in JS!&lt;/p&gt;\n\n&lt;pre class=&quot;lang-js s-code-block&quot;&gt;&lt;code class=&quot;hljs language-javascript&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;foo&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;x&lt;/span&gt;) {\n    x.&lt;span class=&quot;hljs-title function_&quot;&gt;push&lt;/span&gt;( &lt;span class=&quot;hljs-number&quot;&gt;4&lt;/span&gt; );\n    x; &lt;span class=&quot;hljs-comment&quot;&gt;// [1,2,3,4]&lt;/span&gt;\n\n    &lt;span class=&quot;hljs-comment&quot;&gt;// later&lt;/span&gt;\n    x = [&lt;span class=&quot;hljs-number&quot;&gt;4&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;6&lt;/span&gt;];\n    x.&lt;span class=&quot;hljs-title function_&quot;&gt;push&lt;/span&gt;( &lt;span class=&quot;hljs-number&quot;&gt;7&lt;/span&gt; );\n    x; &lt;span class=&quot;hljs-comment&quot;&gt;// [4,5,6,7]&lt;/span&gt;\n}\n\n&lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; a = [&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;];\n\n&lt;span class=&quot;hljs-title function_&quot;&gt;foo&lt;/span&gt;( a );\n\na; &lt;span class=&quot;hljs-comment&quot;&gt;// [1,2,3,4]  not  [4,5,6,7]&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;When we pass in the argument &lt;code&gt;a&lt;/code&gt;, it assigns a copy of the &lt;code&gt;a&lt;/code&gt; reference to &lt;code&gt;x&lt;/code&gt;. &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;a&lt;/code&gt; are separate references pointing at the same &lt;code&gt;[1,2,3]&lt;/code&gt; value. Now, inside the function, we can use that reference to mutate the value itself (&lt;code&gt;push(4)&lt;/code&gt;). But when we make the assignment &lt;code&gt;x = [4,5,6]&lt;/code&gt;, this is in no way affecting where the initial reference &lt;code&gt;a&lt;/code&gt; is pointing -- still points at the (now modified) &lt;code&gt;[1,2,3,4]&lt;/code&gt; value.&lt;/p&gt;\n\n&lt;p&gt;To effectively pass a compound value (like an &lt;code&gt;array&lt;/code&gt;) by value-copy, you need to manually make a copy of it, so that the reference passed doesn&apos;t still point to the original. For example:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-js s-code-block&quot;&gt;&lt;code class=&quot;hljs language-javascript&quot;&gt;&lt;span class=&quot;hljs-title function_&quot;&gt;foo&lt;/span&gt;( a.&lt;span class=&quot;hljs-title function_&quot;&gt;slice&lt;/span&gt;() );\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Compound value (object, array, etc) that can be passed by reference-copy&lt;/p&gt;\n\n&lt;pre class=&quot;lang-js s-code-block&quot;&gt;&lt;code class=&quot;hljs language-javascript&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;foo&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;wrapper&lt;/span&gt;) {\n    wrapper.&lt;span class=&quot;hljs-property&quot;&gt;a&lt;/span&gt; = &lt;span class=&quot;hljs-number&quot;&gt;42&lt;/span&gt;;\n}\n\n&lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; obj = {\n    &lt;span class=&quot;hljs-attr&quot;&gt;a&lt;/span&gt;: &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;\n};\n\n&lt;span class=&quot;hljs-title function_&quot;&gt;foo&lt;/span&gt;( obj );\n\nobj.&lt;span class=&quot;hljs-property&quot;&gt;a&lt;/span&gt;; &lt;span class=&quot;hljs-comment&quot;&gt;// 42&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Here, &lt;code&gt;obj&lt;/code&gt; acts as a wrapper for the scalar primitive property &lt;code&gt;a&lt;/code&gt;. When passed to &lt;code&gt;foo(..)&lt;/code&gt;, a copy of the &lt;code&gt;obj&lt;/code&gt; reference is passed in and set to the &lt;code&gt;wrapper&lt;/code&gt;parameter. We now can use the &lt;code&gt;wrapper&lt;/code&gt; reference to access the shared object, and update its property. After the function finishes, &lt;code&gt;obj.a&lt;/code&gt; will see the updated value &lt;code&gt;42&lt;/code&gt;.&lt;/p&gt;\n\n&lt;p&gt;&lt;a href=&quot;https://github.com/getify/You-Dont-Know-JS/blob/master/types%20%26%20grammar/ch2.md&quot;&gt;Source&lt;/a&gt;&lt;/p&gt;\n    ","\n&lt;p&gt;well, it&apos;s about &apos;performance&apos; and &apos;speed&apos; and in the simple word &apos;memory management&apos; in a programming language.&lt;/p&gt;\n&lt;p&gt;in javascript we can put values in two layer: &lt;strong&gt;type1&lt;/strong&gt;-&lt;code&gt;objects&lt;/code&gt; and &lt;strong&gt;type2&lt;/strong&gt;-all other types of value such as &lt;code&gt;string&lt;/code&gt; &amp;amp; &lt;code&gt;boolean&lt;/code&gt; &amp;amp; etc&lt;/p&gt;\n&lt;p&gt;if you imagine memory as below squares which in every one of them just one type2-value can be saved:&lt;/p&gt;\n&lt;p&gt;&lt;a href=&quot;https://i.stack.imgur.com/wFWOsm.png&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;img src=&quot;https://i.stack.imgur.com/wFWOsm.png&quot; alt=&quot;enter image description here&quot;&gt;&lt;/a&gt;&lt;/p&gt;\n&lt;p&gt;every type2-value (green) is a &lt;strong&gt;single square&lt;/strong&gt; while a type1-value (blue) is a &lt;strong&gt;group of them&lt;/strong&gt;:&lt;/p&gt;\n&lt;p&gt;&lt;a href=&quot;https://i.stack.imgur.com/vwu2vm.png&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;img src=&quot;https://i.stack.imgur.com/vwu2vm.png&quot; alt=&quot;enter image description here&quot;&gt;&lt;/a&gt;&lt;/p&gt;\n&lt;p&gt;the point is that if you want to indicate a type2-value, the address is plain but if you want to do the same thing for type1-value that&apos;s not easy at all! :&lt;/p&gt;\n&lt;p&gt;&lt;a href=&quot;https://i.stack.imgur.com/ZISOHm.png&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;img src=&quot;https://i.stack.imgur.com/ZISOHm.png&quot; alt=&quot;enter image description here&quot;&gt;&lt;/a&gt;&lt;/p&gt;\n&lt;p&gt;and in a more complicated story:&lt;/p&gt;\n&lt;p&gt;&lt;a href=&quot;https://i.stack.imgur.com/GIEvCm.png&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;img src=&quot;https://i.stack.imgur.com/GIEvCm.png&quot; alt=&quot;enter image description here&quot;&gt;&lt;/a&gt;&lt;/p&gt;\n&lt;p&gt;so here &lt;strong&gt;references&lt;/strong&gt; can rescue us:\n&lt;br&gt;\n&lt;a href=&quot;https://i.stack.imgur.com/orhtHm.png&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;img src=&quot;https://i.stack.imgur.com/orhtHm.png&quot; alt=&quot;enter image description here&quot;&gt;&lt;/a&gt;&lt;/p&gt;\n&lt;p&gt;while the green arrow here is a typical variable, the purple one is an object variable, so &lt;strong&gt;because the green arrow(typical variable) has just one task&lt;/strong&gt; (and that is indicating a typical value) we don&apos;t need to separate it&apos;s value from it so we move the green arrow with the value of that wherever it goes and in all assignments, functions and so on ...&lt;/p&gt;\n&lt;p&gt;but we cant do the same thing with the purple arrow, we may want to move &apos;john&apos; cell here or many other things..., so the purple arrow will stick to its place and just typical arrows that were assigned to it will move ...&lt;/p&gt;\n&lt;p&gt;a very confusing situation is where you can&apos;t realize how your referenced variable changes, let&apos;s take a look at a very good example:&lt;/p&gt;\n&lt;pre class=&quot;lang-js s-code-block&quot;&gt;&lt;code class=&quot;hljs language-javascript&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;let&lt;/span&gt; arr = [&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;4&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt;]; &lt;span class=&quot;hljs-comment&quot;&gt;//arr is an object now and a purple arrow is indicating it&lt;/span&gt;\n&lt;span class=&quot;hljs-keyword&quot;&gt;let&lt;/span&gt; obj2 = arr; &lt;span class=&quot;hljs-comment&quot;&gt;// now, obj2 is another purple arrow that is indicating the value of arr obj&lt;/span&gt;\n&lt;span class=&quot;hljs-keyword&quot;&gt;let&lt;/span&gt; obj3 = [&lt;span class=&quot;hljs-string&quot;&gt;&apos;a&apos;&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&apos;b&apos;&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&apos;c&apos;&lt;/span&gt;];\nobj2.&lt;span class=&quot;hljs-title function_&quot;&gt;push&lt;/span&gt;(&lt;span class=&quot;hljs-number&quot;&gt;6&lt;/span&gt;); &lt;span class=&quot;hljs-comment&quot;&gt;// first pic below - making a new hand for the blue circle to point the 6&lt;/span&gt;\n&lt;span class=&quot;hljs-comment&quot;&gt;//obj2 = [1, 2, 3, 4, 5, 6]&lt;/span&gt;\n&lt;span class=&quot;hljs-comment&quot;&gt;//arr = [1, 2, 3, 4, 5, 6]&lt;/span&gt;\n&lt;span class=&quot;hljs-comment&quot;&gt;//we changed the blue circle object value (type1-value) and due to arr and obj2 are indicating that so both of them changed&lt;/span&gt;\nobj2 = obj3; &lt;span class=&quot;hljs-comment&quot;&gt;//next pic below - changing the direction of obj2 array from blue circle to orange circle so obj2 is no more [1,2,3,4,5,6] and it&apos;s no more about changing anything in it but we completely changed its direction and now obj2 is pointing to obj3&lt;/span&gt;\n&lt;span class=&quot;hljs-comment&quot;&gt;//obj2 = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;];&lt;/span&gt;\n&lt;span class=&quot;hljs-comment&quot;&gt;//obj3 = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;];&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;&lt;a href=&quot;https://i.stack.imgur.com/fELHnm.png&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;img src=&quot;https://i.stack.imgur.com/fELHnm.png&quot; alt=&quot;enter image description here&quot;&gt;&lt;/a&gt;\n&lt;a href=&quot;https://i.stack.imgur.com/y9kukm.png&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;img src=&quot;https://i.stack.imgur.com/y9kukm.png&quot; alt=&quot;enter image description here&quot;&gt;&lt;/a&gt;&lt;/p&gt;\n    ","\n&lt;p&gt;This is little more explanation for pass by value and pass by reference (JavaScript). In this concept, they are talking about passing the variable by reference and passing the variable by reference.&lt;/p&gt;\n\n&lt;p&gt;&lt;strong&gt;Pass by value (primitive type)&lt;/strong&gt;&lt;/p&gt;\n\n&lt;pre class=&quot;lang-js s-code-block&quot;&gt;&lt;code class=&quot;hljs language-javascript&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; a = &lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;;\n&lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; b = a;\n\n&lt;span class=&quot;hljs-variable language_&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;hljs-title function_&quot;&gt;log&lt;/span&gt;(a); &lt;span class=&quot;hljs-comment&quot;&gt;// a = 3&lt;/span&gt;\n&lt;span class=&quot;hljs-variable language_&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;hljs-title function_&quot;&gt;log&lt;/span&gt;(b); &lt;span class=&quot;hljs-comment&quot;&gt;// b = 3&lt;/span&gt;\n\na=&lt;span class=&quot;hljs-number&quot;&gt;4&lt;/span&gt;;\n&lt;span class=&quot;hljs-variable language_&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;hljs-title function_&quot;&gt;log&lt;/span&gt;(a); &lt;span class=&quot;hljs-comment&quot;&gt;// a = 4&lt;/span&gt;\n&lt;span class=&quot;hljs-variable language_&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;hljs-title function_&quot;&gt;log&lt;/span&gt;(b); &lt;span class=&quot;hljs-comment&quot;&gt;// b = 3&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;ul&gt;\n&lt;li&gt;applies to all primitive type in JavaScript (string, number, Boolean, undefined, and null).&lt;/li&gt;\n&lt;li&gt;a is allocated a memory (say 0x001) and b creates a copy of the value in memory (say 0x002).&lt;/li&gt;\n&lt;li&gt;So changing the value of a variable doesn&apos;t affect the other, as they both reside in two different locations.&lt;/li&gt;\n&lt;/ul&gt;\n\n&lt;hr&gt;\n\n&lt;p&gt;&lt;strong&gt;Pass by reference (objects)&lt;/strong&gt;&lt;/p&gt;\n\n&lt;pre class=&quot;lang-js s-code-block&quot;&gt;&lt;code class=&quot;hljs language-javascript&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; c = { &lt;span class=&quot;hljs-string&quot;&gt;&quot;name&quot;&lt;/span&gt; : &lt;span class=&quot;hljs-string&quot;&gt;&quot;john&quot;&lt;/span&gt; };\n&lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; d = c;\n\n&lt;span class=&quot;hljs-variable language_&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;hljs-title function_&quot;&gt;log&lt;/span&gt;(c); &lt;span class=&quot;hljs-comment&quot;&gt;// { &quot;name&quot; : &quot;john&quot; }&lt;/span&gt;\n&lt;span class=&quot;hljs-variable language_&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;hljs-title function_&quot;&gt;log&lt;/span&gt;(d); &lt;span class=&quot;hljs-comment&quot;&gt;// { &quot;name&quot; : &quot;john&quot; }&lt;/span&gt;\n\nc.&lt;span class=&quot;hljs-property&quot;&gt;name&lt;/span&gt; = &lt;span class=&quot;hljs-string&quot;&gt;&quot;doe&quot;&lt;/span&gt;;\n\n&lt;span class=&quot;hljs-variable language_&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;hljs-title function_&quot;&gt;log&lt;/span&gt;(c); &lt;span class=&quot;hljs-comment&quot;&gt;// { &quot;name&quot; : &quot;doe&quot; }&lt;/span&gt;\n&lt;span class=&quot;hljs-variable language_&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;hljs-title function_&quot;&gt;log&lt;/span&gt;(d); &lt;span class=&quot;hljs-comment&quot;&gt;// { &quot;name&quot; : &quot;doe&quot; }&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;ul&gt;\n&lt;li&gt;The JavaScript engine assigns the object to the variable &lt;code&gt;c&lt;/code&gt;, and it points to some memory, say (0x012).&lt;/li&gt;\n&lt;li&gt;When d=c, in this step &lt;code&gt;d&lt;/code&gt; points to the same location (0x012).&lt;/li&gt;\n&lt;li&gt;Changing the value of any changes value for both the variable.&lt;/li&gt;\n&lt;li&gt;Functions are objects&lt;/li&gt;\n&lt;/ul&gt;\n\n&lt;hr&gt;\n\n&lt;p&gt;&lt;strong&gt;Special case, pass by reference (objects)&lt;/strong&gt;&lt;/p&gt;\n\n&lt;pre class=&quot;lang-js s-code-block&quot;&gt;&lt;code class=&quot;hljs language-javascript&quot;&gt;c = {&lt;span class=&quot;hljs-string&quot;&gt;&quot;name&quot;&lt;/span&gt; : &lt;span class=&quot;hljs-string&quot;&gt;&quot;jane&quot;&lt;/span&gt;};\n&lt;span class=&quot;hljs-variable language_&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;hljs-title function_&quot;&gt;log&lt;/span&gt;(c); &lt;span class=&quot;hljs-comment&quot;&gt;// { &quot;name&quot; : &quot;jane&quot; }&lt;/span&gt;\n&lt;span class=&quot;hljs-variable language_&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;hljs-title function_&quot;&gt;log&lt;/span&gt;(d); &lt;span class=&quot;hljs-comment&quot;&gt;// { &quot;name&quot; : &quot;doe&quot; }&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;ul&gt;\n&lt;li&gt;The equal(=) operator sets up new memory space or address&lt;/li&gt;\n&lt;/ul&gt;\n    ","\n&lt;p&gt;Semantics!! Setting concrete definitions will necessarily make some answers and comments incompatible since they are not describing the same thing even when using the same words and phrases, but it is critical to get past the confusion (especially for new programmers).&lt;/p&gt;\n\n&lt;p&gt;First of all, there are multiple levels of abstraction that not everyone seems to grasp.  Newer programmers who have learned on 4th or 5th generation languages may have difficulty wrapping their mind around concepts familiar to assembly or C programmers not phased by pointers to pointers to pointers.  Pass-by-reference does not simply mean the ability to change a referenced object using a function parameter variable.&lt;/p&gt;\n\n&lt;p&gt;&lt;strong&gt;Variable&lt;/strong&gt;: Combined concept of a symbol which references a value at a particular location in memory.  This term is usually too loaded to be used alone in discussing details.&lt;/p&gt;\n\n&lt;p&gt;&lt;strong&gt;Symbol&lt;/strong&gt;:  Text string used to refer to variable (i.e. variable&apos;s name).&lt;/p&gt;\n\n&lt;p&gt;&lt;strong&gt;Value&lt;/strong&gt;:  Particular bits stored in memory and referenced using variable&apos;s symbol.&lt;/p&gt;\n\n&lt;p&gt;&lt;strong&gt;Memory location&lt;/strong&gt;:  Where a variable&apos;s value is stored.  (The location itself is represented by a number separate from the value stored at the location.)&lt;/p&gt;\n\n&lt;p&gt;&lt;strong&gt;Function parameter&lt;/strong&gt;:  Variable declared in a function definition, used for referencing variables passed to the function.&lt;/p&gt;\n\n&lt;p&gt;&lt;strong&gt;Function argument&lt;/strong&gt;: Variable outside the function which is passed to the function by the caller.&lt;/p&gt;\n\n&lt;p&gt;&lt;strong&gt;Object variable&lt;/strong&gt;:  Variable whose basic underlying value is not the &quot;object&quot; itself, rather its value is a pointer (memory location value) to another location in memory where the object&apos;s actual data is stored.  In most higher-generation languages, the &quot;pointer&quot; aspect is effectively hidden by automatic de-referencing in various contexts.&lt;/p&gt;\n\n&lt;p&gt;&lt;strong&gt;Primitive variable&lt;/strong&gt;: Variable whose value IS the actual value.  Even this concept can be complicated by auto-boxing and object-like contexts of various languages, but the general ideas is that the variable&apos;s value IS the actual value represented by the variable&apos;s symbol rather than a pointer to another memory location.&lt;/p&gt;\n\n&lt;p&gt;&lt;em&gt;Function arguments and parameters are not the same thing.  Also, a variable&apos;s value is not the variable&apos;s object (as already pointed out by various people, but apparently ignored).  These distinctions are critical to proper understanding.&lt;/em&gt;&lt;/p&gt;\n\n&lt;p&gt;&lt;strong&gt;Pass-by-value or Call-by-sharing (for objects)&lt;/strong&gt;:  The function argument&apos;s value is COPIED to another memory location which is referenced by the function&apos;s parameter symbol (regardless of whether it&apos;s on the stack or heap).  In other words, the function parameter received a copy of the passed argument&apos;s value... AND (critical) the argument&apos;s value IS NEVER UPDATED / ALTERED / CHANGED by the calling function.  Remember, an object variable&apos;s value is NOT the object itself, rather it is the pointer to the object, so passing an object variable by value copies the pointer to the function parameter variable.  The function parameter&apos;s value points to the exact same object in memory.  The object data itself can be altered directly via the function parameter, BUT the function argument&apos;s value IS NEVER UPDATED, so it will continue to point to the &lt;em&gt;same&lt;/em&gt; object throughout and even after the function call (even if its object&apos;s data was altered or if the function parameter is assigned a different object altogether).  It is incorrect to conclude that the function argument was passed by reference just because the referenced object is updatable via the function parameter variable.&lt;/p&gt;\n\n&lt;p&gt;&lt;strong&gt;Call / Pass-by-reference&lt;/strong&gt;:  The function argument&apos;s value can/will be updated directly by the corresponding function parameter.  If it helps, the function parameter becomes an effective &quot;alias&quot; for the argument--they effectively refer to the same value at the same memory location.  If a function argument is an object variable, the ability to change the object&apos;s data is no different than the pass-by-value case since the function parameter will still point to the same object as the argument.  But in the object variable case, if the function parameter is set to a completely different object, then the argument will likewise also point to the different object--this does not happen in the pass-by-value case.&lt;/p&gt;\n\n&lt;p&gt;JavaScript does not pass by reference.  If you read closely, you will realize that all contrary opinions misunderstand what is meant by pass-by-value and they falsely conclude that the ability to update an object&apos;s data via the function parameter is synonymous to &quot;pass-by-value&quot;.&lt;/p&gt;\n\n&lt;p&gt;&lt;strong&gt;Object clone/copy&lt;/strong&gt;: A new object is created and the original object&apos;s data is copied.  This can be a deep copy or shallow copy, but the point is that a new object is created.  Creating a copy of an object is a separate concept from pass-by-value.  Some languages distinguish between class object and structs (or the like), and may have different behavior for passing variables of the different types.  But JavaScript does not do anything like this automatically when passing object variables.  But the absence of automatic object cloning does not translate to pass-by-reference.&lt;/p&gt;\n    ","\n&lt;blockquote&gt;\n  &lt;p&gt;sharing what I know of references in JavaScript&lt;/p&gt;\n&lt;/blockquote&gt;\n\n&lt;p&gt;In JavaScript, when assigning an object to a variable, the value assigned to the variable is a reference to the object:&lt;/p&gt;\n\n&lt;p&gt;&lt;/p&gt;&lt;div class=&quot;snippet&quot; data-lang=&quot;js&quot; data-hide=&quot;false&quot; data-console=&quot;true&quot; data-babel=&quot;false&quot;&gt;\n&lt;div class=&quot;snippet-code&quot;&gt;\n&lt;pre class=&quot;snippet-code-js lang-js s-code-block&quot;&gt;&lt;code class=&quot;hljs language-javascript&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; a = {\n  &lt;span class=&quot;hljs-attr&quot;&gt;a&lt;/span&gt;: &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;,\n  &lt;span class=&quot;hljs-attr&quot;&gt;b&lt;/span&gt;: &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;,\n  &lt;span class=&quot;hljs-attr&quot;&gt;c&lt;/span&gt;: &lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;\n};\n&lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; b = a;\n\n&lt;span class=&quot;hljs-comment&quot;&gt;// b.c is referencing to a.c value&lt;/span&gt;\n&lt;span class=&quot;hljs-variable language_&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;hljs-title function_&quot;&gt;log&lt;/span&gt;(b.&lt;span class=&quot;hljs-property&quot;&gt;c&lt;/span&gt;) &lt;span class=&quot;hljs-comment&quot;&gt;// Output: 3&lt;/span&gt;\n&lt;span class=&quot;hljs-comment&quot;&gt;// Changing value of b.c&lt;/span&gt;\nb.&lt;span class=&quot;hljs-property&quot;&gt;c&lt;/span&gt; = &lt;span class=&quot;hljs-number&quot;&gt;4&lt;/span&gt;\n&lt;span class=&quot;hljs-comment&quot;&gt;// Also changes the value of a.c&lt;/span&gt;\n&lt;span class=&quot;hljs-variable language_&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;hljs-title function_&quot;&gt;log&lt;/span&gt;(a.&lt;span class=&quot;hljs-property&quot;&gt;c&lt;/span&gt;) &lt;span class=&quot;hljs-comment&quot;&gt;// Output: 4&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;\n&lt;div class=&quot;snippet-result&quot;&gt;&lt;div class=&quot;snippet-ctas&quot;&gt;&lt;button type=&quot;button&quot; class=&quot;s-btn s-btn__primary&quot;&gt;&lt;span class=&quot;icon-play-white _hover&quot;&gt;&lt;/span&gt;&lt;span&gt; Run code snippet&lt;/span&gt;&lt;/button&gt;&lt;input class=&quot;copySnippet s-btn s-btn__filled&quot; type=&quot;button&quot; value=&quot;Copy snippet to answer&quot; style=&quot;display: none;&quot;&gt;&lt;button type=&quot;button&quot; class=&quot;s-btn hideResults&quot; style=&quot;display: none;&quot;&gt;Hide results&lt;/button&gt;&lt;div class=&quot;popout-code&quot;&gt;&lt;a class=&quot;snippet-expand-link&quot;&gt;Expand snippet&lt;/a&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class=&quot;snippet-result-code&quot; style=&quot;display: none;&quot;&gt;&lt;iframe name=&quot;sif5&quot; sandbox=&quot;allow-forms allow-modals allow-scripts&quot; class=&quot;snippet-box-edit snippet-box-result&quot; frameborder=&quot;0&quot;&gt;&lt;/iframe&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;\n&lt;/div&gt;\n&lt;p&gt;&lt;/p&gt;\n    ","\n&lt;h2&gt;JavaScript passes primitive types by value and object types by reference&lt;/h2&gt;\n\n&lt;blockquote&gt;\n  &lt;p&gt;Now, people like to bicker endlessly about whether &quot;pass by reference&quot;\n  is the correct way to describe what Java et al. actually do. The point\n  is this:&lt;/p&gt;\n  \n  &lt;ol&gt;\n  &lt;li&gt;Passing an object does not copy the object.&lt;/li&gt;\n  &lt;li&gt;An object passed to a function can have its members modified by the function.&lt;/li&gt;\n  &lt;li&gt;A primitive value passed to a function cannot be modified by the function. A copy is made.&lt;/li&gt;\n  &lt;/ol&gt;\n  \n  &lt;p&gt;In my book that&apos;s called passing by reference.&lt;/p&gt;\n&lt;/blockquote&gt;\n\n&lt;p&gt; &lt;a href=&quot;https://www.quora.com/profile/Brian-Bi&quot; rel=&quot;nofollow noreferrer&quot;&gt;Brian Bi&lt;/a&gt; - &lt;a href=&quot;https://www.quora.com/Which-programming-languages-are-pass-by-reference#&quot; rel=&quot;nofollow noreferrer&quot;&gt;Which programming languages are pass by reference?&lt;/a&gt;&lt;/p&gt;\n\n&lt;hr&gt;\n\n&lt;h1&gt;Update&lt;/h1&gt;\n\n&lt;p&gt;Here is a rebuttal to this:&lt;/p&gt;\n\n&lt;p&gt;&lt;a href=&quot;https://stackoverflow.com/a/7744623/5535245&quot;&gt;There is no &quot;pass by reference&quot; available in JavaScript.&lt;/a&gt;&lt;/p&gt;\n    ","\n&lt;p&gt;&lt;em&gt;Observation: If there isn&apos;t any way for an observer to examine the underlying memory of the engine, there is no way to determine whether an immutable value gets copied or a reference gets passed.&lt;/em&gt;&lt;/p&gt;\n&lt;p&gt;JavaScript is more or less agnostic to the underlying memory model. There is no such thing as a &lt;em&gt;reference&lt;/em&gt;². JavaScript has &lt;em&gt;values&lt;/em&gt;. Two variables can hold the same &lt;em&gt;value&lt;/em&gt; (or more accurate: two &lt;em&gt;environment records&lt;/em&gt; can &lt;em&gt;bind&lt;/em&gt; the same value). The only type of values that can be mutated are objects through their abstract [[Get]] and [[Set]] operations.\nIf you forget about computers and memory, this is all you need to describe JavaScript&apos;s behaviour, and it allows you to understand the specification.&lt;/p&gt;\n&lt;pre class=&quot;lang-js s-code-block&quot;&gt;&lt;code class=&quot;hljs language-javascript&quot;&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;let&lt;/span&gt; a = { &lt;span class=&quot;hljs-attr&quot;&gt;prop&lt;/span&gt;: &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt; };\n &lt;span class=&quot;hljs-keyword&quot;&gt;let&lt;/span&gt; b = a; &lt;span class=&quot;hljs-comment&quot;&gt;// a and b hold the same value&lt;/span&gt;\n a.&lt;span class=&quot;hljs-property&quot;&gt;prop&lt;/span&gt; = &lt;span class=&quot;hljs-string&quot;&gt;&quot;test&quot;&lt;/span&gt;; &lt;span class=&quot;hljs-comment&quot;&gt;// The object gets mutated, can be observed through both a and b&lt;/span&gt;\n b = { &lt;span class=&quot;hljs-attr&quot;&gt;prop&lt;/span&gt;: &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt; }; &lt;span class=&quot;hljs-comment&quot;&gt;// b holds now a different value&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;Now you might ask yourself how two variables can hold the same value on a computer. You might then look into the source code of a JavaScript engine and you&apos;ll most likely find something which a programmer of the language the engine was written in would call a reference.&lt;/p&gt;\n&lt;p&gt;So in fact you can say that JavaScript is &quot;pass by value&quot;, whereas the value can be shared, and you can say that JavaScript is &quot;pass by reference&quot;, which might be a useful logical abstraction for programmers from low level languages, or you might call the behaviour &quot;call by sharing&quot;.&lt;/p&gt;\n&lt;p&gt;As there is no such thing as a reference in JavaScript, all of these are neither wrong nor on point. Therefore I don&apos;t think the answer is particularly useful to search for.&lt;/p&gt;\n&lt;p&gt;² The term &lt;em&gt;Reference&lt;/em&gt; in the specification is not a reference in the traditional sense. It is a container for an object and the name of a property, and it is an intermediate value (e.g., &lt;code&gt;a.b&lt;/code&gt; evaluates to &lt;code&gt;Reference { value = a, name = &quot;b&quot; }&lt;/code&gt;). The term &lt;em&gt;reference&lt;/em&gt; also sometimes appears in the specification in unrelated sections.&lt;/p&gt;\n    ","\n&lt;p&gt;Everything is passed by value.&lt;/p&gt;\n&lt;p&gt;Basic types are passed by value (i.e. a new copy of the actual variable value is passed to the function).&lt;/p&gt;\n&lt;p&gt;Complex types (objects) are passed as &quot;pointer to the object&quot;. So the actual stuff you are passing is a pointer which is passed by value (it&apos;s an address, a numerical value like any other). Obviously if you try to modify a property of the object inside the function, the modification will be reflected even outside of such function. That&apos;s because you are accessing the property via the pointer which points to the unique copy of the property.&lt;/p&gt;\n&lt;p&gt;The confusion here has arises over &quot;passing a pointer by value&quot; and &quot;passing an object by reference&quot;.&lt;/p&gt;\n    ","\n&lt;p&gt;My simple way to understand this...&lt;/p&gt;\n\n&lt;ul&gt;\n&lt;li&gt;&lt;p&gt;When calling a function, you are passing the content (reference or\nvalue) of the argument variables, not the the variables themselves.&lt;/p&gt;\n\n&lt;pre class=&quot;lang-js s-code-block&quot;&gt;&lt;code class=&quot;hljs language-javascript&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; var1 = &lt;span class=&quot;hljs-number&quot;&gt;13&lt;/span&gt;;\n&lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; var2 = { &lt;span class=&quot;hljs-attr&quot;&gt;prop&lt;/span&gt;: &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt; };\n\n&lt;span class=&quot;hljs-comment&quot;&gt;//13 and var2&apos;s content (reference) are being passed here&lt;/span&gt;\n&lt;span class=&quot;hljs-title function_&quot;&gt;foo&lt;/span&gt;(var1, var2); \n&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;\n&lt;li&gt;&lt;p&gt;Inside the function, parameter variables, &lt;code&gt;inVar1&lt;/code&gt; and &lt;code&gt;inVar2&lt;/code&gt;, receive the contents being passed.&lt;/p&gt;\n\n&lt;pre class=&quot;lang-js s-code-block&quot;&gt;&lt;code class=&quot;hljs language-javascript&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;foo&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;inVar1, inVar2&lt;/span&gt;){\n    &lt;span class=&quot;hljs-comment&quot;&gt;//changing contents of inVar1 and inVar2 won&apos;t affect variables outside&lt;/span&gt;\n    inVar1 = &lt;span class=&quot;hljs-number&quot;&gt;20&lt;/span&gt;;\n    inVar2 = { &lt;span class=&quot;hljs-attr&quot;&gt;prop&lt;/span&gt;: &lt;span class=&quot;hljs-number&quot;&gt;7&lt;/span&gt; };\n}\n&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;\n&lt;li&gt;&lt;p&gt;Since &lt;code&gt;inVar2&lt;/code&gt; received the reference of &lt;code&gt;{ prop: 2 }&lt;/code&gt;, you can change the value of the object&apos;s property.&lt;/p&gt;\n\n&lt;pre class=&quot;lang-js s-code-block&quot;&gt;&lt;code class=&quot;hljs language-javascript&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;foo&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;inVar1, inVar2&lt;/span&gt;){\n    inVar2.&lt;span class=&quot;hljs-property&quot;&gt;prop&lt;/span&gt; = &lt;span class=&quot;hljs-number&quot;&gt;7&lt;/span&gt;; \n}\n&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;\n&lt;/ul&gt;\n    ","\n&lt;p&gt;The MDN docs explain it clearly, without being too verbose:  &lt;/p&gt;\n\n&lt;blockquote&gt;\n  &lt;p&gt;The parameters of a function call are the function&apos;s &lt;em&gt;arguments&lt;/em&gt;.\n  Arguments are passed to functions &lt;em&gt;by value&lt;/em&gt;. If the function changes\n  the value of an argument, this change is not reflected globally or in\n  the calling function. However, object references are values, too, and\n  they are special: if the function changes the referred object&apos;s\n  properties, that change is visible outside the function, (...)&lt;/p&gt;\n&lt;/blockquote&gt;\n\n&lt;p&gt;Source: &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions#Description&quot; rel=&quot;nofollow noreferrer&quot;&gt;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions#Description&lt;/a&gt;&lt;/p&gt;\n    ","\n&lt;p&gt;Passing arguments to a function in JavaScript is analogous to passing\nparameters by pointer value in C:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-js s-code-block&quot;&gt;&lt;code class=&quot;hljs language-javascript&quot;&gt;&lt;span class=&quot;hljs-comment&quot;&gt;/*\nThe following C program demonstrates how arguments\nto JavaScript functions are passed in a way analogous\nto pass-by-pointer-value in C. The original JavaScript\ntest case by @Shog9 follows with the translation of\nthe code into C. This should make things clear to\nthose transitioning from C to JavaScript.\n\nfunction changeStuff(num, obj1, obj2)\n{\n    num = num * 10;\n    obj1.item = &quot;changed&quot;;\n    obj2 = {item: &quot;changed&quot;};\n}\n\nvar num = 10;\nvar obj1 = {item: &quot;unchanged&quot;};\nvar obj2 = {item: &quot;unchanged&quot;};\nchangeStuff(num, obj1, obj2);\nconsole.log(num);\nconsole.log(obj1.item);    \nconsole.log(obj2.item);\n\nThis produces the output:\n\n10\nchanged\nunchanged\n*/&lt;/span&gt;\n\n#include &amp;lt;stdio.&lt;span class=&quot;hljs-property&quot;&gt;h&lt;/span&gt;&amp;gt;\n#include &amp;lt;stdlib.&lt;span class=&quot;hljs-property&quot;&gt;h&lt;/span&gt;&amp;gt;\n\nstruct obj {\n    char *item;\n};\n\n&lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;changeStuff&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;int *num, struct obj *obj1, struct obj *obj2&lt;/span&gt;)\n{\n    &lt;span class=&quot;hljs-comment&quot;&gt;// make pointer point to a new memory location&lt;/span&gt;\n    &lt;span class=&quot;hljs-comment&quot;&gt;// holding the new integer value&lt;/span&gt;\n    int *old_num = num;\n    num = &lt;span class=&quot;hljs-title function_&quot;&gt;malloc&lt;/span&gt;(&lt;span class=&quot;hljs-title function_&quot;&gt;sizeof&lt;/span&gt;(int));\n    *num = *old_num * &lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;;\n    &lt;span class=&quot;hljs-comment&quot;&gt;// make property of structure pointed to by pointer&lt;/span&gt;\n    &lt;span class=&quot;hljs-comment&quot;&gt;// point to the new value&lt;/span&gt;\n    obj1-&amp;gt;item = &lt;span class=&quot;hljs-string&quot;&gt;&quot;changed&quot;&lt;/span&gt;;\n    &lt;span class=&quot;hljs-comment&quot;&gt;// make pointer point to a new memory location&lt;/span&gt;\n    &lt;span class=&quot;hljs-comment&quot;&gt;// holding the new structure value&lt;/span&gt;\n    obj2 = &lt;span class=&quot;hljs-title function_&quot;&gt;malloc&lt;/span&gt;(&lt;span class=&quot;hljs-title function_&quot;&gt;sizeof&lt;/span&gt;(struct obj));\n    obj2-&amp;gt;item = &lt;span class=&quot;hljs-string&quot;&gt;&quot;changed&quot;&lt;/span&gt;;\n    &lt;span class=&quot;hljs-title function_&quot;&gt;free&lt;/span&gt;(num); &lt;span class=&quot;hljs-comment&quot;&gt;// end of scope&lt;/span&gt;\n    &lt;span class=&quot;hljs-title function_&quot;&gt;free&lt;/span&gt;(obj2); &lt;span class=&quot;hljs-comment&quot;&gt;// end of scope&lt;/span&gt;\n}\n\nint num = &lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;;\nstruct obj obj1 = { &lt;span class=&quot;hljs-string&quot;&gt;&quot;unchanged&quot;&lt;/span&gt; };\nstruct obj obj2 = { &lt;span class=&quot;hljs-string&quot;&gt;&quot;unchanged&quot;&lt;/span&gt; };\n\nint &lt;span class=&quot;hljs-title function_&quot;&gt;main&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;&lt;/span&gt;)\n{\n    &lt;span class=&quot;hljs-comment&quot;&gt;// pass pointers by value: the pointers&lt;/span&gt;\n    &lt;span class=&quot;hljs-comment&quot;&gt;// will be copied into the argument list&lt;/span&gt;\n    &lt;span class=&quot;hljs-comment&quot;&gt;// of the called function and the copied&lt;/span&gt;\n    &lt;span class=&quot;hljs-comment&quot;&gt;// pointers will point to the same values&lt;/span&gt;\n    &lt;span class=&quot;hljs-comment&quot;&gt;// as the original pointers&lt;/span&gt;\n    &lt;span class=&quot;hljs-title function_&quot;&gt;changeStuff&lt;/span&gt;(&amp;amp;num, &amp;amp;obj1, &amp;amp;obj2);\n    &lt;span class=&quot;hljs-title function_&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;%d\\n&quot;&lt;/span&gt;, num);\n    &lt;span class=&quot;hljs-title function_&quot;&gt;puts&lt;/span&gt;(obj1.&lt;span class=&quot;hljs-property&quot;&gt;item&lt;/span&gt;);\n    &lt;span class=&quot;hljs-title function_&quot;&gt;puts&lt;/span&gt;(obj2.&lt;span class=&quot;hljs-property&quot;&gt;item&lt;/span&gt;);\n    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;;\n}\n&lt;/code&gt;&lt;/pre&gt;\n    ","\n&lt;p&gt;For programming language lawyers, I&apos;ve went through the following sections of ECMAScript 5.1 (which is easier to read than the latest edition), and go as far as &lt;a href=&quot;https://esdiscuss.org/topic/are-the-values-of-objects-the-references-to-them&quot; rel=&quot;nofollow noreferrer&quot;&gt;asking&lt;/a&gt; it on the ECMAScript mailing list.&lt;/p&gt;\n&lt;p&gt;&lt;b&gt;TL;DR&lt;/b&gt;: Everythings&apos;re passed by value, but properties of Objects are references, and the definition of Object is creepily lacking in the standard.&lt;/p&gt;\n&lt;h1&gt;Construction of Argument Lists&lt;/h1&gt;\n&lt;p&gt;Section 11.2.4 &quot;Argument Lists&quot; says the following on producing a argument list consisting of only 1 argument:&lt;/p&gt;\n&lt;blockquote&gt;\n&lt;p&gt;The production ArgumentList : AssignmentExpression is evaluated as follows:&lt;/p&gt;\n&lt;ol&gt;\n&lt;li&gt;Let ref be the result of evaluating AssignmentExpression.&lt;/li&gt;\n&lt;li&gt;Let arg be GetValue(ref).&lt;/li&gt;\n&lt;li&gt;Return a List whose sole item is arg.&lt;/li&gt;\n&lt;/ol&gt;\n&lt;/blockquote&gt;\n&lt;p&gt;The section also enumerate cases where argument list has 0 or &amp;gt;1 arguments.&lt;/p&gt;\n&lt;p&gt;Thus, everything&apos;s are passed by reference.&lt;/p&gt;\n&lt;h1&gt;Access of Object Properties&lt;/h1&gt;\n&lt;p&gt;Section 11.2.1 &quot;Property Accessors&quot;&lt;/p&gt;\n&lt;blockquote&gt;\n&lt;p&gt;The production MemberExpression : MemberExpression [ Expression ] is evaluated as follows:&lt;/p&gt;\n&lt;ol&gt;\n&lt;li&gt;Let baseReference be the result of evaluating MemberExpression.&lt;/li&gt;\n&lt;li&gt;Let baseValue be GetValue(baseReference).&lt;/li&gt;\n&lt;li&gt;Let propertyNameReference be the result of evaluating Expression.&lt;/li&gt;\n&lt;li&gt;Let propertyNameValue be GetValue(propertyNameReference).&lt;/li&gt;\n&lt;li&gt;Call CheckObjectCoercible(baseValue).&lt;/li&gt;\n&lt;li&gt;Let propertyNameString be ToString(propertyNameValue).&lt;/li&gt;\n&lt;li&gt;If the syntactic production that is being evaluated is contained in strict mode code, let strict be true, else let\nstrict be false.&lt;/li&gt;\n&lt;li&gt;&lt;b&gt;Return a value of type Reference&lt;/b&gt; whose base value is baseValue and whose referenced name is\npropertyNameString, and whose strict mode flag is strict.&lt;/li&gt;\n&lt;/ol&gt;\n&lt;/blockquote&gt;\n&lt;p&gt;Thus, properties of Objects are always available as reference.&lt;/p&gt;\n&lt;h1&gt;On Reference&lt;/h1&gt;\n&lt;p&gt;It is described in section 8.7 &quot;The Reference Specification Type&quot;, that references are not real types in the language - they&apos;re only used to describe the behavior of the delete, the typeof, and the assignment operators.&lt;/p&gt;\n&lt;h1&gt;Definition of &quot;Object&quot;&lt;/h1&gt;\n&lt;p&gt;It is defined in 5.1 edition that &quot;An Object is a collection of properties&quot;. Therefore, we can infer, that the value of the object is the collection, but as to what is the value of the collection is poorly defined in the spec, and requires a bit of &lt;a href=&quot;https://stackoverflow.com/questions/45388408/where-is-the-mutability-of-objects-defined-in-ecmascript/45407589#45407589&quot;&gt;effort&lt;/a&gt; to understand.&lt;/p&gt;\n    ","\n&lt;p&gt;The most succinct explanation I found was in the &lt;a href=&quot;https://github.com/airbnb/javascript#types&quot; rel=&quot;nofollow&quot;&gt;AirBNB style guide&lt;/a&gt;:&lt;/p&gt;\n\n&lt;ul&gt;\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;Primitives&lt;/strong&gt;: When you access a primitive type you work directly on its\nvalue&lt;/p&gt;\n\n&lt;ul&gt;\n&lt;li&gt;string&lt;/li&gt;\n&lt;li&gt;number&lt;/li&gt;\n&lt;li&gt;boolean&lt;/li&gt;\n&lt;li&gt;null&lt;/li&gt;\n&lt;li&gt;undefined&lt;/li&gt;\n&lt;/ul&gt;&lt;/li&gt;\n&lt;/ul&gt;\n\n&lt;p&gt;E.g.:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-js s-code-block&quot;&gt;&lt;code class=&quot;hljs language-javascript&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; foo = &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;,\n    bar = foo;\n\nbar = &lt;span class=&quot;hljs-number&quot;&gt;9&lt;/span&gt;;\n\n&lt;span class=&quot;hljs-variable language_&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;hljs-title function_&quot;&gt;log&lt;/span&gt;(foo, bar); &lt;span class=&quot;hljs-comment&quot;&gt;// =&amp;gt; 1, 9&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;ul&gt;\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;Complex&lt;/strong&gt;: When you access a complex type you work on a reference to its value&lt;/p&gt;\n\n&lt;ul&gt;\n&lt;li&gt;object&lt;/li&gt;\n&lt;li&gt;array&lt;/li&gt;\n&lt;li&gt;function&lt;/li&gt;\n&lt;/ul&gt;&lt;/li&gt;\n&lt;/ul&gt;\n\n&lt;p&gt;E.g.:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-js s-code-block&quot;&gt;&lt;code class=&quot;hljs language-javascript&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; foo = [&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;],\n    bar = foo;\n\nbar[&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;] = &lt;span class=&quot;hljs-number&quot;&gt;9&lt;/span&gt;;\n\n&lt;span class=&quot;hljs-variable language_&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;hljs-title function_&quot;&gt;log&lt;/span&gt;(foo[&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;], bar[&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;]); &lt;span class=&quot;hljs-comment&quot;&gt;// =&amp;gt; 9, 9&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;I.e. effectively primitive types are passed by value, and complex types are passed by reference.&lt;/p&gt;\n    ","\n&lt;p&gt;I&apos;ve read through these answers multiple times, but didn&apos;t REALLY get it until I learned about the technical definition of &lt;a href=&quot;https://en.wikipedia.org/wiki/Evaluation_strategy#Call_by_sharing&quot; rel=&quot;nofollow&quot;&gt;&quot;Call by sharing&quot;&lt;/a&gt; as termed by Barbara Liskov&lt;/p&gt;\n\n&lt;blockquote&gt;\n  &lt;p&gt;The semantics of call by sharing differ from call by reference in that assignments to function arguments within the function aren&apos;t visible to the caller (unlike by reference semantics)[citation needed], so e.g. if a variable was passed, it is not possible to simulate an assignment on that variable in the caller&apos;s scope. However, since the function has access to the same object as the caller (no copy is made), mutations to those objects, if the objects are mutable, within the function are visible to the caller, which may appear to differ from call by value semantics. Mutations of a mutable object within the function are visible to the caller because the object is not copied or cloned  it is shared.&lt;/p&gt;\n&lt;/blockquote&gt;\n\n&lt;p&gt;That is, parameter references are alterable if you go and access the parameter value itself. On the other hand, assignment to a parameter will disappear after evaluation, and is non-accessible to the function caller.&lt;/p&gt;\n    ","\n&lt;p&gt;In a low-level language, if you want to pass a variable by reference, you have to use a specific syntax in the creation of the function:&lt;/p&gt;\n&lt;pre class=&quot;lang-js s-code-block&quot;&gt;&lt;code class=&quot;hljs language-javascript&quot;&gt;int myAge = &lt;span class=&quot;hljs-number&quot;&gt;14&lt;/span&gt;;\n&lt;span class=&quot;hljs-title function_&quot;&gt;increaseAgeByRef&lt;/span&gt;(myAge);\n&lt;span class=&quot;hljs-keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;increaseAgeByRef&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;int &amp;amp;age&lt;/span&gt;) {\n  *age = *age + &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;;\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;The &lt;code&gt;&amp;amp;age&lt;/code&gt; is a reference to &lt;code&gt;myAge&lt;/code&gt;, but if you want the value you have to convert the reference, using &lt;code&gt;*age&lt;/code&gt;.&lt;/p&gt;\n&lt;p&gt;JavaScript is a high level language that does this conversion for you.&lt;/p&gt;\n&lt;p&gt;So, although objects are passed by reference, the language converts the reference parameter to the value. You don&apos;t need to use &lt;code&gt;&amp;amp;&lt;/code&gt;, on the function definition, to pass it by reference, neither &lt;code&gt;*&lt;/code&gt;, on the function body, to convert the reference to the value, JavaScript does it for you.&lt;/p&gt;\n&lt;p&gt;That&apos;s why when you try to change an object inside a function, by replacing it&apos;s value (i.e. &lt;code&gt;age = {value:5}&lt;/code&gt;), the change doesn&apos;t persist, but if you change it&apos;s properties (i.e. &lt;code&gt;age.value = 5&lt;/code&gt;), it does.&lt;/p&gt;\n&lt;p&gt;&lt;a href=&quot;https://blog.penjee.com/passing-by-value-vs-by-reference-java-graphical/&quot; rel=&quot;nofollow noreferrer&quot;&gt;Learn more&lt;/a&gt;&lt;/p&gt;\n    ","\n&lt;p&gt;If you want (normal) function parameter behavior like in other languages (passing copy of a value)\nthen just clone the object before passing into a function:&lt;/p&gt;\n&lt;pre class=&quot;lang-js s-code-block&quot;&gt;&lt;code class=&quot;hljs language-javascript&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;run&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;&lt;/span&gt;)\n{\n    &lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; test = [];\n    test.&lt;span class=&quot;hljs-title function_&quot;&gt;push&lt;/span&gt;(&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;);\n\n    &lt;span class=&quot;hljs-variable language_&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;hljs-title function_&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&apos;before: &apos;&lt;/span&gt;+test); &lt;span class=&quot;hljs-comment&quot;&gt;// 1&lt;/span&gt;\n\n    &lt;span class=&quot;hljs-title function_&quot;&gt;changeVariable&lt;/span&gt;(_.&lt;span class=&quot;hljs-title function_&quot;&gt;clone&lt;/span&gt;(test)); &lt;span class=&quot;hljs-comment&quot;&gt;// (Note: I am using lodash _.clone() function)&lt;/span&gt;\n \n    &lt;span class=&quot;hljs-variable language_&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;hljs-title function_&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&apos;after: &apos;&lt;/span&gt;+test); &lt;span class=&quot;hljs-comment&quot;&gt;// 1 &lt;/span&gt;\n}\n\n\n&lt;span class=&quot;hljs-keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;changeVariable&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;test2&lt;/span&gt;) {\n  &lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; test1 = test2;\n  test1.&lt;span class=&quot;hljs-title function_&quot;&gt;push&lt;/span&gt;(&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;); \n  &lt;span class=&quot;hljs-variable language_&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;hljs-title function_&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&apos;inside func:&apos;&lt;/span&gt;, test1);  &lt;span class=&quot;hljs-comment&quot;&gt;// inside func: [1,2]&lt;/span&gt;\n}   \n\n\n&lt;span class=&quot;hljs-title function_&quot;&gt;run&lt;/span&gt;();    \n&lt;/code&gt;&lt;/pre&gt;\n    ","\n&lt;p&gt;I have found the &lt;a href=&quot;http://documentcloud.github.com/underscore/#extend&quot; rel=&quot;nofollow&quot;&gt;extend method&lt;/a&gt; of the &lt;a href=&quot;http://documentcloud.github.com/underscore&quot; rel=&quot;nofollow&quot;&gt;Underscore.js library&lt;/a&gt; very useful when I want to pass in an object as a parameter which may either be modified or replaced entirely.&lt;/p&gt;\n\n&lt;pre class=&quot;lang-js s-code-block&quot;&gt;&lt;code class=&quot;hljs language-javascript&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;replaceOrModify&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;aObj&lt;/span&gt;) {\n  &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (modify) {\n\n    aObj.&lt;span class=&quot;hljs-title function_&quot;&gt;setNewValue&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&apos;foo&apos;&lt;/span&gt;);\n\n  } &lt;span class=&quot;hljs-keyword&quot;&gt;else&lt;/span&gt; {\n\n   &lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; newObj = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;MyObject&lt;/span&gt;();\n   &lt;span class=&quot;hljs-comment&quot;&gt;// _.extend(destination, *sources) &lt;/span&gt;\n   _.&lt;span class=&quot;hljs-title function_&quot;&gt;extend&lt;/span&gt;(newObj, aObj);\n  }\n}\n&lt;/code&gt;&lt;/pre&gt;\n    ","\n&lt;p&gt;I would say it is pass-by-copy -&lt;/p&gt;\n\n&lt;p&gt;Consider arguments and variable objects are objects created during the execution context created in the beginning of function invocation - and your actual value/reference passed into the function just get stored in this arguments + variable objects.&lt;/p&gt;\n\n&lt;p&gt;Simply speaking, for primitive types, the values get copied in the beginning of function call, for object type, the reference get copied.&lt;/p&gt;\n    ","\n&lt;ol&gt;\n&lt;li&gt;primitive type variable like string,number are always pass as  pass\nby value.&lt;/li&gt;\n&lt;li&gt;&lt;p&gt;Array and Object is passed as  pass by reference or  pass by value based on these two condition.&lt;/p&gt;\n\n&lt;ul&gt;\n&lt;li&gt;&lt;p&gt;if you are changing value of that Object or array with new Object or Array then it is pass by Value.&lt;/p&gt;\n\n&lt;p&gt;&lt;code&gt;object1 = {item: &quot;car&quot;};\n  array1=[1,2,3];&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;\n&lt;/ul&gt;\n\n&lt;p&gt;here you are assigning new object or array to old one.you are not changing the value of property \nof old object.so it is pass by value.&lt;/p&gt;\n\n&lt;ul&gt;\n&lt;li&gt;&lt;p&gt;if you are changing a property value of an object or array then it is pass by Reference.&lt;/p&gt;\n\n&lt;p&gt;&lt;code&gt;object1.key1= &quot;car&quot;;\n  array1[0]=9;&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;\n&lt;/ul&gt;\n\n&lt;p&gt;here you are changing a property value of old object.you are not assigning new object or array to old one.so it is pass by reference.&lt;/p&gt;&lt;/li&gt;\n&lt;/ol&gt;\n\n&lt;p&gt;&lt;strong&gt;Code&lt;/strong&gt;&lt;/p&gt;\n\n&lt;pre class=&quot;lang-js s-code-block&quot;&gt;&lt;code class=&quot;hljs language-javascript&quot;&gt;    &lt;span class=&quot;hljs-keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;passVar&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;object1, object2, number1&lt;/span&gt;) {\n\n        object1.&lt;span class=&quot;hljs-property&quot;&gt;key1&lt;/span&gt;= &lt;span class=&quot;hljs-string&quot;&gt;&quot;laptop&quot;&lt;/span&gt;;\n        object2 = {\n            &lt;span class=&quot;hljs-attr&quot;&gt;key2&lt;/span&gt;: &lt;span class=&quot;hljs-string&quot;&gt;&quot;computer&quot;&lt;/span&gt;\n        };\n        number1 = number1 + &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;;\n    }\n\n    &lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; object1 = {\n        &lt;span class=&quot;hljs-attr&quot;&gt;key1&lt;/span&gt;: &lt;span class=&quot;hljs-string&quot;&gt;&quot;car&quot;&lt;/span&gt;\n    };\n    &lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; object2 = {\n        &lt;span class=&quot;hljs-attr&quot;&gt;key2&lt;/span&gt;: &lt;span class=&quot;hljs-string&quot;&gt;&quot;bike&quot;&lt;/span&gt;\n    };\n    &lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; number1 = &lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;;\n\n    &lt;span class=&quot;hljs-title function_&quot;&gt;passVar&lt;/span&gt;(object1, object2, number1);\n    &lt;span class=&quot;hljs-variable language_&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;hljs-title function_&quot;&gt;log&lt;/span&gt;(object1.&lt;span class=&quot;hljs-property&quot;&gt;key1&lt;/span&gt;);\n    &lt;span class=&quot;hljs-variable language_&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;hljs-title function_&quot;&gt;log&lt;/span&gt;(object2.&lt;span class=&quot;hljs-property&quot;&gt;key2&lt;/span&gt;);\n    &lt;span class=&quot;hljs-variable language_&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;hljs-title function_&quot;&gt;log&lt;/span&gt;(number1);\n\n&lt;span class=&quot;hljs-title class_&quot;&gt;Output&lt;/span&gt;: -\n    laptop\n    bike\n    &lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n    ","\n&lt;p&gt;An easy way to determine whether something is &quot;pass by reference&quot; is whether you can write a &quot;swap&quot; function. For example, in C, you can do:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-js s-code-block&quot;&gt;&lt;code class=&quot;hljs language-javascript&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;swap&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;int *i, int *j&lt;/span&gt;)\n{\n    int t;\n    t = *i;\n    *i = *j;\n    *j = t;\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;If you can&apos;t do the equivalent of that in JavaScript, it is not &quot;pass by reference&quot;.&lt;/p&gt;\n    ","\n&lt;ol&gt;\n&lt;li&gt;Primitives (number, Boolean, etc.) are passed by value.\n\n&lt;ul&gt;\n&lt;li&gt;Strings are immutable, so it doesn&apos;t really matter for them.&lt;/li&gt;\n&lt;/ul&gt;&lt;/li&gt;\n&lt;li&gt;Objects are passed by reference (the reference is passed by value).&lt;/li&gt;\n&lt;/ol&gt;\n    "],"id":119,"title":"Is JavaScript a pass-by-reference or pass-by-value language?","content":"\n                \n&lt;p&gt;The primitive types (number, string, etc.) are passed by value, but objects are unknown, because they can be both passed-by-value (in case we consider that a variable holding an object is in fact a reference to the object) and passed-by-reference (when we consider that the variable to the object holds the object itself).&lt;/p&gt;\n\n&lt;p&gt;Although it doesn&apos;t really matter at the end, I want to know what is the correct way to present the arguments passing conventions. Is there an excerpt from JavaScript specification, which defines what should be the semantics regarding this?&lt;/p&gt;\n    ","slug":"is-javascript-a-pass-by-reference-or-pass-by-value-language-1657384675679","postType":"QUESTION","createdAt":"2022-07-09T16:37:55.000Z","updatedAt":"2022-07-09T16:37:55.000Z","tags":[],"relatedQuestions":[]},"randomQuestions":[{"title":"What is the difference between public, protected, package-private and private in Java?","slug":"what-is-the-difference-between-public-protected-package-private-and-private-in-java-1657387376262"},{"title":"How to sum a variable by group","slug":"how-to-sum-a-variable-by-group-1657384838148"},{"title":"How can I iterate through two lists in parallel?","slug":"how-can-i-iterate-through-two-lists-in-parallel-1657387278930"},{"title":"How to lazy load images in ListView in Android","slug":"how-to-lazy-load-images-in-listview-in-android-1657387332835"},{"title":"My attempt at value initialization is interpreted as a function declaration, and why doesn't A a(()); solve it?","slug":"my-attempt-at-value-initialization-is-interpreted-as-a-function-declaration-and-why-doesn't-a-a(())-solve-it-1657388474057"},{"title":"Get the data received in a Flask request","slug":"get-the-data-received-in-a-flask-request-1657387804432"},{"title":"Why should I not #include <bits/stdc++.h>?","slug":"why-should-i-not-include-lessbitsstdc++.hgreater-1657384470484"},{"title":"PHP parse/syntax errors; and how to solve them","slug":"php-parsesyntax-errors-and-how-to-solve-them-1657384264713"},{"title":"event.preventDefault() vs. return false","slug":"event.preventdefault()-vs.-return-false-1657387458377"},{"title":"Iterating over dictionaries using 'for' loops","slug":"iterating-over-dictionaries-using-'for'-loops-1657388334481"},{"title":"What do querySelectorAll and getElementsBy* methods return?","slug":"what-do-queryselectorall-and-getelementsby*-methods-return-1657384425935"},{"title":"How do I use extern to share variables between source files?","slug":"how-do-i-use-extern-to-share-variables-between-source-files-1657387453605"},{"title":"How to append text to an existing file in Java?","slug":"how-to-append-text-to-an-existing-file-in-java-1657388492377"},{"title":"How to convert a factor to integer\\numeric without loss of information?","slug":"how-to-convert-a-factor-to-integernumeric-without-loss-of-information-1657387880273"},{"title":"What are the rules about using an underscore in a C++ identifier?","slug":"what-are-the-rules-about-using-an-underscore-in-a-c++-identifier-1657384557197"},{"title":"Align inline-block DIVs to top of container element","slug":"align-inline-block-divs-to-top-of-container-element-1657387489610"},{"title":"Why is iostream::eof inside a loop condition (i.e. `while (!stream.eof())`) considered wrong?","slug":"why-is-iostream::eof-inside-a-loop-condition-(i.e.-while-(!stream.eof()))-considered-wrong-1657384355427"},{"title":"How can I sort arrays and data in PHP?","slug":"how-can-i-sort-arrays-and-data-in-php-1657384726665"},{"title":"How to format numbers as currency strings","slug":"how-to-format-numbers-as-currency-strings-1657388399166"},{"title":"Creating multiline strings in JavaScript","slug":"creating-multiline-strings-in-javascript-1657388025414"}]},"__N_SSG":true}