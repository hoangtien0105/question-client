<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><meta name="twitter:card" content="summary_large_image"/><meta name="twitter:site" content="@solutionschecker.com"/><meta name="twitter:creator" content="@solutionschecker.com"/><meta property="og:url" content="https://solutionschecker.com"/><meta property="og:type" content="website"/><meta property="og:image" content="https://solutionschecker.com/solutions-checker-banner.png"/><meta property="og:image:alt" content="Find the solution to any question. We focus on finding the fastest possible solution for users. Main topics like coding, learning. - solutionschecker.com"/><link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png"/><link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png"/><link rel="manifest" href="/site.webmanifest"/><script type="application/ld+json">{"@context":"https://schema.org","@type":"Organization","logo":"/logo.svg","url":"https://solutionschecker.com"}</script><link name="keywords" content="composition,aggregation,solutions checker, solution checker, how to, solution for, check for solution, resolve question, what is, what solution for, find solution"/><script type="application/ld+json">{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"item":{"@id":"https://solutionschecker.com","name":"Home"}},{"@type":"ListItem","position":2,"item":{"@id":"https://solutionschecker.com/questions","name":"Questions"}},{"@type":"ListItem","position":3,"item":{"@id":"https://solutionschecker.com/questions/prefer-composition-over-inheritance-1657387399409","name":"Questions"}}]}</script><title>Prefer composition over inheritance? | Solution Checker</title><meta name="robots" content="index,follow"/><meta name="description" content="Why prefer composition over inheritance?  What trade-offs are there for each approach?  When should you choose inheritance over composition?
    "/><meta property="og:title" content="Prefer composition over inheritance? | Solution Checker"/><meta property="og:description" content="Why prefer composition over inheritance?  What trade-offs are there for each approach?  When should you choose inheritance over composition?
    "/><script type="application/ld+json">{"@context":"https://schema.org","@type":"QAPage","mainEntity":{"name":"Prefer composition over inheritance?","text":"Why prefer composition over inheritance?  What trade-offs are there for each approach?  When should you choose inheritance over composition?\n    ","answerCount":30,"upVoteCount":500,"suggestedAnswer":[{"text":"Prefer composition over inheritance as it is more malleable / easy to modify later, but do not use a compose-always approach. With composition, it&apos;s easy to change behavior on the fly with Dependency Injection / Setters. Inheritance is more rigid as most languages do not allow you to derive from more than one type. So the goose is more or less cooked once you derive from TypeA.\n\nMy acid test for the above is:  \n\n\nDoes TypeB want to expose the complete interface (all public methods no less) of TypeA such that TypeB can be used where TypeA is expected? Indicates Inheritance. \n\n\ne.g. A Cessna biplane will expose the complete interface of an airplane, if not more. So that makes it fit to derive from Airplane. \n\nDoes TypeB want only some/part of the behavior exposed by TypeA? Indicates need for Composition.   \n\n\ne.g. A Bird may need only the fly behavior of an Airplane. In this case, it makes sense to extract it out as an interface / class / both and make it a member of both classes.\n\n\n\nUpdate: Just came back to my answer and it seems now that it is incomplete without a specific mention of Barbara Liskov&apos;s Liskov Substitution Principle as a test for &apos;Should I be inheriting from this type?&apos;\n    ","url":"/questions/[slug]#solution1","@type":"Answer","upvoteCount":0},{"text":"Think of containment as a has a relationship. A car &quot;has an&quot; engine, a person &quot;has a&quot; name, etc.\nThink of inheritance as an is a relationship. A car &quot;is a&quot; vehicle, a person &quot;is a&quot; mammal, etc.\nI take no credit for this approach. I took it straight from the Second Edition of Code Complete by Steve McConnell, Section 6.3.\n    ","url":"/questions/[slug]#solution2","@type":"Answer","upvoteCount":0},{"text":"If you understand the difference, it&apos;s easier to explain.\n\nProcedural Code\n\nAn example of this is PHP without the use of classes (particularly before PHP5). All logic is encoded in a set of functions. You may include other files containing helper functions and so on and conduct your business logic by passing data around in functions. This can be very hard to manage as the application grows. PHP5 tries to remedy this by offering more object oriented design.\n\nInheritance\n\nThis encourages the use of classes. Inheritance is one of the three tenets of OO design (inheritance, polymorphism, encapsulation).\n\nclass Person {\n   String Title;\n   String Name;\n   Int Age\n}\n\nclass Employee : Person {\n   Int Salary;\n   String Title;\n}\n\n\nThis is inheritance at work. The Employee &quot;is a&quot; Person or inherits from Person. All inheritance relationships are &quot;is-a&quot; relationships. Employee also shadows the Title property from Person, meaning Employee.Title will return the Title for the Employee not the Person.\n\nComposition\n\nComposition is favoured over inheritance. To put it very simply you would have:\n\nclass Person {\n   String Title;\n   String Name;\n   Int Age;\n\n   public Person(String title, String name, String age) {\n      this.Title = title;\n      this.Name = name;\n      this.Age = age;\n   }\n\n}\n\nclass Employee {\n   Int Salary;\n   private Person person;\n\n   public Employee(Person p, Int salary) {\n       this.person = p;\n       this.Salary = salary;\n   }\n}\n\nPerson johnny = new Person (&quot;Mr.&quot;, &quot;John&quot;, 25);\nEmployee john = new Employee (johnny, 50000);\n\n\nComposition is typically &quot;has a&quot; or &quot;uses a&quot; relationship. Here the Employee class has a Person. It does not inherit from Person but instead gets the Person object passed to it, which is why it &quot;has a&quot; Person.\n\nComposition over Inheritance\n\nNow say you want to create a Manager type so you end up with:\n\nclass Manager : Person, Employee {\n   ...\n}\n\n\nThis example will work fine, however, what if Person and Employee both declared Title? Should Manager.Title return &quot;Manager of Operations&quot; or &quot;Mr.&quot;? Under composition this ambiguity is better handled:\n\nClass Manager {\n   public string Title;\n   public Manager(Person p, Employee e)\n   {\n      this.Title = e.Title;\n   }\n}\n\n\nThe Manager object is composed as an Employee and a Person. The Title behaviour is taken from employee. This explicit composition removes ambiguity among other things and you&apos;ll encounter fewer bugs.\n    ","url":"/questions/[slug]#solution3","@type":"Answer","upvoteCount":0},{"text":"With all the undeniable benefits provided by inheritance, here&apos;s some of its disadvantages.\n\nDisadvantages of Inheritance:\n\n\nYou can&apos;t change the implementation inherited from super classes at runtime (obviously because inheritance is defined at compile time).\nInheritance exposes a subclass to details of its parent class implementation, that&apos;s why it&apos;s often said that inheritance breaks encapsulation (in a sense that you really need to focus on interfaces only not implementation, so reusing by sub classing is not always preferred).\nThe tight coupling provided by inheritance makes the implementation of a subclass very bound up with the implementation of a super class that any change in the parent implementation will force the sub class to change.\nExcessive reusing by sub-classing can make the inheritance stack very deep and very confusing too.\n\n\nOn the other hand Object composition is defined at runtime through objects acquiring references to other objects. In such a case these objects will never be able to reach each-other&apos;s protected data (no encapsulation break) and will be forced to respect each other&apos;s interface. And in this case also, implementation dependencies will be a lot less than in case of inheritance.\n    ","url":"/questions/[slug]#solution4","@type":"Answer","upvoteCount":0},{"text":"Another, very pragmatic reason, to prefer composition over inheritance has to do with your domain model, and mapping it to a relational database. It&apos;s really hard to map inheritance to the SQL model (you end up with all sorts of hacky workarounds, like creating columns that aren&apos;t always used, using views, etc). Some ORMLs try to deal with this, but it always gets complicated quickly. Composition can be easily modeled through a foreign-key relationship between two tables, but inheritance is much harder.\n    ","url":"/questions/[slug]#solution5","@type":"Answer","upvoteCount":0},{"text":"While in short words I would agree with &quot;Prefer composition over inheritance&quot;, very often for me it sounds like &quot;prefer potatoes over coca-cola&quot;. There are places for inheritance and places for composition. You need to understand difference, then this question will disappear. What it really means for me is &quot;if you are going to use inheritance - think again, chances are you need composition&quot;.\n\nYou should prefer potatoes over coca cola when you want to eat, and coca cola over potatoes when you want to drink.\n\nCreating a subclass should mean more than just a convenient way to call superclass methods. You should use inheritance when subclass &quot;is-a&quot; super class both structurally and functionally, when it can be used as superclass and you are going to use that. If it is not the case - it is not inheritance, but something else. Composition is when your objects consists of another, or has some relationship to them.\n\nSo for me it looks like if someone does not know if he needs inheritance or composition, the real problem is that he does not know if he want to drink or to eat. Think about your problem domain more, understand it better.\n    ","url":"/questions/[slug]#solution6","@type":"Answer","upvoteCount":0},{"text":"Didn&apos;t find a satisfactory answer here, so I wrote a new one.\n\nTo understand why &quot;prefer composition over inheritance&quot;, we need first get back the assumption omitted in this shortened idiom.\n\nThere are two benefits of inheritance: subtyping and subclassing\n\n\nSubtyping means conforming to a type (interface) signature, i.e. a set of APIs, and one can override part of the signature to achieve subtyping polymorphism.\nSubclassing means implicit reuse of method implementations.\n\n\nWith the two benefits comes two different purposes for doing inheritance: subtyping oriented and code reuse oriented.\n\nIf code reuse is the sole purpose, subclassing may give one more than what he needs, i.e. some public methods of the parent class don&apos;t make much sense for the child class. In this case, instead of favoring composition over inheritance, composition is demanded. This is also where the &quot;is-a&quot; vs. &quot;has-a&quot; notion comes from.\n\nSo only when subtyping is purposed, i.e. to use the new class later in a polymorphic manner, do we face the problem of choosing inheritance or composition. This is the assumption that gets omitted in the shortened idiom under discussion.\n\nTo subtype is to conform to a type signature, this means composition has always to expose no less amount of APIs of the type. Now the trade offs kick in:\n\n\nInheritance provides straightforward code reuse if not overridden, while composition has to re-code every API, even if it&apos;s just a simple job of delegation.\nInheritance provides straightforward open recursion via the internal polymorphic site this, i.e. invoking overriding method (or even type) in another member function, either public or private (though discouraged). Open recursion can be simulated via composition, but it requires extra effort and may not always viable(?). This answer to a duplicated question talks something similar.\nInheritance exposes protected members. This breaks encapsulation of the parent class, and if used by subclass, another dependency between the child and its parent is introduced.\nComposition has the befit of inversion of control, and its dependency can be injected dynamically, as is shown in decorator pattern and proxy pattern.\nComposition has the benefit of combinator-oriented programming, i.e. working in a way like the composite pattern.\nComposition immediately follows programming to an interface.\nComposition has the benefit of easy multiple inheritance.\n\n\nWith the above trade offs in mind, we hence prefer composition over inheritance. Yet for tightly related classes, i.e. when implicit code reuse really make benefits, or the magic power of open recursion is desired, inheritance shall be the choice.\n    ","url":"/questions/[slug]#solution7","@type":"Answer","upvoteCount":0},{"text":"Inheritance is pretty enticing especially coming from procedural-land and it often looks deceptively elegant. I mean all I need to do is add this one bit of functionality to some other class, right? Well, one of the problems is that inheritance is probably the worst form of coupling you can have\n\nYour base class breaks encapsulation by exposing implementation details to subclasses in the form of protected members. This makes your system rigid and fragile. The more tragic flaw however is the new subclass brings with it all the baggage and opinion of the inheritance chain.\n\nThe article, Inheritance is Evil: The Epic Fail of the DataAnnotationsModelBinder, walks through an example of this in C#. It shows the use of inheritance when composition should have been used and how it could be refactored.\n    ","url":"/questions/[slug]#solution8","@type":"Answer","upvoteCount":0},{"text":"When can you use composition?\nYou can always use composition. In some cases, inheritance is also possible and may lead to a more powerful and/or intuitive API, but composition is always an option.\nWhen can you use inheritance?\nIt is often said that if &quot;a bar is a foo&quot;, then the class Bar can inherit the class Foo. Unfortunately, this test alone is not reliable, use the following instead:\n\n\na bar is a foo, AND\nbars can do everything that foos can do.\n\n\nThe first test ensures that all getters of Foo make sense in Bar (= shared properties), while the second test makes sure that all setters of Foo make sense in Bar (= shared functionality).\nExample: Dog/Animal\nA dog is an animal AND dogs can do everything that animals can do (such as breathing, moving, etc.). Therefore, the class Dog can inherit the class Animal.\nCounter-example: Circle/Ellipse\nA circle is an ellipse BUT circles can&apos;t do everything that ellipses can do. For example, circles can&apos;t stretch, while ellipses can. Therefore, the class Circle cannot inherit the class Ellipse.\nThis is called the Circle-Ellipse problem, which isn&apos;t really a problem, but more an indication that &quot;a bar is a foo&quot; isn&apos;t a reliable test by itself. In particular, this example highlights that derived classes should extend the functionality of base classes, never restrict it. Otherwise, the base class couldn&apos;t be used polymorphically. Adding the test &quot;bars can do everything that foos can do&quot; ensures that polymorphic use is possible, and is equivalent to the Liskov Substitution Principle:\n\nFunctions that use pointers or references to base classes must be able to use objects of derived classes without knowing it\n\nWhen should you use inheritance?\nEven if you can use inheritance doesn&apos;t mean you should: using composition is always an option. Inheritance is a powerful tool allowing implicit code reuse and dynamic dispatch, but it does come with a few disadvantages, which is why composition is often preferred. The trade-offs between inheritance and composition aren&apos;t obvious, and in my opinion are best explained in lcn&apos;s answer.\nAs a rule of thumb, I tend to choose inheritance over composition when polymorphic use is expected to be very common, in which case the power of dynamic dispatch can lead to a much more readable and elegant API. For example, having a polymorphic class Widget in GUI frameworks, or a polymorphic class Node in XML libraries allows to have an API which is much more readable and intuitive to use than what you would have with a solution purely based on composition.\n    ","url":"/questions/[slug]#solution9","@type":"Answer","upvoteCount":0},{"text":"In Java or C#, an object cannot change its type once it has been instantiated.\n\nSo, if your object need to appear as a different object or behave differently depending on an object state or conditions, then use Composition: Refer to State and Strategy Design Patterns.\n\nIf the object need to be of the same type, then use Inheritance or implement interfaces.\n    ","url":"/questions/[slug]#solution10","@type":"Answer","upvoteCount":0},{"text":"Personally I learned to always prefer composition over inheritance. There is no programmatic problem you can solve with inheritance which you cannot solve with composition; though you may have to use Interfaces(Java) or Protocols(Obj-C) in some cases. Since C++ doesn&apos;t know any such thing, you&apos;ll have to use abstract base classes, which means you cannot get entirely rid of inheritance in C++.\n\nComposition is often more logical, it provides better abstraction, better encapsulation, better code reuse (especially in very large projects) and is less likely to break anything at a distance just because you made an isolated change anywhere in your code. It also makes it easier to uphold the &quot;Single Responsibility Principle&quot;, which is often summarized as &quot;There should never be more than one reason for a class to change.&quot;, and it means that every class exists for a specific purpose and it should only have methods that are directly related to its purpose. Also having a very shallow inheritance tree makes it much easier to keep the overview even when your project starts to get really large. Many people think that inheritance represents our real world pretty well, but that isn&apos;t the truth. The real world uses much more composition than inheritance. Pretty much every real world object you can hold in your hand has been composed out of other, smaller real world objects.\n\nThere are downsides of composition, though. If you skip inheritance altogether and only focus on composition, you will notice that you often have to write a couple of extra code lines that weren&apos;t necessary if you had used inheritance. You are also sometimes forced to repeat yourself and this violates the DRY Principle (DRY = Don&apos;t Repeat Yourself). Also composition often requires delegation, and a method is just calling another method of another object with no other code surrounding this call. Such &quot;double method calls&quot; (which may easily extend to triple or quadruple method calls and even farther than that) have much worse performance than inheritance, where you simply inherit a method of your parent. Calling an inherited method may be equally fast as calling a non-inherited one, or it may be slightly slower, but is usually still faster than two consecutive method calls.\n\nYou may have noticed that most OO languages don&apos;t allow multiple inheritance. While there are a couple of cases where multiple inheritance can really buy you something, but those are rather exceptions than the rule. Whenever you run into a situation where you think &quot;multiple inheritance would be a really cool feature to solve this problem&quot;, you are usually at a point where you should re-think inheritance altogether, since even it may require a couple of extra code lines, a solution based on composition will usually turn out to be much more elegant, flexible and future proof.\n\nInheritance is really a cool feature, but I&apos;m afraid it has been overused the last couple of years. People treated inheritance as the one hammer that can nail it all, regardless if it was actually a nail, a screw, or maybe a something completely different.\n    ","url":"/questions/[slug]#solution11","@type":"Answer","upvoteCount":0},{"text":"My general rule of thumb: Before using inheritance, consider if composition makes more sense.\n\nReason: Subclassing usually means more complexity and connectedness, i.e. harder to change, maintain, and scale without making mistakes.\n\nA much more complete and concrete answer from Tim Boudreau of Sun:\n\n\n  Common problems to the use of inheritance as I see it are:\n  \n  \n  Innocent acts can have unexpected results - The classic example of this is calls to overridable methods from the superclass\n  constructor, before the subclasses instance fields have been\n  initialized. In a perfect world, nobody would ever do that. This is\n  not a perfect world.\n  It offers perverse temptations for subclassers to make assumptions about order of method calls and such - such assumptions tend not to\n  be stable if the superclass may evolve over time. See also my toaster\n  and coffee pot analogy.\n  Classes get heavier - you don&apos;t necessarily know what work your superclass is doing in its constructor, or how much memory it&apos;s going\n  to use. So constructing some innocent would-be lightweight object can\n  be far more expensive than you think, and this may change over time if\n  the superclass evolves\n  It encourages an explosion of subclasses. Classloading costs time, more classes costs memory. This may be a non-issue until you&apos;re\n  dealing with an app on the scale of NetBeans, but there, we had real\n  issues with, for example, menus being slow because the first display\n  of a menu triggered massive class loading. We fixed this by moving to\n  more declarative syntax and other techniques, but that cost time to\n  fix as well.\n  It makes it harder to change things later - if you&apos;ve made a class public, swapping the superclass is going to break subclasses -\n  it&apos;s a choice which, once you&apos;ve made the code public, you&apos;re married\n  to. So if you&apos;re not altering the real functionality to your\n  superclass, you get much more freedom to change things later if you\n  use, rather than extend the thing you need. Take, for example,\n  subclassing JPanel - this is usually wrong; and if the subclass is\n  public somewhere, you never get a chance to revisit that decision. If\n  it&apos;s accessed as JComponent getThePanel() , you can still do it (hint:\n  expose models for the components within as your API).\n  Object hierarchies don&apos;t scale (or making them scale later is much harder than planning ahead) - this is the classic &quot;too many layers&quot;\n  problem. I&apos;ll go into this below, and how the AskTheOracle pattern can\n  solve it (though it may offend OOP purists). \n  \n  \n  ...\n  \n  My take on what to do, if you do allow for inheritance, which you may\n  take with a grain of salt is:\n  \n  \n  Expose no fields, ever, except constants\n  Methods shall be either abstract or final\n  Call no methods from the superclass constructor\n  \n  \n  ...\n  \n  all of this applies less to small projects than large ones, and less\n  to private classes than public ones\n\n    ","url":"/questions/[slug]#solution12","@type":"Answer","upvoteCount":0},{"text":"Inheritance is very powerful, but you can&apos;t force it (see: the circle-ellipse problem). If you really can&apos;t be completely sure of a true &quot;is-a&quot; subtype relationship, then it&apos;s best to go with composition.\n    ","url":"/questions/[slug]#solution13","@type":"Answer","upvoteCount":0},{"text":"Inheritance creates a strong relationship between a subclass and super class; subclass must be aware of super class&apos;es implementation details. Creating the super class is much harder, when you have to think about how it can be extended. You have to document class invariants carefully, and state what other methods overridable methods use internally. \n\nInheritance is sometimes useful, if the hierarchy really represents a is-a-relationship. It relates to Open-Closed Principle, which states that classes should be closed for modification but open to extension. That way you can have polymorphism; to have a generic method that deals with super type and its methods, but via dynamic dispatch the method of subclass is invoked. This is flexible, and helps to create indirection, which is essential in software (to know less about implementation details).\n\nInheritance is easily overused, though, and creates additional complexity, with hard dependencies between classes. Also understanding what happens during execution of a program gets pretty hard due to layers and dynamic selection of method calls.\n\nI would suggest using composing as the default. It is more modular, and gives the benefit of late binding (you can change the component dynamically). Also it&apos;s easier to test the things separately. And if you need to use a method from a class, you are not forced to be of certain form (Liskov Substitution Principle).\n    ","url":"/questions/[slug]#solution14","@type":"Answer","upvoteCount":0},{"text":"Suppose an aircraft has only two parts: an engine and wings.\nThen there are two ways to design an aircraft class.  \n\nClass Aircraft extends Engine{\n  var wings;\n}\n\n\nNow your aircraft can start with having fixed wings\nand change them to rotary wings on the fly. It&apos;s essentially\nan engine with wings. But what if I wanted to change\nthe engine on the fly as well?  \n\nEither the base class Engine exposes a mutator to change its\nproperties, or I redesign Aircraft as:   \n\nClass Aircraft {\n  var wings;\n  var engine;\n}\n\n\nNow, I can replace my engine on the fly as well.\n    ","url":"/questions/[slug]#solution15","@type":"Answer","upvoteCount":0},{"text":"You need to have a look at The Liskov Substitution Principle in Uncle Bob&apos;s SOLID principles of class design. :) \n    ","url":"/questions/[slug]#solution16","@type":"Answer","upvoteCount":0},{"text":"To address this question from a different perspective for newer programmers:\n\nInheritance is often taught early when we learn object-oriented programming, so it&apos;s seen as an easy solution to a common problem. \n\n\n  I have three classes that all need some common functionality. So if I\n  write a base class and have them all inherit from it, then they will\n  all have that functionality and I&apos;ll only need to maintain it in once\n  place.\n\n\nIt sounds great, but in practice it almost never, ever works, for one of several reasons:  \n\n\nWe discover that there are some other functions that we want our classes to have. If the way that we add functionality to classes is through inheritance, we have to decide - do we add it to the existing base class, even though not every class that inherits from it needs that functionality? Do we create another base class? But what about classes that already inherit from the other base class?\nWe discover that for just one of the classes that inherits from our base class we want the base class to behave a little differently. So now we go back and tinker with our base class, maybe adding some virtual methods, or even worse, some code that says, &quot;If I&apos;m inherited type A, do this, but if I&apos;m inherited type B, do that.&quot; That&apos;s bad for lots of reasons. One is that every time we change the base class, we&apos;re effectively changing every inherited class. So we&apos;re really changing class A, B, C, and D because we need a slightly different behavior in class A. As careful as we think we are, we might break one of those classes for reasons that have nothing to do with those classes.\nWe might know why we decided to make all of these classes inherit from each other, but it might not (probably won&apos;t) make sense to someone else who has to maintain our code. We might force them into a difficult choice - do I do something really ugly and messy to make the change I need (see the previous bullet point) or do I just rewrite a bunch of this.\n\n\nIn the end, we tie our code in some difficult knots and get no benefit whatsoever from it except that we get to say, &quot;Cool, I learned about inheritance and now I used it.&quot; That&apos;s not meant to be condescending because we&apos;ve all done it. But we all did it because no one told us not to. \n\nAs soon as someone explained &quot;favor composition over inheritance&quot; to me, I thought back over every time I tried to share functionality between classes using inheritance and realized that most of the time it didn&apos;t really work well.\n\nThe antidote is the Single Responsibility Principle. Think of it as a constraint. My class must do one thing. I must be able to give my class a name that somehow describes that one thing it does. (There are exceptions to everything, but absolute rules are sometimes better when we&apos;re learning.) It follows that I cannot write a base class called ObjectBaseThatContainsVariousFunctionsNeededByDifferentClasses. Whatever distinct functionality I need must be in its own class, and then other classes that need that functionality can depend on that class, not inherit from it.\n\nAt the risk of oversimplifying, that&apos;s composition - composing multiple classes to work together. And once we form that habit we find that it&apos;s much more flexible, maintainable, and testable than using inheritance.\n    ","url":"/questions/[slug]#solution17","@type":"Answer","upvoteCount":0},{"text":"If you want the canonical, textbook answer people have been giving since the rise of OOP (which you see many people giving in these answers), then apply the following rule: &quot;if you have an is-a relationship, use inheritance. If you have a has-a relationship, use composition&quot;.\nThis is the traditional advice, and if that satisfies you, you can stop reading here and go on your merry way. For everyone else...\nis-a/has-a comparisons have problems\nFor example:\n\nA square is-a rectangle, but if your rectangle class has setWidth()/setHeight() methods, then there&apos;s no reasonable way to make a Square inherit from Rectangle without breaking Liskov&apos;s substitution principle. As an alternative example, imagine a Car class that has an addGas() method. You&apos;re going to find it pretty difficult to inherit a new ElectricCar class from Car even though an ElectricCar is-a Car.\nAn is-a relationship can often be rephrased to sound like a has-a relationship. For example, an employee is-a person, but a person also has-an employment status of &quot;employed&quot;.\nis-a relationships can lead to nasty multiple inheritance hierarchies if you&apos;re not careful. After all, there&apos;s no rule in English that states that an object is exactly one thing.\nPeople are quick to pass this &quot;rule&quot; around, but has anyone ever tried to back it up, or explain why it&apos;s a good heuristic to follow? Sure, it fits nicely into the idea that OOP is supposed to model the real world, but that&apos;s not in-and-of-itself a reason to adopt a principle.\n\nSee this StackOverflow question for more reading on this subject.\nTo know when to use inheritance vs composition, we first need to understand the pros and cons of each.\nThe problems with implementation inheritance\nOther answers have done a wonderful job at explaining the issues with inheritance, so I&apos;ll try to not delve into too many details here. But, here&apos;s a brief list:\n\nInheritance arguably exposes a degree of implementation details to subclasses (via protected members).\nIt can be difficult to follow logic that weaves between base and sub class methods.\nThe fragile base problem. To make matters worse, most OOP languages allow inheritance by default - API designers who aren&apos;t proactively preventing people from inheriting from their public classes need to be extra cautious whenever they refactor their base classes. Unfortunately, the fragile base problem is often misunderstood, causing many to not understand what it takes to maintain a class that anyone can inherit from. (as an example, you can&apos;t refactor one method to have it start calling another public method, even if it doesn&apos;t change the behavior of the base class, because a subclass could have overridden the public method)\nThe deadly diamond of death\n\nThe problems with composition\n\nIt can sometimes be a little verbose.\n\nThat&apos;s it. I&apos;m serious. This is still a real issue and can sometimes create conflict with the DRY principle, but it&apos;s generally not that bad, at least compared to the myriad of pitfalls associated with inheritance.\nWhen should inheritance be used?\nNext time you&apos;re drawing out your fancy UML diagrams for a project (if you do that), and you&apos;re thinking about adding in some inheritance, please adhere to the following advice: don&apos;t.\nAt least, not yet.\nInheritance is sold as a tool to achieve polymorphism, but bundled with it is this powerful code-reuse system, that frankly, most code doesn&apos;t need. The problem is, as soon as you publicly expose your inheritance hierarchy, you&apos;re locked into this particular style of code-reuse, even if it&apos;s overkill to solve your particular problem.\nTo avoid this, my two cents would be to never expose your base classes publicly.\n\nIf you need polymorphism, use an interface.\nIf you need to allow people to customize the behavior of your class, provide explicit hook-in points via the strategy pattern, it&apos;s a more readable way to accomplish this, plus, it&apos;s easier to keep this sort of API stable as you&apos;re in full control over what behaviors they can and can not change.\nIf you&apos;re trying to follow the open-closed principle by using inheritance to avoid adding a much-needed update to a class, just don&apos;t. Update the class. Your codebase will be much cleaner if you actually take ownership of the code you&apos;re hired to maintain instead of trying to tack stuff onto the side of it. If you&apos;re scared about introducing bugs, then get the existing code under test.\nIf you need to reuse code, start out by trying to use composition or helper functions.\n\nFinally, if you&apos;ve decided that there&apos;s no other good option, and you must use inheritance to achieve the code-reuse that you need, then you can use it, but, follow these four P.A.I.L. rules of restricted inheritance to keep it sane.\n\nUse inheritance as a private implementation detail. Don&apos;t expose your base class publicly, use interfaces for that. This lets you freely add or remove inheritance as you see fit without making a breaking change.\nKeep your base class abstract. It makes it easier to divide out the logic that needs to be shared from the logic that doesn&apos;t.\nIsolate your base and child classes. Don&apos;t let your subclass override base class methods (use the strategy pattern for that), and avoid having them expect properties/methods to exist on each other, use other forms of code-sharing to achieve that.\nInheritance is a last resort.\n\nThe Isolate rule in particular may sound a little rough to follow, but if you discipline yourself, you&apos;ll get some pretty nice benefits. In particular, it gives you the freedom to avoid all of the main nasty pitfalls associated with inheritance that were mentioned above.\n\nYou&apos;re not exposing implementation details via protected members. You have no use for protected if your subclasses strive to not be aware of the properties that the base class offers.\nIt&apos;s much easier to follow the code, because it doesn&apos;t weave in and out of base/sub classes.\nThe fragile base problem goes away. The fragile base problem stems from the fact that people can arbitrarily override methods on a base class without you realizing/remembering it&apos;s happening. When the inheritance is isolated and private, the base class will be no more fragile than a class depending on another via composition.\nThe deadly diamond of death isn&apos;t an issue anymore, since there&apos;s simply no need to have multiple layers of inheritance. If you have the abstract base classes B and C, which both share a lot of functionality, just move that functionality out of B and C and into a new abstract base class, class D. Anyone who inherited from B should update to inherit from both B and D, and anyone who inherited from C should inherit from C and D. Since your base classes are all private implementation details, it shouldn&apos;t be too difficult to figure out who&apos;s inheriting from what, to make these changes.\n\nConclusion\nMy primary suggestion would be to use your brain on this matter. What&apos;s far more important than a list of dos and don&apos;ts about when to use inheritance is an intuitive understanding about inheritance and it&apos;s assosiated pros and cons, along with a good understanding about the other tools out there that can be used instead of inheritance (composition isn&apos;t the only alternative. For example, the strategy pattern is an amazing tool that&apos;s forgotten far too often). Perhaps when you have a good, solid understanding of all of these tools, you&apos;ll choose to use inheritance more often than I would recommend, and that&apos;s completely fine. At least, you&apos;re making an informed decision, and aren&apos;t just using inheritance because that&apos;s the only way you know how to do it.\nFurther reading:\n\nAn article I wrote on this subject, that dives even deeper and provides examples.\nA webpage talking about three different jobs that inheritance does, and how those jobs can be done via other means in the Go language.\nA listing of reasons why it can be good to declare your class as non-inheritable (e.g. &quot;final&quot; in Java).\n\n    ","url":"/questions/[slug]#solution18","@type":"Answer","upvoteCount":0},{"text":"When you want to &quot;copy&quot;/Expose the base class&apos; API, you use inheritance. When you only want to &quot;copy&quot; functionality, use delegation.\n\nOne example of this: You want to create a Stack out of a List. Stack only has pop, push and peek. You shouldn&apos;t use inheritance given that you don&apos;t want push_back, push_front, removeAt, et al.-kind of functionality in a Stack.\n    ","url":"/questions/[slug]#solution19","@type":"Answer","upvoteCount":0},{"text":"These two ways can live together just fine and actually support each other.\n\nComposition is just playing it modular: you create interface similar to the parent class, create new object and delegate calls to it. If these objects need not to know of each other, it&apos;s quite safe and easy to use composition. There are so many possibilites here.\n\nHowever, if the parent class for some reason needs to access functions provided by the &quot;child class&quot; for inexperienced programmer it may look like it&apos;s a great place to use  inheritance. The parent class can just call it&apos;s own abstract &quot;foo()&quot; which is overwritten by the subclass and then it can give the value to the abstract base.\n\nIt looks like a nice idea, but in many cases it&apos;s better just give the class an object which implements the foo() (or even set the value provided the foo() manually) than to inherit the new class from some base class which requires the function foo() to be specified.\n\nWhy?\n\nBecause inheritance is a poor way of moving information.\n\nThe composition has a real edge here: the relationship can be reversed: the &quot;parent class&quot; or &quot;abstract worker&quot; can aggregate any specific &quot;child&quot; objects implementing certain interface + any child can be set inside any other type of parent, which accepts it&apos;s type. And there can be any number of objects, for example MergeSort or QuickSort could sort any list of objects implementing an abstract Compare -interface. Or to put it another way: any group of objects which implement &quot;foo()&quot; and other group of objects which can make use of objects having &quot;foo()&quot; can play together. \n\nI can think of three real reasons for using inheritance:\n\n\nYou have many classes with same interface and you want to save time writing them\nYou have to use same Base Class for each object\nYou need to modify the private variables, which can not be public in any case\n\n\nIf these are true, then it is probably necessary to use inheritance.\n\nThere is nothing bad in using reason 1, it is very good thing to have a solid interface on your objects. This can be done using composition or with inheritance, no problem - if this interface is simple and does not change. Usually inheritance is quite effective here.\n\nIf the reason is number 2 it gets a bit tricky. Do you really only need to use the same base class? In general, just using the same base class is not good enough, but it may be a requirement of your framework, a design consideration which can not be avoided.\n\nHowever, if you want to use the private variables, the case 3, then you may be in trouble. If you consider global variables unsafe, then you should consider using inheritance to get access to private variables also unsafe. Mind you, global variables are not all THAT bad - databases are essentially big set of global variables. But if you can handle it, then it&apos;s quite fine.\n    ","url":"/questions/[slug]#solution20","@type":"Answer","upvoteCount":0},{"text":"Aside from is a/has a considerations, one must also consider the &quot;depth&quot; of inheritance your object has to go through. Anything beyond five or six levels of inheritance deep might cause unexpected casting and boxing/unboxing problems, and in those cases it might be wise to compose your object instead.\n    ","url":"/questions/[slug]#solution21","@type":"Answer","upvoteCount":0},{"text":"When you have an is-a relation between two classes (example dog is a canine), you go for inheritance.\n\nOn the other hand when you have has-a or some adjective relationship between two classes (student has courses) or (teacher studies courses), you chose composition.\n    ","url":"/questions/[slug]#solution22","@type":"Answer","upvoteCount":0},{"text":"A simple way to make sense of this would be that inheritance should be used when you need an object of your class to have the same interface as its parent class, so that it can thereby be treated as an object of the parent class (upcasting). Moreover, function calls on a derived class object would remain the same everywhere in code, but the specific method to call would be determined at runtime (i.e. the low-level implementation differs, the high-level interface remains the same).\n\nComposition should be used when you do not need the new class to have the same interface, i.e. you wish to conceal certain aspects of the class&apos; implementation which the user of that class need not know about. So composition is more in the way of supporting encapsulation (i.e. concealing the implementation) while inheritance is meant to support abstraction (i.e. providing a simplified representation of something, in this case the same interface for a range of types with different internals).\n    ","url":"/questions/[slug]#solution23","@type":"Answer","upvoteCount":0},{"text":"Subtyping is appropriate and more powerful where the invariants can be enumerated, else use function composition for extensibility.\n    ","url":"/questions/[slug]#solution24","@type":"Answer","upvoteCount":0},{"text":"I agree with @Pavel, when he says, there are places for composition and there are places for inheritance.\n\nI think inheritance should be used if your answer is an affirmative to any of these questions.\n\n\nIs your class part of a structure that benefits from polymorphism ? For example, if you had a Shape class, which declares a method called draw(), then we clearly need Circle and Square classes to be subclasses of Shape, so that their client classes would depend on Shape and not on specific subclasses.\nDoes your class need to re-use any high level interactions defined in another class ? The template method design pattern would be impossible to implement without inheritance. I believe all extensible frameworks use this pattern.\n\n\nHowever, if your intention is purely that of code re-use, then composition most likely is a better design choice.\n    ","url":"/questions/[slug]#solution25","@type":"Answer","upvoteCount":0},{"text":"Inheritance is a very powerfull machanism for code reuse. But needs to be used properly. I would say that inheritance is used correctly if the subclass is also a subtype of the parent class. As mentioned above, the Liskov Substitution Principle is the key point here. \n\nSubclass is not the same as subtype. You might create subclasses that are not subtypes (and this is when you should use composition). To understand what a subtype is, lets start giving an explanation of what a type is.\n\nWhen we say that the number 5 is of type integer, we are stating that 5 belongs to a set of possible values (as an example, see the possible values for the Java primitive types). We are also stating that there is a valid set of methods I can perform on the value like addition and subtraction. And finally we are stating that there are a set of properties that are always satisfied, for example, if I add the values 3 and 5, I will get 8 as a result.\n\nTo give another example, think about the abstract data types, Set of integers and List of integers, the values they can hold are restricted to integers. They both support a set of methods, like add(newValue) and size(). And they both have different properties (class invariant), Sets does not allow duplicates while List does allow duplicates (of course there are other properties that they both satisfy).\n\nSubtype is also a type, which has a relation to another type, called parent type (or supertype). The subtype must satisfy the features (values, methods and properties) of the parent type. The relation means that in any context where the supertype is expected, it can be substitutable by a subtype, without affecting the behaviour of the execution. Lets go to see some code to exemplify what Im saying. Suppose I write a List of integers (in some sort of pseudo language):\n\nclass List {\n  data = new Array();\n\n  Integer size() {\n    return data.length;\n  }\n\n  add(Integer anInteger) {\n    data[data.length] = anInteger;\n  }\n}\n\n\nThen, I write the Set of integers as a subclass of the List of integers:\n\nclass Set, inheriting from: List {\n  add(Integer anInteger) {\n     if (data.notContains(anInteger)) {\n       super.add(anInteger);\n     }\n  }\n}\n\n\nOur Set of integers class is a subclass of List of Integers, but is not a subtype, due to it is not satisfying all the features of the List class. The values, and the signature of the methods are satisfied but the properties are not. The behaviour of the add(Integer) method has been clearly changed, not preserving the properties of the parent type. Think from the point of view of the client of your classes. They might receive a Set of integers where a List of integers is expected. The client might want to add a value and get that value added to the List even if that value already exist in the List. But her wont get that behaviour if the value exists. A big suprise for her!\n\nThis is a classic example of an improper use of inheritance. Use composition in this case.\n\n(a fragment from: use inheritance properly).\n    ","url":"/questions/[slug]#solution26","@type":"Answer","upvoteCount":0},{"text":"Even though Composition is preferred, I would like to highlight pros of Inheritance and cons of Composition.\n\nPros of Inheritance:\n\n\nIt establishes a logical &quot;IS A&quot; relation. If Car and Truck are two types of Vehicle ( base class), child class IS A base class. \n\ni.e. \n\nCar is a Vehicle\n\nTruck is a Vehicle\nWith inheritance, you can define/modify/extend a capability\n\n\nBase class provides no implementation and sub-class has to override complete method (abstract) =&gt; You can implement a contract\nBase class provides default implementation and sub-class can change the behaviour =&gt; You can re-define contract\nSub-class adds extension to base class implementation by calling super.methodName() as first statement =&gt; You can extend a contract\nBase class defines structure of the algorithm  and sub-class will override a part of algorithm =&gt; You can implement Template_method without change in base class skeleton\n\n\n\nCons of Composition:\n\n\nIn inheritance, subclass can directly invoke base class method even though it&apos;s not implementing base class method because of IS A relation. If you use composition, you have to add methods in container class to expose contained class API\n\n\ne.g. If  Car contains Vehicle and if you have to get price of the Car, which has been defined in Vehicle, your code will be like this\n\nclass Vehicle{\n     protected double getPrice(){\n          // return price\n     }\n} \n\nclass Car{\n     Vehicle vehicle;\n     protected double getPrice(){\n          return vehicle.getPrice();\n     }\n} \n\n    ","url":"/questions/[slug]#solution27","@type":"Answer","upvoteCount":0},{"text":"A rule of thumb I have heard is inheritance should be used when its a &quot;is-a&quot; relationship and composition when its a &quot;has-a&quot;. Even with that I feel that you should always lean towards composition because it eliminates a lot of complexity.\n    ","url":"/questions/[slug]#solution28","@type":"Answer","upvoteCount":0},{"text":"Composition v/s Inheritance is a wide subject. There is no real answer for what is better as I think it all depends on the design of the system.\n\nGenerally type of relationship between object provide better information to choose one of them.\n\nIf relation type is  &quot;IS-A&quot; relation then Inheritance is better approach.\notherwise relation type is  &quot;HAS-A&quot; relation then composition will better approach.\n\nIts totally depend on entity relationship.\n    ","url":"/questions/[slug]#solution29","@type":"Answer","upvoteCount":0},{"text":"I see no one mentioned the diamond problem, which might arise with inheritance. \n\nIn a glance, if classes B and C inherit A and both override method X, and a fourth class D, inherits from both B and C, and does not override X, which implementation of X D is supposed to use?\n\nWikipedia offers a nice overview of the topic being discussed in this question.\n    ","url":"/questions/[slug]#solution30","@type":"Answer","upvoteCount":0}],"@type":"Question"}}</script><meta name="next-head-count" content="22"/><link rel="preload" href="/_next/static/css/4f7b2847abfe82c6.css" as="style"/><link rel="stylesheet" href="/_next/static/css/4f7b2847abfe82c6.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-0d1b80a048d4787e.js"></script><script src="/_next/static/chunks/webpack-42cdea76c8170223.js" defer=""></script><script src="/_next/static/chunks/framework-4556c45dd113b893.js" defer=""></script><script src="/_next/static/chunks/main-ccfab947c79712f4.js" defer=""></script><script src="/_next/static/chunks/pages/_app-c0d2dcb5e85faf18.js" defer=""></script><script src="/_next/static/chunks/294-106ef8570fa99deb.js" defer=""></script><script src="/_next/static/chunks/490-7f0418bb4354ac73.js" defer=""></script><script src="/_next/static/chunks/pages/questions/%5Bslug%5D-50e201fdaa1e0fd1.js" defer=""></script><script src="/_next/static/eGqQHYKGZKE-nXShFn8wX/_buildManifest.js" defer=""></script><script src="/_next/static/eGqQHYKGZKE-nXShFn8wX/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="wrapper"><header><nav class="bg-white border-gray-200 px-4 lg:px-6 py-2.5 dark:bg-gray-800"><div class="flex flex-wrap justify-between items-center mx-auto max-w-screen-xl"><a class="flex items-center" href="/"><img src="/logo-second.png" class="mr-3 h-6 sm:h-9" alt="Solution Checker Logo"/><h1 class="self-center text-xl font-semibold whitespace-nowrap dark:text-white">Solution Checker</h1></a><div class="flex items-center lg:order-2"><button data-collapse-toggle="mobile-menu-2" type="button" class="inline-flex items-center p-2 ml-1 text-sm text-gray-500 rounded-lg lg:hidden hover:bg-gray-100 focus:outline-none focus:ring-2 focus:ring-gray-200 dark:text-gray-400 dark:hover:bg-gray-700 dark:focus:ring-gray-600" aria-controls="mobile-menu-2" aria-expanded="false"><span class="sr-only">Open main menu</span><svg class="w-6 h-6" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M3 5a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM3 10a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM3 15a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1z" clip-rule="evenodd"></path></svg><svg class="hidden w-6 h-6" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z" clip-rule="evenodd"></path></svg></button></div><div class="hidden justify-between items-center w-full lg:flex lg:w-auto lg:order-1" id="mobile-menu-2"><ul class="flex flex-col mt-4 font-medium lg:flex-row lg:space-x-8 lg:mt-0"><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" aria-current="page" href="/">Home</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/questions?tab=news">Questions</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/post?tab=news">Post</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/questions/prefer-composition-over-inheritance-1657387399409#">Coding</a></li></ul></div></div></nav></header><div class="main-content"><div class="question my-5"><div class="flex question-header items-center m-auto justify-center"><div class="rounded-xl w-full border p-5 shadow-md bg-white"><div class="flex w-full items-center justify-between border-b pb-3"><div class="flex items-center space-x-3"><div class="text-lg font-bold text-slate-700"><a href="/questions/prefer-composition-over-inheritance-1657387399409"><h1>Prefer composition over inheritance?</h1></a></div></div><div class="flex flex-wrap h-auto justify-end items-center space-x-8"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold" href="/questions/tag/composition">composition</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold" href="/questions/tag/aggregation">aggregation</a></div></div><div class="question-content mt-5">
                
<p>Why prefer composition over inheritance?  What trade-offs are there for each approach?  When should you choose inheritance over composition?</p>
    </div></div></div><div class="solution-section"><nav class="flex pagination-solution flex-col justify-end"><h1 class="text-lg font-semibold mb-5">Navigate to solutions: </h1><ul class="inline-flex -space-x-px overflow-auto"><li class="pagination-solution-item"><span data-id="#solution1" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">1</span></li><li class="pagination-solution-item"><span data-id="#solution2" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">2</span></li><li class="pagination-solution-item"><span data-id="#solution3" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">3</span></li><li class="pagination-solution-item"><span data-id="#solution4" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">4</span></li><li class="pagination-solution-item"><span data-id="#solution5" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">5</span></li><li class="pagination-solution-item"><span data-id="#solution6" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">6</span></li><li class="pagination-solution-item"><span data-id="#solution7" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">7</span></li><li class="pagination-solution-item"><span data-id="#solution8" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">8</span></li><li class="pagination-solution-item"><span data-id="#solution9" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">9</span></li><li class="pagination-solution-item"><span data-id="#solution10" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">10</span></li><li class="pagination-solution-item"><span data-id="#solution11" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">11</span></li><li class="pagination-solution-item"><span data-id="#solution12" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">12</span></li><li class="pagination-solution-item"><span data-id="#solution13" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">13</span></li><li class="pagination-solution-item"><span data-id="#solution14" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">14</span></li><li class="pagination-solution-item"><span data-id="#solution15" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">15</span></li><li class="pagination-solution-item"><span data-id="#solution16" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">16</span></li><li class="pagination-solution-item"><span data-id="#solution17" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">17</span></li><li class="pagination-solution-item"><span data-id="#solution18" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">18</span></li><li class="pagination-solution-item"><span data-id="#solution19" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">19</span></li><li class="pagination-solution-item"><span data-id="#solution20" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">20</span></li><li class="pagination-solution-item"><span data-id="#solution21" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">21</span></li><li class="pagination-solution-item"><span data-id="#solution22" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">22</span></li><li class="pagination-solution-item"><span data-id="#solution23" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">23</span></li><li class="pagination-solution-item"><span data-id="#solution24" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">24</span></li><li class="pagination-solution-item"><span data-id="#solution25" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">25</span></li><li class="pagination-solution-item"><span data-id="#solution26" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">26</span></li><li class="pagination-solution-item"><span data-id="#solution27" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">27</span></li><li class="pagination-solution-item"><span data-id="#solution28" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">28</span></li><li class="pagination-solution-item"><span data-id="#solution29" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">29</span></li><li class="pagination-solution-item"><span data-id="#solution30" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">30</span></li></ul></nav><div id="solution1" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 1</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/composition">composition</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/aggregation">aggregation</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p><em>Prefer composition over inheritance as it is more malleable / easy to modify later, but do not use a compose-always approach.</em> With composition, it's easy to change behavior on the fly with Dependency Injection / Setters. Inheritance is more rigid as most languages do not allow you to derive from more than one type. So the goose is more or less cooked once you derive from TypeA.</p>

<p>My acid test for the above is:  </p>

<ul>
<li><p>Does TypeB want to expose the complete interface (all public methods no less) of TypeA such that TypeB can be used where TypeA is expected? Indicates <strong>Inheritance</strong>. </p>

<ul>
<li>e.g. A Cessna biplane will expose the complete interface of an airplane, if not more. So that makes it fit to derive from Airplane. </li>
</ul></li>
<li><p>Does TypeB want only some/part of the behavior exposed by TypeA? Indicates need for <strong>Composition.</strong>   </p>

<ul>
<li>e.g. A Bird may need only the fly behavior of an Airplane. In this case, it makes sense to extract it out as an interface / class / both and make it a member of both classes.</li>
</ul></li>
</ul>

<p><strong>Update:</strong> Just came back to my answer and it seems now that it is incomplete without a specific mention of Barbara Liskov's <a href="http://en.wikipedia.org/wiki/Liskov_substitution_principle" rel="noreferrer">Liskov Substitution Principle</a> as a test for 'Should I be inheriting from this type?'</p>
    </div></div></div></div><div id="solution2" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 2</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/composition">composition</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/aggregation">aggregation</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Think of containment as a <strong>has a</strong> relationship. A car "has an" engine, a person "has a" name, etc.</p>
<p>Think of inheritance as an <strong>is a</strong> relationship. A car "is a" vehicle, a person "is a" mammal, etc.</p>
<p>I take no credit for this approach. I took it straight from the <a href="https://rads.stackoverflow.com/amzn/click/com/0735619670" rel="noreferrer">Second Edition of Code Complete</a> by <a href="https://stevemcconnell.com/" rel="noreferrer">Steve McConnell</a>, <em>Section 6.3</em>.</p>
    </div></div></div></div><div id="solution3" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 3</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/composition">composition</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/aggregation">aggregation</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>If you understand the difference, it's easier to explain.</p>

<h2>Procedural Code</h2>

<p>An example of this is PHP without the use of classes (particularly before PHP5). All logic is encoded in a set of functions. You may include other files containing helper functions and so on and conduct your business logic by passing data around in functions. This can be very hard to manage as the application grows. PHP5 tries to remedy this by offering more object oriented design.</p>

<h2>Inheritance</h2>

<p>This encourages the use of classes. Inheritance is one of the three tenets of OO design (inheritance, polymorphism, encapsulation).</p>

<pre><code>class Person {
   String Title;
   String Name;
   Int Age
}

class Employee : Person {
   Int Salary;
   String Title;
}
</code></pre>

<p>This is inheritance at work. The Employee "is a" Person or inherits from Person. All inheritance relationships are "is-a" relationships. Employee also shadows the Title property from Person, meaning Employee.Title will return the Title for the Employee not the Person.</p>

<h2>Composition</h2>

<p>Composition is favoured over inheritance. To put it very simply you would have:</p>

<pre><code>class Person {
   String Title;
   String Name;
   Int Age;

   public Person(String title, String name, String age) {
      this.Title = title;
      this.Name = name;
      this.Age = age;
   }

}

class Employee {
   Int Salary;
   private Person person;

   public Employee(Person p, Int salary) {
       this.person = p;
       this.Salary = salary;
   }
}

Person johnny = new Person ("Mr.", "John", 25);
Employee john = new Employee (johnny, 50000);
</code></pre>

<p>Composition is typically "has a" or "uses a" relationship. Here the Employee class has a Person. It does not inherit from Person but instead gets the Person object passed to it, which is why it "has a" Person.</p>

<h2>Composition over Inheritance</h2>

<p>Now say you want to create a Manager type so you end up with:</p>

<pre><code>class Manager : Person, Employee {
   ...
}
</code></pre>

<p>This example will work fine, however, what if Person and Employee both declared <code>Title</code>? Should Manager.Title return "Manager of Operations" or "Mr."? Under composition this ambiguity is better handled:</p>

<pre><code>Class Manager {
   public string Title;
   public Manager(Person p, Employee e)
   {
      this.Title = e.Title;
   }
}
</code></pre>

<p>The Manager object is composed as an Employee and a Person. The Title behaviour is taken from employee. This explicit composition removes ambiguity among other things and you'll encounter fewer bugs.</p>
    </div></div></div></div><div id="solution4" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 4</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/composition">composition</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/aggregation">aggregation</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>With all the undeniable benefits provided by inheritance, here's some of its disadvantages.</p>

<p><strong>Disadvantages of Inheritance:</strong></p>

<ol>
<li>You can't change the implementation inherited from super classes at runtime (obviously because inheritance is defined at compile time).</li>
<li>Inheritance exposes a subclass to details of its parent class implementation, that's why it's often said that inheritance breaks encapsulation (in a sense that you really need to focus on interfaces only not implementation, so reusing by sub classing is not always preferred).</li>
<li>The tight coupling provided by inheritance makes the implementation of a subclass very bound up with the implementation of a super class that any change in the parent implementation will force the sub class to change.</li>
<li>Excessive reusing by sub-classing can make the inheritance stack very deep and very confusing too.</li>
</ol>

<p>On the other hand <b>Object composition</b> is defined at runtime through objects acquiring references to other objects. In such a case these objects will never be able to reach each-other's protected data (no encapsulation break) and will be forced to respect each other's interface. And in this case also, implementation dependencies will be a lot less than in case of inheritance.</p>
    </div></div></div></div><div id="solution5" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 5</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/composition">composition</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/aggregation">aggregation</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Another, very pragmatic reason, to prefer composition over inheritance has to do with your domain model, and mapping it to a relational database. It's really hard to map inheritance to the SQL model (you end up with all sorts of hacky workarounds, like creating columns that aren't always used, using views, etc). Some ORMLs try to deal with this, but it always gets complicated quickly. Composition can be easily modeled through a foreign-key relationship between two tables, but inheritance is much harder.</p>
    </div></div></div></div><div id="solution6" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 6</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/composition">composition</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/aggregation">aggregation</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>While in short words I would agree with "Prefer composition over inheritance", very often for me it sounds like "prefer potatoes over coca-cola". There are places for inheritance and places for composition. You need to understand difference, then this question will disappear. What it really means for me is "if you are going to use inheritance - think again, chances are you need composition".</p>

<p>You should prefer potatoes over coca cola when you want to eat, and coca cola over potatoes when you want to drink.</p>

<p>Creating a subclass should mean more than just a convenient way to call superclass methods. You should use inheritance when subclass "is-a" super class both structurally and functionally, when it can be used as superclass and you are going to use that. If it is not the case - it is not inheritance, but something else. Composition is when your objects consists of another, or has some relationship to them.</p>

<p>So for me it looks like if someone does not know if he needs inheritance or composition, the real problem is that he does not know if he want to drink or to eat. Think about your problem domain more, understand it better.</p>
    </div></div></div></div><div id="solution7" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 7</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/composition">composition</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/aggregation">aggregation</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Didn't find a satisfactory answer here, so I wrote a new one.</p>

<p>To understand why "<em>prefer</em> composition over inheritance", we need first get back the assumption omitted in this shortened idiom.</p>

<p>There are two benefits of inheritance: <a href="https://www.cs.princeton.edu/courses/archive/fall98/cs441/mainus/node12.html" rel="noreferrer">subtyping and subclassing</a></p>

<ol>
<li><p><strong>Subtyping</strong> means conforming to a type (interface) signature, i.e. a set of APIs, and one can override part of the signature to achieve subtyping polymorphism.</p></li>
<li><p><strong>Subclassing</strong> means implicit reuse of method implementations.</p></li>
</ol>

<p>With the two benefits comes two different purposes for doing inheritance: subtyping oriented and code reuse oriented.</p>

<p>If code reuse is the <em>sole</em> purpose, subclassing may give one more than what he needs, i.e. some public methods of the parent class don't make much sense for the child class. In this case, instead of favoring composition over inheritance, composition is <em>demanded</em>. This is also where the "is-a" vs. "has-a" notion comes from.</p>

<p>So only when subtyping is purposed, i.e. to use the new class later in a polymorphic manner, do we face the problem of choosing inheritance or composition. This is the assumption that gets omitted in the shortened idiom under discussion.</p>

<p>To subtype is to conform to a type signature, this means composition has always to expose no less amount of APIs of the type. Now the trade offs kick in:</p>

<ol>
<li><p>Inheritance provides straightforward code reuse if not overridden, while composition has to re-code every API, even if it's just a simple job of delegation.</p></li>
<li><p>Inheritance provides straightforward <a href="https://en.wikipedia.org/wiki/This_%28computer_programming%29#Open_recursion" rel="noreferrer">open recursion</a> via the internal polymorphic site <code>this</code>, i.e. invoking overriding method (or even <a href="http://www.scala-lang.org/old/node/1637.html#comment-5489" rel="noreferrer">type</a>) in another member function, either public or private (though <a href="https://softwareengineering.stackexchange.com/questions/35946/is-it-bad-code-smell-if-private-method-calls-public-one">discouraged</a>). Open recursion can be <a href="https://github.com/akottr/edu-pattern/blob/master/org.akottr.patterns.composition/src/org/akottr/patterns/composition/inheritance/Compositon.java" rel="noreferrer">simulated via composition</a>, but it requires extra effort and may not always viable(?). This <a href="https://stackoverflow.com/a/2238735/2073130">answer</a> to a duplicated question talks something similar.</p></li>
<li><p>Inheritance exposes <em>protected</em> members. This breaks encapsulation of the parent class, and if used by subclass, another dependency between the child and its parent is introduced.</p></li>
<li><p>Composition has the befit of inversion of control, and its dependency can be injected dynamically, as is shown in <a href="https://en.wikipedia.org/wiki/Decorator_pattern#Java" rel="noreferrer">decorator pattern</a> and <a href="https://en.wikipedia.org/wiki/Proxy_pattern#Java" rel="noreferrer">proxy pattern</a>.</p></li>
<li><p>Composition has the benefit of <a href="http://www.codecommit.com/blog/scala/the-magic-behind-parser-combinators" rel="noreferrer">combinator-oriented</a> programming, i.e. working in a way like the <a href="https://en.wikipedia.org/wiki/Composite_pattern#Java" rel="noreferrer">composite pattern</a>.</p></li>
<li><p>Composition immediately follows <a href="https://stackoverflow.com/questions/383947/what-does-it-mean-to-program-to-an-interface">programming to an interface</a>.</p></li>
<li><p>Composition has the benefit of easy <a href="https://stackoverflow.com/questions/3556652/how-do-java-interfaces-simulate-multiple-inheritance">multiple inheritance</a>.</p></li>
</ol>

<p>With the above trade offs in mind, we hence <em>prefer</em> composition over inheritance. Yet for tightly related classes, i.e. when implicit code reuse really make benefits, or the magic power of open recursion is desired, inheritance shall be the choice.</p>
    </div></div></div></div><div id="solution8" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 8</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/composition">composition</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/aggregation">aggregation</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Inheritance is pretty enticing especially coming from procedural-land and it often looks deceptively elegant. I mean all I need to do is add this one bit of functionality to some other class, right? Well, one of the problems is that </p><h2>inheritance is probably the worst form of coupling you can have</h2><p></p>

<p>Your base class breaks encapsulation by exposing implementation details to subclasses in the form of protected members. This makes your system rigid and fragile. The more tragic flaw however is the new subclass brings with it all the baggage and opinion of the inheritance chain.</p>

<p>The article, <a href="http://www.agileatwork.com/inheritance-is-evil-the-story-of-the-epic-fail-of-dataannotationsmodelbinder/" rel="noreferrer">Inheritance is Evil: The Epic Fail of the DataAnnotationsModelBinder</a>, walks through an example of this in C#. It shows the use of inheritance when composition should have been used and how it could be refactored.</p>
    </div></div></div></div><div id="solution9" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 9</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/composition">composition</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/aggregation">aggregation</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<h1>When can you use composition?</h1>
<p>You can always use composition. In some cases, inheritance is also possible and may lead to a more powerful and/or intuitive API, but composition is always an option.</p>
<h1>When can you use inheritance?</h1>
<p>It is often said that if "a bar is a foo", then the class <code>Bar</code> can inherit the class <code>Foo</code>. Unfortunately, this test alone is not reliable, use the following instead:</p>
<blockquote>
<ol>
<li>a bar is a foo, <strong>AND</strong></li>
<li>bars can do everything that foos can do.</li>
</ol>
</blockquote>
<p>The first test ensures that all <em>getters</em> of <code>Foo</code> make sense in <code>Bar</code> (= shared properties), while the second test makes sure that all <em>setters</em> of <code>Foo</code> make sense in <code>Bar</code> (= shared functionality).</p>
<p><strong>Example: Dog/Animal</strong></p>
<p>A dog is an animal AND dogs can do everything that animals can do (such as breathing, moving, etc.). Therefore, the class <code>Dog</code> <strong>can</strong> inherit the class <code>Animal</code>.</p>
<p><strong>Counter-example: Circle/Ellipse</strong></p>
<p>A circle is an ellipse BUT circles can't do everything that ellipses can do. For example, circles can't stretch, while ellipses can. Therefore, the class <code>Circle</code> <strong>cannot</strong> inherit the class <code>Ellipse</code>.</p>
<p>This is called the <a href="https://en.wikipedia.org/wiki/Circle-ellipse_problem" rel="noreferrer">Circle-Ellipse problem</a>, which isn't really a problem, but more an indication that "a bar is a foo" isn't a reliable test by itself. In particular, this example highlights that derived classes should <em>extend</em> the functionality of base classes, never <em>restrict</em> it. Otherwise, the base class couldn't be used polymorphically. Adding the test "bars can do everything that foos can do" ensures that polymorphic use is possible, and is equivalent to the <a href="http://web.archive.org/web/20110722014513/http://www.objectmentor.com/resources/articles/lsp.pdf" rel="noreferrer">Liskov Substitution Principle</a>:</p>
<blockquote>
<p>Functions that use pointers or references to base classes must be able to use objects of derived classes without knowing it</p>
</blockquote>
<h1>When should you use inheritance?</h1>
<p>Even if you <em>can</em> use inheritance doesn't mean you <em>should</em>: using composition is always an option. Inheritance is a powerful tool allowing implicit code reuse and dynamic dispatch, but it does come with a few disadvantages, which is why composition is often preferred. The trade-offs between inheritance and composition aren't obvious, and in my opinion are best explained in <a href="https://stackoverflow.com/a/32557773/1951907">lcn's answer</a>.</p>
<p>As a rule of thumb, I tend to choose inheritance over composition when polymorphic use is expected to be very common, in which case the power of dynamic dispatch can lead to a much more readable and elegant API. For example, having a polymorphic class <code>Widget</code> in GUI frameworks, or a polymorphic class <code>Node</code> in XML libraries allows to have an API which is much more readable and intuitive to use than what you would have with a solution purely based on composition.</p>
    </div></div></div></div><div id="solution10" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 10</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/composition">composition</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/aggregation">aggregation</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>In Java or C#, an object cannot change its type once it has been instantiated.</p>

<p>So, if your object need to appear as a different object or behave differently depending on an object state or conditions, then use <strong>Composition</strong>: Refer to <a href="http://www.dofactory.com/Patterns/PatternState.aspx" rel="noreferrer">State</a> and <a href="http://www.dofactory.com/Patterns/PatternStrategy.aspx" rel="noreferrer">Strategy</a> Design Patterns.</p>

<p>If the object need to be of the same type, then use <strong>Inheritance</strong> or implement interfaces.</p>
    </div></div></div></div><div id="solution11" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 11</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/composition">composition</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/aggregation">aggregation</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Personally I learned to always prefer composition over inheritance. There is no programmatic problem you can solve with inheritance which you cannot solve with composition; though you may have to use Interfaces(Java) or Protocols(Obj-C) in some cases. Since C++ doesn't know any such thing, you'll have to use abstract base classes, which means you cannot get entirely rid of inheritance in C++.</p>

<p>Composition is often more logical, it provides better abstraction, better encapsulation, better code reuse (especially in very large projects) and is less likely to break anything at a distance just because you made an isolated change anywhere in your code. It also makes it easier to uphold the "<em>Single Responsibility Principle</em>", which is often summarized as "<em>There should never be more than one reason for a class to change.</em>", and it means that every class exists for a specific purpose and it should only have methods that are directly related to its purpose. Also having a very shallow inheritance tree makes it much easier to keep the overview even when your project starts to get really large. Many people think that inheritance represents our <em>real world</em> pretty well, but that isn't the truth. The real world uses much more composition than inheritance. Pretty much every real world object you can hold in your hand has been composed out of other, smaller real world objects.</p>

<p>There are downsides of composition, though. If you skip inheritance altogether and only focus on composition, you will notice that you often have to write a couple of extra code lines that weren't necessary if you had used inheritance. You are also sometimes forced to repeat yourself and this violates the <em>DRY Principle</em> (DRY = Don't Repeat Yourself). Also composition often requires delegation, and a method is just calling another method of another object with no other code surrounding this call. Such "double method calls" (which may easily extend to triple or quadruple method calls and even farther than that) have much worse performance than inheritance, where you simply inherit a method of your parent. Calling an inherited method may be equally fast as calling a non-inherited one, or it may be slightly slower, but is usually still faster than two consecutive method calls.</p>

<p>You may have noticed that most OO languages don't allow multiple inheritance. While there are a couple of cases where multiple inheritance can really buy you something, but those are rather exceptions than the rule. Whenever you run into a situation where you think "multiple inheritance would be a really cool feature to solve this problem", you are usually at a point where you should re-think inheritance altogether, since even it may require a couple of extra code lines, a solution based on composition will usually turn out to be much more elegant, flexible and future proof.</p>

<p>Inheritance is really a cool feature, but I'm afraid it has been overused the last couple of years. People treated inheritance as the one hammer that can nail it all, regardless if it was actually a nail, a screw, or maybe a something completely different.</p>
    </div></div></div></div><div id="solution12" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 12</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/composition">composition</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/aggregation">aggregation</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>My general rule of thumb: <em>Before using inheritance, consider if composition makes more sense.</em></p>

<p>Reason: <em>Subclassing usually means more complexity and connectedness, i.e. harder to change, maintain, and scale without making mistakes.</em></p>

<p>A much more complete and concrete <a href="http://www.javalobby.org/forums/thread.jspa?forumID=61&amp;threadID=16487#91822172" rel="noreferrer">answer from Tim Boudreau</a> of Sun:</p>

<blockquote>
  <p>Common problems to the use of inheritance as I see it are:</p>
  
  <ul>
  <li><em>Innocent acts can have unexpected results</em> - The classic example of this is calls to overridable methods from the superclass
  constructor, before the subclasses instance fields have been
  initialized. In a perfect world, nobody would ever do that. This is
  not a perfect world.</li>
  <li><em>It offers perverse temptations for subclassers to make assumptions about order of method calls and such</em> - such assumptions tend not to
  be stable if the superclass may evolve over time. See also <a href="http://www.javalobby.org/forums/thread.jspa?threadID=16036&amp;messageID=91819530#91819530" rel="noreferrer">my toaster
  and coffee pot analogy</a>.</li>
  <li><em>Classes get heavier</em> - you don't necessarily know what work your superclass is doing in its constructor, or how much memory it's going
  to use. So constructing some innocent would-be lightweight object can
  be far more expensive than you think, and this may change over time if
  the superclass evolves</li>
  <li><em>It encourages an explosion of subclasses</em>. Classloading costs time, more classes costs memory. This may be a non-issue until you're
  dealing with an app on the scale of NetBeans, but there, we had real
  issues with, for example, menus being slow because the first display
  of a menu triggered massive class loading. We fixed this by moving to
  more declarative syntax and other techniques, but that cost time to
  fix as well.</li>
  <li><em>It makes it harder to change things later</em> - if you've made a class public, swapping the superclass is going to break subclasses -
  it's a choice which, once you've made the code public, you're married
  to. So if you're not altering the real functionality to your
  superclass, you get much more freedom to change things later if you
  use, rather than extend the thing you need. Take, for example,
  subclassing JPanel - this is usually wrong; and if the subclass is
  public somewhere, you never get a chance to revisit that decision. If
  it's accessed as JComponent getThePanel() , you can still do it (hint:
  expose models for the components within as your API).</li>
  <li><em>Object hierarchies don't scale (or making them scale later is much harder than planning ahead)</em> - this is the classic "too many layers"
  problem. I'll go into this below, and how the AskTheOracle pattern can
  solve it (though it may offend OOP purists). </li>
  </ul>
  
  <p>...</p>
  
  <p>My take on what to do, if you do allow for inheritance, which you may
  take with a grain of salt is:</p>
  
  <ul>
  <li>Expose no fields, ever, except constants</li>
  <li>Methods shall be either abstract or final</li>
  <li>Call no methods from the superclass constructor</li>
  </ul>
  
  <p>...</p>
  
  <p>all of this applies less to small projects than large ones, and less
  to private classes than public ones</p>
</blockquote>
    </div></div></div></div><div id="solution13" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 13</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/composition">composition</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/aggregation">aggregation</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Inheritance is very powerful, but you can't force it (see: the <a href="http://en.wikipedia.org/wiki/Circle-ellipse_problem" rel="noreferrer">circle-ellipse problem</a>). If you really can't be completely sure of a true "is-a" subtype relationship, then it's best to go with composition.</p>
    </div></div></div></div><div id="solution14" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 14</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/composition">composition</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/aggregation">aggregation</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Inheritance creates a strong relationship between a subclass and super class; subclass must be aware of super class'es implementation details. Creating the super class is much harder, when you have to think about how it can be extended. You have to document class invariants carefully, and state what other methods overridable methods use internally. </p>

<p>Inheritance is sometimes useful, if the hierarchy really represents a is-a-relationship. It relates to Open-Closed Principle, which states that classes should be closed for modification but open to extension. That way you can have polymorphism; to have a generic method that deals with super type and its methods, but via dynamic dispatch the method of subclass is invoked. This is flexible, and helps to create indirection, which is essential in software (to know less about implementation details).</p>

<p>Inheritance is easily overused, though, and creates additional complexity, with hard dependencies between classes. Also understanding what happens during execution of a program gets pretty hard due to layers and dynamic selection of method calls.</p>

<p>I would suggest using composing as the default. It is more modular, and gives the benefit of late binding (you can change the component dynamically). Also it's easier to test the things separately. And if you need to use a method from a class, you are not forced to be of certain form (Liskov Substitution Principle).</p>
    </div></div></div></div><div id="solution15" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 15</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/composition">composition</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/aggregation">aggregation</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Suppose an aircraft has only two parts: an engine and wings.<br>
Then there are two ways to design an aircraft class.  </p>

<pre><code>Class Aircraft extends Engine{
  var wings;
}
</code></pre>

<p>Now your aircraft can start with having fixed wings<br>
and change them to rotary wings on the fly. It's essentially<br>
an engine with wings. But what if I wanted to change<br>
the engine on the fly as well?  </p>

<p>Either the base class <code>Engine</code> exposes a mutator to change its<br>
properties, or I redesign <code>Aircraft</code> as:   </p>

<pre><code>Class Aircraft {
  var wings;
  var engine;
}
</code></pre>

<p>Now, I can replace my engine on the fly as well.</p>
    </div></div></div></div><div id="solution16" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 16</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/composition">composition</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/aggregation">aggregation</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>You need to have a look at <strong><a href="http://web.archive.org/web/20110722014513/http://www.objectmentor.com/resources/articles/lsp.pdf" rel="noreferrer">The Liskov Substitution Principle</a></strong> in Uncle Bob's <a href="http://butunclebob.com/ArticleS.UncleBob.PrinciplesOfOod" rel="noreferrer">SOLID</a> principles of class design. :) </p>
    </div></div></div></div><div id="solution17" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 17</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/composition">composition</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/aggregation">aggregation</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>To address this question from a different perspective for newer programmers:</p>

<p>Inheritance is often taught early when we learn object-oriented programming, so it's seen as an easy solution to a common problem. </p>

<blockquote>
  <p>I have three classes that all need some common functionality. So if I
  write a base class and have them all inherit from it, then they will
  all have that functionality and I'll only need to maintain it in once
  place.</p>
</blockquote>

<p>It sounds great, but in practice it almost never, ever works, for one of several reasons:  </p>

<ul>
<li>We discover that there are some other functions that we want our classes to have. If the way that we add functionality to classes is through inheritance, we have to decide - do we add it to the existing base class, even though not every class that inherits from it needs that functionality? Do we create another base class? But what about classes that already inherit from the other base class?</li>
<li>We discover that for just one of the classes that inherits from our base class we want the base class to behave a little differently. So now we go back and tinker with our base class, maybe adding some virtual methods, or even worse, some code that says, "If I'm inherited type A, do this, but if I'm inherited type B, do that." That's bad for lots of reasons. One is that every time we change the base class, we're effectively changing every inherited class. So we're really changing class A, B, C, and D because we need a slightly different behavior in class A. As careful as we think we are, we might break one of those classes for reasons that have nothing to do with those classes.</li>
<li>We might know why we decided to make all of these classes inherit from each other, but it might not (probably won't) make sense to someone else who has to maintain our code. We might force them into a difficult choice - do I do something really ugly and messy to make the change I need (see the previous bullet point) or do I just rewrite a bunch of this.</li>
</ul>

<p>In the end, we tie our code in some difficult knots and get no benefit whatsoever from it except that we get to say, "Cool, I learned about inheritance and now I used it." That's not meant to be condescending because we've all done it. But we all did it because no one told us not to. </p>

<p>As soon as someone explained "favor composition over inheritance" to me, I thought back over every time I tried to share functionality between classes using inheritance and realized that most of the time it didn't really work well.</p>

<p>The antidote is the <a href="https://en.wikipedia.org/wiki/Single_responsibility_principle" rel="noreferrer">Single Responsibility Principle</a>. Think of it as a constraint. My class <em>must</em> do one thing. I <em>must</em> be able to give my class a name that somehow describes that one thing it does. (There are exceptions to everything, but absolute rules are sometimes better when we're learning.) It follows that I cannot write a base class called <code>ObjectBaseThatContainsVariousFunctionsNeededByDifferentClasses</code>. Whatever distinct functionality I need must be in its own class, and then other classes that need that functionality can depend on that class, <em>not</em> inherit from it.</p>

<p>At the risk of oversimplifying, that's composition - composing multiple classes to work together. And once we form that habit we find that it's much more flexible, maintainable, and testable than using inheritance.</p>
    </div></div></div></div><div id="solution18" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 18</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/composition">composition</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/aggregation">aggregation</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>If you want the canonical, textbook answer people have been giving since the rise of OOP (which you see many people giving in these answers), then apply the following rule: "if you have an is-a relationship, use inheritance. If you have a has-a relationship, use composition".</p>
<p>This is the traditional advice, and if that satisfies you, you can stop reading here and go on your merry way. For everyone else...</p>
<h1>is-a/has-a comparisons have problems</h1>
<p>For example:</p>
<ul>
<li>A square is-a rectangle, but if your rectangle class has <code>setWidth()</code>/<code>setHeight()</code> methods, then there's no reasonable way to make a <code>Square</code> inherit from <code>Rectangle</code> without breaking <a href="https://en.wikipedia.org/wiki/Liskov_substitution_principle" rel="nofollow noreferrer">Liskov's substitution principle</a>. As an alternative example, imagine a <code>Car</code> class that has an <code>addGas()</code> method. You're going to find it pretty difficult to inherit a new <code>ElectricCar</code> class from <code>Car</code> even though an <code>ElectricCar</code> is-a <code>Car</code>.</li>
<li>An is-a relationship can often be rephrased to sound like a has-a relationship. For example, an employee is-a person, but a person also has-an employment status of "employed".</li>
<li>is-a relationships can lead to nasty multiple inheritance hierarchies if you're not careful. After all, there's no rule in English that states that an object <em>is</em> exactly one thing.</li>
<li>People are quick to pass this "rule" around, but has anyone ever tried to back it up, or explain why it's a good heuristic to follow? Sure, it fits nicely into the idea that OOP is supposed to model the real world, but that's not in-and-of-itself a reason to adopt a principle.</li>
</ul>
<p>See <a href="https://stackoverflow.com/questions/453738/inheritance-or-composition-rely-on-is-a-and-has-a">this</a> StackOverflow question for more reading on this subject.</p>
<p>To know when to use inheritance vs composition, we first need to understand the pros and cons of each.</p>
<h1>The problems with implementation inheritance</h1>
<p>Other answers have done a wonderful job at explaining the issues with inheritance, so I'll try to not delve into too many details here. But, here's a brief list:</p>
<ul>
<li>Inheritance arguably exposes a degree of implementation details to subclasses (via protected members).</li>
<li>It can be difficult to follow logic that weaves between base and sub class methods.</li>
<li>The <a href="https://en.wikipedia.org/wiki/Fragile_base_class" rel="nofollow noreferrer">fragile base problem</a>. To make matters worse, most OOP languages allow inheritance by default - API designers who aren't proactively preventing people from inheriting from their public classes need to be extra cautious whenever they refactor their base classes. Unfortunately, the fragile base problem is often misunderstood, causing many to not understand what it takes to maintain a class that anyone can inherit from. (as an example, you can't refactor one method to have it start calling another public method, even if it doesn't change the behavior of the base class, because a subclass could have overridden the public method)</li>
<li>The <a href="https://en.wikipedia.org/wiki/Multiple_inheritance#:%7E:text=inherit%20multiple%20methods.-,The%20diamond%20problem,-%5Bedit%5D" rel="nofollow noreferrer">deadly diamond of death</a></li>
</ul>
<h1>The problems with composition</h1>
<ul>
<li>It can sometimes be a little verbose.</li>
</ul>
<p>That's it. I'm serious. This is still a real issue and can sometimes create conflict with the DRY principle, but it's generally not that bad, at least compared to the myriad of pitfalls associated with inheritance.</p>
<h1>When should inheritance be used?</h1>
<p>Next time you're drawing out your fancy UML diagrams for a project (if you do that), and you're thinking about adding in some inheritance, please adhere to the following advice: don't.</p>
<p>At least, not yet.</p>
<p>Inheritance is sold as a tool to achieve polymorphism, but bundled with it is this powerful code-reuse system, that frankly, most code doesn't need. The problem is, as soon as you publicly expose your inheritance hierarchy, you're locked into this particular style of code-reuse, even if it's overkill to solve your particular problem.</p>
<p>To avoid this, my two cents would be to never expose your base classes publicly.</p>
<ul>
<li>If you need polymorphism, use an interface.</li>
<li>If you need to allow people to customize the behavior of your class, provide explicit hook-in points via <a href="https://en.wikipedia.org/wiki/Strategy_pattern" rel="nofollow noreferrer">the strategy pattern</a>, it's a more readable way to accomplish this, plus, it's easier to keep this sort of API stable as you're in full control over what behaviors they can and can not change.</li>
<li>If you're trying to follow the open-closed principle by using inheritance to avoid adding a much-needed update to a class, just don't. Update the class. Your codebase will be much cleaner if you actually take ownership of the code you're hired to maintain instead of trying to tack stuff onto the side of it. If you're scared about introducing bugs, then get the existing code under test.</li>
<li>If you need to reuse code, start out by trying to use composition or helper functions.</li>
</ul>
<p>Finally, if you've decided that there's no other good option, and you must use inheritance to achieve the code-reuse that you need, then you can use it, but, follow these four <strong>P.A.I.L.</strong> rules of restricted inheritance to keep it sane.</p>
<ol>
<li>Use inheritance as a <strong>private</strong> implementation detail. Don't expose your base class publicly, use interfaces for that. This lets you freely add or remove inheritance as you see fit without making a breaking change.</li>
<li>Keep your base class <strong>abstract</strong>. It makes it easier to divide out the logic that needs to be shared from the logic that doesn't.</li>
<li><strong>Isolate</strong> your base and child classes. Don't let your subclass override base class methods (use the strategy pattern for that), and avoid having them expect properties/methods to exist on each other, use other forms of code-sharing to achieve that.</li>
<li>Inheritance is a <strong>last</strong> resort.</li>
</ol>
<p>The <strong>Isolate</strong> rule in particular may sound a little rough to follow, but if you discipline yourself, you'll get some pretty nice benefits. In particular, it gives you the freedom to avoid all of the main nasty pitfalls associated with inheritance that were mentioned above.</p>
<ul>
<li>You're not exposing implementation details via protected members. You have no use for protected if your subclasses strive to not be aware of the properties that the base class offers.</li>
<li>It's much easier to follow the code, because it doesn't weave in and out of base/sub classes.</li>
<li>The fragile base problem goes away. The fragile base problem stems from the fact that people can arbitrarily override methods on a base class without you realizing/remembering it's happening. When the inheritance is isolated and private, the base class will be no more fragile than a class depending on another via composition.</li>
<li>The deadly diamond of death isn't an issue anymore, since there's simply no need to have multiple layers of inheritance. If you have the abstract base classes B and C, which both share a lot of functionality, just move that functionality out of B and C and into a new abstract base class, class D. Anyone who inherited from B should update to inherit from both B and D, and anyone who inherited from C should inherit from C and D. Since your base classes are all private implementation details, it shouldn't be too difficult to figure out who's inheriting from what, to make these changes.</li>
</ul>
<h2>Conclusion</h2>
<p>My primary suggestion would be to use your brain on this matter. What's far more important than a list of dos and don'ts about when to use inheritance is an intuitive understanding about inheritance and it's assosiated pros and cons, along with a good understanding about the other tools out there that can be used instead of inheritance (composition isn't the only alternative. For example, the strategy pattern is an amazing tool that's forgotten far too often). Perhaps when you have a good, solid understanding of all of these tools, you'll choose to use inheritance more often than I would recommend, and that's completely fine. At least, you're making an informed decision, and aren't just using inheritance because that's the only way you know how to do it.</p>
<p>Further reading:</p>
<ul>
<li><a href="https://javascript.plainenglish.io/composition-alone-cant-replace-inheritance-606760f03d60?source=friends_link&amp;sk=24f58b20b2d4162404376c6f7ec16301" rel="nofollow noreferrer">An article</a> I wrote on this subject, that dives even deeper and provides examples.</li>
<li><a href="https://yourbasic.org/golang/inheritance-object-oriented/" rel="nofollow noreferrer">A webpage</a> talking about three different jobs that inheritance does, and how those jobs can be done via other means in the Go language.</li>
<li><a href="https://programming.guide/java/when-to-create-a-final-class.html" rel="nofollow noreferrer">A listing</a> of reasons why it can be good to declare your class as non-inheritable (e.g. "final" in Java).</li>
</ul>
    </div></div></div></div><div id="solution19" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 19</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/composition">composition</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/aggregation">aggregation</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>When you want to "copy"/Expose the base class' API, you use inheritance. When you only want to "copy" functionality, use delegation.</p>

<p>One example of this: You want to create a Stack out of a List. Stack only has pop, push and peek. You shouldn't use inheritance given that you don't want push_back, push_front, removeAt, et al.-kind of functionality in a Stack.</p>
    </div></div></div></div><div id="solution20" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 20</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/composition">composition</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/aggregation">aggregation</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>These two ways can live together just fine and actually support each other.</p>

<p>Composition is just playing it modular: you create interface similar to the parent class, create new object and delegate calls to it. If these objects need not to know of each other, it's quite safe and easy to use composition. There are so many possibilites here.</p>

<p>However, if the parent class for some reason needs to access functions provided by the "child class" for inexperienced programmer it may look like it's a great place to use  inheritance. The parent class can just call it's own abstract "foo()" which is overwritten by the subclass and then it can give the value to the abstract base.</p>

<p>It looks like a nice idea, but in many cases it's better just give the class an object which implements the foo() (or even set the value provided the foo() manually) than to inherit the new class from some base class which requires the function foo() to be specified.</p>

<p>Why?</p>

<p><strong>Because inheritance is a poor way of moving information</strong>.</p>

<p>The composition has a real edge here: the relationship can be reversed: the "parent class" or "abstract worker" can aggregate any specific "child" objects implementing certain interface + <strong>any child can be set inside any other type of parent, which accepts it's type</strong>. And there can be any number of objects, for example MergeSort or QuickSort could sort any list of objects implementing an abstract Compare -interface. Or to put it another way: any group of objects which implement "foo()" and other group of objects which can make use of objects having "foo()" can play together. </p>

<p>I can think of three real reasons for using inheritance:</p>

<ol>
<li>You have many classes with <strong>same interface</strong> and you want to save time writing them</li>
<li>You have to use same Base Class for each object</li>
<li>You need to modify the private variables, which can not be public in any case</li>
</ol>

<p>If these are true, then it is probably necessary to use inheritance.</p>

<p>There is nothing bad in using reason 1, it is very good thing to have a solid interface on your objects. This can be done using composition or with inheritance, no problem - if this interface is simple and does not change. Usually inheritance is quite effective here.</p>

<p>If the reason is number 2 it gets a bit tricky. Do you really only need to use the same base class? In general, just using the same base class is not good enough, but it may be a requirement of your framework, a design consideration which can not be avoided.</p>

<p>However, if you want to use the private variables, the case 3, then you may be in trouble. <strong>If you consider global variables unsafe, then you should consider using inheritance to get access to private variables also unsafe</strong>. Mind you, global variables are not all THAT bad - databases are essentially big set of global variables. But if you can handle it, then it's quite fine.</p>
    </div></div></div></div><div id="solution21" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 21</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/composition">composition</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/aggregation">aggregation</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Aside from is a/has a considerations, one must also consider the "depth" of inheritance your object has to go through. Anything beyond five or six levels of inheritance deep might cause unexpected casting and boxing/unboxing problems, and in those cases it might be wise to compose your object instead.</p>
    </div></div></div></div><div id="solution22" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 22</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/composition">composition</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/aggregation">aggregation</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>When you have an <strong>is-a</strong> relation between two classes (example dog is a canine), you go for inheritance.</p>

<p>On the other hand when you have <strong>has-a</strong> or some adjective relationship between two classes (student has courses) or (teacher studies courses), you chose composition.</p>
    </div></div></div></div><div id="solution23" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 23</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/composition">composition</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/aggregation">aggregation</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>A simple way to make sense of this would be that inheritance should be used when you need an object of your class to have the same <em>interface</em> as its parent class, so that it can thereby be treated as an object of the parent class (upcasting). Moreover, function calls on a derived class object would remain the same everywhere in code, but the specific method to call would be determined at runtime (i.e. the low-level <em>implementation</em> differs, the high-level <em>interface</em> remains the same).</p>

<p>Composition should be used when you do not need the new class to have the same interface, i.e. you wish to conceal certain aspects of the class' implementation which the user of that class need not know about. So composition is more in the way of supporting <em>encapsulation</em> (i.e. concealing the implementation) while inheritance is meant to support <em>abstraction</em> (i.e. providing a simplified representation of something, in this case the <strong>same</strong> interface for a range of types with different internals).</p>
    </div></div></div></div><div id="solution24" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 24</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/composition">composition</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/aggregation">aggregation</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Subtyping is appropriate and more powerful where the <a href="https://stackoverflow.com/a/8352969">invariants can be enumerated</a>, else use function composition for extensibility.</p>
    </div></div></div></div><div id="solution25" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 25</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/composition">composition</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/aggregation">aggregation</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>I agree with @Pavel, when he says, there are places for composition and there are places for inheritance.</p>

<p>I think inheritance should be used if your answer is an affirmative to any of these questions.</p>

<ul>
<li>Is your class part of a structure that benefits from polymorphism ? For example, if you had a Shape class, which declares a method called draw(), then we clearly need Circle and Square classes to be subclasses of Shape, so that their client classes would depend on Shape and not on specific subclasses.</li>
<li>Does your class need to re-use any high level interactions defined in another class ? The <a href="http://en.wikipedia.org/wiki/Template_method_pattern" rel="nofollow noreferrer">template method</a> design pattern would be impossible to implement without inheritance. I believe all extensible frameworks use this pattern.</li>
</ul>

<p>However, if your intention is purely that of code re-use, then composition most likely is a better design choice.</p>
    </div></div></div></div><div id="solution26" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 26</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/composition">composition</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/aggregation">aggregation</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Inheritance is a very powerfull machanism for code reuse. But needs to be used properly. I would say that inheritance is used correctly if the subclass is also a subtype of the parent class. As mentioned above, the Liskov Substitution Principle is the key point here. </p>

<p>Subclass is not the same as subtype. You might create subclasses that are not subtypes (and this is when you should use composition). To understand what a subtype is, lets start giving an explanation of what a type is.</p>

<p>When we say that the number 5 is of type integer, we are stating that 5 belongs to a set of possible values (as an example, see the possible values for the Java primitive types). We are also stating that there is a valid set of methods I can perform on the value like addition and subtraction. And finally we are stating that there are a set of properties that are always satisfied, for example, if I add the values 3 and 5, I will get 8 as a result.</p>

<p>To give another example, think about the abstract data types, Set of integers and List of integers, the values they can hold are restricted to integers. They both support a set of methods, like add(newValue) and size(). And they both have different properties (class invariant), Sets does not allow duplicates while List does allow duplicates (of course there are other properties that they both satisfy).</p>

<p>Subtype is also a type, which has a relation to another type, called parent type (or supertype). The subtype must satisfy the features (values, methods and properties) of the parent type. The relation means that in any context where the supertype is expected, it can be substitutable by a subtype, without affecting the behaviour of the execution. Lets go to see some code to exemplify what Im saying. Suppose I write a List of integers (in some sort of pseudo language):</p>

<pre><code>class List {
  data = new Array();

  Integer size() {
    return data.length;
  }

  add(Integer anInteger) {
    data[data.length] = anInteger;
  }
}
</code></pre>

<p>Then, I write the Set of integers as a subclass of the List of integers:</p>

<pre><code>class Set, inheriting from: List {
  add(Integer anInteger) {
     if (data.notContains(anInteger)) {
       super.add(anInteger);
     }
  }
}
</code></pre>

<p>Our Set of integers class is a subclass of List of Integers, but is not a subtype, due to it is not satisfying all the features of the List class. The values, and the signature of the methods are satisfied but the properties are not. The behaviour of the add(Integer) method has been clearly changed, not preserving the properties of the parent type. Think from the point of view of the client of your classes. They might receive a Set of integers where a List of integers is expected. The client might want to add a value and get that value added to the List even if that value already exist in the List. But her wont get that behaviour if the value exists. A big suprise for her!</p>

<p>This is a classic example of an improper use of inheritance. Use composition in this case.</p>

<p>(a fragment from: <a href="http://www.copypasteisforword.com/notes/use-inheritance-properly" rel="nofollow">use inheritance properly</a>).</p>
    </div></div></div></div><div id="solution27" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 27</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/composition">composition</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/aggregation">aggregation</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Even though Composition is preferred, I would like to highlight pros of <em>Inheritance</em> and cons of <em>Composition</em>.</p>

<p><strong><em>Pros of Inheritance:</em></strong></p>

<ol>
<li><p>It establishes a logical "<strong>IS A"</strong> relation. If <em>Car</em> and <em>Truck</em> are two types of <em>Vehicle</em> ( base class), child class <strong>IS A</strong> base class. </p>

<p>i.e. </p>

<p><em>Car is a Vehicle</em></p>

<p><em>Truck is a Vehicle</em></p></li>
<li><p>With inheritance, you can define/modify/extend a capability</p>

<ol>
<li>Base class provides no implementation and sub-class has to override complete method (abstract) =&gt; <strong><em>You can implement a contract</em></strong></li>
<li>Base class provides default implementation and sub-class can change the behaviour =&gt; <strong><em>You can re-define contract</em></strong></li>
<li>Sub-class adds extension to base class implementation by calling super.methodName() as first statement =&gt; <strong><em>You can extend a contract</em></strong></li>
<li>Base class defines structure of the algorithm  and sub-class will override a part of algorithm =&gt; <strong><em>You can implement <a href="https://en.wikipedia.org/wiki/Template_method_pattern" rel="nofollow noreferrer">Template_method</a> without change in base class skeleton</em></strong></li>
</ol></li>
</ol>

<p><strong><em>Cons of Composition:</em></strong></p>

<ol>
<li>In inheritance, subclass can directly invoke base class method even though it's not implementing base class method because of <strong><em>IS A</em></strong> relation. If you use composition, you have to add methods in container class to expose contained class API</li>
</ol>

<p>e.g. If  <em>Car</em> contains <em>Vehicle</em> and if you have to get price of the <em>Car</em>, which has been defined in <em>Vehicle</em>, your code will be like this</p>

<pre><code>class Vehicle{
     protected double getPrice(){
          // return price
     }
} 

class Car{
     Vehicle vehicle;
     protected double getPrice(){
          return vehicle.getPrice();
     }
} 
</code></pre>
    </div></div></div></div><div id="solution28" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 28</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/composition">composition</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/aggregation">aggregation</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>A rule of thumb I have heard is inheritance should be used when its a "is-a" relationship and composition when its a "has-a". Even with that I feel that you should always lean towards composition because it eliminates a lot of complexity.</p>
    </div></div></div></div><div id="solution29" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 29</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/composition">composition</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/aggregation">aggregation</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Composition v/s Inheritance is a wide subject. There is no real answer for what is better as I think it all depends on the design of the system.</p>

<p>Generally type of relationship between object provide better information to choose one of them.</p>

<p>If relation type is  "IS-A" relation then Inheritance is better approach.
otherwise relation type is  "HAS-A" relation then composition will better approach.</p>

<p>Its totally depend on entity relationship.</p>
    </div></div></div></div><div id="solution30" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 30</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/composition">composition</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/aggregation">aggregation</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>I see no one mentioned the <a href="http://en.wikipedia.org/wiki/Multiple_inheritance#The_diamond_problem" rel="nofollow"><strong>diamond problem</strong></a>, which might arise with inheritance. </p>

<p>In a glance, if classes B and C inherit A and both override method X, and a fourth class D, inherits from both B and C, and does not override X, which implementation of X D is supposed to use?</p>

<p><a href="http://en.wikipedia.org/wiki/Composition_over_inheritance" rel="nofollow">Wikipedia</a> offers a nice overview of the topic being discussed in this question.</p>
    </div></div></div></div></div></div><div class="widget"><a href="/questions/mysql-pivot-row-into-dynamic-number-of-columns-1657387981930">MySQL pivot row into dynamic number of columns</a><a href="/questions/remove-duplicate-values-from-js-array-duplicate-1657387801931">Remove duplicate values from JS array [duplicate]</a><a href="/questions/what-is-array-to-pointer-decay-1657384709608">What is array to pointer decay?</a><a href="/questions/what-is-the-difference-between-and-equals()-in-java-1657387729654">What is the difference between == and equals() in Java?</a><a href="/questions/%22cross-origin-requests-are-only-supported-for-http.%22-error-when-loading-a-local-file-1657387942403">&quot;Cross origin requests are only supported for HTTP.&quot; error when loading a local file</a><a href="/questions/how-to-create-a-mysql-hierarchical-recursive-query-1657387662163">How to create a MySQL hierarchical recursive query?</a><a href="/questions/what-is-the-rule-of-three-1657384390295">What is The Rule of Three?</a><a href="/questions/how-to-create-a-generic-array-in-java-1657387532298">How to create a generic array in Java?</a><a href="/questions/what-is-the-difference-between-a-definition-and-a-declaration-1657387851618">What is the difference between a definition and a declaration?</a><a href="/questions/what-is-the-difference-between-public-protected-package-private-and-private-in-java-1657387376262">What is the difference between public, protected, package-private and private in Java?</a><a href="/questions/importing-installed-package-from-script-raises-%22attributeerror:-module-has-no-attribute%22-or-%22importerror:-cannot-import-name%22-1657387790607">Importing installed package from script raises &quot;AttributeError: module has no attribute&quot; or &quot;ImportError: cannot import name&quot;</a><a href="/questions/how-do-i-modify-the-url-without-reloading-the-page-1657387509731">How do I modify the URL without reloading the page?</a><a href="/questions/sending-email-in-android-using-javamail-api-without-using-the-defaultbuilt-in-app-1657387883400">Sending Email in Android using JavaMail API without using the default/built-in app</a><a href="/questions/where-do-i-find-the-current-c-or-c++-standard-documents-1657388006897">Where do I find the current C or C++ standard documents?</a><a href="/questions/how-can-i-upload-files-to-a-server-using-jspservlet-1657384847658">How can I upload files to a server using JSP/Servlet?</a><a href="/questions/what-are-drawbacks-or-disadvantages-of-singleton-pattern-closed-1657387360749">What are drawbacks or disadvantages of singleton pattern? [closed]</a><a href="/questions/what-do-&#x27;lazy&#x27;-and-&#x27;greedy&#x27;-mean-in-the-context-of-regular-expressions-1657388200552">What do &#x27;lazy&#x27; and &#x27;greedy&#x27; mean in the context of regular expressions?</a><a href="/questions/converting-string-into-datetime-1657387717295">Converting string into datetime</a><a href="/questions/how-to-remove-all-duplicates-from-an-array-of-objects-1657388256190">How to remove all duplicates from an array of objects?</a><a href="/questions/how-do-i-copy-to-the-clipboard-in-javascript-1657385501223">How do I copy to the clipboard in JavaScript?</a></div></div><span class="cursor-pointer text-lg p-2" style="position:fixed;bottom:20px;left:20px;background:#000;z-index:2000;color:white">Go go top</span></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"data":{"answer":["\n\u0026lt;p\u0026gt;\u0026lt;em\u0026gt;Prefer composition over inheritance as it is more malleable / easy to modify later, but do not use a compose-always approach.\u0026lt;/em\u0026gt; With composition, it\u0026apos;s easy to change behavior on the fly with Dependency Injection / Setters. Inheritance is more rigid as most languages do not allow you to derive from more than one type. So the goose is more or less cooked once you derive from TypeA.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;My acid test for the above is:  \u0026lt;/p\u0026gt;\n\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;Does TypeB want to expose the complete interface (all public methods no less) of TypeA such that TypeB can be used where TypeA is expected? Indicates \u0026lt;strong\u0026gt;Inheritance\u0026lt;/strong\u0026gt;. \u0026lt;/p\u0026gt;\n\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;e.g. A Cessna biplane will expose the complete interface of an airplane, if not more. So that makes it fit to derive from Airplane. \u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;Does TypeB want only some/part of the behavior exposed by TypeA? Indicates need for \u0026lt;strong\u0026gt;Composition.\u0026lt;/strong\u0026gt;   \u0026lt;/p\u0026gt;\n\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;e.g. A Bird may need only the fly behavior of an Airplane. In this case, it makes sense to extract it out as an interface / class / both and make it a member of both classes.\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Update:\u0026lt;/strong\u0026gt; Just came back to my answer and it seems now that it is incomplete without a specific mention of Barbara Liskov\u0026apos;s \u0026lt;a href=\u0026quot;http://en.wikipedia.org/wiki/Liskov_substitution_principle\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;Liskov Substitution Principle\u0026lt;/a\u0026gt; as a test for \u0026apos;Should I be inheriting from this type?\u0026apos;\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Think of containment as a \u0026lt;strong\u0026gt;has a\u0026lt;/strong\u0026gt; relationship. A car \u0026quot;has an\u0026quot; engine, a person \u0026quot;has a\u0026quot; name, etc.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Think of inheritance as an \u0026lt;strong\u0026gt;is a\u0026lt;/strong\u0026gt; relationship. A car \u0026quot;is a\u0026quot; vehicle, a person \u0026quot;is a\u0026quot; mammal, etc.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;I take no credit for this approach. I took it straight from the \u0026lt;a href=\u0026quot;https://rads.stackoverflow.com/amzn/click/com/0735619670\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;Second Edition of Code Complete\u0026lt;/a\u0026gt; by \u0026lt;a href=\u0026quot;https://stevemcconnell.com/\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;Steve McConnell\u0026lt;/a\u0026gt;, \u0026lt;em\u0026gt;Section 6.3\u0026lt;/em\u0026gt;.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;If you understand the difference, it\u0026apos;s easier to explain.\u0026lt;/p\u0026gt;\n\n\u0026lt;h2\u0026gt;Procedural Code\u0026lt;/h2\u0026gt;\n\n\u0026lt;p\u0026gt;An example of this is PHP without the use of classes (particularly before PHP5). All logic is encoded in a set of functions. You may include other files containing helper functions and so on and conduct your business logic by passing data around in functions. This can be very hard to manage as the application grows. PHP5 tries to remedy this by offering more object oriented design.\u0026lt;/p\u0026gt;\n\n\u0026lt;h2\u0026gt;Inheritance\u0026lt;/h2\u0026gt;\n\n\u0026lt;p\u0026gt;This encourages the use of classes. Inheritance is one of the three tenets of OO design (inheritance, polymorphism, encapsulation).\u0026lt;/p\u0026gt;\n\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;class Person {\n   String Title;\n   String Name;\n   Int Age\n}\n\nclass Employee : Person {\n   Int Salary;\n   String Title;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;This is inheritance at work. The Employee \u0026quot;is a\u0026quot; Person or inherits from Person. All inheritance relationships are \u0026quot;is-a\u0026quot; relationships. Employee also shadows the Title property from Person, meaning Employee.Title will return the Title for the Employee not the Person.\u0026lt;/p\u0026gt;\n\n\u0026lt;h2\u0026gt;Composition\u0026lt;/h2\u0026gt;\n\n\u0026lt;p\u0026gt;Composition is favoured over inheritance. To put it very simply you would have:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;class Person {\n   String Title;\n   String Name;\n   Int Age;\n\n   public Person(String title, String name, String age) {\n      this.Title = title;\n      this.Name = name;\n      this.Age = age;\n   }\n\n}\n\nclass Employee {\n   Int Salary;\n   private Person person;\n\n   public Employee(Person p, Int salary) {\n       this.person = p;\n       this.Salary = salary;\n   }\n}\n\nPerson johnny = new Person (\u0026quot;Mr.\u0026quot;, \u0026quot;John\u0026quot;, 25);\nEmployee john = new Employee (johnny, 50000);\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Composition is typically \u0026quot;has a\u0026quot; or \u0026quot;uses a\u0026quot; relationship. Here the Employee class has a Person. It does not inherit from Person but instead gets the Person object passed to it, which is why it \u0026quot;has a\u0026quot; Person.\u0026lt;/p\u0026gt;\n\n\u0026lt;h2\u0026gt;Composition over Inheritance\u0026lt;/h2\u0026gt;\n\n\u0026lt;p\u0026gt;Now say you want to create a Manager type so you end up with:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;class Manager : Person, Employee {\n   ...\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;This example will work fine, however, what if Person and Employee both declared \u0026lt;code\u0026gt;Title\u0026lt;/code\u0026gt;? Should Manager.Title return \u0026quot;Manager of Operations\u0026quot; or \u0026quot;Mr.\u0026quot;? Under composition this ambiguity is better handled:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;Class Manager {\n   public string Title;\n   public Manager(Person p, Employee e)\n   {\n      this.Title = e.Title;\n   }\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;The Manager object is composed as an Employee and a Person. The Title behaviour is taken from employee. This explicit composition removes ambiguity among other things and you\u0026apos;ll encounter fewer bugs.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;With all the undeniable benefits provided by inheritance, here\u0026apos;s some of its disadvantages.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Disadvantages of Inheritance:\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;ol\u0026gt;\n\u0026lt;li\u0026gt;You can\u0026apos;t change the implementation inherited from super classes at runtime (obviously because inheritance is defined at compile time).\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Inheritance exposes a subclass to details of its parent class implementation, that\u0026apos;s why it\u0026apos;s often said that inheritance breaks encapsulation (in a sense that you really need to focus on interfaces only not implementation, so reusing by sub classing is not always preferred).\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;The tight coupling provided by inheritance makes the implementation of a subclass very bound up with the implementation of a super class that any change in the parent implementation will force the sub class to change.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Excessive reusing by sub-classing can make the inheritance stack very deep and very confusing too.\u0026lt;/li\u0026gt;\n\u0026lt;/ol\u0026gt;\n\n\u0026lt;p\u0026gt;On the other hand \u0026lt;b\u0026gt;Object composition\u0026lt;/b\u0026gt; is defined at runtime through objects acquiring references to other objects. In such a case these objects will never be able to reach each-other\u0026apos;s protected data (no encapsulation break) and will be forced to respect each other\u0026apos;s interface. And in this case also, implementation dependencies will be a lot less than in case of inheritance.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Another, very pragmatic reason, to prefer composition over inheritance has to do with your domain model, and mapping it to a relational database. It\u0026apos;s really hard to map inheritance to the SQL model (you end up with all sorts of hacky workarounds, like creating columns that aren\u0026apos;t always used, using views, etc). Some ORMLs try to deal with this, but it always gets complicated quickly. Composition can be easily modeled through a foreign-key relationship between two tables, but inheritance is much harder.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;While in short words I would agree with \u0026quot;Prefer composition over inheritance\u0026quot;, very often for me it sounds like \u0026quot;prefer potatoes over coca-cola\u0026quot;. There are places for inheritance and places for composition. You need to understand difference, then this question will disappear. What it really means for me is \u0026quot;if you are going to use inheritance - think again, chances are you need composition\u0026quot;.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;You should prefer potatoes over coca cola when you want to eat, and coca cola over potatoes when you want to drink.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Creating a subclass should mean more than just a convenient way to call superclass methods. You should use inheritance when subclass \u0026quot;is-a\u0026quot; super class both structurally and functionally, when it can be used as superclass and you are going to use that. If it is not the case - it is not inheritance, but something else. Composition is when your objects consists of another, or has some relationship to them.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;So for me it looks like if someone does not know if he needs inheritance or composition, the real problem is that he does not know if he want to drink or to eat. Think about your problem domain more, understand it better.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Didn\u0026apos;t find a satisfactory answer here, so I wrote a new one.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;To understand why \u0026quot;\u0026lt;em\u0026gt;prefer\u0026lt;/em\u0026gt; composition over inheritance\u0026quot;, we need first get back the assumption omitted in this shortened idiom.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;There are two benefits of inheritance: \u0026lt;a href=\u0026quot;https://www.cs.princeton.edu/courses/archive/fall98/cs441/mainus/node12.html\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;subtyping and subclassing\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;ol\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Subtyping\u0026lt;/strong\u0026gt; means conforming to a type (interface) signature, i.e. a set of APIs, and one can override part of the signature to achieve subtyping polymorphism.\u0026lt;/p\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Subclassing\u0026lt;/strong\u0026gt; means implicit reuse of method implementations.\u0026lt;/p\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;/ol\u0026gt;\n\n\u0026lt;p\u0026gt;With the two benefits comes two different purposes for doing inheritance: subtyping oriented and code reuse oriented.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;If code reuse is the \u0026lt;em\u0026gt;sole\u0026lt;/em\u0026gt; purpose, subclassing may give one more than what he needs, i.e. some public methods of the parent class don\u0026apos;t make much sense for the child class. In this case, instead of favoring composition over inheritance, composition is \u0026lt;em\u0026gt;demanded\u0026lt;/em\u0026gt;. This is also where the \u0026quot;is-a\u0026quot; vs. \u0026quot;has-a\u0026quot; notion comes from.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;So only when subtyping is purposed, i.e. to use the new class later in a polymorphic manner, do we face the problem of choosing inheritance or composition. This is the assumption that gets omitted in the shortened idiom under discussion.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;To subtype is to conform to a type signature, this means composition has always to expose no less amount of APIs of the type. Now the trade offs kick in:\u0026lt;/p\u0026gt;\n\n\u0026lt;ol\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;Inheritance provides straightforward code reuse if not overridden, while composition has to re-code every API, even if it\u0026apos;s just a simple job of delegation.\u0026lt;/p\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;Inheritance provides straightforward \u0026lt;a href=\u0026quot;https://en.wikipedia.org/wiki/This_%28computer_programming%29#Open_recursion\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;open recursion\u0026lt;/a\u0026gt; via the internal polymorphic site \u0026lt;code\u0026gt;this\u0026lt;/code\u0026gt;, i.e. invoking overriding method (or even \u0026lt;a href=\u0026quot;http://www.scala-lang.org/old/node/1637.html#comment-5489\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;type\u0026lt;/a\u0026gt;) in another member function, either public or private (though \u0026lt;a href=\u0026quot;https://softwareengineering.stackexchange.com/questions/35946/is-it-bad-code-smell-if-private-method-calls-public-one\u0026quot;\u0026gt;discouraged\u0026lt;/a\u0026gt;). Open recursion can be \u0026lt;a href=\u0026quot;https://github.com/akottr/edu-pattern/blob/master/org.akottr.patterns.composition/src/org/akottr/patterns/composition/inheritance/Compositon.java\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;simulated via composition\u0026lt;/a\u0026gt;, but it requires extra effort and may not always viable(?). This \u0026lt;a href=\u0026quot;https://stackoverflow.com/a/2238735/2073130\u0026quot;\u0026gt;answer\u0026lt;/a\u0026gt; to a duplicated question talks something similar.\u0026lt;/p\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;Inheritance exposes \u0026lt;em\u0026gt;protected\u0026lt;/em\u0026gt; members. This breaks encapsulation of the parent class, and if used by subclass, another dependency between the child and its parent is introduced.\u0026lt;/p\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;Composition has the befit of inversion of control, and its dependency can be injected dynamically, as is shown in \u0026lt;a href=\u0026quot;https://en.wikipedia.org/wiki/Decorator_pattern#Java\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;decorator pattern\u0026lt;/a\u0026gt; and \u0026lt;a href=\u0026quot;https://en.wikipedia.org/wiki/Proxy_pattern#Java\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;proxy pattern\u0026lt;/a\u0026gt;.\u0026lt;/p\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;Composition has the benefit of \u0026lt;a href=\u0026quot;http://www.codecommit.com/blog/scala/the-magic-behind-parser-combinators\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;combinator-oriented\u0026lt;/a\u0026gt; programming, i.e. working in a way like the \u0026lt;a href=\u0026quot;https://en.wikipedia.org/wiki/Composite_pattern#Java\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;composite pattern\u0026lt;/a\u0026gt;.\u0026lt;/p\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;Composition immediately follows \u0026lt;a href=\u0026quot;https://stackoverflow.com/questions/383947/what-does-it-mean-to-program-to-an-interface\u0026quot;\u0026gt;programming to an interface\u0026lt;/a\u0026gt;.\u0026lt;/p\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;Composition has the benefit of easy \u0026lt;a href=\u0026quot;https://stackoverflow.com/questions/3556652/how-do-java-interfaces-simulate-multiple-inheritance\u0026quot;\u0026gt;multiple inheritance\u0026lt;/a\u0026gt;.\u0026lt;/p\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;/ol\u0026gt;\n\n\u0026lt;p\u0026gt;With the above trade offs in mind, we hence \u0026lt;em\u0026gt;prefer\u0026lt;/em\u0026gt; composition over inheritance. Yet for tightly related classes, i.e. when implicit code reuse really make benefits, or the magic power of open recursion is desired, inheritance shall be the choice.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Inheritance is pretty enticing especially coming from procedural-land and it often looks deceptively elegant. I mean all I need to do is add this one bit of functionality to some other class, right? Well, one of the problems is that \u0026lt;/p\u0026gt;\u0026lt;h2\u0026gt;inheritance is probably the worst form of coupling you can have\u0026lt;/h2\u0026gt;\u0026lt;p\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Your base class breaks encapsulation by exposing implementation details to subclasses in the form of protected members. This makes your system rigid and fragile. The more tragic flaw however is the new subclass brings with it all the baggage and opinion of the inheritance chain.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;The article, \u0026lt;a href=\u0026quot;http://www.agileatwork.com/inheritance-is-evil-the-story-of-the-epic-fail-of-dataannotationsmodelbinder/\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;Inheritance is Evil: The Epic Fail of the DataAnnotationsModelBinder\u0026lt;/a\u0026gt;, walks through an example of this in C#. It shows the use of inheritance when composition should have been used and how it could be refactored.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;h1\u0026gt;When can you use composition?\u0026lt;/h1\u0026gt;\n\u0026lt;p\u0026gt;You can always use composition. In some cases, inheritance is also possible and may lead to a more powerful and/or intuitive API, but composition is always an option.\u0026lt;/p\u0026gt;\n\u0026lt;h1\u0026gt;When can you use inheritance?\u0026lt;/h1\u0026gt;\n\u0026lt;p\u0026gt;It is often said that if \u0026quot;a bar is a foo\u0026quot;, then the class \u0026lt;code\u0026gt;Bar\u0026lt;/code\u0026gt; can inherit the class \u0026lt;code\u0026gt;Foo\u0026lt;/code\u0026gt;. Unfortunately, this test alone is not reliable, use the following instead:\u0026lt;/p\u0026gt;\n\u0026lt;blockquote\u0026gt;\n\u0026lt;ol\u0026gt;\n\u0026lt;li\u0026gt;a bar is a foo, \u0026lt;strong\u0026gt;AND\u0026lt;/strong\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;bars can do everything that foos can do.\u0026lt;/li\u0026gt;\n\u0026lt;/ol\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\u0026lt;p\u0026gt;The first test ensures that all \u0026lt;em\u0026gt;getters\u0026lt;/em\u0026gt; of \u0026lt;code\u0026gt;Foo\u0026lt;/code\u0026gt; make sense in \u0026lt;code\u0026gt;Bar\u0026lt;/code\u0026gt; (= shared properties), while the second test makes sure that all \u0026lt;em\u0026gt;setters\u0026lt;/em\u0026gt; of \u0026lt;code\u0026gt;Foo\u0026lt;/code\u0026gt; make sense in \u0026lt;code\u0026gt;Bar\u0026lt;/code\u0026gt; (= shared functionality).\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Example: Dog/Animal\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;A dog is an animal AND dogs can do everything that animals can do (such as breathing, moving, etc.). Therefore, the class \u0026lt;code\u0026gt;Dog\u0026lt;/code\u0026gt; \u0026lt;strong\u0026gt;can\u0026lt;/strong\u0026gt; inherit the class \u0026lt;code\u0026gt;Animal\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Counter-example: Circle/Ellipse\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;A circle is an ellipse BUT circles can\u0026apos;t do everything that ellipses can do. For example, circles can\u0026apos;t stretch, while ellipses can. Therefore, the class \u0026lt;code\u0026gt;Circle\u0026lt;/code\u0026gt; \u0026lt;strong\u0026gt;cannot\u0026lt;/strong\u0026gt; inherit the class \u0026lt;code\u0026gt;Ellipse\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;This is called the \u0026lt;a href=\u0026quot;https://en.wikipedia.org/wiki/Circle-ellipse_problem\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;Circle-Ellipse problem\u0026lt;/a\u0026gt;, which isn\u0026apos;t really a problem, but more an indication that \u0026quot;a bar is a foo\u0026quot; isn\u0026apos;t a reliable test by itself. In particular, this example highlights that derived classes should \u0026lt;em\u0026gt;extend\u0026lt;/em\u0026gt; the functionality of base classes, never \u0026lt;em\u0026gt;restrict\u0026lt;/em\u0026gt; it. Otherwise, the base class couldn\u0026apos;t be used polymorphically. Adding the test \u0026quot;bars can do everything that foos can do\u0026quot; ensures that polymorphic use is possible, and is equivalent to the \u0026lt;a href=\u0026quot;http://web.archive.org/web/20110722014513/http://www.objectmentor.com/resources/articles/lsp.pdf\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;Liskov Substitution Principle\u0026lt;/a\u0026gt;:\u0026lt;/p\u0026gt;\n\u0026lt;blockquote\u0026gt;\n\u0026lt;p\u0026gt;Functions that use pointers or references to base classes must be able to use objects of derived classes without knowing it\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\u0026lt;h1\u0026gt;When should you use inheritance?\u0026lt;/h1\u0026gt;\n\u0026lt;p\u0026gt;Even if you \u0026lt;em\u0026gt;can\u0026lt;/em\u0026gt; use inheritance doesn\u0026apos;t mean you \u0026lt;em\u0026gt;should\u0026lt;/em\u0026gt;: using composition is always an option. Inheritance is a powerful tool allowing implicit code reuse and dynamic dispatch, but it does come with a few disadvantages, which is why composition is often preferred. The trade-offs between inheritance and composition aren\u0026apos;t obvious, and in my opinion are best explained in \u0026lt;a href=\u0026quot;https://stackoverflow.com/a/32557773/1951907\u0026quot;\u0026gt;lcn\u0026apos;s answer\u0026lt;/a\u0026gt;.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;As a rule of thumb, I tend to choose inheritance over composition when polymorphic use is expected to be very common, in which case the power of dynamic dispatch can lead to a much more readable and elegant API. For example, having a polymorphic class \u0026lt;code\u0026gt;Widget\u0026lt;/code\u0026gt; in GUI frameworks, or a polymorphic class \u0026lt;code\u0026gt;Node\u0026lt;/code\u0026gt; in XML libraries allows to have an API which is much more readable and intuitive to use than what you would have with a solution purely based on composition.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;In Java or C#, an object cannot change its type once it has been instantiated.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;So, if your object need to appear as a different object or behave differently depending on an object state or conditions, then use \u0026lt;strong\u0026gt;Composition\u0026lt;/strong\u0026gt;: Refer to \u0026lt;a href=\u0026quot;http://www.dofactory.com/Patterns/PatternState.aspx\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;State\u0026lt;/a\u0026gt; and \u0026lt;a href=\u0026quot;http://www.dofactory.com/Patterns/PatternStrategy.aspx\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;Strategy\u0026lt;/a\u0026gt; Design Patterns.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;If the object need to be of the same type, then use \u0026lt;strong\u0026gt;Inheritance\u0026lt;/strong\u0026gt; or implement interfaces.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Personally I learned to always prefer composition over inheritance. There is no programmatic problem you can solve with inheritance which you cannot solve with composition; though you may have to use Interfaces(Java) or Protocols(Obj-C) in some cases. Since C++ doesn\u0026apos;t know any such thing, you\u0026apos;ll have to use abstract base classes, which means you cannot get entirely rid of inheritance in C++.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Composition is often more logical, it provides better abstraction, better encapsulation, better code reuse (especially in very large projects) and is less likely to break anything at a distance just because you made an isolated change anywhere in your code. It also makes it easier to uphold the \u0026quot;\u0026lt;em\u0026gt;Single Responsibility Principle\u0026lt;/em\u0026gt;\u0026quot;, which is often summarized as \u0026quot;\u0026lt;em\u0026gt;There should never be more than one reason for a class to change.\u0026lt;/em\u0026gt;\u0026quot;, and it means that every class exists for a specific purpose and it should only have methods that are directly related to its purpose. Also having a very shallow inheritance tree makes it much easier to keep the overview even when your project starts to get really large. Many people think that inheritance represents our \u0026lt;em\u0026gt;real world\u0026lt;/em\u0026gt; pretty well, but that isn\u0026apos;t the truth. The real world uses much more composition than inheritance. Pretty much every real world object you can hold in your hand has been composed out of other, smaller real world objects.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;There are downsides of composition, though. If you skip inheritance altogether and only focus on composition, you will notice that you often have to write a couple of extra code lines that weren\u0026apos;t necessary if you had used inheritance. You are also sometimes forced to repeat yourself and this violates the \u0026lt;em\u0026gt;DRY Principle\u0026lt;/em\u0026gt; (DRY = Don\u0026apos;t Repeat Yourself). Also composition often requires delegation, and a method is just calling another method of another object with no other code surrounding this call. Such \u0026quot;double method calls\u0026quot; (which may easily extend to triple or quadruple method calls and even farther than that) have much worse performance than inheritance, where you simply inherit a method of your parent. Calling an inherited method may be equally fast as calling a non-inherited one, or it may be slightly slower, but is usually still faster than two consecutive method calls.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;You may have noticed that most OO languages don\u0026apos;t allow multiple inheritance. While there are a couple of cases where multiple inheritance can really buy you something, but those are rather exceptions than the rule. Whenever you run into a situation where you think \u0026quot;multiple inheritance would be a really cool feature to solve this problem\u0026quot;, you are usually at a point where you should re-think inheritance altogether, since even it may require a couple of extra code lines, a solution based on composition will usually turn out to be much more elegant, flexible and future proof.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Inheritance is really a cool feature, but I\u0026apos;m afraid it has been overused the last couple of years. People treated inheritance as the one hammer that can nail it all, regardless if it was actually a nail, a screw, or maybe a something completely different.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;My general rule of thumb: \u0026lt;em\u0026gt;Before using inheritance, consider if composition makes more sense.\u0026lt;/em\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Reason: \u0026lt;em\u0026gt;Subclassing usually means more complexity and connectedness, i.e. harder to change, maintain, and scale without making mistakes.\u0026lt;/em\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;A much more complete and concrete \u0026lt;a href=\u0026quot;http://www.javalobby.org/forums/thread.jspa?forumID=61\u0026amp;amp;threadID=16487#91822172\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;answer from Tim Boudreau\u0026lt;/a\u0026gt; of Sun:\u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;Common problems to the use of inheritance as I see it are:\u0026lt;/p\u0026gt;\n  \n  \u0026lt;ul\u0026gt;\n  \u0026lt;li\u0026gt;\u0026lt;em\u0026gt;Innocent acts can have unexpected results\u0026lt;/em\u0026gt; - The classic example of this is calls to overridable methods from the superclass\n  constructor, before the subclasses instance fields have been\n  initialized. In a perfect world, nobody would ever do that. This is\n  not a perfect world.\u0026lt;/li\u0026gt;\n  \u0026lt;li\u0026gt;\u0026lt;em\u0026gt;It offers perverse temptations for subclassers to make assumptions about order of method calls and such\u0026lt;/em\u0026gt; - such assumptions tend not to\n  be stable if the superclass may evolve over time. See also \u0026lt;a href=\u0026quot;http://www.javalobby.org/forums/thread.jspa?threadID=16036\u0026amp;amp;messageID=91819530#91819530\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;my toaster\n  and coffee pot analogy\u0026lt;/a\u0026gt;.\u0026lt;/li\u0026gt;\n  \u0026lt;li\u0026gt;\u0026lt;em\u0026gt;Classes get heavier\u0026lt;/em\u0026gt; - you don\u0026apos;t necessarily know what work your superclass is doing in its constructor, or how much memory it\u0026apos;s going\n  to use. So constructing some innocent would-be lightweight object can\n  be far more expensive than you think, and this may change over time if\n  the superclass evolves\u0026lt;/li\u0026gt;\n  \u0026lt;li\u0026gt;\u0026lt;em\u0026gt;It encourages an explosion of subclasses\u0026lt;/em\u0026gt;. Classloading costs time, more classes costs memory. This may be a non-issue until you\u0026apos;re\n  dealing with an app on the scale of NetBeans, but there, we had real\n  issues with, for example, menus being slow because the first display\n  of a menu triggered massive class loading. We fixed this by moving to\n  more declarative syntax and other techniques, but that cost time to\n  fix as well.\u0026lt;/li\u0026gt;\n  \u0026lt;li\u0026gt;\u0026lt;em\u0026gt;It makes it harder to change things later\u0026lt;/em\u0026gt; - if you\u0026apos;ve made a class public, swapping the superclass is going to break subclasses -\n  it\u0026apos;s a choice which, once you\u0026apos;ve made the code public, you\u0026apos;re married\n  to. So if you\u0026apos;re not altering the real functionality to your\n  superclass, you get much more freedom to change things later if you\n  use, rather than extend the thing you need. Take, for example,\n  subclassing JPanel - this is usually wrong; and if the subclass is\n  public somewhere, you never get a chance to revisit that decision. If\n  it\u0026apos;s accessed as JComponent getThePanel() , you can still do it (hint:\n  expose models for the components within as your API).\u0026lt;/li\u0026gt;\n  \u0026lt;li\u0026gt;\u0026lt;em\u0026gt;Object hierarchies don\u0026apos;t scale (or making them scale later is much harder than planning ahead)\u0026lt;/em\u0026gt; - this is the classic \u0026quot;too many layers\u0026quot;\n  problem. I\u0026apos;ll go into this below, and how the AskTheOracle pattern can\n  solve it (though it may offend OOP purists). \u0026lt;/li\u0026gt;\n  \u0026lt;/ul\u0026gt;\n  \n  \u0026lt;p\u0026gt;...\u0026lt;/p\u0026gt;\n  \n  \u0026lt;p\u0026gt;My take on what to do, if you do allow for inheritance, which you may\n  take with a grain of salt is:\u0026lt;/p\u0026gt;\n  \n  \u0026lt;ul\u0026gt;\n  \u0026lt;li\u0026gt;Expose no fields, ever, except constants\u0026lt;/li\u0026gt;\n  \u0026lt;li\u0026gt;Methods shall be either abstract or final\u0026lt;/li\u0026gt;\n  \u0026lt;li\u0026gt;Call no methods from the superclass constructor\u0026lt;/li\u0026gt;\n  \u0026lt;/ul\u0026gt;\n  \n  \u0026lt;p\u0026gt;...\u0026lt;/p\u0026gt;\n  \n  \u0026lt;p\u0026gt;all of this applies less to small projects than large ones, and less\n  to private classes than public ones\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Inheritance is very powerful, but you can\u0026apos;t force it (see: the \u0026lt;a href=\u0026quot;http://en.wikipedia.org/wiki/Circle-ellipse_problem\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;circle-ellipse problem\u0026lt;/a\u0026gt;). If you really can\u0026apos;t be completely sure of a true \u0026quot;is-a\u0026quot; subtype relationship, then it\u0026apos;s best to go with composition.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Inheritance creates a strong relationship between a subclass and super class; subclass must be aware of super class\u0026apos;es implementation details. Creating the super class is much harder, when you have to think about how it can be extended. You have to document class invariants carefully, and state what other methods overridable methods use internally. \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Inheritance is sometimes useful, if the hierarchy really represents a is-a-relationship. It relates to Open-Closed Principle, which states that classes should be closed for modification but open to extension. That way you can have polymorphism; to have a generic method that deals with super type and its methods, but via dynamic dispatch the method of subclass is invoked. This is flexible, and helps to create indirection, which is essential in software (to know less about implementation details).\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Inheritance is easily overused, though, and creates additional complexity, with hard dependencies between classes. Also understanding what happens during execution of a program gets pretty hard due to layers and dynamic selection of method calls.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;I would suggest using composing as the default. It is more modular, and gives the benefit of late binding (you can change the component dynamically). Also it\u0026apos;s easier to test the things separately. And if you need to use a method from a class, you are not forced to be of certain form (Liskov Substitution Principle).\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Suppose an aircraft has only two parts: an engine and wings.\u0026lt;br\u0026gt;\nThen there are two ways to design an aircraft class.  \u0026lt;/p\u0026gt;\n\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;Class Aircraft extends Engine{\n  var wings;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Now your aircraft can start with having fixed wings\u0026lt;br\u0026gt;\nand change them to rotary wings on the fly. It\u0026apos;s essentially\u0026lt;br\u0026gt;\nan engine with wings. But what if I wanted to change\u0026lt;br\u0026gt;\nthe engine on the fly as well?  \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Either the base class \u0026lt;code\u0026gt;Engine\u0026lt;/code\u0026gt; exposes a mutator to change its\u0026lt;br\u0026gt;\nproperties, or I redesign \u0026lt;code\u0026gt;Aircraft\u0026lt;/code\u0026gt; as:   \u0026lt;/p\u0026gt;\n\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;Class Aircraft {\n  var wings;\n  var engine;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Now, I can replace my engine on the fly as well.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;You need to have a look at \u0026lt;strong\u0026gt;\u0026lt;a href=\u0026quot;http://web.archive.org/web/20110722014513/http://www.objectmentor.com/resources/articles/lsp.pdf\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;The Liskov Substitution Principle\u0026lt;/a\u0026gt;\u0026lt;/strong\u0026gt; in Uncle Bob\u0026apos;s \u0026lt;a href=\u0026quot;http://butunclebob.com/ArticleS.UncleBob.PrinciplesOfOod\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;SOLID\u0026lt;/a\u0026gt; principles of class design. :) \u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;To address this question from a different perspective for newer programmers:\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Inheritance is often taught early when we learn object-oriented programming, so it\u0026apos;s seen as an easy solution to a common problem. \u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;I have three classes that all need some common functionality. So if I\n  write a base class and have them all inherit from it, then they will\n  all have that functionality and I\u0026apos;ll only need to maintain it in once\n  place.\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;p\u0026gt;It sounds great, but in practice it almost never, ever works, for one of several reasons:  \u0026lt;/p\u0026gt;\n\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;We discover that there are some other functions that we want our classes to have. If the way that we add functionality to classes is through inheritance, we have to decide - do we add it to the existing base class, even though not every class that inherits from it needs that functionality? Do we create another base class? But what about classes that already inherit from the other base class?\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;We discover that for just one of the classes that inherits from our base class we want the base class to behave a little differently. So now we go back and tinker with our base class, maybe adding some virtual methods, or even worse, some code that says, \u0026quot;If I\u0026apos;m inherited type A, do this, but if I\u0026apos;m inherited type B, do that.\u0026quot; That\u0026apos;s bad for lots of reasons. One is that every time we change the base class, we\u0026apos;re effectively changing every inherited class. So we\u0026apos;re really changing class A, B, C, and D because we need a slightly different behavior in class A. As careful as we think we are, we might break one of those classes for reasons that have nothing to do with those classes.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;We might know why we decided to make all of these classes inherit from each other, but it might not (probably won\u0026apos;t) make sense to someone else who has to maintain our code. We might force them into a difficult choice - do I do something really ugly and messy to make the change I need (see the previous bullet point) or do I just rewrite a bunch of this.\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\n\u0026lt;p\u0026gt;In the end, we tie our code in some difficult knots and get no benefit whatsoever from it except that we get to say, \u0026quot;Cool, I learned about inheritance and now I used it.\u0026quot; That\u0026apos;s not meant to be condescending because we\u0026apos;ve all done it. But we all did it because no one told us not to. \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;As soon as someone explained \u0026quot;favor composition over inheritance\u0026quot; to me, I thought back over every time I tried to share functionality between classes using inheritance and realized that most of the time it didn\u0026apos;t really work well.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;The antidote is the \u0026lt;a href=\u0026quot;https://en.wikipedia.org/wiki/Single_responsibility_principle\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;Single Responsibility Principle\u0026lt;/a\u0026gt;. Think of it as a constraint. My class \u0026lt;em\u0026gt;must\u0026lt;/em\u0026gt; do one thing. I \u0026lt;em\u0026gt;must\u0026lt;/em\u0026gt; be able to give my class a name that somehow describes that one thing it does. (There are exceptions to everything, but absolute rules are sometimes better when we\u0026apos;re learning.) It follows that I cannot write a base class called \u0026lt;code\u0026gt;ObjectBaseThatContainsVariousFunctionsNeededByDifferentClasses\u0026lt;/code\u0026gt;. Whatever distinct functionality I need must be in its own class, and then other classes that need that functionality can depend on that class, \u0026lt;em\u0026gt;not\u0026lt;/em\u0026gt; inherit from it.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;At the risk of oversimplifying, that\u0026apos;s composition - composing multiple classes to work together. And once we form that habit we find that it\u0026apos;s much more flexible, maintainable, and testable than using inheritance.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;If you want the canonical, textbook answer people have been giving since the rise of OOP (which you see many people giving in these answers), then apply the following rule: \u0026quot;if you have an is-a relationship, use inheritance. If you have a has-a relationship, use composition\u0026quot;.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;This is the traditional advice, and if that satisfies you, you can stop reading here and go on your merry way. For everyone else...\u0026lt;/p\u0026gt;\n\u0026lt;h1\u0026gt;is-a/has-a comparisons have problems\u0026lt;/h1\u0026gt;\n\u0026lt;p\u0026gt;For example:\u0026lt;/p\u0026gt;\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;A square is-a rectangle, but if your rectangle class has \u0026lt;code\u0026gt;setWidth()\u0026lt;/code\u0026gt;/\u0026lt;code\u0026gt;setHeight()\u0026lt;/code\u0026gt; methods, then there\u0026apos;s no reasonable way to make a \u0026lt;code\u0026gt;Square\u0026lt;/code\u0026gt; inherit from \u0026lt;code\u0026gt;Rectangle\u0026lt;/code\u0026gt; without breaking \u0026lt;a href=\u0026quot;https://en.wikipedia.org/wiki/Liskov_substitution_principle\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;Liskov\u0026apos;s substitution principle\u0026lt;/a\u0026gt;. As an alternative example, imagine a \u0026lt;code\u0026gt;Car\u0026lt;/code\u0026gt; class that has an \u0026lt;code\u0026gt;addGas()\u0026lt;/code\u0026gt; method. You\u0026apos;re going to find it pretty difficult to inherit a new \u0026lt;code\u0026gt;ElectricCar\u0026lt;/code\u0026gt; class from \u0026lt;code\u0026gt;Car\u0026lt;/code\u0026gt; even though an \u0026lt;code\u0026gt;ElectricCar\u0026lt;/code\u0026gt; is-a \u0026lt;code\u0026gt;Car\u0026lt;/code\u0026gt;.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;An is-a relationship can often be rephrased to sound like a has-a relationship. For example, an employee is-a person, but a person also has-an employment status of \u0026quot;employed\u0026quot;.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;is-a relationships can lead to nasty multiple inheritance hierarchies if you\u0026apos;re not careful. After all, there\u0026apos;s no rule in English that states that an object \u0026lt;em\u0026gt;is\u0026lt;/em\u0026gt; exactly one thing.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;People are quick to pass this \u0026quot;rule\u0026quot; around, but has anyone ever tried to back it up, or explain why it\u0026apos;s a good heuristic to follow? Sure, it fits nicely into the idea that OOP is supposed to model the real world, but that\u0026apos;s not in-and-of-itself a reason to adopt a principle.\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;p\u0026gt;See \u0026lt;a href=\u0026quot;https://stackoverflow.com/questions/453738/inheritance-or-composition-rely-on-is-a-and-has-a\u0026quot;\u0026gt;this\u0026lt;/a\u0026gt; StackOverflow question for more reading on this subject.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;To know when to use inheritance vs composition, we first need to understand the pros and cons of each.\u0026lt;/p\u0026gt;\n\u0026lt;h1\u0026gt;The problems with implementation inheritance\u0026lt;/h1\u0026gt;\n\u0026lt;p\u0026gt;Other answers have done a wonderful job at explaining the issues with inheritance, so I\u0026apos;ll try to not delve into too many details here. But, here\u0026apos;s a brief list:\u0026lt;/p\u0026gt;\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;Inheritance arguably exposes a degree of implementation details to subclasses (via protected members).\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;It can be difficult to follow logic that weaves between base and sub class methods.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;The \u0026lt;a href=\u0026quot;https://en.wikipedia.org/wiki/Fragile_base_class\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;fragile base problem\u0026lt;/a\u0026gt;. To make matters worse, most OOP languages allow inheritance by default - API designers who aren\u0026apos;t proactively preventing people from inheriting from their public classes need to be extra cautious whenever they refactor their base classes. Unfortunately, the fragile base problem is often misunderstood, causing many to not understand what it takes to maintain a class that anyone can inherit from. (as an example, you can\u0026apos;t refactor one method to have it start calling another public method, even if it doesn\u0026apos;t change the behavior of the base class, because a subclass could have overridden the public method)\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;The \u0026lt;a href=\u0026quot;https://en.wikipedia.org/wiki/Multiple_inheritance#:%7E:text=inherit%20multiple%20methods.-,The%20diamond%20problem,-%5Bedit%5D\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;deadly diamond of death\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;h1\u0026gt;The problems with composition\u0026lt;/h1\u0026gt;\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;It can sometimes be a little verbose.\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;p\u0026gt;That\u0026apos;s it. I\u0026apos;m serious. This is still a real issue and can sometimes create conflict with the DRY principle, but it\u0026apos;s generally not that bad, at least compared to the myriad of pitfalls associated with inheritance.\u0026lt;/p\u0026gt;\n\u0026lt;h1\u0026gt;When should inheritance be used?\u0026lt;/h1\u0026gt;\n\u0026lt;p\u0026gt;Next time you\u0026apos;re drawing out your fancy UML diagrams for a project (if you do that), and you\u0026apos;re thinking about adding in some inheritance, please adhere to the following advice: don\u0026apos;t.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;At least, not yet.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Inheritance is sold as a tool to achieve polymorphism, but bundled with it is this powerful code-reuse system, that frankly, most code doesn\u0026apos;t need. The problem is, as soon as you publicly expose your inheritance hierarchy, you\u0026apos;re locked into this particular style of code-reuse, even if it\u0026apos;s overkill to solve your particular problem.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;To avoid this, my two cents would be to never expose your base classes publicly.\u0026lt;/p\u0026gt;\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;If you need polymorphism, use an interface.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;If you need to allow people to customize the behavior of your class, provide explicit hook-in points via \u0026lt;a href=\u0026quot;https://en.wikipedia.org/wiki/Strategy_pattern\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;the strategy pattern\u0026lt;/a\u0026gt;, it\u0026apos;s a more readable way to accomplish this, plus, it\u0026apos;s easier to keep this sort of API stable as you\u0026apos;re in full control over what behaviors they can and can not change.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;If you\u0026apos;re trying to follow the open-closed principle by using inheritance to avoid adding a much-needed update to a class, just don\u0026apos;t. Update the class. Your codebase will be much cleaner if you actually take ownership of the code you\u0026apos;re hired to maintain instead of trying to tack stuff onto the side of it. If you\u0026apos;re scared about introducing bugs, then get the existing code under test.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;If you need to reuse code, start out by trying to use composition or helper functions.\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;p\u0026gt;Finally, if you\u0026apos;ve decided that there\u0026apos;s no other good option, and you must use inheritance to achieve the code-reuse that you need, then you can use it, but, follow these four \u0026lt;strong\u0026gt;P.A.I.L.\u0026lt;/strong\u0026gt; rules of restricted inheritance to keep it sane.\u0026lt;/p\u0026gt;\n\u0026lt;ol\u0026gt;\n\u0026lt;li\u0026gt;Use inheritance as a \u0026lt;strong\u0026gt;private\u0026lt;/strong\u0026gt; implementation detail. Don\u0026apos;t expose your base class publicly, use interfaces for that. This lets you freely add or remove inheritance as you see fit without making a breaking change.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Keep your base class \u0026lt;strong\u0026gt;abstract\u0026lt;/strong\u0026gt;. It makes it easier to divide out the logic that needs to be shared from the logic that doesn\u0026apos;t.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;strong\u0026gt;Isolate\u0026lt;/strong\u0026gt; your base and child classes. Don\u0026apos;t let your subclass override base class methods (use the strategy pattern for that), and avoid having them expect properties/methods to exist on each other, use other forms of code-sharing to achieve that.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Inheritance is a \u0026lt;strong\u0026gt;last\u0026lt;/strong\u0026gt; resort.\u0026lt;/li\u0026gt;\n\u0026lt;/ol\u0026gt;\n\u0026lt;p\u0026gt;The \u0026lt;strong\u0026gt;Isolate\u0026lt;/strong\u0026gt; rule in particular may sound a little rough to follow, but if you discipline yourself, you\u0026apos;ll get some pretty nice benefits. In particular, it gives you the freedom to avoid all of the main nasty pitfalls associated with inheritance that were mentioned above.\u0026lt;/p\u0026gt;\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;You\u0026apos;re not exposing implementation details via protected members. You have no use for protected if your subclasses strive to not be aware of the properties that the base class offers.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;It\u0026apos;s much easier to follow the code, because it doesn\u0026apos;t weave in and out of base/sub classes.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;The fragile base problem goes away. The fragile base problem stems from the fact that people can arbitrarily override methods on a base class without you realizing/remembering it\u0026apos;s happening. When the inheritance is isolated and private, the base class will be no more fragile than a class depending on another via composition.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;The deadly diamond of death isn\u0026apos;t an issue anymore, since there\u0026apos;s simply no need to have multiple layers of inheritance. If you have the abstract base classes B and C, which both share a lot of functionality, just move that functionality out of B and C and into a new abstract base class, class D. Anyone who inherited from B should update to inherit from both B and D, and anyone who inherited from C should inherit from C and D. Since your base classes are all private implementation details, it shouldn\u0026apos;t be too difficult to figure out who\u0026apos;s inheriting from what, to make these changes.\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;h2\u0026gt;Conclusion\u0026lt;/h2\u0026gt;\n\u0026lt;p\u0026gt;My primary suggestion would be to use your brain on this matter. What\u0026apos;s far more important than a list of dos and don\u0026apos;ts about when to use inheritance is an intuitive understanding about inheritance and it\u0026apos;s assosiated pros and cons, along with a good understanding about the other tools out there that can be used instead of inheritance (composition isn\u0026apos;t the only alternative. For example, the strategy pattern is an amazing tool that\u0026apos;s forgotten far too often). Perhaps when you have a good, solid understanding of all of these tools, you\u0026apos;ll choose to use inheritance more often than I would recommend, and that\u0026apos;s completely fine. At least, you\u0026apos;re making an informed decision, and aren\u0026apos;t just using inheritance because that\u0026apos;s the only way you know how to do it.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Further reading:\u0026lt;/p\u0026gt;\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;a href=\u0026quot;https://javascript.plainenglish.io/composition-alone-cant-replace-inheritance-606760f03d60?source=friends_link\u0026amp;amp;sk=24f58b20b2d4162404376c6f7ec16301\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;An article\u0026lt;/a\u0026gt; I wrote on this subject, that dives even deeper and provides examples.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;a href=\u0026quot;https://yourbasic.org/golang/inheritance-object-oriented/\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;A webpage\u0026lt;/a\u0026gt; talking about three different jobs that inheritance does, and how those jobs can be done via other means in the Go language.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;a href=\u0026quot;https://programming.guide/java/when-to-create-a-final-class.html\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;A listing\u0026lt;/a\u0026gt; of reasons why it can be good to declare your class as non-inheritable (e.g. \u0026quot;final\u0026quot; in Java).\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n    ","\n\u0026lt;p\u0026gt;When you want to \u0026quot;copy\u0026quot;/Expose the base class\u0026apos; API, you use inheritance. When you only want to \u0026quot;copy\u0026quot; functionality, use delegation.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;One example of this: You want to create a Stack out of a List. Stack only has pop, push and peek. You shouldn\u0026apos;t use inheritance given that you don\u0026apos;t want push_back, push_front, removeAt, et al.-kind of functionality in a Stack.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;These two ways can live together just fine and actually support each other.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Composition is just playing it modular: you create interface similar to the parent class, create new object and delegate calls to it. If these objects need not to know of each other, it\u0026apos;s quite safe and easy to use composition. There are so many possibilites here.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;However, if the parent class for some reason needs to access functions provided by the \u0026quot;child class\u0026quot; for inexperienced programmer it may look like it\u0026apos;s a great place to use  inheritance. The parent class can just call it\u0026apos;s own abstract \u0026quot;foo()\u0026quot; which is overwritten by the subclass and then it can give the value to the abstract base.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;It looks like a nice idea, but in many cases it\u0026apos;s better just give the class an object which implements the foo() (or even set the value provided the foo() manually) than to inherit the new class from some base class which requires the function foo() to be specified.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Why?\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Because inheritance is a poor way of moving information\u0026lt;/strong\u0026gt;.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;The composition has a real edge here: the relationship can be reversed: the \u0026quot;parent class\u0026quot; or \u0026quot;abstract worker\u0026quot; can aggregate any specific \u0026quot;child\u0026quot; objects implementing certain interface + \u0026lt;strong\u0026gt;any child can be set inside any other type of parent, which accepts it\u0026apos;s type\u0026lt;/strong\u0026gt;. And there can be any number of objects, for example MergeSort or QuickSort could sort any list of objects implementing an abstract Compare -interface. Or to put it another way: any group of objects which implement \u0026quot;foo()\u0026quot; and other group of objects which can make use of objects having \u0026quot;foo()\u0026quot; can play together. \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;I can think of three real reasons for using inheritance:\u0026lt;/p\u0026gt;\n\n\u0026lt;ol\u0026gt;\n\u0026lt;li\u0026gt;You have many classes with \u0026lt;strong\u0026gt;same interface\u0026lt;/strong\u0026gt; and you want to save time writing them\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;You have to use same Base Class for each object\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;You need to modify the private variables, which can not be public in any case\u0026lt;/li\u0026gt;\n\u0026lt;/ol\u0026gt;\n\n\u0026lt;p\u0026gt;If these are true, then it is probably necessary to use inheritance.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;There is nothing bad in using reason 1, it is very good thing to have a solid interface on your objects. This can be done using composition or with inheritance, no problem - if this interface is simple and does not change. Usually inheritance is quite effective here.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;If the reason is number 2 it gets a bit tricky. Do you really only need to use the same base class? In general, just using the same base class is not good enough, but it may be a requirement of your framework, a design consideration which can not be avoided.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;However, if you want to use the private variables, the case 3, then you may be in trouble. \u0026lt;strong\u0026gt;If you consider global variables unsafe, then you should consider using inheritance to get access to private variables also unsafe\u0026lt;/strong\u0026gt;. Mind you, global variables are not all THAT bad - databases are essentially big set of global variables. But if you can handle it, then it\u0026apos;s quite fine.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Aside from is a/has a considerations, one must also consider the \u0026quot;depth\u0026quot; of inheritance your object has to go through. Anything beyond five or six levels of inheritance deep might cause unexpected casting and boxing/unboxing problems, and in those cases it might be wise to compose your object instead.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;When you have an \u0026lt;strong\u0026gt;is-a\u0026lt;/strong\u0026gt; relation between two classes (example dog is a canine), you go for inheritance.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;On the other hand when you have \u0026lt;strong\u0026gt;has-a\u0026lt;/strong\u0026gt; or some adjective relationship between two classes (student has courses) or (teacher studies courses), you chose composition.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;A simple way to make sense of this would be that inheritance should be used when you need an object of your class to have the same \u0026lt;em\u0026gt;interface\u0026lt;/em\u0026gt; as its parent class, so that it can thereby be treated as an object of the parent class (upcasting). Moreover, function calls on a derived class object would remain the same everywhere in code, but the specific method to call would be determined at runtime (i.e. the low-level \u0026lt;em\u0026gt;implementation\u0026lt;/em\u0026gt; differs, the high-level \u0026lt;em\u0026gt;interface\u0026lt;/em\u0026gt; remains the same).\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Composition should be used when you do not need the new class to have the same interface, i.e. you wish to conceal certain aspects of the class\u0026apos; implementation which the user of that class need not know about. So composition is more in the way of supporting \u0026lt;em\u0026gt;encapsulation\u0026lt;/em\u0026gt; (i.e. concealing the implementation) while inheritance is meant to support \u0026lt;em\u0026gt;abstraction\u0026lt;/em\u0026gt; (i.e. providing a simplified representation of something, in this case the \u0026lt;strong\u0026gt;same\u0026lt;/strong\u0026gt; interface for a range of types with different internals).\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Subtyping is appropriate and more powerful where the \u0026lt;a href=\u0026quot;https://stackoverflow.com/a/8352969\u0026quot;\u0026gt;invariants can be enumerated\u0026lt;/a\u0026gt;, else use function composition for extensibility.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;I agree with @Pavel, when he says, there are places for composition and there are places for inheritance.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;I think inheritance should be used if your answer is an affirmative to any of these questions.\u0026lt;/p\u0026gt;\n\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;Is your class part of a structure that benefits from polymorphism ? For example, if you had a Shape class, which declares a method called draw(), then we clearly need Circle and Square classes to be subclasses of Shape, so that their client classes would depend on Shape and not on specific subclasses.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Does your class need to re-use any high level interactions defined in another class ? The \u0026lt;a href=\u0026quot;http://en.wikipedia.org/wiki/Template_method_pattern\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;template method\u0026lt;/a\u0026gt; design pattern would be impossible to implement without inheritance. I believe all extensible frameworks use this pattern.\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\n\u0026lt;p\u0026gt;However, if your intention is purely that of code re-use, then composition most likely is a better design choice.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Inheritance is a very powerfull machanism for code reuse. But needs to be used properly. I would say that inheritance is used correctly if the subclass is also a subtype of the parent class. As mentioned above, the Liskov Substitution Principle is the key point here. \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Subclass is not the same as subtype. You might create subclasses that are not subtypes (and this is when you should use composition). To understand what a subtype is, lets start giving an explanation of what a type is.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;When we say that the number 5 is of type integer, we are stating that 5 belongs to a set of possible values (as an example, see the possible values for the Java primitive types). We are also stating that there is a valid set of methods I can perform on the value like addition and subtraction. And finally we are stating that there are a set of properties that are always satisfied, for example, if I add the values 3 and 5, I will get 8 as a result.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;To give another example, think about the abstract data types, Set of integers and List of integers, the values they can hold are restricted to integers. They both support a set of methods, like add(newValue) and size(). And they both have different properties (class invariant), Sets does not allow duplicates while List does allow duplicates (of course there are other properties that they both satisfy).\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Subtype is also a type, which has a relation to another type, called parent type (or supertype). The subtype must satisfy the features (values, methods and properties) of the parent type. The relation means that in any context where the supertype is expected, it can be substitutable by a subtype, without affecting the behaviour of the execution. Lets go to see some code to exemplify what Im saying. Suppose I write a List of integers (in some sort of pseudo language):\u0026lt;/p\u0026gt;\n\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;class List {\n  data = new Array();\n\n  Integer size() {\n    return data.length;\n  }\n\n  add(Integer anInteger) {\n    data[data.length] = anInteger;\n  }\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Then, I write the Set of integers as a subclass of the List of integers:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;class Set, inheriting from: List {\n  add(Integer anInteger) {\n     if (data.notContains(anInteger)) {\n       super.add(anInteger);\n     }\n  }\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Our Set of integers class is a subclass of List of Integers, but is not a subtype, due to it is not satisfying all the features of the List class. The values, and the signature of the methods are satisfied but the properties are not. The behaviour of the add(Integer) method has been clearly changed, not preserving the properties of the parent type. Think from the point of view of the client of your classes. They might receive a Set of integers where a List of integers is expected. The client might want to add a value and get that value added to the List even if that value already exist in the List. But her wont get that behaviour if the value exists. A big suprise for her!\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;This is a classic example of an improper use of inheritance. Use composition in this case.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;(a fragment from: \u0026lt;a href=\u0026quot;http://www.copypasteisforword.com/notes/use-inheritance-properly\u0026quot; rel=\u0026quot;nofollow\u0026quot;\u0026gt;use inheritance properly\u0026lt;/a\u0026gt;).\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Even though Composition is preferred, I would like to highlight pros of \u0026lt;em\u0026gt;Inheritance\u0026lt;/em\u0026gt; and cons of \u0026lt;em\u0026gt;Composition\u0026lt;/em\u0026gt;.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;\u0026lt;em\u0026gt;Pros of Inheritance:\u0026lt;/em\u0026gt;\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;ol\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;It establishes a logical \u0026quot;\u0026lt;strong\u0026gt;IS A\u0026quot;\u0026lt;/strong\u0026gt; relation. If \u0026lt;em\u0026gt;Car\u0026lt;/em\u0026gt; and \u0026lt;em\u0026gt;Truck\u0026lt;/em\u0026gt; are two types of \u0026lt;em\u0026gt;Vehicle\u0026lt;/em\u0026gt; ( base class), child class \u0026lt;strong\u0026gt;IS A\u0026lt;/strong\u0026gt; base class. \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;i.e. \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;em\u0026gt;Car is a Vehicle\u0026lt;/em\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;em\u0026gt;Truck is a Vehicle\u0026lt;/em\u0026gt;\u0026lt;/p\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;With inheritance, you can define/modify/extend a capability\u0026lt;/p\u0026gt;\n\n\u0026lt;ol\u0026gt;\n\u0026lt;li\u0026gt;Base class provides no implementation and sub-class has to override complete method (abstract) =\u0026amp;gt; \u0026lt;strong\u0026gt;\u0026lt;em\u0026gt;You can implement a contract\u0026lt;/em\u0026gt;\u0026lt;/strong\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Base class provides default implementation and sub-class can change the behaviour =\u0026amp;gt; \u0026lt;strong\u0026gt;\u0026lt;em\u0026gt;You can re-define contract\u0026lt;/em\u0026gt;\u0026lt;/strong\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Sub-class adds extension to base class implementation by calling super.methodName() as first statement =\u0026amp;gt; \u0026lt;strong\u0026gt;\u0026lt;em\u0026gt;You can extend a contract\u0026lt;/em\u0026gt;\u0026lt;/strong\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Base class defines structure of the algorithm  and sub-class will override a part of algorithm =\u0026amp;gt; \u0026lt;strong\u0026gt;\u0026lt;em\u0026gt;You can implement \u0026lt;a href=\u0026quot;https://en.wikipedia.org/wiki/Template_method_pattern\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;Template_method\u0026lt;/a\u0026gt; without change in base class skeleton\u0026lt;/em\u0026gt;\u0026lt;/strong\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;/ol\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;/ol\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;\u0026lt;em\u0026gt;Cons of Composition:\u0026lt;/em\u0026gt;\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;ol\u0026gt;\n\u0026lt;li\u0026gt;In inheritance, subclass can directly invoke base class method even though it\u0026apos;s not implementing base class method because of \u0026lt;strong\u0026gt;\u0026lt;em\u0026gt;IS A\u0026lt;/em\u0026gt;\u0026lt;/strong\u0026gt; relation. If you use composition, you have to add methods in container class to expose contained class API\u0026lt;/li\u0026gt;\n\u0026lt;/ol\u0026gt;\n\n\u0026lt;p\u0026gt;e.g. If  \u0026lt;em\u0026gt;Car\u0026lt;/em\u0026gt; contains \u0026lt;em\u0026gt;Vehicle\u0026lt;/em\u0026gt; and if you have to get price of the \u0026lt;em\u0026gt;Car\u0026lt;/em\u0026gt;, which has been defined in \u0026lt;em\u0026gt;Vehicle\u0026lt;/em\u0026gt;, your code will be like this\u0026lt;/p\u0026gt;\n\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;class Vehicle{\n     protected double getPrice(){\n          // return price\n     }\n} \n\nclass Car{\n     Vehicle vehicle;\n     protected double getPrice(){\n          return vehicle.getPrice();\n     }\n} \n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;A rule of thumb I have heard is inheritance should be used when its a \u0026quot;is-a\u0026quot; relationship and composition when its a \u0026quot;has-a\u0026quot;. Even with that I feel that you should always lean towards composition because it eliminates a lot of complexity.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Composition v/s Inheritance is a wide subject. There is no real answer for what is better as I think it all depends on the design of the system.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Generally type of relationship between object provide better information to choose one of them.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;If relation type is  \u0026quot;IS-A\u0026quot; relation then Inheritance is better approach.\notherwise relation type is  \u0026quot;HAS-A\u0026quot; relation then composition will better approach.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Its totally depend on entity relationship.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;I see no one mentioned the \u0026lt;a href=\u0026quot;http://en.wikipedia.org/wiki/Multiple_inheritance#The_diamond_problem\u0026quot; rel=\u0026quot;nofollow\u0026quot;\u0026gt;\u0026lt;strong\u0026gt;diamond problem\u0026lt;/strong\u0026gt;\u0026lt;/a\u0026gt;, which might arise with inheritance. \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;In a glance, if classes B and C inherit A and both override method X, and a fourth class D, inherits from both B and C, and does not override X, which implementation of X D is supposed to use?\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;a href=\u0026quot;http://en.wikipedia.org/wiki/Composition_over_inheritance\u0026quot; rel=\u0026quot;nofollow\u0026quot;\u0026gt;Wikipedia\u0026lt;/a\u0026gt; offers a nice overview of the topic being discussed in this question.\u0026lt;/p\u0026gt;\n    "],"id":249,"title":"Prefer composition over inheritance?","content":"\n                \n\u0026lt;p\u0026gt;Why prefer composition over inheritance?  What trade-offs are there for each approach?  When should you choose inheritance over composition?\u0026lt;/p\u0026gt;\n    ","slug":"prefer-composition-over-inheritance-1657387399409","postType":"QUESTION","createdAt":"2022-07-09T17:23:19.000Z","updatedAt":"2022-07-09T17:23:19.000Z","tags":[{"id":1621,"name":"composition","slug":"composition","createdAt":"2022-07-09T17:23:19.000Z","updatedAt":"2022-07-09T17:23:19.000Z","Questions_Tags":{"questionId":249,"tagId":1621}},{"id":1622,"name":"aggregation","slug":"aggregation","createdAt":"2022-07-09T17:23:19.000Z","updatedAt":"2022-07-09T17:23:19.000Z","Questions_Tags":{"questionId":249,"tagId":1622}}],"relatedQuestions":[{"title":"Prefer composition over inheritance?","slug":"prefer-composition-over-inheritance-1657387399409","tags":[{"name":"composition","Questions_Tags":{"questionId":249,"tagId":1621}},{"name":"aggregation","Questions_Tags":{"questionId":249,"tagId":1622}}]}]},"randomQuestions":[{"title":"MySQL pivot row into dynamic number of columns","slug":"mysql-pivot-row-into-dynamic-number-of-columns-1657387981930"},{"title":"Remove duplicate values from JS array [duplicate]","slug":"remove-duplicate-values-from-js-array-duplicate-1657387801931"},{"title":"What is array to pointer decay?","slug":"what-is-array-to-pointer-decay-1657384709608"},{"title":"What is the difference between == and equals() in Java?","slug":"what-is-the-difference-between-and-equals()-in-java-1657387729654"},{"title":"\"Cross origin requests are only supported for HTTP.\" error when loading a local file","slug":"\"cross-origin-requests-are-only-supported-for-http.\"-error-when-loading-a-local-file-1657387942403"},{"title":"How to create a MySQL hierarchical recursive query?","slug":"how-to-create-a-mysql-hierarchical-recursive-query-1657387662163"},{"title":"What is The Rule of Three?","slug":"what-is-the-rule-of-three-1657384390295"},{"title":"How to create a generic array in Java?","slug":"how-to-create-a-generic-array-in-java-1657387532298"},{"title":"What is the difference between a definition and a declaration?","slug":"what-is-the-difference-between-a-definition-and-a-declaration-1657387851618"},{"title":"What is the difference between public, protected, package-private and private in Java?","slug":"what-is-the-difference-between-public-protected-package-private-and-private-in-java-1657387376262"},{"title":"Importing installed package from script raises \"AttributeError: module has no attribute\" or \"ImportError: cannot import name\"","slug":"importing-installed-package-from-script-raises-\"attributeerror:-module-has-no-attribute\"-or-\"importerror:-cannot-import-name\"-1657387790607"},{"title":"How do I modify the URL without reloading the page?","slug":"how-do-i-modify-the-url-without-reloading-the-page-1657387509731"},{"title":"Sending Email in Android using JavaMail API without using the default/built-in app","slug":"sending-email-in-android-using-javamail-api-without-using-the-defaultbuilt-in-app-1657387883400"},{"title":"Where do I find the current C or C++ standard documents?","slug":"where-do-i-find-the-current-c-or-c++-standard-documents-1657388006897"},{"title":"How can I upload files to a server using JSP/Servlet?","slug":"how-can-i-upload-files-to-a-server-using-jspservlet-1657384847658"},{"title":"What are drawbacks or disadvantages of singleton pattern? [closed]","slug":"what-are-drawbacks-or-disadvantages-of-singleton-pattern-closed-1657387360749"},{"title":"What do 'lazy' and 'greedy' mean in the context of regular expressions?","slug":"what-do-'lazy'-and-'greedy'-mean-in-the-context-of-regular-expressions-1657388200552"},{"title":"Converting string into datetime","slug":"converting-string-into-datetime-1657387717295"},{"title":"How to remove all duplicates from an array of objects?","slug":"how-to-remove-all-duplicates-from-an-array-of-objects-1657388256190"},{"title":"How do I copy to the clipboard in JavaScript?","slug":"how-do-i-copy-to-the-clipboard-in-javascript-1657385501223"}]},"__N_SSG":true},"page":"/questions/[slug]","query":{"slug":"prefer-composition-over-inheritance-1657387399409"},"buildId":"eGqQHYKGZKE-nXShFn8wX","isFallback":false,"gsp":true,"locale":"en","locales":["en"],"defaultLocale":"en","scriptLoader":[]}</script></body></html>