{"pageProps":{"data":{"answer":["\n&lt;p&gt;Greedy will consume as much as possible. From &lt;a href=&quot;http://www.regular-expressions.info/repeat.html&quot; rel=&quot;noreferrer&quot;&gt;http://www.regular-expressions.info/repeat.html&lt;/a&gt; we see the example of trying to match HTML tags with &lt;code&gt;&amp;lt;.+&amp;gt;&lt;/code&gt;. Suppose you have the following:&lt;/p&gt;\n\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-css&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-selector-tag&quot;&gt;em&lt;/span&gt;&amp;gt;Hello World&amp;lt;/&lt;span class=&quot;hljs-selector-tag&quot;&gt;em&lt;/span&gt;&amp;gt;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;You may think that &lt;code&gt;&amp;lt;.+&amp;gt;&lt;/code&gt; (&lt;code&gt;.&lt;/code&gt; means &lt;em&gt;any non newline character&lt;/em&gt; and &lt;code&gt;+&lt;/code&gt; means &lt;em&gt;one or more&lt;/em&gt;) would only match the &lt;code&gt;&amp;lt;em&amp;gt;&lt;/code&gt; and the &lt;code&gt;&amp;lt;/em&amp;gt;&lt;/code&gt;, when in reality it will be very greedy, and go from the first &lt;code&gt;&amp;lt;&lt;/code&gt; to the last &lt;code&gt;&amp;gt;&lt;/code&gt;. This means it will match &lt;code&gt;&amp;lt;em&amp;gt;Hello World&amp;lt;/em&amp;gt;&lt;/code&gt; instead of what you wanted.&lt;/p&gt;\n\n&lt;p&gt;Making it lazy (&lt;code&gt;&amp;lt;.+?&amp;gt;&lt;/code&gt;) will prevent this. By adding the &lt;code&gt;?&lt;/code&gt; after the &lt;code&gt;+&lt;/code&gt;, we tell it to repeat &lt;em&gt;as few times as possible&lt;/em&gt;, so the first &lt;code&gt;&amp;gt;&lt;/code&gt; it comes across, is where we want to stop the matching.&lt;/p&gt;\n\n&lt;p&gt;I&apos;d encourage you to download &lt;a href=&quot;http://www.gskinner.com/RegExr/&quot; rel=&quot;noreferrer&quot;&gt;RegExr&lt;/a&gt;, a great tool that will help you explore Regular Expressions - I use it all the time.&lt;/p&gt;\n    ","\n&lt;p&gt;&lt;strong&gt;&apos;Greedy&apos;&lt;/strong&gt; means match longest possible string.&lt;/p&gt;\n\n&lt;p&gt;&lt;strong&gt;&apos;Lazy&apos;&lt;/strong&gt; means match shortest possible string.&lt;/p&gt;\n\n&lt;p&gt;For example, the greedy &lt;code&gt;h.+l&lt;/code&gt; matches &lt;code&gt;&apos;hell&apos;&lt;/code&gt; in &lt;code&gt;&apos;hello&apos;&lt;/code&gt; but the lazy &lt;code&gt;h.+?l&lt;/code&gt; matches &lt;code&gt;&apos;hel&apos;&lt;/code&gt;.&lt;/p&gt;\n    ","\n&lt;div class=&quot;s-table-container&quot;&gt;\n&lt;table class=&quot;s-table&quot;&gt;\n&lt;thead&gt;\n&lt;tr&gt;\n&lt;th&gt;Greedy quantifier&lt;/th&gt;\n&lt;th&gt;Lazy quantifier&lt;/th&gt;\n&lt;th&gt;Description&lt;/th&gt;\n&lt;/tr&gt;\n&lt;/thead&gt;\n&lt;tbody&gt;\n&lt;tr&gt;\n&lt;td&gt;&lt;code&gt;*&lt;/code&gt;&lt;/td&gt;\n&lt;td&gt;&lt;code&gt;*?&lt;/code&gt;&lt;/td&gt;\n&lt;td&gt;Star Quantifier: 0 or more&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;&lt;code&gt;+&lt;/code&gt;&lt;/td&gt;\n&lt;td&gt;&lt;code&gt;+?&lt;/code&gt;&lt;/td&gt;\n&lt;td&gt;Plus Quantifier: 1 or more&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;&lt;code&gt;?&lt;/code&gt;&lt;/td&gt;\n&lt;td&gt;&lt;code&gt;??&lt;/code&gt;&lt;/td&gt;\n&lt;td&gt;Optional Quantifier: 0 or 1&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;&lt;code&gt;{n}&lt;/code&gt;&lt;/td&gt;\n&lt;td&gt;&lt;code&gt;{n}?&lt;/code&gt;&lt;/td&gt;\n&lt;td&gt;Quantifier: exactly n&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;&lt;code&gt;{n,}&lt;/code&gt;&lt;/td&gt;\n&lt;td&gt;&lt;code&gt;{n,}?&lt;/code&gt;&lt;/td&gt;\n&lt;td&gt;Quantifier: n or more&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;&lt;code&gt;{n,m}&lt;/code&gt;&lt;/td&gt;\n&lt;td&gt;&lt;code&gt;{n,m}?&lt;/code&gt;&lt;/td&gt;\n&lt;td&gt;Quantifier: between n and m&lt;/td&gt;\n&lt;/tr&gt;\n&lt;/tbody&gt;\n&lt;/table&gt;\n&lt;/div&gt;\n&lt;blockquote&gt;\n&lt;p&gt;Add a ? to a quantifier to make it ungreedy i.e lazy.&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;p&gt;&lt;strong&gt;Example:&lt;/strong&gt;&lt;br&gt;\ntest string : &lt;em&gt;stackoverflow&lt;/em&gt;&lt;br&gt;\n&lt;em&gt;greedy reg expression&lt;/em&gt; : &lt;a href=&quot;http://regexr.com/3glo4&quot; rel=&quot;noreferrer&quot;&gt;&lt;code&gt;s.*o&lt;/code&gt;&lt;/a&gt; output: &lt;strong&gt;stackoverflo&lt;/strong&gt;w&lt;br&gt;\n&lt;em&gt;lazy reg expression&lt;/em&gt; : &lt;a href=&quot;http://regexr.com/3glo7&quot; rel=&quot;noreferrer&quot;&gt;&lt;code&gt;s.*?o&lt;/code&gt;&lt;/a&gt; output: &lt;strong&gt;stacko&lt;/strong&gt;verflow&lt;/p&gt;\n    ","\n&lt;p&gt;Greedy means your expression will match as large a group as possible, lazy means it will match the smallest group possible.  For this string:&lt;/p&gt;\n\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-undefined&quot;&gt;abcdefghijklmc\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;and this expression:&lt;/p&gt;\n\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-css&quot;&gt;&lt;span class=&quot;hljs-selector-tag&quot;&gt;a&lt;/span&gt;.*c\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;A greedy match will match the whole string, and a lazy match will match just the first &lt;code&gt;abc&lt;/code&gt;.&lt;/p&gt;\n    ","\n&lt;p&gt;As far as I know, most regex engine is greedy by default. Add a question mark at the end of quantifier will enable lazy match.&lt;/p&gt;\n&lt;p&gt;As @Andre S mentioned in comment.&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;Greedy: Keep searching until condition is not satisfied.&lt;/li&gt;\n&lt;li&gt;Lazy: Stop searching once condition is satisfied.&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;Refer to the example below for what is greedy and what is lazy.&lt;/p&gt;\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-java&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; java.util.regex.Matcher;\n&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; java.util.regex.Pattern;\n\n&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;Test&lt;/span&gt; {\n    &lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(String args[])&lt;/span&gt;{\n        &lt;span class=&quot;hljs-type&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;hljs-variable&quot;&gt;money&lt;/span&gt; &lt;span class=&quot;hljs-operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;100000000999&quot;&lt;/span&gt;;\n        &lt;span class=&quot;hljs-type&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;hljs-variable&quot;&gt;greedyRegex&lt;/span&gt; &lt;span class=&quot;hljs-operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;100(0*)&quot;&lt;/span&gt;;\n        &lt;span class=&quot;hljs-type&quot;&gt;Pattern&lt;/span&gt; &lt;span class=&quot;hljs-variable&quot;&gt;pattern&lt;/span&gt; &lt;span class=&quot;hljs-operator&quot;&gt;=&lt;/span&gt; Pattern.compile(greedyRegex);\n        &lt;span class=&quot;hljs-type&quot;&gt;Matcher&lt;/span&gt; &lt;span class=&quot;hljs-variable&quot;&gt;matcher&lt;/span&gt; &lt;span class=&quot;hljs-operator&quot;&gt;=&lt;/span&gt; pattern.matcher(money);\n        &lt;span class=&quot;hljs-keyword&quot;&gt;while&lt;/span&gt;(matcher.find()){\n            System.out.println(&lt;span class=&quot;hljs-string&quot;&gt;&quot;I&apos;m greedy and I want &quot;&lt;/span&gt; + matcher.group() + &lt;span class=&quot;hljs-string&quot;&gt;&quot; dollars. This is the most I can get.&quot;&lt;/span&gt;);\n        }\n        \n        &lt;span class=&quot;hljs-type&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;hljs-variable&quot;&gt;lazyRegex&lt;/span&gt; &lt;span class=&quot;hljs-operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;100(0*?)&quot;&lt;/span&gt;;\n        pattern = Pattern.compile(lazyRegex);\n        matcher = pattern.matcher(money);\n        &lt;span class=&quot;hljs-keyword&quot;&gt;while&lt;/span&gt;(matcher.find()){\n            System.out.println(&lt;span class=&quot;hljs-string&quot;&gt;&quot;I&apos;m too lazy to get so much money, only &quot;&lt;/span&gt; + matcher.group() + &lt;span class=&quot;hljs-string&quot;&gt;&quot; dollars is enough for me&quot;&lt;/span&gt;);\n        }\n    }\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;hr&gt;\nThe result is:\n```\nI&apos;m greedy and I want 100000000 dollars. This is the most I can get.\n&lt;p&gt;I&apos;m too lazy to get so much money, only 100 dollars is enough for me&lt;/p&gt;\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-undefined&quot;&gt;\n\n&lt;/code&gt;&lt;/pre&gt;\n    ","\n&lt;p&gt;Taken From &lt;a href=&quot;http://www.regular-expressions.info/possessive.html&quot; rel=&quot;noreferrer&quot;&gt;www.regular-expressions.info&lt;/a&gt;&lt;/p&gt;\n\n&lt;p&gt;&lt;strong&gt;Greediness&lt;/strong&gt;: Greedy quantifiers first tries to repeat the token as many times\nas possible, and gradually gives up matches as the engine backtracks to find \nan overall match.&lt;/p&gt;\n\n&lt;p&gt;&lt;strong&gt;Laziness&lt;/strong&gt;: Lazy quantifier first repeats the token as few times as required, and\ngradually expands the match as the engine backtracks through the regex to\nfind an overall match.&lt;/p&gt;\n    ","\n&lt;p&gt;From &lt;a href=&quot;http://en.wikipedia.org/wiki/Regular_expression&quot; rel=&quot;noreferrer&quot;&gt;Regular expression&lt;/a&gt;&lt;/p&gt;\n\n&lt;blockquote&gt;\n  &lt;p&gt;The standard quantifiers in regular\n  expressions are greedy, meaning they\n  match as much as they can, only giving\n  back as necessary to match the\n  remainder of the regex. &lt;/p&gt;\n  \n  &lt;p&gt;By using a lazy quantifier, the\n  expression tries the minimal match\n  first.&lt;/p&gt;\n&lt;/blockquote&gt;\n    ","\n&lt;h2&gt;Greedy Quantifiers are like the IRS&lt;/h2&gt;\n&lt;p&gt;Theyll take as much as they can. e.g. matches with this regex: &lt;code&gt;.*&lt;/code&gt;&lt;/p&gt;\n&lt;p&gt;&lt;code&gt;$50,000&lt;/code&gt;&lt;/p&gt;\n&lt;p&gt;Bye-bye bank balance.&lt;/p&gt;\n&lt;p&gt;See here for an example: &lt;a href=&quot;https://regexr.com/4t27f&quot; rel=&quot;nofollow noreferrer&quot;&gt;Greedy-example&lt;/a&gt;&lt;/p&gt;\n&lt;h2&gt;Non-greedy quantifiers - they take as little as they can&lt;/h2&gt;\n&lt;p&gt;Ask for a tax refund: the IRS sudden becomes non-greedy - and return as little as possible: i.e. they use this quantifier:&lt;/p&gt;\n&lt;p&gt;&lt;code&gt;(.{2,5}?)([0-9]*)&lt;/code&gt; against this input: &lt;code&gt;$50,000&lt;/code&gt;&lt;/p&gt;\n&lt;p&gt;The first group is non-needy and only matches &lt;code&gt;$5&lt;/code&gt;  so I get a &lt;code&gt;$5&lt;/code&gt; refund against the $50,000 input.&lt;/p&gt;\n&lt;p&gt;See here: &lt;a href=&quot;https://regexr.com/59qrk&quot; rel=&quot;nofollow noreferrer&quot;&gt;Non-greedy-example&lt;/a&gt;.&lt;/p&gt;\n&lt;h2&gt;Why do we need greedy vs non-greedy?&lt;/h2&gt;\n&lt;p&gt;It becomes important if you are trying to match certain parts of an expression. Sometimes you don&apos;t want to match everything - as little as possible. Sometimes you want to match as much as possible. Nothing more to it.&lt;/p&gt;\n&lt;p&gt;You can play around with the examples in the links posted above.&lt;/p&gt;\n&lt;p&gt;(Analogy used to help you remember).&lt;/p&gt;\n    ","\n&lt;p&gt;Best shown by example. String. &lt;code&gt;192.168.1.1&lt;/code&gt; and a greedy regex &lt;code&gt;\\b.+\\b&lt;/code&gt;\nYou might think this would give you the 1st octet but is actually matches against the whole string. Why? Because the.+ is greedy and a greedy match matches every character in &lt;code&gt;192.168.1.1&lt;/code&gt; until it reaches the end of the string. This is the important bit! Now it starts to backtrack one character at a time until it finds a match for the 3rd token (&lt;code&gt;\\b&lt;/code&gt;).&lt;/p&gt;\n\n&lt;p&gt;If the string a 4GB text file and 192.168.1.1 was at the start you could easily see how this backtracking would cause an issue.&lt;/p&gt;\n\n&lt;p&gt;To make a regex non greedy (lazy) put a question mark after your greedy search e.g&lt;/p&gt;\n\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-ruby&quot;&gt;*?\n&lt;span class=&quot;hljs-string&quot;&gt;??&lt;/span&gt;\n+?\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;What happens now is token 2 (&lt;code&gt;+?&lt;/code&gt;) finds a match, regex moves along a character and then tries the next token (&lt;code&gt;\\b&lt;/code&gt;) rather than token 2 (&lt;code&gt;+?&lt;/code&gt;). So it creeps along gingerly.&lt;/p&gt;\n    ","\n&lt;p&gt;&lt;strong&gt;Greedy matching.&lt;/strong&gt; The default behavior of regular expressions is to be greedy. That means it tries to extract as much as possible until it conforms to a pattern even when a smaller part would have been syntactically sufficient.&lt;/p&gt;\n\n&lt;p&gt;&lt;strong&gt;Example:&lt;/strong&gt;&lt;/p&gt;\n\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-coffeescript&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; re\ntext = &lt;span class=&quot;hljs-string&quot;&gt;&quot;&amp;lt;body&amp;gt;Regex Greedy Matching Example &amp;lt;/body&amp;gt;&quot;&lt;/span&gt;\nre.findall(&lt;span class=&quot;hljs-string&quot;&gt;&apos;&amp;lt;.*&amp;gt;&apos;&lt;/span&gt;, text)\n&lt;span class=&quot;hljs-comment&quot;&gt;#&amp;gt; [&apos;&amp;lt;body&amp;gt;Regex Greedy Matching Example &amp;lt;/body&amp;gt;&apos;]&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Instead of matching till the first occurrence of &amp;gt;, it extracted the whole string. This is the default greedy or take it all behavior of regex.&lt;/p&gt;\n\n&lt;p&gt;&lt;strong&gt;Lazy matching&lt;/strong&gt;, on the other hand, takes as little as possible. This can be effected by adding a &lt;code&gt;?&lt;/code&gt; at the end of the pattern.&lt;/p&gt;\n\n&lt;p&gt;&lt;strong&gt;Example:&lt;/strong&gt;&lt;/p&gt;\n\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-less&quot;&gt;&lt;span class=&quot;hljs-selector-tag&quot;&gt;re&lt;/span&gt;&lt;span class=&quot;hljs-selector-class&quot;&gt;.findall&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&apos;&amp;lt;.*?&amp;gt;&apos;&lt;/span&gt;, text)\n#&amp;gt; &lt;span class=&quot;hljs-selector-attr&quot;&gt;[&lt;span class=&quot;hljs-string&quot;&gt;&apos;&amp;lt;body&amp;gt;&apos;&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&apos;&amp;lt;/body&amp;gt;&apos;&lt;/span&gt;]&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;If you want only the first match to be retrieved, use the search method instead.&lt;/p&gt;\n\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-csharp&quot;&gt;re.search(&lt;span class=&quot;hljs-string&quot;&gt;&apos;&amp;lt;.*?&amp;gt;&apos;&lt;/span&gt;, text).&lt;span class=&quot;hljs-keyword&quot;&gt;group&lt;/span&gt;()\n&lt;span class=&quot;hljs-meta&quot;&gt;#&amp;gt; &apos;&amp;lt;body&amp;gt;&apos;&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Source: &lt;a href=&quot;https://www.machinelearningplus.com/python-regex-tutorial-examples/#greedy_matching_in_regex&quot; rel=&quot;nofollow noreferrer&quot;&gt;Python Regex Examples&lt;/a&gt;&lt;/p&gt;\n    ","\n&lt;p&gt;Greedy means it will consume your pattern until there are none of them left and it can look no further.&lt;/p&gt;\n\n&lt;p&gt;Lazy will stop as soon as it will encounter the first pattern you requested.&lt;/p&gt;\n\n&lt;p&gt;One common example that I often encounter is &lt;code&gt;\\s*-\\s*?&lt;/code&gt; of a regex &lt;code&gt;([0-9]{2}\\s*-\\s*?[0-9]{7})&lt;/code&gt;&lt;/p&gt;\n\n&lt;p&gt;The first &lt;code&gt;\\s*&lt;/code&gt; is classified as greedy because of &lt;code&gt;*&lt;/code&gt; and will look as many white spaces as possible after the digits are encountered and then look for a dash character &quot;-&quot;. Where as the second &lt;code&gt;\\s*?&lt;/code&gt; is lazy because of the present of &lt;code&gt;*?&lt;/code&gt; which means that it will look the first white space character and stop right there.&lt;/p&gt;\n    ","\n&lt;p&gt;try to understand the following behavior:&lt;/p&gt;\n\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-dart&quot;&gt;    &lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; input = &lt;span class=&quot;hljs-string&quot;&gt;&quot;0014.2&quot;&lt;/span&gt;;\n\nRegex r1 = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; Regex(&lt;span class=&quot;hljs-string&quot;&gt;&quot;\\\\d+.{0,1}\\\\d+&quot;&lt;/span&gt;);\nRegex r2 = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; Regex(&lt;span class=&quot;hljs-string&quot;&gt;&quot;\\\\d*.{0,1}\\\\d*&quot;&lt;/span&gt;);\n\nConsole.WriteLine(r1.&lt;span class=&quot;hljs-built_in&quot;&gt;Match&lt;/span&gt;(input).Value); &lt;span class=&quot;hljs-comment&quot;&gt;// &quot;0014.2&quot;&lt;/span&gt;\nConsole.WriteLine(r2.&lt;span class=&quot;hljs-built_in&quot;&gt;Match&lt;/span&gt;(input).Value); &lt;span class=&quot;hljs-comment&quot;&gt;// &quot;0014.2&quot;&lt;/span&gt;\n\ninput = &lt;span class=&quot;hljs-string&quot;&gt;&quot; 0014.2&quot;&lt;/span&gt;;\n\nConsole.WriteLine(r1.&lt;span class=&quot;hljs-built_in&quot;&gt;Match&lt;/span&gt;(input).Value); &lt;span class=&quot;hljs-comment&quot;&gt;// &quot;0014.2&quot;&lt;/span&gt;\nConsole.WriteLine(r2.&lt;span class=&quot;hljs-built_in&quot;&gt;Match&lt;/span&gt;(input).Value); &lt;span class=&quot;hljs-comment&quot;&gt;// &quot; 0014&quot;&lt;/span&gt;\n\ninput = &lt;span class=&quot;hljs-string&quot;&gt;&quot;  0014.2&quot;&lt;/span&gt;;\n\nConsole.WriteLine(r1.&lt;span class=&quot;hljs-built_in&quot;&gt;Match&lt;/span&gt;(input).Value); &lt;span class=&quot;hljs-comment&quot;&gt;// &quot;0014.2&quot;&lt;/span&gt;\nConsole.WriteLine(r2.&lt;span class=&quot;hljs-built_in&quot;&gt;Match&lt;/span&gt;(input).Value); &lt;span class=&quot;hljs-comment&quot;&gt;// &quot;&quot;&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n    "],"id":500,"title":"What do 'lazy' and 'greedy' mean in the context of regular expressions?","content":"\n                \n&lt;p&gt;What are these two terms in an understandable way?&lt;/p&gt;\n    ","slug":"what-do-'lazy'-and-'greedy'-mean-in-the-context-of-regular-expressions-1657388200552","postType":"QUESTION","createdAt":"2022-07-09T17:36:40.000Z","updatedAt":"2022-07-09T17:36:40.000Z","tags":[{"id":2495,"name":"regex-greedy","slug":"regex-greedy","createdAt":"2022-07-09T17:36:40.000Z","updatedAt":"2022-07-09T17:36:40.000Z","Questions_Tags":{"questionId":500,"tagId":2495}},{"id":2497,"name":"non-greedy","slug":"non-greedy","createdAt":"2022-07-09T17:36:40.000Z","updatedAt":"2022-07-09T17:36:40.000Z","Questions_Tags":{"questionId":500,"tagId":2497}}],"relatedQuestions":[{"title":"What do 'lazy' and 'greedy' mean in the context of regular expressions?","slug":"what-do-'lazy'-and-'greedy'-mean-in-the-context-of-regular-expressions-1657388200552","tags":[{"name":"regex-greedy","Questions_Tags":{"questionId":500,"tagId":2495}},{"name":"non-greedy","Questions_Tags":{"questionId":500,"tagId":2497}}]}]},"randomQuestions":[{"title":"Can I mix MySQL APIs in PHP?","slug":"can-i-mix-mysql-apis-in-php-1657384597444"},{"title":"Captured variable in a loop in C#","slug":"captured-variable-in-a-loop-in-c-1657387696779"},{"title":"Cross-thread operation not valid: Control accessed from a thread other than the thread it was created on","slug":"cross-thread-operation-not-valid:-control-accessed-from-a-thread-other-than-the-thread-it-was-created-on-1657387659019"},{"title":"Google Maps JS API v3 - Simple Multiple Marker Example","slug":"google-maps-js-api-v3-simple-multiple-marker-example-1657388073335"},{"title":"PHP code is not being executed, but the code shows in the browser source code","slug":"php-code-is-not-being-executed-but-the-code-shows-in-the-browser-source-code-1657384553581"},{"title":"Using fflush(stdin)","slug":"using-fflush(stdin)-1657387602771"},{"title":"Why is “while( !feof(file) )” always wrong?","slug":"why-is-\"while(-!feof(file)-)\"-always-wrong-1657384367349"},{"title":"R cannot be resolved - Android error","slug":"r-cannot-be-resolved-android-error-1657388526258"},{"title":"How do you convert a byte array to a hexadecimal string, and vice versa?","slug":"how-do-you-convert-a-byte-array-to-a-hexadecimal-string-and-vice-versa-1657388010428"},{"title":"What is a smart pointer and when should I use one?","slug":"what-is-a-smart-pointer-and-when-should-i-use-one-1657387905461"},{"title":"Self-references in object literals / initializers","slug":"self-references-in-object-literals-initializers-1657384835356"},{"title":"How to find the 'sizeof' (a pointer pointing to an array)?","slug":"how-to-find-the-'sizeof'-(a-pointer-pointing-to-an-array)-1657387354284"},{"title":"How to iterate over rows in a DataFrame in Pandas","slug":"how-to-iterate-over-rows-in-a-dataframe-in-pandas-1657387358115"},{"title":"How to filter Pandas dataframe using 'in' and 'not in' like in SQL","slug":"how-to-filter-pandas-dataframe-using-'in'-and-'not-in'-like-in-sql-1657387371355"},{"title":"How do I access previous promise results in a .then() chain?","slug":"how-do-i-access-previous-promise-results-in-a-.then()-chain-1657387705386"},{"title":"Is JavaScript a pass-by-reference or pass-by-value language?","slug":"is-javascript-a-pass-by-reference-or-pass-by-value-language-1657384675679"},{"title":"Example images for code and mark-up Q&As [closed]","slug":"example-images-for-code-and-mark-up-qandas-closed-1657387690222"},{"title":"Can a local variable's memory be accessed outside its scope?","slug":"can-a-local-variable's-memory-be-accessed-outside-its-scope-1657384460386"},{"title":"input() error - NameError: name '...' is not defined","slug":"input()-error-nameerror:-name-'...'-is-not-defined-1657388497243"},{"title":"How do I use shell variables in an awk script?","slug":"how-do-i-use-shell-variables-in-an-awk-script-1657387754261"}]},"__N_SSG":true}