{"pageProps":{"data":{"answer":["\n&lt;p&gt;The short answer is &lt;strong&gt;yes, yes there is a way to get around &lt;code&gt;mysql_real_escape_string()&lt;/code&gt;&lt;/strong&gt;.\n#For Very OBSCURE EDGE CASES!!!&lt;/p&gt;\n&lt;p&gt;The long answer isn&apos;t so easy. It&apos;s based off an attack &lt;a href=&quot;http://shiflett.org/blog/2006/jan/addslashes-versus-mysql-real-escape-string&quot; rel=&quot;noreferrer&quot;&gt;demonstrated here&lt;/a&gt;.&lt;/p&gt;\n&lt;h1&gt;The Attack&lt;/h1&gt;\n&lt;p&gt;So, let&apos;s start off by showing the attack...&lt;/p&gt;\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-bash&quot;&gt;mysql_query(&lt;span class=&quot;hljs-string&quot;&gt;&apos;SET NAMES gbk&apos;&lt;/span&gt;);\n&lt;span class=&quot;hljs-variable&quot;&gt;$var&lt;/span&gt; = mysql_real_escape_string(&lt;span class=&quot;hljs-string&quot;&gt;&quot;\\xbf\\x27 OR 1=1 /*&quot;&lt;/span&gt;);\nmysql_query(&lt;span class=&quot;hljs-string&quot;&gt;&quot;SELECT * FROM test WHERE name = &apos;&lt;span class=&quot;hljs-variable&quot;&gt;$var&lt;/span&gt;&apos; LIMIT 1&quot;&lt;/span&gt;);\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;In certain circumstances, that will return more than 1 row. Let&apos;s dissect what&apos;s going on here:&lt;/p&gt;\n&lt;ol&gt;\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;Selecting a Character Set&lt;/strong&gt;&lt;/p&gt;\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-scss&quot;&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;mysql_query&lt;/span&gt;(&apos;SET NAMES gbk&apos;);\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;For this attack to work, we need the encoding that the server&apos;s expecting on the connection both to encode &lt;code&gt;&apos;&lt;/code&gt; as in ASCII i.e. &lt;code&gt;0x27&lt;/code&gt; &lt;em&gt;and&lt;/em&gt; to have some character whose final byte is an ASCII &lt;code&gt;\\&lt;/code&gt; i.e. &lt;code&gt;0x5c&lt;/code&gt;.  As it turns out, there are 5 such encodings supported in MySQL 5.6 by default: &lt;code&gt;big5&lt;/code&gt;, &lt;code&gt;cp932&lt;/code&gt;, &lt;code&gt;gb2312&lt;/code&gt;, &lt;code&gt;gbk&lt;/code&gt; and &lt;code&gt;sjis&lt;/code&gt;.  We&apos;ll select &lt;code&gt;gbk&lt;/code&gt; here.&lt;/p&gt;\n&lt;p&gt;Now, it&apos;s very important to note the use of &lt;code&gt;SET NAMES&lt;/code&gt; here. This sets the character set &lt;strong&gt;ON THE SERVER&lt;/strong&gt;. If we used the call to the C API function &lt;code&gt;mysql_set_charset()&lt;/code&gt;, we&apos;d be fine (on MySQL releases since 2006). But more on why in a minute...&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;The Payload&lt;/strong&gt;&lt;/p&gt;\n&lt;p&gt;The payload we&apos;re going to use for this injection starts with the byte sequence &lt;code&gt;0xbf27&lt;/code&gt;.  In &lt;code&gt;gbk&lt;/code&gt;, that&apos;s an invalid multibyte character; in &lt;code&gt;latin1&lt;/code&gt;, it&apos;s the string &lt;code&gt;Â¿&apos;&lt;/code&gt;.  Note that in &lt;code&gt;latin1&lt;/code&gt; &lt;strong&gt;and&lt;/strong&gt; &lt;code&gt;gbk&lt;/code&gt;, &lt;code&gt;0x27&lt;/code&gt; on its own is a literal &lt;code&gt;&apos;&lt;/code&gt; character.&lt;/p&gt;\n&lt;p&gt;We have chosen this payload because, if we called &lt;code&gt;addslashes()&lt;/code&gt; on it, we&apos;d insert an ASCII &lt;code&gt;\\&lt;/code&gt; i.e. &lt;code&gt;0x5c&lt;/code&gt;, before the &lt;code&gt;&apos;&lt;/code&gt; character. So we&apos;d wind up with &lt;code&gt;0xbf5c27&lt;/code&gt;, which in &lt;code&gt;gbk&lt;/code&gt; is a two character sequence: &lt;code&gt;0xbf5c&lt;/code&gt; followed by &lt;code&gt;0x27&lt;/code&gt;. Or in other words, a &lt;em&gt;valid&lt;/em&gt; character followed by an unescaped &lt;code&gt;&apos;&lt;/code&gt;. But we&apos;re not using &lt;code&gt;addslashes()&lt;/code&gt;. So on to the next step...&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;mysql_real_escape_string()&lt;/strong&gt;&lt;/p&gt;\n&lt;p&gt;The C API call to &lt;code&gt;mysql_real_escape_string()&lt;/code&gt; differs from &lt;code&gt;addslashes()&lt;/code&gt; in that it knows the connection character set. So it can perform the escaping properly for the character set that the server is expecting. However, up to this point, the client thinks that we&apos;re still using &lt;code&gt;latin1&lt;/code&gt; for the connection, because we never told it otherwise. We did tell the &lt;em&gt;server&lt;/em&gt; we&apos;re using &lt;code&gt;gbk&lt;/code&gt;, but the &lt;em&gt;client&lt;/em&gt; still thinks it&apos;s &lt;code&gt;latin1&lt;/code&gt;.&lt;/p&gt;\n&lt;p&gt;Therefore the call to &lt;code&gt;mysql_real_escape_string()&lt;/code&gt; inserts the backslash, and we have a free hanging &lt;code&gt;&apos;&lt;/code&gt; character in our &quot;escaped&quot; content! In fact, if we were to look at &lt;code&gt;$var&lt;/code&gt; in the &lt;code&gt;gbk&lt;/code&gt; character set, we&apos;d see:&lt;/p&gt;\n&lt;pre&gt;&apos; OR 1=1 /*&lt;/pre&gt;\n&lt;p&gt;Which is &lt;a href=&quot;https://www.google.com/search?q=%E7%B8%97%27%20OR&amp;amp;oq=%E7%B8%97%27%20OR&amp;amp;aqs=chrome..69i57&amp;amp;sourceid=chrome&amp;amp;es_sm=122&amp;amp;ie=UTF-8&quot; rel=&quot;noreferrer&quot;&gt;exactly what&lt;/a&gt; the attack requires.&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;The Query&lt;/strong&gt;&lt;/p&gt;\n&lt;p&gt;This part is just a formality, but here&apos;s the rendered query:&lt;/p&gt;\n&lt;pre class=&quot;lang-sql s-code-block&quot;&gt;&lt;code class=&quot;hljs language-sql&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;SELECT&lt;/span&gt; &lt;span class=&quot;hljs-operator&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;FROM&lt;/span&gt; test &lt;span class=&quot;hljs-keyword&quot;&gt;WHERE&lt;/span&gt; name &lt;span class=&quot;hljs-operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&apos;&apos;&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;OR&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;hljs-operator&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;hljs-comment&quot;&gt;/*&apos; LIMIT 1\n&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;\n&lt;/li&gt;\n&lt;/ol&gt;\n&lt;p&gt;Congratulations, you just successfully attacked a program using &lt;code&gt;mysql_real_escape_string()&lt;/code&gt;...&lt;/p&gt;\n&lt;h1&gt;The Bad&lt;/h1&gt;\n&lt;p&gt;It gets worse. &lt;code&gt;PDO&lt;/code&gt; defaults to &lt;em&gt;emulating&lt;/em&gt; prepared statements with MySQL. That means that on the client side, it basically does a sprintf through &lt;code&gt;mysql_real_escape_string()&lt;/code&gt; (in the C library), which means the following will result in a successful injection:&lt;/p&gt;\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-php&quot;&gt;&lt;span class=&quot;hljs-variable&quot;&gt;$pdo&lt;/span&gt;-&amp;gt;&lt;span class=&quot;hljs-title function_ invoke__&quot;&gt;query&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&apos;SET NAMES gbk&apos;&lt;/span&gt;);\n&lt;span class=&quot;hljs-variable&quot;&gt;$stmt&lt;/span&gt; = &lt;span class=&quot;hljs-variable&quot;&gt;$pdo&lt;/span&gt;-&amp;gt;&lt;span class=&quot;hljs-title function_ invoke__&quot;&gt;prepare&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&apos;SELECT * FROM test WHERE name = ? LIMIT 1&apos;&lt;/span&gt;);\n&lt;span class=&quot;hljs-variable&quot;&gt;$stmt&lt;/span&gt;-&amp;gt;&lt;span class=&quot;hljs-title function_ invoke__&quot;&gt;execute&lt;/span&gt;(&lt;span class=&quot;hljs-keyword&quot;&gt;array&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;\\xbf\\x27 OR 1=1 /*&quot;&lt;/span&gt;));\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;Now, it&apos;s worth noting that you can prevent this by disabling emulated prepared statements:&lt;/p&gt;\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-php&quot;&gt;&lt;span class=&quot;hljs-variable&quot;&gt;$pdo&lt;/span&gt;-&amp;gt;&lt;span class=&quot;hljs-title function_ invoke__&quot;&gt;setAttribute&lt;/span&gt;(PDO::&lt;span class=&quot;hljs-variable constant_&quot;&gt;ATTR_EMULATE_PREPARES&lt;/span&gt;, &lt;span class=&quot;hljs-literal&quot;&gt;false&lt;/span&gt;);\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;This will &lt;em&gt;usually&lt;/em&gt; result in a true prepared statement (i.e. the data being sent over in a separate packet from the query). However, be aware that PDO will silently &lt;a href=&quot;https://github.com/php/php-src/blob/master/ext/pdo_mysql/mysql_driver.c#L210&quot; rel=&quot;noreferrer&quot;&gt;fallback&lt;/a&gt; to emulating statements that MySQL can&apos;t prepare natively: those that it can are &lt;a href=&quot;https://dev.mysql.com/doc/en/sql-prepared-statements.html#prepared-statements-permitted&quot; rel=&quot;noreferrer&quot;&gt;listed&lt;/a&gt; in the manual, but beware to select the appropriate server version).&lt;/p&gt;\n&lt;h1&gt;The Ugly&lt;/h1&gt;\n&lt;p&gt;I said at the very beginning that we could have prevented all of this if we had used &lt;code&gt;mysql_set_charset(&apos;gbk&apos;)&lt;/code&gt; instead of &lt;code&gt;SET NAMES gbk&lt;/code&gt;. And that&apos;s true provided you are using a MySQL release since 2006.&lt;/p&gt;\n&lt;p&gt;If you&apos;re using an earlier MySQL release, then a &lt;a href=&quot;http://bugs.mysql.com/bug.php?id=8378&quot; rel=&quot;noreferrer&quot;&gt;bug&lt;/a&gt; in &lt;code&gt;mysql_real_escape_string()&lt;/code&gt; meant that invalid multibyte characters such as those in our payload were treated as single bytes for escaping purposes &lt;em&gt;even if the client had been correctly informed of the connection encoding&lt;/em&gt; and so this attack would still succeed.  The bug was fixed in MySQL &lt;a href=&quot;http://dev.mysql.com/doc/refman/4.1/en/news-4-1-20.html&quot; rel=&quot;noreferrer&quot;&gt;4.1.20&lt;/a&gt;, &lt;a href=&quot;http://dev.mysql.com/doc/relnotes/mysql/5.0/en/news-5-0-22.html&quot; rel=&quot;noreferrer&quot;&gt;5.0.22&lt;/a&gt; and &lt;a href=&quot;http://dev.mysql.com/doc/relnotes/mysql/5.1/en/news-5-1-11.html&quot; rel=&quot;noreferrer&quot;&gt;5.1.11&lt;/a&gt;.&lt;/p&gt;\n&lt;p&gt;But the worst part is that &lt;code&gt;PDO&lt;/code&gt; didn&apos;t expose the C API for &lt;code&gt;mysql_set_charset()&lt;/code&gt; until 5.3.6, so in prior versions it &lt;strong&gt;cannot&lt;/strong&gt; prevent this attack for every possible command!\nIt&apos;s now exposed as a &lt;a href=&quot;http://www.php.net/manual/en/ref.pdo-mysql.connection.php&quot; rel=&quot;noreferrer&quot;&gt;DSN parameter&lt;/a&gt;.&lt;/p&gt;\n&lt;h1&gt;The Saving Grace&lt;/h1&gt;\n&lt;p&gt;As we said at the outset, for this attack to work the database connection must be encoded using a vulnerable character set.  &lt;a href=&quot;http://dev.mysql.com/doc/en/charset-unicode-utf8mb4.html&quot; rel=&quot;noreferrer&quot;&gt;&lt;code&gt;utf8mb4&lt;/code&gt;&lt;/a&gt; is &lt;em&gt;not vulnerable&lt;/em&gt; and yet can support &lt;em&gt;every&lt;/em&gt; Unicode character: so you could elect to use that insteadbut it has only been available since MySQL 5.5.3.  An alternative is &lt;a href=&quot;http://dev.mysql.com/doc/en/charset-unicode-utf8.html&quot; rel=&quot;noreferrer&quot;&gt;&lt;code&gt;utf8&lt;/code&gt;&lt;/a&gt;, which is also &lt;em&gt;not vulnerable&lt;/em&gt; and can support the whole of the Unicode &lt;a href=&quot;http://en.wikipedia.org/wiki/Plane_(Unicode)#Basic_Multilingual_Plane&quot; rel=&quot;noreferrer&quot;&gt;Basic Multilingual Plane&lt;/a&gt;.&lt;/p&gt;\n&lt;p&gt;Alternatively, you can enable the &lt;a href=&quot;http://dev.mysql.com/doc/en/sql-mode.html#sqlmode_no_backslash_escapes&quot; rel=&quot;noreferrer&quot;&gt;&lt;code&gt;NO_BACKSLASH_ESCAPES&lt;/code&gt;&lt;/a&gt; SQL mode, which (amongst other things) alters the operation of &lt;code&gt;mysql_real_escape_string()&lt;/code&gt;.  With this mode enabled, &lt;code&gt;0x27&lt;/code&gt; will be replaced with &lt;code&gt;0x2727&lt;/code&gt; rather than &lt;code&gt;0x5c27&lt;/code&gt; and thus the escaping process &lt;em&gt;cannot&lt;/em&gt; create valid characters in any of the vulnerable encodings where they did not exist previously (i.e. &lt;code&gt;0xbf27&lt;/code&gt; is still &lt;code&gt;0xbf27&lt;/code&gt; etc.)so the server will still reject the string as invalid.  However, see &lt;a href=&quot;https://stackoverflow.com/a/23277864/623041&quot;&gt;@eggyal&apos;s answer&lt;/a&gt; for a different vulnerability that can arise from using this SQL mode.&lt;/p&gt;\n&lt;h1&gt;Safe Examples&lt;/h1&gt;\n&lt;p&gt;The following examples are safe:&lt;/p&gt;\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-bash&quot;&gt;mysql_query(&lt;span class=&quot;hljs-string&quot;&gt;&apos;SET NAMES utf8&apos;&lt;/span&gt;);\n&lt;span class=&quot;hljs-variable&quot;&gt;$var&lt;/span&gt; = mysql_real_escape_string(&lt;span class=&quot;hljs-string&quot;&gt;&quot;\\xbf\\x27 OR 1=1 /*&quot;&lt;/span&gt;);\nmysql_query(&lt;span class=&quot;hljs-string&quot;&gt;&quot;SELECT * FROM test WHERE name = &apos;&lt;span class=&quot;hljs-variable&quot;&gt;$var&lt;/span&gt;&apos; LIMIT 1&quot;&lt;/span&gt;);\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;Because the server&apos;s expecting &lt;code&gt;utf8&lt;/code&gt;...&lt;/p&gt;\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-bash&quot;&gt;mysql_set_charset(&lt;span class=&quot;hljs-string&quot;&gt;&apos;gbk&apos;&lt;/span&gt;);\n&lt;span class=&quot;hljs-variable&quot;&gt;$var&lt;/span&gt; = mysql_real_escape_string(&lt;span class=&quot;hljs-string&quot;&gt;&quot;\\xbf\\x27 OR 1=1 /*&quot;&lt;/span&gt;);\nmysql_query(&lt;span class=&quot;hljs-string&quot;&gt;&quot;SELECT * FROM test WHERE name = &apos;&lt;span class=&quot;hljs-variable&quot;&gt;$var&lt;/span&gt;&apos; LIMIT 1&quot;&lt;/span&gt;);\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;Because we&apos;ve properly set the character set so the client and the server match.&lt;/p&gt;\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-php&quot;&gt;&lt;span class=&quot;hljs-variable&quot;&gt;$pdo&lt;/span&gt;-&amp;gt;&lt;span class=&quot;hljs-title function_ invoke__&quot;&gt;setAttribute&lt;/span&gt;(PDO::&lt;span class=&quot;hljs-variable constant_&quot;&gt;ATTR_EMULATE_PREPARES&lt;/span&gt;, &lt;span class=&quot;hljs-literal&quot;&gt;false&lt;/span&gt;);\n&lt;span class=&quot;hljs-variable&quot;&gt;$pdo&lt;/span&gt;-&amp;gt;&lt;span class=&quot;hljs-title function_ invoke__&quot;&gt;query&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&apos;SET NAMES gbk&apos;&lt;/span&gt;);\n&lt;span class=&quot;hljs-variable&quot;&gt;$stmt&lt;/span&gt; = &lt;span class=&quot;hljs-variable&quot;&gt;$pdo&lt;/span&gt;-&amp;gt;&lt;span class=&quot;hljs-title function_ invoke__&quot;&gt;prepare&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&apos;SELECT * FROM test WHERE name = ? LIMIT 1&apos;&lt;/span&gt;);\n&lt;span class=&quot;hljs-variable&quot;&gt;$stmt&lt;/span&gt;-&amp;gt;&lt;span class=&quot;hljs-title function_ invoke__&quot;&gt;execute&lt;/span&gt;(&lt;span class=&quot;hljs-keyword&quot;&gt;array&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;\\xbf\\x27 OR 1=1 /*&quot;&lt;/span&gt;));\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;Because we&apos;ve turned off emulated prepared statements.&lt;/p&gt;\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-php&quot;&gt;&lt;span class=&quot;hljs-variable&quot;&gt;$pdo&lt;/span&gt; = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;hljs-title function_ invoke__&quot;&gt;PDO&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&apos;mysql:host=localhost;dbname=testdb;charset=gbk&apos;&lt;/span&gt;, &lt;span class=&quot;hljs-variable&quot;&gt;$user&lt;/span&gt;, &lt;span class=&quot;hljs-variable&quot;&gt;$password&lt;/span&gt;);\n&lt;span class=&quot;hljs-variable&quot;&gt;$stmt&lt;/span&gt; = &lt;span class=&quot;hljs-variable&quot;&gt;$pdo&lt;/span&gt;-&amp;gt;&lt;span class=&quot;hljs-title function_ invoke__&quot;&gt;prepare&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&apos;SELECT * FROM test WHERE name = ? LIMIT 1&apos;&lt;/span&gt;);\n&lt;span class=&quot;hljs-variable&quot;&gt;$stmt&lt;/span&gt;-&amp;gt;&lt;span class=&quot;hljs-title function_ invoke__&quot;&gt;execute&lt;/span&gt;(&lt;span class=&quot;hljs-keyword&quot;&gt;array&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;\\xbf\\x27 OR 1=1 /*&quot;&lt;/span&gt;));\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;Because we&apos;ve set the character set properly.&lt;/p&gt;\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-bash&quot;&gt;&lt;span class=&quot;hljs-variable&quot;&gt;$mysqli&lt;/span&gt;-&amp;gt;query(&lt;span class=&quot;hljs-string&quot;&gt;&apos;SET NAMES gbk&apos;&lt;/span&gt;);\n&lt;span class=&quot;hljs-variable&quot;&gt;$stmt&lt;/span&gt; = &lt;span class=&quot;hljs-variable&quot;&gt;$mysqli&lt;/span&gt;-&amp;gt;prepare(&lt;span class=&quot;hljs-string&quot;&gt;&apos;SELECT * FROM test WHERE name = ? LIMIT 1&apos;&lt;/span&gt;);\n&lt;span class=&quot;hljs-variable&quot;&gt;$param&lt;/span&gt; = &lt;span class=&quot;hljs-string&quot;&gt;&quot;\\xbf\\x27 OR 1=1 /*&quot;&lt;/span&gt;;\n&lt;span class=&quot;hljs-variable&quot;&gt;$stmt&lt;/span&gt;-&amp;gt;bind_param(&lt;span class=&quot;hljs-string&quot;&gt;&apos;s&apos;&lt;/span&gt;, &lt;span class=&quot;hljs-variable&quot;&gt;$param&lt;/span&gt;);\n&lt;span class=&quot;hljs-variable&quot;&gt;$stmt&lt;/span&gt;-&amp;gt;execute();\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;Because MySQLi does true prepared statements all the time.&lt;/p&gt;\n&lt;h1&gt;Wrapping Up&lt;/h1&gt;\n&lt;p&gt;If you:&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;Use Modern Versions of MySQL (late 5.1, all 5.5, 5.6, etc) &lt;strong&gt;AND&lt;/strong&gt; &lt;code&gt;mysql_set_charset()&lt;/code&gt; / &lt;code&gt;$mysqli-&amp;gt;set_charset()&lt;/code&gt; / PDO&apos;s DSN charset parameter (in PHP  5.3.6)&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;&lt;strong&gt;OR&lt;/strong&gt;&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;Don&apos;t use a vulnerable character set for connection encoding (you only use &lt;code&gt;utf8&lt;/code&gt; / &lt;code&gt;latin1&lt;/code&gt; / &lt;code&gt;ascii&lt;/code&gt; / etc)&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;You&apos;re 100% safe.&lt;/p&gt;\n&lt;p&gt;Otherwise, you&apos;re vulnerable &lt;strong&gt;even though you&apos;re using &lt;code&gt;mysql_real_escape_string()&lt;/code&gt;&lt;/strong&gt;...&lt;/p&gt;\n    ","\n&lt;p&gt;Consider the following query:&lt;/p&gt;\n\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-bash&quot;&gt;&lt;span class=&quot;hljs-variable&quot;&gt;$iId&lt;/span&gt; = mysql_real_escape_string(&lt;span class=&quot;hljs-string&quot;&gt;&quot;1 OR 1=1&quot;&lt;/span&gt;);    \n&lt;span class=&quot;hljs-variable&quot;&gt;$sSql&lt;/span&gt; = &lt;span class=&quot;hljs-string&quot;&gt;&quot;SELECT * FROM table WHERE id = &lt;span class=&quot;hljs-variable&quot;&gt;$iId&lt;/span&gt;&quot;&lt;/span&gt;;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;&lt;code&gt;mysql_real_escape_string()&lt;/code&gt; will not protect you against this.\n&lt;strong&gt;The fact that you use single quotes (&lt;code&gt;&apos; &apos;&lt;/code&gt;) around your variables inside your query is what protects you against this.&lt;/strong&gt; The following is also an option:&lt;/p&gt;\n\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-php&quot;&gt;&lt;span class=&quot;hljs-variable&quot;&gt;$iId&lt;/span&gt; = (&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt;)&lt;span class=&quot;hljs-string&quot;&gt;&quot;1 OR 1=1&quot;&lt;/span&gt;;\n&lt;span class=&quot;hljs-variable&quot;&gt;$sSql&lt;/span&gt; = &lt;span class=&quot;hljs-string&quot;&gt;&quot;SELECT * FROM table WHERE id = &lt;span class=&quot;hljs-subst&quot;&gt;$iId&lt;/span&gt;&quot;&lt;/span&gt;;\n&lt;/code&gt;&lt;/pre&gt;\n    ","\n\n\n&lt;blockquote&gt;\n  &lt;h1&gt;TL;DR&lt;/h1&gt;\n  \n  &lt;p&gt;&lt;code&gt;mysql_real_escape_string()&lt;/code&gt; will &lt;strong&gt;provide no protection whatsoever&lt;/strong&gt; (and could furthermore munge your data) if:&lt;/p&gt;\n  \n  &lt;ul&gt;\n  &lt;li&gt;&lt;p&gt;MySQL&apos;s &lt;a href=&quot;http://dev.mysql.com/doc/en/sql-mode.html#sqlmode_no_backslash_escapes&quot; rel=&quot;noreferrer&quot;&gt;&lt;code&gt;NO_BACKSLASH_ESCAPES&lt;/code&gt;&lt;/a&gt; SQL mode is enabled (which it &lt;em&gt;might&lt;/em&gt; be, unless you &lt;em&gt;explicitly&lt;/em&gt; select another SQL mode &lt;em&gt;every time you connect&lt;/em&gt;); and&lt;/p&gt;&lt;/li&gt;\n  &lt;li&gt;&lt;p&gt;your SQL string literals are quoted using double-quote &lt;code&gt;&quot;&lt;/code&gt; characters.&lt;/p&gt;&lt;/li&gt;\n  &lt;/ul&gt;\n  \n  &lt;p&gt;This was filed as &lt;a href=&quot;http://bugs.mysql.com/bug.php?id=72458&quot; rel=&quot;noreferrer&quot;&gt;bug #72458&lt;/a&gt; and has been fixed in MySQL v5.7.6 (see the section headed &quot;&lt;strong&gt;The Saving Grace&lt;/strong&gt;&quot;, below).&lt;/p&gt;\n&lt;/blockquote&gt;\n\n&lt;h1&gt;This is another, (perhaps less?) obscure EDGE CASE!!!&lt;/h1&gt;\n\n&lt;p&gt;In homage to &lt;a href=&quot;https://stackoverflow.com/a/12118602&quot;&gt;@ircmaxell&apos;s excellent answer&lt;/a&gt; (really, this is supposed to be flattery and not plagiarism!), I will adopt his format:&lt;/p&gt;\n\n&lt;h2&gt;The Attack&lt;/h2&gt;\n\n&lt;p&gt;Starting off with a demonstration...&lt;/p&gt;\n\n&lt;pre class=&quot;lang-php s-code-block&quot;&gt;&lt;code class=&quot;hljs language-php&quot;&gt;&lt;span class=&quot;hljs-title function_ invoke__&quot;&gt;mysql_query&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&apos;SET SQL_MODE=&quot;NO_BACKSLASH_ESCAPES&quot;&apos;&lt;/span&gt;); &lt;span class=&quot;hljs-comment&quot;&gt;// could already be set&lt;/span&gt;\n&lt;span class=&quot;hljs-variable&quot;&gt;$var&lt;/span&gt; = &lt;span class=&quot;hljs-title function_ invoke__&quot;&gt;mysql_real_escape_string&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&apos;&quot; OR 1=1 -- &apos;&lt;/span&gt;);\n&lt;span class=&quot;hljs-title function_ invoke__&quot;&gt;mysql_query&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&apos;SELECT * FROM test WHERE name = &quot;&apos;&lt;/span&gt;.&lt;span class=&quot;hljs-variable&quot;&gt;$var&lt;/span&gt;.&lt;span class=&quot;hljs-string&quot;&gt;&apos;&quot; LIMIT 1&apos;&lt;/span&gt;);\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;This will return all records from the &lt;code&gt;test&lt;/code&gt; table.  A dissection:&lt;/p&gt;\n\n&lt;ol&gt;\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;Selecting an SQL Mode&lt;/strong&gt;&lt;/p&gt;\n\n&lt;pre class=&quot;lang-php s-code-block&quot;&gt;&lt;code class=&quot;hljs language-php&quot;&gt;&lt;span class=&quot;hljs-title function_ invoke__&quot;&gt;mysql_query&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&apos;SET SQL_MODE=&quot;NO_BACKSLASH_ESCAPES&quot;&apos;&lt;/span&gt;);\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;As documented under &lt;a href=&quot;http://dev.mysql.com/doc/en/string-literals.html&quot; rel=&quot;noreferrer&quot;&gt;String Literals&lt;/a&gt;:&lt;/p&gt;\n\n&lt;blockquote&gt;\n  &lt;p&gt;There are several ways to include quote characters within a string:&lt;/p&gt;\n  \n  &lt;ul&gt;\n  &lt;li&gt;&lt;p&gt;A &lt;code&gt;&apos;&lt;/code&gt; inside a string quoted with &lt;code&gt;&apos;&lt;/code&gt; may be written as &lt;code&gt;&apos;&apos;&lt;/code&gt;.&lt;/p&gt;&lt;/li&gt;\n  &lt;li&gt;&lt;p&gt;A &lt;code&gt;&quot;&lt;/code&gt; inside a string quoted with &lt;code&gt;&quot;&lt;/code&gt; may be written as &lt;code&gt;&quot;&quot;&lt;/code&gt;.&lt;/p&gt;&lt;/li&gt;\n  &lt;li&gt;&lt;p&gt;Precede the quote character by an escape character (&lt;code&gt;\\&lt;/code&gt;).&lt;/p&gt;&lt;/li&gt;\n  &lt;li&gt;&lt;p&gt;A &lt;code&gt;&apos;&lt;/code&gt; inside a string quoted with &lt;code&gt;&quot;&lt;/code&gt; needs no special treatment and need not be doubled or escaped. In the same way, &lt;code&gt;&quot;&lt;/code&gt; inside a string quoted with &lt;code&gt;&apos;&lt;/code&gt; needs no special treatment.&lt;/p&gt;&lt;/li&gt;\n  &lt;/ul&gt;\n&lt;/blockquote&gt;\n\n&lt;p&gt;If the server&apos;s SQL mode includes &lt;a href=&quot;http://dev.mysql.com/doc/en/sql-mode.html#sqlmode_no_backslash_escapes&quot; rel=&quot;noreferrer&quot;&gt;&lt;code&gt;NO_BACKSLASH_ESCAPES&lt;/code&gt;&lt;/a&gt;, then the third of these optionswhich is the usual approach adopted by &lt;code&gt;mysql_real_escape_string()&lt;/code&gt;is not available: one of the first two options must be used instead.  Note that the effect of the fourth bullet is that one must necessarily know the character that will be used to quote the literal in order to avoid munging one&apos;s data.&lt;/p&gt;&lt;/li&gt;\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;The Payload&lt;/strong&gt;&lt;/p&gt;\n\n&lt;pre class=&quot;lang-php s-code-block&quot;&gt;&lt;code class=&quot;hljs language-php&quot;&gt;&lt;span class=&quot;hljs-string&quot;&gt;&quot; OR 1=1 -- \n&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;The payload initiates this injection quite literally with the &lt;code&gt;&quot;&lt;/code&gt; character.  No particular encoding.  No special characters.  No weird bytes.&lt;/p&gt;&lt;/li&gt;\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;mysql_real_escape_string()&lt;/strong&gt;&lt;/p&gt;\n\n&lt;pre class=&quot;lang-php s-code-block&quot;&gt;&lt;code class=&quot;hljs language-php&quot;&gt;&lt;span class=&quot;hljs-variable&quot;&gt;$var&lt;/span&gt; = &lt;span class=&quot;hljs-title function_ invoke__&quot;&gt;mysql_real_escape_string&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&apos;&quot; OR 1=1 -- &apos;&lt;/span&gt;);\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Fortunately, &lt;code&gt;mysql_real_escape_string()&lt;/code&gt; does check the SQL mode and adjust its behaviour accordingly.  See &lt;a href=&quot;http://bazaar.launchpad.net/~mysql/libmysql/1.0/view/head:/libmysql/libmysql.c#L1267&quot; rel=&quot;noreferrer&quot;&gt;&lt;code&gt;libmysql.c&lt;/code&gt;&lt;/a&gt;:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;ulong STDCALL\n&lt;span class=&quot;hljs-title function_&quot;&gt;mysql_real_escape_string&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(MYSQL *mysql, &lt;span class=&quot;hljs-type&quot;&gt;char&lt;/span&gt; *to,&lt;span class=&quot;hljs-type&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;char&lt;/span&gt; *from,\n             ulong length)&lt;/span&gt;\n{\n  &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (mysql-&amp;gt;server_status &amp;amp; SERVER_STATUS_NO_BACKSLASH_ESCAPES)\n    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; escape_quotes_for_mysql(mysql-&amp;gt;charset, to, &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;, from, length);\n  &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; escape_string_for_mysql(mysql-&amp;gt;charset, to, &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;, from, length);\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Thus a different underlying function, &lt;code&gt;escape_quotes_for_mysql()&lt;/code&gt;, is invoked if the &lt;code&gt;NO_BACKSLASH_ESCAPES&lt;/code&gt; SQL mode is in use.  As mentioned above, such a function needs to know which character will be used to quote the literal in order to repeat it without causing the other quotation character from being repeated literally.&lt;/p&gt;\n\n&lt;p&gt;However, this function arbitrarily &lt;em&gt;assumes&lt;/em&gt; that the string will be quoted using the single-quote &lt;code&gt;&apos;&lt;/code&gt; character.  See &lt;a href=&quot;http://bazaar.launchpad.net/~mysql/libmysql/1.0/view/head:/mysys/charset.c#L836&quot; rel=&quot;noreferrer&quot;&gt;&lt;code&gt;charset.c&lt;/code&gt;&lt;/a&gt;:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-c s-code-block&quot;&gt;&lt;code class=&quot;hljs language-c&quot;&gt;&lt;span class=&quot;hljs-comment&quot;&gt;/*\n  Escape apostrophes by doubling them up\n\n// [ deletia 839-845 ]\n\n  DESCRIPTION\n    This escapes the contents of a string by doubling up any apostrophes that\n    it contains. This is used when the NO_BACKSLASH_ESCAPES SQL_MODE is in\n    effect on the server.\n\n// [ deletia 852-858 ]\n*/&lt;/span&gt;\n\n&lt;span class=&quot;hljs-type&quot;&gt;size_t&lt;/span&gt; &lt;span class=&quot;hljs-title function_&quot;&gt;escape_quotes_for_mysql&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(CHARSET_INFO *charset_info,\n                               &lt;span class=&quot;hljs-type&quot;&gt;char&lt;/span&gt; *to, &lt;span class=&quot;hljs-type&quot;&gt;size_t&lt;/span&gt; to_length,\n                               &lt;span class=&quot;hljs-type&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;char&lt;/span&gt; *from, &lt;span class=&quot;hljs-type&quot;&gt;size_t&lt;/span&gt; length)&lt;/span&gt;\n{\n&lt;span class=&quot;hljs-comment&quot;&gt;// [ deletia 865-892 ]&lt;/span&gt;\n\n    &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (*from == &lt;span class=&quot;hljs-string&quot;&gt;&apos;\\&apos;&apos;&lt;/span&gt;)\n    {\n      &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (to + &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt; &amp;gt; to_end)\n      {\n        overflow= TRUE;\n        &lt;span class=&quot;hljs-keyword&quot;&gt;break&lt;/span&gt;;\n      }\n      *to++= &lt;span class=&quot;hljs-string&quot;&gt;&apos;\\&apos;&apos;&lt;/span&gt;;\n      *to++= &lt;span class=&quot;hljs-string&quot;&gt;&apos;\\&apos;&apos;&lt;/span&gt;;\n    }\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;So, it leaves double-quote &lt;code&gt;&quot;&lt;/code&gt; characters untouched (and doubles all single-quote &lt;code&gt;&apos;&lt;/code&gt; characters) &lt;em&gt;irrespective of the actual character that is used to quote the literal&lt;/em&gt;!  In our case &lt;code&gt;$var&lt;/code&gt; remains exactly the same as the argument that was provided to &lt;code&gt;mysql_real_escape_string()&lt;/code&gt;it&apos;s as though no escaping has taken place &lt;em&gt;at all&lt;/em&gt;.&lt;/p&gt;&lt;/li&gt;\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;The Query&lt;/strong&gt;&lt;/p&gt;\n\n&lt;pre class=&quot;lang-php s-code-block&quot;&gt;&lt;code class=&quot;hljs language-php&quot;&gt;&lt;span class=&quot;hljs-title function_ invoke__&quot;&gt;mysql_query&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&apos;SELECT * FROM test WHERE name = &quot;&apos;&lt;/span&gt;.&lt;span class=&quot;hljs-variable&quot;&gt;$var&lt;/span&gt;.&lt;span class=&quot;hljs-string&quot;&gt;&apos;&quot; LIMIT 1&apos;&lt;/span&gt;);\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Something of a formality, the rendered query is:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-sql s-code-block&quot;&gt;&lt;code class=&quot;hljs language-sql&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;SELECT&lt;/span&gt; &lt;span class=&quot;hljs-operator&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;FROM&lt;/span&gt; test &lt;span class=&quot;hljs-keyword&quot;&gt;WHERE&lt;/span&gt; name &lt;span class=&quot;hljs-operator&quot;&gt;=&lt;/span&gt; &quot;&quot; &lt;span class=&quot;hljs-keyword&quot;&gt;OR&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;hljs-operator&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;hljs-comment&quot;&gt;-- &quot; LIMIT 1&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;\n&lt;/ol&gt;\n\n&lt;p&gt;As my learned friend put it: congratulations, you just successfully attacked a program using &lt;code&gt;mysql_real_escape_string()&lt;/code&gt;...&lt;/p&gt;\n\n&lt;h2&gt;The Bad&lt;/h2&gt;\n\n&lt;p&gt;&lt;a href=&quot;http://www.php.net/manual/en/function.mysql-set-charset.php&quot; rel=&quot;noreferrer&quot;&gt;&lt;code&gt;mysql_set_charset()&lt;/code&gt;&lt;/a&gt; cannot help, as this has nothing to do with character sets; nor can &lt;a href=&quot;http://www.php.net/manual/en/mysqli.real-escape-string.php&quot; rel=&quot;noreferrer&quot;&gt;&lt;code&gt;mysqli::real_escape_string()&lt;/code&gt;&lt;/a&gt;, since that&apos;s just a different wrapper around this same function.&lt;/p&gt;\n\n&lt;p&gt;The problem, if not already obvious, is that the call to &lt;code&gt;mysql_real_escape_string()&lt;/code&gt; &lt;strong&gt;cannot know&lt;/strong&gt; with which character the literal will be quoted, as that&apos;s left to the developer to decide at a later time.  So, in &lt;code&gt;NO_BACKSLASH_ESCAPES&lt;/code&gt; mode, there is literally &lt;em&gt;no way&lt;/em&gt; that this function can safely escape every input for use with arbitrary quoting (at least, not without doubling characters that do not require doubling and thus munging your data).&lt;/p&gt;\n\n&lt;h2&gt;The Ugly&lt;/h2&gt;\n\n&lt;p&gt;It gets worse.  &lt;code&gt;NO_BACKSLASH_ESCAPES&lt;/code&gt; may not be all that uncommon in the wild owing to the necessity of its use for compatibility with standard SQL (e.g. see section 5.3 of the &lt;a href=&quot;http://www.contrib.andrew.cmu.edu/~shadow/sql/sql1992.txt&quot; rel=&quot;noreferrer&quot;&gt;SQL-92 specification&lt;/a&gt;, namely the &lt;code&gt;&amp;lt;quote symbol&amp;gt; ::= &amp;lt;quote&amp;gt;&amp;lt;quote&amp;gt;&lt;/code&gt; grammar production and lack of any special meaning given to backslash).  Furthermore, its use was explicitly &lt;a href=&quot;http://dev.mysql.com/doc/relnotes/mysql/5.1/en/news-5-1-11.html&quot; rel=&quot;noreferrer&quot;&gt;recommended as a workaround&lt;/a&gt; to the (long since fixed) &lt;a href=&quot;http://bugs.mysql.com/bug.php?id=8378&quot; rel=&quot;noreferrer&quot;&gt;bug&lt;/a&gt; that ircmaxell&apos;s post describes.  Who knows, some DBAs might even configure it to be on by default as means of discouraging use of incorrect escaping methods like &lt;a href=&quot;http://www.php.net/manual/en/function.addslashes.php&quot; rel=&quot;noreferrer&quot;&gt;&lt;code&gt;addslashes()&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;\n\n&lt;p&gt;Also, the &lt;a href=&quot;http://dev.mysql.com/doc/en/sql-mode.html#sql-mode-setting&quot; rel=&quot;noreferrer&quot;&gt;SQL mode of a new connection&lt;/a&gt; is set by the server according to its configuration (which a &lt;code&gt;SUPER&lt;/code&gt; user can change at any time); thus, to be certain of the server&apos;s behaviour, you must &lt;em&gt;always&lt;/em&gt; explicitly specify your desired mode after connecting.&lt;/p&gt;\n\n&lt;h2&gt;The Saving Grace&lt;/h2&gt;\n\n&lt;p&gt;So long as you always &lt;em&gt;explicitly&lt;/em&gt; set the SQL mode not to include &lt;code&gt;NO_BACKSLASH_ESCAPES&lt;/code&gt;, or quote MySQL string literals using the single-quote character, this bug cannot rear its ugly head: respectively &lt;code&gt;escape_quotes_for_mysql()&lt;/code&gt; will not be used, or its assumption about which quote characters require repeating will be correct.&lt;/p&gt;\n\n&lt;p&gt;For this reason, I recommend that anyone using &lt;code&gt;NO_BACKSLASH_ESCAPES&lt;/code&gt; also enables &lt;a href=&quot;http://dev.mysql.com/doc/en/sql-mode.html#sqlmode_ansi_quotes&quot; rel=&quot;noreferrer&quot;&gt;&lt;code&gt;ANSI_QUOTES&lt;/code&gt;&lt;/a&gt; mode, as it will force habitual use of single-quoted string literals.  Note that this does not prevent SQL injection in the event that double-quoted literals happen to be usedit merely reduces the likelihood of that happening (because normal, non-malicious queries would fail).&lt;/p&gt;\n\n&lt;p&gt;In PDO, both its equivalent function &lt;a href=&quot;http://www.php.net/manual/en/pdo.quote.php&quot; rel=&quot;noreferrer&quot;&gt;&lt;code&gt;PDO::quote()&lt;/code&gt;&lt;/a&gt; and its prepared statement emulator call upon &lt;a href=&quot;https://github.com/php/php-src/blob/af6c11c5f060870d052a2b765dc634d9e47d0f18/ext/pdo_mysql/mysql_driver.c#L302&quot; rel=&quot;noreferrer&quot;&gt;&lt;code&gt;mysql_handle_quoter()&lt;/code&gt;&lt;/a&gt;which does exactly this: it ensures that the escaped literal is quoted in single-quotes, so you can be certain that PDO is always immune from this bug.&lt;/p&gt;\n\n&lt;p&gt;As of MySQL v5.7.6, this bug has been fixed.  See &lt;a href=&quot;http://dev.mysql.com/doc/relnotes/mysql/5.7/en/news-5-7-6.html&quot; rel=&quot;noreferrer&quot;&gt;change log&lt;/a&gt;:&lt;/p&gt;\n\n&lt;blockquote&gt;\n  &lt;h3&gt;Functionality Added or Changed&lt;/h3&gt;\n  \n  &lt;ul&gt;\n  &lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;em&gt;Incompatible Change:&lt;/em&gt;&lt;/strong&gt; A new C API function, &lt;a href=&quot;http://dev.mysql.com/doc/refman/5.7/en/mysql-real-escape-string-quote.html&quot; rel=&quot;noreferrer&quot;&gt;&lt;code&gt;mysql_real_escape_string_quote()&lt;/code&gt;&lt;/a&gt;, has been implemented as a replacement for &lt;a href=&quot;http://dev.mysql.com/doc/refman/5.7/en/mysql-real-escape-string.html&quot; rel=&quot;noreferrer&quot;&gt;&lt;code&gt;mysql_real_escape_string()&lt;/code&gt;&lt;/a&gt; because the latter function can fail to properly encode characters when the &lt;a href=&quot;http://dev.mysql.com/doc/refman/5.7/en/sql-mode.html#sqlmode_no_backslash_escapes&quot; rel=&quot;noreferrer&quot;&gt;&lt;code&gt;NO_BACKSLASH_ESCAPES&lt;/code&gt;&lt;/a&gt; SQL mode is enabled. In this case, &lt;a href=&quot;http://dev.mysql.com/doc/refman/5.7/en/mysql-real-escape-string.html&quot; rel=&quot;noreferrer&quot;&gt;&lt;code&gt;mysql_real_escape_string()&lt;/code&gt;&lt;/a&gt; cannot escape quote characters except by doubling them, and to do this properly, it must know more information about the quoting context than is available. &lt;a href=&quot;http://dev.mysql.com/doc/refman/5.7/en/mysql-real-escape-string-quote.html&quot; rel=&quot;noreferrer&quot;&gt;&lt;code&gt;mysql_real_escape_string_quote()&lt;/code&gt;&lt;/a&gt; takes an extra argument for specifying the quoting context. For usage details, see &lt;a href=&quot;http://dev.mysql.com/doc/refman/5.7/en/mysql-real-escape-string-quote.html&quot; rel=&quot;noreferrer&quot;&gt;mysql_real_escape_string_quote()&lt;/a&gt;.&lt;/p&gt;\n  \n  &lt;blockquote&gt;\n    &lt;h3&gt;&amp;nbsp;Note&lt;/h3&gt;\n    \n    &lt;p&gt;Applications should be modified to use &lt;a href=&quot;http://dev.mysql.com/doc/refman/5.7/en/mysql-real-escape-string-quote.html&quot; rel=&quot;noreferrer&quot;&gt;&lt;code&gt;mysql_real_escape_string_quote()&lt;/code&gt;&lt;/a&gt;, instead of &lt;a href=&quot;http://dev.mysql.com/doc/refman/5.7/en/mysql-real-escape-string.html&quot; rel=&quot;noreferrer&quot;&gt;&lt;code&gt;mysql_real_escape_string()&lt;/code&gt;&lt;/a&gt;, which now fails and produces an &lt;a href=&quot;http://dev.mysql.com/doc/refman/5.7/en/error-messages-client.html#error_cr_insecure_api_err&quot; rel=&quot;noreferrer&quot;&gt;&lt;code&gt;CR_INSECURE_API_ERR&lt;/code&gt;&lt;/a&gt; error if &lt;a href=&quot;http://dev.mysql.com/doc/refman/5.7/en/sql-mode.html#sqlmode_no_backslash_escapes&quot; rel=&quot;noreferrer&quot;&gt;&lt;code&gt;NO_BACKSLASH_ESCAPES&lt;/code&gt;&lt;/a&gt; is enabled.&lt;/p&gt;\n  &lt;/blockquote&gt;\n  \n  &lt;p&gt;References: See also Bug #19211994.&lt;/p&gt;&lt;/li&gt;\n  &lt;/ul&gt;\n&lt;/blockquote&gt;\n\n&lt;h2&gt;Safe Examples&lt;/h2&gt;\n\n&lt;p&gt;Taken together with the bug explained by ircmaxell, the following examples are entirely safe (assuming that one is either using MySQL later than 4.1.20, 5.0.22, 5.1.11; or that one is not using a GBK/Big5 connection encoding):&lt;/p&gt;\n\n&lt;pre class=&quot;lang-php s-code-block&quot;&gt;&lt;code class=&quot;hljs language-php&quot;&gt;&lt;span class=&quot;hljs-title function_ invoke__&quot;&gt;mysql_set_charset&lt;/span&gt;(&lt;span class=&quot;hljs-variable&quot;&gt;$charset&lt;/span&gt;);\n&lt;span class=&quot;hljs-title function_ invoke__&quot;&gt;mysql_query&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;SET SQL_MODE=&apos;&apos;&quot;&lt;/span&gt;);\n&lt;span class=&quot;hljs-variable&quot;&gt;$var&lt;/span&gt; = &lt;span class=&quot;hljs-title function_ invoke__&quot;&gt;mysql_real_escape_string&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&apos;&quot; OR 1=1 /*&apos;&lt;/span&gt;);\n&lt;span class=&quot;hljs-title function_ invoke__&quot;&gt;mysql_query&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&apos;SELECT * FROM test WHERE name = &quot;&apos;&lt;/span&gt;.&lt;span class=&quot;hljs-variable&quot;&gt;$var&lt;/span&gt;.&lt;span class=&quot;hljs-string&quot;&gt;&apos;&quot; LIMIT 1&apos;&lt;/span&gt;);\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;...because we&apos;ve explicitly selected an SQL mode that doesn&apos;t include &lt;code&gt;NO_BACKSLASH_ESCAPES&lt;/code&gt;.&lt;/p&gt;\n\n&lt;pre class=&quot;lang-php s-code-block&quot;&gt;&lt;code class=&quot;hljs language-php&quot;&gt;&lt;span class=&quot;hljs-title function_ invoke__&quot;&gt;mysql_set_charset&lt;/span&gt;(&lt;span class=&quot;hljs-variable&quot;&gt;$charset&lt;/span&gt;);\n&lt;span class=&quot;hljs-variable&quot;&gt;$var&lt;/span&gt; = &lt;span class=&quot;hljs-title function_ invoke__&quot;&gt;mysql_real_escape_string&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;&apos; OR 1=1 /*&quot;&lt;/span&gt;);\n&lt;span class=&quot;hljs-title function_ invoke__&quot;&gt;mysql_query&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;SELECT * FROM test WHERE name = &apos;&lt;span class=&quot;hljs-subst&quot;&gt;$var&lt;/span&gt;&apos; LIMIT 1&quot;&lt;/span&gt;);\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;...because we&apos;re quoting our string literal with single-quotes.&lt;/p&gt;\n\n&lt;pre class=&quot;lang-php s-code-block&quot;&gt;&lt;code class=&quot;hljs language-php&quot;&gt;&lt;span class=&quot;hljs-variable&quot;&gt;$stmt&lt;/span&gt; = &lt;span class=&quot;hljs-variable&quot;&gt;$pdo&lt;/span&gt;-&amp;gt;&lt;span class=&quot;hljs-title function_ invoke__&quot;&gt;prepare&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&apos;SELECT * FROM test WHERE name = ? LIMIT 1&apos;&lt;/span&gt;);\n&lt;span class=&quot;hljs-variable&quot;&gt;$stmt&lt;/span&gt;-&amp;gt;&lt;span class=&quot;hljs-title function_ invoke__&quot;&gt;execute&lt;/span&gt;([&lt;span class=&quot;hljs-string&quot;&gt;&quot;&apos; OR 1=1 /*&quot;&lt;/span&gt;]);\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;...because PDO prepared statements are immune from this vulnerability (and ircmaxell&apos;s too, provided either that you&apos;re using PHP5.3.6 and the character set has been correctly set in the DSN; or that prepared statement emulation has been disabled).&lt;/p&gt;\n\n&lt;pre class=&quot;lang-php s-code-block&quot;&gt;&lt;code class=&quot;hljs language-php&quot;&gt;&lt;span class=&quot;hljs-variable&quot;&gt;$var&lt;/span&gt;  = &lt;span class=&quot;hljs-variable&quot;&gt;$pdo&lt;/span&gt;-&amp;gt;&lt;span class=&quot;hljs-title function_ invoke__&quot;&gt;quote&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;&apos; OR 1=1 /*&quot;&lt;/span&gt;);\n&lt;span class=&quot;hljs-variable&quot;&gt;$stmt&lt;/span&gt; = &lt;span class=&quot;hljs-variable&quot;&gt;$pdo&lt;/span&gt;-&amp;gt;&lt;span class=&quot;hljs-title function_ invoke__&quot;&gt;query&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;SELECT * FROM test WHERE name = &lt;span class=&quot;hljs-subst&quot;&gt;$var&lt;/span&gt; LIMIT 1&quot;&lt;/span&gt;);\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;...because PDO&apos;s &lt;code&gt;quote()&lt;/code&gt; function not only escapes the literal, but also quotes it (in single-quote &lt;code&gt;&apos;&lt;/code&gt; characters); note that to avoid ircmaxell&apos;s bug in this case, you &lt;em&gt;must&lt;/em&gt; be using PHP5.3.6 &lt;em&gt;and&lt;/em&gt; have correctly set the character set in the DSN.&lt;/p&gt;\n\n&lt;pre class=&quot;lang-php s-code-block&quot;&gt;&lt;code class=&quot;hljs language-php&quot;&gt;&lt;span class=&quot;hljs-variable&quot;&gt;$stmt&lt;/span&gt; = &lt;span class=&quot;hljs-variable&quot;&gt;$mysqli&lt;/span&gt;-&amp;gt;&lt;span class=&quot;hljs-title function_ invoke__&quot;&gt;prepare&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&apos;SELECT * FROM test WHERE name = ? LIMIT 1&apos;&lt;/span&gt;);\n&lt;span class=&quot;hljs-variable&quot;&gt;$param&lt;/span&gt; = &lt;span class=&quot;hljs-string&quot;&gt;&quot;&apos; OR 1=1 /*&quot;&lt;/span&gt;;\n&lt;span class=&quot;hljs-variable&quot;&gt;$stmt&lt;/span&gt;-&amp;gt;&lt;span class=&quot;hljs-title function_ invoke__&quot;&gt;bind_param&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&apos;s&apos;&lt;/span&gt;, &lt;span class=&quot;hljs-variable&quot;&gt;$param&lt;/span&gt;);\n&lt;span class=&quot;hljs-variable&quot;&gt;$stmt&lt;/span&gt;-&amp;gt;&lt;span class=&quot;hljs-title function_ invoke__&quot;&gt;execute&lt;/span&gt;();\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;...because MySQLi prepared statements are safe.&lt;/p&gt;\n\n&lt;h2&gt;Wrapping Up&lt;/h2&gt;\n\n&lt;p&gt;Thus, if you:&lt;/p&gt;\n\n&lt;ul&gt;\n&lt;li&gt;use native prepared statements&lt;/li&gt;\n&lt;/ul&gt;\n\n&lt;p&gt;&lt;strong&gt;OR&lt;/strong&gt;&lt;/p&gt;\n\n&lt;ul&gt;\n&lt;li&gt;use MySQL v5.7.6 or later&lt;/li&gt;\n&lt;/ul&gt;\n\n&lt;p&gt;&lt;strong&gt;OR&lt;/strong&gt;&lt;/p&gt;\n\n&lt;ul&gt;\n&lt;li&gt;&lt;p&gt;in &lt;em&gt;addition&lt;/em&gt; to employing one of the solutions in ircmaxell&apos;s summary, use at least one of:&lt;/p&gt;\n\n&lt;ul&gt;\n&lt;li&gt;PDO;&lt;/li&gt;\n&lt;li&gt;single-quoted string literals; or&lt;/li&gt;\n&lt;li&gt;an explicitly set SQL mode that does not include &lt;code&gt;NO_BACKSLASH_ESCAPES&lt;/code&gt;&lt;/li&gt;\n&lt;/ul&gt;&lt;/li&gt;\n&lt;/ul&gt;\n\n&lt;p&gt;...then you &lt;em&gt;should&lt;/em&gt; be completely safe (vulnerabilities outside the scope of string escaping aside).&lt;/p&gt;\n    ","\n&lt;p&gt;Well, there&apos;s nothing really that can pass through that, other than &lt;code&gt;%&lt;/code&gt; wildcard. It could be dangerous if you were using &lt;code&gt;LIKE&lt;/code&gt; statement as attacker could put just &lt;code&gt;%&lt;/code&gt; as login if you don&apos;t filter that out, and would have to just bruteforce a password of any of your users.\nPeople often suggest using prepared statements to make it 100% safe, as data can&apos;t interfere with the query itself that way.\nBut for such simple queries it probably would be more efficient to do something like &lt;code&gt;$login = preg_replace(&apos;/[^a-zA-Z0-9_]/&apos;, &apos;&apos;, $login);&lt;/code&gt;&lt;/p&gt;\n    "],"id":38,"title":"SQL injection that gets around mysql_real_escape_string()","content":"\n                \n&lt;p&gt;Is there an SQL injection possibility even when using &lt;code&gt;mysql_real_escape_string()&lt;/code&gt; function?&lt;/p&gt;\n\n&lt;p&gt;Consider this sample situation. SQL is constructed in PHP like this:&lt;/p&gt;\n\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-bash&quot;&gt;&lt;span class=&quot;hljs-variable&quot;&gt;$login&lt;/span&gt; = mysql_real_escape_string(GetFromPost(&lt;span class=&quot;hljs-string&quot;&gt;&apos;login&apos;&lt;/span&gt;));\n&lt;span class=&quot;hljs-variable&quot;&gt;$password&lt;/span&gt; = mysql_real_escape_string(GetFromPost(&lt;span class=&quot;hljs-string&quot;&gt;&apos;password&apos;&lt;/span&gt;));\n\n&lt;span class=&quot;hljs-variable&quot;&gt;$sql&lt;/span&gt; = &lt;span class=&quot;hljs-string&quot;&gt;&quot;SELECT * FROM table WHERE login=&apos;&lt;span class=&quot;hljs-variable&quot;&gt;$login&lt;/span&gt;&apos; AND password=&apos;&lt;span class=&quot;hljs-variable&quot;&gt;$password&lt;/span&gt;&apos;&quot;&lt;/span&gt;;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;I have heard numerous people say to me that code like that is still dangerous and possible to hack even with &lt;code&gt;mysql_real_escape_string()&lt;/code&gt; function used. But I cannot think of any possible exploit?&lt;/p&gt;\n\n&lt;p&gt;Classic injections like this:&lt;/p&gt;\n\n&lt;pre class=&quot;default s-code-block&quot;&gt;&lt;code class=&quot;hljs language-haskell&quot;&gt;&lt;span class=&quot;hljs-title&quot;&gt;aaa&apos;&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;OR&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;=&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;hljs-comment&quot;&gt;--&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;do not work.&lt;/p&gt;\n\n&lt;p&gt;Do you know of any possible injection that would get through the PHP code above?&lt;/p&gt;\n    ","slug":"sql-injection-that-gets-around-mysql_real_escape_string()-1657384364747","postType":"QUESTION","createdAt":"2022-07-09T16:32:44.000Z","updatedAt":"2022-07-09T16:32:44.000Z","tags":[],"relatedQuestions":[]},"randomQuestions":[{"title":"Read file line by line using ifstream in C++","slug":"read-file-line-by-line-using-ifstream-in-c++-1657388236966"},{"title":"How can I remove a specific item from an array?","slug":"how-can-i-remove-a-specific-item-from-an-array-1657387552077"},{"title":"How to fix java.lang.UnsupportedClassVersionError: Unsupported major.minor version","slug":"how-to-fix-java.lang.unsupportedclassversionerror:-unsupported-major.minor-version-1657384863422"},{"title":"CSS margin terror; Margin adds space outside parent element [duplicate]","slug":"css-margin-terror-margin-adds-space-outside-parent-element-duplicate-1657388142199"},{"title":"Should I avoid the use of set(Preferred|Maximum|Minimum)Size methods in Java Swing?","slug":"should-i-avoid-the-use-of-set(preferredormaximumorminimum)size-methods-in-java-swing-1657384628399"},{"title":"Get the data received in a Flask request","slug":"get-the-data-received-in-a-flask-request-1657387804432"},{"title":"What is a plain English explanation of \"Big O\" notation?","slug":"what-is-a-plain-english-explanation-of-\"big-o\"-notation-1657387641953"},{"title":"What is this weird colon-member (\" : \") syntax in the constructor?","slug":"what-is-this-weird-colon-member-(\"-:-\")-syntax-in-the-constructor-1657387264047"},{"title":"How to access a local variable from a different function using pointers?","slug":"how-to-access-a-local-variable-from-a-different-function-using-pointers-1657388159760"},{"title":"When to use LinkedList over ArrayList in Java?","slug":"when-to-use-linkedlist-over-arraylist-in-java-1657388107480"},{"title":"Why is iostream::eof inside a loop condition (i.e. `while (!stream.eof())`) considered wrong?","slug":"why-is-iostream::eof-inside-a-loop-condition-(i.e.-while-(!stream.eof()))-considered-wrong-1657384355427"},{"title":"Most efficient method to groupby on an array of objects","slug":"most-efficient-method-to-groupby-on-an-array-of-objects-1657387580538"},{"title":"jQuery Ajax File Upload","slug":"jquery-ajax-file-upload-1657387368970"},{"title":"Using global variables in a function","slug":"using-global-variables-in-a-function-1657384796002"},{"title":"Relative imports for the billionth time","slug":"relative-imports-for-the-billionth-time-1657387756383"},{"title":"Why does my function that calls an API or launches a coroutine return an empty or null value?","slug":"why-does-my-function-that-calls-an-api-or-launches-a-coroutine-return-an-empty-or-null-value-1657388483820"},{"title":"Remove duplicate values from JS array [duplicate]","slug":"remove-duplicate-values-from-js-array-duplicate-1657387801931"},{"title":"How can I merge properties of two JavaScript objects dynamically?","slug":"how-can-i-merge-properties-of-two-javascript-objects-dynamically-1657387492535"},{"title":"How to convert a factor to integer\\numeric without loss of information?","slug":"how-to-convert-a-factor-to-integernumeric-without-loss-of-information-1657387880273"},{"title":"Undefined, unspecified and implementation-defined behavior","slug":"undefined-unspecified-and-implementation-defined-behavior-1657384516085"}]},"__N_SSG":true}