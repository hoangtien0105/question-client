{"pageProps":{"data":{"answer":["\n&lt;p&gt;The problem you&apos;re having relates to how &lt;a href=&quot;https://www.mathworks.com/help/matlab/matlab_prog/floating-point-numbers.html&quot; rel=&quot;noreferrer&quot;&gt;floating-point numbers&lt;/a&gt; are represented on a computer. A more detailed discussion of floating-point representations appears towards the end of my answer (The &quot;Floating-point representation&quot; section). The &lt;strong&gt;TL;DR&lt;/strong&gt; version: because computers have finite amounts of memory, numbers can only be represented with finite precision. Thus, the accuracy of floating-point numbers is limited to a certain number of decimal places (about 16 significant digits for &lt;a href=&quot;https://en.wikipedia.org/wiki/Double-precision_floating-point_format&quot; rel=&quot;noreferrer&quot;&gt;double-precision values&lt;/a&gt;, the default used in MATLAB).&lt;/p&gt;\n\n&lt;h2&gt;Actual vs. displayed precision&lt;/h2&gt;\n\n&lt;p&gt;Now to address the specific example in the question... &lt;strong&gt;while &lt;code&gt;24.0000&lt;/code&gt; and &lt;code&gt;24.0000&lt;/code&gt; are &lt;em&gt;displayed&lt;/em&gt; in the same manner, it turns out that they actually differ by very small decimal amounts in this case. You don&apos;t see it because MATLAB &lt;a href=&quot;https://www.mathworks.com/help/matlab/ref/format.html&quot; rel=&quot;noreferrer&quot;&gt;only displays 4 significant digits by default&lt;/a&gt;, keeping the overall display neat and tidy.&lt;/strong&gt; If you want to see the full precision, you should either issue the &lt;code&gt;format long&lt;/code&gt; command or view a &lt;a href=&quot;https://www.mathworks.com/help/matlab/ref/num2hex.html&quot; rel=&quot;noreferrer&quot;&gt;hexadecimal representation&lt;/a&gt; of the number:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-matlab s-code-block&quot;&gt;&lt;code class=&quot;hljs language-matlab&quot;&gt;&amp;gt;&amp;gt; &lt;span class=&quot;hljs-built_in&quot;&gt;pi&lt;/span&gt;\n&lt;span class=&quot;hljs-built_in&quot;&gt;ans&lt;/span&gt; =\n    &lt;span class=&quot;hljs-number&quot;&gt;3.1416&lt;/span&gt;\n&amp;gt;&amp;gt; format long\n&amp;gt;&amp;gt; &lt;span class=&quot;hljs-built_in&quot;&gt;pi&lt;/span&gt;\n&lt;span class=&quot;hljs-built_in&quot;&gt;ans&lt;/span&gt; =\n   &lt;span class=&quot;hljs-number&quot;&gt;3.141592653589793&lt;/span&gt;\n&amp;gt;&amp;gt; num2hex(&lt;span class=&quot;hljs-built_in&quot;&gt;pi&lt;/span&gt;)\n&lt;span class=&quot;hljs-built_in&quot;&gt;ans&lt;/span&gt; =\n&lt;span class=&quot;hljs-number&quot;&gt;400921&lt;/span&gt;fb54442d18\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;h2&gt;Initialized values vs. computed values&lt;/h2&gt;\n\n&lt;p&gt;Since there are only a finite number of values that can be represented for a floating-point number, it&apos;s possible for a computation to result in a value that falls between two of these representations. In such a case, the result has to be rounded off to one of them. This introduces a small &lt;a href=&quot;https://en.wikipedia.org/wiki/Machine_epsilon&quot; rel=&quot;noreferrer&quot;&gt;machine-precision error&lt;/a&gt;. This also means that initializing a value directly or by some computation can give slightly different results. For example, the value &lt;code&gt;0.1&lt;/code&gt; doesn&apos;t have an &lt;em&gt;exact&lt;/em&gt; floating-point representation (i.e. it gets slightly rounded off), and so you end up with counter-intuitive results like this due to the way round-off errors accumulate:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-matlab s-code-block&quot;&gt;&lt;code class=&quot;hljs language-matlab&quot;&gt;&amp;gt;&amp;gt; a=sum([&lt;span class=&quot;hljs-number&quot;&gt;0.1&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;0.1&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;0.1&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;0.1&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;0.1&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;0.1&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;0.1&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;0.1&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;0.1&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;0.1&lt;/span&gt;]);  &lt;span class=&quot;hljs-comment&quot;&gt;% Sum 10 0.1s&lt;/span&gt;\n&amp;gt;&amp;gt; b=&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;;                                               &lt;span class=&quot;hljs-comment&quot;&gt;% Initialize to 1&lt;/span&gt;\n&amp;gt;&amp;gt; a == b\n&lt;span class=&quot;hljs-built_in&quot;&gt;ans&lt;/span&gt; =\n  logical\n   &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;                &lt;span class=&quot;hljs-comment&quot;&gt;% They are unequal!&lt;/span&gt;\n&amp;gt;&amp;gt; num2hex(a)       &lt;span class=&quot;hljs-comment&quot;&gt;% Let&apos;s check their hex representation to confirm&lt;/span&gt;\n&lt;span class=&quot;hljs-built_in&quot;&gt;ans&lt;/span&gt; =\n&lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;fefffffffffffff\n&amp;gt;&amp;gt; num2hex(b)\n&lt;span class=&quot;hljs-built_in&quot;&gt;ans&lt;/span&gt; =\n&lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;ff0000000000000\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;h2&gt;How to correctly handle floating-point comparisons&lt;/h2&gt;\n\n&lt;p&gt;Since floating-point values can differ by very small amounts, any comparisons should be done by checking that the values are within some range (i.e. tolerance) of one another, as opposed to exactly equal to each other. For example:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-matlab s-code-block&quot;&gt;&lt;code class=&quot;hljs language-matlab&quot;&gt;a = &lt;span class=&quot;hljs-number&quot;&gt;24&lt;/span&gt;;\nb = &lt;span class=&quot;hljs-number&quot;&gt;24.000001&lt;/span&gt;;\ntolerance = &lt;span class=&quot;hljs-number&quot;&gt;0.001&lt;/span&gt;;\n&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;hljs-built_in&quot;&gt;abs&lt;/span&gt;(a-b) &amp;lt; tolerance, &lt;span class=&quot;hljs-built_in&quot;&gt;disp&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&apos;Equal!&apos;&lt;/span&gt;); &lt;span class=&quot;hljs-keyword&quot;&gt;end&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;will display &quot;Equal!&quot;.&lt;/p&gt;\n\n&lt;p&gt;You could then change your code to something like:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-matlab s-code-block&quot;&gt;&lt;code class=&quot;hljs language-matlab&quot;&gt;points = points((&lt;span class=&quot;hljs-built_in&quot;&gt;abs&lt;/span&gt;(points(:,&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;)-vertex1(&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;)) &amp;gt; tolerance) | ...\n                (&lt;span class=&quot;hljs-built_in&quot;&gt;abs&lt;/span&gt;(points(:,&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;)-vertex1(&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;)) &amp;gt; tolerance),:)\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;hr&gt;\n\n&lt;h1&gt;Floating-point representation&lt;/h1&gt;\n\n&lt;p&gt;A good overview of floating-point numbers (and specifically the &lt;a href=&quot;https://en.wikipedia.org/wiki/IEEE_floating_point&quot; rel=&quot;noreferrer&quot;&gt;IEEE 754 standard for floating-point arithmetic&lt;/a&gt;) is &lt;a href=&quot;http://docs.oracle.com/cd/E19957-01/806-3568/ncg_goldberg.html&quot; rel=&quot;noreferrer&quot;&gt;&lt;em&gt;What Every Computer Scientist Should Know About Floating-Point Arithmetic&lt;/em&gt;&lt;/a&gt; by David Goldberg.&lt;/p&gt;\n\n&lt;p&gt;A binary floating-point number is actually represented by three integers: a sign bit &lt;code&gt;s&lt;/code&gt;, a significand (or coefficient/fraction) &lt;code&gt;b&lt;/code&gt;, and an exponent &lt;code&gt;e&lt;/code&gt;. &lt;a href=&quot;https://en.wikipedia.org/wiki/Double-precision_floating-point_format&quot; rel=&quot;noreferrer&quot;&gt;For double-precision floating-point format&lt;/a&gt;, each number is represented by 64 bits laid out in memory as follows:&lt;/p&gt;\n\n&lt;p&gt;&lt;a href=&quot;https://i.stack.imgur.com/KTTPX.png&quot; rel=&quot;noreferrer&quot;&gt;&lt;img src=&quot;https://i.stack.imgur.com/KTTPX.png&quot; alt=&quot;enter image description here&quot;&gt;&lt;/a&gt;&lt;/p&gt;\n\n&lt;p&gt;The real value can then be found with the following formula:&lt;/p&gt;\n\n&lt;p&gt;&lt;a href=&quot;https://i.stack.imgur.com/nV0ly.png&quot; rel=&quot;noreferrer&quot;&gt;&lt;img src=&quot;https://i.stack.imgur.com/nV0ly.png&quot; alt=&quot;enter image description here&quot;&gt;&lt;/a&gt;&lt;/p&gt;\n\n&lt;p&gt;This format allows for number representations in the range 10^-308 to 10^308. For MATLAB you can get these limits from &lt;a href=&quot;https://www.mathworks.com/help/matlab/ref/realmin.html&quot; rel=&quot;noreferrer&quot;&gt;&lt;code&gt;realmin&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://www.mathworks.com/help/matlab/ref/realmax.html&quot; rel=&quot;noreferrer&quot;&gt;&lt;code&gt;realmax&lt;/code&gt;&lt;/a&gt;:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-matlab s-code-block&quot;&gt;&lt;code class=&quot;hljs language-matlab&quot;&gt;&amp;gt;&amp;gt; &lt;span class=&quot;hljs-built_in&quot;&gt;realmin&lt;/span&gt;\n&lt;span class=&quot;hljs-built_in&quot;&gt;ans&lt;/span&gt; =\n    &lt;span class=&quot;hljs-number&quot;&gt;2.225073858507201e-308&lt;/span&gt;\n&amp;gt;&amp;gt; &lt;span class=&quot;hljs-built_in&quot;&gt;realmax&lt;/span&gt;\n&lt;span class=&quot;hljs-built_in&quot;&gt;ans&lt;/span&gt; =\n    &lt;span class=&quot;hljs-number&quot;&gt;1.797693134862316e+308&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Since there are a finite number of bits used to represent a floating-point number, there are only so many finite numbers that can be represented within the above given range. Computations will often result in a value that doesn&apos;t exactly match one of these finite representations, so the values must be rounded off. These &lt;a href=&quot;https://en.wikipedia.org/wiki/Machine_epsilon&quot; rel=&quot;noreferrer&quot;&gt;machine-precision errors&lt;/a&gt; make themselves evident in different ways, as discussed in the above examples.&lt;/p&gt;\n\n&lt;p&gt;In order to better understand these round-off errors it&apos;s useful to look at the relative floating-point accuracy provided by the function &lt;a href=&quot;https://www.mathworks.com/help/matlab/ref/eps.html&quot; rel=&quot;noreferrer&quot;&gt;&lt;code&gt;eps&lt;/code&gt;&lt;/a&gt;, which quantifies the distance from a given number to the next largest floating-point representation:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-matlab s-code-block&quot;&gt;&lt;code class=&quot;hljs language-matlab&quot;&gt;&amp;gt;&amp;gt; &lt;span class=&quot;hljs-built_in&quot;&gt;eps&lt;/span&gt;(&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;)\n&lt;span class=&quot;hljs-built_in&quot;&gt;ans&lt;/span&gt; =\n     &lt;span class=&quot;hljs-number&quot;&gt;2.220446049250313e-16&lt;/span&gt;\n&amp;gt;&amp;gt; &lt;span class=&quot;hljs-built_in&quot;&gt;eps&lt;/span&gt;(&lt;span class=&quot;hljs-number&quot;&gt;1000&lt;/span&gt;)\n&lt;span class=&quot;hljs-built_in&quot;&gt;ans&lt;/span&gt; =\n     &lt;span class=&quot;hljs-number&quot;&gt;1.136868377216160e-13&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Notice that the precision is &lt;em&gt;relative&lt;/em&gt; to the size of a given number being represented; larger numbers will have larger distances between floating-point representations, and will thus have fewer digits of precision following the decimal point. This can be an important consideration with some calculations. Consider the following example:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-matlab s-code-block&quot;&gt;&lt;code class=&quot;hljs language-matlab&quot;&gt;&amp;gt;&amp;gt; format long              &lt;span class=&quot;hljs-comment&quot;&gt;% Display full precision&lt;/span&gt;\n&amp;gt;&amp;gt; x = &lt;span class=&quot;hljs-built_in&quot;&gt;rand&lt;/span&gt;(&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;);         &lt;span class=&quot;hljs-comment&quot;&gt;% Get 10 random values between 0 and 1&lt;/span&gt;\n&amp;gt;&amp;gt; a = &lt;span class=&quot;hljs-built_in&quot;&gt;mean&lt;/span&gt;(x)              &lt;span class=&quot;hljs-comment&quot;&gt;% Take the mean&lt;/span&gt;\na =\n   &lt;span class=&quot;hljs-number&quot;&gt;0.587307428244141&lt;/span&gt;\n&amp;gt;&amp;gt; b = &lt;span class=&quot;hljs-built_in&quot;&gt;mean&lt;/span&gt;(x+&lt;span class=&quot;hljs-number&quot;&gt;10000&lt;/span&gt;)&lt;span class=&quot;hljs-number&quot;&gt;-10000&lt;/span&gt;  &lt;span class=&quot;hljs-comment&quot;&gt;% Take the mean at a different scale, then shift back&lt;/span&gt;\nb =\n   &lt;span class=&quot;hljs-number&quot;&gt;0.587307428244458&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Note that when we shift the values of &lt;code&gt;x&lt;/code&gt; from the range &lt;code&gt;[0 1]&lt;/code&gt; to the range &lt;code&gt;[10000 10001]&lt;/code&gt;, compute a mean, then subtract the mean offset for comparison, we get a value that differs for the last 3 significant digits. This illustrates how an offset or scaling of data can change the accuracy of calculations performed on it, which is something that has to be accounted for with certain problems.&lt;/p&gt;\n    ","\n&lt;p&gt;Look at this article: &lt;a href=&quot;http://www.lahey.com/float.htm&quot; rel=&quot;noreferrer&quot;&gt;The Perils of Floating Point&lt;/a&gt;. Though its examples are in FORTRAN it has sense for virtually any modern programming language, including MATLAB. Your problem (and solution for it) is described in &quot;Safe Comparisons&quot; section.&lt;/p&gt;\n    ","\n&lt;p&gt;type&lt;/p&gt;\n\n&lt;pre class=&quot;lang-matlab s-code-block&quot;&gt;&lt;code class=&quot;hljs language-matlab&quot;&gt;format long g\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;This command will show the FULL value of the number. It&apos;s likely to be something like 24.00000021321 != 24.00000123124&lt;/p&gt;\n    ","\n&lt;p&gt;Try writing &lt;/p&gt;\n\n&lt;blockquote&gt;\n  &lt;p&gt;0.1 + 0.1 + 0.1 == 0.3. &lt;/p&gt;\n&lt;/blockquote&gt;\n\n&lt;p&gt;Warning: You might be surprised about the result!&lt;/p&gt;\n    ","\n&lt;p&gt;Maybe the two numbers are really 24.0 and 24.000000001 but you&apos;re not seeing all the decimal places.&lt;/p&gt;\n    ","\n&lt;p&gt;Check out the &lt;a href=&quot;https://www.mathworks.com/help/matlab/ref/eps.html&quot; rel=&quot;nofollow noreferrer&quot;&gt;Matlab EPS function&lt;/a&gt;.&lt;/p&gt;\n\n&lt;p&gt;Matlab uses floating point math up to 16 digits of precision (only 5 are displayed).&lt;/p&gt;\n    "],"id":545,"title":"Why is 24.0000 not equal to 24.0000 in MATLAB?","content":"\n                \n&lt;p&gt;I am writing a program where I need to delete duplicate points stored in a matrix. The problem is that when it comes to check whether those points are in the matrix, MATLAB can&apos;t recognize them in the matrix although they exist.&lt;/p&gt;\n\n&lt;p&gt;In the following code, &lt;code&gt;intersections&lt;/code&gt; function gets the intersection points:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-matlab s-code-block&quot;&gt;&lt;code class=&quot;hljs language-matlab&quot;&gt;[points(:,&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;), points(:,&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;)] = intersections(...\n    obj.modifiedVGVertices(&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;,:), obj.modifiedVGVertices(&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;,:), ...\n    [vertex1(&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;) vertex2(&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;)], [vertex1(&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;) vertex2(&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;)]);\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;The result:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-matlab s-code-block&quot;&gt;&lt;code class=&quot;hljs language-matlab&quot;&gt;&amp;gt;&amp;gt; points\npoints =\n   &lt;span class=&quot;hljs-number&quot;&gt;12.0000&lt;/span&gt;   &lt;span class=&quot;hljs-number&quot;&gt;15.0000&lt;/span&gt;\n   &lt;span class=&quot;hljs-number&quot;&gt;33.0000&lt;/span&gt;   &lt;span class=&quot;hljs-number&quot;&gt;24.0000&lt;/span&gt;\n   &lt;span class=&quot;hljs-number&quot;&gt;33.0000&lt;/span&gt;   &lt;span class=&quot;hljs-number&quot;&gt;24.0000&lt;/span&gt;\n\n&amp;gt;&amp;gt; vertex1\nvertex1 =\n    &lt;span class=&quot;hljs-number&quot;&gt;12&lt;/span&gt;\n    &lt;span class=&quot;hljs-number&quot;&gt;15&lt;/span&gt;\n\n&amp;gt;&amp;gt; vertex2    \nvertex2 =\n    &lt;span class=&quot;hljs-number&quot;&gt;33&lt;/span&gt;\n    &lt;span class=&quot;hljs-number&quot;&gt;24&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Two points (&lt;code&gt;vertex1&lt;/code&gt; and &lt;code&gt;vertex2&lt;/code&gt;) should be eliminated from the result. It should be done by the below commands:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-matlab s-code-block&quot;&gt;&lt;code class=&quot;hljs language-matlab&quot;&gt;points = points((points(:,&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;) ~= vertex1(&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;)) | (points(:,&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;) ~= vertex1(&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;)), :);\npoints = points((points(:,&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;) ~= vertex2(&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;)) | (points(:,&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;) ~= vertex2(&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;)), :);\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;After doing that, we have this unexpected outcome:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-matlab s-code-block&quot;&gt;&lt;code class=&quot;hljs language-matlab&quot;&gt;&amp;gt;&amp;gt; points\npoints =\n   &lt;span class=&quot;hljs-number&quot;&gt;33.0000&lt;/span&gt;   &lt;span class=&quot;hljs-number&quot;&gt;24.0000&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;The outcome should be an empty matrix. As you can see, the first (or second?) pair of &lt;code&gt;[33.0000 24.0000]&lt;/code&gt; has been eliminated, but not the second one.&lt;/p&gt;\n\n&lt;p&gt;Then I checked these two expressions:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-matlab s-code-block&quot;&gt;&lt;code class=&quot;hljs language-matlab&quot;&gt;&amp;gt;&amp;gt; points(&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;) ~= vertex2(&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;)\n&lt;span class=&quot;hljs-built_in&quot;&gt;ans&lt;/span&gt; =\n     &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;\n&amp;gt;&amp;gt; points(&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;) ~= vertex2(&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;)\n&lt;span class=&quot;hljs-built_in&quot;&gt;ans&lt;/span&gt; =\n     &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;   &lt;span class=&quot;hljs-comment&quot;&gt;% &amp;lt;-- It means 24.0000 is not equal to 24.0000?&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;What is the problem?&lt;/p&gt;\n\n&lt;hr&gt;\n\n&lt;p&gt;More surprisingly, I made a new script that has only these commands:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-matlab s-code-block&quot;&gt;&lt;code class=&quot;hljs language-matlab&quot;&gt;points = [&lt;span class=&quot;hljs-number&quot;&gt;12.0000&lt;/span&gt;   &lt;span class=&quot;hljs-number&quot;&gt;15.0000&lt;/span&gt;\n          &lt;span class=&quot;hljs-number&quot;&gt;33.0000&lt;/span&gt;   &lt;span class=&quot;hljs-number&quot;&gt;24.0000&lt;/span&gt;\n          &lt;span class=&quot;hljs-number&quot;&gt;33.0000&lt;/span&gt;   &lt;span class=&quot;hljs-number&quot;&gt;24.0000&lt;/span&gt;];\n\nvertex1 = [&lt;span class=&quot;hljs-number&quot;&gt;12&lt;/span&gt; ;  &lt;span class=&quot;hljs-number&quot;&gt;15&lt;/span&gt;];\nvertex2 = [&lt;span class=&quot;hljs-number&quot;&gt;33&lt;/span&gt; ;  &lt;span class=&quot;hljs-number&quot;&gt;24&lt;/span&gt;];\n\npoints = points((points(:,&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;) ~= vertex1(&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;)) | (points(:,&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;) ~= vertex1(&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;)), :);\npoints = points((points(:,&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;) ~= vertex2(&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;)) | (points(:,&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;) ~= vertex2(&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;)), :);\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;The result as expected:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-matlab s-code-block&quot;&gt;&lt;code class=&quot;hljs language-matlab&quot;&gt;&amp;gt;&amp;gt; points\npoints =  \n   Empty matrix: &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;-by&lt;span class=&quot;hljs-number&quot;&gt;-2&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n    ","slug":"why-is-24.0000-not-equal-to-24.0000-in-matlab-1657388376753","postType":"QUESTION","createdAt":"2022-07-09T17:39:36.000Z","updatedAt":"2022-07-09T17:39:36.000Z","tags":[{"id":2657,"name":"matlab","slug":"matlab","createdAt":"2022-07-09T17:39:36.000Z","updatedAt":"2022-07-09T17:39:36.000Z","Questions_Tags":{"questionId":545,"tagId":2657}}],"relatedQuestions":[{"title":"Why is 24.0000 not equal to 24.0000 in MATLAB?","slug":"why-is-24.0000-not-equal-to-24.0000-in-matlab-1657388376753","tags":[{"name":"matlab","Questions_Tags":{"questionId":545,"tagId":2657}}]}]},"randomQuestions":[{"title":"How to access a local variable from a different function using pointers?","slug":"how-to-access-a-local-variable-from-a-different-function-using-pointers-1657388159760"},{"title":"Reference - What does this error mean in PHP?","slug":"reference-what-does-this-error-mean-in-php-1657384301782"},{"title":"How to horizontally center an element","slug":"how-to-horizontally-center-an-element-1657384634147"},{"title":"Use of 'prototype' vs. 'this' in JavaScript?","slug":"use-of-'prototype'-vs.-'this'-in-javascript-1657388117307"},{"title":"What is the best way to detect a mobile device?","slug":"what-is-the-best-way-to-detect-a-mobile-device-1657387665025"},{"title":"How do I make a flat list out of a list of lists?","slug":"how-do-i-make-a-flat-list-out-of-a-list-of-lists-1657384500439"},{"title":"Is floating point math broken?","slug":"is-floating-point-math-broken-1657384238910"},{"title":"How do I print my Java object without getting \"SomeType@2f92e0f4\"?","slug":"how-do-i-print-my-java-object-without-getting-\"sometype@2f92e0f4\"-1657384731950"},{"title":"How does the \"this\" keyword work, and when should it be used?","slug":"how-does-the-\"this\"-keyword-work-and-when-should-it-be-used-1657384384385"},{"title":"Performance optimization strategies of last resort [closed]","slug":"performance-optimization-strategies-of-last-resort-closed-1657388420614"},{"title":"What does a \"Cannot find symbol\" or \"Cannot resolve symbol\" error mean?","slug":"what-does-a-\"cannot-find-symbol\"-or-\"cannot-resolve-symbol\"-error-mean-1657384492160"},{"title":"How do I count the occurrences of a list item?","slug":"how-do-i-count-the-occurrences-of-a-list-item-1657387916234"},{"title":"What is the difference between __str__ and __repr__?","slug":"what-is-the-difference-between-__str__-and-__repr__-1657387738760"},{"title":"What is move semantics?","slug":"what-is-move-semantics-1657387702625"},{"title":"How to serve static files in Flask","slug":"how-to-serve-static-files-in-flask-1657387862496"},{"title":"Does Python have a ternary conditional operator?","slug":"does-python-have-a-ternary-conditional-operator-1657387555448"},{"title":"How do I detect a click outside an element?","slug":"how-do-i-detect-a-click-outside-an-element-1657387505351"},{"title":"Scanner is skipping nextLine() after using next() or nextFoo()?","slug":"scanner-is-skipping-nextline()-after-using-next()-or-nextfoo()-1657384379697"},{"title":"PHP parse/syntax errors; and how to solve them","slug":"php-parsesyntax-errors-and-how-to-solve-them-1657384264713"},{"title":"What is the !! (not not) operator in JavaScript?","slug":"what-is-the-!!-(not-not)-operator-in-javascript-1657387947844"}]},"__N_SSG":true}