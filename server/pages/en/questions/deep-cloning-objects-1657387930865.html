<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><meta name="twitter:card" content="summary_large_image"/><meta name="twitter:site" content="@solutionschecker.com"/><meta name="twitter:creator" content="@solutionschecker.com"/><meta property="og:url" content="https://solutionschecker.com"/><meta property="og:type" content="website"/><meta property="og:image" content="https://solutionschecker.com/solutions-checker-banner.png"/><meta property="og:image:alt" content="Find solution for coding, HTML, CSS, JAVASCRIPT, MYSQL, PHP, PYTHON,... quickly. - solutionschecker.com"/><script type="application/ld+json">{"@context":"https://schema.org","@type":"Organization","logo":"/logo.svg","url":"https://solutionschecker.com"}</script><title>Deep cloning objects | Solutions Checker</title><meta name="robots" content="index,follow"/><meta name="description" content="I want to do something like:

MyObject myObj = GetMyObj(); // Create and fill a new object
MyObject newObj = myObj.Clone();


And then make changes to the new object that are not reflected in the original object.

I don&#x27;t often need this functionality, so when it&#x27;s been necessary, I&#x27;ve resorted to creating a new object and then copying each property individually, but it always leaves me with the feeling that there is a better or more elegant way of handling the situation.

How can I clone or deep copy an object so that the cloned object can be modified without any changes being reflected in the original object?
    "/><meta property="og:title" content="Deep cloning objects | Solutions Checker"/><meta property="og:description" content="I want to do something like:

MyObject myObj = GetMyObj(); // Create and fill a new object
MyObject newObj = myObj.Clone();


And then make changes to the new object that are not reflected in the original object.

I don&#x27;t often need this functionality, so when it&#x27;s been necessary, I&#x27;ve resorted to creating a new object and then copying each property individually, but it always leaves me with the feeling that there is a better or more elegant way of handling the situation.

How can I clone or deep copy an object so that the cloned object can be modified without any changes being reflected in the original object?
    "/><script type="application/ld+json">{"@context":"https://schema.org","@type":"QAPage","mainEntity":{"name":"Deep cloning objects","text":"I want to do something like:\n\nMyObject myObj = GetMyObj(); // Create and fill a new object\nMyObject newObj = myObj.Clone();\n\n\nAnd then make changes to the new object that are not reflected in the original object.\n\nI don&apos;t often need this functionality, so when it&apos;s been necessary, I&apos;ve resorted to creating a new object and then copying each property individually, but it always leaves me with the feeling that there is a better or more elegant way of handling the situation.\n\nHow can I clone or deep copy an object so that the cloned object can be modified without any changes being reflected in the original object?\n    ","answerCount":30,"upVoteCount":500,"suggestedAnswer":[{"text":"Whereas one approach is to implement the ICloneable interface (described here, so I won&apos;t regurgitate), here&apos;s a nice deep clone object copier I found on The Code Project a while ago and incorporated it into our code.\nAs mentioned elsewhere, it requires your objects to be serializable.\nusing System;\nusing System.IO;\nusing System.Runtime.Serialization;\nusing System.Runtime.Serialization.Formatters.Binary;\n\n/// &lt;summary&gt;\n/// Reference Article http://www.codeproject.com/KB/tips/SerializedObjectCloner.aspx\n/// Provides a method for performing a deep copy of an object.\n/// Binary Serialization is used to perform the copy.\n/// &lt;/summary&gt;\npublic static class ObjectCopier\n{\n    /// &lt;summary&gt;\n    /// Perform a deep copy of the object via serialization.\n    /// &lt;/summary&gt;\n    /// &lt;typeparam name=&quot;T&quot;&gt;The type of object being copied.&lt;/typeparam&gt;\n    /// &lt;param name=&quot;source&quot;&gt;The object instance to copy.&lt;/param&gt;\n    /// &lt;returns&gt;A deep copy of the object.&lt;/returns&gt;\n    public static T Clone&lt;T&gt;(T source)\n    {\n        if (!typeof(T).IsSerializable)\n        {\n            throw new ArgumentException(&quot;The type must be serializable.&quot;, nameof(source));\n        }\n\n        // Don&apos;t serialize a null object, simply return the default for that object\n        if (ReferenceEquals(source, null)) return default;\n\n        using var Stream stream = new MemoryStream();\n        IFormatter formatter = new BinaryFormatter();\n        formatter.Serialize(stream, source);\n        stream.Seek(0, SeekOrigin.Begin);\n        return (T)formatter.Deserialize(stream);\n    }\n}\n\nThe idea is that it serializes your object and then deserializes it into a fresh object. The benefit is that you don&apos;t have to concern yourself about cloning everything when an object gets too complex.\nIn case of you prefer to use the new extension methods of C# 3.0, change the method to have the following signature:\npublic static T Clone&lt;T&gt;(this T source)\n{\n   // ...\n}\n\nNow the method call simply becomes objectBeingCloned.Clone();.\nEDIT (January 10 2015) Thought I&apos;d revisit this, to mention I recently started using (Newtonsoft) Json to do this, it should be lighter, and avoids the overhead of [Serializable] tags. (NB @atconway has pointed out in the comments that private members are not cloned using the JSON method)\n/// &lt;summary&gt;\n/// Perform a deep Copy of the object, using Json as a serialization method. NOTE: Private members are not cloned using this method.\n/// &lt;/summary&gt;\n/// &lt;typeparam name=&quot;T&quot;&gt;The type of object being copied.&lt;/typeparam&gt;\n/// &lt;param name=&quot;source&quot;&gt;The object instance to copy.&lt;/param&gt;\n/// &lt;returns&gt;The copied object.&lt;/returns&gt;\npublic static T CloneJson&lt;T&gt;(this T source)\n{            \n    // Don&apos;t serialize a null object, simply return the default for that object\n    if (ReferenceEquals(source, null)) return default;\n\n    // initialize inner objects individually\n    // for example in default constructor some list property initialized with some values,\n    // but in &apos;source&apos; these items are cleaned -\n    // without ObjectCreationHandling.Replace default constructor values will be added to result\n    var deserializeSettings = new JsonSerializerSettings {ObjectCreationHandling = ObjectCreationHandling.Replace};\n\n    return JsonConvert.DeserializeObject&lt;T&gt;(JsonConvert.SerializeObject(source), deserializeSettings);\n}\n\n    ","url":"/questions/[slug]#solution1","@type":"Answer","upvoteCount":0},{"text":"I wanted a cloner for very simple objects of mostly primitives and lists.  If your object is out of the box JSON serializable then this method will do the trick.  This requires no modification or implementation of interfaces on the cloned class, just a JSON serializer like JSON.NET.\n\npublic static T Clone&lt;T&gt;(T source)\n{\n    var serialized = JsonConvert.SerializeObject(source);\n    return JsonConvert.DeserializeObject&lt;T&gt;(serialized);\n}\n\n\nAlso, you can use this extension method\n\npublic static class SystemExtension\n{\n    public static T Clone&lt;T&gt;(this T source)\n    {\n        var serialized = JsonConvert.SerializeObject(source);\n        return JsonConvert.DeserializeObject&lt;T&gt;(serialized);\n    }\n}\n\n    ","url":"/questions/[slug]#solution2","@type":"Answer","upvoteCount":0},{"text":"The reason not to use ICloneable is not because it doesn&apos;t have a generic interface.  The reason not to use it is because it&apos;s vague.  It doesn&apos;t make clear whether you&apos;re getting a shallow or a deep copy; that&apos;s up to the implementer.\n\nYes, MemberwiseClone makes a shallow copy, but the opposite of MemberwiseClone isn&apos;t Clone; it would be, perhaps, DeepClone, which doesn&apos;t exist.  When you use an object through its ICloneable interface, you can&apos;t know which kind of cloning the underlying object performs.  (And XML comments won&apos;t make it clear, because you&apos;ll get the interface comments rather than the ones on the object&apos;s Clone method.)\n\nWhat I usually do is simply make a Copy method that does exactly what I want.\n    ","url":"/questions/[slug]#solution3","@type":"Answer","upvoteCount":0},{"text":"After much much reading about many of the options linked here, and possible solutions for this issue, I believe all the options are summarized pretty well at Ian P&apos;s link (all other options are variations of those) and the best solution is provided by Pedro77&apos;s link on the question comments.\n\nSo I&apos;ll just copy relevant parts of those 2 references here. That way we can have:\n\nThe best thing to do for cloning objects in C sharp!\n\nFirst and foremost, those are all our options:\n\n\nManually with ICloneable, which is Shallow and not Type-Safe\nMemberwiseClone, which uses ICloneable\nReflection by using Activator.CreateInstance and recursive MemberwiseClone\nSerialization, as pointed by johnc&apos;s preferred answer\nIntermediate Language, which I got no idea how works\nExtension Methods, such as this custom clone framework by Havard Straden\nExpression Trees\n\n\nThe article Fast Deep Copy by Expression Trees   has  also performance comparison of cloning by Serialization, Reflection and Expression Trees.\n\nWhy I choose ICloneable (i.e. manually)\n\nMr Venkat Subramaniam (redundant link here) explains in much detail why.\n\nAll his article circles around an example that tries to be applicable for most cases, using 3 objects: Person, Brain and City. We want to clone a person, which will have its own brain but the same city. You can either picture all problems any of the other methods above can bring or read the article.\n\nThis is my slightly modified version of his conclusion:\n\n\n  Copying an object by specifying New followed by the class name often leads to code that is not extensible. Using clone, the application of prototype pattern, is a better way to achieve this. However, using clone as it is provided in C# (and Java) can be quite problematic as well. It is better to provide a protected (non-public) copy constructor and invoke that from the clone method. This gives us the ability to delegate the task of creating an object to an instance of a class itself, thus providing extensibility and also, safely creating the objects using the protected copy constructor.\n\n\nHopefully this implementation can make things clear:\n\npublic class Person : ICloneable\n{\n    private final Brain brain; // brain is final since I do not want \n                // any transplant on it once created!\n    private int age;\n    public Person(Brain aBrain, int theAge)\n    {\n        brain = aBrain; \n        age = theAge;\n    }\n    protected Person(Person another)\n    {\n        Brain refBrain = null;\n        try\n        {\n            refBrain = (Brain) another.brain.clone();\n            // You can set the brain in the constructor\n        }\n        catch(CloneNotSupportedException e) {}\n        brain = refBrain;\n        age = another.age;\n    }\n    public String toString()\n    {\n        return &quot;This is person with &quot; + brain;\n        // Not meant to sound rude as it reads!\n    }\n    public Object clone()\n    {\n        return new Person(this);\n    }\n    \n}\n\n\nNow consider having a class derive from Person.\n\npublic class SkilledPerson extends Person\n{\n    private String theSkills;\n    public SkilledPerson(Brain aBrain, int theAge, String skills)\n    {\n        super(aBrain, theAge);\n        theSkills = skills;\n    }\n    protected SkilledPerson(SkilledPerson another)\n    {\n        super(another);\n        theSkills = another.theSkills;\n    }\n\n    public Object clone()\n    {\n        return new SkilledPerson(this);\n    }\n    public String toString()\n    {\n        return &quot;SkilledPerson: &quot; + super.toString();\n    }\n}\n\n\nYou may try running the following code:\n\npublic class User\n{\n    public static void play(Person p)\n    {\n        Person another = (Person) p.clone();\n        System.out.println(p);\n        System.out.println(another);\n    }\n    public static void main(String[] args)\n    {\n        Person sam = new Person(new Brain(), 1);\n        play(sam);\n        SkilledPerson bob = new SkilledPerson(new SmarterBrain(), 1, &quot;Writer&quot;);\n        play(bob);\n    }\n}\n\n\nThe output produced will be:\n\nThis is person with Brain@1fcc69\nThis is person with Brain@253498\nSkilledPerson: This is person with SmarterBrain@1fef6f\nSkilledPerson: This is person with SmarterBrain@209f4e\n\n\nObserve that, if we keep a count of the number of objects, the clone as implemented here will keep a correct count of the number of objects.\n    ","url":"/questions/[slug]#solution4","@type":"Answer","upvoteCount":0},{"text":"I prefer a copy constructor to a clone. The intent is clearer.\n    ","url":"/questions/[slug]#solution5","@type":"Answer","upvoteCount":0},{"text":"Simple extension method to copy all the public properties. Works for any objects and does not require class to be [Serializable]. Can be extended for other access level.\n\npublic static void CopyTo( this object S, object T )\n{\n    foreach( var pS in S.GetType().GetProperties() )\n    {\n        foreach( var pT in T.GetType().GetProperties() )\n        {\n            if( pT.Name != pS.Name ) continue;\n            ( pT.GetSetMethod() ).Invoke( T, new object[] \n            { pS.GetGetMethod().Invoke( S, null ) } );\n        }\n    };\n}\n\n    ","url":"/questions/[slug]#solution6","@type":"Answer","upvoteCount":0},{"text":"I&apos;ve just created CloneExtensions library project. It performs fast, deep clone using simple assignment operations generated by Expression Tree runtime code compilation.\n\nHow to use it?\n\nInstead of writing your own Clone or Copy methods with a tone of assignments between fields and properties make the program do it for yourself, using Expression Tree. GetClone&lt;T&gt;() method marked as extension method allows you to simply call it on your instance:\n\nvar newInstance = source.GetClone();\n\n\nYou can choose what should be copied from source to newInstance using CloningFlags enum:\n\nvar newInstance \n    = source.GetClone(CloningFlags.Properties | CloningFlags.CollectionItems);\n\n\nWhat can be cloned?\n\n\nPrimitive (int, uint, byte, double, char, etc.), known immutable\ntypes (DateTime, TimeSpan, String) and delegates (including\nAction, Func, etc)\nNullable\nT[] arrays\nCustom classes and structs, including generic classes and structs.\n\n\nFollowing class/struct members are cloned internally:\n\n\nValues of public, not readonly fields\nValues of public properties with both get and set accessors\nCollection items for types implementing ICollection\n\n\nHow fast it is?\n\nThe solution is faster then reflection, because members information has to be gathered only once, before GetClone&lt;T&gt; is used for the first time for given type T.\n\nIt&apos;s also faster than serialization-based solution when you clone more then couple instances of the same type T.\n\nand more...\n\nRead more about generated expressions on documentation.\n\nSample expression debug listing for List&lt;int&gt;:\n\n.Lambda #Lambda1&lt;System.Func`4[System.Collections.Generic.List`1[System.Int32],CloneExtensions.CloningFlags,System.Collections.Generic.IDictionary`2[System.Type,System.Func`2[System.Object,System.Object]],System.Collections.Generic.List`1[System.Int32]]&gt;(\n    System.Collections.Generic.List`1[System.Int32] $source,\n    CloneExtensions.CloningFlags $flags,\n    System.Collections.Generic.IDictionary`2[System.Type,System.Func`2[System.Object,System.Object]] $initializers) {\n    .Block(System.Collections.Generic.List`1[System.Int32] $target) {\n        .If ($source == null) {\n            .Return #Label1 { null }\n        } .Else {\n            .Default(System.Void)\n        };\n        .If (\n            .Call $initializers.ContainsKey(.Constant&lt;System.Type&gt;(System.Collections.Generic.List`1[System.Int32]))\n        ) {\n            $target = (System.Collections.Generic.List`1[System.Int32]).Call ($initializers.Item[.Constant&lt;System.Type&gt;(System.Collections.Generic.List`1[System.Int32])]\n            ).Invoke((System.Object)$source)\n        } .Else {\n            $target = .New System.Collections.Generic.List`1[System.Int32]()\n        };\n        .If (\n            ((System.Byte)$flags &amp; (System.Byte).Constant&lt;CloneExtensions.CloningFlags&gt;(Fields)) == (System.Byte).Constant&lt;CloneExtensions.CloningFlags&gt;(Fields)\n        ) {\n            .Default(System.Void)\n        } .Else {\n            .Default(System.Void)\n        };\n        .If (\n            ((System.Byte)$flags &amp; (System.Byte).Constant&lt;CloneExtensions.CloningFlags&gt;(Properties)) == (System.Byte).Constant&lt;CloneExtensions.CloningFlags&gt;(Properties)\n        ) {\n            .Block() {\n                $target.Capacity = .Call CloneExtensions.CloneFactory.GetClone(\n                    $source.Capacity,\n                    $flags,\n                    $initializers)\n            }\n        } .Else {\n            .Default(System.Void)\n        };\n        .If (\n            ((System.Byte)$flags &amp; (System.Byte).Constant&lt;CloneExtensions.CloningFlags&gt;(CollectionItems)) == (System.Byte).Constant&lt;CloneExtensions.CloningFlags&gt;(CollectionItems)\n        ) {\n            .Block(\n                System.Collections.Generic.IEnumerator`1[System.Int32] $var1,\n                System.Collections.Generic.ICollection`1[System.Int32] $var2) {\n                $var1 = (System.Collections.Generic.IEnumerator`1[System.Int32]).Call $source.GetEnumerator();\n                $var2 = (System.Collections.Generic.ICollection`1[System.Int32])$target;\n                .Loop  {\n                    .If (.Call $var1.MoveNext() != False) {\n                        .Call $var2.Add(.Call CloneExtensions.CloneFactory.GetClone(\n                                $var1.Current,\n                                $flags,\n\n\n                         $initializers))\n                } .Else {\n                    .Break #Label2 { }\n                }\n            }\n            .LabelTarget #Label2:\n        }\n    } .Else {\n        .Default(System.Void)\n    };\n    .Label\n        $target\n    .LabelTarget #Label1:\n}\n\n\n}\n\nwhat has the same meaning like following c# code:\n\n(source, flags, initializers) =&gt;\n{\n    if(source == null)\n        return null;\n\n    if(initializers.ContainsKey(typeof(List&lt;int&gt;))\n        target = (List&lt;int&gt;)initializers[typeof(List&lt;int&gt;)].Invoke((object)source);\n    else\n        target = new List&lt;int&gt;();\n\n    if((flags &amp; CloningFlags.Properties) == CloningFlags.Properties)\n    {\n        target.Capacity = target.Capacity.GetClone(flags, initializers);\n    }\n\n    if((flags &amp; CloningFlags.CollectionItems) == CloningFlags.CollectionItems)\n    {\n        var targetCollection = (ICollection&lt;int&gt;)target;\n        foreach(var item in (ICollection&lt;int&gt;)source)\n        {\n            targetCollection.Add(item.Clone(flags, initializers));\n        }\n    }\n\n    return target;\n}\n\n\nIsn&apos;t it quite like how you&apos;d write your own Clone method for List&lt;int&gt;?\n    ","url":"/questions/[slug]#solution7","@type":"Answer","upvoteCount":0},{"text":"If you&apos;re already using a 3rd party application like ValueInjecter or Automapper, you can do something like this:\n\nMyObject oldObj; // The existing object to clone\n\nMyObject newObj = new MyObject();\nnewObj.InjectFrom(oldObj); // Using ValueInjecter syntax\n\n\nUsing this method you don&apos;t have to implement ISerializable or ICloneable on your objects. This is common with the MVC/MVVM pattern, so simple tools like this have been created.\n\nsee the ValueInjecter deep cloning sample on GitHub.\n    ","url":"/questions/[slug]#solution8","@type":"Answer","upvoteCount":0},{"text":"Well I was having problems using ICloneable in Silverlight, but I liked the idea of seralization, I can seralize XML, so I did this:\nstatic public class SerializeHelper\n{\n    //Michael White, Holly Springs Consulting, 2009\n    //michael@hollyspringsconsulting.com\n    public static T DeserializeXML&lt;T&gt;(string xmlData) \n        where T:new()\n    {\n        if (string.IsNullOrEmpty(xmlData))\n            return default(T);\n\n        TextReader tr = new StringReader(xmlData);\n        T DocItms = new T();\n        XmlSerializer xms = new XmlSerializer(DocItms.GetType());\n        DocItms = (T)xms.Deserialize(tr);\n\n        return DocItms == null ? default(T) : DocItms;\n    }\n\n    public static string SeralizeObjectToXML&lt;T&gt;(T xmlObject)\n    {\n        StringBuilder sbTR = new StringBuilder();\n        XmlSerializer xmsTR = new XmlSerializer(xmlObject.GetType());\n        XmlWriterSettings xwsTR = new XmlWriterSettings();\n        \n        XmlWriter xmwTR = XmlWriter.Create(sbTR, xwsTR);\n        xmsTR.Serialize(xmwTR,xmlObject);\n        \n        return sbTR.ToString();\n    }\n\n    public static T CloneObject&lt;T&gt;(T objClone) \n        where T:new()\n    {\n        string GetString = SerializeHelper.SeralizeObjectToXML&lt;T&gt;(objClone);\n        return SerializeHelper.DeserializeXML&lt;T&gt;(GetString);\n    }\n}\n\n    ","url":"/questions/[slug]#solution9","@type":"Answer","upvoteCount":0},{"text":"The best is to implement an extension method like\n\npublic static T DeepClone&lt;T&gt;(this T originalObject)\n{ /* the cloning code */ }\n\n\nand then use it anywhere in the solution by\n\nvar copy = anyObject.DeepClone();\n\n\nWe can have the following three implementations:\n\n\nBy Serialization (the shortest code)\nBy Reflection - 5x faster\nBy Expression Trees - 20x faster\n\n\nAll linked methods are well working and were deeply tested.\n    ","url":"/questions/[slug]#solution10","@type":"Answer","upvoteCount":0},{"text":"The short answer is you inherit from the ICloneable interface and then implement the .clone function. Clone should do a memberwise copy and perform a deep copy on any member that requires it, then return the resulting object. This is a recursive operation ( it requires that all members of the class you want to clone are either value types or implement ICloneable and that their members are either value types or implement ICloneable, and so on).\n\nFor a more detailed explanation on Cloning using ICloneable, check out this article.\n\nThe long answer is &quot;it depends&quot;. As mentioned by others, ICloneable is not supported by generics, requires special considerations for circular class references, and is actually viewed by some as a &quot;mistake&quot; in the .NET Framework. The serialization method depends on your objects being serializable, which they may not be and you may have no control over. There is still much debate in the community over which is the &quot;best&quot; practice. In reality, none of the solutions are the one-size fits all best practice for all situations like ICloneable was originally interpreted to be.\n\nSee the this Developer&apos;s Corner article for a few more options (credit to Ian).\n    ","url":"/questions/[slug]#solution11","@type":"Answer","upvoteCount":0},{"text":"\nBasically you need to implement ICloneable interface and then realize object structure copying. \nIf it&apos;s deep copy of all members, you need to insure (not relating on solution you choose) that all children are clonable as well. \nSometimes you need to be aware of some restriction during this process, for example if you copying the ORM objects most of frameworks allow only one object attached to the session and you MUST NOT make clones of this object, or if it&apos;s possible you need to care about session attaching of these objects.\n\n\nCheers.\n    ","url":"/questions/[slug]#solution12","@type":"Answer","upvoteCount":0},{"text":"DeepCloner: Quick, easy, effective NuGet package to solve cloning\n\nAfter reading all answers I was surprised no one mentioned this excellent package: \n\nDeepCloner GitHub project  \n\nDeepCloner NuGet package\n\nElaborating a bit on its README, here are the reason why we chose it at work:\n\n\n  \n  It can deep or shallow copy \n  In deep cloning all object graph is maintained. \n  Uses code-generation in runtime, as result cloning is blazingly fast\n  Objects copied by internal structure, no methods or ctors called\n  You don&apos;t need to mark classes somehow (like Serializable-attribute, or implement interfaces)\n  No requirement to specify object type for cloning. Object can be casted to interface or as an abstract object (e.g. you can clone array of ints as abstract Array or IEnumerable; even null can be cloned without any errors)\n  Cloned object doesn&apos;t have any ability to determine that he is clone (except with very specific methods)\n  \n\n\nUsage:\n\nvar deepClone = new { Id = 1, Name = &quot;222&quot; }.DeepClone();\nvar shallowClone = new { Id = 1, Name = &quot;222&quot; }.ShallowClone();\n\n\nPerformance:\n\nThe README contains a performance comparison of various cloning libraries and methods: DeepCloner Performance.\n\nRequirements:\n\n\n.NET 4.0 or higher or .NET Standard 1.3 (.NET Core)\nRequires Full Trust permission set or Reflection permission (MemberAccess)\n\n    ","url":"/questions/[slug]#solution13","@type":"Answer","upvoteCount":0},{"text":"EDIT: project is discontinued\n\nIf you want true cloning to unknown types you can take a look at\nfastclone.\n\nThat&apos;s expression based cloning working about 10 times faster than binary serialization and maintaining complete object graph integrity.\n\nThat means: if you refer multiple times to the same object in your hierachy, the clone will also have a single instance beeing referenced.\n\nThere is no need for interfaces, attributes or any other modification to the objects being cloned.\n    ","url":"/questions/[slug]#solution14","@type":"Answer","upvoteCount":0},{"text":"Keep things simple and use AutoMapper as others mentioned, it&apos;s a simple little library to map one object to another... To copy an object to another with the same type, all you need is three lines of code:\n\nMyType source = new MyType();\nMapper.CreateMap&lt;MyType, MyType&gt;();\nMyType target = Mapper.Map&lt;MyType, MyType&gt;(source);\n\n\nThe target object is now a copy of the source object.\nNot simple enough? Create an extension method to use everywhere in your solution:\n\npublic static T Copy&lt;T&gt;(this T source)\n{\n    T copy = default(T);\n    Mapper.CreateMap&lt;T, T&gt;();\n    copy = Mapper.Map&lt;T, T&gt;(source);\n    return copy;\n}\n\n\nThe extension method can be used as follow:\n\nMyType copy = source.Copy();\n\n    ","url":"/questions/[slug]#solution15","@type":"Answer","upvoteCount":0},{"text":"In general, you implement the ICloneable interface and implement Clone yourself.\nC# objects have a built-in MemberwiseClone method that performs a shallow copy that can help you out for all the primitives.\n\nFor a deep copy, there is no way it can know how to automatically do it.\n    ","url":"/questions/[slug]#solution16","@type":"Answer","upvoteCount":0},{"text":"I came up with this to overcome a .NET shortcoming having to manually deep copy List&lt;T&gt;.\n\nI use this:\n\nstatic public IEnumerable&lt;SpotPlacement&gt; CloneList(List&lt;SpotPlacement&gt; spotPlacements)\n{\n    foreach (SpotPlacement sp in spotPlacements)\n    {\n        yield return (SpotPlacement)sp.Clone();\n    }\n}\n\n\nAnd at another place:\n\npublic object Clone()\n{\n    OrderItem newOrderItem = new OrderItem();\n    ...\n    newOrderItem._exactPlacements.AddRange(SpotPlacement.CloneList(_exactPlacements));\n    ...\n    return newOrderItem;\n}\n\n\nI tried to come up with oneliner that does this, but it&apos;s not possible, due to yield not working inside anonymous method blocks.\n\nBetter still, use generic List&lt;T&gt; cloner:\n\nclass Utility&lt;T&gt; where T : ICloneable\n{\n    static public IEnumerable&lt;T&gt; CloneList(List&lt;T&gt; tl)\n    {\n        foreach (T t in tl)\n        {\n            yield return (T)t.Clone();\n        }\n    }\n}\n\n    ","url":"/questions/[slug]#solution17","@type":"Answer","upvoteCount":0},{"text":"Q. Why would I choose this answer?\n\nChoose this answer if you want the fastest speed .NET is capable of.\nIgnore this answer if you want a really, really easy method of cloning.\n\nIn other words, go with another answer unless you have a performance bottleneck that needs fixing, and you can prove it with a profiler.\n10x faster than other methods\nThe following method of performing a deep clone is:\n\n10x faster than anything that involves serialization/deserialization;\nPretty darn close to the theoretical maximum speed .NET is capable of.\n\nAnd the method ...\nFor ultimate speed, you can use Nested MemberwiseClone to do a deep copy. Its almost the same speed as copying a value struct, and is much faster than (a) reflection or (b) serialization (as described in other answers on this page).\nNote that if you use Nested MemberwiseClone for a deep copy, you have to manually implement a ShallowCopy for each nested level in the class, and a DeepCopy which calls all said ShallowCopy methods to create a complete clone. This is simple: only a few lines in total, see the demo code below.\nHere is the output of the code showing the relative performance difference for 100,000 clones:\n\n1.08 seconds for Nested MemberwiseClone on nested structs\n4.77 seconds for Nested MemberwiseClone on nested classes\n39.93 seconds for Serialization/Deserialization\n\nUsing Nested MemberwiseClone on a class almost as fast as copying a struct, and copying a struct is pretty darn close to the theoretical maximum speed .NET is capable of.\nDemo 1 of shallow and deep copy, using classes and MemberwiseClone:\n  Create Bob\n    Bob.Age=30, Bob.Purchase.Description=Lamborghini\n  Clone Bob &gt;&gt; BobsSon\n  Adjust BobsSon details\n    BobsSon.Age=2, BobsSon.Purchase.Description=Toy car\n  Proof of deep copy: If BobsSon is a true clone, then adjusting BobsSon details will not affect Bob:\n    Bob.Age=30, Bob.Purchase.Description=Lamborghini\n  Elapsed time: 00:00:04.7795670,30000000\n\nDemo 2 of shallow and deep copy, using structs and value copying:\n  Create Bob\n    Bob.Age=30, Bob.Purchase.Description=Lamborghini\n  Clone Bob &gt;&gt; BobsSon\n  Adjust BobsSon details:\n    BobsSon.Age=2, BobsSon.Purchase.Description=Toy car\n  Proof of deep copy: If BobsSon is a true clone, then adjusting BobsSon details will not affect Bob:\n    Bob.Age=30, Bob.Purchase.Description=Lamborghini\n  Elapsed time: 00:00:01.0875454,30000000\n\nDemo 3 of deep copy, using class and serialize/deserialize:\n  Elapsed time: 00:00:39.9339425,30000000\n\nTo understand how to do a deep copy using MemberwiseCopy, here is the demo project that was used to generate the times above:\n// Nested MemberwiseClone example. \n// Added to demo how to deep copy a reference class.\n[Serializable] // Not required if using MemberwiseClone, only used for speed comparison using serialization.\npublic class Person\n{\n    public Person(int age, string description)\n    {\n        this.Age = age;\n        this.Purchase.Description = description;\n    }\n    [Serializable] // Not required if using MemberwiseClone\n    public class PurchaseType\n    {\n        public string Description;\n        public PurchaseType ShallowCopy()\n        {\n            return (PurchaseType)this.MemberwiseClone();\n        }\n    }\n    public PurchaseType Purchase = new PurchaseType();\n    public int Age;\n    // Add this if using nested MemberwiseClone.\n    // This is a class, which is a reference type, so cloning is more difficult.\n    public Person ShallowCopy()\n    {\n        return (Person)this.MemberwiseClone();\n    }\n    // Add this if using nested MemberwiseClone.\n    // This is a class, which is a reference type, so cloning is more difficult.\n    public Person DeepCopy()\n    {\n            // Clone the root ...\n        Person other = (Person) this.MemberwiseClone();\n            // ... then clone the nested class.\n        other.Purchase = this.Purchase.ShallowCopy();\n        return other;\n    }\n}\n// Added to demo how to copy a value struct (this is easy - a deep copy happens by default)\npublic struct PersonStruct\n{\n    public PersonStruct(int age, string description)\n    {\n        this.Age = age;\n        this.Purchase.Description = description;\n    }\n    public struct PurchaseType\n    {\n        public string Description;\n    }\n    public PurchaseType Purchase;\n    public int Age;\n    // This is a struct, which is a value type, so everything is a clone by default.\n    public PersonStruct ShallowCopy()\n    {\n        return (PersonStruct)this;\n    }\n    // This is a struct, which is a value type, so everything is a clone by default.\n    public PersonStruct DeepCopy()\n    {\n        return (PersonStruct)this;\n    }\n}\n// Added only for a speed comparison.\npublic class MyDeepCopy\n{\n    public static T DeepCopy&lt;T&gt;(T obj)\n    {\n        object result = null;\n        using (var ms = new MemoryStream())\n        {\n            var formatter = new BinaryFormatter();\n            formatter.Serialize(ms, obj);\n            ms.Position = 0;\n            result = (T)formatter.Deserialize(ms);\n            ms.Close();\n        }\n        return (T)result;\n    }\n}\n\nThen, call the demo from main:\nvoid MyMain(string[] args)\n{\n    {\n        Console.Write(&quot;Demo 1 of shallow and deep copy, using classes and MemberwiseCopy:\\n&quot;);\n        var Bob = new Person(30, &quot;Lamborghini&quot;);\n        Console.Write(&quot;  Create Bob\\n&quot;);\n        Console.Write(&quot;    Bob.Age={0}, Bob.Purchase.Description={1}\\n&quot;, Bob.Age, Bob.Purchase.Description);\n        Console.Write(&quot;  Clone Bob &gt;&gt; BobsSon\\n&quot;);\n        var BobsSon = Bob.DeepCopy();\n        Console.Write(&quot;  Adjust BobsSon details\\n&quot;);\n        BobsSon.Age = 2;\n        BobsSon.Purchase.Description = &quot;Toy car&quot;;\n        Console.Write(&quot;    BobsSon.Age={0}, BobsSon.Purchase.Description={1}\\n&quot;, BobsSon.Age, BobsSon.Purchase.Description);\n        Console.Write(&quot;  Proof of deep copy: If BobsSon is a true clone, then adjusting BobsSon details will not affect Bob:\\n&quot;);\n        Console.Write(&quot;    Bob.Age={0}, Bob.Purchase.Description={1}\\n&quot;, Bob.Age, Bob.Purchase.Description);\n        Debug.Assert(Bob.Age == 30);\n        Debug.Assert(Bob.Purchase.Description == &quot;Lamborghini&quot;);\n        var sw = new Stopwatch();\n        sw.Start();\n        int total = 0;\n        for (int i = 0; i &lt; 100000; i++)\n        {\n            var n = Bob.DeepCopy();\n            total += n.Age;\n        }\n        Console.Write(&quot;  Elapsed time: {0},{1}\\n\\n&quot;, sw.Elapsed, total);\n    }\n    {               \n        Console.Write(&quot;Demo 2 of shallow and deep copy, using structs:\\n&quot;);\n        var Bob = new PersonStruct(30, &quot;Lamborghini&quot;);\n        Console.Write(&quot;  Create Bob\\n&quot;);\n        Console.Write(&quot;    Bob.Age={0}, Bob.Purchase.Description={1}\\n&quot;, Bob.Age, Bob.Purchase.Description);\n        Console.Write(&quot;  Clone Bob &gt;&gt; BobsSon\\n&quot;);\n        var BobsSon = Bob.DeepCopy();\n        Console.Write(&quot;  Adjust BobsSon details:\\n&quot;);\n        BobsSon.Age = 2;\n        BobsSon.Purchase.Description = &quot;Toy car&quot;;\n        Console.Write(&quot;    BobsSon.Age={0}, BobsSon.Purchase.Description={1}\\n&quot;, BobsSon.Age, BobsSon.Purchase.Description);\n        Console.Write(&quot;  Proof of deep copy: If BobsSon is a true clone, then adjusting BobsSon details will not affect Bob:\\n&quot;);\n        Console.Write(&quot;    Bob.Age={0}, Bob.Purchase.Description={1}\\n&quot;, Bob.Age, Bob.Purchase.Description);                \n        Debug.Assert(Bob.Age == 30);\n        Debug.Assert(Bob.Purchase.Description == &quot;Lamborghini&quot;);\n        var sw = new Stopwatch();\n        sw.Start();\n        int total = 0;\n        for (int i = 0; i &lt; 100000; i++)\n        {\n            var n = Bob.DeepCopy();\n            total += n.Age;\n        }\n        Console.Write(&quot;  Elapsed time: {0},{1}\\n\\n&quot;, sw.Elapsed, total);\n    }\n    {\n        Console.Write(&quot;Demo 3 of deep copy, using class and serialize/deserialize:\\n&quot;);\n        int total = 0;\n        var sw = new Stopwatch();\n        sw.Start();\n        var Bob = new Person(30, &quot;Lamborghini&quot;);\n        for (int i = 0; i &lt; 100000; i++)\n        {\n            var BobsSon = MyDeepCopy.DeepCopy&lt;Person&gt;(Bob);\n            total += BobsSon.Age;\n        }\n        Console.Write(&quot;  Elapsed time: {0},{1}\\n&quot;, sw.Elapsed, total);\n    }\n    Console.ReadKey();\n}\n\nAgain, note that if you use Nested MemberwiseClone for a deep copy, you have to manually implement a ShallowCopy for each nested level in the class, and a DeepCopy which calls all said ShallowCopy methods to create a complete clone. This is simple: only a few lines in total, see the demo code above.\nValue types vs. References Types\nNote that when it comes to cloning an object, there is is a big difference between a &quot;struct&quot; and a &quot;class&quot;:\n\nIf you have a &quot;struct&quot;, it&apos;s a value type so you can just copy it, and the contents will be cloned (but it will only make a shallow clone unless you use the techniques in this post).\nIf you have a &quot;class&quot;, it&apos;s a reference type, so if you copy it, all you are doing is copying the pointer to it. To create a true clone, you have to be more creative, and use differences between value types and references types which creates another copy of the original object in memory.\n\nSee differences between value types and references types.\nChecksums to aid in debugging\n\nCloning objects incorrectly can lead to very difficult-to-pin-down bugs. In production code, I tend to implement a checksum to double check that the object has been cloned properly, and hasn&apos;t been corrupted by another reference to it. This checksum can be switched off in Release mode.\nI find this method quite useful: often, you only want to clone parts of the object, not the entire thing.\n\nReally useful for decoupling many threads from many other threads\nOne excellent use case for this code is feeding clones of a nested class or struct into a queue, to implement the producer / consumer pattern.\n\nWe can have one  (or more) threads modifying a class that they own, then pushing a complete copy of this class into a ConcurrentQueue.\nWe then have one (or more) threads pulling copies of these classes out and dealing with them.\n\nThis works extremely well in practice, and allows us to decouple many threads (the producers) from one or more threads (the consumers).\nAnd this method is blindingly fast too: if we use nested structs, it&apos;s 35x faster than serializing/deserializing nested classes, and allows us to take advantage of all of the threads available on the machine.\nUpdate\nApparently, ExpressMapper is as fast, if not faster, than hand coding such as above. I might have to see how they compare with a profiler.\n    ","url":"/questions/[slug]#solution18","@type":"Answer","upvoteCount":0},{"text":"Disclaimer: I&apos;m the author of the mentioned package.\n\nI was surprised how the top answers to this question in 2019 still use serialization or reflection. \n\nSerialization is limiting (requires attributes, specific constructors, etc.) and is very slow\n\nBinaryFormatter requires the Serializable attribute, JsonConverter requires a parameterless constructor or attributes, neither handle read only fields or interfaces very well and both are 10-30x slower than necessary.\n\nExpression Trees\n\nYou can instead use Expression Trees or Reflection.Emit to generate cloning code only once, then use that compiled code instead of slow reflection or serialization.\n\nHaving come across the problem myself and seeing no satisfactory solution, I decided to create a package that does just that and works with every type and is a almost as fast as custom written code.\n\nYou can find the project on GitHub: https://github.com/marcelltoth/ObjectCloner\n\nUsage\n\nYou can install it from NuGet. Either get the ObjectCloner package and use it as:\n\nvar clone = ObjectCloner.DeepClone(original);\n\n\nor if you don&apos;t mind polluting your object type with extensions get ObjectCloner.Extensions as well and write:\n\nvar clone = original.DeepClone();\n\n\nPerformance\n\nA simple benchmark of cloning a class hierarchy showed performance ~3x faster than using Reflection, ~12x faster than Newtonsoft.Json serialization and ~36x faster than the highly suggested BinaryFormatter.\n    ","url":"/questions/[slug]#solution19","@type":"Answer","upvoteCount":0},{"text":"I&apos;ve seen it implemented through reflection as well. Basically there was a method that would iterate through the members of an object and appropriately copy them to the new object. When it reached reference types or collections I think it did a recursive call on itself. Reflection is expensive, but it worked pretty well.\n    ","url":"/questions/[slug]#solution20","@type":"Answer","upvoteCount":0},{"text":"Here is a deep copy implementation:\n\npublic static object CloneObject(object opSource)\n{\n    //grab the type and create a new instance of that type\n    Type opSourceType = opSource.GetType();\n    object opTarget = CreateInstanceOfType(opSourceType);\n\n    //grab the properties\n    PropertyInfo[] opPropertyInfo = opSourceType.GetProperties(BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance);\n\n    //iterate over the properties and if it has a &apos;set&apos; method assign it from the source TO the target\n    foreach (PropertyInfo item in opPropertyInfo)\n    {\n        if (item.CanWrite)\n        {\n            //value types can simply be &apos;set&apos;\n            if (item.PropertyType.IsValueType || item.PropertyType.IsEnum || item.PropertyType.Equals(typeof(System.String)))\n            {\n                item.SetValue(opTarget, item.GetValue(opSource, null), null);\n            }\n            //object/complex types need to recursively call this method until the end of the tree is reached\n            else\n            {\n                object opPropertyValue = item.GetValue(opSource, null);\n                if (opPropertyValue == null)\n                {\n                    item.SetValue(opTarget, null, null);\n                }\n                else\n                {\n                    item.SetValue(opTarget, CloneObject(opPropertyValue), null);\n                }\n            }\n        }\n    }\n    //return the new item\n    return opTarget;\n}\n\n    ","url":"/questions/[slug]#solution21","@type":"Answer","upvoteCount":0},{"text":"As I couldn&apos;t find a cloner that meets all my requirements in different projects, I created a deep cloner that can be configured and adapted to different code structures instead of adapting my code to meet the cloners requirements. Its achieved by adding annotations to the code that shall be cloned or you just leave the code as it is to have the default behaviour. It uses reflection, type caches and is based on fasterflect. The cloning process is very fast for a huge amount of data and a high object hierarchy (compared to other reflection/serialization based algorithms). \n\nhttps://github.com/kalisohn/CloneBehave\n\nAlso available as a nuget package:\nhttps://www.nuget.org/packages/Clone.Behave/1.0.0\n\nFor example: The following code will deepClone Address, but only perform a shallow copy of the _currentJob field. \n\npublic class Person \n{\n  [DeepClone(DeepCloneBehavior.Shallow)]\n  private Job _currentJob;      \n\n  public string Name { get; set; }\n\n  public Job CurrentJob \n  { \n    get{ return _currentJob; }\n    set{ _currentJob = value; }\n  }\n\n  public Person Manager { get; set; }\n}\n\npublic class Address \n{      \n  public Person PersonLivingHere { get; set; }\n}\n\nAddress adr = new Address();\nadr.PersonLivingHere = new Person(&quot;John&quot;);\nadr.PersonLivingHere.BestFriend = new Person(&quot;James&quot;);\nadr.PersonLivingHere.CurrentJob = new Job(&quot;Programmer&quot;);\n\nAddress adrClone = adr.Clone();\n\n//RESULT\nadr.PersonLivingHere == adrClone.PersonLivingHere //false\nadr.PersonLivingHere.Manager == adrClone.PersonLivingHere.Manager //false\nadr.PersonLivingHere.CurrentJob == adrClone.PersonLivingHere.CurrentJob //true\nadr.PersonLivingHere.CurrentJob.AnyProperty == adrClone.PersonLivingHere.CurrentJob.AnyProperty //true\n\n    ","url":"/questions/[slug]#solution22","@type":"Answer","upvoteCount":0},{"text":"Create an extension:\npublic static T Clone&lt;T&gt;(this T theObject)\n{\n    string jsonData = JsonConvert.SerializeObject(theObject);\n    return JsonConvert.DeserializeObject&lt;T&gt;(jsonData);\n}\n\nAnd call it like this:\nNewObject = OldObject.Clone();\n\n    ","url":"/questions/[slug]#solution23","@type":"Answer","upvoteCount":0},{"text":"Code Generator\n\nWe have seen a lot of ideas from serialization over manual implementation to reflection and I want to propose a totally different approach using the CGbR Code Generator. The generate clone method is memory and CPU efficient and therefor 300x faster as the standard DataContractSerializer.\n\nAll you need is a partial class definition with ICloneable and the generator does the rest:\n\npublic partial class Root : ICloneable\n{\n    public Root(int number)\n    {\n        _number = number;\n    }\n    private int _number;\n\n    public Partial[] Partials { get; set; }\n\n    public IList&lt;ulong&gt; Numbers { get; set; }\n\n    public object Clone()\n    {\n        return Clone(true);\n    }\n\n    private Root()\n    {\n    }\n} \n\npublic partial class Root\n{\n    public Root Clone(bool deep)\n    {\n        var copy = new Root();\n        // All value types can be simply copied\n        copy._number = _number; \n        if (deep)\n        {\n            // In a deep clone the references are cloned \n            var tempPartials = new Partial[Partials.Length];\n            for (var i = 0; i &lt; Partials.Length; i++)\n            {\n                var value = Partials[i];\n                value = value.Clone(true);\n                tempPartials[i] = value;\n            }\n            copy.Partials = tempPartials;\n            var tempNumbers = new List&lt;ulong&gt;(Numbers.Count);\n            for (var i = 0; i &lt; Numbers.Count; i++)\n            {\n                var value = Numbers[i];\n                tempNumbers.Add(value);\n            }\n            copy.Numbers = tempNumbers;\n        }\n        else\n        {\n            // In a shallow clone only references are copied\n            copy.Partials = Partials; \n            copy.Numbers = Numbers; \n        }\n        return copy;\n    }\n}\n\n\nNote: Latest version has a more null checks, but I left them out for better understanding.\n    ","url":"/questions/[slug]#solution24","@type":"Answer","upvoteCount":0},{"text":"I like Copyconstructors like that:\n\n    public AnyObject(AnyObject anyObject)\n    {\n        foreach (var property in typeof(AnyObject).GetProperties())\n        {\n            property.SetValue(this, property.GetValue(anyObject));\n        }\n        foreach (var field in typeof(AnyObject).GetFields())\n        {\n            field.SetValue(this, field.GetValue(anyObject));\n        }\n    }\n\n\nIf you have more things to copy add them\n    ","url":"/questions/[slug]#solution25","@type":"Answer","upvoteCount":0},{"text":"This method solved the problem for me:\n\nprivate static MyObj DeepCopy(MyObj source)\n        {\n\n            var DeserializeSettings = new JsonSerializerSettings { ObjectCreationHandling = ObjectCreationHandling.Replace };\n\n            return JsonConvert.DeserializeObject&lt;MyObj &gt;(JsonConvert.SerializeObject(source), DeserializeSettings);\n\n        }\n\n\nUse it like this: MyObj a = DeepCopy(b);\n    ","url":"/questions/[slug]#solution26","@type":"Answer","upvoteCount":0},{"text":"Here a solution fast and easy that worked for me without relaying on Serialization/Deserialization. \n\npublic class MyClass\n{\n    public virtual MyClass DeepClone()\n    {\n        var returnObj = (MyClass)MemberwiseClone();\n        var type = returnObj.GetType();\n        var fieldInfoArray = type.GetRuntimeFields().ToArray();\n\n        foreach (var fieldInfo in fieldInfoArray)\n        {\n            object sourceFieldValue = fieldInfo.GetValue(this);\n            if (!(sourceFieldValue is MyClass))\n            {\n                continue;\n            }\n\n            var sourceObj = (MyClass)sourceFieldValue;\n            var clonedObj = sourceObj.DeepClone();\n            fieldInfo.SetValue(returnObj, clonedObj);\n        }\n        return returnObj;\n    }\n}\n\n\nEDIT:\nrequires \n\n    using System.Linq;\n    using System.Reflection;\n\n\nThat&apos;s How I used it\n\npublic MyClass Clone(MyClass theObjectIneededToClone)\n{\n    MyClass clonedObj = theObjectIneededToClone.DeepClone();\n}\n\n    ","url":"/questions/[slug]#solution27","@type":"Answer","upvoteCount":0},{"text":"Follow these steps:\n\n\nDefine an ISelf&lt;T&gt; with a read-only Self property that returns T, and ICloneable&lt;out T&gt;, which derives from ISelf&lt;T&gt; and includes a method T Clone().\nThen define a CloneBase type which implements a protected virtual generic VirtualClone casting MemberwiseClone to the passed-in type.  \nEach derived type should implement VirtualClone by calling the base clone method and then doing whatever needs to be done to properly clone those aspects of the derived type which the parent VirtualClone method hasn&apos;t yet handled.\n\n\nFor maximum inheritance versatility, classes exposing public cloning functionality should be sealed, but derive from a base class which is otherwise identical except for the lack of cloning.  Rather than passing variables of the explicit clonable type, take a parameter of type ICloneable&lt;theNonCloneableType&gt;.  This will allow a routine that expects a cloneable derivative of  Foo to work with a cloneable derivative of DerivedFoo, but also allow the creation of non-cloneable derivatives of Foo.\n    ","url":"/questions/[slug]#solution28","@type":"Answer","upvoteCount":0},{"text":"As nearly all of the answers to this question have been unsatisfactory or plainly don&apos;t work in my situation, I have authored AnyClone which is entirely implemented with reflection and solved all of the needs here. I was unable to get serialization to work in a complicated scenario with complex structure, and IClonable is less than ideal - in fact it shouldn&apos;t even be necessary.\n\nStandard ignore attributes are supported using [IgnoreDataMember], [NonSerialized]. Supports complex collections, properties without setters, readonly fields etc.\n\nI hope it helps someone else out there who ran into the same problems I did.\n    ","url":"/questions/[slug]#solution29","@type":"Answer","upvoteCount":0},{"text":"I have created a version of the accepted answer that works with both &apos;[Serializable]&apos; and &apos;[DataContract]&apos;. It has been a while since I wrote it, but if I remember correctly [DataContract] needed a different serializer.\n\nRequires System, System.IO, System.Runtime.Serialization, System.Runtime.Serialization.Formatters.Binary, System.Xml;\n\npublic static class ObjectCopier\n{\n\n    /// &lt;summary&gt;\n    /// Perform a deep Copy of an object that is marked with &apos;[Serializable]&apos; or &apos;[DataContract]&apos;\n    /// &lt;/summary&gt;\n    /// &lt;typeparam name=&quot;T&quot;&gt;The type of object being copied.&lt;/typeparam&gt;\n    /// &lt;param name=&quot;source&quot;&gt;The object instance to copy.&lt;/param&gt;\n    /// &lt;returns&gt;The copied object.&lt;/returns&gt;\n    public static T Clone&lt;T&gt;(T source)\n    {\n        if (typeof(T).IsSerializable == true)\n        {\n            return CloneUsingSerializable&lt;T&gt;(source);\n        }\n\n        if (IsDataContract(typeof(T)) == true)\n        {\n            return CloneUsingDataContracts&lt;T&gt;(source);\n        }\n\n        throw new ArgumentException(&quot;The type must be Serializable or use DataContracts.&quot;, &quot;source&quot;);\n    }\n\n\n    /// &lt;summary&gt;\n    /// Perform a deep Copy of an object that is marked with &apos;[Serializable]&apos;\n    /// &lt;/summary&gt;\n    /// &lt;remarks&gt;\n    /// Found on http://stackoverflow.com/questions/78536/cloning-objects-in-c-sharp\n    /// Uses code found on CodeProject, which allows free use in third party apps\n    /// - http://www.codeproject.com/KB/tips/SerializedObjectCloner.aspx\n    /// &lt;/remarks&gt;\n    /// &lt;typeparam name=&quot;T&quot;&gt;The type of object being copied.&lt;/typeparam&gt;\n    /// &lt;param name=&quot;source&quot;&gt;The object instance to copy.&lt;/param&gt;\n    /// &lt;returns&gt;The copied object.&lt;/returns&gt;\n    public static T CloneUsingSerializable&lt;T&gt;(T source)\n    {\n        if (!typeof(T).IsSerializable)\n        {\n            throw new ArgumentException(&quot;The type must be serializable.&quot;, &quot;source&quot;);\n        }\n\n        // Don&apos;t serialize a null object, simply return the default for that object\n        if (Object.ReferenceEquals(source, null))\n        {\n            return default(T);\n        }\n\n        IFormatter formatter = new BinaryFormatter();\n        Stream stream = new MemoryStream();\n        using (stream)\n        {\n            formatter.Serialize(stream, source);\n            stream.Seek(0, SeekOrigin.Begin);\n            return (T)formatter.Deserialize(stream);\n        }\n    }\n\n\n    /// &lt;summary&gt;\n    /// Perform a deep Copy of an object that is marked with &apos;[DataContract]&apos;\n    /// &lt;/summary&gt;\n    /// &lt;typeparam name=&quot;T&quot;&gt;The type of object being copied.&lt;/typeparam&gt;\n    /// &lt;param name=&quot;source&quot;&gt;The object instance to copy.&lt;/param&gt;\n    /// &lt;returns&gt;The copied object.&lt;/returns&gt;\n    public static T CloneUsingDataContracts&lt;T&gt;(T source)\n    {\n        if (IsDataContract(typeof(T)) == false)\n        {\n            throw new ArgumentException(&quot;The type must be a data contract.&quot;, &quot;source&quot;);\n        }\n\n        // ** Don&apos;t serialize a null object, simply return the default for that object\n        if (Object.ReferenceEquals(source, null))\n        {\n            return default(T);\n        }\n\n        DataContractSerializer dcs = new DataContractSerializer(typeof(T));\n        using(Stream stream = new MemoryStream())\n        {\n            using (XmlDictionaryWriter writer = XmlDictionaryWriter.CreateBinaryWriter(stream))\n            {\n                dcs.WriteObject(writer, source);\n                writer.Flush();\n                stream.Seek(0, SeekOrigin.Begin);\n                using (XmlDictionaryReader reader = XmlDictionaryReader.CreateBinaryReader(stream, XmlDictionaryReaderQuotas.Max))\n                {\n                    return (T)dcs.ReadObject(reader);\n                }\n            }\n        }\n    }\n\n\n    /// &lt;summary&gt;\n    /// Helper function to check if a class is a [DataContract]\n    /// &lt;/summary&gt;\n    /// &lt;param name=&quot;type&quot;&gt;The type of the object to check.&lt;/param&gt;\n    /// &lt;returns&gt;Boolean flag indicating if the class is a DataContract (true) or not (false) &lt;/returns&gt;\n    public static bool IsDataContract(Type type)\n    {\n        object[] attributes = type.GetCustomAttributes(typeof(DataContractAttribute), false);\n        return attributes.Length == 1;\n    }\n\n} \n\n    ","url":"/questions/[slug]#solution30","@type":"Answer","upvoteCount":0}],"@type":"Question"}}</script><meta name="next-head-count" content="16"/><link rel="preload" href="/_next/static/css/08bcc42a26fe5c92.css" as="style"/><link rel="stylesheet" href="/_next/static/css/08bcc42a26fe5c92.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-0d1b80a048d4787e.js"></script><script src="/_next/static/chunks/webpack-42cdea76c8170223.js" defer=""></script><script src="/_next/static/chunks/framework-4556c45dd113b893.js" defer=""></script><script src="/_next/static/chunks/main-ccfab947c79712f4.js" defer=""></script><script src="/_next/static/chunks/pages/_app-08d1a634dea6705e.js" defer=""></script><script src="/_next/static/chunks/29107295-fbcfe2172188e46f.js" defer=""></script><script src="/_next/static/chunks/150-b06815e21c943e0d.js" defer=""></script><script src="/_next/static/chunks/490-7f0418bb4354ac73.js" defer=""></script><script src="/_next/static/chunks/108-87de33c23337ff53.js" defer=""></script><script src="/_next/static/chunks/pages/questions/%5Bslug%5D-79a1437acf654019.js" defer=""></script><script src="/_next/static/TQ2eYlCSdocSK-hq6gkM0/_buildManifest.js" defer=""></script><script src="/_next/static/TQ2eYlCSdocSK-hq6gkM0/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="wrapper"><header><nav class="bg-white border-gray-200 px-4 lg:px-6 py-2.5 dark:bg-gray-800"><div class="flex flex-wrap justify-between items-center mx-auto max-w-screen-xl"><a class="flex items-center" href="/"><img src="/logo-second.png" class="mr-3 h-6 sm:h-9" alt="Solution Checker Logo"/><h4 class="self-center text-xl font-semibold whitespace-nowrap dark:text-white">Solution Checker</h4></a><div class="flex items-center lg:order-2"><button data-collapse-toggle="mobile-menu-2" type="button" class="inline-flex items-center p-2 ml-1 text-sm text-gray-500 rounded-lg lg:hidden hover:bg-gray-100 focus:outline-none focus:ring-2 focus:ring-gray-200 dark:text-gray-400 dark:hover:bg-gray-700 dark:focus:ring-gray-600" aria-controls="mobile-menu-2" aria-expanded="false"><span class="sr-only">Open main menu</span><svg class="w-6 h-6" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M3 5a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM3 10a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM3 15a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1z" clip-rule="evenodd"></path></svg><svg class="hidden w-6 h-6" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z" clip-rule="evenodd"></path></svg></button></div><div class="hidden justify-between items-center w-full lg:flex lg:w-auto lg:order-1" id="mobile-menu-2"><ul class="flex flex-col mt-4 font-medium lg:flex-row lg:space-x-8 lg:mt-0"><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" aria-current="page" href="/">Home</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/questions?tab=news">Questions</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/post?tab=news">Post</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/questions/deep-cloning-objects-1657387930865#">Coding</a></li></ul></div></div></nav></header><div class="main-content"><div class="question my-5"><div class="flex question-header items-center m-auto justify-center"><div class="rounded-xl w-full border p-5 shadow-md bg-white"><div class="flex w-full items-center justify-between border-b pb-3"><div class="flex items-center space-x-3"><div class="text-lg font-bold text-slate-700"><a href="/questions/deep-cloning-objects-1657387930865"><h1>Deep cloning objects</h1></a></div></div><div class="flex flex-wrap h-auto justify-end items-center space-x-8"></div></div><div class="question-content mt-5">
                
<p>I want to do something like:</p>

<pre class="lang-cs s-code-block"><code class="hljs language-csharp">MyObject myObj = GetMyObj(); <span class="hljs-comment">// Create and fill a new object</span>
MyObject newObj = myObj.Clone();
</code></pre>

<p>And then make changes to the new object that are not reflected in the original object.</p>

<p>I don't often need this functionality, so when it's been necessary, I've resorted to creating a new object and then copying each property individually, but it always leaves me with the feeling that there is a better or more elegant way of handling the situation.</p>

<p>How can I clone or deep copy an object so that the cloned object can be modified without any changes being reflected in the original object?</p>
    </div></div></div><div class="solution-section"><nav class="flex pagination-solution flex-col justify-end"><ul class="inline-flex -space-x-px overflow-auto"><li class="pagination-solution-item"><span data-id="#solution1" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">1</span></li><li class="pagination-solution-item"><span data-id="#solution2" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">2</span></li><li class="pagination-solution-item"><span data-id="#solution3" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">3</span></li><li class="pagination-solution-item"><span data-id="#solution4" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">4</span></li><li class="pagination-solution-item"><span data-id="#solution5" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">5</span></li><li class="pagination-solution-item"><span data-id="#solution6" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">6</span></li><li class="pagination-solution-item"><span data-id="#solution7" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">7</span></li><li class="pagination-solution-item"><span data-id="#solution8" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">8</span></li><li class="pagination-solution-item"><span data-id="#solution9" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">9</span></li><li class="pagination-solution-item"><span data-id="#solution10" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">10</span></li><li class="pagination-solution-item"><span data-id="#solution11" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">11</span></li><li class="pagination-solution-item"><span data-id="#solution12" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">12</span></li><li class="pagination-solution-item"><span data-id="#solution13" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">13</span></li><li class="pagination-solution-item"><span data-id="#solution14" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">14</span></li><li class="pagination-solution-item"><span data-id="#solution15" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">15</span></li><li class="pagination-solution-item"><span data-id="#solution16" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">16</span></li><li class="pagination-solution-item"><span data-id="#solution17" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">17</span></li><li class="pagination-solution-item"><span data-id="#solution18" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">18</span></li><li class="pagination-solution-item"><span data-id="#solution19" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">19</span></li><li class="pagination-solution-item"><span data-id="#solution20" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">20</span></li><li class="pagination-solution-item"><span data-id="#solution21" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">21</span></li><li class="pagination-solution-item"><span data-id="#solution22" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">22</span></li><li class="pagination-solution-item"><span data-id="#solution23" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">23</span></li><li class="pagination-solution-item"><span data-id="#solution24" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">24</span></li><li class="pagination-solution-item"><span data-id="#solution25" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">25</span></li><li class="pagination-solution-item"><span data-id="#solution26" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">26</span></li><li class="pagination-solution-item"><span data-id="#solution27" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">27</span></li><li class="pagination-solution-item"><span data-id="#solution28" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">28</span></li><li class="pagination-solution-item"><span data-id="#solution29" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">29</span></li><li class="pagination-solution-item"><span data-id="#solution30" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">30</span></li></ul></nav><div id="solution1" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 1</h4><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Whereas one approach is to implement the <a href="http://msdn.microsoft.com/en-us/library/system.icloneable.aspx" rel="noreferrer"><code>ICloneable</code></a> interface (described <a href="https://stackoverflow.com/questions/78536/cloning-objects-in-c/78568#78568">here</a>, so I won't regurgitate), here's a nice deep clone object copier I found on <a href="http://www.codeproject.com/Articles/23832/Implementing-Deep-Cloning-via-Serializing-objects" rel="noreferrer">The Code Project</a> a while ago and incorporated it into our code.
As mentioned elsewhere, it requires your objects to be serializable.</p>
<pre class="lang-cs s-code-block"><code class="hljs language-csharp"><span class="hljs-keyword">using</span> System;
<span class="hljs-keyword">using</span> System.IO;
<span class="hljs-keyword">using</span> System.Runtime.Serialization;
<span class="hljs-keyword">using</span> System.Runtime.Serialization.Formatters.Binary;

<span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span>
<span class="hljs-comment"><span class="hljs-doctag">///</span> Reference Article http://www.codeproject.com/KB/tips/SerializedObjectCloner.aspx</span>
<span class="hljs-comment"><span class="hljs-doctag">///</span> Provides a method for performing a deep copy of an object.</span>
<span class="hljs-comment"><span class="hljs-doctag">///</span> Binary Serialization is used to perform the copy.</span>
<span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title">ObjectCopier</span>
{
    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span>
    <span class="hljs-comment"><span class="hljs-doctag">///</span> Perform a deep copy of the object via serialization.</span>
    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span>
    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;typeparam name="T"&gt;</span>The type of object being copied.<span class="hljs-doctag">&lt;/typeparam&gt;</span></span>
    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;param name="source"&gt;</span>The object instance to copy.<span class="hljs-doctag">&lt;/param&gt;</span></span>
    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;returns&gt;</span>A deep copy of the object.<span class="hljs-doctag">&lt;/returns&gt;</span></span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> T <span class="hljs-title">Clone</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params">T source</span>)</span>
    {
        <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">typeof</span>(T).IsSerializable)
        {
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ArgumentException(<span class="hljs-string">"The type must be serializable."</span>, <span class="hljs-keyword">nameof</span>(source));
        }

        <span class="hljs-comment">// Don't serialize a null object, simply return the default for that object</span>
        <span class="hljs-keyword">if</span> (ReferenceEquals(source, <span class="hljs-literal">null</span>)) <span class="hljs-keyword">return</span> <span class="hljs-literal">default</span>;

        <span class="hljs-keyword">using</span> <span class="hljs-keyword">var</span> Stream stream = <span class="hljs-keyword">new</span> MemoryStream();
        IFormatter formatter = <span class="hljs-keyword">new</span> BinaryFormatter();
        formatter.Serialize(stream, source);
        stream.Seek(<span class="hljs-number">0</span>, SeekOrigin.Begin);
        <span class="hljs-keyword">return</span> (T)formatter.Deserialize(stream);
    }
}
</code></pre>
<p>The idea is that it serializes your object and then deserializes it into a fresh object. The benefit is that you don't have to concern yourself about cloning everything when an object gets too complex.</p>
<p>In case of you prefer to use the new <a href="http://en.wikipedia.org/wiki/Extension_method" rel="noreferrer">extension methods</a> of C# 3.0, change the method to have the following signature:</p>
<pre class="lang-cs s-code-block"><code class="hljs language-csharp"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> T <span class="hljs-title">Clone</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params"><span class="hljs-keyword">this</span> T source</span>)</span>
{
   <span class="hljs-comment">// ...</span>
}
</code></pre>
<p>Now the method call simply becomes <code>objectBeingCloned.Clone();</code>.</p>
<p><strong>EDIT</strong> (January 10 2015) Thought I'd revisit this, to mention I recently started using (Newtonsoft) Json to do this, it <a href="http://maxondev.com/serialization-performance-comparison-c-net-formats-frameworks-xmldatacontractserializer-xmlserializer-binaryformatter-json-newtonsoft-servicestack-text/" rel="noreferrer">should be</a> lighter, and avoids the overhead of [Serializable] tags. (<strong>NB</strong> @atconway has pointed out in the comments that private members are not cloned using the JSON method)</p>
<pre class="lang-cs s-code-block"><code class="hljs language-csharp"><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span>
<span class="hljs-comment"><span class="hljs-doctag">///</span> Perform a deep Copy of the object, using Json as a serialization method. <span class="hljs-doctag">NOTE:</span> Private members are not cloned using this method.</span>
<span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span>
<span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;typeparam name="T"&gt;</span>The type of object being copied.<span class="hljs-doctag">&lt;/typeparam&gt;</span></span>
<span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;param name="source"&gt;</span>The object instance to copy.<span class="hljs-doctag">&lt;/param&gt;</span></span>
<span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;returns&gt;</span>The copied object.<span class="hljs-doctag">&lt;/returns&gt;</span></span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> T <span class="hljs-title">CloneJson</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params"><span class="hljs-keyword">this</span> T source</span>)</span>
{            
    <span class="hljs-comment">// Don't serialize a null object, simply return the default for that object</span>
    <span class="hljs-keyword">if</span> (ReferenceEquals(source, <span class="hljs-literal">null</span>)) <span class="hljs-keyword">return</span> <span class="hljs-literal">default</span>;

    <span class="hljs-comment">// initialize inner objects individually</span>
    <span class="hljs-comment">// for example in default constructor some list property initialized with some values,</span>
    <span class="hljs-comment">// but in 'source' these items are cleaned -</span>
    <span class="hljs-comment">// without ObjectCreationHandling.Replace default constructor values will be added to result</span>
    <span class="hljs-keyword">var</span> deserializeSettings = <span class="hljs-keyword">new</span> JsonSerializerSettings {ObjectCreationHandling = ObjectCreationHandling.Replace};

    <span class="hljs-keyword">return</span> JsonConvert.DeserializeObject&lt;T&gt;(JsonConvert.SerializeObject(source), deserializeSettings);
}
</code></pre>
    </div></div></div></div><div id="solution2" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 2</h4><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>I wanted a cloner for very simple objects of mostly primitives and lists.  If your object is out of the box JSON serializable then this method will do the trick.  This requires no modification or implementation of interfaces on the cloned class, just a JSON serializer like JSON.NET.</p>

<pre class="lang-cs s-code-block"><code class="hljs language-csharp"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> T <span class="hljs-title">Clone</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params">T source</span>)</span>
{
    <span class="hljs-keyword">var</span> serialized = JsonConvert.SerializeObject(source);
    <span class="hljs-keyword">return</span> JsonConvert.DeserializeObject&lt;T&gt;(serialized);
}
</code></pre>

<p>Also, you can use this extension method</p>

<pre class="lang-cs s-code-block"><code class="hljs language-csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title">SystemExtension</span>
{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> T <span class="hljs-title">Clone</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params"><span class="hljs-keyword">this</span> T source</span>)</span>
    {
        <span class="hljs-keyword">var</span> serialized = JsonConvert.SerializeObject(source);
        <span class="hljs-keyword">return</span> JsonConvert.DeserializeObject&lt;T&gt;(serialized);
    }
}
</code></pre>
    </div></div></div></div><div id="solution3" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 3</h4><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>The reason not to use <a href="http://referencesource.microsoft.com/mscorlib/system/icloneable.cs.html#fb795e239ce05299" rel="noreferrer">ICloneable</a> is <strong>not</strong> because it doesn't have a generic interface.  <a href="http://blogs.msdn.com/brada/archive/2004/05/03/125427.aspx" rel="noreferrer">The reason not to use it is because it's vague</a>.  It doesn't make clear whether you're getting a shallow or a deep copy; that's up to the implementer.</p>

<p>Yes, <code>MemberwiseClone</code> makes a shallow copy, but the opposite of <code>MemberwiseClone</code> isn't <code>Clone</code>; it would be, perhaps, <code>DeepClone</code>, which doesn't exist.  When you use an object through its ICloneable interface, you can't know which kind of cloning the underlying object performs.  (And XML comments won't make it clear, because you'll get the interface comments rather than the ones on the object's Clone method.)</p>

<p>What I usually do is simply make a <code>Copy</code> method that does exactly what I want.</p>
    </div></div></div></div><div id="solution4" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 4</h4><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>After much much reading about many of the options linked here, and possible solutions for this issue, I believe <a href="https://developerscon.blogspot.com/2008/06/c-object-clone-wars.html" rel="noreferrer">all the options are summarized pretty well at <em>Ian P</em>'s link</a> (all other options are variations of those) and the best solution is provided by <a href="http://www.agiledeveloper.com/articles/cloning072002.htm" rel="noreferrer"><em>Pedro77</em>'s link</a> on the question comments.</p>

<p>So I'll just copy relevant parts of those 2 references here. That way we can have:</p>

<h2>The best thing to do for cloning objects in C sharp!</h2>

<p>First and foremost, those are all our options:</p>

<ul>
<li>Manually with <strong><a href="https://docs.microsoft.com/en-us/dotnet/api/system.icloneable" rel="noreferrer">ICloneable</a></strong>, which is <em>Shallow</em> and not <em>Type-Safe</em></li>
<li><strong><a href="https://docs.microsoft.com/en-us/dotnet/api/system.object.memberwiseclone" rel="noreferrer">MemberwiseClone</a></strong>, which uses ICloneable</li>
<li><strong><a href="https://www.codeproject.com/Articles/3441/Base-class-for-cloning-an-object-in-C" rel="noreferrer">Reflection</a></strong> by using <a href="https://docs.microsoft.com/en-us/dotnet/api/system.activator.createinstance" rel="noreferrer">Activator.CreateInstance</a> and <a href="https://github.com/Burtsev-Alexey/net-object-deep-copy/" rel="noreferrer">recursive MemberwiseClone</a></li>
<li><strong><a href="https://docs.microsoft.com/en-us/dotnet/api/system.serializableattribute" rel="noreferrer">Serialization</a></strong>, as pointed by <a href="https://stackoverflow.com/a/78612/274502">johnc's preferred answer</a></li>
<li><strong>Intermediate Language</strong>, which I got no idea <a href="https://whizzodev.blogspot.com/2008/03/object-cloning-using-il-in-c.html" rel="noreferrer">how works</a></li>
<li><strong>Extension Methods</strong>, such as this <a href="https://circlesandcrossesblogarchive.blogspot.com/2008/01/extension-methods-for-copying-or.html" rel="noreferrer">custom clone framework by Havard Straden</a></li>
<li><strong><a href="https://www.codeproject.com/Articles/1111658/Fast-Deep-Copy-of-Objects-by-Expression-Trees-Csha" rel="noreferrer">Expression Trees</a></strong></li>
</ul>

<p>The <a href="https://www.codeproject.com/Articles/1111658/Fast-Deep-Copy-of-Objects-by-Expression-Trees-Csha" rel="noreferrer">article Fast Deep Copy by Expression Trees</a>   has  also performance comparison of cloning by Serialization, Reflection and Expression Trees.</p>

<h1>Why I choose <em>ICloneable</em> (i.e. manually)</h1>

<p><a href="http://www.agiledeveloper.com/articles/cloning072002.htm" rel="noreferrer">Mr Venkat Subramaniam (redundant link here) explains in much detail why</a>.</p>

<p>All his article circles around an example that tries to be applicable for most cases, using 3 objects: <em>Person</em>, <em>Brain</em> and <em>City</em>. We want to clone a person, which will have its own brain but the same city. You can either picture all problems any of the other methods above can bring or read the article.</p>

<p>This is my slightly modified version of his conclusion:</p>

<blockquote>
  <p>Copying an object by specifying <code>New</code> followed by the class name often leads to code that is not extensible. Using clone, the application of prototype pattern, is a better way to achieve this. However, using clone as it is provided in C# (and Java) can be quite problematic as well. It is better to provide a protected (non-public) copy constructor and invoke that from the clone method. This gives us the ability to delegate the task of creating an object to an instance of a class itself, thus providing extensibility and also, safely creating the objects using the protected copy constructor.</p>
</blockquote>

<p>Hopefully this implementation can make things clear:</p>

<pre class="lang-cs s-code-block"><code class="hljs language-csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> : <span class="hljs-title">ICloneable</span>
{
    <span class="hljs-keyword">private</span> final Brain brain; <span class="hljs-comment">// brain is final since I do not want </span>
                <span class="hljs-comment">// any transplant on it once created!</span>
    <span class="hljs-keyword">private</span> <span class="hljs-built_in">int</span> age;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Person</span>(<span class="hljs-params">Brain aBrain, <span class="hljs-built_in">int</span> theAge</span>)</span>
    {
        brain = aBrain; 
        age = theAge;
    }
    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-title">Person</span>(<span class="hljs-params">Person another</span>)</span>
    {
        Brain refBrain = <span class="hljs-literal">null</span>;
        <span class="hljs-keyword">try</span>
        {
            refBrain = (Brain) another.brain.clone();
            <span class="hljs-comment">// You can set the brain in the constructor</span>
        }
        <span class="hljs-keyword">catch</span>(CloneNotSupportedException e) {}
        brain = refBrain;
        age = another.age;
    }
    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span>()</span>
    {
        <span class="hljs-keyword">return</span> <span class="hljs-string">"This is person with "</span> + brain;
        <span class="hljs-comment">// Not meant to sound rude as it reads!</span>
    }
    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">clone</span>()</span>
    {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Person(<span class="hljs-keyword">this</span>);
    }
    
}
</code></pre>

<p>Now consider having a class derive from Person.</p>

<pre class="lang-cs s-code-block"><code class="hljs language-csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">SkilledPerson</span> <span class="hljs-title">extends</span> <span class="hljs-title">Person</span>
{
    <span class="hljs-keyword">private</span> String theSkills;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">SkilledPerson</span>(<span class="hljs-params">Brain aBrain, <span class="hljs-built_in">int</span> theAge, String skills</span>)</span>
    {
        super(aBrain, theAge);
        theSkills = skills;
    }
    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-title">SkilledPerson</span>(<span class="hljs-params">SkilledPerson another</span>)</span>
    {
        super(another);
        theSkills = another.theSkills;
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">clone</span>()</span>
    {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> SkilledPerson(<span class="hljs-keyword">this</span>);
    }
    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span>()</span>
    {
        <span class="hljs-keyword">return</span> <span class="hljs-string">"SkilledPerson: "</span> + super.toString();
    }
}
</code></pre>

<p>You may try running the following code:</p>

<pre class="lang-cs s-code-block"><code class="hljs language-csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">User</span>
{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">play</span>(<span class="hljs-params">Person p</span>)</span>
    {
        Person another = (Person) p.clone();
        System.<span class="hljs-keyword">out</span>.println(p);
        System.<span class="hljs-keyword">out</span>.println(another);
    }
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(<span class="hljs-params">String[] args</span>)</span>
    {
        Person sam = <span class="hljs-keyword">new</span> Person(<span class="hljs-keyword">new</span> Brain(), <span class="hljs-number">1</span>);
        play(sam);
        SkilledPerson bob = <span class="hljs-keyword">new</span> SkilledPerson(<span class="hljs-keyword">new</span> SmarterBrain(), <span class="hljs-number">1</span>, <span class="hljs-string">"Writer"</span>);
        play(bob);
    }
}
</code></pre>

<p>The output produced will be:</p>

<pre class="lang-cs s-code-block"><code class="hljs language-csharp">This <span class="hljs-keyword">is</span> person <span class="hljs-keyword">with</span> Brain@<span class="hljs-number">1f</span>cc69
This <span class="hljs-keyword">is</span> person <span class="hljs-keyword">with</span> Brain@<span class="hljs-number">253498</span>
SkilledPerson: This <span class="hljs-keyword">is</span> person <span class="hljs-keyword">with</span> SmarterBrain@<span class="hljs-number">1f</span>ef6f
SkilledPerson: This <span class="hljs-keyword">is</span> person <span class="hljs-keyword">with</span> SmarterBrain@<span class="hljs-number">209f</span>4e
</code></pre>

<p>Observe that, if we keep a count of the number of objects, the clone as implemented here will keep a correct count of the number of objects.</p>
    </div></div></div></div><div id="solution5" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 5</h4><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>I prefer a copy constructor to a clone. The intent is clearer.</p>
    </div></div></div></div><div id="solution6" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 6</h4><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Simple extension method to copy all the public properties. Works for any objects and <strong>does not</strong> require class to be <code>[Serializable]</code>. Can be extended for other access level.</p>

<pre class="lang-cs s-code-block"><code class="hljs language-csharp"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">CopyTo</span>(<span class="hljs-params"> <span class="hljs-keyword">this</span> <span class="hljs-built_in">object</span> S, <span class="hljs-built_in">object</span> T </span>)</span>
{
    <span class="hljs-keyword">foreach</span>( <span class="hljs-keyword">var</span> pS <span class="hljs-keyword">in</span> S.GetType().GetProperties() )
    {
        <span class="hljs-keyword">foreach</span>( <span class="hljs-keyword">var</span> pT <span class="hljs-keyword">in</span> T.GetType().GetProperties() )
        {
            <span class="hljs-keyword">if</span>( pT.Name != pS.Name ) <span class="hljs-keyword">continue</span>;
            ( pT.GetSetMethod() ).Invoke( T, <span class="hljs-keyword">new</span> <span class="hljs-built_in">object</span>[] 
            { pS.GetGetMethod().Invoke( S, <span class="hljs-literal">null</span> ) } );
        }
    };
}
</code></pre>
    </div></div></div></div><div id="solution7" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 7</h4><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>I've just created <strong><a href="https://github.com/MarcinJuraszek/CloneExtensions"><code>CloneExtensions</code> library</a></strong> project. It performs fast, deep clone using simple assignment operations generated by Expression Tree runtime code compilation.</p>

<p><strong>How to use it?</strong></p>

<p>Instead of writing your own <code>Clone</code> or <code>Copy</code> methods with a tone of assignments between fields and properties make the program do it for yourself, using Expression Tree. <code>GetClone&lt;T&gt;()</code> method marked as extension method allows you to simply call it on your instance:</p>

<pre class="lang-cs s-code-block"><code class="hljs language-csharp"><span class="hljs-keyword">var</span> newInstance = source.GetClone();
</code></pre>

<p>You can choose what should be copied from <code>source</code> to <code>newInstance</code> using <code>CloningFlags</code> enum:</p>

<pre class="lang-cs s-code-block"><code class="hljs language-csharp"><span class="hljs-keyword">var</span> newInstance 
    = source.GetClone(CloningFlags.Properties | CloningFlags.CollectionItems);
</code></pre>

<p><strong>What can be cloned?</strong></p>

<ul>
<li>Primitive (int, uint, byte, double, char, etc.), known immutable
types (DateTime, TimeSpan, String) and delegates (including
Action, Func, etc)</li>
<li>Nullable</li>
<li>T[] arrays</li>
<li>Custom classes and structs, including generic classes and structs.</li>
</ul>

<p>Following class/struct members are cloned internally:</p>

<ul>
<li>Values of public, not readonly fields</li>
<li>Values of public properties with both get and set accessors</li>
<li>Collection items for types implementing ICollection</li>
</ul>

<p><strong>How fast it is?</strong></p>

<p>The solution is faster then reflection, because members information has to be gathered only once, before <code>GetClone&lt;T&gt;</code> is used for the first time for given type <code>T</code>.</p>

<p>It's also faster than serialization-based solution when you clone more then couple instances of the same type <code>T</code>.</p>

<p><strong>and more...</strong></p>

<p>Read more about generated expressions on <a href="https://github.com/MarcinJuraszek/CloneExtensions/blob/master/EXPRESSION_TREES.md">documentation</a>.</p>

<p>Sample expression debug listing for <code>List&lt;int&gt;</code>:</p>

<pre class="lang-cs s-code-block"><code class="hljs language-csharp">.Lambda <span class="hljs-meta">#Lambda1&lt;System.Func`4[System.Collections.Generic.List`1[System.Int32],CloneExtensions.CloningFlags,System.Collections.Generic.IDictionary`2[System.Type,System.Func`2[System.Object,System.Object]],System.Collections.Generic.List`1[System.Int32]]&gt;(</span>
    System.Collections.Generic.List`<span class="hljs-number">1</span>[System.Int32] $source,
    CloneExtensions.CloningFlags $flags,
    System.Collections.Generic.IDictionary`<span class="hljs-number">2</span>[System.Type,System.Func`<span class="hljs-number">2</span>[System.Object,System.Object]] $initializers) {
    .Block(System.Collections.Generic.List`<span class="hljs-number">1</span>[System.Int32] $target) {
        .If ($source == <span class="hljs-literal">null</span>) {
            .Return <span class="hljs-meta">#Label1 { null }</span>
        } .Else {
            .Default(System.Void)
        };
        .If (
            .Call $initializers.ContainsKey(.Constant&lt;System.Type&gt;(System.Collections.Generic.List`<span class="hljs-number">1</span>[System.Int32]))
        ) {
            $target = (System.Collections.Generic.List`<span class="hljs-number">1</span>[System.Int32]).Call ($initializers.Item[.Constant&lt;System.Type&gt;(System.Collections.Generic.List`<span class="hljs-number">1</span>[System.Int32])]
            ).Invoke((System.Object)$source)
        } .Else {
            $target = .New System.Collections.Generic.List`<span class="hljs-number">1</span>[System.Int32]()
        };
        .If (
            ((System.Byte)$flags &amp; (System.Byte).Constant&lt;CloneExtensions.CloningFlags&gt;(Fields)) == (System.Byte).Constant&lt;CloneExtensions.CloningFlags&gt;(Fields)
        ) {
            .Default(System.Void)
        } .Else {
            .Default(System.Void)
        };
        .If (
            ((System.Byte)$flags &amp; (System.Byte).Constant&lt;CloneExtensions.CloningFlags&gt;(Properties)) == (System.Byte).Constant&lt;CloneExtensions.CloningFlags&gt;(Properties)
        ) {
            .Block() {
                $target.Capacity = .Call CloneExtensions.CloneFactory.GetClone(
                    $source.Capacity,
                    $flags,
                    $initializers)
            }
        } .Else {
            .Default(System.Void)
        };
        .If (
            ((System.Byte)$flags &amp; (System.Byte).Constant&lt;CloneExtensions.CloningFlags&gt;(CollectionItems)) == (System.Byte).Constant&lt;CloneExtensions.CloningFlags&gt;(CollectionItems)
        ) {
            .Block(
                System.Collections.Generic.IEnumerator`<span class="hljs-number">1</span>[System.Int32] $var1,
                System.Collections.Generic.ICollection`<span class="hljs-number">1</span>[System.Int32] $var2) {
                $var1 = (System.Collections.Generic.IEnumerator`<span class="hljs-number">1</span>[System.Int32]).Call $source.GetEnumerator();
                $var2 = (System.Collections.Generic.ICollection`<span class="hljs-number">1</span>[System.Int32])$target;
                .Loop  {
                    .If (.Call $var1.MoveNext() != False) {
                        .Call $var2.Add(.Call CloneExtensions.CloneFactory.GetClone(
                                $var1.Current,
                                $flags,


                         $initializers))
                } .Else {
                    .Break <span class="hljs-meta">#Label2 { }</span>
                }
            }
            .LabelTarget <span class="hljs-meta">#Label2:</span>
        }
    } .Else {
        .Default(System.Void)
    };
    .Label
        $target
    .LabelTarget <span class="hljs-meta">#Label1:</span>
}
</code></pre>

<p>}</p>

<p>what has the same meaning like following c# code:</p>

<pre class="lang-cs s-code-block"><code class="hljs language-csharp">(source, flags, initializers) =&gt;
{
    <span class="hljs-keyword">if</span>(source == <span class="hljs-literal">null</span>)
        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;

    <span class="hljs-keyword">if</span>(initializers.ContainsKey(<span class="hljs-keyword">typeof</span>(List&lt;<span class="hljs-built_in">int</span>&gt;))
        target = (List&lt;<span class="hljs-built_in">int</span>&gt;)initializers[<span class="hljs-keyword">typeof</span>(List&lt;<span class="hljs-built_in">int</span>&gt;)].Invoke((<span class="hljs-built_in">object</span>)source);
    <span class="hljs-keyword">else</span>
        target = <span class="hljs-keyword">new</span> List&lt;<span class="hljs-built_in">int</span>&gt;();

    <span class="hljs-keyword">if</span>((flags &amp; CloningFlags.Properties) == CloningFlags.Properties)
    {
        target.Capacity = target.Capacity.GetClone(flags, initializers);
    }

    <span class="hljs-keyword">if</span>((flags &amp; CloningFlags.CollectionItems) == CloningFlags.CollectionItems)
    {
        <span class="hljs-keyword">var</span> targetCollection = (ICollection&lt;<span class="hljs-built_in">int</span>&gt;)target;
        <span class="hljs-keyword">foreach</span>(<span class="hljs-function"><span class="hljs-keyword">var</span> item <span class="hljs-title">in</span> (<span class="hljs-params">ICollection&lt;<span class="hljs-built_in">int</span>&gt;</span>)source)</span>
        {
            targetCollection.Add(item.Clone(flags, initializers));
        }
    }

    <span class="hljs-keyword">return</span> target;
}
</code></pre>

<p>Isn't it quite like how you'd write your own <code>Clone</code> method for <code>List&lt;int&gt;</code>?</p>
    </div></div></div></div><div id="solution8" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 8</h4><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>If you're already using a 3rd party application like <a href="https://github.com/omuleanu/ValueInjecter" rel="noreferrer">ValueInjecter</a> or <a href="https://github.com/AutoMapper/AutoMapper" rel="noreferrer">Automapper</a>, you can do something like this:</p>

<pre class="lang-cs s-code-block"><code class="hljs language-csharp">MyObject oldObj; <span class="hljs-comment">// The existing object to clone</span>

MyObject newObj = <span class="hljs-keyword">new</span> MyObject();
newObj.InjectFrom(oldObj); <span class="hljs-comment">// Using ValueInjecter syntax</span>
</code></pre>

<p>Using this method you don't have to implement <code>ISerializable</code> or <code>ICloneable</code> on your objects. This is common with the MVC/MVVM pattern, so simple tools like this have been created.</p>

<p>see <a href="https://github.com/omuleanu/ValueInjecter/blob/dae7956439cac8516979fe254a520a1942c5cdeb/Tests/Cloning.cs" rel="noreferrer">the ValueInjecter deep cloning sample on GitHub</a>.</p>
    </div></div></div></div><div id="solution9" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 9</h4><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Well I was having problems using ICloneable in Silverlight, but I liked the idea of seralization, I can seralize XML, so I did this:</p>
<pre class="lang-cs s-code-block"><code class="hljs language-csharp"><span class="hljs-keyword">static</span> <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">SerializeHelper</span>
{
    <span class="hljs-comment">//Michael White, Holly Springs Consulting, 2009</span>
    <span class="hljs-comment">//michael@hollyspringsconsulting.com</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> T <span class="hljs-title">DeserializeXML</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params"><span class="hljs-built_in">string</span> xmlData</span>) 
        <span class="hljs-keyword">where</span> T:<span class="hljs-keyword">new</span>()</span>
    {
        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">string</span>.IsNullOrEmpty(xmlData))
            <span class="hljs-keyword">return</span> <span class="hljs-literal">default</span>(T);

        TextReader tr = <span class="hljs-keyword">new</span> StringReader(xmlData);
        T DocItms = <span class="hljs-keyword">new</span> T();
        XmlSerializer xms = <span class="hljs-keyword">new</span> XmlSerializer(DocItms.GetType());
        DocItms = (T)xms.Deserialize(tr);

        <span class="hljs-keyword">return</span> DocItms == <span class="hljs-literal">null</span> ? <span class="hljs-literal">default</span>(T) : DocItms;
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">string</span> <span class="hljs-title">SeralizeObjectToXML</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params">T xmlObject</span>)</span>
    {
        StringBuilder sbTR = <span class="hljs-keyword">new</span> StringBuilder();
        XmlSerializer xmsTR = <span class="hljs-keyword">new</span> XmlSerializer(xmlObject.GetType());
        XmlWriterSettings xwsTR = <span class="hljs-keyword">new</span> XmlWriterSettings();
        
        XmlWriter xmwTR = XmlWriter.Create(sbTR, xwsTR);
        xmsTR.Serialize(xmwTR,xmlObject);
        
        <span class="hljs-keyword">return</span> sbTR.ToString();
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> T <span class="hljs-title">CloneObject</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params">T objClone</span>) 
        <span class="hljs-keyword">where</span> T:<span class="hljs-keyword">new</span>()</span>
    {
        <span class="hljs-built_in">string</span> GetString = SerializeHelper.SeralizeObjectToXML&lt;T&gt;(objClone);
        <span class="hljs-keyword">return</span> SerializeHelper.DeserializeXML&lt;T&gt;(GetString);
    }
}
</code></pre>
    </div></div></div></div><div id="solution10" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 10</h4><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>The best is to implement an <strong>extension method</strong> like</p>

<pre class="lang-cs s-code-block"><code class="hljs language-csharp"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> T <span class="hljs-title">DeepClone</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params"><span class="hljs-keyword">this</span> T originalObject</span>)</span>
{ <span class="hljs-comment">/* the cloning code */</span> }
</code></pre>

<p>and then use it anywhere in the solution by</p>

<pre class="lang-cs s-code-block"><code class="hljs language-csharp"><span class="hljs-keyword">var</span> copy = anyObject.DeepClone();
</code></pre>

<p>We can have the following three implementations:</p>

<ol>
<li><a href="https://stackoverflow.com/a/129395/2094687"><strong>By Serialization</strong></a> (the shortest code)</li>
<li><a href="https://github.com/Burtsev-Alexey/net-object-deep-copy/" rel="noreferrer"><strong>By Reflection</strong></a> - <strong>5x faster</strong></li>
<li><a href="http://www.codeproject.com/Articles/1111658/Fast-Deep-Copy-by-Expression-Trees-C-Sharp" rel="noreferrer"><strong>By Expression Trees</strong></a> - <strong>20x faster</strong></li>
</ol>

<p>All linked methods are well working and were deeply tested.</p>
    </div></div></div></div><div id="solution11" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 11</h4><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>The short answer is you inherit from the ICloneable interface and then implement the .clone function. Clone should do a memberwise copy and perform a deep copy on any member that requires it, then return the resulting object. This is a recursive operation ( it requires that all members of the class you want to clone are either value types or implement ICloneable and that their members are either value types or implement ICloneable, and so on).</p>

<p>For a more detailed explanation on Cloning using ICloneable, check out <a href="https://web.archive.org/web/20120113123300/http://www.ondotnet.com/pub/a/dotnet/2002/11/25/copying.html" rel="noreferrer">this article</a>.</p>

<p>The <em>long</em> answer is "it depends". As mentioned by others, ICloneable is not supported by generics, requires special considerations for circular class references, and is actually viewed by some as a <a href="http://blogs.msdn.com/brada/archive/2004/05/03/125427.aspx" rel="noreferrer">"mistake"</a> in the .NET Framework. The serialization method depends on your objects being serializable, which they may not be and you may have no control over. There is still much debate in the community over which is the "best" practice. In reality, none of the solutions are the one-size fits all best practice for all situations like ICloneable was originally interpreted to be.</p>

<p>See the this <a href="http://developerscon.blogspot.com/2008/06/c-object-clone-wars.html" rel="noreferrer">Developer's Corner article</a> for a few more options (credit to Ian).</p>
    </div></div></div></div><div id="solution12" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 12</h4><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<ol>
<li>Basically you need to implement ICloneable interface and then realize object structure copying. </li>
<li>If it's deep copy of all members, you need to insure (not relating on solution you choose) that all children are clonable as well. </li>
<li>Sometimes you need to be aware of some restriction during this process, for example if you copying the ORM objects most of frameworks allow only one object attached to the session and you MUST NOT make clones of this object, or if it's possible you need to care about session attaching of these objects.</li>
</ol>

<p>Cheers.</p>
    </div></div></div></div><div id="solution13" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 13</h4><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<h2>DeepCloner: Quick, easy, effective NuGet package to solve cloning</h2>

<p>After reading all answers I was surprised no one mentioned this excellent package: </p>

<p><a href="https://github.com/force-net/DeepCloner" rel="noreferrer">DeepCloner GitHub project</a>  </p>

<p><a href="https://www.nuget.org/packages/DeepCloner" rel="noreferrer">DeepCloner NuGet package</a></p>

<p>Elaborating a bit on its README, here are the reason why we chose it at work:</p>

<blockquote>
  <ul>
  <li>It can deep or shallow copy </li>
  <li>In deep cloning all object graph is maintained. </li>
  <li>Uses code-generation in runtime, as result cloning is blazingly fast</li>
  <li>Objects copied by internal structure, no methods or ctors called</li>
  <li>You don't need to mark classes somehow (like Serializable-attribute, or implement interfaces)</li>
  <li>No requirement to specify object type for cloning. Object can be casted to interface or as an abstract object (e.g. you can clone array of ints as abstract Array or IEnumerable; even null can be cloned without any errors)</li>
  <li>Cloned object doesn't have any ability to determine that he is clone (except with very specific methods)</li>
  </ul>
</blockquote>

<h3>Usage:</h3>

<pre class="lang-cs s-code-block"><code class="hljs language-csharp"><span class="hljs-keyword">var</span> deepClone = <span class="hljs-keyword">new</span> { Id = <span class="hljs-number">1</span>, Name = <span class="hljs-string">"222"</span> }.DeepClone();
<span class="hljs-keyword">var</span> shallowClone = <span class="hljs-keyword">new</span> { Id = <span class="hljs-number">1</span>, Name = <span class="hljs-string">"222"</span> }.ShallowClone();
</code></pre>

<h3>Performance:</h3>

<p>The README contains a performance comparison of various cloning libraries and methods: <a href="https://github.com/force-net/DeepCloner#performance" rel="noreferrer">DeepCloner Performance</a>.</p>

<h3>Requirements:</h3>

<ul>
<li><em>.NET 4.0 or higher or .NET Standard 1.3 (.NET Core)</em></li>
<li><em>Requires Full Trust permission set or Reflection permission (MemberAccess)</em></li>
</ul>
    </div></div></div></div><div id="solution14" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 14</h4><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>EDIT: project is discontinued</p>

<p>If you want true cloning to unknown types you can take a look at
<a href="http://fastclone.codeplex.com/" rel="nofollow noreferrer">fastclone</a>.</p>

<p>That's expression based cloning working about 10 times faster than binary serialization and maintaining complete object graph integrity.</p>

<p>That means: if you refer multiple times to the same object in your hierachy, the clone will also have a single instance beeing referenced.</p>

<p>There is no need for interfaces, attributes or any other modification to the objects being cloned.</p>
    </div></div></div></div><div id="solution15" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 15</h4><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Keep things simple and use <a href="http://automapper.org/" rel="nofollow noreferrer">AutoMapper</a> as others mentioned, it's a simple little library to map one object to another... To copy an object to another with the same type, all you need is three lines of code:</p>

<pre class="lang-cs s-code-block"><code class="hljs language-csharp">MyType source = <span class="hljs-keyword">new</span> MyType();
Mapper.CreateMap&lt;MyType, MyType&gt;();
MyType target = Mapper.Map&lt;MyType, MyType&gt;(source);
</code></pre>

<p>The target object is now a copy of the source object.
Not simple enough? Create an extension method to use everywhere in your solution:</p>

<pre class="lang-cs s-code-block"><code class="hljs language-csharp"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> T <span class="hljs-title">Copy</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params"><span class="hljs-keyword">this</span> T source</span>)</span>
{
    T copy = <span class="hljs-literal">default</span>(T);
    Mapper.CreateMap&lt;T, T&gt;();
    copy = Mapper.Map&lt;T, T&gt;(source);
    <span class="hljs-keyword">return</span> copy;
}
</code></pre>

<p>The extension method can be used as follow:</p>

<pre class="lang-cs s-code-block"><code class="hljs language-csharp">MyType copy = source.Copy();
</code></pre>
    </div></div></div></div><div id="solution16" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 16</h4><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>In general, you implement the ICloneable interface and implement Clone yourself.
C# objects have a built-in MemberwiseClone method that performs a shallow copy that can help you out for all the primitives.</p>

<p>For a deep copy, there is no way it can know how to automatically do it.</p>
    </div></div></div></div><div id="solution17" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 17</h4><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>I came up with this to overcome a <a href="http://en.wikipedia.org/wiki/.NET_Framework" rel="noreferrer">.NET</a> shortcoming having to manually deep copy List&lt;T&gt;.</p>

<p>I use this:</p>

<pre class="lang-cs s-code-block"><code class="hljs language-csharp"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">public</span> IEnumerable&lt;SpotPlacement&gt; <span class="hljs-title">CloneList</span>(<span class="hljs-params">List&lt;SpotPlacement&gt; spotPlacements</span>)</span>
{
    <span class="hljs-keyword">foreach</span> (SpotPlacement sp <span class="hljs-keyword">in</span> spotPlacements)
    {
        <span class="hljs-function"><span class="hljs-keyword">yield</span> <span class="hljs-title">return</span> (<span class="hljs-params">SpotPlacement</span>)sp.<span class="hljs-title">Clone</span>()</span>;
    }
}
</code></pre>

<p>And at another place:</p>

<pre class="lang-cs s-code-block"><code class="hljs language-csharp"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">object</span> <span class="hljs-title">Clone</span>()</span>
{
    OrderItem newOrderItem = <span class="hljs-keyword">new</span> OrderItem();
    ...
    newOrderItem._exactPlacements.AddRange(SpotPlacement.CloneList(_exactPlacements));
    ...
    <span class="hljs-keyword">return</span> newOrderItem;
}
</code></pre>

<p>I tried to come up with oneliner that does this, but it's not possible, due to yield not working inside anonymous method blocks.</p>

<p>Better still, use generic List&lt;T&gt; cloner:</p>

<pre class="lang-cs s-code-block"><code class="hljs language-csharp"><span class="hljs-keyword">class</span> <span class="hljs-title">Utility</span>&lt;<span class="hljs-title">T</span>&gt; <span class="hljs-keyword">where</span> <span class="hljs-title">T</span> : <span class="hljs-title">ICloneable</span>
{
    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">public</span> IEnumerable&lt;T&gt; <span class="hljs-title">CloneList</span>(<span class="hljs-params">List&lt;T&gt; tl</span>)</span>
    {
        <span class="hljs-keyword">foreach</span> (T t <span class="hljs-keyword">in</span> tl)
        {
            <span class="hljs-function"><span class="hljs-keyword">yield</span> <span class="hljs-title">return</span> (<span class="hljs-params">T</span>)t.<span class="hljs-title">Clone</span>()</span>;
        }
    }
}
</code></pre>
    </div></div></div></div><div id="solution18" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 18</h4><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<h3>Q. Why would I choose this answer?</h3>
<ul>
<li>Choose this answer if you want the fastest speed .NET is capable of.</li>
<li>Ignore this answer if you want a really, really easy method of cloning.</li>
</ul>
<p>In other words, <a href="http://c2.com/cgi/wiki?PrematureOptimization" rel="noreferrer">go with another answer unless you have a performance bottleneck that needs fixing, and you can prove it with a profiler</a>.</p>
<h3>10x faster than other methods</h3>
<p>The following method of performing a deep clone is:</p>
<ul>
<li>10x faster than anything that involves serialization/deserialization;</li>
<li>Pretty darn close to the theoretical maximum speed .NET is capable of.</li>
</ul>
<h3>And the method ...</h3>
<p>For ultimate speed, you can use <strong>Nested MemberwiseClone to do a deep copy</strong>. Its almost the same speed as copying a value struct, and is much faster than (a) reflection or (b) serialization (as described in other answers on this page).</p>
<p>Note that <strong>if</strong> you use <strong>Nested MemberwiseClone for a deep copy</strong>, you have to manually implement a ShallowCopy for each nested level in the class, and a DeepCopy which calls all said ShallowCopy methods to create a complete clone. This is simple: only a few lines in total, see the demo code below.</p>
<p>Here is the output of the code showing the relative performance difference for 100,000 clones:</p>
<ul>
<li>1.08 seconds for Nested MemberwiseClone on nested structs</li>
<li>4.77 seconds for Nested MemberwiseClone on nested classes</li>
<li>39.93 seconds for Serialization/Deserialization</li>
</ul>
<p>Using Nested MemberwiseClone on a class almost as fast as copying a struct, and copying a struct is pretty darn close to the theoretical maximum speed .NET is capable of.</p>
<pre class="lang-cs s-code-block"><code class="hljs language-csharp">Demo <span class="hljs-number">1</span> of shallow <span class="hljs-keyword">and</span> deep copy, <span class="hljs-keyword">using</span> classes <span class="hljs-keyword">and</span> MemberwiseClone:
  Create Bob
    Bob.Age=<span class="hljs-number">30</span>, Bob.Purchase.Description=Lamborghini
  Clone Bob &gt;&gt; BobsSon
  Adjust BobsSon details
    BobsSon.Age=<span class="hljs-number">2</span>, BobsSon.Purchase.Description=Toy car
  Proof of deep copy: If BobsSon <span class="hljs-keyword">is</span> a <span class="hljs-literal">true</span> clone, then adjusting BobsSon details will <span class="hljs-keyword">not</span> affect Bob:
    Bob.Age=<span class="hljs-number">30</span>, Bob.Purchase.Description=Lamborghini
  Elapsed time: <span class="hljs-number">00</span>:<span class="hljs-number">00</span>:<span class="hljs-number">04.7795670</span>,<span class="hljs-number">30000000</span>

Demo <span class="hljs-number">2</span> of shallow <span class="hljs-keyword">and</span> deep copy, <span class="hljs-keyword">using</span> structs <span class="hljs-keyword">and</span> <span class="hljs-keyword">value</span> copying:
  Create Bob
    Bob.Age=<span class="hljs-number">30</span>, Bob.Purchase.Description=Lamborghini
  Clone Bob &gt;&gt; BobsSon
  Adjust BobsSon details:
    BobsSon.Age=<span class="hljs-number">2</span>, BobsSon.Purchase.Description=Toy car
  Proof of deep copy: If BobsSon <span class="hljs-keyword">is</span> a <span class="hljs-literal">true</span> clone, then adjusting BobsSon details will <span class="hljs-keyword">not</span> affect Bob:
    Bob.Age=<span class="hljs-number">30</span>, Bob.Purchase.Description=Lamborghini
  Elapsed time: <span class="hljs-number">00</span>:<span class="hljs-number">00</span>:<span class="hljs-number">01.0875454</span>,<span class="hljs-number">30000000</span>

Demo <span class="hljs-number">3</span> of deep copy, <span class="hljs-keyword">using</span> <span class="hljs-keyword">class</span> <span class="hljs-title">and</span> <span class="hljs-title">serialize</span>/<span class="hljs-title">deserialize</span>:
  <span class="hljs-title">Elapsed</span> <span class="hljs-title">time</span>: 00:00:39.9339425,30000000
</code></pre>
<p>To understand how to do a deep copy using MemberwiseCopy, here is the demo project that was used to generate the times above:</p>
<pre class="lang-cs s-code-block"><code class="hljs language-csharp"><span class="hljs-comment">// Nested MemberwiseClone example. </span>
<span class="hljs-comment">// Added to demo how to deep copy a reference class.</span>
[<span class="hljs-meta">Serializable</span>] <span class="hljs-comment">// Not required if using MemberwiseClone, only used for speed comparison using serialization.</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Person</span>
{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Person</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> age, <span class="hljs-built_in">string</span> description</span>)</span>
    {
        <span class="hljs-keyword">this</span>.Age = age;
        <span class="hljs-keyword">this</span>.Purchase.Description = description;
    }
    [<span class="hljs-meta">Serializable</span>] <span class="hljs-comment">// Not required if using MemberwiseClone</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">PurchaseType</span>
    {
        <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> Description;
        <span class="hljs-function"><span class="hljs-keyword">public</span> PurchaseType <span class="hljs-title">ShallowCopy</span>()</span>
        {
            <span class="hljs-keyword">return</span> (PurchaseType)<span class="hljs-keyword">this</span>.MemberwiseClone();
        }
    }
    <span class="hljs-keyword">public</span> PurchaseType Purchase = <span class="hljs-keyword">new</span> PurchaseType();
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Age;
    <span class="hljs-comment">// Add this if using nested MemberwiseClone.</span>
    <span class="hljs-comment">// This is a class, which is a reference type, so cloning is more difficult.</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> Person <span class="hljs-title">ShallowCopy</span>()</span>
    {
        <span class="hljs-keyword">return</span> (Person)<span class="hljs-keyword">this</span>.MemberwiseClone();
    }
    <span class="hljs-comment">// Add this if using nested MemberwiseClone.</span>
    <span class="hljs-comment">// This is a class, which is a reference type, so cloning is more difficult.</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> Person <span class="hljs-title">DeepCopy</span>()</span>
    {
            <span class="hljs-comment">// Clone the root ...</span>
        Person other = (Person) <span class="hljs-keyword">this</span>.MemberwiseClone();
            <span class="hljs-comment">// ... then clone the nested class.</span>
        other.Purchase = <span class="hljs-keyword">this</span>.Purchase.ShallowCopy();
        <span class="hljs-keyword">return</span> other;
    }
}
<span class="hljs-comment">// Added to demo how to copy a value struct (this is easy - a deep copy happens by default)</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">struct</span> PersonStruct
{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">PersonStruct</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> age, <span class="hljs-built_in">string</span> description</span>)</span>
    {
        <span class="hljs-keyword">this</span>.Age = age;
        <span class="hljs-keyword">this</span>.Purchase.Description = description;
    }
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">struct</span> PurchaseType
    {
        <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> Description;
    }
    <span class="hljs-keyword">public</span> PurchaseType Purchase;
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Age;
    <span class="hljs-comment">// This is a struct, which is a value type, so everything is a clone by default.</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> PersonStruct <span class="hljs-title">ShallowCopy</span>()</span>
    {
        <span class="hljs-keyword">return</span> (PersonStruct)<span class="hljs-keyword">this</span>;
    }
    <span class="hljs-comment">// This is a struct, which is a value type, so everything is a clone by default.</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> PersonStruct <span class="hljs-title">DeepCopy</span>()</span>
    {
        <span class="hljs-keyword">return</span> (PersonStruct)<span class="hljs-keyword">this</span>;
    }
}
<span class="hljs-comment">// Added only for a speed comparison.</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MyDeepCopy</span>
{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> T <span class="hljs-title">DeepCopy</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params">T obj</span>)</span>
    {
        <span class="hljs-built_in">object</span> result = <span class="hljs-literal">null</span>;
        <span class="hljs-keyword">using</span> (<span class="hljs-keyword">var</span> ms = <span class="hljs-keyword">new</span> MemoryStream())
        {
            <span class="hljs-keyword">var</span> formatter = <span class="hljs-keyword">new</span> BinaryFormatter();
            formatter.Serialize(ms, obj);
            ms.Position = <span class="hljs-number">0</span>;
            result = (T)formatter.Deserialize(ms);
            ms.Close();
        }
        <span class="hljs-keyword">return</span> (T)result;
    }
}
</code></pre>
<p>Then, call the demo from main:</p>
<pre class="lang-cs s-code-block"><code class="hljs language-csharp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">MyMain</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span>
{
    {
        Console.Write(<span class="hljs-string">"Demo 1 of shallow and deep copy, using classes and MemberwiseCopy:\n"</span>);
        <span class="hljs-keyword">var</span> Bob = <span class="hljs-keyword">new</span> Person(<span class="hljs-number">30</span>, <span class="hljs-string">"Lamborghini"</span>);
        Console.Write(<span class="hljs-string">"  Create Bob\n"</span>);
        Console.Write(<span class="hljs-string">"    Bob.Age={0}, Bob.Purchase.Description={1}\n"</span>, Bob.Age, Bob.Purchase.Description);
        Console.Write(<span class="hljs-string">"  Clone Bob &gt;&gt; BobsSon\n"</span>);
        <span class="hljs-keyword">var</span> BobsSon = Bob.DeepCopy();
        Console.Write(<span class="hljs-string">"  Adjust BobsSon details\n"</span>);
        BobsSon.Age = <span class="hljs-number">2</span>;
        BobsSon.Purchase.Description = <span class="hljs-string">"Toy car"</span>;
        Console.Write(<span class="hljs-string">"    BobsSon.Age={0}, BobsSon.Purchase.Description={1}\n"</span>, BobsSon.Age, BobsSon.Purchase.Description);
        Console.Write(<span class="hljs-string">"  Proof of deep copy: If BobsSon is a true clone, then adjusting BobsSon details will not affect Bob:\n"</span>);
        Console.Write(<span class="hljs-string">"    Bob.Age={0}, Bob.Purchase.Description={1}\n"</span>, Bob.Age, Bob.Purchase.Description);
        Debug.Assert(Bob.Age == <span class="hljs-number">30</span>);
        Debug.Assert(Bob.Purchase.Description == <span class="hljs-string">"Lamborghini"</span>);
        <span class="hljs-keyword">var</span> sw = <span class="hljs-keyword">new</span> Stopwatch();
        sw.Start();
        <span class="hljs-built_in">int</span> total = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100000</span>; i++)
        {
            <span class="hljs-keyword">var</span> n = Bob.DeepCopy();
            total += n.Age;
        }
        Console.Write(<span class="hljs-string">"  Elapsed time: {0},{1}\n\n"</span>, sw.Elapsed, total);
    }
    {               
        Console.Write(<span class="hljs-string">"Demo 2 of shallow and deep copy, using structs:\n"</span>);
        <span class="hljs-keyword">var</span> Bob = <span class="hljs-keyword">new</span> PersonStruct(<span class="hljs-number">30</span>, <span class="hljs-string">"Lamborghini"</span>);
        Console.Write(<span class="hljs-string">"  Create Bob\n"</span>);
        Console.Write(<span class="hljs-string">"    Bob.Age={0}, Bob.Purchase.Description={1}\n"</span>, Bob.Age, Bob.Purchase.Description);
        Console.Write(<span class="hljs-string">"  Clone Bob &gt;&gt; BobsSon\n"</span>);
        <span class="hljs-keyword">var</span> BobsSon = Bob.DeepCopy();
        Console.Write(<span class="hljs-string">"  Adjust BobsSon details:\n"</span>);
        BobsSon.Age = <span class="hljs-number">2</span>;
        BobsSon.Purchase.Description = <span class="hljs-string">"Toy car"</span>;
        Console.Write(<span class="hljs-string">"    BobsSon.Age={0}, BobsSon.Purchase.Description={1}\n"</span>, BobsSon.Age, BobsSon.Purchase.Description);
        Console.Write(<span class="hljs-string">"  Proof of deep copy: If BobsSon is a true clone, then adjusting BobsSon details will not affect Bob:\n"</span>);
        Console.Write(<span class="hljs-string">"    Bob.Age={0}, Bob.Purchase.Description={1}\n"</span>, Bob.Age, Bob.Purchase.Description);                
        Debug.Assert(Bob.Age == <span class="hljs-number">30</span>);
        Debug.Assert(Bob.Purchase.Description == <span class="hljs-string">"Lamborghini"</span>);
        <span class="hljs-keyword">var</span> sw = <span class="hljs-keyword">new</span> Stopwatch();
        sw.Start();
        <span class="hljs-built_in">int</span> total = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100000</span>; i++)
        {
            <span class="hljs-keyword">var</span> n = Bob.DeepCopy();
            total += n.Age;
        }
        Console.Write(<span class="hljs-string">"  Elapsed time: {0},{1}\n\n"</span>, sw.Elapsed, total);
    }
    {
        Console.Write(<span class="hljs-string">"Demo 3 of deep copy, using class and serialize/deserialize:\n"</span>);
        <span class="hljs-built_in">int</span> total = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">var</span> sw = <span class="hljs-keyword">new</span> Stopwatch();
        sw.Start();
        <span class="hljs-keyword">var</span> Bob = <span class="hljs-keyword">new</span> Person(<span class="hljs-number">30</span>, <span class="hljs-string">"Lamborghini"</span>);
        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100000</span>; i++)
        {
            <span class="hljs-keyword">var</span> BobsSon = MyDeepCopy.DeepCopy&lt;Person&gt;(Bob);
            total += BobsSon.Age;
        }
        Console.Write(<span class="hljs-string">"  Elapsed time: {0},{1}\n"</span>, sw.Elapsed, total);
    }
    Console.ReadKey();
}
</code></pre>
<p>Again, note that <strong>if</strong> you use <strong>Nested MemberwiseClone for a deep copy</strong>, you have to manually implement a ShallowCopy for each nested level in the class, and a DeepCopy which calls all said ShallowCopy methods to create a complete clone. This is simple: only a few lines in total, see the demo code above.</p>
<h3>Value types vs. References Types</h3>
<p>Note that when it comes to cloning an object, there is is a big difference between a "<strong>struct</strong>" and a "<strong>class</strong>":</p>
<ul>
<li>If you have a "<strong>struct</strong>", it's a <strong>value type</strong> so you can just copy it, and the contents will be cloned (but it will only make a shallow clone unless you use the techniques in this post).</li>
<li>If you have a "<strong>class</strong>", it's a <strong>reference type</strong>, so if you copy it, all you are doing is copying the pointer to it. To create a true clone, you have to be more creative, and use <a href="https://msdn.microsoft.com/en-us/library/system.object.memberwiseclone(v=vs.110).aspx" rel="noreferrer">differences between value types and references types</a> which creates another copy of the original object in memory.</li>
</ul>
<p>See <a href="https://msdn.microsoft.com/en-us/library/system.object.memberwiseclone(v=vs.110).aspx" rel="noreferrer">differences between value types and references types</a>.</p>
<h3>Checksums to aid in debugging</h3>
<ul>
<li>Cloning objects incorrectly can lead to very difficult-to-pin-down bugs. In production code, I tend to implement a checksum to double check that the object has been cloned properly, and hasn't been corrupted by another reference to it. This checksum can be switched off in Release mode.</li>
<li>I find this method quite useful: often, you only want to clone parts of the object, not the entire thing.</li>
</ul>
<h3>Really useful for decoupling many threads from many other threads</h3>
<p>One excellent use case for this code is feeding clones of a nested class or struct into a queue, to implement the producer / consumer pattern.</p>
<ul>
<li>We can have one  (or more) threads modifying a class that they own, then pushing a complete copy of this class into a <code>ConcurrentQueue</code>.</li>
<li>We then have one (or more) threads pulling copies of these classes out and dealing with them.</li>
</ul>
<p>This works extremely well in practice, and allows us to decouple many threads (the producers) from one or more threads (the consumers).</p>
<p>And this method is blindingly fast too: if we use nested structs, it's 35x faster than serializing/deserializing nested classes, and allows us to take advantage of all of the threads available on the machine.</p>
<h1>Update</h1>
<p>Apparently, ExpressMapper is as fast, if not faster, than hand coding such as above. I might have to see how they compare with a profiler.</p>
    </div></div></div></div><div id="solution19" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 19</h4><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p><em>Disclaimer: I'm the author of the mentioned package.</em></p>

<p>I was surprised how the top answers to this question in 2019 still use serialization or reflection. </p>

<h2>Serialization is limiting (requires attributes, specific constructors, etc.) and is very slow</h2>

<p><code>BinaryFormatter</code> requires the <code>Serializable</code> attribute, <code>JsonConverter</code> requires a parameterless constructor or attributes, neither handle read only fields or interfaces very well and both are 10-30x slower than necessary.</p>

<h2>Expression Trees</h2>

<p>You can instead use <em>Expression Trees</em> or <em>Reflection.Emit</em> to generate cloning code only once, then use that compiled code instead of slow reflection or serialization.</p>

<p>Having come across the problem myself and seeing no satisfactory solution, I decided to create a package that does just that and <strong>works with every type and is a almost as fast as custom written code</strong>.</p>

<p>You can find the project on GitHub: <a href="https://github.com/marcelltoth/ObjectCloner" rel="noreferrer">https://github.com/marcelltoth/ObjectCloner</a></p>

<h2>Usage</h2>

<p>You can install it from NuGet. Either get the <code>ObjectCloner</code> package and use it as:</p>

<pre class="lang-cs s-code-block"><code class="hljs language-csharp"><span class="hljs-keyword">var</span> clone = ObjectCloner.DeepClone(original);
</code></pre>

<p>or if you don't mind polluting your object type with extensions get <code>ObjectCloner.Extensions</code> as well and write:</p>

<pre class="lang-cs s-code-block"><code class="hljs language-csharp"><span class="hljs-keyword">var</span> clone = original.DeepClone();
</code></pre>

<h2>Performance</h2>

<p>A simple benchmark of cloning a class hierarchy showed performance ~3x faster than using Reflection, ~12x faster than Newtonsoft.Json serialization and ~36x faster than the highly suggested <code>BinaryFormatter</code>.</p>
    </div></div></div></div><div id="solution20" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 20</h4><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>I've seen it implemented through reflection as well. Basically there was a method that would iterate through the members of an object and appropriately copy them to the new object. When it reached reference types or collections I think it did a recursive call on itself. Reflection is expensive, but it worked pretty well.</p>
    </div></div></div></div><div id="solution21" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 21</h4><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Here is a deep copy implementation:</p>

<pre class="lang-cs s-code-block"><code class="hljs language-csharp"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">object</span> <span class="hljs-title">CloneObject</span>(<span class="hljs-params"><span class="hljs-built_in">object</span> opSource</span>)</span>
{
    <span class="hljs-comment">//grab the type and create a new instance of that type</span>
    Type opSourceType = opSource.GetType();
    <span class="hljs-built_in">object</span> opTarget = CreateInstanceOfType(opSourceType);

    <span class="hljs-comment">//grab the properties</span>
    PropertyInfo[] opPropertyInfo = opSourceType.GetProperties(BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance);

    <span class="hljs-comment">//iterate over the properties and if it has a 'set' method assign it from the source TO the target</span>
    <span class="hljs-keyword">foreach</span> (PropertyInfo item <span class="hljs-keyword">in</span> opPropertyInfo)
    {
        <span class="hljs-keyword">if</span> (item.CanWrite)
        {
            <span class="hljs-comment">//value types can simply be 'set'</span>
            <span class="hljs-keyword">if</span> (item.PropertyType.IsValueType || item.PropertyType.IsEnum || item.PropertyType.Equals(<span class="hljs-keyword">typeof</span>(System.String)))
            {
                item.SetValue(opTarget, item.GetValue(opSource, <span class="hljs-literal">null</span>), <span class="hljs-literal">null</span>);
            }
            <span class="hljs-comment">//object/complex types need to recursively call this method until the end of the tree is reached</span>
            <span class="hljs-keyword">else</span>
            {
                <span class="hljs-built_in">object</span> opPropertyValue = item.GetValue(opSource, <span class="hljs-literal">null</span>);
                <span class="hljs-keyword">if</span> (opPropertyValue == <span class="hljs-literal">null</span>)
                {
                    item.SetValue(opTarget, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>);
                }
                <span class="hljs-keyword">else</span>
                {
                    item.SetValue(opTarget, CloneObject(opPropertyValue), <span class="hljs-literal">null</span>);
                }
            }
        }
    }
    <span class="hljs-comment">//return the new item</span>
    <span class="hljs-keyword">return</span> opTarget;
}
</code></pre>
    </div></div></div></div><div id="solution22" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 22</h4><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>As I couldn't find a cloner that meets all my requirements in different projects, I created a deep cloner that can be configured and adapted to different code structures instead of adapting my code to meet the cloners requirements. Its achieved by adding annotations to the code that shall be cloned or you just leave the code as it is to have the default behaviour. It uses reflection, type caches and is based on <a href="https://fasterflect.codeplex.com/" rel="noreferrer">fasterflect</a>. The cloning process is very fast for a huge amount of data and a high object hierarchy (compared to other reflection/serialization based algorithms). </p>

<p><a href="https://github.com/kalisohn/CloneBehave" rel="noreferrer">https://github.com/kalisohn/CloneBehave</a></p>

<p>Also available as a nuget package:
<a href="https://www.nuget.org/packages/Clone.Behave/1.0.0" rel="noreferrer">https://www.nuget.org/packages/Clone.Behave/1.0.0</a></p>

<p>For example: The following code will deepClone Address, but only perform a shallow copy of the _currentJob field. </p>

<pre class="lang-cs s-code-block"><code class="hljs language-csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> 
{
  [<span class="hljs-meta">DeepClone(DeepCloneBehavior.Shallow)</span>]
  <span class="hljs-keyword">private</span> Job _currentJob;      

  <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> Name { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }

  <span class="hljs-keyword">public</span> Job CurrentJob 
  { 
    <span class="hljs-keyword">get</span>{ <span class="hljs-keyword">return</span> _currentJob; }
    <span class="hljs-keyword">set</span>{ _currentJob = <span class="hljs-keyword">value</span>; }
  }

  <span class="hljs-keyword">public</span> Person Manager { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }
}

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Address</span> 
{      
  <span class="hljs-keyword">public</span> Person PersonLivingHere { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }
}

Address adr = <span class="hljs-keyword">new</span> Address();
adr.PersonLivingHere = <span class="hljs-keyword">new</span> Person(<span class="hljs-string">"John"</span>);
adr.PersonLivingHere.BestFriend = <span class="hljs-keyword">new</span> Person(<span class="hljs-string">"James"</span>);
adr.PersonLivingHere.CurrentJob = <span class="hljs-keyword">new</span> Job(<span class="hljs-string">"Programmer"</span>);

Address adrClone = adr.Clone();

<span class="hljs-comment">//RESULT</span>
adr.PersonLivingHere == adrClone.PersonLivingHere <span class="hljs-comment">//false</span>
adr.PersonLivingHere.Manager == adrClone.PersonLivingHere.Manager <span class="hljs-comment">//false</span>
adr.PersonLivingHere.CurrentJob == adrClone.PersonLivingHere.CurrentJob <span class="hljs-comment">//true</span>
adr.PersonLivingHere.CurrentJob.AnyProperty == adrClone.PersonLivingHere.CurrentJob.AnyProperty <span class="hljs-comment">//true</span>
</code></pre>
    </div></div></div></div><div id="solution23" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 23</h4><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Create an extension:</p>
<pre class="lang-cs s-code-block"><code class="hljs language-csharp"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> T <span class="hljs-title">Clone</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params"><span class="hljs-keyword">this</span> T theObject</span>)</span>
{
    <span class="hljs-built_in">string</span> jsonData = JsonConvert.SerializeObject(theObject);
    <span class="hljs-keyword">return</span> JsonConvert.DeserializeObject&lt;T&gt;(jsonData);
}
</code></pre>
<p>And call it like this:</p>
<pre class="lang-cs s-code-block"><code class="hljs language-csharp">NewObject = OldObject.Clone();
</code></pre>
    </div></div></div></div><div id="solution24" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 24</h4><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<h1>Code Generator</h1>

<p>We have seen a lot of ideas from serialization over manual implementation to reflection and I want to propose a totally different approach using the <a href="https://github.com/Toxantron/CGbR#cloneable" rel="noreferrer">CGbR Code Generator</a>. The generate clone method is memory and CPU efficient and therefor 300x faster as the standard DataContractSerializer.</p>

<p>All you need is a partial class definition with <code>ICloneable</code> and the generator does the rest:</p>

<pre class="lang-cs s-code-block"><code class="hljs language-csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Root</span> : <span class="hljs-title">ICloneable</span>
{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Root</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> number</span>)</span>
    {
        _number = number;
    }
    <span class="hljs-keyword">private</span> <span class="hljs-built_in">int</span> _number;

    <span class="hljs-keyword">public</span> Partial[] Partials { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }

    <span class="hljs-keyword">public</span> IList&lt;<span class="hljs-built_in">ulong</span>&gt; Numbers { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">object</span> <span class="hljs-title">Clone</span>()</span>
    {
        <span class="hljs-keyword">return</span> Clone(<span class="hljs-literal">true</span>);
    }

    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Root</span>()</span>
    {
    }
} 

<span class="hljs-keyword">public</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Root</span>
{
    <span class="hljs-function"><span class="hljs-keyword">public</span> Root <span class="hljs-title">Clone</span>(<span class="hljs-params"><span class="hljs-built_in">bool</span> deep</span>)</span>
    {
        <span class="hljs-keyword">var</span> copy = <span class="hljs-keyword">new</span> Root();
        <span class="hljs-comment">// All value types can be simply copied</span>
        copy._number = _number; 
        <span class="hljs-keyword">if</span> (deep)
        {
            <span class="hljs-comment">// In a deep clone the references are cloned </span>
            <span class="hljs-keyword">var</span> tempPartials = <span class="hljs-keyword">new</span> Partial[Partials.Length];
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; Partials.Length; i++)
            {
                <span class="hljs-keyword">var</span> <span class="hljs-keyword">value</span> = Partials[i];
                <span class="hljs-keyword">value</span> = <span class="hljs-keyword">value</span>.Clone(<span class="hljs-literal">true</span>);
                tempPartials[i] = <span class="hljs-keyword">value</span>;
            }
            copy.Partials = tempPartials;
            <span class="hljs-keyword">var</span> tempNumbers = <span class="hljs-keyword">new</span> List&lt;<span class="hljs-built_in">ulong</span>&gt;(Numbers.Count);
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; Numbers.Count; i++)
            {
                <span class="hljs-keyword">var</span> <span class="hljs-keyword">value</span> = Numbers[i];
                tempNumbers.Add(<span class="hljs-keyword">value</span>);
            }
            copy.Numbers = tempNumbers;
        }
        <span class="hljs-keyword">else</span>
        {
            <span class="hljs-comment">// In a shallow clone only references are copied</span>
            copy.Partials = Partials; 
            copy.Numbers = Numbers; 
        }
        <span class="hljs-keyword">return</span> copy;
    }
}
</code></pre>

<p><strong>Note:</strong> Latest version has a more null checks, but I left them out for better understanding.</p>
    </div></div></div></div><div id="solution25" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 25</h4><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>I like Copyconstructors like that:</p>

<pre class="lang-cs s-code-block"><code class="hljs language-csharp">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">AnyObject</span>(<span class="hljs-params">AnyObject anyObject</span>)</span>
    {
        <span class="hljs-keyword">foreach</span> (<span class="hljs-function"><span class="hljs-keyword">var</span> property <span class="hljs-keyword">in</span> <span class="hljs-title">typeof</span>(<span class="hljs-params">AnyObject</span>).<span class="hljs-title">GetProperties</span>())</span>
        {
            property.SetValue(<span class="hljs-keyword">this</span>, property.GetValue(anyObject));
        }
        <span class="hljs-keyword">foreach</span> (<span class="hljs-function"><span class="hljs-keyword">var</span> field <span class="hljs-keyword">in</span> <span class="hljs-title">typeof</span>(<span class="hljs-params">AnyObject</span>).<span class="hljs-title">GetFields</span>())</span>
        {
            field.SetValue(<span class="hljs-keyword">this</span>, field.GetValue(anyObject));
        }
    }
</code></pre>

<p>If you have more things to copy add them</p>
    </div></div></div></div><div id="solution26" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 26</h4><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>This method solved the problem for me:</p>

<pre class="lang-cs s-code-block"><code class="hljs language-csharp"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> MyObj <span class="hljs-title">DeepCopy</span>(<span class="hljs-params">MyObj source</span>)</span>
        {

            <span class="hljs-keyword">var</span> DeserializeSettings = <span class="hljs-keyword">new</span> JsonSerializerSettings { ObjectCreationHandling = ObjectCreationHandling.Replace };

            <span class="hljs-keyword">return</span> JsonConvert.DeserializeObject&lt;MyObj &gt;(JsonConvert.SerializeObject(source), DeserializeSettings);

        }
</code></pre>

<p>Use it like this: <code>MyObj a = DeepCopy(b);</code></p>
    </div></div></div></div><div id="solution27" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 27</h4><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Here a solution fast and easy that worked for me without relaying on Serialization/Deserialization. </p>

<pre class="lang-cs s-code-block"><code class="hljs language-csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span>
{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">virtual</span> MyClass <span class="hljs-title">DeepClone</span>()</span>
    {
        <span class="hljs-keyword">var</span> returnObj = (MyClass)MemberwiseClone();
        <span class="hljs-keyword">var</span> type = returnObj.GetType();
        <span class="hljs-keyword">var</span> fieldInfoArray = type.GetRuntimeFields().ToArray();

        <span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">var</span> fieldInfo <span class="hljs-keyword">in</span> fieldInfoArray)
        {
            <span class="hljs-built_in">object</span> sourceFieldValue = fieldInfo.GetValue(<span class="hljs-keyword">this</span>);
            <span class="hljs-keyword">if</span> (!(sourceFieldValue <span class="hljs-keyword">is</span> MyClass))
            {
                <span class="hljs-keyword">continue</span>;
            }

            <span class="hljs-keyword">var</span> sourceObj = (MyClass)sourceFieldValue;
            <span class="hljs-keyword">var</span> clonedObj = sourceObj.DeepClone();
            fieldInfo.SetValue(returnObj, clonedObj);
        }
        <span class="hljs-keyword">return</span> returnObj;
    }
}
</code></pre>

<p><strong>EDIT</strong>:
requires </p>

<pre class="lang-cs s-code-block"><code class="hljs language-csharp">    <span class="hljs-keyword">using</span> System.Linq;
    <span class="hljs-keyword">using</span> System.Reflection;
</code></pre>

<p>That's How I used it</p>

<pre class="lang-cs s-code-block"><code class="hljs language-csharp"><span class="hljs-function"><span class="hljs-keyword">public</span> MyClass <span class="hljs-title">Clone</span>(<span class="hljs-params">MyClass theObjectIneededToClone</span>)</span>
{
    MyClass clonedObj = theObjectIneededToClone.DeepClone();
}
</code></pre>
    </div></div></div></div><div id="solution28" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 28</h4><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Follow these steps:</p>

<ul>
<li>Define an <code>ISelf&lt;T&gt;</code> with a read-only <code>Self</code> property that returns <code>T</code>, and <code>ICloneable&lt;out T&gt;</code>, which derives from <code>ISelf&lt;T&gt;</code> and includes a method <code>T Clone()</code>.</li>
<li>Then define a <code>CloneBase</code> type which implements a <code>protected virtual generic VirtualClone</code> casting <code>MemberwiseClone</code> to the passed-in type.  </li>
<li>Each derived type should implement <code>VirtualClone</code> by calling the base clone method and then doing whatever needs to be done to properly clone those aspects of the derived type which the parent VirtualClone method hasn't yet handled.</li>
</ul>

<p>For maximum inheritance versatility, classes exposing public cloning functionality should be <code>sealed</code>, but derive from a base class which is otherwise identical except for the lack of cloning.  Rather than passing variables of the explicit clonable type, take a parameter of type <code>ICloneable&lt;theNonCloneableType&gt;</code>.  This will allow a routine that expects a cloneable derivative of  <code>Foo</code> to work with a cloneable derivative of <code>DerivedFoo</code>, but also allow the creation of non-cloneable derivatives of <code>Foo</code>.</p>
    </div></div></div></div><div id="solution29" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 29</h4><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>As nearly all of the answers to this question have been unsatisfactory or plainly don't work in my situation, I have authored <a href="https://github.com/replaysMike/AnyClone" rel="noreferrer">AnyClone</a> which is entirely implemented with reflection and solved all of the needs here. I was unable to get serialization to work in a complicated scenario with complex structure, and <code>IClonable</code> is less than ideal - in fact it shouldn't even be necessary.</p>

<p>Standard ignore attributes are supported using <code>[IgnoreDataMember]</code>, <code>[NonSerialized]</code>. Supports complex collections, properties without setters, readonly fields etc.</p>

<p>I hope it helps someone else out there who ran into the same problems I did.</p>
    </div></div></div></div><div id="solution30" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 30</h4><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>I have created a version of the accepted answer that works with both '[Serializable]' and '[DataContract]'. It has been a while since I wrote it, but if I remember correctly [DataContract] needed a different serializer.</p>

<p>Requires <em>System, System.IO, System.Runtime.Serialization, System.Runtime.Serialization.Formatters.Binary, System.Xml</em>;</p>

<pre class="lang-cs s-code-block"><code class="hljs language-csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title">ObjectCopier</span>
{

    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span>
    <span class="hljs-comment"><span class="hljs-doctag">///</span> Perform a deep Copy of an object that is marked with '[Serializable]' or '[DataContract]'</span>
    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span>
    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;typeparam name="T"&gt;</span>The type of object being copied.<span class="hljs-doctag">&lt;/typeparam&gt;</span></span>
    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;param name="source"&gt;</span>The object instance to copy.<span class="hljs-doctag">&lt;/param&gt;</span></span>
    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;returns&gt;</span>The copied object.<span class="hljs-doctag">&lt;/returns&gt;</span></span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> T <span class="hljs-title">Clone</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params">T source</span>)</span>
    {
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span>(T).IsSerializable == <span class="hljs-literal">true</span>)
        {
            <span class="hljs-keyword">return</span> CloneUsingSerializable&lt;T&gt;(source);
        }

        <span class="hljs-keyword">if</span> (IsDataContract(<span class="hljs-keyword">typeof</span>(T)) == <span class="hljs-literal">true</span>)
        {
            <span class="hljs-keyword">return</span> CloneUsingDataContracts&lt;T&gt;(source);
        }

        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ArgumentException(<span class="hljs-string">"The type must be Serializable or use DataContracts."</span>, <span class="hljs-string">"source"</span>);
    }


    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span>
    <span class="hljs-comment"><span class="hljs-doctag">///</span> Perform a deep Copy of an object that is marked with '[Serializable]'</span>
    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span>
    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;remarks&gt;</span></span>
    <span class="hljs-comment"><span class="hljs-doctag">///</span> Found on http://stackoverflow.com/questions/78536/cloning-objects-in-c-sharp</span>
    <span class="hljs-comment"><span class="hljs-doctag">///</span> Uses code found on CodeProject, which allows free use in third party apps</span>
    <span class="hljs-comment"><span class="hljs-doctag">///</span> - http://www.codeproject.com/KB/tips/SerializedObjectCloner.aspx</span>
    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/remarks&gt;</span></span>
    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;typeparam name="T"&gt;</span>The type of object being copied.<span class="hljs-doctag">&lt;/typeparam&gt;</span></span>
    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;param name="source"&gt;</span>The object instance to copy.<span class="hljs-doctag">&lt;/param&gt;</span></span>
    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;returns&gt;</span>The copied object.<span class="hljs-doctag">&lt;/returns&gt;</span></span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> T <span class="hljs-title">CloneUsingSerializable</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params">T source</span>)</span>
    {
        <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">typeof</span>(T).IsSerializable)
        {
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ArgumentException(<span class="hljs-string">"The type must be serializable."</span>, <span class="hljs-string">"source"</span>);
        }

        <span class="hljs-comment">// Don't serialize a null object, simply return the default for that object</span>
        <span class="hljs-keyword">if</span> (Object.ReferenceEquals(source, <span class="hljs-literal">null</span>))
        {
            <span class="hljs-keyword">return</span> <span class="hljs-literal">default</span>(T);
        }

        IFormatter formatter = <span class="hljs-keyword">new</span> BinaryFormatter();
        Stream stream = <span class="hljs-keyword">new</span> MemoryStream();
        <span class="hljs-keyword">using</span> (stream)
        {
            formatter.Serialize(stream, source);
            stream.Seek(<span class="hljs-number">0</span>, SeekOrigin.Begin);
            <span class="hljs-keyword">return</span> (T)formatter.Deserialize(stream);
        }
    }


    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span>
    <span class="hljs-comment"><span class="hljs-doctag">///</span> Perform a deep Copy of an object that is marked with '[DataContract]'</span>
    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span>
    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;typeparam name="T"&gt;</span>The type of object being copied.<span class="hljs-doctag">&lt;/typeparam&gt;</span></span>
    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;param name="source"&gt;</span>The object instance to copy.<span class="hljs-doctag">&lt;/param&gt;</span></span>
    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;returns&gt;</span>The copied object.<span class="hljs-doctag">&lt;/returns&gt;</span></span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> T <span class="hljs-title">CloneUsingDataContracts</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params">T source</span>)</span>
    {
        <span class="hljs-keyword">if</span> (IsDataContract(<span class="hljs-keyword">typeof</span>(T)) == <span class="hljs-literal">false</span>)
        {
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ArgumentException(<span class="hljs-string">"The type must be a data contract."</span>, <span class="hljs-string">"source"</span>);
        }

        <span class="hljs-comment">// ** Don't serialize a null object, simply return the default for that object</span>
        <span class="hljs-keyword">if</span> (Object.ReferenceEquals(source, <span class="hljs-literal">null</span>))
        {
            <span class="hljs-keyword">return</span> <span class="hljs-literal">default</span>(T);
        }

        DataContractSerializer dcs = <span class="hljs-keyword">new</span> DataContractSerializer(<span class="hljs-keyword">typeof</span>(T));
        <span class="hljs-keyword">using</span>(Stream stream = <span class="hljs-keyword">new</span> MemoryStream())
        {
            <span class="hljs-keyword">using</span> (XmlDictionaryWriter writer = XmlDictionaryWriter.CreateBinaryWriter(stream))
            {
                dcs.WriteObject(writer, source);
                writer.Flush();
                stream.Seek(<span class="hljs-number">0</span>, SeekOrigin.Begin);
                <span class="hljs-keyword">using</span> (XmlDictionaryReader reader = XmlDictionaryReader.CreateBinaryReader(stream, XmlDictionaryReaderQuotas.Max))
                {
                    <span class="hljs-keyword">return</span> (T)dcs.ReadObject(reader);
                }
            }
        }
    }


    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span>
    <span class="hljs-comment"><span class="hljs-doctag">///</span> Helper function to check if a class is a [DataContract]</span>
    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span>
    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;param name="type"&gt;</span>The type of the object to check.<span class="hljs-doctag">&lt;/param&gt;</span></span>
    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;returns&gt;</span>Boolean flag indicating if the class is a DataContract (true) or not (false) <span class="hljs-doctag">&lt;/returns&gt;</span></span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">bool</span> <span class="hljs-title">IsDataContract</span>(<span class="hljs-params">Type type</span>)</span>
    {
        <span class="hljs-built_in">object</span>[] attributes = type.GetCustomAttributes(<span class="hljs-keyword">typeof</span>(DataContractAttribute), <span class="hljs-literal">false</span>);
        <span class="hljs-keyword">return</span> attributes.Length == <span class="hljs-number">1</span>;
    }

} 
</code></pre>
    </div></div></div></div></div></div><div class="widget"><a href="/questions/why-is-processing-a-sorted-array-faster-than-processing-an-unsorted-array-1657385497444">Why is processing a sorted array faster than processing an unsorted array?</a><a href="/questions/collapse-concatenate-aggregate-a-column-to-a-single-comma-separated-string-within-each-group-1657387870901">Collapse / concatenate / aggregate a column to a single comma separated string within each group</a><a href="/questions/how-to-parse-json-in-java-1657384575136">How to parse JSON in Java</a><a href="/questions/how-can-i-group-an-array-of-objects-by-key-1657388065372">How can I group an array of objects by key?</a><a href="/questions/what-does-this-symbol-mean-in-javascript-1657387632971">What does this symbol mean in JavaScript?</a><a href="/questions/cross-thread-operation-not-valid:-control-accessed-from-a-thread-other-than-the-thread-it-was-created-on-1657387659019">Cross-thread operation not valid: Control accessed from a thread other than the thread it was created on</a><a href="/questions/how-do-i-expire-a-php-session-after-30-minutes-1657387990658">How do I expire a PHP session after 30 minutes?</a><a href="/questions/why-are-global-variables-evil-closed-1657388260006">Why are global variables evil? [closed]</a><a href="/questions/how-do-i-pass-variables-and-data-from-php-to-javascript-1657384684553">How do I pass variables and data from PHP to JavaScript?</a><a href="/questions/how-to-deal-with-settingwithcopywarning-in-pandas-1657384778377">How to deal with SettingWithCopyWarning in Pandas</a><a href="/questions/i-just-assigned-a-variable-but-echo-dollarvariable-shows-something-else-1657387574561">I just assigned a variable, but echo $variable shows something else</a><a href="/questions/how-to-calculate-the-difference-between-two-dates-using-php-1657387409560">How to calculate the difference between two dates using PHP?</a><a href="/questions/is-there-a-unique-android-device-id-1657388089268">Is there a unique Android device ID?</a><a href="/questions/get-the-values-from-the-%22get%22-parameters-(javascript)-duplicate-1657387656693">Get the values from the &quot;GET&quot; parameters (JavaScript) [duplicate]</a><a href="/questions/how-do-function-pointers-in-c-work-1657388332074">How do function pointers in C work?</a><a href="/questions/what-to-do-regular-expression-pattern-doesn&#x27;t-match-anywhere-in-string-1657388095896">What to do Regular expression pattern doesn&#x27;t match anywhere in string?</a><a href="/questions/how-can-i-convert-ereg-expressions-to-preg-in-php-1657387652855">How can I convert ereg expressions to preg in PHP?</a><a href="/questions/the-viewdata-item-that-has-the-key-&#x27;xxx&#x27;-is-of-type-&#x27;system.int32&#x27;-but-must-be-of-type-&#x27;ienumerablelessselectlistitemgreater&#x27;-1657388454191">The ViewData item that has the key &#x27;XXX&#x27; is of type &#x27;System.Int32&#x27; but must be of type &#x27;IEnumerable&lt;SelectListItem&gt;&#x27;</a><a href="/questions/how-do-i-set-clear-and-toggle-a-single-bit-1657388227052">How do I set, clear, and toggle a single bit?</a><a href="/questions/how-do-i-attach-events-to-dynamic-html-elements-with-jquery-duplicate-1657387992964">How do I attach events to dynamic HTML elements with jQuery? [duplicate]</a></div></div><span class="cursor-pointer text-lg p-2" style="position:fixed;bottom:20px;left:20px;background:#000;z-index:2000;color:white">Go go top</span></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"data":{"answer":["\n\u0026lt;p\u0026gt;Whereas one approach is to implement the \u0026lt;a href=\u0026quot;http://msdn.microsoft.com/en-us/library/system.icloneable.aspx\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;\u0026lt;code\u0026gt;ICloneable\u0026lt;/code\u0026gt;\u0026lt;/a\u0026gt; interface (described \u0026lt;a href=\u0026quot;https://stackoverflow.com/questions/78536/cloning-objects-in-c/78568#78568\u0026quot;\u0026gt;here\u0026lt;/a\u0026gt;, so I won\u0026apos;t regurgitate), here\u0026apos;s a nice deep clone object copier I found on \u0026lt;a href=\u0026quot;http://www.codeproject.com/Articles/23832/Implementing-Deep-Cloning-via-Serializing-objects\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;The Code Project\u0026lt;/a\u0026gt; a while ago and incorporated it into our code.\nAs mentioned elsewhere, it requires your objects to be serializable.\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-cs s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-csharp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;using\u0026lt;/span\u0026gt; System;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;using\u0026lt;/span\u0026gt; System.IO;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;using\u0026lt;/span\u0026gt; System.Runtime.Serialization;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;using\u0026lt;/span\u0026gt; System.Runtime.Serialization.Formatters.Binary;\n\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-doctag\u0026quot;\u0026gt;///\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-doctag\u0026quot;\u0026gt;\u0026amp;lt;summary\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-doctag\u0026quot;\u0026gt;///\u0026lt;/span\u0026gt; Reference Article http://www.codeproject.com/KB/tips/SerializedObjectCloner.aspx\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-doctag\u0026quot;\u0026gt;///\u0026lt;/span\u0026gt; Provides a method for performing a deep copy of an object.\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-doctag\u0026quot;\u0026gt;///\u0026lt;/span\u0026gt; Binary Serialization is used to perform the copy.\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-doctag\u0026quot;\u0026gt;///\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-doctag\u0026quot;\u0026gt;\u0026amp;lt;/summary\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;static\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;ObjectCopier\u0026lt;/span\u0026gt;\n{\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-doctag\u0026quot;\u0026gt;///\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-doctag\u0026quot;\u0026gt;\u0026amp;lt;summary\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-doctag\u0026quot;\u0026gt;///\u0026lt;/span\u0026gt; Perform a deep copy of the object via serialization.\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-doctag\u0026quot;\u0026gt;///\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-doctag\u0026quot;\u0026gt;\u0026amp;lt;/summary\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-doctag\u0026quot;\u0026gt;///\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-doctag\u0026quot;\u0026gt;\u0026amp;lt;typeparam name=\u0026quot;T\u0026quot;\u0026amp;gt;\u0026lt;/span\u0026gt;The type of object being copied.\u0026lt;span class=\u0026quot;hljs-doctag\u0026quot;\u0026gt;\u0026amp;lt;/typeparam\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-doctag\u0026quot;\u0026gt;///\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-doctag\u0026quot;\u0026gt;\u0026amp;lt;param name=\u0026quot;source\u0026quot;\u0026amp;gt;\u0026lt;/span\u0026gt;The object instance to copy.\u0026lt;span class=\u0026quot;hljs-doctag\u0026quot;\u0026gt;\u0026amp;lt;/param\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-doctag\u0026quot;\u0026gt;///\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-doctag\u0026quot;\u0026gt;\u0026amp;lt;returns\u0026amp;gt;\u0026lt;/span\u0026gt;A deep copy of the object.\u0026lt;span class=\u0026quot;hljs-doctag\u0026quot;\u0026gt;\u0026amp;lt;/returns\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;static\u0026lt;/span\u0026gt; T \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;Clone\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;T\u0026lt;/span\u0026gt;\u0026amp;gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;T source\u0026lt;/span\u0026gt;)\u0026lt;/span\u0026gt;\n    {\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (!\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typeof\u0026lt;/span\u0026gt;(T).IsSerializable)\n        {\n            \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;throw\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; ArgumentException(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;The type must be serializable.\u0026quot;\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;nameof\u0026lt;/span\u0026gt;(source));\n        }\n\n        \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Don\u0026apos;t serialize a null object, simply return the default for that object\u0026lt;/span\u0026gt;\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (ReferenceEquals(source, \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;null\u0026lt;/span\u0026gt;)) \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;default\u0026lt;/span\u0026gt;;\n\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;using\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; Stream stream = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; MemoryStream();\n        IFormatter formatter = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; BinaryFormatter();\n        formatter.Serialize(stream, source);\n        stream.Seek(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;, SeekOrigin.Begin);\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; (T)formatter.Deserialize(stream);\n    }\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;The idea is that it serializes your object and then deserializes it into a fresh object. The benefit is that you don\u0026apos;t have to concern yourself about cloning everything when an object gets too complex.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;In case of you prefer to use the new \u0026lt;a href=\u0026quot;http://en.wikipedia.org/wiki/Extension_method\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;extension methods\u0026lt;/a\u0026gt; of C# 3.0, change the method to have the following signature:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-cs s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-csharp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;static\u0026lt;/span\u0026gt; T \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;Clone\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;T\u0026lt;/span\u0026gt;\u0026amp;gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;this\u0026lt;/span\u0026gt; T source\u0026lt;/span\u0026gt;)\u0026lt;/span\u0026gt;\n{\n   \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// ...\u0026lt;/span\u0026gt;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;Now the method call simply becomes \u0026lt;code\u0026gt;objectBeingCloned.Clone();\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;EDIT\u0026lt;/strong\u0026gt; (January 10 2015) Thought I\u0026apos;d revisit this, to mention I recently started using (Newtonsoft) Json to do this, it \u0026lt;a href=\u0026quot;http://maxondev.com/serialization-performance-comparison-c-net-formats-frameworks-xmldatacontractserializer-xmlserializer-binaryformatter-json-newtonsoft-servicestack-text/\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;should be\u0026lt;/a\u0026gt; lighter, and avoids the overhead of [Serializable] tags. (\u0026lt;strong\u0026gt;NB\u0026lt;/strong\u0026gt; @atconway has pointed out in the comments that private members are not cloned using the JSON method)\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-cs s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-csharp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-doctag\u0026quot;\u0026gt;///\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-doctag\u0026quot;\u0026gt;\u0026amp;lt;summary\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-doctag\u0026quot;\u0026gt;///\u0026lt;/span\u0026gt; Perform a deep Copy of the object, using Json as a serialization method. \u0026lt;span class=\u0026quot;hljs-doctag\u0026quot;\u0026gt;NOTE:\u0026lt;/span\u0026gt; Private members are not cloned using this method.\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-doctag\u0026quot;\u0026gt;///\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-doctag\u0026quot;\u0026gt;\u0026amp;lt;/summary\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-doctag\u0026quot;\u0026gt;///\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-doctag\u0026quot;\u0026gt;\u0026amp;lt;typeparam name=\u0026quot;T\u0026quot;\u0026amp;gt;\u0026lt;/span\u0026gt;The type of object being copied.\u0026lt;span class=\u0026quot;hljs-doctag\u0026quot;\u0026gt;\u0026amp;lt;/typeparam\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-doctag\u0026quot;\u0026gt;///\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-doctag\u0026quot;\u0026gt;\u0026amp;lt;param name=\u0026quot;source\u0026quot;\u0026amp;gt;\u0026lt;/span\u0026gt;The object instance to copy.\u0026lt;span class=\u0026quot;hljs-doctag\u0026quot;\u0026gt;\u0026amp;lt;/param\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-doctag\u0026quot;\u0026gt;///\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-doctag\u0026quot;\u0026gt;\u0026amp;lt;returns\u0026amp;gt;\u0026lt;/span\u0026gt;The copied object.\u0026lt;span class=\u0026quot;hljs-doctag\u0026quot;\u0026gt;\u0026amp;lt;/returns\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;static\u0026lt;/span\u0026gt; T \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;CloneJson\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;T\u0026lt;/span\u0026gt;\u0026amp;gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;this\u0026lt;/span\u0026gt; T source\u0026lt;/span\u0026gt;)\u0026lt;/span\u0026gt;\n{            \n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Don\u0026apos;t serialize a null object, simply return the default for that object\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (ReferenceEquals(source, \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;null\u0026lt;/span\u0026gt;)) \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;default\u0026lt;/span\u0026gt;;\n\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// initialize inner objects individually\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// for example in default constructor some list property initialized with some values,\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// but in \u0026apos;source\u0026apos; these items are cleaned -\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// without ObjectCreationHandling.Replace default constructor values will be added to result\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; deserializeSettings = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; JsonSerializerSettings {ObjectCreationHandling = ObjectCreationHandling.Replace};\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; JsonConvert.DeserializeObject\u0026amp;lt;T\u0026amp;gt;(JsonConvert.SerializeObject(source), deserializeSettings);\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;I wanted a cloner for very simple objects of mostly primitives and lists.  If your object is out of the box JSON serializable then this method will do the trick.  This requires no modification or implementation of interfaces on the cloned class, just a JSON serializer like JSON.NET.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cs s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-csharp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;static\u0026lt;/span\u0026gt; T \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;Clone\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;T\u0026lt;/span\u0026gt;\u0026amp;gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;T source\u0026lt;/span\u0026gt;)\u0026lt;/span\u0026gt;\n{\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; serialized = JsonConvert.SerializeObject(source);\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; JsonConvert.DeserializeObject\u0026amp;lt;T\u0026amp;gt;(serialized);\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Also, you can use this extension method\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cs s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-csharp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;static\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;SystemExtension\u0026lt;/span\u0026gt;\n{\n    \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;static\u0026lt;/span\u0026gt; T \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;Clone\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;T\u0026lt;/span\u0026gt;\u0026amp;gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;this\u0026lt;/span\u0026gt; T source\u0026lt;/span\u0026gt;)\u0026lt;/span\u0026gt;\n    {\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; serialized = JsonConvert.SerializeObject(source);\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; JsonConvert.DeserializeObject\u0026amp;lt;T\u0026amp;gt;(serialized);\n    }\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;The reason not to use \u0026lt;a href=\u0026quot;http://referencesource.microsoft.com/mscorlib/system/icloneable.cs.html#fb795e239ce05299\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;ICloneable\u0026lt;/a\u0026gt; is \u0026lt;strong\u0026gt;not\u0026lt;/strong\u0026gt; because it doesn\u0026apos;t have a generic interface.  \u0026lt;a href=\u0026quot;http://blogs.msdn.com/brada/archive/2004/05/03/125427.aspx\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;The reason not to use it is because it\u0026apos;s vague\u0026lt;/a\u0026gt;.  It doesn\u0026apos;t make clear whether you\u0026apos;re getting a shallow or a deep copy; that\u0026apos;s up to the implementer.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Yes, \u0026lt;code\u0026gt;MemberwiseClone\u0026lt;/code\u0026gt; makes a shallow copy, but the opposite of \u0026lt;code\u0026gt;MemberwiseClone\u0026lt;/code\u0026gt; isn\u0026apos;t \u0026lt;code\u0026gt;Clone\u0026lt;/code\u0026gt;; it would be, perhaps, \u0026lt;code\u0026gt;DeepClone\u0026lt;/code\u0026gt;, which doesn\u0026apos;t exist.  When you use an object through its ICloneable interface, you can\u0026apos;t know which kind of cloning the underlying object performs.  (And XML comments won\u0026apos;t make it clear, because you\u0026apos;ll get the interface comments rather than the ones on the object\u0026apos;s Clone method.)\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;What I usually do is simply make a \u0026lt;code\u0026gt;Copy\u0026lt;/code\u0026gt; method that does exactly what I want.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;After much much reading about many of the options linked here, and possible solutions for this issue, I believe \u0026lt;a href=\u0026quot;https://developerscon.blogspot.com/2008/06/c-object-clone-wars.html\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;all the options are summarized pretty well at \u0026lt;em\u0026gt;Ian P\u0026lt;/em\u0026gt;\u0026apos;s link\u0026lt;/a\u0026gt; (all other options are variations of those) and the best solution is provided by \u0026lt;a href=\u0026quot;http://www.agiledeveloper.com/articles/cloning072002.htm\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;\u0026lt;em\u0026gt;Pedro77\u0026lt;/em\u0026gt;\u0026apos;s link\u0026lt;/a\u0026gt; on the question comments.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;So I\u0026apos;ll just copy relevant parts of those 2 references here. That way we can have:\u0026lt;/p\u0026gt;\n\n\u0026lt;h2\u0026gt;The best thing to do for cloning objects in C sharp!\u0026lt;/h2\u0026gt;\n\n\u0026lt;p\u0026gt;First and foremost, those are all our options:\u0026lt;/p\u0026gt;\n\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;Manually with \u0026lt;strong\u0026gt;\u0026lt;a href=\u0026quot;https://docs.microsoft.com/en-us/dotnet/api/system.icloneable\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;ICloneable\u0026lt;/a\u0026gt;\u0026lt;/strong\u0026gt;, which is \u0026lt;em\u0026gt;Shallow\u0026lt;/em\u0026gt; and not \u0026lt;em\u0026gt;Type-Safe\u0026lt;/em\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;strong\u0026gt;\u0026lt;a href=\u0026quot;https://docs.microsoft.com/en-us/dotnet/api/system.object.memberwiseclone\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;MemberwiseClone\u0026lt;/a\u0026gt;\u0026lt;/strong\u0026gt;, which uses ICloneable\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;strong\u0026gt;\u0026lt;a href=\u0026quot;https://www.codeproject.com/Articles/3441/Base-class-for-cloning-an-object-in-C\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;Reflection\u0026lt;/a\u0026gt;\u0026lt;/strong\u0026gt; by using \u0026lt;a href=\u0026quot;https://docs.microsoft.com/en-us/dotnet/api/system.activator.createinstance\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;Activator.CreateInstance\u0026lt;/a\u0026gt; and \u0026lt;a href=\u0026quot;https://github.com/Burtsev-Alexey/net-object-deep-copy/\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;recursive MemberwiseClone\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;strong\u0026gt;\u0026lt;a href=\u0026quot;https://docs.microsoft.com/en-us/dotnet/api/system.serializableattribute\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;Serialization\u0026lt;/a\u0026gt;\u0026lt;/strong\u0026gt;, as pointed by \u0026lt;a href=\u0026quot;https://stackoverflow.com/a/78612/274502\u0026quot;\u0026gt;johnc\u0026apos;s preferred answer\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;strong\u0026gt;Intermediate Language\u0026lt;/strong\u0026gt;, which I got no idea \u0026lt;a href=\u0026quot;https://whizzodev.blogspot.com/2008/03/object-cloning-using-il-in-c.html\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;how works\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;strong\u0026gt;Extension Methods\u0026lt;/strong\u0026gt;, such as this \u0026lt;a href=\u0026quot;https://circlesandcrossesblogarchive.blogspot.com/2008/01/extension-methods-for-copying-or.html\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;custom clone framework by Havard Straden\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;strong\u0026gt;\u0026lt;a href=\u0026quot;https://www.codeproject.com/Articles/1111658/Fast-Deep-Copy-of-Objects-by-Expression-Trees-Csha\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;Expression Trees\u0026lt;/a\u0026gt;\u0026lt;/strong\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\n\u0026lt;p\u0026gt;The \u0026lt;a href=\u0026quot;https://www.codeproject.com/Articles/1111658/Fast-Deep-Copy-of-Objects-by-Expression-Trees-Csha\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;article Fast Deep Copy by Expression Trees\u0026lt;/a\u0026gt;   has  also performance comparison of cloning by Serialization, Reflection and Expression Trees.\u0026lt;/p\u0026gt;\n\n\u0026lt;h1\u0026gt;Why I choose \u0026lt;em\u0026gt;ICloneable\u0026lt;/em\u0026gt; (i.e. manually)\u0026lt;/h1\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;a href=\u0026quot;http://www.agiledeveloper.com/articles/cloning072002.htm\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;Mr Venkat Subramaniam (redundant link here) explains in much detail why\u0026lt;/a\u0026gt;.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;All his article circles around an example that tries to be applicable for most cases, using 3 objects: \u0026lt;em\u0026gt;Person\u0026lt;/em\u0026gt;, \u0026lt;em\u0026gt;Brain\u0026lt;/em\u0026gt; and \u0026lt;em\u0026gt;City\u0026lt;/em\u0026gt;. We want to clone a person, which will have its own brain but the same city. You can either picture all problems any of the other methods above can bring or read the article.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;This is my slightly modified version of his conclusion:\u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;Copying an object by specifying \u0026lt;code\u0026gt;New\u0026lt;/code\u0026gt; followed by the class name often leads to code that is not extensible. Using clone, the application of prototype pattern, is a better way to achieve this. However, using clone as it is provided in C# (and Java) can be quite problematic as well. It is better to provide a protected (non-public) copy constructor and invoke that from the clone method. This gives us the ability to delegate the task of creating an object to an instance of a class itself, thus providing extensibility and also, safely creating the objects using the protected copy constructor.\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;p\u0026gt;Hopefully this implementation can make things clear:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cs s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-csharp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;Person\u0026lt;/span\u0026gt; : \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;ICloneable\u0026lt;/span\u0026gt;\n{\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;private\u0026lt;/span\u0026gt; final Brain brain; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// brain is final since I do not want \u0026lt;/span\u0026gt;\n                \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// any transplant on it once created!\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;private\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; age;\n    \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;Person\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;Brain aBrain, \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; theAge\u0026lt;/span\u0026gt;)\u0026lt;/span\u0026gt;\n    {\n        brain = aBrain; \n        age = theAge;\n    }\n    \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;protected\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;Person\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;Person another\u0026lt;/span\u0026gt;)\u0026lt;/span\u0026gt;\n    {\n        Brain refBrain = \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;null\u0026lt;/span\u0026gt;;\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;try\u0026lt;/span\u0026gt;\n        {\n            refBrain = (Brain) another.brain.clone();\n            \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// You can set the brain in the constructor\u0026lt;/span\u0026gt;\n        }\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;catch\u0026lt;/span\u0026gt;(CloneNotSupportedException e) {}\n        brain = refBrain;\n        age = another.age;\n    }\n    \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; String \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;toString\u0026lt;/span\u0026gt;()\u0026lt;/span\u0026gt;\n    {\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;This is person with \u0026quot;\u0026lt;/span\u0026gt; + brain;\n        \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Not meant to sound rude as it reads!\u0026lt;/span\u0026gt;\n    }\n    \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; Object \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;clone\u0026lt;/span\u0026gt;()\u0026lt;/span\u0026gt;\n    {\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; Person(\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;this\u0026lt;/span\u0026gt;);\n    }\n    \n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Now consider having a class derive from Person.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cs s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-csharp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;SkilledPerson\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;extends\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;Person\u0026lt;/span\u0026gt;\n{\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;private\u0026lt;/span\u0026gt; String theSkills;\n    \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;SkilledPerson\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;Brain aBrain, \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; theAge, String skills\u0026lt;/span\u0026gt;)\u0026lt;/span\u0026gt;\n    {\n        super(aBrain, theAge);\n        theSkills = skills;\n    }\n    \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;protected\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;SkilledPerson\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;SkilledPerson another\u0026lt;/span\u0026gt;)\u0026lt;/span\u0026gt;\n    {\n        super(another);\n        theSkills = another.theSkills;\n    }\n\n    \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; Object \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;clone\u0026lt;/span\u0026gt;()\u0026lt;/span\u0026gt;\n    {\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; SkilledPerson(\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;this\u0026lt;/span\u0026gt;);\n    }\n    \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; String \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;toString\u0026lt;/span\u0026gt;()\u0026lt;/span\u0026gt;\n    {\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;SkilledPerson: \u0026quot;\u0026lt;/span\u0026gt; + super.toString();\n    }\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;You may try running the following code:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cs s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-csharp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;User\u0026lt;/span\u0026gt;\n{\n    \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;static\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;play\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;Person p\u0026lt;/span\u0026gt;)\u0026lt;/span\u0026gt;\n    {\n        Person another = (Person) p.clone();\n        System.\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;out\u0026lt;/span\u0026gt;.println(p);\n        System.\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;out\u0026lt;/span\u0026gt;.println(another);\n    }\n    \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;static\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;main\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;String[] args\u0026lt;/span\u0026gt;)\u0026lt;/span\u0026gt;\n    {\n        Person sam = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; Person(\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; Brain(), \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;);\n        play(sam);\n        SkilledPerson bob = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; SkilledPerson(\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; SmarterBrain(), \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Writer\u0026quot;\u0026lt;/span\u0026gt;);\n        play(bob);\n    }\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;The output produced will be:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cs s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-csharp\u0026quot;\u0026gt;This \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;is\u0026lt;/span\u0026gt; person \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;with\u0026lt;/span\u0026gt; Brain@\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1f\u0026lt;/span\u0026gt;cc69\nThis \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;is\u0026lt;/span\u0026gt; person \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;with\u0026lt;/span\u0026gt; Brain@\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;253498\u0026lt;/span\u0026gt;\nSkilledPerson: This \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;is\u0026lt;/span\u0026gt; person \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;with\u0026lt;/span\u0026gt; SmarterBrain@\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1f\u0026lt;/span\u0026gt;ef6f\nSkilledPerson: This \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;is\u0026lt;/span\u0026gt; person \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;with\u0026lt;/span\u0026gt; SmarterBrain@\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;209f\u0026lt;/span\u0026gt;4e\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Observe that, if we keep a count of the number of objects, the clone as implemented here will keep a correct count of the number of objects.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;I prefer a copy constructor to a clone. The intent is clearer.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Simple extension method to copy all the public properties. Works for any objects and \u0026lt;strong\u0026gt;does not\u0026lt;/strong\u0026gt; require class to be \u0026lt;code\u0026gt;[Serializable]\u0026lt;/code\u0026gt;. Can be extended for other access level.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cs s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-csharp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;static\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;CopyTo\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;this\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;object\u0026lt;/span\u0026gt; S, \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;object\u0026lt;/span\u0026gt; T \u0026lt;/span\u0026gt;)\u0026lt;/span\u0026gt;\n{\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;foreach\u0026lt;/span\u0026gt;( \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; pS \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;in\u0026lt;/span\u0026gt; S.GetType().GetProperties() )\n    {\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;foreach\u0026lt;/span\u0026gt;( \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; pT \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;in\u0026lt;/span\u0026gt; T.GetType().GetProperties() )\n        {\n            \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt;( pT.Name != pS.Name ) \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;continue\u0026lt;/span\u0026gt;;\n            ( pT.GetSetMethod() ).Invoke( T, \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;object\u0026lt;/span\u0026gt;[] \n            { pS.GetGetMethod().Invoke( S, \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;null\u0026lt;/span\u0026gt; ) } );\n        }\n    };\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;I\u0026apos;ve just created \u0026lt;strong\u0026gt;\u0026lt;a href=\u0026quot;https://github.com/MarcinJuraszek/CloneExtensions\u0026quot;\u0026gt;\u0026lt;code\u0026gt;CloneExtensions\u0026lt;/code\u0026gt; library\u0026lt;/a\u0026gt;\u0026lt;/strong\u0026gt; project. It performs fast, deep clone using simple assignment operations generated by Expression Tree runtime code compilation.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;How to use it?\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Instead of writing your own \u0026lt;code\u0026gt;Clone\u0026lt;/code\u0026gt; or \u0026lt;code\u0026gt;Copy\u0026lt;/code\u0026gt; methods with a tone of assignments between fields and properties make the program do it for yourself, using Expression Tree. \u0026lt;code\u0026gt;GetClone\u0026amp;lt;T\u0026amp;gt;()\u0026lt;/code\u0026gt; method marked as extension method allows you to simply call it on your instance:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cs s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-csharp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; newInstance = source.GetClone();\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;You can choose what should be copied from \u0026lt;code\u0026gt;source\u0026lt;/code\u0026gt; to \u0026lt;code\u0026gt;newInstance\u0026lt;/code\u0026gt; using \u0026lt;code\u0026gt;CloningFlags\u0026lt;/code\u0026gt; enum:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cs s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-csharp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; newInstance \n    = source.GetClone(CloningFlags.Properties | CloningFlags.CollectionItems);\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;What can be cloned?\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;Primitive (int, uint, byte, double, char, etc.), known immutable\ntypes (DateTime, TimeSpan, String) and delegates (including\nAction, Func, etc)\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Nullable\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;T[] arrays\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Custom classes and structs, including generic classes and structs.\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\n\u0026lt;p\u0026gt;Following class/struct members are cloned internally:\u0026lt;/p\u0026gt;\n\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;Values of public, not readonly fields\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Values of public properties with both get and set accessors\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Collection items for types implementing ICollection\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;How fast it is?\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;The solution is faster then reflection, because members information has to be gathered only once, before \u0026lt;code\u0026gt;GetClone\u0026amp;lt;T\u0026amp;gt;\u0026lt;/code\u0026gt; is used for the first time for given type \u0026lt;code\u0026gt;T\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;It\u0026apos;s also faster than serialization-based solution when you clone more then couple instances of the same type \u0026lt;code\u0026gt;T\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;and more...\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Read more about generated expressions on \u0026lt;a href=\u0026quot;https://github.com/MarcinJuraszek/CloneExtensions/blob/master/EXPRESSION_TREES.md\u0026quot;\u0026gt;documentation\u0026lt;/a\u0026gt;.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Sample expression debug listing for \u0026lt;code\u0026gt;List\u0026amp;lt;int\u0026amp;gt;\u0026lt;/code\u0026gt;:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cs s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-csharp\u0026quot;\u0026gt;.Lambda \u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#Lambda1\u0026amp;lt;System.Func`4[System.Collections.Generic.List`1[System.Int32],CloneExtensions.CloningFlags,System.Collections.Generic.IDictionary`2[System.Type,System.Func`2[System.Object,System.Object]],System.Collections.Generic.List`1[System.Int32]]\u0026amp;gt;(\u0026lt;/span\u0026gt;\n    System.Collections.Generic.List`\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;[System.Int32] $source,\n    CloneExtensions.CloningFlags $flags,\n    System.Collections.Generic.IDictionary`\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;[System.Type,System.Func`\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;[System.Object,System.Object]] $initializers) {\n    .Block(System.Collections.Generic.List`\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;[System.Int32] $target) {\n        .If ($source == \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;null\u0026lt;/span\u0026gt;) {\n            .Return \u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#Label1 { null }\u0026lt;/span\u0026gt;\n        } .Else {\n            .Default(System.Void)\n        };\n        .If (\n            .Call $initializers.ContainsKey(.Constant\u0026amp;lt;System.Type\u0026amp;gt;(System.Collections.Generic.List`\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;[System.Int32]))\n        ) {\n            $target = (System.Collections.Generic.List`\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;[System.Int32]).Call ($initializers.Item[.Constant\u0026amp;lt;System.Type\u0026amp;gt;(System.Collections.Generic.List`\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;[System.Int32])]\n            ).Invoke((System.Object)$source)\n        } .Else {\n            $target = .New System.Collections.Generic.List`\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;[System.Int32]()\n        };\n        .If (\n            ((System.Byte)$flags \u0026amp;amp; (System.Byte).Constant\u0026amp;lt;CloneExtensions.CloningFlags\u0026amp;gt;(Fields)) == (System.Byte).Constant\u0026amp;lt;CloneExtensions.CloningFlags\u0026amp;gt;(Fields)\n        ) {\n            .Default(System.Void)\n        } .Else {\n            .Default(System.Void)\n        };\n        .If (\n            ((System.Byte)$flags \u0026amp;amp; (System.Byte).Constant\u0026amp;lt;CloneExtensions.CloningFlags\u0026amp;gt;(Properties)) == (System.Byte).Constant\u0026amp;lt;CloneExtensions.CloningFlags\u0026amp;gt;(Properties)\n        ) {\n            .Block() {\n                $target.Capacity = .Call CloneExtensions.CloneFactory.GetClone(\n                    $source.Capacity,\n                    $flags,\n                    $initializers)\n            }\n        } .Else {\n            .Default(System.Void)\n        };\n        .If (\n            ((System.Byte)$flags \u0026amp;amp; (System.Byte).Constant\u0026amp;lt;CloneExtensions.CloningFlags\u0026amp;gt;(CollectionItems)) == (System.Byte).Constant\u0026amp;lt;CloneExtensions.CloningFlags\u0026amp;gt;(CollectionItems)\n        ) {\n            .Block(\n                System.Collections.Generic.IEnumerator`\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;[System.Int32] $var1,\n                System.Collections.Generic.ICollection`\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;[System.Int32] $var2) {\n                $var1 = (System.Collections.Generic.IEnumerator`\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;[System.Int32]).Call $source.GetEnumerator();\n                $var2 = (System.Collections.Generic.ICollection`\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;[System.Int32])$target;\n                .Loop  {\n                    .If (.Call $var1.MoveNext() != False) {\n                        .Call $var2.Add(.Call CloneExtensions.CloneFactory.GetClone(\n                                $var1.Current,\n                                $flags,\n\n\n                         $initializers))\n                } .Else {\n                    .Break \u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#Label2 { }\u0026lt;/span\u0026gt;\n                }\n            }\n            .LabelTarget \u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#Label2:\u0026lt;/span\u0026gt;\n        }\n    } .Else {\n        .Default(System.Void)\n    };\n    .Label\n        $target\n    .LabelTarget \u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#Label1:\u0026lt;/span\u0026gt;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;}\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;what has the same meaning like following c# code:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cs s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-csharp\u0026quot;\u0026gt;(source, flags, initializers) =\u0026amp;gt;\n{\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt;(source == \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;null\u0026lt;/span\u0026gt;)\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;null\u0026lt;/span\u0026gt;;\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt;(initializers.ContainsKey(\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typeof\u0026lt;/span\u0026gt;(List\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;\u0026amp;gt;))\n        target = (List\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;\u0026amp;gt;)initializers[\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typeof\u0026lt;/span\u0026gt;(List\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;\u0026amp;gt;)].Invoke((\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;object\u0026lt;/span\u0026gt;)source);\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;else\u0026lt;/span\u0026gt;\n        target = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; List\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;\u0026amp;gt;();\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt;((flags \u0026amp;amp; CloningFlags.Properties) == CloningFlags.Properties)\n    {\n        target.Capacity = target.Capacity.GetClone(flags, initializers);\n    }\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt;((flags \u0026amp;amp; CloningFlags.CollectionItems) == CloningFlags.CollectionItems)\n    {\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; targetCollection = (ICollection\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;\u0026amp;gt;)target;\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;foreach\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; item \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;in\u0026lt;/span\u0026gt; (\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;ICollection\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026lt;/span\u0026gt;)source)\u0026lt;/span\u0026gt;\n        {\n            targetCollection.Add(item.Clone(flags, initializers));\n        }\n    }\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; target;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Isn\u0026apos;t it quite like how you\u0026apos;d write your own \u0026lt;code\u0026gt;Clone\u0026lt;/code\u0026gt; method for \u0026lt;code\u0026gt;List\u0026amp;lt;int\u0026amp;gt;\u0026lt;/code\u0026gt;?\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;If you\u0026apos;re already using a 3rd party application like \u0026lt;a href=\u0026quot;https://github.com/omuleanu/ValueInjecter\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;ValueInjecter\u0026lt;/a\u0026gt; or \u0026lt;a href=\u0026quot;https://github.com/AutoMapper/AutoMapper\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;Automapper\u0026lt;/a\u0026gt;, you can do something like this:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cs s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-csharp\u0026quot;\u0026gt;MyObject oldObj; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// The existing object to clone\u0026lt;/span\u0026gt;\n\nMyObject newObj = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; MyObject();\nnewObj.InjectFrom(oldObj); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Using ValueInjecter syntax\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Using this method you don\u0026apos;t have to implement \u0026lt;code\u0026gt;ISerializable\u0026lt;/code\u0026gt; or \u0026lt;code\u0026gt;ICloneable\u0026lt;/code\u0026gt; on your objects. This is common with the MVC/MVVM pattern, so simple tools like this have been created.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;see \u0026lt;a href=\u0026quot;https://github.com/omuleanu/ValueInjecter/blob/dae7956439cac8516979fe254a520a1942c5cdeb/Tests/Cloning.cs\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;the ValueInjecter deep cloning sample on GitHub\u0026lt;/a\u0026gt;.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Well I was having problems using ICloneable in Silverlight, but I liked the idea of seralization, I can seralize XML, so I did this:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-cs s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-csharp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;static\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;SerializeHelper\u0026lt;/span\u0026gt;\n{\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//Michael White, Holly Springs Consulting, 2009\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//michael@hollyspringsconsulting.com\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;static\u0026lt;/span\u0026gt; T \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;DeserializeXML\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;T\u0026lt;/span\u0026gt;\u0026amp;gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;string\u0026lt;/span\u0026gt; xmlData\u0026lt;/span\u0026gt;) \n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;where\u0026lt;/span\u0026gt; T:\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt;()\u0026lt;/span\u0026gt;\n    {\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;string\u0026lt;/span\u0026gt;.IsNullOrEmpty(xmlData))\n            \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;default\u0026lt;/span\u0026gt;(T);\n\n        TextReader tr = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; StringReader(xmlData);\n        T DocItms = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; T();\n        XmlSerializer xms = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; XmlSerializer(DocItms.GetType());\n        DocItms = (T)xms.Deserialize(tr);\n\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; DocItms == \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;null\u0026lt;/span\u0026gt; ? \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;default\u0026lt;/span\u0026gt;(T) : DocItms;\n    }\n\n    \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;static\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;string\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;SeralizeObjectToXML\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;T\u0026lt;/span\u0026gt;\u0026amp;gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;T xmlObject\u0026lt;/span\u0026gt;)\u0026lt;/span\u0026gt;\n    {\n        StringBuilder sbTR = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; StringBuilder();\n        XmlSerializer xmsTR = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; XmlSerializer(xmlObject.GetType());\n        XmlWriterSettings xwsTR = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; XmlWriterSettings();\n        \n        XmlWriter xmwTR = XmlWriter.Create(sbTR, xwsTR);\n        xmsTR.Serialize(xmwTR,xmlObject);\n        \n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; sbTR.ToString();\n    }\n\n    \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;static\u0026lt;/span\u0026gt; T \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;CloneObject\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;T\u0026lt;/span\u0026gt;\u0026amp;gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;T objClone\u0026lt;/span\u0026gt;) \n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;where\u0026lt;/span\u0026gt; T:\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt;()\u0026lt;/span\u0026gt;\n    {\n        \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;string\u0026lt;/span\u0026gt; GetString = SerializeHelper.SeralizeObjectToXML\u0026amp;lt;T\u0026amp;gt;(objClone);\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; SerializeHelper.DeserializeXML\u0026amp;lt;T\u0026amp;gt;(GetString);\n    }\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;The best is to implement an \u0026lt;strong\u0026gt;extension method\u0026lt;/strong\u0026gt; like\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cs s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-csharp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;static\u0026lt;/span\u0026gt; T \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;DeepClone\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;T\u0026lt;/span\u0026gt;\u0026amp;gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;this\u0026lt;/span\u0026gt; T originalObject\u0026lt;/span\u0026gt;)\u0026lt;/span\u0026gt;\n{ \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;/* the cloning code */\u0026lt;/span\u0026gt; }\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;and then use it anywhere in the solution by\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cs s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-csharp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; copy = anyObject.DeepClone();\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;We can have the following three implementations:\u0026lt;/p\u0026gt;\n\n\u0026lt;ol\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;a href=\u0026quot;https://stackoverflow.com/a/129395/2094687\u0026quot;\u0026gt;\u0026lt;strong\u0026gt;By Serialization\u0026lt;/strong\u0026gt;\u0026lt;/a\u0026gt; (the shortest code)\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;a href=\u0026quot;https://github.com/Burtsev-Alexey/net-object-deep-copy/\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;\u0026lt;strong\u0026gt;By Reflection\u0026lt;/strong\u0026gt;\u0026lt;/a\u0026gt; - \u0026lt;strong\u0026gt;5x faster\u0026lt;/strong\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;a href=\u0026quot;http://www.codeproject.com/Articles/1111658/Fast-Deep-Copy-by-Expression-Trees-C-Sharp\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;\u0026lt;strong\u0026gt;By Expression Trees\u0026lt;/strong\u0026gt;\u0026lt;/a\u0026gt; - \u0026lt;strong\u0026gt;20x faster\u0026lt;/strong\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;/ol\u0026gt;\n\n\u0026lt;p\u0026gt;All linked methods are well working and were deeply tested.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;The short answer is you inherit from the ICloneable interface and then implement the .clone function. Clone should do a memberwise copy and perform a deep copy on any member that requires it, then return the resulting object. This is a recursive operation ( it requires that all members of the class you want to clone are either value types or implement ICloneable and that their members are either value types or implement ICloneable, and so on).\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;For a more detailed explanation on Cloning using ICloneable, check out \u0026lt;a href=\u0026quot;https://web.archive.org/web/20120113123300/http://www.ondotnet.com/pub/a/dotnet/2002/11/25/copying.html\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;this article\u0026lt;/a\u0026gt;.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;The \u0026lt;em\u0026gt;long\u0026lt;/em\u0026gt; answer is \u0026quot;it depends\u0026quot;. As mentioned by others, ICloneable is not supported by generics, requires special considerations for circular class references, and is actually viewed by some as a \u0026lt;a href=\u0026quot;http://blogs.msdn.com/brada/archive/2004/05/03/125427.aspx\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;\u0026quot;mistake\u0026quot;\u0026lt;/a\u0026gt; in the .NET Framework. The serialization method depends on your objects being serializable, which they may not be and you may have no control over. There is still much debate in the community over which is the \u0026quot;best\u0026quot; practice. In reality, none of the solutions are the one-size fits all best practice for all situations like ICloneable was originally interpreted to be.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;See the this \u0026lt;a href=\u0026quot;http://developerscon.blogspot.com/2008/06/c-object-clone-wars.html\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;Developer\u0026apos;s Corner article\u0026lt;/a\u0026gt; for a few more options (credit to Ian).\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;ol\u0026gt;\n\u0026lt;li\u0026gt;Basically you need to implement ICloneable interface and then realize object structure copying. \u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;If it\u0026apos;s deep copy of all members, you need to insure (not relating on solution you choose) that all children are clonable as well. \u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Sometimes you need to be aware of some restriction during this process, for example if you copying the ORM objects most of frameworks allow only one object attached to the session and you MUST NOT make clones of this object, or if it\u0026apos;s possible you need to care about session attaching of these objects.\u0026lt;/li\u0026gt;\n\u0026lt;/ol\u0026gt;\n\n\u0026lt;p\u0026gt;Cheers.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;h2\u0026gt;DeepCloner: Quick, easy, effective NuGet package to solve cloning\u0026lt;/h2\u0026gt;\n\n\u0026lt;p\u0026gt;After reading all answers I was surprised no one mentioned this excellent package: \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;a href=\u0026quot;https://github.com/force-net/DeepCloner\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;DeepCloner GitHub project\u0026lt;/a\u0026gt;  \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;a href=\u0026quot;https://www.nuget.org/packages/DeepCloner\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;DeepCloner NuGet package\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Elaborating a bit on its README, here are the reason why we chose it at work:\u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;ul\u0026gt;\n  \u0026lt;li\u0026gt;It can deep or shallow copy \u0026lt;/li\u0026gt;\n  \u0026lt;li\u0026gt;In deep cloning all object graph is maintained. \u0026lt;/li\u0026gt;\n  \u0026lt;li\u0026gt;Uses code-generation in runtime, as result cloning is blazingly fast\u0026lt;/li\u0026gt;\n  \u0026lt;li\u0026gt;Objects copied by internal structure, no methods or ctors called\u0026lt;/li\u0026gt;\n  \u0026lt;li\u0026gt;You don\u0026apos;t need to mark classes somehow (like Serializable-attribute, or implement interfaces)\u0026lt;/li\u0026gt;\n  \u0026lt;li\u0026gt;No requirement to specify object type for cloning. Object can be casted to interface or as an abstract object (e.g. you can clone array of ints as abstract Array or IEnumerable; even null can be cloned without any errors)\u0026lt;/li\u0026gt;\n  \u0026lt;li\u0026gt;Cloned object doesn\u0026apos;t have any ability to determine that he is clone (except with very specific methods)\u0026lt;/li\u0026gt;\n  \u0026lt;/ul\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;h3\u0026gt;Usage:\u0026lt;/h3\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cs s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-csharp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; deepClone = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; { Id = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;, Name = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;222\u0026quot;\u0026lt;/span\u0026gt; }.DeepClone();\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; shallowClone = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; { Id = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;, Name = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;222\u0026quot;\u0026lt;/span\u0026gt; }.ShallowClone();\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;h3\u0026gt;Performance:\u0026lt;/h3\u0026gt;\n\n\u0026lt;p\u0026gt;The README contains a performance comparison of various cloning libraries and methods: \u0026lt;a href=\u0026quot;https://github.com/force-net/DeepCloner#performance\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;DeepCloner Performance\u0026lt;/a\u0026gt;.\u0026lt;/p\u0026gt;\n\n\u0026lt;h3\u0026gt;Requirements:\u0026lt;/h3\u0026gt;\n\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;em\u0026gt;.NET 4.0 or higher or .NET Standard 1.3 (.NET Core)\u0026lt;/em\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;em\u0026gt;Requires Full Trust permission set or Reflection permission (MemberAccess)\u0026lt;/em\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n    ","\n\u0026lt;p\u0026gt;EDIT: project is discontinued\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;If you want true cloning to unknown types you can take a look at\n\u0026lt;a href=\u0026quot;http://fastclone.codeplex.com/\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;fastclone\u0026lt;/a\u0026gt;.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;That\u0026apos;s expression based cloning working about 10 times faster than binary serialization and maintaining complete object graph integrity.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;That means: if you refer multiple times to the same object in your hierachy, the clone will also have a single instance beeing referenced.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;There is no need for interfaces, attributes or any other modification to the objects being cloned.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Keep things simple and use \u0026lt;a href=\u0026quot;http://automapper.org/\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;AutoMapper\u0026lt;/a\u0026gt; as others mentioned, it\u0026apos;s a simple little library to map one object to another... To copy an object to another with the same type, all you need is three lines of code:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cs s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-csharp\u0026quot;\u0026gt;MyType source = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; MyType();\nMapper.CreateMap\u0026amp;lt;MyType, MyType\u0026amp;gt;();\nMyType target = Mapper.Map\u0026amp;lt;MyType, MyType\u0026amp;gt;(source);\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;The target object is now a copy of the source object.\nNot simple enough? Create an extension method to use everywhere in your solution:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cs s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-csharp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;static\u0026lt;/span\u0026gt; T \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;Copy\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;T\u0026lt;/span\u0026gt;\u0026amp;gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;this\u0026lt;/span\u0026gt; T source\u0026lt;/span\u0026gt;)\u0026lt;/span\u0026gt;\n{\n    T copy = \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;default\u0026lt;/span\u0026gt;(T);\n    Mapper.CreateMap\u0026amp;lt;T, T\u0026amp;gt;();\n    copy = Mapper.Map\u0026amp;lt;T, T\u0026amp;gt;(source);\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; copy;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;The extension method can be used as follow:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cs s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-csharp\u0026quot;\u0026gt;MyType copy = source.Copy();\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;In general, you implement the ICloneable interface and implement Clone yourself.\nC# objects have a built-in MemberwiseClone method that performs a shallow copy that can help you out for all the primitives.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;For a deep copy, there is no way it can know how to automatically do it.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;I came up with this to overcome a \u0026lt;a href=\u0026quot;http://en.wikipedia.org/wiki/.NET_Framework\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;.NET\u0026lt;/a\u0026gt; shortcoming having to manually deep copy List\u0026amp;lt;T\u0026amp;gt;.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;I use this:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cs s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-csharp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;static\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; IEnumerable\u0026amp;lt;SpotPlacement\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;CloneList\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;List\u0026amp;lt;SpotPlacement\u0026amp;gt; spotPlacements\u0026lt;/span\u0026gt;)\u0026lt;/span\u0026gt;\n{\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;foreach\u0026lt;/span\u0026gt; (SpotPlacement sp \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;in\u0026lt;/span\u0026gt; spotPlacements)\n    {\n        \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;yield\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; (\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;SpotPlacement\u0026lt;/span\u0026gt;)sp.\u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;Clone\u0026lt;/span\u0026gt;()\u0026lt;/span\u0026gt;;\n    }\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;And at another place:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cs s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-csharp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;object\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;Clone\u0026lt;/span\u0026gt;()\u0026lt;/span\u0026gt;\n{\n    OrderItem newOrderItem = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; OrderItem();\n    ...\n    newOrderItem._exactPlacements.AddRange(SpotPlacement.CloneList(_exactPlacements));\n    ...\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; newOrderItem;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;I tried to come up with oneliner that does this, but it\u0026apos;s not possible, due to yield not working inside anonymous method blocks.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Better still, use generic List\u0026amp;lt;T\u0026amp;gt; cloner:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cs s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-csharp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;Utility\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;T\u0026lt;/span\u0026gt;\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;where\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;T\u0026lt;/span\u0026gt; : \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;ICloneable\u0026lt;/span\u0026gt;\n{\n    \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;static\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; IEnumerable\u0026amp;lt;T\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;CloneList\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;List\u0026amp;lt;T\u0026amp;gt; tl\u0026lt;/span\u0026gt;)\u0026lt;/span\u0026gt;\n    {\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;foreach\u0026lt;/span\u0026gt; (T t \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;in\u0026lt;/span\u0026gt; tl)\n        {\n            \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;yield\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; (\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;T\u0026lt;/span\u0026gt;)t.\u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;Clone\u0026lt;/span\u0026gt;()\u0026lt;/span\u0026gt;;\n        }\n    }\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;h3\u0026gt;Q. Why would I choose this answer?\u0026lt;/h3\u0026gt;\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;Choose this answer if you want the fastest speed .NET is capable of.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Ignore this answer if you want a really, really easy method of cloning.\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;p\u0026gt;In other words, \u0026lt;a href=\u0026quot;http://c2.com/cgi/wiki?PrematureOptimization\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;go with another answer unless you have a performance bottleneck that needs fixing, and you can prove it with a profiler\u0026lt;/a\u0026gt;.\u0026lt;/p\u0026gt;\n\u0026lt;h3\u0026gt;10x faster than other methods\u0026lt;/h3\u0026gt;\n\u0026lt;p\u0026gt;The following method of performing a deep clone is:\u0026lt;/p\u0026gt;\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;10x faster than anything that involves serialization/deserialization;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Pretty darn close to the theoretical maximum speed .NET is capable of.\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;h3\u0026gt;And the method ...\u0026lt;/h3\u0026gt;\n\u0026lt;p\u0026gt;For ultimate speed, you can use \u0026lt;strong\u0026gt;Nested MemberwiseClone to do a deep copy\u0026lt;/strong\u0026gt;. Its almost the same speed as copying a value struct, and is much faster than (a) reflection or (b) serialization (as described in other answers on this page).\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Note that \u0026lt;strong\u0026gt;if\u0026lt;/strong\u0026gt; you use \u0026lt;strong\u0026gt;Nested MemberwiseClone for a deep copy\u0026lt;/strong\u0026gt;, you have to manually implement a ShallowCopy for each nested level in the class, and a DeepCopy which calls all said ShallowCopy methods to create a complete clone. This is simple: only a few lines in total, see the demo code below.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Here is the output of the code showing the relative performance difference for 100,000 clones:\u0026lt;/p\u0026gt;\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;1.08 seconds for Nested MemberwiseClone on nested structs\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;4.77 seconds for Nested MemberwiseClone on nested classes\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;39.93 seconds for Serialization/Deserialization\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;p\u0026gt;Using Nested MemberwiseClone on a class almost as fast as copying a struct, and copying a struct is pretty darn close to the theoretical maximum speed .NET is capable of.\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-cs s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-csharp\u0026quot;\u0026gt;Demo \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt; of shallow \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;and\u0026lt;/span\u0026gt; deep copy, \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;using\u0026lt;/span\u0026gt; classes \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;and\u0026lt;/span\u0026gt; MemberwiseClone:\n  Create Bob\n    Bob.Age=\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;30\u0026lt;/span\u0026gt;, Bob.Purchase.Description=Lamborghini\n  Clone Bob \u0026amp;gt;\u0026amp;gt; BobsSon\n  Adjust BobsSon details\n    BobsSon.Age=\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;, BobsSon.Purchase.Description=Toy car\n  Proof of deep copy: If BobsSon \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;is\u0026lt;/span\u0026gt; a \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;true\u0026lt;/span\u0026gt; clone, then adjusting BobsSon details will \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;not\u0026lt;/span\u0026gt; affect Bob:\n    Bob.Age=\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;30\u0026lt;/span\u0026gt;, Bob.Purchase.Description=Lamborghini\n  Elapsed time: \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;00\u0026lt;/span\u0026gt;:\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;00\u0026lt;/span\u0026gt;:\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;04.7795670\u0026lt;/span\u0026gt;,\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;30000000\u0026lt;/span\u0026gt;\n\nDemo \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt; of shallow \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;and\u0026lt;/span\u0026gt; deep copy, \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;using\u0026lt;/span\u0026gt; structs \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;and\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;value\u0026lt;/span\u0026gt; copying:\n  Create Bob\n    Bob.Age=\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;30\u0026lt;/span\u0026gt;, Bob.Purchase.Description=Lamborghini\n  Clone Bob \u0026amp;gt;\u0026amp;gt; BobsSon\n  Adjust BobsSon details:\n    BobsSon.Age=\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;, BobsSon.Purchase.Description=Toy car\n  Proof of deep copy: If BobsSon \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;is\u0026lt;/span\u0026gt; a \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;true\u0026lt;/span\u0026gt; clone, then adjusting BobsSon details will \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;not\u0026lt;/span\u0026gt; affect Bob:\n    Bob.Age=\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;30\u0026lt;/span\u0026gt;, Bob.Purchase.Description=Lamborghini\n  Elapsed time: \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;00\u0026lt;/span\u0026gt;:\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;00\u0026lt;/span\u0026gt;:\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;01.0875454\u0026lt;/span\u0026gt;,\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;30000000\u0026lt;/span\u0026gt;\n\nDemo \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3\u0026lt;/span\u0026gt; of deep copy, \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;using\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;and\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;serialize\u0026lt;/span\u0026gt;/\u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;deserialize\u0026lt;/span\u0026gt;:\n  \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;Elapsed\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;time\u0026lt;/span\u0026gt;: 00:00:39.9339425,30000000\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;To understand how to do a deep copy using MemberwiseCopy, here is the demo project that was used to generate the times above:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-cs s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-csharp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Nested MemberwiseClone example. \u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Added to demo how to deep copy a reference class.\u0026lt;/span\u0026gt;\n[\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;Serializable\u0026lt;/span\u0026gt;] \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Not required if using MemberwiseClone, only used for speed comparison using serialization.\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;Person\u0026lt;/span\u0026gt;\n{\n    \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;Person\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; age, \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;string\u0026lt;/span\u0026gt; description\u0026lt;/span\u0026gt;)\u0026lt;/span\u0026gt;\n    {\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;this\u0026lt;/span\u0026gt;.Age = age;\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;this\u0026lt;/span\u0026gt;.Purchase.Description = description;\n    }\n    [\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;Serializable\u0026lt;/span\u0026gt;] \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Not required if using MemberwiseClone\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;PurchaseType\u0026lt;/span\u0026gt;\n    {\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;string\u0026lt;/span\u0026gt; Description;\n        \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; PurchaseType \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;ShallowCopy\u0026lt;/span\u0026gt;()\u0026lt;/span\u0026gt;\n        {\n            \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; (PurchaseType)\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;this\u0026lt;/span\u0026gt;.MemberwiseClone();\n        }\n    }\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; PurchaseType Purchase = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; PurchaseType();\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; Age;\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Add this if using nested MemberwiseClone.\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// This is a class, which is a reference type, so cloning is more difficult.\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; Person \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;ShallowCopy\u0026lt;/span\u0026gt;()\u0026lt;/span\u0026gt;\n    {\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; (Person)\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;this\u0026lt;/span\u0026gt;.MemberwiseClone();\n    }\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Add this if using nested MemberwiseClone.\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// This is a class, which is a reference type, so cloning is more difficult.\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; Person \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;DeepCopy\u0026lt;/span\u0026gt;()\u0026lt;/span\u0026gt;\n    {\n            \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Clone the root ...\u0026lt;/span\u0026gt;\n        Person other = (Person) \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;this\u0026lt;/span\u0026gt;.MemberwiseClone();\n            \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// ... then clone the nested class.\u0026lt;/span\u0026gt;\n        other.Purchase = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;this\u0026lt;/span\u0026gt;.Purchase.ShallowCopy();\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; other;\n    }\n}\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Added to demo how to copy a value struct (this is easy - a deep copy happens by default)\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; PersonStruct\n{\n    \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;PersonStruct\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; age, \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;string\u0026lt;/span\u0026gt; description\u0026lt;/span\u0026gt;)\u0026lt;/span\u0026gt;\n    {\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;this\u0026lt;/span\u0026gt;.Age = age;\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;this\u0026lt;/span\u0026gt;.Purchase.Description = description;\n    }\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; PurchaseType\n    {\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;string\u0026lt;/span\u0026gt; Description;\n    }\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; PurchaseType Purchase;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; Age;\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// This is a struct, which is a value type, so everything is a clone by default.\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; PersonStruct \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;ShallowCopy\u0026lt;/span\u0026gt;()\u0026lt;/span\u0026gt;\n    {\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; (PersonStruct)\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;this\u0026lt;/span\u0026gt;;\n    }\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// This is a struct, which is a value type, so everything is a clone by default.\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; PersonStruct \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;DeepCopy\u0026lt;/span\u0026gt;()\u0026lt;/span\u0026gt;\n    {\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; (PersonStruct)\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;this\u0026lt;/span\u0026gt;;\n    }\n}\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Added only for a speed comparison.\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;MyDeepCopy\u0026lt;/span\u0026gt;\n{\n    \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;static\u0026lt;/span\u0026gt; T \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;DeepCopy\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;T\u0026lt;/span\u0026gt;\u0026amp;gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;T obj\u0026lt;/span\u0026gt;)\u0026lt;/span\u0026gt;\n    {\n        \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;object\u0026lt;/span\u0026gt; result = \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;null\u0026lt;/span\u0026gt;;\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;using\u0026lt;/span\u0026gt; (\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; ms = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; MemoryStream())\n        {\n            \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; formatter = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; BinaryFormatter();\n            formatter.Serialize(ms, obj);\n            ms.Position = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;;\n            result = (T)formatter.Deserialize(ms);\n            ms.Close();\n        }\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; (T)result;\n    }\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;Then, call the demo from main:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-cs s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-csharp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;MyMain\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;string\u0026lt;/span\u0026gt;[] args\u0026lt;/span\u0026gt;)\u0026lt;/span\u0026gt;\n{\n    {\n        Console.Write(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Demo 1 of shallow and deep copy, using classes and MemberwiseCopy:\\n\u0026quot;\u0026lt;/span\u0026gt;);\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; Bob = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; Person(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;30\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Lamborghini\u0026quot;\u0026lt;/span\u0026gt;);\n        Console.Write(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;  Create Bob\\n\u0026quot;\u0026lt;/span\u0026gt;);\n        Console.Write(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;    Bob.Age={0}, Bob.Purchase.Description={1}\\n\u0026quot;\u0026lt;/span\u0026gt;, Bob.Age, Bob.Purchase.Description);\n        Console.Write(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;  Clone Bob \u0026amp;gt;\u0026amp;gt; BobsSon\\n\u0026quot;\u0026lt;/span\u0026gt;);\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; BobsSon = Bob.DeepCopy();\n        Console.Write(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;  Adjust BobsSon details\\n\u0026quot;\u0026lt;/span\u0026gt;);\n        BobsSon.Age = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;;\n        BobsSon.Purchase.Description = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Toy car\u0026quot;\u0026lt;/span\u0026gt;;\n        Console.Write(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;    BobsSon.Age={0}, BobsSon.Purchase.Description={1}\\n\u0026quot;\u0026lt;/span\u0026gt;, BobsSon.Age, BobsSon.Purchase.Description);\n        Console.Write(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;  Proof of deep copy: If BobsSon is a true clone, then adjusting BobsSon details will not affect Bob:\\n\u0026quot;\u0026lt;/span\u0026gt;);\n        Console.Write(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;    Bob.Age={0}, Bob.Purchase.Description={1}\\n\u0026quot;\u0026lt;/span\u0026gt;, Bob.Age, Bob.Purchase.Description);\n        Debug.Assert(Bob.Age == \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;30\u0026lt;/span\u0026gt;);\n        Debug.Assert(Bob.Purchase.Description == \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Lamborghini\u0026quot;\u0026lt;/span\u0026gt;);\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; sw = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; Stopwatch();\n        sw.Start();\n        \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; total = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;;\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt; (\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; i = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;; i \u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;100000\u0026lt;/span\u0026gt;; i++)\n        {\n            \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; n = Bob.DeepCopy();\n            total += n.Age;\n        }\n        Console.Write(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;  Elapsed time: {0},{1}\\n\\n\u0026quot;\u0026lt;/span\u0026gt;, sw.Elapsed, total);\n    }\n    {               \n        Console.Write(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Demo 2 of shallow and deep copy, using structs:\\n\u0026quot;\u0026lt;/span\u0026gt;);\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; Bob = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; PersonStruct(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;30\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Lamborghini\u0026quot;\u0026lt;/span\u0026gt;);\n        Console.Write(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;  Create Bob\\n\u0026quot;\u0026lt;/span\u0026gt;);\n        Console.Write(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;    Bob.Age={0}, Bob.Purchase.Description={1}\\n\u0026quot;\u0026lt;/span\u0026gt;, Bob.Age, Bob.Purchase.Description);\n        Console.Write(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;  Clone Bob \u0026amp;gt;\u0026amp;gt; BobsSon\\n\u0026quot;\u0026lt;/span\u0026gt;);\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; BobsSon = Bob.DeepCopy();\n        Console.Write(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;  Adjust BobsSon details:\\n\u0026quot;\u0026lt;/span\u0026gt;);\n        BobsSon.Age = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;;\n        BobsSon.Purchase.Description = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Toy car\u0026quot;\u0026lt;/span\u0026gt;;\n        Console.Write(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;    BobsSon.Age={0}, BobsSon.Purchase.Description={1}\\n\u0026quot;\u0026lt;/span\u0026gt;, BobsSon.Age, BobsSon.Purchase.Description);\n        Console.Write(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;  Proof of deep copy: If BobsSon is a true clone, then adjusting BobsSon details will not affect Bob:\\n\u0026quot;\u0026lt;/span\u0026gt;);\n        Console.Write(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;    Bob.Age={0}, Bob.Purchase.Description={1}\\n\u0026quot;\u0026lt;/span\u0026gt;, Bob.Age, Bob.Purchase.Description);                \n        Debug.Assert(Bob.Age == \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;30\u0026lt;/span\u0026gt;);\n        Debug.Assert(Bob.Purchase.Description == \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Lamborghini\u0026quot;\u0026lt;/span\u0026gt;);\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; sw = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; Stopwatch();\n        sw.Start();\n        \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; total = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;;\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt; (\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; i = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;; i \u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;100000\u0026lt;/span\u0026gt;; i++)\n        {\n            \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; n = Bob.DeepCopy();\n            total += n.Age;\n        }\n        Console.Write(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;  Elapsed time: {0},{1}\\n\\n\u0026quot;\u0026lt;/span\u0026gt;, sw.Elapsed, total);\n    }\n    {\n        Console.Write(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Demo 3 of deep copy, using class and serialize/deserialize:\\n\u0026quot;\u0026lt;/span\u0026gt;);\n        \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; total = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;;\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; sw = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; Stopwatch();\n        sw.Start();\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; Bob = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; Person(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;30\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Lamborghini\u0026quot;\u0026lt;/span\u0026gt;);\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt; (\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; i = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;; i \u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;100000\u0026lt;/span\u0026gt;; i++)\n        {\n            \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; BobsSon = MyDeepCopy.DeepCopy\u0026amp;lt;Person\u0026amp;gt;(Bob);\n            total += BobsSon.Age;\n        }\n        Console.Write(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;  Elapsed time: {0},{1}\\n\u0026quot;\u0026lt;/span\u0026gt;, sw.Elapsed, total);\n    }\n    Console.ReadKey();\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;Again, note that \u0026lt;strong\u0026gt;if\u0026lt;/strong\u0026gt; you use \u0026lt;strong\u0026gt;Nested MemberwiseClone for a deep copy\u0026lt;/strong\u0026gt;, you have to manually implement a ShallowCopy for each nested level in the class, and a DeepCopy which calls all said ShallowCopy methods to create a complete clone. This is simple: only a few lines in total, see the demo code above.\u0026lt;/p\u0026gt;\n\u0026lt;h3\u0026gt;Value types vs. References Types\u0026lt;/h3\u0026gt;\n\u0026lt;p\u0026gt;Note that when it comes to cloning an object, there is is a big difference between a \u0026quot;\u0026lt;strong\u0026gt;struct\u0026lt;/strong\u0026gt;\u0026quot; and a \u0026quot;\u0026lt;strong\u0026gt;class\u0026lt;/strong\u0026gt;\u0026quot;:\u0026lt;/p\u0026gt;\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;If you have a \u0026quot;\u0026lt;strong\u0026gt;struct\u0026lt;/strong\u0026gt;\u0026quot;, it\u0026apos;s a \u0026lt;strong\u0026gt;value type\u0026lt;/strong\u0026gt; so you can just copy it, and the contents will be cloned (but it will only make a shallow clone unless you use the techniques in this post).\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;If you have a \u0026quot;\u0026lt;strong\u0026gt;class\u0026lt;/strong\u0026gt;\u0026quot;, it\u0026apos;s a \u0026lt;strong\u0026gt;reference type\u0026lt;/strong\u0026gt;, so if you copy it, all you are doing is copying the pointer to it. To create a true clone, you have to be more creative, and use \u0026lt;a href=\u0026quot;https://msdn.microsoft.com/en-us/library/system.object.memberwiseclone(v=vs.110).aspx\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;differences between value types and references types\u0026lt;/a\u0026gt; which creates another copy of the original object in memory.\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;p\u0026gt;See \u0026lt;a href=\u0026quot;https://msdn.microsoft.com/en-us/library/system.object.memberwiseclone(v=vs.110).aspx\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;differences between value types and references types\u0026lt;/a\u0026gt;.\u0026lt;/p\u0026gt;\n\u0026lt;h3\u0026gt;Checksums to aid in debugging\u0026lt;/h3\u0026gt;\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;Cloning objects incorrectly can lead to very difficult-to-pin-down bugs. In production code, I tend to implement a checksum to double check that the object has been cloned properly, and hasn\u0026apos;t been corrupted by another reference to it. This checksum can be switched off in Release mode.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;I find this method quite useful: often, you only want to clone parts of the object, not the entire thing.\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;h3\u0026gt;Really useful for decoupling many threads from many other threads\u0026lt;/h3\u0026gt;\n\u0026lt;p\u0026gt;One excellent use case for this code is feeding clones of a nested class or struct into a queue, to implement the producer / consumer pattern.\u0026lt;/p\u0026gt;\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;We can have one  (or more) threads modifying a class that they own, then pushing a complete copy of this class into a \u0026lt;code\u0026gt;ConcurrentQueue\u0026lt;/code\u0026gt;.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;We then have one (or more) threads pulling copies of these classes out and dealing with them.\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;p\u0026gt;This works extremely well in practice, and allows us to decouple many threads (the producers) from one or more threads (the consumers).\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;And this method is blindingly fast too: if we use nested structs, it\u0026apos;s 35x faster than serializing/deserializing nested classes, and allows us to take advantage of all of the threads available on the machine.\u0026lt;/p\u0026gt;\n\u0026lt;h1\u0026gt;Update\u0026lt;/h1\u0026gt;\n\u0026lt;p\u0026gt;Apparently, ExpressMapper is as fast, if not faster, than hand coding such as above. I might have to see how they compare with a profiler.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;\u0026lt;em\u0026gt;Disclaimer: I\u0026apos;m the author of the mentioned package.\u0026lt;/em\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;I was surprised how the top answers to this question in 2019 still use serialization or reflection. \u0026lt;/p\u0026gt;\n\n\u0026lt;h2\u0026gt;Serialization is limiting (requires attributes, specific constructors, etc.) and is very slow\u0026lt;/h2\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;code\u0026gt;BinaryFormatter\u0026lt;/code\u0026gt; requires the \u0026lt;code\u0026gt;Serializable\u0026lt;/code\u0026gt; attribute, \u0026lt;code\u0026gt;JsonConverter\u0026lt;/code\u0026gt; requires a parameterless constructor or attributes, neither handle read only fields or interfaces very well and both are 10-30x slower than necessary.\u0026lt;/p\u0026gt;\n\n\u0026lt;h2\u0026gt;Expression Trees\u0026lt;/h2\u0026gt;\n\n\u0026lt;p\u0026gt;You can instead use \u0026lt;em\u0026gt;Expression Trees\u0026lt;/em\u0026gt; or \u0026lt;em\u0026gt;Reflection.Emit\u0026lt;/em\u0026gt; to generate cloning code only once, then use that compiled code instead of slow reflection or serialization.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Having come across the problem myself and seeing no satisfactory solution, I decided to create a package that does just that and \u0026lt;strong\u0026gt;works with every type and is a almost as fast as custom written code\u0026lt;/strong\u0026gt;.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;You can find the project on GitHub: \u0026lt;a href=\u0026quot;https://github.com/marcelltoth/ObjectCloner\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;https://github.com/marcelltoth/ObjectCloner\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;h2\u0026gt;Usage\u0026lt;/h2\u0026gt;\n\n\u0026lt;p\u0026gt;You can install it from NuGet. Either get the \u0026lt;code\u0026gt;ObjectCloner\u0026lt;/code\u0026gt; package and use it as:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cs s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-csharp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; clone = ObjectCloner.DeepClone(original);\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;or if you don\u0026apos;t mind polluting your object type with extensions get \u0026lt;code\u0026gt;ObjectCloner.Extensions\u0026lt;/code\u0026gt; as well and write:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cs s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-csharp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; clone = original.DeepClone();\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;h2\u0026gt;Performance\u0026lt;/h2\u0026gt;\n\n\u0026lt;p\u0026gt;A simple benchmark of cloning a class hierarchy showed performance ~3x faster than using Reflection, ~12x faster than Newtonsoft.Json serialization and ~36x faster than the highly suggested \u0026lt;code\u0026gt;BinaryFormatter\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;I\u0026apos;ve seen it implemented through reflection as well. Basically there was a method that would iterate through the members of an object and appropriately copy them to the new object. When it reached reference types or collections I think it did a recursive call on itself. Reflection is expensive, but it worked pretty well.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Here is a deep copy implementation:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cs s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-csharp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;static\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;object\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;CloneObject\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;object\u0026lt;/span\u0026gt; opSource\u0026lt;/span\u0026gt;)\u0026lt;/span\u0026gt;\n{\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//grab the type and create a new instance of that type\u0026lt;/span\u0026gt;\n    Type opSourceType = opSource.GetType();\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;object\u0026lt;/span\u0026gt; opTarget = CreateInstanceOfType(opSourceType);\n\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//grab the properties\u0026lt;/span\u0026gt;\n    PropertyInfo[] opPropertyInfo = opSourceType.GetProperties(BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance);\n\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//iterate over the properties and if it has a \u0026apos;set\u0026apos; method assign it from the source TO the target\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;foreach\u0026lt;/span\u0026gt; (PropertyInfo item \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;in\u0026lt;/span\u0026gt; opPropertyInfo)\n    {\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (item.CanWrite)\n        {\n            \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//value types can simply be \u0026apos;set\u0026apos;\u0026lt;/span\u0026gt;\n            \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (item.PropertyType.IsValueType || item.PropertyType.IsEnum || item.PropertyType.Equals(\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typeof\u0026lt;/span\u0026gt;(System.String)))\n            {\n                item.SetValue(opTarget, item.GetValue(opSource, \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;null\u0026lt;/span\u0026gt;), \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;null\u0026lt;/span\u0026gt;);\n            }\n            \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//object/complex types need to recursively call this method until the end of the tree is reached\u0026lt;/span\u0026gt;\n            \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;else\u0026lt;/span\u0026gt;\n            {\n                \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;object\u0026lt;/span\u0026gt; opPropertyValue = item.GetValue(opSource, \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;null\u0026lt;/span\u0026gt;);\n                \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (opPropertyValue == \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;null\u0026lt;/span\u0026gt;)\n                {\n                    item.SetValue(opTarget, \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;null\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;null\u0026lt;/span\u0026gt;);\n                }\n                \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;else\u0026lt;/span\u0026gt;\n                {\n                    item.SetValue(opTarget, CloneObject(opPropertyValue), \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;null\u0026lt;/span\u0026gt;);\n                }\n            }\n        }\n    }\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//return the new item\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; opTarget;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;As I couldn\u0026apos;t find a cloner that meets all my requirements in different projects, I created a deep cloner that can be configured and adapted to different code structures instead of adapting my code to meet the cloners requirements. Its achieved by adding annotations to the code that shall be cloned or you just leave the code as it is to have the default behaviour. It uses reflection, type caches and is based on \u0026lt;a href=\u0026quot;https://fasterflect.codeplex.com/\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;fasterflect\u0026lt;/a\u0026gt;. The cloning process is very fast for a huge amount of data and a high object hierarchy (compared to other reflection/serialization based algorithms). \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;a href=\u0026quot;https://github.com/kalisohn/CloneBehave\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;https://github.com/kalisohn/CloneBehave\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Also available as a nuget package:\n\u0026lt;a href=\u0026quot;https://www.nuget.org/packages/Clone.Behave/1.0.0\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;https://www.nuget.org/packages/Clone.Behave/1.0.0\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;For example: The following code will deepClone Address, but only perform a shallow copy of the _currentJob field. \u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cs s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-csharp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;Person\u0026lt;/span\u0026gt; \n{\n  [\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;DeepClone(DeepCloneBehavior.Shallow)\u0026lt;/span\u0026gt;]\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;private\u0026lt;/span\u0026gt; Job _currentJob;      \n\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;string\u0026lt;/span\u0026gt; Name { \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;get\u0026lt;/span\u0026gt;; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;set\u0026lt;/span\u0026gt;; }\n\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; Job CurrentJob \n  { \n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;get\u0026lt;/span\u0026gt;{ \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; _currentJob; }\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;set\u0026lt;/span\u0026gt;{ _currentJob = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;value\u0026lt;/span\u0026gt;; }\n  }\n\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; Person Manager { \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;get\u0026lt;/span\u0026gt;; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;set\u0026lt;/span\u0026gt;; }\n}\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;Address\u0026lt;/span\u0026gt; \n{      \n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; Person PersonLivingHere { \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;get\u0026lt;/span\u0026gt;; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;set\u0026lt;/span\u0026gt;; }\n}\n\nAddress adr = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; Address();\nadr.PersonLivingHere = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; Person(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;John\u0026quot;\u0026lt;/span\u0026gt;);\nadr.PersonLivingHere.BestFriend = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; Person(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;James\u0026quot;\u0026lt;/span\u0026gt;);\nadr.PersonLivingHere.CurrentJob = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; Job(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Programmer\u0026quot;\u0026lt;/span\u0026gt;);\n\nAddress adrClone = adr.Clone();\n\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//RESULT\u0026lt;/span\u0026gt;\nadr.PersonLivingHere == adrClone.PersonLivingHere \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//false\u0026lt;/span\u0026gt;\nadr.PersonLivingHere.Manager == adrClone.PersonLivingHere.Manager \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//false\u0026lt;/span\u0026gt;\nadr.PersonLivingHere.CurrentJob == adrClone.PersonLivingHere.CurrentJob \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//true\u0026lt;/span\u0026gt;\nadr.PersonLivingHere.CurrentJob.AnyProperty == adrClone.PersonLivingHere.CurrentJob.AnyProperty \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//true\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Create an extension:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-cs s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-csharp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;static\u0026lt;/span\u0026gt; T \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;Clone\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;T\u0026lt;/span\u0026gt;\u0026amp;gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;this\u0026lt;/span\u0026gt; T theObject\u0026lt;/span\u0026gt;)\u0026lt;/span\u0026gt;\n{\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;string\u0026lt;/span\u0026gt; jsonData = JsonConvert.SerializeObject(theObject);\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; JsonConvert.DeserializeObject\u0026amp;lt;T\u0026amp;gt;(jsonData);\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;And call it like this:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-cs s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-csharp\u0026quot;\u0026gt;NewObject = OldObject.Clone();\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;h1\u0026gt;Code Generator\u0026lt;/h1\u0026gt;\n\n\u0026lt;p\u0026gt;We have seen a lot of ideas from serialization over manual implementation to reflection and I want to propose a totally different approach using the \u0026lt;a href=\u0026quot;https://github.com/Toxantron/CGbR#cloneable\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;CGbR Code Generator\u0026lt;/a\u0026gt;. The generate clone method is memory and CPU efficient and therefor 300x faster as the standard DataContractSerializer.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;All you need is a partial class definition with \u0026lt;code\u0026gt;ICloneable\u0026lt;/code\u0026gt; and the generator does the rest:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cs s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-csharp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;partial\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;Root\u0026lt;/span\u0026gt; : \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;ICloneable\u0026lt;/span\u0026gt;\n{\n    \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;Root\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; number\u0026lt;/span\u0026gt;)\u0026lt;/span\u0026gt;\n    {\n        _number = number;\n    }\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;private\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; _number;\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; Partial[] Partials { \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;get\u0026lt;/span\u0026gt;; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;set\u0026lt;/span\u0026gt;; }\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; IList\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;ulong\u0026lt;/span\u0026gt;\u0026amp;gt; Numbers { \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;get\u0026lt;/span\u0026gt;; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;set\u0026lt;/span\u0026gt;; }\n\n    \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;object\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;Clone\u0026lt;/span\u0026gt;()\u0026lt;/span\u0026gt;\n    {\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; Clone(\u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;true\u0026lt;/span\u0026gt;);\n    }\n\n    \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;private\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;Root\u0026lt;/span\u0026gt;()\u0026lt;/span\u0026gt;\n    {\n    }\n} \n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;partial\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;Root\u0026lt;/span\u0026gt;\n{\n    \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; Root \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;Clone\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;bool\u0026lt;/span\u0026gt; deep\u0026lt;/span\u0026gt;)\u0026lt;/span\u0026gt;\n    {\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; copy = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; Root();\n        \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// All value types can be simply copied\u0026lt;/span\u0026gt;\n        copy._number = _number; \n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (deep)\n        {\n            \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// In a deep clone the references are cloned \u0026lt;/span\u0026gt;\n            \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; tempPartials = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; Partial[Partials.Length];\n            \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt; (\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; i = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;; i \u0026amp;lt; Partials.Length; i++)\n            {\n                \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;value\u0026lt;/span\u0026gt; = Partials[i];\n                \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;value\u0026lt;/span\u0026gt; = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;value\u0026lt;/span\u0026gt;.Clone(\u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;true\u0026lt;/span\u0026gt;);\n                tempPartials[i] = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;value\u0026lt;/span\u0026gt;;\n            }\n            copy.Partials = tempPartials;\n            \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; tempNumbers = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; List\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;ulong\u0026lt;/span\u0026gt;\u0026amp;gt;(Numbers.Count);\n            \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt; (\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; i = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;; i \u0026amp;lt; Numbers.Count; i++)\n            {\n                \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;value\u0026lt;/span\u0026gt; = Numbers[i];\n                tempNumbers.Add(\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;value\u0026lt;/span\u0026gt;);\n            }\n            copy.Numbers = tempNumbers;\n        }\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;else\u0026lt;/span\u0026gt;\n        {\n            \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// In a shallow clone only references are copied\u0026lt;/span\u0026gt;\n            copy.Partials = Partials; \n            copy.Numbers = Numbers; \n        }\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; copy;\n    }\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Note:\u0026lt;/strong\u0026gt; Latest version has a more null checks, but I left them out for better understanding.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;I like Copyconstructors like that:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cs s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-csharp\u0026quot;\u0026gt;    \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;AnyObject\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;AnyObject anyObject\u0026lt;/span\u0026gt;)\u0026lt;/span\u0026gt;\n    {\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;foreach\u0026lt;/span\u0026gt; (\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; property \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;in\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;typeof\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;AnyObject\u0026lt;/span\u0026gt;).\u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;GetProperties\u0026lt;/span\u0026gt;())\u0026lt;/span\u0026gt;\n        {\n            property.SetValue(\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;this\u0026lt;/span\u0026gt;, property.GetValue(anyObject));\n        }\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;foreach\u0026lt;/span\u0026gt; (\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; field \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;in\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;typeof\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;AnyObject\u0026lt;/span\u0026gt;).\u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;GetFields\u0026lt;/span\u0026gt;())\u0026lt;/span\u0026gt;\n        {\n            field.SetValue(\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;this\u0026lt;/span\u0026gt;, field.GetValue(anyObject));\n        }\n    }\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;If you have more things to copy add them\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;This method solved the problem for me:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cs s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-csharp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;private\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;static\u0026lt;/span\u0026gt; MyObj \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;DeepCopy\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;MyObj source\u0026lt;/span\u0026gt;)\u0026lt;/span\u0026gt;\n        {\n\n            \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; DeserializeSettings = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; JsonSerializerSettings { ObjectCreationHandling = ObjectCreationHandling.Replace };\n\n            \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; JsonConvert.DeserializeObject\u0026amp;lt;MyObj \u0026amp;gt;(JsonConvert.SerializeObject(source), DeserializeSettings);\n\n        }\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Use it like this: \u0026lt;code\u0026gt;MyObj a = DeepCopy(b);\u0026lt;/code\u0026gt;\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Here a solution fast and easy that worked for me without relaying on Serialization/Deserialization. \u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cs s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-csharp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;MyClass\u0026lt;/span\u0026gt;\n{\n    \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;virtual\u0026lt;/span\u0026gt; MyClass \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;DeepClone\u0026lt;/span\u0026gt;()\u0026lt;/span\u0026gt;\n    {\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; returnObj = (MyClass)MemberwiseClone();\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; type = returnObj.GetType();\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; fieldInfoArray = type.GetRuntimeFields().ToArray();\n\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;foreach\u0026lt;/span\u0026gt; (\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; fieldInfo \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;in\u0026lt;/span\u0026gt; fieldInfoArray)\n        {\n            \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;object\u0026lt;/span\u0026gt; sourceFieldValue = fieldInfo.GetValue(\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;this\u0026lt;/span\u0026gt;);\n            \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (!(sourceFieldValue \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;is\u0026lt;/span\u0026gt; MyClass))\n            {\n                \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;continue\u0026lt;/span\u0026gt;;\n            }\n\n            \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; sourceObj = (MyClass)sourceFieldValue;\n            \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; clonedObj = sourceObj.DeepClone();\n            fieldInfo.SetValue(returnObj, clonedObj);\n        }\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; returnObj;\n    }\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;EDIT\u0026lt;/strong\u0026gt;:\nrequires \u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cs s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-csharp\u0026quot;\u0026gt;    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;using\u0026lt;/span\u0026gt; System.Linq;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;using\u0026lt;/span\u0026gt; System.Reflection;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;That\u0026apos;s How I used it\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cs s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-csharp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; MyClass \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;Clone\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;MyClass theObjectIneededToClone\u0026lt;/span\u0026gt;)\u0026lt;/span\u0026gt;\n{\n    MyClass clonedObj = theObjectIneededToClone.DeepClone();\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Follow these steps:\u0026lt;/p\u0026gt;\n\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;Define an \u0026lt;code\u0026gt;ISelf\u0026amp;lt;T\u0026amp;gt;\u0026lt;/code\u0026gt; with a read-only \u0026lt;code\u0026gt;Self\u0026lt;/code\u0026gt; property that returns \u0026lt;code\u0026gt;T\u0026lt;/code\u0026gt;, and \u0026lt;code\u0026gt;ICloneable\u0026amp;lt;out T\u0026amp;gt;\u0026lt;/code\u0026gt;, which derives from \u0026lt;code\u0026gt;ISelf\u0026amp;lt;T\u0026amp;gt;\u0026lt;/code\u0026gt; and includes a method \u0026lt;code\u0026gt;T Clone()\u0026lt;/code\u0026gt;.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Then define a \u0026lt;code\u0026gt;CloneBase\u0026lt;/code\u0026gt; type which implements a \u0026lt;code\u0026gt;protected virtual generic VirtualClone\u0026lt;/code\u0026gt; casting \u0026lt;code\u0026gt;MemberwiseClone\u0026lt;/code\u0026gt; to the passed-in type.  \u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Each derived type should implement \u0026lt;code\u0026gt;VirtualClone\u0026lt;/code\u0026gt; by calling the base clone method and then doing whatever needs to be done to properly clone those aspects of the derived type which the parent VirtualClone method hasn\u0026apos;t yet handled.\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\n\u0026lt;p\u0026gt;For maximum inheritance versatility, classes exposing public cloning functionality should be \u0026lt;code\u0026gt;sealed\u0026lt;/code\u0026gt;, but derive from a base class which is otherwise identical except for the lack of cloning.  Rather than passing variables of the explicit clonable type, take a parameter of type \u0026lt;code\u0026gt;ICloneable\u0026amp;lt;theNonCloneableType\u0026amp;gt;\u0026lt;/code\u0026gt;.  This will allow a routine that expects a cloneable derivative of  \u0026lt;code\u0026gt;Foo\u0026lt;/code\u0026gt; to work with a cloneable derivative of \u0026lt;code\u0026gt;DerivedFoo\u0026lt;/code\u0026gt;, but also allow the creation of non-cloneable derivatives of \u0026lt;code\u0026gt;Foo\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;As nearly all of the answers to this question have been unsatisfactory or plainly don\u0026apos;t work in my situation, I have authored \u0026lt;a href=\u0026quot;https://github.com/replaysMike/AnyClone\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;AnyClone\u0026lt;/a\u0026gt; which is entirely implemented with reflection and solved all of the needs here. I was unable to get serialization to work in a complicated scenario with complex structure, and \u0026lt;code\u0026gt;IClonable\u0026lt;/code\u0026gt; is less than ideal - in fact it shouldn\u0026apos;t even be necessary.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Standard ignore attributes are supported using \u0026lt;code\u0026gt;[IgnoreDataMember]\u0026lt;/code\u0026gt;, \u0026lt;code\u0026gt;[NonSerialized]\u0026lt;/code\u0026gt;. Supports complex collections, properties without setters, readonly fields etc.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;I hope it helps someone else out there who ran into the same problems I did.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;I have created a version of the accepted answer that works with both \u0026apos;[Serializable]\u0026apos; and \u0026apos;[DataContract]\u0026apos;. It has been a while since I wrote it, but if I remember correctly [DataContract] needed a different serializer.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Requires \u0026lt;em\u0026gt;System, System.IO, System.Runtime.Serialization, System.Runtime.Serialization.Formatters.Binary, System.Xml\u0026lt;/em\u0026gt;;\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cs s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-csharp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;static\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;ObjectCopier\u0026lt;/span\u0026gt;\n{\n\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-doctag\u0026quot;\u0026gt;///\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-doctag\u0026quot;\u0026gt;\u0026amp;lt;summary\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-doctag\u0026quot;\u0026gt;///\u0026lt;/span\u0026gt; Perform a deep Copy of an object that is marked with \u0026apos;[Serializable]\u0026apos; or \u0026apos;[DataContract]\u0026apos;\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-doctag\u0026quot;\u0026gt;///\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-doctag\u0026quot;\u0026gt;\u0026amp;lt;/summary\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-doctag\u0026quot;\u0026gt;///\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-doctag\u0026quot;\u0026gt;\u0026amp;lt;typeparam name=\u0026quot;T\u0026quot;\u0026amp;gt;\u0026lt;/span\u0026gt;The type of object being copied.\u0026lt;span class=\u0026quot;hljs-doctag\u0026quot;\u0026gt;\u0026amp;lt;/typeparam\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-doctag\u0026quot;\u0026gt;///\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-doctag\u0026quot;\u0026gt;\u0026amp;lt;param name=\u0026quot;source\u0026quot;\u0026amp;gt;\u0026lt;/span\u0026gt;The object instance to copy.\u0026lt;span class=\u0026quot;hljs-doctag\u0026quot;\u0026gt;\u0026amp;lt;/param\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-doctag\u0026quot;\u0026gt;///\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-doctag\u0026quot;\u0026gt;\u0026amp;lt;returns\u0026amp;gt;\u0026lt;/span\u0026gt;The copied object.\u0026lt;span class=\u0026quot;hljs-doctag\u0026quot;\u0026gt;\u0026amp;lt;/returns\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;static\u0026lt;/span\u0026gt; T \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;Clone\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;T\u0026lt;/span\u0026gt;\u0026amp;gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;T source\u0026lt;/span\u0026gt;)\u0026lt;/span\u0026gt;\n    {\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typeof\u0026lt;/span\u0026gt;(T).IsSerializable == \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;true\u0026lt;/span\u0026gt;)\n        {\n            \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; CloneUsingSerializable\u0026amp;lt;T\u0026amp;gt;(source);\n        }\n\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (IsDataContract(\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typeof\u0026lt;/span\u0026gt;(T)) == \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;true\u0026lt;/span\u0026gt;)\n        {\n            \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; CloneUsingDataContracts\u0026amp;lt;T\u0026amp;gt;(source);\n        }\n\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;throw\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; ArgumentException(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;The type must be Serializable or use DataContracts.\u0026quot;\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;source\u0026quot;\u0026lt;/span\u0026gt;);\n    }\n\n\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-doctag\u0026quot;\u0026gt;///\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-doctag\u0026quot;\u0026gt;\u0026amp;lt;summary\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-doctag\u0026quot;\u0026gt;///\u0026lt;/span\u0026gt; Perform a deep Copy of an object that is marked with \u0026apos;[Serializable]\u0026apos;\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-doctag\u0026quot;\u0026gt;///\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-doctag\u0026quot;\u0026gt;\u0026amp;lt;/summary\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-doctag\u0026quot;\u0026gt;///\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-doctag\u0026quot;\u0026gt;\u0026amp;lt;remarks\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-doctag\u0026quot;\u0026gt;///\u0026lt;/span\u0026gt; Found on http://stackoverflow.com/questions/78536/cloning-objects-in-c-sharp\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-doctag\u0026quot;\u0026gt;///\u0026lt;/span\u0026gt; Uses code found on CodeProject, which allows free use in third party apps\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-doctag\u0026quot;\u0026gt;///\u0026lt;/span\u0026gt; - http://www.codeproject.com/KB/tips/SerializedObjectCloner.aspx\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-doctag\u0026quot;\u0026gt;///\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-doctag\u0026quot;\u0026gt;\u0026amp;lt;/remarks\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-doctag\u0026quot;\u0026gt;///\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-doctag\u0026quot;\u0026gt;\u0026amp;lt;typeparam name=\u0026quot;T\u0026quot;\u0026amp;gt;\u0026lt;/span\u0026gt;The type of object being copied.\u0026lt;span class=\u0026quot;hljs-doctag\u0026quot;\u0026gt;\u0026amp;lt;/typeparam\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-doctag\u0026quot;\u0026gt;///\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-doctag\u0026quot;\u0026gt;\u0026amp;lt;param name=\u0026quot;source\u0026quot;\u0026amp;gt;\u0026lt;/span\u0026gt;The object instance to copy.\u0026lt;span class=\u0026quot;hljs-doctag\u0026quot;\u0026gt;\u0026amp;lt;/param\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-doctag\u0026quot;\u0026gt;///\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-doctag\u0026quot;\u0026gt;\u0026amp;lt;returns\u0026amp;gt;\u0026lt;/span\u0026gt;The copied object.\u0026lt;span class=\u0026quot;hljs-doctag\u0026quot;\u0026gt;\u0026amp;lt;/returns\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;static\u0026lt;/span\u0026gt; T \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;CloneUsingSerializable\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;T\u0026lt;/span\u0026gt;\u0026amp;gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;T source\u0026lt;/span\u0026gt;)\u0026lt;/span\u0026gt;\n    {\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (!\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typeof\u0026lt;/span\u0026gt;(T).IsSerializable)\n        {\n            \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;throw\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; ArgumentException(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;The type must be serializable.\u0026quot;\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;source\u0026quot;\u0026lt;/span\u0026gt;);\n        }\n\n        \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Don\u0026apos;t serialize a null object, simply return the default for that object\u0026lt;/span\u0026gt;\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (Object.ReferenceEquals(source, \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;null\u0026lt;/span\u0026gt;))\n        {\n            \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;default\u0026lt;/span\u0026gt;(T);\n        }\n\n        IFormatter formatter = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; BinaryFormatter();\n        Stream stream = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; MemoryStream();\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;using\u0026lt;/span\u0026gt; (stream)\n        {\n            formatter.Serialize(stream, source);\n            stream.Seek(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;, SeekOrigin.Begin);\n            \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; (T)formatter.Deserialize(stream);\n        }\n    }\n\n\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-doctag\u0026quot;\u0026gt;///\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-doctag\u0026quot;\u0026gt;\u0026amp;lt;summary\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-doctag\u0026quot;\u0026gt;///\u0026lt;/span\u0026gt; Perform a deep Copy of an object that is marked with \u0026apos;[DataContract]\u0026apos;\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-doctag\u0026quot;\u0026gt;///\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-doctag\u0026quot;\u0026gt;\u0026amp;lt;/summary\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-doctag\u0026quot;\u0026gt;///\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-doctag\u0026quot;\u0026gt;\u0026amp;lt;typeparam name=\u0026quot;T\u0026quot;\u0026amp;gt;\u0026lt;/span\u0026gt;The type of object being copied.\u0026lt;span class=\u0026quot;hljs-doctag\u0026quot;\u0026gt;\u0026amp;lt;/typeparam\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-doctag\u0026quot;\u0026gt;///\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-doctag\u0026quot;\u0026gt;\u0026amp;lt;param name=\u0026quot;source\u0026quot;\u0026amp;gt;\u0026lt;/span\u0026gt;The object instance to copy.\u0026lt;span class=\u0026quot;hljs-doctag\u0026quot;\u0026gt;\u0026amp;lt;/param\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-doctag\u0026quot;\u0026gt;///\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-doctag\u0026quot;\u0026gt;\u0026amp;lt;returns\u0026amp;gt;\u0026lt;/span\u0026gt;The copied object.\u0026lt;span class=\u0026quot;hljs-doctag\u0026quot;\u0026gt;\u0026amp;lt;/returns\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;static\u0026lt;/span\u0026gt; T \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;CloneUsingDataContracts\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;T\u0026lt;/span\u0026gt;\u0026amp;gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;T source\u0026lt;/span\u0026gt;)\u0026lt;/span\u0026gt;\n    {\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (IsDataContract(\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typeof\u0026lt;/span\u0026gt;(T)) == \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;false\u0026lt;/span\u0026gt;)\n        {\n            \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;throw\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; ArgumentException(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;The type must be a data contract.\u0026quot;\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;source\u0026quot;\u0026lt;/span\u0026gt;);\n        }\n\n        \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// ** Don\u0026apos;t serialize a null object, simply return the default for that object\u0026lt;/span\u0026gt;\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (Object.ReferenceEquals(source, \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;null\u0026lt;/span\u0026gt;))\n        {\n            \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;default\u0026lt;/span\u0026gt;(T);\n        }\n\n        DataContractSerializer dcs = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; DataContractSerializer(\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typeof\u0026lt;/span\u0026gt;(T));\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;using\u0026lt;/span\u0026gt;(Stream stream = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; MemoryStream())\n        {\n            \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;using\u0026lt;/span\u0026gt; (XmlDictionaryWriter writer = XmlDictionaryWriter.CreateBinaryWriter(stream))\n            {\n                dcs.WriteObject(writer, source);\n                writer.Flush();\n                stream.Seek(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;, SeekOrigin.Begin);\n                \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;using\u0026lt;/span\u0026gt; (XmlDictionaryReader reader = XmlDictionaryReader.CreateBinaryReader(stream, XmlDictionaryReaderQuotas.Max))\n                {\n                    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; (T)dcs.ReadObject(reader);\n                }\n            }\n        }\n    }\n\n\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-doctag\u0026quot;\u0026gt;///\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-doctag\u0026quot;\u0026gt;\u0026amp;lt;summary\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-doctag\u0026quot;\u0026gt;///\u0026lt;/span\u0026gt; Helper function to check if a class is a [DataContract]\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-doctag\u0026quot;\u0026gt;///\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-doctag\u0026quot;\u0026gt;\u0026amp;lt;/summary\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-doctag\u0026quot;\u0026gt;///\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-doctag\u0026quot;\u0026gt;\u0026amp;lt;param name=\u0026quot;type\u0026quot;\u0026amp;gt;\u0026lt;/span\u0026gt;The type of the object to check.\u0026lt;span class=\u0026quot;hljs-doctag\u0026quot;\u0026gt;\u0026amp;lt;/param\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-doctag\u0026quot;\u0026gt;///\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-doctag\u0026quot;\u0026gt;\u0026amp;lt;returns\u0026amp;gt;\u0026lt;/span\u0026gt;Boolean flag indicating if the class is a DataContract (true) or not (false) \u0026lt;span class=\u0026quot;hljs-doctag\u0026quot;\u0026gt;\u0026amp;lt;/returns\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;static\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;bool\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;IsDataContract\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;Type type\u0026lt;/span\u0026gt;)\u0026lt;/span\u0026gt;\n    {\n        \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;object\u0026lt;/span\u0026gt;[] attributes = type.GetCustomAttributes(\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typeof\u0026lt;/span\u0026gt;(DataContractAttribute), \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;false\u0026lt;/span\u0026gt;);\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; attributes.Length == \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;;\n    }\n\n} \n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    "],"id":421,"title":"Deep cloning objects","content":"\n                \n\u0026lt;p\u0026gt;I want to do something like:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cs s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-csharp\u0026quot;\u0026gt;MyObject myObj = GetMyObj(); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Create and fill a new object\u0026lt;/span\u0026gt;\nMyObject newObj = myObj.Clone();\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;And then make changes to the new object that are not reflected in the original object.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;I don\u0026apos;t often need this functionality, so when it\u0026apos;s been necessary, I\u0026apos;ve resorted to creating a new object and then copying each property individually, but it always leaves me with the feeling that there is a better or more elegant way of handling the situation.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;How can I clone or deep copy an object so that the cloned object can be modified without any changes being reflected in the original object?\u0026lt;/p\u0026gt;\n    ","slug":"deep-cloning-objects-1657387930865","postType":"QUESTION","createdAt":"2022-07-09T17:32:10.000Z","updatedAt":"2022-07-09T17:32:10.000Z","tags":[],"relatedQuestions":[]},"randomQuestions":[{"title":"Why is processing a sorted array faster than processing an unsorted array?","slug":"why-is-processing-a-sorted-array-faster-than-processing-an-unsorted-array-1657385497444"},{"title":"Collapse / concatenate / aggregate a column to a single comma separated string within each group","slug":"collapse-concatenate-aggregate-a-column-to-a-single-comma-separated-string-within-each-group-1657387870901"},{"title":"How to parse JSON in Java","slug":"how-to-parse-json-in-java-1657384575136"},{"title":"How can I group an array of objects by key?","slug":"how-can-i-group-an-array-of-objects-by-key-1657388065372"},{"title":"What does this symbol mean in JavaScript?","slug":"what-does-this-symbol-mean-in-javascript-1657387632971"},{"title":"Cross-thread operation not valid: Control accessed from a thread other than the thread it was created on","slug":"cross-thread-operation-not-valid:-control-accessed-from-a-thread-other-than-the-thread-it-was-created-on-1657387659019"},{"title":"How do I expire a PHP session after 30 minutes?","slug":"how-do-i-expire-a-php-session-after-30-minutes-1657387990658"},{"title":"Why are global variables evil? [closed]","slug":"why-are-global-variables-evil-closed-1657388260006"},{"title":"How do I pass variables and data from PHP to JavaScript?","slug":"how-do-i-pass-variables-and-data-from-php-to-javascript-1657384684553"},{"title":"How to deal with SettingWithCopyWarning in Pandas","slug":"how-to-deal-with-settingwithcopywarning-in-pandas-1657384778377"},{"title":"I just assigned a variable, but echo $variable shows something else","slug":"i-just-assigned-a-variable-but-echo-dollarvariable-shows-something-else-1657387574561"},{"title":"How to calculate the difference between two dates using PHP?","slug":"how-to-calculate-the-difference-between-two-dates-using-php-1657387409560"},{"title":"Is there a unique Android device ID?","slug":"is-there-a-unique-android-device-id-1657388089268"},{"title":"Get the values from the \"GET\" parameters (JavaScript) [duplicate]","slug":"get-the-values-from-the-\"get\"-parameters-(javascript)-duplicate-1657387656693"},{"title":"How do function pointers in C work?","slug":"how-do-function-pointers-in-c-work-1657388332074"},{"title":"What to do Regular expression pattern doesn't match anywhere in string?","slug":"what-to-do-regular-expression-pattern-doesn't-match-anywhere-in-string-1657388095896"},{"title":"How can I convert ereg expressions to preg in PHP?","slug":"how-can-i-convert-ereg-expressions-to-preg-in-php-1657387652855"},{"title":"The ViewData item that has the key 'XXX' is of type 'System.Int32' but must be of type 'IEnumerable\u003cSelectListItem\u003e'","slug":"the-viewdata-item-that-has-the-key-'xxx'-is-of-type-'system.int32'-but-must-be-of-type-'ienumerablelessselectlistitemgreater'-1657388454191"},{"title":"How do I set, clear, and toggle a single bit?","slug":"how-do-i-set-clear-and-toggle-a-single-bit-1657388227052"},{"title":"How do I attach events to dynamic HTML elements with jQuery? [duplicate]","slug":"how-do-i-attach-events-to-dynamic-html-elements-with-jquery-duplicate-1657387992964"}]},"__N_SSG":true},"page":"/questions/[slug]","query":{"slug":"deep-cloning-objects-1657387930865"},"buildId":"TQ2eYlCSdocSK-hq6gkM0","isFallback":false,"gsp":true,"locale":"en","locales":["en"],"defaultLocale":"en","scriptLoader":[]}</script></body></html>