<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><meta name="twitter:card" content="summary_large_image"/><meta name="twitter:site" content="@solutionschecker.com"/><meta name="twitter:creator" content="@solutionschecker.com"/><meta property="og:url" content="https://solutionschecker.com"/><meta property="og:type" content="website"/><meta property="og:image" content="https://solutionschecker.com/solutions-checker-banner.png"/><meta property="og:image:alt" content="Find the solution to any question. We focus on finding the fastest possible solution for users. Main topics like coding, learning. - solutionschecker.com"/><link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png"/><link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png"/><link rel="manifest" href="/site.webmanifest"/><script type="application/ld+json">{"@context":"https://schema.org","@type":"Organization","logo":"/logo.svg","url":"https://solutionschecker.com"}</script><link name="keywords" content="srand,solutions checker, solution checker, how to, solution for, check for solution, resolve question, what is, what solution for, find solution"/><script type="application/ld+json">{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"item":{"@id":"https://solutionschecker.com","name":"Home"}},{"@type":"ListItem","position":2,"item":{"@id":"https://solutionschecker.com/questions","name":"Questions"}},{"@type":"ListItem","position":3,"item":{"@id":"https://solutionschecker.com/questions/srand()-why-call-it-only-once-1657387794760","name":"Questions"}}]}</script><title>srand() — why call it only once? | Solution Checker</title><meta name="robots" content="index,follow"/><meta name="description" content="This question is about a comment in this question
Recommended way to initialize srand? The first comment says that srand() should be called only ONCE in an application. Why is it so?
    "/><meta property="og:title" content="srand() — why call it only once? | Solution Checker"/><meta property="og:description" content="This question is about a comment in this question
Recommended way to initialize srand? The first comment says that srand() should be called only ONCE in an application. Why is it so?
    "/><script type="application/ld+json">{"@context":"https://schema.org","@type":"QAPage","mainEntity":{"name":"srand() — why call it only once?","text":"This question is about a comment in this question\nRecommended way to initialize srand? The first comment says that srand() should be called only ONCE in an application. Why is it so?\n    ","answerCount":7,"upVoteCount":500,"suggestedAnswer":[{"text":"That depends on what you are trying to achieve.\n\nRandomization is performed as a function that has a starting value, namely the seed.\n\nSo, for the same seed, you will always get the same sequence of values.\n\nIf you try to set the seed every time you need a random value, and the seed is the same number, you will always get the same &quot;random&quot; value.\n\nSeed is usually taken from the current time, which are the seconds, as in time(NULL), so if you always set the seed before taking the random number, you will get the same number as long as you call the srand/rand combo multiple times in the same second.\n\nTo avoid this problem, srand is set only once per application, because it is doubtful that two of the application instances will be initialized in the same second, so each instance will then have a different sequence of random numbers.\n\nHowever, there is a slight possibility that you will run your app (especially if it&apos;s a short one, or a command line tool or something like that) many times in a second, then you will have to resort to some other way of choosing a seed (unless the same sequence in different application instances is ok by you). But like I said, that depends on your application context of usage.\n\nAlso, you may want to try to increase the precision to microseconds (minimizing the chance of the same seed), requires (sys/time.h):\n\nstruct timeval t1;\ngettimeofday(&amp;t1, NULL);\nsrand(t1.tv_usec * t1.tv_sec);\n\n    ","url":"/questions/[slug]#solution1","@type":"Answer","upvoteCount":0},{"text":"Random numbers are actually pseudo random. A seed is set first, from which each call of rand gets a random number, and modifies the internal state and this new state is used in the next rand call to get another number. Because a certain formula is used to generate these &quot;random numbers&quot; therefore setting a certain value of seed after every call to rand will return the same number from the call. For example srand (1234); rand (); will return the same value. Initializing once the initial state with the seed value will generate enough random numbers as you do not set the internal state with srand, thus making the numbers more probable to be random.\n\nGenerally we use the time (NULL) returned seconds value when initializing the seed value. Say the srand (time (NULL)); is in a loop. Then loop can iterate more than once in one second, therefore the number of times the loop iterates inside the loop in a second rand call in the loop will return the same &quot;random number&quot;, which is not desired. Initializing it once at program start will set the seed once, and each time rand is called, a new number is generated and the internal state is modified, so the next call rand returns a number which is random enough.\n\nFor example this code from http://linux.die.net/man/3/rand:\n\nstatic unsigned long next = 1;\n/* RAND_MAX assumed to be 32767 */\nint myrand(void) {\n    next = next * 1103515245 + 12345;\n    return((unsigned)(next/65536) % 32768);\n}\nvoid mysrand(unsigned seed) {\n    next = seed;\n}\n\n\nThe internal state next is declared as global. Each myrand call will modify the internal state and update it, and return a random number. Every call of myrand will have a different next value therefore the the method will return the different numbers every call. \n\nLook at the mysrand implementation; it simply sets the seed value you pass to next. Therefore if you set the next value the same  everytime before calling rand it will return the same random value, because of the identical formula applied on it, which is not desirable, as the function is made to be random.\n\nBut depending on your needs you can set the seed to some certain value to generate the same &quot;random sequence&quot; each run, say for some benchmark or others.\n    ","url":"/questions/[slug]#solution2","@type":"Answer","upvoteCount":0},{"text":"Short answer: calling srand() is not like &quot;rolling the dice&quot; for the random number generator.  Nor is it like shuffling a deck of cards.  If anything, it&apos;s more like just cutting a deck of cards.\nThink of it like this.  rand() deals from a big deck of cards, and every time you call it, all it does is pick the next card off the top of the deck, give you the value, and return that card to the bottom of the deck.  (Yes, that means the &quot;random&quot; sequence will repeat after a while.  It&apos;s a very big deck, though: typically 4,294,967,296 cards.)\nFurthermore, every time your program runs, a brand-new pack of cards is bought from the game shop, and every brand-new pack of cards always has the same sequence.  So unless you do something special, every time your program runs, it will get exactly the same &quot;random&quot; numbers back from rand().\nNow, you might say, &quot;Okay, so how do I shuffle the deck?&quot;  And the answer -- at least as far as rand and srand are concerned -- is that there is no way of shuffling the deck.\nSo what does srand do?  Based on the analogy I&apos;ve been building here, calling srand(n) is basically like saying, &quot;cut the deck n cards from the top&quot;.  But wait, one more thing: it&apos;s actually start with another brand-new deck and cut it n cards from the top.\nSo if you call srand(n), rand(), srand(n), rand(), ..., with the same n every time, you won&apos;t just get a not-very-random sequence, you&apos;ll actually get the same number back from rand() every time.  (Probably not the same number you handed to srand, but the same number back from rand over and over.)\nSo the best you can do is to cut the deck once, that is, call srand() once, at the beginning of your program, with an n that&apos;s reasonably random, so that you&apos;ll start at a different random place in the big deck each time your program runs.  With rand(), that really is the best you can do.\n[P.S. Yes, I know, in real life, when you buy a brand-new deck of cards it&apos;s typically in order, not in random order.  For the analogy here to work, I&apos;m imagining that each deck you buy from the game shop is in a seemingly random order, but the exact same seemingly-random order as every other deck of cards you buy from that same shop.  Sort of like the identically shuffled decks of cards they use in bridge tournaments.]\n\nAddendum: For a very cute demonstration of the fact that for a given PRNG algorithm and a given seed value, you always get the same sequence, see this question (which is about Java, not C, but anyway).\n    ","url":"/questions/[slug]#solution3","@type":"Answer","upvoteCount":0},{"text":"The reason is that srand() sets the initial state of the random generator, and all the values that generator produces are only &quot;random enough&quot; if you don&apos;t touch the state yourself in between.\n\nFor example you could do:\n\nint getRandomValue()\n{\n    srand(time(0));\n    return rand();\n}\n\n\nand then if you call that function repeatedly so that time() returns the same values in adjacent calls you just get the same value generated - that&apos;s by design.\n    ","url":"/questions/[slug]#solution4","@type":"Answer","upvoteCount":0},{"text":"A simpler solution for using srand() for generating different seeds for application instances run at the same second is as seen.\n\nsrand(time(NULL)-getpid());\n\n\nThis method makes your seed very close to random as there is no way to guess at what time your thread started and the pid will be different also.\n    ","url":"/questions/[slug]#solution5","@type":"Answer","upvoteCount":0},{"text":"srand seeds the pseudorandom number generator.  If you call it more than once, you will reseed the RNG.  And if you call it with the same argument, it will restart the same sequence.\nTo prove it, if you do something simple like this, you will see the same number printed 100 times:\n#include &lt;stdlib.h&gt;\n#include &lt;stdio.h&gt;\nint main() {\n    for(int i = 0; i != 100; ++i) {\n        srand(0);\n        printf(&quot;%d\\n&quot;, rand());\n    }\n}\n\n    ","url":"/questions/[slug]#solution6","@type":"Answer","upvoteCount":0},{"text":"\nIt seems that every time rand() runs, it will set a new seed for the next rand().\n\nIf srand() runs multiple times, the problem is if the two running happen in one second (the time(NULL) does not change), the next rand() will be the same as the rand() right after the previous srand().\n\n\n    ","url":"/questions/[slug]#solution7","@type":"Answer","upvoteCount":0}],"@type":"Question"}}</script><meta name="next-head-count" content="22"/><link rel="preload" href="/_next/static/css/4f7b2847abfe82c6.css" as="style"/><link rel="stylesheet" href="/_next/static/css/4f7b2847abfe82c6.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-0d1b80a048d4787e.js"></script><script src="/_next/static/chunks/webpack-42cdea76c8170223.js" defer=""></script><script src="/_next/static/chunks/framework-4556c45dd113b893.js" defer=""></script><script src="/_next/static/chunks/main-ccfab947c79712f4.js" defer=""></script><script src="/_next/static/chunks/pages/_app-c0d2dcb5e85faf18.js" defer=""></script><script src="/_next/static/chunks/294-106ef8570fa99deb.js" defer=""></script><script src="/_next/static/chunks/490-7f0418bb4354ac73.js" defer=""></script><script src="/_next/static/chunks/pages/questions/%5Bslug%5D-50e201fdaa1e0fd1.js" defer=""></script><script src="/_next/static/eGqQHYKGZKE-nXShFn8wX/_buildManifest.js" defer=""></script><script src="/_next/static/eGqQHYKGZKE-nXShFn8wX/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="wrapper"><header><nav class="bg-white border-gray-200 px-4 lg:px-6 py-2.5 dark:bg-gray-800"><div class="flex flex-wrap justify-between items-center mx-auto max-w-screen-xl"><a class="flex items-center" href="/"><img src="/logo-second.png" class="mr-3 h-6 sm:h-9" alt="Solution Checker Logo"/><h1 class="self-center text-xl font-semibold whitespace-nowrap dark:text-white">Solution Checker</h1></a><div class="flex items-center lg:order-2"><button data-collapse-toggle="mobile-menu-2" type="button" class="inline-flex items-center p-2 ml-1 text-sm text-gray-500 rounded-lg lg:hidden hover:bg-gray-100 focus:outline-none focus:ring-2 focus:ring-gray-200 dark:text-gray-400 dark:hover:bg-gray-700 dark:focus:ring-gray-600" aria-controls="mobile-menu-2" aria-expanded="false"><span class="sr-only">Open main menu</span><svg class="w-6 h-6" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M3 5a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM3 10a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM3 15a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1z" clip-rule="evenodd"></path></svg><svg class="hidden w-6 h-6" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z" clip-rule="evenodd"></path></svg></button></div><div class="hidden justify-between items-center w-full lg:flex lg:w-auto lg:order-1" id="mobile-menu-2"><ul class="flex flex-col mt-4 font-medium lg:flex-row lg:space-x-8 lg:mt-0"><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" aria-current="page" href="/">Home</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/questions?tab=news">Questions</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/post?tab=news">Post</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/questions/srand()-why-call-it-only-once-1657387794760#">Coding</a></li></ul></div></div></nav></header><div class="main-content"><div class="question my-5"><div class="flex question-header items-center m-auto justify-center"><div class="rounded-xl w-full border p-5 shadow-md bg-white"><div class="flex w-full items-center justify-between border-b pb-3"><div class="flex items-center space-x-3"><div class="text-lg font-bold text-slate-700"><a href="/questions/srand()-why-call-it-only-once-1657387794760"><h1>srand() — why call it only once?</h1></a></div></div><div class="flex flex-wrap h-auto justify-end items-center space-x-8"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold" href="/questions/tag/srand">srand</a></div></div><div class="question-content mt-5">
                
<p>This question is about a comment in this question
<a href="https://stackoverflow.com/questions/322938/recommended-way-to-initialize-srand">Recommended way to initialize srand?</a> The first comment says that <code>srand()</code> should be called only ONCE in an application. Why is it so?</p>
    </div></div></div><div class="solution-section"><nav class="flex pagination-solution flex-col justify-end"><h1 class="text-lg font-semibold mb-5">Navigate to solutions: </h1><ul class="inline-flex -space-x-px overflow-auto"><li class="pagination-solution-item"><span data-id="#solution1" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">1</span></li><li class="pagination-solution-item"><span data-id="#solution2" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">2</span></li><li class="pagination-solution-item"><span data-id="#solution3" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">3</span></li><li class="pagination-solution-item"><span data-id="#solution4" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">4</span></li><li class="pagination-solution-item"><span data-id="#solution5" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">5</span></li><li class="pagination-solution-item"><span data-id="#solution6" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">6</span></li><li class="pagination-solution-item"><span data-id="#solution7" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">7</span></li></ul></nav><div id="solution1" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 1</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/srand">srand</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>That depends on what you are trying to achieve.</p>

<p>Randomization is performed as a function that has a starting value, namely <strong>the seed</strong>.</p>

<p>So, for the same seed, you will always get the same sequence of values.</p>

<p>If you try to set the seed every time you need a random value, and the seed is the same number, you will always get the same "random" value.</p>

<p>Seed is usually taken from the current time, which are the seconds, as in <code>time(NULL)</code>, so if you always set the seed before taking the random number, you will get the same number as long as you call the srand/rand combo multiple times <strong>in the same second</strong>.</p>

<p>To avoid this problem, srand is set only once per application, because it is doubtful that two of the application instances will be initialized in the same second, so each instance will then have a different sequence of random numbers.</p>

<p>However, there is a slight possibility that you will run your app (especially if it's a short one, or a command line tool or something like that) many times in a second, then you will have to resort to some other way of choosing a seed (unless the same sequence in different application instances is ok by you). But like I said, that depends on your application context of usage.</p>

<p>Also, you may want to try to increase the precision to microseconds (minimizing the chance of the same seed), requires (<code>sys/time.h</code>):</p>

<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">timeval</span> <span class="hljs-title">t1</span>;</span>
gettimeofday(&amp;t1, <span class="hljs-literal">NULL</span>);
srand(t1.tv_usec * t1.tv_sec);
</code></pre>
    </div></div></div></div><div id="solution2" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 2</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/srand">srand</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Random numbers are actually pseudo random. A seed is set first, from which each call of <code>rand</code> gets a random number, and modifies the internal state and this new state is used in the next <code>rand</code> call to get another number. Because a certain formula is used to generate these "random numbers" therefore setting a certain value of seed after every call to <code>rand</code> will return the same number from the call. For example <code>srand (1234); rand ();</code> will return the same value. Initializing once the initial state with the seed value will generate enough random numbers as you do not set the internal state with <code>srand</code>, thus making the numbers more probable to be random.</p>

<p>Generally we use the <code>time (NULL)</code> returned seconds value when initializing the seed value. Say the <code>srand (time (NULL));</code> is in a loop. Then loop can iterate more than once in one second, therefore the number of times the loop iterates inside the loop in a second <code>rand</code> call in the loop will return the same "random number", which is not desired. Initializing it once at program start will set the seed once, and each time <code>rand</code> is called, a new number is generated and the internal state is modified, so the next call <code>rand</code> returns a number which is random enough.</p>

<p>For example this code from <a href="http://linux.die.net/man/3/rand" rel="noreferrer">http://linux.die.net/man/3/rand</a>:</p>

<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-type">static</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> next = <span class="hljs-number">1</span>;
<span class="hljs-comment">/* RAND_MAX assumed to be 32767 */</span>
<span class="hljs-type">int</span> <span class="hljs-title function_">myrand</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> {
    next = next * <span class="hljs-number">1103515245</span> + <span class="hljs-number">12345</span>;
    <span class="hljs-keyword">return</span>((<span class="hljs-type">unsigned</span>)(next/<span class="hljs-number">65536</span>) % <span class="hljs-number">32768</span>);
}
<span class="hljs-type">void</span> <span class="hljs-title function_">mysrand</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> seed)</span> {
    next = seed;
}
</code></pre>

<p>The internal state <code>next</code> is declared as global. Each <code>myrand</code> call will modify the internal state and update it, and return a random number. Every call of <code>myrand</code> will have a different <code>next</code> value therefore the the method will return the different numbers every call. </p>

<p>Look at the <code>mysrand</code> implementation; it simply sets the seed value you pass to <code>next</code>. Therefore if you set the <code>next</code> value the same  everytime before calling <code>rand</code> it will return the same random value, because of the identical formula applied on it, which is not desirable, as the function is made to be random.</p>

<p>But depending on your needs you can set the seed to some certain value to generate the same "random sequence" each run, say for some benchmark or others.</p>
    </div></div></div></div><div id="solution3" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 3</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/srand">srand</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Short answer: calling <code>srand()</code> is <strong>not</strong> like "rolling the dice" for the random number generator.  Nor is it like shuffling a deck of cards.  If anything, it's more like just cutting a deck of cards.</p>
<p>Think of it like this.  <code>rand()</code> deals from a big deck of cards, and every time you call it, all it does is pick the next card off the top of the deck, give you the value, and return that card to the bottom of the deck.  (Yes, that means the "random" sequence will repeat after a while.  It's a <em>very</em> big deck, though: typically 4,294,967,296 cards.)</p>
<p>Furthermore, every time your program runs, a brand-new pack of cards is bought from the game shop, <em>and</em> every brand-new pack of cards always has the same sequence.  So unless you do something special, every time your program runs, it will get exactly the same "random" numbers back from <code>rand()</code>.</p>
<p>Now, you might say, "Okay, so how do I shuffle the deck?"  And the answer -- at least as far as <code>rand</code> and <code>srand</code> are concerned -- is that there is no way of shuffling the deck.</p>
<p>So what does <code>srand</code> do?  Based on the analogy I've been building here, calling <code>srand(n)</code> is basically like saying, "cut the deck <code>n</code> cards from the top".  But wait, one more thing: it's actually <em>start with another brand-new deck and cut it <code>n</code> cards from the top</em>.</p>
<p>So if you call <code>srand(n)</code>, <code>rand()</code>, <code>srand(n)</code>, <code>rand()</code>, ..., with the same <code>n</code> every time, you won't just get a not-very-random sequence, you'll actually get the same number back from <code>rand()</code> every time.  (Probably not the same number you handed to <code>srand</code>, but the same number back from <code>rand</code> over and over.)</p>
<p>So the best you can do is to cut the deck <em>once</em>, that is, call <code>srand()</code> once, at the beginning of your program, with an <code>n</code> that's reasonably random, so that you'll start at a different random place in the big deck each time your program runs.  With <code>rand()</code>, that really is the best you can do.</p>
<p>[P.S. Yes, I know, in real life, when you buy a brand-new deck of cards it's typically in order, not in random order.  For the analogy here to work, I'm imagining that each deck you buy from the game shop is in a seemingly random order, but the exact same seemingly-random order as every other deck of cards you buy from that same shop.  Sort of like the identically shuffled decks of cards they use in bridge tournaments.]</p>
<hr>
<p>Addendum: For a very cute demonstration of the fact that for a given PRNG algorithm and a given seed value, you always get the same sequence, see <a href="https://stackoverflow.com/questions/15182496/why-does-this-code-using-random-strings-print-hello-world">this question</a> (which is about Java, not C, but anyway).</p>
    </div></div></div></div><div id="solution4" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 4</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/srand">srand</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>The reason is that <code>srand()</code> sets the initial state of the random generator, and all the values that generator produces are only "random enough" if you don't touch the state yourself in between.</p>

<p>For example you could do:</p>

<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-type">int</span> <span class="hljs-title function_">getRandomValue</span><span class="hljs-params">()</span>
{
    srand(time(<span class="hljs-number">0</span>));
    <span class="hljs-keyword">return</span> rand();
}
</code></pre>

<p>and then if you call that function repeatedly so that <code>time()</code> returns the same values in adjacent calls you just get the same value generated - that's by design.</p>
    </div></div></div></div><div id="solution5" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 5</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/srand">srand</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>A simpler solution for using <code>srand()</code> for generating different seeds for application instances run at the same second is as seen.</p>

<pre class="lang-c s-code-block"><code class="hljs language-c">srand(time(<span class="hljs-literal">NULL</span>)-getpid());
</code></pre>

<p>This method makes your seed very close to random as there is no way to guess at what time your thread started and the pid will be different also.</p>
    </div></div></div></div><div id="solution6" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 6</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/srand">srand</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>srand seeds the pseudorandom number generator.  If you call it more than once, you will reseed the RNG.  And if you call it with the same argument, it will restart the same sequence.</p>
<p>To prove it, if you do something simple like this, you will see the same number printed 100 times:</p>
<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span>
<span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> {
    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i != <span class="hljs-number">100</span>; ++i) {
        srand(<span class="hljs-number">0</span>);
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>, rand());
    }
}
</code></pre>
    </div></div></div></div><div id="solution7" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 7</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/srand">srand</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<ol>
<li><p>It seems that every time <code>rand()</code> runs, it will set a new seed for the next <code>rand()</code>.</p>
</li>
<li><p>If <code>srand()</code> runs multiple times, the problem is if the two running happen in one second (the <code>time(NULL)</code> does not change), the next <code>rand()</code> will be the same as the <code>rand()</code> right after the previous <code>srand()</code>.</p>
</li>
</ol>
    </div></div></div></div></div></div><div class="widget"><a href="/questions/can-a-local-variable&#x27;s-memory-be-accessed-outside-its-scope-1657384460386">Can a local variable&#x27;s memory be accessed outside its scope?</a><a href="/questions/how-to-generate-all-permutations-of-a-list-1657388537371">How to generate all permutations of a list</a><a href="/questions/strange-result-when-removing-item-from-a-list-while-iterating-over-it-duplicate-1657387735759">Strange result when removing item from a list while iterating over it [duplicate]</a><a href="/questions/what-is-a-debugger-and-how-can-it-help-me-diagnose-problems-1657384472469">What is a debugger and how can it help me diagnose problems?</a><a href="/questions/why-use-getters-and-settersaccessors-1657387343971">Why use getters and setters/accessors?</a><a href="/questions/converting-string-into-datetime-1657387717295">Converting string into datetime</a><a href="/questions/how-do-i-vertically-center-text-with-css-duplicate-1657387645821">How do I vertically center text with CSS? [duplicate]</a><a href="/questions/what-is-the-rule-of-three-1657384390295">What is The Rule of Three?</a><a href="/questions/fetch-the-rows-which-have-the-max-value-for-a-column-for-each-distinct-value-of-another-column-1657387423925">Fetch the rows which have the Max value for a column for each distinct value of another column</a><a href="/questions/what-does-enctype&#x27;multipartform-data&#x27;-mean-1657388229352">What does enctype=&#x27;multipart/form-data&#x27; mean?</a><a href="/questions/how-do-i-make-git-forget-about-a-file-that-was-tracked-but-is-now-in-.gitignore-1657387328843">How do I make Git forget about a file that was tracked, but is now in .gitignore?</a><a href="/questions/how-do-i-use-extern-to-share-variables-between-source-files-1657387453605">How do I use extern to share variables between source files?</a><a href="/questions/what-is-the-javascript-version-of-sleep()-1657387391406">What is the JavaScript version of sleep()?</a><a href="/questions/pandas-merging-101-1657384447080">Pandas Merging 101</a><a href="/questions/is-there-any-way-to-kill-a-thread-1657387859831">Is there any way to kill a Thread?</a><a href="/questions/how-to-use-regular-expressions-(regex)-in-microsoft-excel-both-in-cell-and-loops-1657387487287">How to use Regular Expressions (Regex) in Microsoft Excel both in-cell and loops</a><a href="/questions/what&#x27;s-the-simplest-way-to-print-a-java-array-1657384702397">What&#x27;s the simplest way to print a Java array?</a><a href="/questions/find-object-by-id-in-an-array-of-javascript-objects-1657387572087">Find object by id in an array of JavaScript objects</a><a href="/questions/how-to-remove-the-space-between-inlineinline-block-elements-1657384532273">How to remove the space between inline/inline-block elements?</a><a href="/questions/how-to-remove-items-from-a-list-while-iterating-1657384496375">How to remove items from a list while iterating?</a></div></div><span class="cursor-pointer text-lg p-2" style="position:fixed;bottom:20px;left:20px;background:#000;z-index:2000;color:white">Go go top</span></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"data":{"answer":["\n\u0026lt;p\u0026gt;That depends on what you are trying to achieve.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Randomization is performed as a function that has a starting value, namely \u0026lt;strong\u0026gt;the seed\u0026lt;/strong\u0026gt;.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;So, for the same seed, you will always get the same sequence of values.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;If you try to set the seed every time you need a random value, and the seed is the same number, you will always get the same \u0026quot;random\u0026quot; value.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Seed is usually taken from the current time, which are the seconds, as in \u0026lt;code\u0026gt;time(NULL)\u0026lt;/code\u0026gt;, so if you always set the seed before taking the random number, you will get the same number as long as you call the srand/rand combo multiple times \u0026lt;strong\u0026gt;in the same second\u0026lt;/strong\u0026gt;.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;To avoid this problem, srand is set only once per application, because it is doubtful that two of the application instances will be initialized in the same second, so each instance will then have a different sequence of random numbers.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;However, there is a slight possibility that you will run your app (especially if it\u0026apos;s a short one, or a command line tool or something like that) many times in a second, then you will have to resort to some other way of choosing a seed (unless the same sequence in different application instances is ok by you). But like I said, that depends on your application context of usage.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Also, you may want to try to increase the precision to microseconds (minimizing the chance of the same seed), requires (\u0026lt;code\u0026gt;sys/time.h\u0026lt;/code\u0026gt;):\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-class\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;timeval\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;t1\u0026lt;/span\u0026gt;;\u0026lt;/span\u0026gt;\ngettimeofday(\u0026amp;amp;t1, \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;NULL\u0026lt;/span\u0026gt;);\nsrand(t1.tv_usec * t1.tv_sec);\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Random numbers are actually pseudo random. A seed is set first, from which each call of \u0026lt;code\u0026gt;rand\u0026lt;/code\u0026gt; gets a random number, and modifies the internal state and this new state is used in the next \u0026lt;code\u0026gt;rand\u0026lt;/code\u0026gt; call to get another number. Because a certain formula is used to generate these \u0026quot;random numbers\u0026quot; therefore setting a certain value of seed after every call to \u0026lt;code\u0026gt;rand\u0026lt;/code\u0026gt; will return the same number from the call. For example \u0026lt;code\u0026gt;srand (1234); rand ();\u0026lt;/code\u0026gt; will return the same value. Initializing once the initial state with the seed value will generate enough random numbers as you do not set the internal state with \u0026lt;code\u0026gt;srand\u0026lt;/code\u0026gt;, thus making the numbers more probable to be random.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Generally we use the \u0026lt;code\u0026gt;time (NULL)\u0026lt;/code\u0026gt; returned seconds value when initializing the seed value. Say the \u0026lt;code\u0026gt;srand (time (NULL));\u0026lt;/code\u0026gt; is in a loop. Then loop can iterate more than once in one second, therefore the number of times the loop iterates inside the loop in a second \u0026lt;code\u0026gt;rand\u0026lt;/code\u0026gt; call in the loop will return the same \u0026quot;random number\u0026quot;, which is not desired. Initializing it once at program start will set the seed once, and each time \u0026lt;code\u0026gt;rand\u0026lt;/code\u0026gt; is called, a new number is generated and the internal state is modified, so the next call \u0026lt;code\u0026gt;rand\u0026lt;/code\u0026gt; returns a number which is random enough.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;For example this code from \u0026lt;a href=\u0026quot;http://linux.die.net/man/3/rand\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;http://linux.die.net/man/3/rand\u0026lt;/a\u0026gt;:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;static\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;unsigned\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;long\u0026lt;/span\u0026gt; next = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;;\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;/* RAND_MAX assumed to be 32767 */\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;myrand\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt;)\u0026lt;/span\u0026gt; {\n    next = next * \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1103515245\u0026lt;/span\u0026gt; + \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;12345\u0026lt;/span\u0026gt;;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt;((\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;unsigned\u0026lt;/span\u0026gt;)(next/\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;65536\u0026lt;/span\u0026gt;) % \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;32768\u0026lt;/span\u0026gt;);\n}\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;mysrand\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;unsigned\u0026lt;/span\u0026gt; seed)\u0026lt;/span\u0026gt; {\n    next = seed;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;The internal state \u0026lt;code\u0026gt;next\u0026lt;/code\u0026gt; is declared as global. Each \u0026lt;code\u0026gt;myrand\u0026lt;/code\u0026gt; call will modify the internal state and update it, and return a random number. Every call of \u0026lt;code\u0026gt;myrand\u0026lt;/code\u0026gt; will have a different \u0026lt;code\u0026gt;next\u0026lt;/code\u0026gt; value therefore the the method will return the different numbers every call. \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Look at the \u0026lt;code\u0026gt;mysrand\u0026lt;/code\u0026gt; implementation; it simply sets the seed value you pass to \u0026lt;code\u0026gt;next\u0026lt;/code\u0026gt;. Therefore if you set the \u0026lt;code\u0026gt;next\u0026lt;/code\u0026gt; value the same  everytime before calling \u0026lt;code\u0026gt;rand\u0026lt;/code\u0026gt; it will return the same random value, because of the identical formula applied on it, which is not desirable, as the function is made to be random.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;But depending on your needs you can set the seed to some certain value to generate the same \u0026quot;random sequence\u0026quot; each run, say for some benchmark or others.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Short answer: calling \u0026lt;code\u0026gt;srand()\u0026lt;/code\u0026gt; is \u0026lt;strong\u0026gt;not\u0026lt;/strong\u0026gt; like \u0026quot;rolling the dice\u0026quot; for the random number generator.  Nor is it like shuffling a deck of cards.  If anything, it\u0026apos;s more like just cutting a deck of cards.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Think of it like this.  \u0026lt;code\u0026gt;rand()\u0026lt;/code\u0026gt; deals from a big deck of cards, and every time you call it, all it does is pick the next card off the top of the deck, give you the value, and return that card to the bottom of the deck.  (Yes, that means the \u0026quot;random\u0026quot; sequence will repeat after a while.  It\u0026apos;s a \u0026lt;em\u0026gt;very\u0026lt;/em\u0026gt; big deck, though: typically 4,294,967,296 cards.)\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Furthermore, every time your program runs, a brand-new pack of cards is bought from the game shop, \u0026lt;em\u0026gt;and\u0026lt;/em\u0026gt; every brand-new pack of cards always has the same sequence.  So unless you do something special, every time your program runs, it will get exactly the same \u0026quot;random\u0026quot; numbers back from \u0026lt;code\u0026gt;rand()\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Now, you might say, \u0026quot;Okay, so how do I shuffle the deck?\u0026quot;  And the answer -- at least as far as \u0026lt;code\u0026gt;rand\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;srand\u0026lt;/code\u0026gt; are concerned -- is that there is no way of shuffling the deck.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;So what does \u0026lt;code\u0026gt;srand\u0026lt;/code\u0026gt; do?  Based on the analogy I\u0026apos;ve been building here, calling \u0026lt;code\u0026gt;srand(n)\u0026lt;/code\u0026gt; is basically like saying, \u0026quot;cut the deck \u0026lt;code\u0026gt;n\u0026lt;/code\u0026gt; cards from the top\u0026quot;.  But wait, one more thing: it\u0026apos;s actually \u0026lt;em\u0026gt;start with another brand-new deck and cut it \u0026lt;code\u0026gt;n\u0026lt;/code\u0026gt; cards from the top\u0026lt;/em\u0026gt;.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;So if you call \u0026lt;code\u0026gt;srand(n)\u0026lt;/code\u0026gt;, \u0026lt;code\u0026gt;rand()\u0026lt;/code\u0026gt;, \u0026lt;code\u0026gt;srand(n)\u0026lt;/code\u0026gt;, \u0026lt;code\u0026gt;rand()\u0026lt;/code\u0026gt;, ..., with the same \u0026lt;code\u0026gt;n\u0026lt;/code\u0026gt; every time, you won\u0026apos;t just get a not-very-random sequence, you\u0026apos;ll actually get the same number back from \u0026lt;code\u0026gt;rand()\u0026lt;/code\u0026gt; every time.  (Probably not the same number you handed to \u0026lt;code\u0026gt;srand\u0026lt;/code\u0026gt;, but the same number back from \u0026lt;code\u0026gt;rand\u0026lt;/code\u0026gt; over and over.)\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;So the best you can do is to cut the deck \u0026lt;em\u0026gt;once\u0026lt;/em\u0026gt;, that is, call \u0026lt;code\u0026gt;srand()\u0026lt;/code\u0026gt; once, at the beginning of your program, with an \u0026lt;code\u0026gt;n\u0026lt;/code\u0026gt; that\u0026apos;s reasonably random, so that you\u0026apos;ll start at a different random place in the big deck each time your program runs.  With \u0026lt;code\u0026gt;rand()\u0026lt;/code\u0026gt;, that really is the best you can do.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;[P.S. Yes, I know, in real life, when you buy a brand-new deck of cards it\u0026apos;s typically in order, not in random order.  For the analogy here to work, I\u0026apos;m imagining that each deck you buy from the game shop is in a seemingly random order, but the exact same seemingly-random order as every other deck of cards you buy from that same shop.  Sort of like the identically shuffled decks of cards they use in bridge tournaments.]\u0026lt;/p\u0026gt;\n\u0026lt;hr\u0026gt;\n\u0026lt;p\u0026gt;Addendum: For a very cute demonstration of the fact that for a given PRNG algorithm and a given seed value, you always get the same sequence, see \u0026lt;a href=\u0026quot;https://stackoverflow.com/questions/15182496/why-does-this-code-using-random-strings-print-hello-world\u0026quot;\u0026gt;this question\u0026lt;/a\u0026gt; (which is about Java, not C, but anyway).\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;The reason is that \u0026lt;code\u0026gt;srand()\u0026lt;/code\u0026gt; sets the initial state of the random generator, and all the values that generator produces are only \u0026quot;random enough\u0026quot; if you don\u0026apos;t touch the state yourself in between.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;For example you could do:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;getRandomValue\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt;\n{\n    srand(time(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;));\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; rand();\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;and then if you call that function repeatedly so that \u0026lt;code\u0026gt;time()\u0026lt;/code\u0026gt; returns the same values in adjacent calls you just get the same value generated - that\u0026apos;s by design.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;A simpler solution for using \u0026lt;code\u0026gt;srand()\u0026lt;/code\u0026gt; for generating different seeds for application instances run at the same second is as seen.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;srand(time(\u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;NULL\u0026lt;/span\u0026gt;)-getpid());\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;This method makes your seed very close to random as there is no way to guess at what time your thread started and the pid will be different also.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;srand seeds the pseudorandom number generator.  If you call it more than once, you will reseed the RNG.  And if you call it with the same argument, it will restart the same sequence.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;To prove it, if you do something simple like this, you will see the same number printed 100 times:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;stdlib.h\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;stdio.h\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;main\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt; {\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; i = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;; i != \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;100\u0026lt;/span\u0026gt;; ++i) {\n        srand(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;);\n        \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;printf\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;%d\\n\u0026quot;\u0026lt;/span\u0026gt;, rand());\n    }\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;ol\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;It seems that every time \u0026lt;code\u0026gt;rand()\u0026lt;/code\u0026gt; runs, it will set a new seed for the next \u0026lt;code\u0026gt;rand()\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;If \u0026lt;code\u0026gt;srand()\u0026lt;/code\u0026gt; runs multiple times, the problem is if the two running happen in one second (the \u0026lt;code\u0026gt;time(NULL)\u0026lt;/code\u0026gt; does not change), the next \u0026lt;code\u0026gt;rand()\u0026lt;/code\u0026gt; will be the same as the \u0026lt;code\u0026gt;rand()\u0026lt;/code\u0026gt; right after the previous \u0026lt;code\u0026gt;srand()\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;/ol\u0026gt;\n    "],"id":376,"title":"srand() — why call it only once?","content":"\n                \n\u0026lt;p\u0026gt;This question is about a comment in this question\n\u0026lt;a href=\u0026quot;https://stackoverflow.com/questions/322938/recommended-way-to-initialize-srand\u0026quot;\u0026gt;Recommended way to initialize srand?\u0026lt;/a\u0026gt; The first comment says that \u0026lt;code\u0026gt;srand()\u0026lt;/code\u0026gt; should be called only ONCE in an application. Why is it so?\u0026lt;/p\u0026gt;\n    ","slug":"srand()-why-call-it-only-once-1657387794760","postType":"QUESTION","createdAt":"2022-07-09T17:29:54.000Z","updatedAt":"2022-07-09T17:29:54.000Z","tags":[{"id":2062,"name":"srand","slug":"srand","createdAt":"2022-07-09T17:29:54.000Z","updatedAt":"2022-07-09T17:29:54.000Z","Questions_Tags":{"questionId":376,"tagId":2062}}],"relatedQuestions":[{"title":"srand() — why call it only once?","slug":"srand()-why-call-it-only-once-1657387794760","tags":[{"name":"srand","Questions_Tags":{"questionId":376,"tagId":2062}}]}]},"randomQuestions":[{"title":"Can a local variable's memory be accessed outside its scope?","slug":"can-a-local-variable's-memory-be-accessed-outside-its-scope-1657384460386"},{"title":"How to generate all permutations of a list","slug":"how-to-generate-all-permutations-of-a-list-1657388537371"},{"title":"Strange result when removing item from a list while iterating over it [duplicate]","slug":"strange-result-when-removing-item-from-a-list-while-iterating-over-it-duplicate-1657387735759"},{"title":"What is a debugger and how can it help me diagnose problems?","slug":"what-is-a-debugger-and-how-can-it-help-me-diagnose-problems-1657384472469"},{"title":"Why use getters and setters/accessors?","slug":"why-use-getters-and-settersaccessors-1657387343971"},{"title":"Converting string into datetime","slug":"converting-string-into-datetime-1657387717295"},{"title":"How do I vertically center text with CSS? [duplicate]","slug":"how-do-i-vertically-center-text-with-css-duplicate-1657387645821"},{"title":"What is The Rule of Three?","slug":"what-is-the-rule-of-three-1657384390295"},{"title":"Fetch the rows which have the Max value for a column for each distinct value of another column","slug":"fetch-the-rows-which-have-the-max-value-for-a-column-for-each-distinct-value-of-another-column-1657387423925"},{"title":"What does enctype='multipart/form-data' mean?","slug":"what-does-enctype'multipartform-data'-mean-1657388229352"},{"title":"How do I make Git forget about a file that was tracked, but is now in .gitignore?","slug":"how-do-i-make-git-forget-about-a-file-that-was-tracked-but-is-now-in-.gitignore-1657387328843"},{"title":"How do I use extern to share variables between source files?","slug":"how-do-i-use-extern-to-share-variables-between-source-files-1657387453605"},{"title":"What is the JavaScript version of sleep()?","slug":"what-is-the-javascript-version-of-sleep()-1657387391406"},{"title":"Pandas Merging 101","slug":"pandas-merging-101-1657384447080"},{"title":"Is there any way to kill a Thread?","slug":"is-there-any-way-to-kill-a-thread-1657387859831"},{"title":"How to use Regular Expressions (Regex) in Microsoft Excel both in-cell and loops","slug":"how-to-use-regular-expressions-(regex)-in-microsoft-excel-both-in-cell-and-loops-1657387487287"},{"title":"What's the simplest way to print a Java array?","slug":"what's-the-simplest-way-to-print-a-java-array-1657384702397"},{"title":"Find object by id in an array of JavaScript objects","slug":"find-object-by-id-in-an-array-of-javascript-objects-1657387572087"},{"title":"How to remove the space between inline/inline-block elements?","slug":"how-to-remove-the-space-between-inlineinline-block-elements-1657384532273"},{"title":"How to remove items from a list while iterating?","slug":"how-to-remove-items-from-a-list-while-iterating-1657384496375"}]},"__N_SSG":true},"page":"/questions/[slug]","query":{"slug":"srand()-why-call-it-only-once-1657387794760"},"buildId":"eGqQHYKGZKE-nXShFn8wX","isFallback":false,"gsp":true,"locale":"en","locales":["en"],"defaultLocale":"en","scriptLoader":[]}</script></body></html>