<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><meta name="twitter:card" content="summary_large_image"/><meta name="twitter:site" content="@solutionschecker.com"/><meta name="twitter:creator" content="@solutionschecker.com"/><meta property="og:url" content="https://solutionschecker.com"/><meta property="og:type" content="website"/><meta property="og:image" content="https://solutionschecker.com/solutions-checker-banner.png"/><meta property="og:image:alt" content="Find the solution to any question. We focus on finding the fastest possible solution for users. Main topics like coding, learning. - solutionschecker.com"/><link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png"/><link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png"/><link rel="manifest" href="/site.webmanifest"/><script type="application/ld+json">{"@context":"https://schema.org","@type":"Organization","logo":"/logo.svg","url":"https://solutionschecker.com"}</script><link name="keywords" content="solutions checker, solution checker, how to, solution for, check for solution, resolve question, what is, what solution for, find solution"/><script type="application/ld+json">{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"item":{"@id":"https://solutionschecker.com","name":"Home"}},{"@type":"ListItem","position":2,"item":{"@id":"https://solutionschecker.com/questions","name":"Questions"}},{"@type":"ListItem","position":3,"item":{"@id":"https://solutionschecker.com/questions/c++-singleton-design-pattern-1657387830040","name":"Questions"}}]}</script><title>C++ Singleton design pattern | Solution Checker</title><meta name="robots" content="index,follow"/><meta name="description" content="Recently I&#x27;ve bumped into a realization/implementation of the Singleton design pattern for C++. It has looked like this (I have adopted it from the real-life example):
// a lot of methods are omitted here
class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
};

From this declaration, I can deduce that the instance field is initiated on the heap. That means there is a memory allocation. What is completely unclear for me is when exactly the memory is going to be deallocated? Or is there a bug and memory leak? It seems like there is a problem with the implementation.
My main question is, how do I implement it in the right way?
    "/><meta property="og:title" content="C++ Singleton design pattern | Solution Checker"/><meta property="og:description" content="Recently I&#x27;ve bumped into a realization/implementation of the Singleton design pattern for C++. It has looked like this (I have adopted it from the real-life example):
// a lot of methods are omitted here
class Singleton
{
   public:
       static Singleton* getInstance( );
       ~Singleton( );
   private:
       Singleton( );
       static Singleton* instance;
};

From this declaration, I can deduce that the instance field is initiated on the heap. That means there is a memory allocation. What is completely unclear for me is when exactly the memory is going to be deallocated? Or is there a bug and memory leak? It seems like there is a problem with the implementation.
My main question is, how do I implement it in the right way?
    "/><script type="application/ld+json">{"@context":"https://schema.org","@type":"QAPage","mainEntity":{"name":"C++ Singleton design pattern","text":"Recently I&apos;ve bumped into a realization/implementation of the Singleton design pattern for C++. It has looked like this (I have adopted it from the real-life example):\n// a lot of methods are omitted here\nclass Singleton\n{\n   public:\n       static Singleton* getInstance( );\n       ~Singleton( );\n   private:\n       Singleton( );\n       static Singleton* instance;\n};\n\nFrom this declaration, I can deduce that the instance field is initiated on the heap. That means there is a memory allocation. What is completely unclear for me is when exactly the memory is going to be deallocated? Or is there a bug and memory leak? It seems like there is a problem with the implementation.\nMy main question is, how do I implement it in the right way?\n    ","answerCount":24,"upVoteCount":500,"suggestedAnswer":[{"text":"In 2008 I provided a C++98 implementation of the Singleton design pattern that is lazy-evaluated, guaranteed-destruction, not-technically-thread-safe:\nCan any one provide me a sample of Singleton in c++?\nHere is an updated C++11 implementation of the Singleton design pattern that is lazy-evaluated, correctly-destroyed, and thread-safe.\nclass S\n{\n    public:\n        static S&amp; getInstance()\n        {\n            static S    instance; // Guaranteed to be destroyed.\n                                  // Instantiated on first use.\n            return instance;\n        }\n    private:\n        S() {}                    // Constructor? (the {} brackets) are needed here.\n\n        // C++ 03\n        // ========\n        // Don&apos;t forget to declare these two. You want to make sure they\n        // are inaccessible(especially from outside), otherwise, you may accidentally get copies of\n        // your singleton appearing.\n        S(S const&amp;);              // Don&apos;t Implement\n        void operator=(S const&amp;); // Don&apos;t implement\n\n        // C++ 11\n        // =======\n        // We can use the better technique of deleting the methods\n        // we don&apos;t want.\n    public:\n        S(S const&amp;)               = delete;\n        void operator=(S const&amp;)  = delete;\n\n        // Note: Scott Meyers mentions in his Effective Modern\n        //       C++ book, that deleted functions should generally\n        //       be public as it results in better error messages\n        //       due to the compilers behavior to check accessibility\n        //       before deleted status\n};\n\nSee this article about when to use a singleton: (not often)\nSingleton: How should it be used\nSee this two article about initialization order and how to cope:\nStatic variables initialisation order\nFinding C++ static initialization order problems\nSee this article describing lifetimes:\nWhat is the lifetime of a static variable in a C++ function?\nSee this article that discusses some threading implications to singletons:\nSingleton instance declared as static variable of GetInstance method, is it thread-safe?\nSee this article that explains why double checked locking will not work on C++:\nWhat are all the common undefined behaviours that a C++ programmer should know about?\nDr Dobbs: C++ and The Perils of Double-Checked Locking: Part I\n    ","url":"/questions/[slug]#solution1","@type":"Answer","upvoteCount":0},{"text":"You could avoid memory allocation. There are many variants, all having problems in case of multithreading environment.\n\nI prefer this kind of implementation (actually, it is not correctly said I prefer, because I avoid singletons as much as possible):\n\nclass Singleton\n{\nprivate:\n   Singleton();\n\npublic:\n   static Singleton&amp; instance()\n   {\n      static Singleton INSTANCE;\n      return INSTANCE;\n   }\n};\n\n\nIt has no dynamic memory allocation.\n    ","url":"/questions/[slug]#solution2","@type":"Answer","upvoteCount":0},{"text":"Being a Singleton, you usually do not want it to be destructed.\n\nIt will get torn down and deallocated when the program terminates, which is the normal, desired behavior for a singleton.  If you want to be able to explicitly clean it, it&apos;s fairly easy to add a static method to the class that allows you to restore it to a clean state, and have it reallocate next time it&apos;s used, but that&apos;s outside of the scope of a &quot;classic&quot; singleton.\n    ","url":"/questions/[slug]#solution3","@type":"Answer","upvoteCount":0},{"text":"@Loki Astari&apos;s answer is excellent. \n\nHowever there are times with multiple static objects where you need to be able to guarantee that the singleton will not be destroyed until all your static objects that use the singleton no longer need it.\n\nIn this case std::shared_ptr can be used to keep the singleton alive for all users even when the static destructors are being called at the end of the program:\n\nclass Singleton\n{\npublic:\n    Singleton(Singleton const&amp;) = delete;\n    Singleton&amp; operator=(Singleton const&amp;) = delete;\n\n    static std::shared_ptr&lt;Singleton&gt; instance()\n    {\n        static std::shared_ptr&lt;Singleton&gt; s{new Singleton};\n        return s;\n    }\n\nprivate:\n    Singleton() {}\n};\n\n    ","url":"/questions/[slug]#solution4","@type":"Answer","upvoteCount":0},{"text":"Another non-allocating alternative: create a singleton, say of class C, as you need it:\n\nsingleton&lt;C&gt;()\n\n\nusing\n\ntemplate &lt;class X&gt;\nX&amp; singleton()\n{\n    static X x;\n    return x;\n}\n\n\nNeither this nor Cătălin&apos;s answer is automatically thread-safe in current C++, but will be in C++0x.\n    ","url":"/questions/[slug]#solution5","@type":"Answer","upvoteCount":0},{"text":"I did not find a CRTP implementation among the answers, so here it is:\n\ntemplate&lt;typename HeirT&gt;\nclass Singleton\n{\npublic:\n    Singleton() = delete;\n\n    Singleton(const Singleton &amp;) = delete;\n\n    Singleton &amp;operator=(const Singleton &amp;) = delete;\n\n    static HeirT &amp;instance()\n    {\n        static HeirT instance;\n        return instance;\n    }\n};\n\n\nTo use just inherit your class from this, like: class Test : public Singleton&lt;Test&gt;\n    ","url":"/questions/[slug]#solution6","@type":"Answer","upvoteCount":0},{"text":"We went over this topic recently in my EECS class. If you want to look at the lecture notes in detail, visit http://umich.edu/~eecs381/lecture/IdiomsDesPattsCreational.pdf. These notes (and quotations I give in this answer) were created by my Professor, David Kieras.\nThere are two ways that I know to create a Singleton class correctly.\nFirst Way:\nImplement it similar to the way you have it in your example. As for destruction, &quot;Singletons usually endure for the length of the program run; most OSs will recover memory and most other resources when a program terminates, so there is an argument for not worrying about this.&quot;\nHowever, it is good practice to clean up at program termination. Therefore, you can do this with an auxiliary static SingletonDestructor class and declare that as a friend in your Singleton.\nclass Singleton {\npublic:\n  static Singleton* get_instance();\n  \n  // disable copy/move -- this is a Singleton\n  Singleton(const Singleton&amp;) = delete;\n  Singleton(Singleton&amp;&amp;) = delete;\n  Singleton&amp; operator=(const Singleton&amp;) = delete;\n  Singleton&amp; operator=(Singleton&amp;&amp;) = delete;\n\n  friend class Singleton_destroyer;\n\nprivate:\n  Singleton();  // no one else can create one\n  ~Singleton(); // prevent accidental deletion\n\n  static Singleton* ptr;\n};\n\n// auxiliary static object for destroying the memory of Singleton\nclass Singleton_destroyer {\npublic:\n  ~Singleton_destroyer { delete Singleton::ptr; }\n};\n\n// somewhere in code (Singleton.cpp is probably the best place) \n// create a global static Singleton_destroyer object\nSingleton_destoyer the_destroyer;\n\nThe Singleton_destroyer will be created on program startup, and &quot;when program terminates, all global/static objects are destroyed by the runtime library shutdown code (inserted by the linker), so the_destroyer will be destroyed; its destructor will delete the Singleton, running its destructor.&quot;\nSecond Way\nThis is called the Meyers Singleton, created by C++ wizard Scott Meyers. Simply define get_instance() differently. Now you can also get rid of the pointer member variable.\n// public member function\nstatic Singleton&amp; Singleton::get_instance()\n{\n  static Singleton s;\n  return s;\n}\n\nThis is neat because the value returned is by reference and you can use . syntax instead of -&gt; to access member variables.\n&quot;Compiler automatically builds code that creates &apos;s&apos; first time through the\ndeclaration, not thereafter, and then deletes the static object at program\ntermination.&quot;\nNote also that with the Meyers Singleton you &quot;can get into very difficult situation if objects rely on each other at the time of\ntermination - when does the Singleton disappear relative to other objects? But for simple applications, this works fine.&quot;\n    ","url":"/questions/[slug]#solution7","@type":"Answer","upvoteCount":0},{"text":"Here is an easy implementation.\n\n#include &lt;Windows.h&gt;\n#include &lt;iostream&gt;\n\nusing namespace std;\n\n\nclass SingletonClass {\n\npublic:\n    static SingletonClass* getInstance() {\n\n    return (!m_instanceSingleton) ?\n        m_instanceSingleton = new SingletonClass : \n        m_instanceSingleton;\n    }\n\nprivate:\n    // private constructor and destructor\n    SingletonClass() { cout &lt;&lt; &quot;SingletonClass instance created!\\n&quot;; }\n    ~SingletonClass() {}\n\n    // private copy constructor and assignment operator\n    SingletonClass(const SingletonClass&amp;);\n    SingletonClass&amp; operator=(const SingletonClass&amp;);\n\n    static SingletonClass *m_instanceSingleton;\n};\n\nSingletonClass* SingletonClass::m_instanceSingleton = nullptr;\n\n\n\nint main(int argc, const char * argv[]) {\n\n    SingletonClass *singleton;\n    singleton = singleton-&gt;getInstance();\n    cout &lt;&lt; singleton &lt;&lt; endl;\n\n    // Another object gets the reference of the first object!\n    SingletonClass *anotherSingleton;\n    anotherSingleton = anotherSingleton-&gt;getInstance();\n    cout &lt;&lt; anotherSingleton &lt;&lt; endl;\n\n    Sleep(5000);\n\n    return 0;\n}\n\n\nOnly one object created and this object reference is returned each and every time afterwords.\n\nSingletonClass instance created!\n00915CB8\n00915CB8\n\n\nHere 00915CB8 is the memory location of singleton Object, same for the duration of the program but (normally!) different each time the program is run.\n\nN.B. This is not a thread safe one.You have to ensure thread safety.\n    ","url":"/questions/[slug]#solution8","@type":"Answer","upvoteCount":0},{"text":"The solution in the accepted answer has a significant drawback - the destructor for the singleton is called after the control leaves the main() function. There may be problems really, when some dependent objects are allocated inside main.\n\nI met this problem, when trying to introduce a Singleton in the Qt application. I decided, that all my setup dialogs must be Singletons, and adopted the pattern above. Unfortunately, Qt&apos;s main class QApplication was allocated on stack in the main function, and Qt forbids creating/destroying dialogs when no application object is available.\n\nThat is why I prefer heap-allocated singletons. I provide an explicit init() and term() methods for all the singletons and call them inside main. Thus I have a full control over the order of singletons creation/destruction, and also I guarantee that singletons will be created, no matter whether someone called getInstance() or not.\n    ","url":"/questions/[slug]#solution9","@type":"Answer","upvoteCount":0},{"text":"Has anyone mentioned std::call_once and std::once_flag?\nMost other approaches - including double checked locking - are broken.\n\nOne major problem in singleton pattern implementation is safe initialization. The only safe way is to guard the initialization sequence with synchronizing barriers. But those barriers themselves need to be safely initiated. std::once_flag is the mechanism to get guaranteed safe initialization.\n    ","url":"/questions/[slug]#solution10","@type":"Answer","upvoteCount":0},{"text":"If you want to allocate the object in heap, why don&apos;t use a unique pointer. Memory will also be deallocated since we are using a unique pointer.\n\nclass S\n{\n    public:\n        static S&amp; getInstance()\n        {\n            if( m_s.get() == 0 )\n            {\n              m_s.reset( new S() );\n            }\n            return *m_s;\n        }\n\n    private:\n        static std::unique_ptr&lt;S&gt; m_s;\n\n        S();\n        S(S const&amp;);            // Don&apos;t Implement\n        void operator=(S const&amp;); // Don&apos;t implement\n};\n\nstd::unique_ptr&lt;S&gt; S::m_s(0);\n\n    ","url":"/questions/[slug]#solution11","@type":"Answer","upvoteCount":0},{"text":"C++11 Thread safe implementation:\n #include &lt;iostream&gt;\n #include &lt;thread&gt;\n\n\n class Singleton\n {\n     private:\n         static Singleton * _instance;\n         static std::mutex mutex_;\n\n     protected:\n         Singleton(const std::string value): value_(value)\n         {\n         }\n         ~Singleton() {}\n         std::string value_;\n\n     public:\n         /**\n          * Singletons should not be cloneable.\n          */\n         Singleton(Singleton &amp;other) = delete;\n         /**\n          * Singletons should not be assignable.\n          */\n         void operator=(const Singleton &amp;) = delete;\n\n         //static Singleton *GetInstance(const std::string&amp; value);\n         static Singleton *GetInstance(const std::string&amp; value)\n         {\n             if (_instance == nullptr)\n             {\n                 std::lock_guard&lt;std::mutex&gt; lock(mutex_);\n                 if (_instance == nullptr)\n                 {\n                     _instance = new Singleton(value);\n                 }\n             }\n             return _instance;\n         }\n\n         std::string value() const{\n             return value_;\n         }\n };\n\n /**\n  * Static methods should be defined outside the class.\n  */\n Singleton* Singleton::_instance = nullptr;\n std::mutex Singleton::mutex_;\n\n\n void ThreadFoo(){\n     std::this_thread::sleep_for(std::chrono::milliseconds(10));\n     Singleton* singleton = Singleton::GetInstance(&quot;FOO&quot;);\n     std::cout &lt;&lt; singleton-&gt;value() &lt;&lt; &quot;\\n&quot;;\n }\n\n void ThreadBar(){\n     std::this_thread::sleep_for(std::chrono::milliseconds(1000));\n     Singleton* singleton = Singleton::GetInstance(&quot;BAR&quot;);\n     std::cout &lt;&lt; singleton-&gt;value() &lt;&lt; &quot;\\n&quot;;\n }\n\n int main()\n {\n     std::cout &lt;&lt;&quot;If you see the same value, then singleton was reused (yay!\\n&quot; &lt;&lt;\n                 &quot;If you see different values, then 2 singletons were created (booo!!)\\n\\n&quot; &lt;&lt;\n                 &quot;RESULT:\\n&quot;;\n     std::thread t1(ThreadFoo);\n     std::thread t2(ThreadBar);\n     t1.join();\n     t2.join();\n     std::cout &lt;&lt; &quot;Complete!&quot; &lt;&lt; std::endl;\n\n     return 0;\n }\n\n    ","url":"/questions/[slug]#solution12","@type":"Answer","upvoteCount":0},{"text":"It is indeed probably allocated from the heap, but without the sources there is no way of knowing.\n\nThe typical implementation (taken from some code I have in emacs already) would be:\n\nSingleton * Singleton::getInstance() {\n    if (!instance) {\n        instance = new Singleton();\n    };\n    return instance;\n};\n\n\n...and rely on the program going out of scope to clean up afterwards.\n\nIf you work on a platform where cleanup must be done manually, I&apos;d probably add a manual cleanup routine.\n\nAnother issue with doing it this way is that it isn&apos;t thread-safe. In a multithreaded environment, two threads could get through the &quot;if&quot; before either has a chance to allocate the new instance (so both would). This still isn&apos;t too big of a deal if you are relying on program termination to clean up anyway.\n    ","url":"/questions/[slug]#solution13","@type":"Answer","upvoteCount":0},{"text":"In addition to the other discussion here, it may be worth noting that you can have global-ness, without limiting usage to one instance. For example, consider the case of reference counting something...\n\nstruct Store{\n   std::array&lt;Something, 1024&gt; data;\n   size_t get(size_t idx){ /* ... */ }\n   void incr_ref(size_t idx){ /* ... */}\n   void decr_ref(size_t idx){ /* ... */}\n};\n\ntemplate&lt;Store* store_p&gt;\nstruct ItemRef{\n   size_t idx;\n   auto get(){ return store_p-&gt;get(idx); };\n   ItemRef() { store_p-&gt;incr_ref(idx); };\n   ~ItemRef() { store_p-&gt;decr_ref(idx); };\n};\n\nStore store1_g;\nStore store2_g; // we don&apos;t restrict the number of global Store instances\n\n\nNow somewhere inside a function (such as main) you can do:\n\nauto ref1_a = ItemRef&lt;&amp;store1_g&gt;(101);\nauto ref2_a = ItemRef&lt;&amp;store2_g&gt;(201); \n\n\nThe refs don&apos;t need to store a pointer back to their respective Store because that information is supplied at compile-time. You also don&apos;t have to worry about the Store&apos;s lifetime because the compiler requires that it is global.  If there is indeed only one instance of Store then there&apos;s no overhead in this approach; with more than one instance it&apos;s up to the compiler to be clever about code generation. If necessary, the ItemRef class can even be made a friend of Store (you can have templated friends!).\n\nIf Store itself is a templated class then things get messier, but it is still possible to use this method, perhaps by implementing a helper class with the following signature:\n\ntemplate &lt;typename Store_t, Store_t* store_p&gt;\nstruct StoreWrapper{ /* stuff to access store_p, e.g. methods returning \n                       instances of ItemRef&lt;Store_t, store_p&gt;. */ };\n\n\nThe user can now create a StoreWrapper type (and global instance) for each global Store instance, and always access the stores via their wrapper instance (thus forgetting about the gory details of the template parameters needed for using Store).\n    ","url":"/questions/[slug]#solution14","@type":"Answer","upvoteCount":0},{"text":"Here is a mockable singleton using CRTP. It relies on a little helper to enforce a single object at any one time (at most). To enforce a single object over program execution, remove the reset (which we find useful for tests).\nA ConcreteSinleton can be implemented like this:\nclass ConcreteSingleton : public Singleton&lt;ConcreteSingleton&gt;\n{\npublic:\n  ConcreteSingleton(const Singleton&lt;ConcreteSingleton&gt;::PrivatePass&amp;)\n      : Singleton&lt;StandardPaths&gt;::Singleton{pass}\n  {}\n  \n  // ... concrete interface\n  int f() const {return 42;}\n\n};\n\nAnd then used with\nConcreteSingleton::instance().f();\n\n    ","url":"/questions/[slug]#solution15","@type":"Answer","upvoteCount":0},{"text":"This is about object life-time management. Suppose you have more than singletons in your software. And they depend on Logger singleton. During application destruction, suppose another singleton object uses Logger to log its destruction steps. You have to guarantee that Logger should be cleaned up last. Therefore, please also check out this paper:\nhttp://www.cs.wustl.edu/~schmidt/PDF/ObjMan.pdf \n    ","url":"/questions/[slug]#solution16","@type":"Answer","upvoteCount":0},{"text":"My implementation is similar to Galik&apos;s. The difference is my implementation allows the shared pointers to clean up allocated memory, as opposed to holding onto the memory until the application is exited and the static pointers are cleaned up.\n\n#pragma once\n\n#include &lt;memory&gt;\n\ntemplate&lt;typename T&gt;\nclass Singleton\n{\nprivate:\n  static std::weak_ptr&lt;T&gt; _singleton;\npublic:\n  static std::shared_ptr&lt;T&gt; singleton()\n  {\n    std::shared_ptr&lt;T&gt; singleton = _singleton.lock();\n    if (!singleton) \n    {\n      singleton.reset(new T());\n      _singleton = singleton;\n    }\n\n    return singleton;\n  }\n};\n\ntemplate&lt;typename T&gt;\nstd::weak_ptr&lt;T&gt; Singleton&lt;T&gt;::_singleton;\n\n    ","url":"/questions/[slug]#solution17","@type":"Answer","upvoteCount":0},{"text":"Your code is correct, except that you didn&apos;t declare the instance pointer outside the class. The inside class declarations of static variables are not considered declarations in C++, however this is allowed in other languages like C# or Java etc.\n\nclass Singleton\n{\n   public:\n       static Singleton* getInstance( );\n   private:\n       Singleton( );\n       static Singleton* instance;\n};\nSingleton* Singleton::instance; //we need to declare outside because static variables are global\n\n\nYou must know that Singleton instance doesn&apos;t need to be manually deleted by us. We need a single object of it throughout the whole program, so at the end of program execution, it will be automatically deallocated.\n    ","url":"/questions/[slug]#solution18","@type":"Answer","upvoteCount":0},{"text":"Here is my view on how to do proper singletons (and other non-trivial static objects): https://github.com/alex4747-pub/proper_singleton\nSummary:\n\nUse static initialization list to instantiate singletons at the right time: after entering main and before enabling multi-threading\nAdd minor improvements to make it unit-test friendly.\n\n    ","url":"/questions/[slug]#solution19","@type":"Answer","upvoteCount":0},{"text":"I would like to show here another example of a singleton in C++. It makes sense to use template programming. Besides, it makes sense to derive your singleton class from a not copyable and not movabe classes. Here how it looks like in the code:\n#include&lt;iostream&gt;\n#include&lt;string&gt;\n\nclass DoNotCopy\n{\nprotected:\n    DoNotCopy(void) = default;\n    DoNotCopy(const DoNotCopy&amp;) = delete;\n    DoNotCopy&amp; operator=(const DoNotCopy&amp;) = delete;\n};\n\nclass DoNotMove\n{\nprotected:\n    DoNotMove(void) = default;\n    DoNotMove(DoNotMove&amp;&amp;) = delete;\n    DoNotMove&amp; operator=(DoNotMove&amp;&amp;) = delete;\n};\n\nclass DoNotCopyMove : public DoNotCopy,\n    public DoNotMove\n{\nprotected:\n    DoNotCopyMove(void) = default;\n};\n\ntemplate&lt;class T&gt;\nclass Singleton : public DoNotCopyMove\n{\npublic:\n    static T&amp; Instance(void)\n    {\n        static T instance;\n        return instance;\n    }\n\nprotected:\n    Singleton(void) = default;\n};\n\nclass Logger final: public Singleton&lt;Logger&gt;\n{\npublic:\n    void log(const std::string&amp; str) { std::cout &lt;&lt; str &lt;&lt; std::endl; }\n};\n\n\n\nint main()\n{\n    Logger::Instance().log(&quot;xx&quot;);\n}\n\nThe splitting into NotCopyable and NotMovable clases allows you to define your singleton more specific (sometimes you want to move your single instance).\n    ","url":"/questions/[slug]#solution20","@type":"Answer","upvoteCount":0},{"text":"It restrict instantiation of a class to one object. This is useful when exactly one object is needed to coordinate actions across the system\nclass Singleton {\nprivate:\n    int data;\n    static Singleton* instance;\n    Singleton();\npublic:\n    static Singleton* getInstance();\n};\nSingleton* Singleton::instance = 0;\nSingleton::Singleton()\n{\n    this-&gt;data = 0;\n    cout &lt;&lt; &quot;constructor called..&quot; &lt;&lt; endl;\n}\n\n \n\nSingleton* Singleton::getInstance() {\n    if (!instance) {\n        instance = new Singleton();\n        return instance;\n    }\n}\nint main() {\n    Singleton *s = s-&gt;getInstance();\n    Singleton *s1 =s1-&gt;getInstance();\n    }\n\n    ","url":"/questions/[slug]#solution21","@type":"Answer","upvoteCount":0},{"text":"The paper that was linked to above describes the shortcoming of double checked locking is that the compiler may allocate the memory for the object and set a pointer to the address of the allocated memory, before the object&apos;s constructor has been called. It is quite easy in c++ however to use allocaters to allocate the memory manually, and then use a construct call to initialize the memory. Using this appraoch, the double-checked locking works just fine.\n    ","url":"/questions/[slug]#solution22","@type":"Answer","upvoteCount":0},{"text":"Simple singleton class, This must be your header class file\n\n#ifndef SC_SINGLETON_CLASS_H\n#define SC_SINGLETON_CLASS_H\n\nclass SingletonClass\n{\n    public:\n        static SingletonClass* Instance()\n        {\n           static SingletonClass* instance = new SingletonClass();\n           return instance;\n        }\n\n        void Relocate(int X, int Y, int Z);\n\n    private:\n        SingletonClass();\n        ~SingletonClass();\n};\n\n#define sSingletonClass SingletonClass::Instance()\n\n#endif\n\n\nAccess your singleton like this:\n\nsSingletonClass-&gt;Relocate(1, 2, 5);\n\n    ","url":"/questions/[slug]#solution23","@type":"Answer","upvoteCount":0},{"text":"#define INS(c) private:void operator=(c const&amp;){};public:static c&amp; I(){static c _instance;return _instance;}\n\n\nExample:\n\n   class CCtrl\n    {\n    private:\n        CCtrl(void);\n        virtual ~CCtrl(void);\n\n    public:\n        INS(CCtrl);\n\n    ","url":"/questions/[slug]#solution24","@type":"Answer","upvoteCount":0}],"@type":"Question"}}</script><meta name="next-head-count" content="22"/><link rel="preload" href="/_next/static/css/4f7b2847abfe82c6.css" as="style"/><link rel="stylesheet" href="/_next/static/css/4f7b2847abfe82c6.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-0d1b80a048d4787e.js"></script><script src="/_next/static/chunks/webpack-42cdea76c8170223.js" defer=""></script><script src="/_next/static/chunks/framework-4556c45dd113b893.js" defer=""></script><script src="/_next/static/chunks/main-ccfab947c79712f4.js" defer=""></script><script src="/_next/static/chunks/pages/_app-c0d2dcb5e85faf18.js" defer=""></script><script src="/_next/static/chunks/294-106ef8570fa99deb.js" defer=""></script><script src="/_next/static/chunks/490-7f0418bb4354ac73.js" defer=""></script><script src="/_next/static/chunks/pages/questions/%5Bslug%5D-50e201fdaa1e0fd1.js" defer=""></script><script src="/_next/static/eGqQHYKGZKE-nXShFn8wX/_buildManifest.js" defer=""></script><script src="/_next/static/eGqQHYKGZKE-nXShFn8wX/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="wrapper"><header><nav class="bg-white border-gray-200 px-4 lg:px-6 py-2.5 dark:bg-gray-800"><div class="flex flex-wrap justify-between items-center mx-auto max-w-screen-xl"><a class="flex items-center" href="/"><img src="/logo-second.png" class="mr-3 h-6 sm:h-9" alt="Solution Checker Logo"/><h1 class="self-center text-xl font-semibold whitespace-nowrap dark:text-white">Solution Checker</h1></a><div class="flex items-center lg:order-2"><button data-collapse-toggle="mobile-menu-2" type="button" class="inline-flex items-center p-2 ml-1 text-sm text-gray-500 rounded-lg lg:hidden hover:bg-gray-100 focus:outline-none focus:ring-2 focus:ring-gray-200 dark:text-gray-400 dark:hover:bg-gray-700 dark:focus:ring-gray-600" aria-controls="mobile-menu-2" aria-expanded="false"><span class="sr-only">Open main menu</span><svg class="w-6 h-6" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M3 5a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM3 10a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM3 15a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1z" clip-rule="evenodd"></path></svg><svg class="hidden w-6 h-6" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z" clip-rule="evenodd"></path></svg></button></div><div class="hidden justify-between items-center w-full lg:flex lg:w-auto lg:order-1" id="mobile-menu-2"><ul class="flex flex-col mt-4 font-medium lg:flex-row lg:space-x-8 lg:mt-0"><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" aria-current="page" href="/">Home</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/questions?tab=news">Questions</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/post?tab=news">Post</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/questions/c++-singleton-design-pattern-1657387830040#">Coding</a></li></ul></div></div></nav></header><div class="main-content"><div class="question my-5"><div class="flex question-header items-center m-auto justify-center"><div class="rounded-xl w-full border p-5 shadow-md bg-white"><div class="flex w-full items-center justify-between border-b pb-3"><div class="flex items-center space-x-3"><div class="text-lg font-bold text-slate-700"><a href="/questions/c++-singleton-design-pattern-1657387830040"><h1>C++ Singleton design pattern</h1></a></div></div><div class="flex flex-wrap h-auto justify-end items-center space-x-8"></div></div><div class="question-content mt-5">
                
<p>Recently I've bumped into a realization/implementation of the Singleton design pattern for C++. It has looked like this (I have adopted it from the real-life example):</p>
<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-comment">// a lot of methods are omitted here</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span>
{
   <span class="hljs-keyword">public</span>:
       <span class="hljs-function"><span class="hljs-type">static</span> Singleton* <span class="hljs-title">getInstance</span><span class="hljs-params">( )</span></span>;
       ~<span class="hljs-built_in">Singleton</span>( );
   <span class="hljs-keyword">private</span>:
       <span class="hljs-built_in">Singleton</span>( );
       <span class="hljs-type">static</span> Singleton* instance;
};
</code></pre>
<p>From this declaration, I can deduce that the instance field is initiated on the heap. That means there is a memory allocation. What is completely unclear for me is when exactly the memory is going to be deallocated? Or is there a bug and memory leak? It seems like there is a problem with the implementation.</p>
<p>My main question is, how do I implement it in the right way?</p>
    </div></div></div><div class="solution-section"><nav class="flex pagination-solution flex-col justify-end"><h1 class="text-lg font-semibold mb-5">Navigate to solutions: </h1><ul class="inline-flex -space-x-px overflow-auto"><li class="pagination-solution-item"><span data-id="#solution1" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">1</span></li><li class="pagination-solution-item"><span data-id="#solution2" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">2</span></li><li class="pagination-solution-item"><span data-id="#solution3" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">3</span></li><li class="pagination-solution-item"><span data-id="#solution4" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">4</span></li><li class="pagination-solution-item"><span data-id="#solution5" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">5</span></li><li class="pagination-solution-item"><span data-id="#solution6" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">6</span></li><li class="pagination-solution-item"><span data-id="#solution7" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">7</span></li><li class="pagination-solution-item"><span data-id="#solution8" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">8</span></li><li class="pagination-solution-item"><span data-id="#solution9" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">9</span></li><li class="pagination-solution-item"><span data-id="#solution10" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">10</span></li><li class="pagination-solution-item"><span data-id="#solution11" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">11</span></li><li class="pagination-solution-item"><span data-id="#solution12" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">12</span></li><li class="pagination-solution-item"><span data-id="#solution13" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">13</span></li><li class="pagination-solution-item"><span data-id="#solution14" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">14</span></li><li class="pagination-solution-item"><span data-id="#solution15" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">15</span></li><li class="pagination-solution-item"><span data-id="#solution16" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">16</span></li><li class="pagination-solution-item"><span data-id="#solution17" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">17</span></li><li class="pagination-solution-item"><span data-id="#solution18" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">18</span></li><li class="pagination-solution-item"><span data-id="#solution19" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">19</span></li><li class="pagination-solution-item"><span data-id="#solution20" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">20</span></li><li class="pagination-solution-item"><span data-id="#solution21" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">21</span></li><li class="pagination-solution-item"><span data-id="#solution22" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">22</span></li><li class="pagination-solution-item"><span data-id="#solution23" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">23</span></li><li class="pagination-solution-item"><span data-id="#solution24" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">24</span></li></ul></nav><div id="solution1" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 1</h1><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>In 2008 I provided a C++98 implementation of the Singleton design pattern that is lazy-evaluated, guaranteed-destruction, not-technically-thread-safe:<br>
<a href="https://stackoverflow.com/a/271104/364696">Can any one provide me a sample of Singleton in c++?</a></p>
<p>Here is an updated C++11 implementation of the Singleton design pattern that is lazy-evaluated, correctly-destroyed, and <a href="https://stackoverflow.com/a/449823/52074">thread-safe</a>.</p>
<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">S</span>
{
    <span class="hljs-keyword">public</span>:
        <span class="hljs-function"><span class="hljs-type">static</span> S&amp; <span class="hljs-title">getInstance</span><span class="hljs-params">()</span>
        </span>{
            <span class="hljs-type">static</span> S    instance; <span class="hljs-comment">// Guaranteed to be destroyed.</span>
                                  <span class="hljs-comment">// Instantiated on first use.</span>
            <span class="hljs-keyword">return</span> instance;
        }
    <span class="hljs-keyword">private</span>:
        <span class="hljs-built_in">S</span>() {}                    <span class="hljs-comment">// Constructor? (the {} brackets) are needed here.</span>

        <span class="hljs-comment">// C++ 03</span>
        <span class="hljs-comment">// ========</span>
        <span class="hljs-comment">// Don't forget to declare these two. You want to make sure they</span>
        <span class="hljs-comment">// are inaccessible(especially from outside), otherwise, you may accidentally get copies of</span>
        <span class="hljs-comment">// your singleton appearing.</span>
        <span class="hljs-built_in">S</span>(S <span class="hljs-type">const</span>&amp;);              <span class="hljs-comment">// Don't Implement</span>
        <span class="hljs-type">void</span> <span class="hljs-keyword">operator</span>=(S <span class="hljs-type">const</span>&amp;); <span class="hljs-comment">// Don't implement</span>

        <span class="hljs-comment">// C++ 11</span>
        <span class="hljs-comment">// =======</span>
        <span class="hljs-comment">// We can use the better technique of deleting the methods</span>
        <span class="hljs-comment">// we don't want.</span>
    <span class="hljs-keyword">public</span>:
        <span class="hljs-built_in">S</span>(S <span class="hljs-type">const</span>&amp;)               = <span class="hljs-keyword">delete</span>;
        <span class="hljs-type">void</span> <span class="hljs-keyword">operator</span>=(S <span class="hljs-type">const</span>&amp;)  = <span class="hljs-keyword">delete</span>;

        <span class="hljs-comment">// Note: Scott Meyers mentions in his Effective Modern</span>
        <span class="hljs-comment">//       C++ book, that deleted functions should generally</span>
        <span class="hljs-comment">//       be public as it results in better error messages</span>
        <span class="hljs-comment">//       due to the compilers behavior to check accessibility</span>
        <span class="hljs-comment">//       before deleted status</span>
};
</code></pre>
<p>See this article about when to use a singleton: (not often)<br>
<a href="https://stackoverflow.com/questions/86582/singleton-how-should-it-be-used">Singleton: How should it be used</a></p>
<p>See this two article about initialization order and how to cope:<br>
<a href="https://stackoverflow.com/questions/211237/c-static-variables-initialisation-order/211307#211307">Static variables initialisation order</a><br>
<a href="https://stackoverflow.com/questions/335369/finding-c-static-initialization-order-problems/335746#335746">Finding C++ static initialization order problems</a></p>
<p>See this article describing lifetimes:<br>
<a href="https://stackoverflow.com/questions/246564/what-is-the-lifetime-of-a-static-variable-in-a-c-function">What is the lifetime of a static variable in a C++ function?</a></p>
<p>See this article that discusses some threading implications to singletons:<br>
<a href="https://stackoverflow.com/questions/449436/singleton-instance-declared-as-static-variable-of-getinstance-method/449823#449823">Singleton instance declared as static variable of GetInstance method, is it thread-safe?</a></p>
<p>See this article that explains why double checked locking will not work on C++:<br>
<a href="https://stackoverflow.com/questions/367633/what-are-all-the-common-undefined-behaviour-that-c-programmer-should-know-about/367690#367690">What are all the common undefined behaviours that a C++ programmer should know about?</a><br>
<a href="http://www.drdobbs.com/cpp/c-and-the-perils-of-double-checked-locki/184405726" rel="noreferrer">Dr Dobbs: C++ and The Perils of Double-Checked Locking: Part I</a></p>
    </div></div></div></div><div id="solution2" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 2</h1><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>You could avoid memory allocation. There are many variants, all having problems in case of multithreading environment.</p>

<p>I prefer this kind of implementation (actually, it is not correctly said I prefer, because I avoid singletons as much as possible):</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span>
{
<span class="hljs-keyword">private</span>:
   <span class="hljs-built_in">Singleton</span>();

<span class="hljs-keyword">public</span>:
   <span class="hljs-function"><span class="hljs-type">static</span> Singleton&amp; <span class="hljs-title">instance</span><span class="hljs-params">()</span>
   </span>{
      <span class="hljs-type">static</span> Singleton INSTANCE;
      <span class="hljs-keyword">return</span> INSTANCE;
   }
};
</code></pre>

<p>It has no dynamic memory allocation.</p>
    </div></div></div></div><div id="solution3" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 3</h1><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Being a Singleton, you usually do not want it to be destructed.</p>

<p>It will get torn down and deallocated when the program terminates, which is the normal, desired behavior for a singleton.  If you want to be able to explicitly clean it, it's fairly easy to add a static method to the class that allows you to restore it to a clean state, and have it reallocate next time it's used, but that's outside of the scope of a "classic" singleton.</p>
    </div></div></div></div><div id="solution4" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 4</h1><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p><a href="https://stackoverflow.com/a/1008289/3807729">@Loki Astari's answer</a> is excellent. </p>

<p>However there are times with multiple static objects where you need to be able to guarantee that the <em>singleton</em> will not be destroyed until all your static objects that use the <em>singleton</em> no longer need it.</p>

<p>In this case <code>std::shared_ptr</code> can be used to keep the <em>singleton</em> alive for all users even when the static destructors are being called at the end of the program:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span>
{
<span class="hljs-keyword">public</span>:
    <span class="hljs-built_in">Singleton</span>(Singleton <span class="hljs-type">const</span>&amp;) = <span class="hljs-keyword">delete</span>;
    Singleton&amp; <span class="hljs-keyword">operator</span>=(Singleton <span class="hljs-type">const</span>&amp;) = <span class="hljs-keyword">delete</span>;

    <span class="hljs-function"><span class="hljs-type">static</span> std::shared_ptr&lt;Singleton&gt; <span class="hljs-title">instance</span><span class="hljs-params">()</span>
    </span>{
        <span class="hljs-type">static</span> std::shared_ptr&lt;Singleton&gt; s{<span class="hljs-keyword">new</span> Singleton};
        <span class="hljs-keyword">return</span> s;
    }

<span class="hljs-keyword">private</span>:
    <span class="hljs-built_in">Singleton</span>() {}
};
</code></pre>
    </div></div></div></div><div id="solution5" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 5</h1><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Another non-allocating alternative: create a singleton, say of class <code>C</code>, as you need it:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-built_in">singleton</span>&lt;C&gt;()
</code></pre>

<p>using</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">X</span>&gt;
<span class="hljs-function">X&amp; <span class="hljs-title">singleton</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-type">static</span> X x;
    <span class="hljs-keyword">return</span> x;
}
</code></pre>

<p>Neither this nor Cătălin's answer is automatically thread-safe in current C++, but will be in C++0x.</p>
    </div></div></div></div><div id="solution6" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 6</h1><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>I did not find a CRTP implementation among the answers, so here it is:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> HeirT&gt;
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span>
{
<span class="hljs-keyword">public</span>:
    <span class="hljs-built_in">Singleton</span>() = <span class="hljs-keyword">delete</span>;

    <span class="hljs-built_in">Singleton</span>(<span class="hljs-type">const</span> Singleton &amp;) = <span class="hljs-keyword">delete</span>;

    Singleton &amp;<span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Singleton &amp;) = <span class="hljs-keyword">delete</span>;

    <span class="hljs-function"><span class="hljs-type">static</span> HeirT &amp;<span class="hljs-title">instance</span><span class="hljs-params">()</span>
    </span>{
        <span class="hljs-type">static</span> HeirT instance;
        <span class="hljs-keyword">return</span> instance;
    }
};
</code></pre>

<p>To use just inherit your class from this, like: <code>class Test : public Singleton&lt;Test&gt;</code></p>
    </div></div></div></div><div id="solution7" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 7</h1><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>We went over this topic recently in my EECS class. If you want to look at the lecture notes in detail, visit <a href="http://umich.edu/%7Eeecs381/lecture/IdiomsDesPattsCreational.pdf" rel="nofollow noreferrer">http://umich.edu/~eecs381/lecture/IdiomsDesPattsCreational.pdf</a>. These notes (and quotations I give in this answer) were created by my Professor, David Kieras.</p>
<p>There are two ways that I know to create a Singleton class correctly.</p>
<p><strong>First Way:</strong></p>
<p>Implement it similar to the way you have it in your example. As for destruction, "Singletons usually endure for the length of the program run; most OSs will recover memory and most other resources when a program terminates, so there is an argument for not worrying about this."</p>
<p>However, it is good practice to clean up at program termination. Therefore, you can do this with an auxiliary static SingletonDestructor class and declare that as a friend in your Singleton.</p>
<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> {
<span class="hljs-keyword">public</span>:
  <span class="hljs-function"><span class="hljs-type">static</span> Singleton* <span class="hljs-title">get_instance</span><span class="hljs-params">()</span></span>;
  
  <span class="hljs-comment">// disable copy/move -- this is a Singleton</span>
  <span class="hljs-built_in">Singleton</span>(<span class="hljs-type">const</span> Singleton&amp;) = <span class="hljs-keyword">delete</span>;
  <span class="hljs-built_in">Singleton</span>(Singleton&amp;&amp;) = <span class="hljs-keyword">delete</span>;
  Singleton&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Singleton&amp;) = <span class="hljs-keyword">delete</span>;
  Singleton&amp; <span class="hljs-keyword">operator</span>=(Singleton&amp;&amp;) = <span class="hljs-keyword">delete</span>;

  <span class="hljs-keyword">friend</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton_destroyer</span>;

<span class="hljs-keyword">private</span>:
  <span class="hljs-built_in">Singleton</span>();  <span class="hljs-comment">// no one else can create one</span>
  ~<span class="hljs-built_in">Singleton</span>(); <span class="hljs-comment">// prevent accidental deletion</span>

  <span class="hljs-type">static</span> Singleton* ptr;
};

<span class="hljs-comment">// auxiliary static object for destroying the memory of Singleton</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton_destroyer</span> {
<span class="hljs-keyword">public</span>:
  ~Singleton_destroyer { <span class="hljs-keyword">delete</span> Singleton::ptr; }
};

<span class="hljs-comment">// somewhere in code (Singleton.cpp is probably the best place) </span>
<span class="hljs-comment">// create a global static Singleton_destroyer object</span>
Singleton_destoyer the_destroyer;
</code></pre>
<p>The Singleton_destroyer will be created on program startup, and "when program terminates, all global/static objects are destroyed by the runtime library shutdown code (inserted by the linker), so the_destroyer will be destroyed; its destructor will delete the Singleton, running its destructor."</p>
<p><strong>Second Way</strong></p>
<p>This is called the Meyers Singleton, created by C++ wizard Scott Meyers. Simply define get_instance() differently. Now you can also get rid of the pointer member variable.</p>
<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-comment">// public member function</span>
<span class="hljs-function"><span class="hljs-type">static</span> Singleton&amp; <span class="hljs-title">Singleton::get_instance</span><span class="hljs-params">()</span>
</span>{
  <span class="hljs-type">static</span> Singleton s;
  <span class="hljs-keyword">return</span> s;
}
</code></pre>
<p>This is neat because the value returned is by reference and you can use <code>.</code> syntax instead of <code>-&gt;</code> to access member variables.</p>
<p>"Compiler automatically builds code that creates 's' first time through the
declaration, not thereafter, and then deletes the static object at program
termination."</p>
<p>Note also that with the Meyers Singleton you "can get into very difficult situation if objects rely on each other at the time of
termination - when does the Singleton disappear relative to other objects? But for simple applications, this works fine."</p>
    </div></div></div></div><div id="solution8" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 8</h1><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Here is an easy implementation.</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;Windows.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>

<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;


<span class="hljs-keyword">class</span> <span class="hljs-title class_">SingletonClass</span> {

<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-type">static</span> SingletonClass* <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>{

    <span class="hljs-keyword">return</span> (!m_instanceSingleton) ?
        m_instanceSingleton = <span class="hljs-keyword">new</span> SingletonClass : 
        m_instanceSingleton;
    }

<span class="hljs-keyword">private</span>:
    <span class="hljs-comment">// private constructor and destructor</span>
    <span class="hljs-built_in">SingletonClass</span>() { cout &lt;&lt; <span class="hljs-string">"SingletonClass instance created!\n"</span>; }
    ~<span class="hljs-built_in">SingletonClass</span>() {}

    <span class="hljs-comment">// private copy constructor and assignment operator</span>
    <span class="hljs-built_in">SingletonClass</span>(<span class="hljs-type">const</span> SingletonClass&amp;);
    SingletonClass&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> SingletonClass&amp;);

    <span class="hljs-type">static</span> SingletonClass *m_instanceSingleton;
};

SingletonClass* SingletonClass::m_instanceSingleton = <span class="hljs-literal">nullptr</span>;



<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">const</span> <span class="hljs-type">char</span> * argv[])</span> </span>{

    SingletonClass *singleton;
    singleton = singleton-&gt;<span class="hljs-built_in">getInstance</span>();
    cout &lt;&lt; singleton &lt;&lt; endl;

    <span class="hljs-comment">// Another object gets the reference of the first object!</span>
    SingletonClass *anotherSingleton;
    anotherSingleton = anotherSingleton-&gt;<span class="hljs-built_in">getInstance</span>();
    cout &lt;&lt; anotherSingleton &lt;&lt; endl;

    <span class="hljs-built_in">Sleep</span>(<span class="hljs-number">5000</span>);

    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>

<p>Only one object created and this object reference is returned each and every time afterwords.</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp">SingletonClass instance created!
<span class="hljs-number">00915</span>CB8
<span class="hljs-number">00915</span>CB8
</code></pre>

<p>Here 00915CB8 is the memory location of singleton Object, same for the duration of the program but (normally!) different each time the program is run.</p>

<p>N.B. This is not a thread safe one.You have to ensure thread safety.</p>
    </div></div></div></div><div id="solution9" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 9</h1><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>The solution in the accepted answer has a significant drawback - the destructor for the singleton is called after the control leaves the <code>main()</code> function. There may be problems really, when some dependent objects are allocated inside <code>main</code>.</p>

<p>I met this problem, when trying to introduce a Singleton in the Qt application. I decided, that all my setup dialogs must be Singletons, and adopted the pattern above. Unfortunately, Qt's main class <code>QApplication</code> was allocated on stack in the <code>main</code> function, and Qt forbids creating/destroying dialogs when no application object is available.</p>

<p>That is why I prefer heap-allocated singletons. I provide an explicit <code>init()</code> and <code>term()</code> methods for all the singletons and call them inside <code>main</code>. Thus I have a full control over the order of singletons creation/destruction, and also I guarantee that singletons will be created, no matter whether someone called <code>getInstance()</code> or not.</p>
    </div></div></div></div><div id="solution10" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 10</h1><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Has anyone mentioned <code>std::call_once</code> and <code>std::once_flag</code>?
Most other approaches - including double checked locking - are broken.</p>

<p>One major problem in singleton pattern implementation is safe initialization. The only safe way is to guard the initialization sequence with synchronizing barriers. But those barriers themselves need to be safely initiated. <code>std::once_flag</code> is the mechanism to get guaranteed safe initialization.</p>
    </div></div></div></div><div id="solution11" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 11</h1><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>If you want to allocate the object in heap, why don't use a unique pointer. Memory will also be deallocated since we are using a unique pointer.</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">S</span>
{
    <span class="hljs-keyword">public</span>:
        <span class="hljs-function"><span class="hljs-type">static</span> S&amp; <span class="hljs-title">getInstance</span><span class="hljs-params">()</span>
        </span>{
            <span class="hljs-keyword">if</span>( m_s.<span class="hljs-built_in">get</span>() == <span class="hljs-number">0</span> )
            {
              m_s.<span class="hljs-built_in">reset</span>( <span class="hljs-keyword">new</span> <span class="hljs-built_in">S</span>() );
            }
            <span class="hljs-keyword">return</span> *m_s;
        }

    <span class="hljs-keyword">private</span>:
        <span class="hljs-type">static</span> std::unique_ptr&lt;S&gt; m_s;

        <span class="hljs-built_in">S</span>();
        <span class="hljs-built_in">S</span>(S <span class="hljs-type">const</span>&amp;);            <span class="hljs-comment">// Don't Implement</span>
        <span class="hljs-type">void</span> <span class="hljs-keyword">operator</span>=(S <span class="hljs-type">const</span>&amp;); <span class="hljs-comment">// Don't implement</span>
};

<span class="hljs-function">std::unique_ptr&lt;S&gt; <span class="hljs-title">S::m_s</span><span class="hljs-params">(<span class="hljs-number">0</span>)</span></span>;
</code></pre>
    </div></div></div></div><div id="solution12" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 12</h1><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>C++11 Thread safe implementation:</p>
<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"> <span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>
 <span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span>


 <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span>
 {
     <span class="hljs-keyword">private</span>:
         <span class="hljs-type">static</span> Singleton * _instance;
         <span class="hljs-type">static</span> std::mutex mutex_;

     <span class="hljs-keyword">protected</span>:
         <span class="hljs-built_in">Singleton</span>(<span class="hljs-type">const</span> std::string value): <span class="hljs-built_in">value_</span>(value)
         {
         }
         ~<span class="hljs-built_in">Singleton</span>() {}
         std::string value_;

     <span class="hljs-keyword">public</span>:
         <span class="hljs-comment">/**
          * Singletons should not be cloneable.
          */</span>
         <span class="hljs-built_in">Singleton</span>(Singleton &amp;other) = <span class="hljs-keyword">delete</span>;
         <span class="hljs-comment">/**
          * Singletons should not be assignable.
          */</span>
         <span class="hljs-type">void</span> <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Singleton &amp;) = <span class="hljs-keyword">delete</span>;

         <span class="hljs-comment">//static Singleton *GetInstance(const std::string&amp; value);</span>
         <span class="hljs-function"><span class="hljs-type">static</span> Singleton *<span class="hljs-title">GetInstance</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; value)</span>
         </span>{
             <span class="hljs-keyword">if</span> (_instance == <span class="hljs-literal">nullptr</span>)
             {
                 <span class="hljs-function">std::lock_guard&lt;std::mutex&gt; <span class="hljs-title">lock</span><span class="hljs-params">(mutex_)</span></span>;
                 <span class="hljs-keyword">if</span> (_instance == <span class="hljs-literal">nullptr</span>)
                 {
                     _instance = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Singleton</span>(value);
                 }
             }
             <span class="hljs-keyword">return</span> _instance;
         }

         <span class="hljs-function">std::string <span class="hljs-title">value</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>{
             <span class="hljs-keyword">return</span> value_;
         }
 };

 <span class="hljs-comment">/**
  * Static methods should be defined outside the class.
  */</span>
 Singleton* Singleton::_instance = <span class="hljs-literal">nullptr</span>;
 std::mutex Singleton::mutex_;


 <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ThreadFoo</span><span class="hljs-params">()</span></span>{
     std::this_thread::<span class="hljs-built_in">sleep_for</span>(std::chrono::<span class="hljs-built_in">milliseconds</span>(<span class="hljs-number">10</span>));
     Singleton* singleton = Singleton::<span class="hljs-built_in">GetInstance</span>(<span class="hljs-string">"FOO"</span>);
     std::cout &lt;&lt; singleton-&gt;<span class="hljs-built_in">value</span>() &lt;&lt; <span class="hljs-string">"\n"</span>;
 }

 <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ThreadBar</span><span class="hljs-params">()</span></span>{
     std::this_thread::<span class="hljs-built_in">sleep_for</span>(std::chrono::<span class="hljs-built_in">milliseconds</span>(<span class="hljs-number">1000</span>));
     Singleton* singleton = Singleton::<span class="hljs-built_in">GetInstance</span>(<span class="hljs-string">"BAR"</span>);
     std::cout &lt;&lt; singleton-&gt;<span class="hljs-built_in">value</span>() &lt;&lt; <span class="hljs-string">"\n"</span>;
 }

 <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
 </span>{
     std::cout &lt;&lt;<span class="hljs-string">"If you see the same value, then singleton was reused (yay!\n"</span> &lt;&lt;
                 <span class="hljs-string">"If you see different values, then 2 singletons were created (booo!!)\n\n"</span> &lt;&lt;
                 <span class="hljs-string">"RESULT:\n"</span>;
     <span class="hljs-function">std::thread <span class="hljs-title">t1</span><span class="hljs-params">(ThreadFoo)</span></span>;
     <span class="hljs-function">std::thread <span class="hljs-title">t2</span><span class="hljs-params">(ThreadBar)</span></span>;
     t1.<span class="hljs-built_in">join</span>();
     t2.<span class="hljs-built_in">join</span>();
     std::cout &lt;&lt; <span class="hljs-string">"Complete!"</span> &lt;&lt; std::endl;

     <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
 }
</code></pre>
    </div></div></div></div><div id="solution13" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 13</h1><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>It is indeed probably allocated from the heap, but without the sources there is no way of knowing.</p>

<p>The typical implementation (taken from some code I have in emacs already) would be:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-function">Singleton * <span class="hljs-title">Singleton::getInstance</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">if</span> (!instance) {
        instance = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Singleton</span>();
    };
    <span class="hljs-keyword">return</span> instance;
};
</code></pre>

<p>...and rely on the program going out of scope to clean up afterwards.</p>

<p>If you work on a platform where cleanup must be done manually, I'd probably add a manual cleanup routine.</p>

<p>Another issue with doing it this way is that it isn't thread-safe. In a multithreaded environment, two threads could get through the "if" before either has a chance to allocate the new instance (so both would). This still isn't too big of a deal if you are relying on program termination to clean up anyway.</p>
    </div></div></div></div><div id="solution14" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 14</h1><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>In addition to the other discussion here, it may be worth noting that you can have global-ness, without limiting usage to one instance. For example, consider the case of reference counting something...</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Store</span>{
   std::array&lt;Something, 1024&gt; data;
   <span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-type">size_t</span> idx)</span></span>{ <span class="hljs-comment">/* ... */</span> }
   <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">incr_ref</span><span class="hljs-params">(<span class="hljs-type">size_t</span> idx)</span></span>{ <span class="hljs-comment">/* ... */</span>}
   <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">decr_ref</span><span class="hljs-params">(<span class="hljs-type">size_t</span> idx)</span></span>{ <span class="hljs-comment">/* ... */</span>}
};

<span class="hljs-keyword">template</span>&lt;Store* store_p&gt;
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">ItemRef</span>{
   <span class="hljs-type">size_t</span> idx;
   <span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">get</span><span class="hljs-params">()</span></span>{ <span class="hljs-keyword">return</span> store_p-&gt;<span class="hljs-built_in">get</span>(idx); };
   <span class="hljs-built_in">ItemRef</span>() { store_p-&gt;<span class="hljs-built_in">incr_ref</span>(idx); };
   ~<span class="hljs-built_in">ItemRef</span>() { store_p-&gt;<span class="hljs-built_in">decr_ref</span>(idx); };
};

Store store1_g;
Store store2_g; <span class="hljs-comment">// we don't restrict the number of global Store instances</span>
</code></pre>

<p>Now somewhere inside a function (such as <code>main</code>) you can do:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-keyword">auto</span> ref1_a = <span class="hljs-built_in">ItemRef</span>&lt;&amp;store1_g&gt;(<span class="hljs-number">101</span>);
<span class="hljs-keyword">auto</span> ref2_a = <span class="hljs-built_in">ItemRef</span>&lt;&amp;store2_g&gt;(<span class="hljs-number">201</span>); 
</code></pre>

<p>The refs don't need to store a pointer back to their respective <code>Store</code> because that information is supplied at compile-time. You also don't have to worry about the <code>Store</code>'s lifetime because the compiler requires that it is global.  If there is indeed only one instance of <code>Store</code> then there's no overhead in this approach; with more than one instance it's up to the compiler to be clever about code generation. If necessary, the <code>ItemRef</code> class can even be made a <code>friend</code> of <code>Store</code> (you can have templated friends!).</p>

<p>If <code>Store</code> itself is a templated class then things get messier, but it is still possible to use this method, perhaps by implementing a helper class with the following signature:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Store_t, Store_t* store_p&gt;
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">StoreWrapper</span>{ <span class="hljs-comment">/* stuff to access store_p, e.g. methods returning 
                       instances of ItemRef&lt;Store_t, store_p&gt;. */</span> };
</code></pre>

<p>The user can now create a <code>StoreWrapper</code> type (and global instance) for each global <code>Store</code> instance, and always access the stores via their wrapper instance (thus forgetting about the gory details of the template parameters needed for using <code>Store</code>).</p>
    </div></div></div></div><div id="solution15" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 15</h1><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Here is a <a href="https://github.com/canonical/multipass/blob/7d3de5fb1a4402b4438dae4806677fdd6c776450/include/multipass/singleton.h" rel="nofollow noreferrer">mockable singleton</a> using <a href="https://en.wikipedia.org/wiki/Curiously_recurring_template_pattern" rel="nofollow noreferrer">CRTP</a>. It relies on <a href="https://github.com/canonical/multipass/blob/7d3de5fb1a4402b4438dae4806677fdd6c776450/include/multipass/private_pass_provider.h" rel="nofollow noreferrer">a little helper</a> to enforce a single object at any one time (at most). To enforce a single object over program execution, remove the reset (which we find useful for tests).</p>
<p>A <code>ConcreteSinleton</code> can be implemented like this:</p>
<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteSingleton</span> : <span class="hljs-keyword">public</span> Singleton&lt;ConcreteSingleton&gt;
{
<span class="hljs-keyword">public</span>:
  <span class="hljs-built_in">ConcreteSingleton</span>(<span class="hljs-type">const</span> Singleton&lt;ConcreteSingleton&gt;::PrivatePass&amp;)
      : Singleton&lt;StandardPaths&gt;::Singleton{pass}
  {}
  
  <span class="hljs-comment">// ... concrete interface</span>
  <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">f</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>{<span class="hljs-keyword">return</span> <span class="hljs-number">42</span>;}

};
</code></pre>
<p>And then used with</p>
<pre class="lang-cpp s-code-block"><code class="hljs language-cpp">ConcreteSingleton::<span class="hljs-built_in">instance</span>().<span class="hljs-built_in">f</span>();
</code></pre>
    </div></div></div></div><div id="solution16" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 16</h1><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>This is about object life-time management. Suppose you have more than singletons in your software. And they depend on Logger singleton. During application destruction, suppose another singleton object uses Logger to log its destruction steps. You have to guarantee that Logger should be cleaned up last. Therefore, please also check out this paper:
<a href="http://www.cs.wustl.edu/~schmidt/PDF/ObjMan.pdf" rel="nofollow noreferrer">http://www.cs.wustl.edu/~schmidt/PDF/ObjMan.pdf</a> </p>
    </div></div></div></div><div id="solution17" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 17</h1><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>My implementation is similar to Galik's. The difference is my implementation allows the shared pointers to clean up allocated memory, as opposed to holding onto the memory until the application is exited and the static pointers are cleaned up.</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> once</span>

<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span>

<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span>
{
<span class="hljs-keyword">private</span>:
  <span class="hljs-type">static</span> std::weak_ptr&lt;T&gt; _singleton;
<span class="hljs-keyword">public</span>:
  <span class="hljs-function"><span class="hljs-type">static</span> std::shared_ptr&lt;T&gt; <span class="hljs-title">singleton</span><span class="hljs-params">()</span>
  </span>{
    std::shared_ptr&lt;T&gt; singleton = _singleton.<span class="hljs-built_in">lock</span>();
    <span class="hljs-keyword">if</span> (!singleton) 
    {
      singleton.<span class="hljs-built_in">reset</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">T</span>());
      _singleton = singleton;
    }

    <span class="hljs-keyword">return</span> singleton;
  }
};

<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;
std::weak_ptr&lt;T&gt; Singleton&lt;T&gt;::_singleton;
</code></pre>
    </div></div></div></div><div id="solution18" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 18</h1><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Your code is correct, except that <em>you didn't declare the instance pointer outside the class</em>. The inside class declarations of static variables are not considered declarations in C++, however this is allowed in other languages like <strong>C#</strong> or <strong>Java</strong> etc.</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span>
{
   <span class="hljs-keyword">public</span>:
       <span class="hljs-function"><span class="hljs-type">static</span> Singleton* <span class="hljs-title">getInstance</span><span class="hljs-params">( )</span></span>;
   <span class="hljs-keyword">private</span>:
       <span class="hljs-built_in">Singleton</span>( );
       <span class="hljs-type">static</span> Singleton* instance;
};
Singleton* Singleton::instance; <span class="hljs-comment">//we need to declare outside because static variables are global</span>
</code></pre>

<p>You must know that Singleton instance <em>doesn't need to be manually deleted by us</em>. We need a single object of it throughout the whole program, so <em>at the end of program execution, it will be automatically deallocated.</em></p>
    </div></div></div></div><div id="solution19" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 19</h1><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Here is my view on how to do proper singletons (and other non-trivial static objects): <a href="https://github.com/alex4747-pub/proper_singleton" rel="nofollow noreferrer">https://github.com/alex4747-pub/proper_singleton</a></p>
<p>Summary:</p>
<ol>
<li>Use static initialization list to instantiate singletons at the right time: after entering main and before enabling multi-threading</li>
<li>Add minor improvements to make it unit-test friendly.</li>
</ol>
    </div></div></div></div><div id="solution20" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 20</h1><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>I would like to show here another example of a singleton in C++. It makes sense to use template programming. Besides, it makes sense to derive your singleton class from a not copyable and not movabe classes. Here how it looks like in the code:</p>
<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;string&gt;</span></span>

<span class="hljs-keyword">class</span> <span class="hljs-title class_">DoNotCopy</span>
{
<span class="hljs-keyword">protected</span>:
    <span class="hljs-built_in">DoNotCopy</span>(<span class="hljs-type">void</span>) = <span class="hljs-keyword">default</span>;
    <span class="hljs-built_in">DoNotCopy</span>(<span class="hljs-type">const</span> DoNotCopy&amp;) = <span class="hljs-keyword">delete</span>;
    DoNotCopy&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> DoNotCopy&amp;) = <span class="hljs-keyword">delete</span>;
};

<span class="hljs-keyword">class</span> <span class="hljs-title class_">DoNotMove</span>
{
<span class="hljs-keyword">protected</span>:
    <span class="hljs-built_in">DoNotMove</span>(<span class="hljs-type">void</span>) = <span class="hljs-keyword">default</span>;
    <span class="hljs-built_in">DoNotMove</span>(DoNotMove&amp;&amp;) = <span class="hljs-keyword">delete</span>;
    DoNotMove&amp; <span class="hljs-keyword">operator</span>=(DoNotMove&amp;&amp;) = <span class="hljs-keyword">delete</span>;
};

<span class="hljs-keyword">class</span> <span class="hljs-title class_">DoNotCopyMove</span> : <span class="hljs-keyword">public</span> DoNotCopy,
    <span class="hljs-keyword">public</span> DoNotMove
{
<span class="hljs-keyword">protected</span>:
    <span class="hljs-built_in">DoNotCopyMove</span>(<span class="hljs-type">void</span>) = <span class="hljs-keyword">default</span>;
};

<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> : <span class="hljs-keyword">public</span> DoNotCopyMove
{
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-type">static</span> T&amp; <span class="hljs-title">Instance</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>
    </span>{
        <span class="hljs-type">static</span> T instance;
        <span class="hljs-keyword">return</span> instance;
    }

<span class="hljs-keyword">protected</span>:
    <span class="hljs-built_in">Singleton</span>(<span class="hljs-type">void</span>) = <span class="hljs-keyword">default</span>;
};

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Logger</span> <span class="hljs-keyword">final</span>: <span class="hljs-keyword">public</span> Singleton&lt;Logger&gt;
{
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">log</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; str)</span> </span>{ std::cout &lt;&lt; str &lt;&lt; std::endl; }
};



<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    Logger::<span class="hljs-built_in">Instance</span>().<span class="hljs-built_in">log</span>(<span class="hljs-string">"xx"</span>);
}
</code></pre>
<p>The splitting into NotCopyable and NotMovable clases allows you to define your singleton more specific (sometimes you want to move your single instance).</p>
    </div></div></div></div><div id="solution21" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 21</h1><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>It restrict instantiation of a class to one object. This is useful when exactly one object is needed to coordinate actions across the system</p>
<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> {
<span class="hljs-keyword">private</span>:
    <span class="hljs-type">int</span> data;
    <span class="hljs-type">static</span> Singleton* instance;
    <span class="hljs-built_in">Singleton</span>();
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-type">static</span> Singleton* <span class="hljs-title">getInstance</span><span class="hljs-params">()</span></span>;
};
Singleton* Singleton::instance = <span class="hljs-number">0</span>;
Singleton::<span class="hljs-built_in">Singleton</span>()
{
    <span class="hljs-keyword">this</span>-&gt;data = <span class="hljs-number">0</span>;
    cout &lt;&lt; <span class="hljs-string">"constructor called.."</span> &lt;&lt; endl;
}

 

<span class="hljs-function">Singleton* <span class="hljs-title">Singleton::getInstance</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">if</span> (!instance) {
        instance = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Singleton</span>();
        <span class="hljs-keyword">return</span> instance;
    }
}
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    Singleton *s = s-&gt;<span class="hljs-built_in">getInstance</span>();
    Singleton *s1 =s1-&gt;<span class="hljs-built_in">getInstance</span>();
    }
</code></pre>
    </div></div></div></div><div id="solution22" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 22</h1><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>The paper that was linked to above describes the shortcoming of double checked locking is that the compiler may allocate the memory for the object and set a pointer to the address of the allocated memory, before the object's constructor has been called. It is quite easy in c++ however to use allocaters to allocate the memory manually, and then use a construct call to initialize the memory. Using this appraoch, the double-checked locking works just fine.</p>
    </div></div></div></div><div id="solution23" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 23</h1><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Simple singleton class, This must be your header class file</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> SC_SINGLETON_CLASS_H</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> SC_SINGLETON_CLASS_H</span>

<span class="hljs-keyword">class</span> <span class="hljs-title class_">SingletonClass</span>
{
    <span class="hljs-keyword">public</span>:
        <span class="hljs-function"><span class="hljs-type">static</span> SingletonClass* <span class="hljs-title">Instance</span><span class="hljs-params">()</span>
        </span>{
           <span class="hljs-type">static</span> SingletonClass* instance = <span class="hljs-keyword">new</span> <span class="hljs-built_in">SingletonClass</span>();
           <span class="hljs-keyword">return</span> instance;
        }

        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Relocate</span><span class="hljs-params">(<span class="hljs-type">int</span> X, <span class="hljs-type">int</span> Y, <span class="hljs-type">int</span> Z)</span></span>;

    <span class="hljs-keyword">private</span>:
        <span class="hljs-built_in">SingletonClass</span>();
        ~<span class="hljs-built_in">SingletonClass</span>();
};

<span class="hljs-meta">#<span class="hljs-keyword">define</span> sSingletonClass SingletonClass::Instance()</span>

<span class="hljs-meta">#<span class="hljs-keyword">endif</span></span>
</code></pre>

<p>Access your singleton like this:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp">sSingletonClass-&gt;<span class="hljs-built_in">Relocate</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">5</span>);
</code></pre>
    </div></div></div></div><div id="solution24" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 24</h1><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> INS(c) private:void operator=(c const&amp;){};public:static c&amp; I(){static c _instance;return _instance;}</span>
</code></pre>

<p>Example:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp">   <span class="hljs-keyword">class</span> <span class="hljs-title class_">CCtrl</span>
    {
    <span class="hljs-keyword">private</span>:
        <span class="hljs-built_in">CCtrl</span>(<span class="hljs-type">void</span>);
        <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">CCtrl</span>(<span class="hljs-type">void</span>);

    <span class="hljs-keyword">public</span>:
        <span class="hljs-built_in">INS</span>(CCtrl);
</code></pre>
    </div></div></div></div></div></div><div class="widget"><a href="/questions/the-difference-between-bracket-and-double-bracket-for-accessing-the-elements-of-a-list-or-dataframe-1657388451711">The difference between bracket [ ] and double bracket [[ ]] for accessing the elements of a list or dataframe</a><a href="/questions/how-do-i-print-my-java-object-without-getting-%22sometype@2f92e0f4%22-1657384731950">How do I print my Java object without getting &quot;SomeType@2f92e0f4&quot;?</a><a href="/questions/how-to-replace-all-occurrences-of-a-string-in-javascript-1657384895467">How to replace all occurrences of a string in JavaScript</a><a href="/questions/why-does-this-unboundlocalerror-occur-(closure)-duplicate-1657388531538">Why does this UnboundLocalError occur (closure)? [duplicate]</a><a href="/questions/mergeflatten-an-array-of-arrays-1657387827427">Merge/flatten an array of arrays</a><a href="/questions/re.findall-behaves-weird-1657388408049">re.findall behaves weird</a><a href="/questions/how-do-i-declare-a-2d-array-in-c++-using-new-1657388441163">How do I declare a 2d array in C++ using new?</a><a href="/questions/transpose-reshape-dataframe-without-%22timevar%22-from-long-to-wide-format-1657388213347">Transpose / reshape dataframe without &quot;timevar&quot; from long to wide format</a><a href="/questions/why-does-a-regexp-with-global-flag-give-wrong-results-1657387788550">Why does a RegExp with global flag give wrong results?</a><a href="/questions/how-can-i-access-and-process-nested-objects-arrays-or-json-1657384332823">How can I access and process nested objects, arrays, or JSON?</a><a href="/questions/how-to-unnest-(explode)-a-column-in-a-pandas-dataframe-into-multiple-rows-1657387806735">How to unnest (explode) a column in a pandas DataFrame, into multiple rows</a><a href="/questions/why-are-mutable-structs-%22evil%22-1657388508974">Why are mutable structs “evil”?</a><a href="/questions/what-are-good-ways-to-prevent-sql-injection-duplicate-1657388431570">What are good ways to prevent SQL injection? [duplicate]</a><a href="/questions/how-can-i-combine-two-strings-together-in-php-1657388279401">How can I combine two strings together in PHP?</a><a href="/questions/php-failed-to-open-stream-:-no-such-file-or-directory-1657387872896">PHP - Failed to open stream : No such file or directory</a><a href="/questions/sorting-object-property-by-values-1657388367300">Sorting object property by values</a><a href="/questions/the-usestate-set-method-is-not-reflecting-a-change-immediately-1657384524775">The useState set method is not reflecting a change immediately</a><a href="/questions/how-do-i-make-a-list-of-data-frames-1657385480437">How do I make a list of data frames?</a><a href="/questions/what-is-dependency-injection-1657387953056">What is dependency injection?</a><a href="/questions/change-the-maximum-upload-file-size-1657388495156">Change the maximum upload file size</a></div></div><span class="cursor-pointer text-lg p-2" style="position:fixed;bottom:20px;left:20px;background:#000;z-index:2000;color:white">Go go top</span></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"data":{"answer":["\n\u0026lt;p\u0026gt;In 2008 I provided a C++98 implementation of the Singleton design pattern that is lazy-evaluated, guaranteed-destruction, not-technically-thread-safe:\u0026lt;br\u0026gt;\n\u0026lt;a href=\u0026quot;https://stackoverflow.com/a/271104/364696\u0026quot;\u0026gt;Can any one provide me a sample of Singleton in c++?\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Here is an updated C++11 implementation of the Singleton design pattern that is lazy-evaluated, correctly-destroyed, and \u0026lt;a href=\u0026quot;https://stackoverflow.com/a/449823/52074\u0026quot;\u0026gt;thread-safe\u0026lt;/a\u0026gt;.\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;S\u0026lt;/span\u0026gt;\n{\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt;:\n        \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;static\u0026lt;/span\u0026gt; S\u0026amp;amp; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;getInstance\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt;\n        \u0026lt;/span\u0026gt;{\n            \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;static\u0026lt;/span\u0026gt; S    instance; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Guaranteed to be destroyed.\u0026lt;/span\u0026gt;\n                                  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Instantiated on first use.\u0026lt;/span\u0026gt;\n            \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; instance;\n        }\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;private\u0026lt;/span\u0026gt;:\n        \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;S\u0026lt;/span\u0026gt;() {}                    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Constructor? (the {} brackets) are needed here.\u0026lt;/span\u0026gt;\n\n        \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// C++ 03\u0026lt;/span\u0026gt;\n        \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// ========\u0026lt;/span\u0026gt;\n        \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Don\u0026apos;t forget to declare these two. You want to make sure they\u0026lt;/span\u0026gt;\n        \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// are inaccessible(especially from outside), otherwise, you may accidentally get copies of\u0026lt;/span\u0026gt;\n        \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// your singleton appearing.\u0026lt;/span\u0026gt;\n        \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;S\u0026lt;/span\u0026gt;(S \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt;\u0026amp;amp;);              \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Don\u0026apos;t Implement\u0026lt;/span\u0026gt;\n        \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;operator\u0026lt;/span\u0026gt;=(S \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt;\u0026amp;amp;); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Don\u0026apos;t implement\u0026lt;/span\u0026gt;\n\n        \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// C++ 11\u0026lt;/span\u0026gt;\n        \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// =======\u0026lt;/span\u0026gt;\n        \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// We can use the better technique of deleting the methods\u0026lt;/span\u0026gt;\n        \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// we don\u0026apos;t want.\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt;:\n        \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;S\u0026lt;/span\u0026gt;(S \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt;\u0026amp;amp;)               = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;delete\u0026lt;/span\u0026gt;;\n        \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;operator\u0026lt;/span\u0026gt;=(S \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt;\u0026amp;amp;)  = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;delete\u0026lt;/span\u0026gt;;\n\n        \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Note: Scott Meyers mentions in his Effective Modern\u0026lt;/span\u0026gt;\n        \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//       C++ book, that deleted functions should generally\u0026lt;/span\u0026gt;\n        \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//       be public as it results in better error messages\u0026lt;/span\u0026gt;\n        \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//       due to the compilers behavior to check accessibility\u0026lt;/span\u0026gt;\n        \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//       before deleted status\u0026lt;/span\u0026gt;\n};\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;See this article about when to use a singleton: (not often)\u0026lt;br\u0026gt;\n\u0026lt;a href=\u0026quot;https://stackoverflow.com/questions/86582/singleton-how-should-it-be-used\u0026quot;\u0026gt;Singleton: How should it be used\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;See this two article about initialization order and how to cope:\u0026lt;br\u0026gt;\n\u0026lt;a href=\u0026quot;https://stackoverflow.com/questions/211237/c-static-variables-initialisation-order/211307#211307\u0026quot;\u0026gt;Static variables initialisation order\u0026lt;/a\u0026gt;\u0026lt;br\u0026gt;\n\u0026lt;a href=\u0026quot;https://stackoverflow.com/questions/335369/finding-c-static-initialization-order-problems/335746#335746\u0026quot;\u0026gt;Finding C++ static initialization order problems\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;See this article describing lifetimes:\u0026lt;br\u0026gt;\n\u0026lt;a href=\u0026quot;https://stackoverflow.com/questions/246564/what-is-the-lifetime-of-a-static-variable-in-a-c-function\u0026quot;\u0026gt;What is the lifetime of a static variable in a C++ function?\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;See this article that discusses some threading implications to singletons:\u0026lt;br\u0026gt;\n\u0026lt;a href=\u0026quot;https://stackoverflow.com/questions/449436/singleton-instance-declared-as-static-variable-of-getinstance-method/449823#449823\u0026quot;\u0026gt;Singleton instance declared as static variable of GetInstance method, is it thread-safe?\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;See this article that explains why double checked locking will not work on C++:\u0026lt;br\u0026gt;\n\u0026lt;a href=\u0026quot;https://stackoverflow.com/questions/367633/what-are-all-the-common-undefined-behaviour-that-c-programmer-should-know-about/367690#367690\u0026quot;\u0026gt;What are all the common undefined behaviours that a C++ programmer should know about?\u0026lt;/a\u0026gt;\u0026lt;br\u0026gt;\n\u0026lt;a href=\u0026quot;http://www.drdobbs.com/cpp/c-and-the-perils-of-double-checked-locki/184405726\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;Dr Dobbs: C++ and The Perils of Double-Checked Locking: Part I\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;You could avoid memory allocation. There are many variants, all having problems in case of multithreading environment.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;I prefer this kind of implementation (actually, it is not correctly said I prefer, because I avoid singletons as much as possible):\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Singleton\u0026lt;/span\u0026gt;\n{\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;private\u0026lt;/span\u0026gt;:\n   \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;Singleton\u0026lt;/span\u0026gt;();\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt;:\n   \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;static\u0026lt;/span\u0026gt; Singleton\u0026amp;amp; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;instance\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt;\n   \u0026lt;/span\u0026gt;{\n      \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;static\u0026lt;/span\u0026gt; Singleton INSTANCE;\n      \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; INSTANCE;\n   }\n};\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;It has no dynamic memory allocation.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Being a Singleton, you usually do not want it to be destructed.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;It will get torn down and deallocated when the program terminates, which is the normal, desired behavior for a singleton.  If you want to be able to explicitly clean it, it\u0026apos;s fairly easy to add a static method to the class that allows you to restore it to a clean state, and have it reallocate next time it\u0026apos;s used, but that\u0026apos;s outside of the scope of a \u0026quot;classic\u0026quot; singleton.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;\u0026lt;a href=\u0026quot;https://stackoverflow.com/a/1008289/3807729\u0026quot;\u0026gt;@Loki Astari\u0026apos;s answer\u0026lt;/a\u0026gt; is excellent. \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;However there are times with multiple static objects where you need to be able to guarantee that the \u0026lt;em\u0026gt;singleton\u0026lt;/em\u0026gt; will not be destroyed until all your static objects that use the \u0026lt;em\u0026gt;singleton\u0026lt;/em\u0026gt; no longer need it.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;In this case \u0026lt;code\u0026gt;std::shared_ptr\u0026lt;/code\u0026gt; can be used to keep the \u0026lt;em\u0026gt;singleton\u0026lt;/em\u0026gt; alive for all users even when the static destructors are being called at the end of the program:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Singleton\u0026lt;/span\u0026gt;\n{\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt;:\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;Singleton\u0026lt;/span\u0026gt;(Singleton \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt;\u0026amp;amp;) = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;delete\u0026lt;/span\u0026gt;;\n    Singleton\u0026amp;amp; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;operator\u0026lt;/span\u0026gt;=(Singleton \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt;\u0026amp;amp;) = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;delete\u0026lt;/span\u0026gt;;\n\n    \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;static\u0026lt;/span\u0026gt; std::shared_ptr\u0026amp;lt;Singleton\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;instance\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt;\n    \u0026lt;/span\u0026gt;{\n        \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;static\u0026lt;/span\u0026gt; std::shared_ptr\u0026amp;lt;Singleton\u0026amp;gt; s{\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; Singleton};\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; s;\n    }\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;private\u0026lt;/span\u0026gt;:\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;Singleton\u0026lt;/span\u0026gt;() {}\n};\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Another non-allocating alternative: create a singleton, say of class \u0026lt;code\u0026gt;C\u0026lt;/code\u0026gt;, as you need it:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;singleton\u0026lt;/span\u0026gt;\u0026amp;lt;C\u0026amp;gt;()\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;using\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;X\u0026lt;/span\u0026gt;\u0026amp;gt;\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;X\u0026amp;amp; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;singleton\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt;\n\u0026lt;/span\u0026gt;{\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;static\u0026lt;/span\u0026gt; X x;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; x;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Neither this nor Cătălin\u0026apos;s answer is automatically thread-safe in current C++, but will be in C++0x.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;I did not find a CRTP implementation among the answers, so here it is:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; HeirT\u0026amp;gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Singleton\u0026lt;/span\u0026gt;\n{\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt;:\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;Singleton\u0026lt;/span\u0026gt;() = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;delete\u0026lt;/span\u0026gt;;\n\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;Singleton\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; Singleton \u0026amp;amp;) = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;delete\u0026lt;/span\u0026gt;;\n\n    Singleton \u0026amp;amp;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;operator\u0026lt;/span\u0026gt;=(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; Singleton \u0026amp;amp;) = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;delete\u0026lt;/span\u0026gt;;\n\n    \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;static\u0026lt;/span\u0026gt; HeirT \u0026amp;amp;\u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;instance\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt;\n    \u0026lt;/span\u0026gt;{\n        \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;static\u0026lt;/span\u0026gt; HeirT instance;\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; instance;\n    }\n};\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;To use just inherit your class from this, like: \u0026lt;code\u0026gt;class Test : public Singleton\u0026amp;lt;Test\u0026amp;gt;\u0026lt;/code\u0026gt;\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;We went over this topic recently in my EECS class. If you want to look at the lecture notes in detail, visit \u0026lt;a href=\u0026quot;http://umich.edu/%7Eeecs381/lecture/IdiomsDesPattsCreational.pdf\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;http://umich.edu/~eecs381/lecture/IdiomsDesPattsCreational.pdf\u0026lt;/a\u0026gt;. These notes (and quotations I give in this answer) were created by my Professor, David Kieras.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;There are two ways that I know to create a Singleton class correctly.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;First Way:\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Implement it similar to the way you have it in your example. As for destruction, \u0026quot;Singletons usually endure for the length of the program run; most OSs will recover memory and most other resources when a program terminates, so there is an argument for not worrying about this.\u0026quot;\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;However, it is good practice to clean up at program termination. Therefore, you can do this with an auxiliary static SingletonDestructor class and declare that as a friend in your Singleton.\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Singleton\u0026lt;/span\u0026gt; {\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt;:\n  \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;static\u0026lt;/span\u0026gt; Singleton* \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;get_instance\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;;\n  \n  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// disable copy/move -- this is a Singleton\u0026lt;/span\u0026gt;\n  \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;Singleton\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; Singleton\u0026amp;amp;) = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;delete\u0026lt;/span\u0026gt;;\n  \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;Singleton\u0026lt;/span\u0026gt;(Singleton\u0026amp;amp;\u0026amp;amp;) = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;delete\u0026lt;/span\u0026gt;;\n  Singleton\u0026amp;amp; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;operator\u0026lt;/span\u0026gt;=(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; Singleton\u0026amp;amp;) = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;delete\u0026lt;/span\u0026gt;;\n  Singleton\u0026amp;amp; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;operator\u0026lt;/span\u0026gt;=(Singleton\u0026amp;amp;\u0026amp;amp;) = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;delete\u0026lt;/span\u0026gt;;\n\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;friend\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Singleton_destroyer\u0026lt;/span\u0026gt;;\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;private\u0026lt;/span\u0026gt;:\n  \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;Singleton\u0026lt;/span\u0026gt;();  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// no one else can create one\u0026lt;/span\u0026gt;\n  ~\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;Singleton\u0026lt;/span\u0026gt;(); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// prevent accidental deletion\u0026lt;/span\u0026gt;\n\n  \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;static\u0026lt;/span\u0026gt; Singleton* ptr;\n};\n\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// auxiliary static object for destroying the memory of Singleton\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Singleton_destroyer\u0026lt;/span\u0026gt; {\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt;:\n  ~Singleton_destroyer { \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;delete\u0026lt;/span\u0026gt; Singleton::ptr; }\n};\n\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// somewhere in code (Singleton.cpp is probably the best place) \u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// create a global static Singleton_destroyer object\u0026lt;/span\u0026gt;\nSingleton_destoyer the_destroyer;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;The Singleton_destroyer will be created on program startup, and \u0026quot;when program terminates, all global/static objects are destroyed by the runtime library shutdown code (inserted by the linker), so the_destroyer will be destroyed; its destructor will delete the Singleton, running its destructor.\u0026quot;\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Second Way\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;This is called the Meyers Singleton, created by C++ wizard Scott Meyers. Simply define get_instance() differently. Now you can also get rid of the pointer member variable.\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// public member function\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;static\u0026lt;/span\u0026gt; Singleton\u0026amp;amp; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;Singleton::get_instance\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt;\n\u0026lt;/span\u0026gt;{\n  \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;static\u0026lt;/span\u0026gt; Singleton s;\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; s;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;This is neat because the value returned is by reference and you can use \u0026lt;code\u0026gt;.\u0026lt;/code\u0026gt; syntax instead of \u0026lt;code\u0026gt;-\u0026amp;gt;\u0026lt;/code\u0026gt; to access member variables.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026quot;Compiler automatically builds code that creates \u0026apos;s\u0026apos; first time through the\ndeclaration, not thereafter, and then deletes the static object at program\ntermination.\u0026quot;\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Note also that with the Meyers Singleton you \u0026quot;can get into very difficult situation if objects rely on each other at the time of\ntermination - when does the Singleton disappear relative to other objects? But for simple applications, this works fine.\u0026quot;\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Here is an easy implementation.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;Windows.h\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;iostream\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;using\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;namespace\u0026lt;/span\u0026gt; std;\n\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;SingletonClass\u0026lt;/span\u0026gt; {\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt;:\n    \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;static\u0026lt;/span\u0026gt; SingletonClass* \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;getInstance\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt; \u0026lt;/span\u0026gt;{\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; (!m_instanceSingleton) ?\n        m_instanceSingleton = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; SingletonClass : \n        m_instanceSingleton;\n    }\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;private\u0026lt;/span\u0026gt;:\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// private constructor and destructor\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;SingletonClass\u0026lt;/span\u0026gt;() { cout \u0026amp;lt;\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;SingletonClass instance created!\\n\u0026quot;\u0026lt;/span\u0026gt;; }\n    ~\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;SingletonClass\u0026lt;/span\u0026gt;() {}\n\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// private copy constructor and assignment operator\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;SingletonClass\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; SingletonClass\u0026amp;amp;);\n    SingletonClass\u0026amp;amp; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;operator\u0026lt;/span\u0026gt;=(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; SingletonClass\u0026amp;amp;);\n\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;static\u0026lt;/span\u0026gt; SingletonClass *m_instanceSingleton;\n};\n\nSingletonClass* SingletonClass::m_instanceSingleton = \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;nullptr\u0026lt;/span\u0026gt;;\n\n\n\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;main\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; argc, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; * argv[])\u0026lt;/span\u0026gt; \u0026lt;/span\u0026gt;{\n\n    SingletonClass *singleton;\n    singleton = singleton-\u0026amp;gt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;getInstance\u0026lt;/span\u0026gt;();\n    cout \u0026amp;lt;\u0026amp;lt; singleton \u0026amp;lt;\u0026amp;lt; endl;\n\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Another object gets the reference of the first object!\u0026lt;/span\u0026gt;\n    SingletonClass *anotherSingleton;\n    anotherSingleton = anotherSingleton-\u0026amp;gt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;getInstance\u0026lt;/span\u0026gt;();\n    cout \u0026amp;lt;\u0026amp;lt; anotherSingleton \u0026amp;lt;\u0026amp;lt; endl;\n\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;Sleep\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;5000\u0026lt;/span\u0026gt;);\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Only one object created and this object reference is returned each and every time afterwords.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;SingletonClass instance created!\n\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;00915\u0026lt;/span\u0026gt;CB8\n\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;00915\u0026lt;/span\u0026gt;CB8\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Here 00915CB8 is the memory location of singleton Object, same for the duration of the program but (normally!) different each time the program is run.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;N.B. This is not a thread safe one.You have to ensure thread safety.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;The solution in the accepted answer has a significant drawback - the destructor for the singleton is called after the control leaves the \u0026lt;code\u0026gt;main()\u0026lt;/code\u0026gt; function. There may be problems really, when some dependent objects are allocated inside \u0026lt;code\u0026gt;main\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;I met this problem, when trying to introduce a Singleton in the Qt application. I decided, that all my setup dialogs must be Singletons, and adopted the pattern above. Unfortunately, Qt\u0026apos;s main class \u0026lt;code\u0026gt;QApplication\u0026lt;/code\u0026gt; was allocated on stack in the \u0026lt;code\u0026gt;main\u0026lt;/code\u0026gt; function, and Qt forbids creating/destroying dialogs when no application object is available.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;That is why I prefer heap-allocated singletons. I provide an explicit \u0026lt;code\u0026gt;init()\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;term()\u0026lt;/code\u0026gt; methods for all the singletons and call them inside \u0026lt;code\u0026gt;main\u0026lt;/code\u0026gt;. Thus I have a full control over the order of singletons creation/destruction, and also I guarantee that singletons will be created, no matter whether someone called \u0026lt;code\u0026gt;getInstance()\u0026lt;/code\u0026gt; or not.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Has anyone mentioned \u0026lt;code\u0026gt;std::call_once\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;std::once_flag\u0026lt;/code\u0026gt;?\nMost other approaches - including double checked locking - are broken.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;One major problem in singleton pattern implementation is safe initialization. The only safe way is to guard the initialization sequence with synchronizing barriers. But those barriers themselves need to be safely initiated. \u0026lt;code\u0026gt;std::once_flag\u0026lt;/code\u0026gt; is the mechanism to get guaranteed safe initialization.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;If you want to allocate the object in heap, why don\u0026apos;t use a unique pointer. Memory will also be deallocated since we are using a unique pointer.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;S\u0026lt;/span\u0026gt;\n{\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt;:\n        \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;static\u0026lt;/span\u0026gt; S\u0026amp;amp; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;getInstance\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt;\n        \u0026lt;/span\u0026gt;{\n            \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt;( m_s.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;get\u0026lt;/span\u0026gt;() == \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt; )\n            {\n              m_s.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;reset\u0026lt;/span\u0026gt;( \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;S\u0026lt;/span\u0026gt;() );\n            }\n            \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; *m_s;\n        }\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;private\u0026lt;/span\u0026gt;:\n        \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;static\u0026lt;/span\u0026gt; std::unique_ptr\u0026amp;lt;S\u0026amp;gt; m_s;\n\n        \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;S\u0026lt;/span\u0026gt;();\n        \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;S\u0026lt;/span\u0026gt;(S \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt;\u0026amp;amp;);            \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Don\u0026apos;t Implement\u0026lt;/span\u0026gt;\n        \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;operator\u0026lt;/span\u0026gt;=(S \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt;\u0026amp;amp;); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Don\u0026apos;t implement\u0026lt;/span\u0026gt;\n};\n\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;std::unique_ptr\u0026amp;lt;S\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;S::m_s\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;)\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;C++11 Thread safe implementation:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt; \u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;iostream\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n \u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;thread\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\n\n \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Singleton\u0026lt;/span\u0026gt;\n {\n     \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;private\u0026lt;/span\u0026gt;:\n         \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;static\u0026lt;/span\u0026gt; Singleton * _instance;\n         \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;static\u0026lt;/span\u0026gt; std::mutex mutex_;\n\n     \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;protected\u0026lt;/span\u0026gt;:\n         \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;Singleton\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; std::string value): \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;value_\u0026lt;/span\u0026gt;(value)\n         {\n         }\n         ~\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;Singleton\u0026lt;/span\u0026gt;() {}\n         std::string value_;\n\n     \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt;:\n         \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;/**\n          * Singletons should not be cloneable.\n          */\u0026lt;/span\u0026gt;\n         \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;Singleton\u0026lt;/span\u0026gt;(Singleton \u0026amp;amp;other) = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;delete\u0026lt;/span\u0026gt;;\n         \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;/**\n          * Singletons should not be assignable.\n          */\u0026lt;/span\u0026gt;\n         \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;operator\u0026lt;/span\u0026gt;=(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; Singleton \u0026amp;amp;) = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;delete\u0026lt;/span\u0026gt;;\n\n         \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//static Singleton *GetInstance(const std::string\u0026amp;amp; value);\u0026lt;/span\u0026gt;\n         \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;static\u0026lt;/span\u0026gt; Singleton *\u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;GetInstance\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; std::string\u0026amp;amp; value)\u0026lt;/span\u0026gt;\n         \u0026lt;/span\u0026gt;{\n             \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (_instance == \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;nullptr\u0026lt;/span\u0026gt;)\n             {\n                 \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;std::lock_guard\u0026amp;lt;std::mutex\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;lock\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(mutex_)\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;;\n                 \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (_instance == \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;nullptr\u0026lt;/span\u0026gt;)\n                 {\n                     _instance = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;Singleton\u0026lt;/span\u0026gt;(value);\n                 }\n             }\n             \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; _instance;\n         }\n\n         \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;std::string \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;value\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;{\n             \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; value_;\n         }\n };\n\n \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;/**\n  * Static methods should be defined outside the class.\n  */\u0026lt;/span\u0026gt;\n Singleton* Singleton::_instance = \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;nullptr\u0026lt;/span\u0026gt;;\n std::mutex Singleton::mutex_;\n\n\n \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;ThreadFoo\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;{\n     std::this_thread::\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;sleep_for\u0026lt;/span\u0026gt;(std::chrono::\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;milliseconds\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;10\u0026lt;/span\u0026gt;));\n     Singleton* singleton = Singleton::\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;GetInstance\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;FOO\u0026quot;\u0026lt;/span\u0026gt;);\n     std::cout \u0026amp;lt;\u0026amp;lt; singleton-\u0026amp;gt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;value\u0026lt;/span\u0026gt;() \u0026amp;lt;\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;\\n\u0026quot;\u0026lt;/span\u0026gt;;\n }\n\n \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;ThreadBar\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;{\n     std::this_thread::\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;sleep_for\u0026lt;/span\u0026gt;(std::chrono::\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;milliseconds\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1000\u0026lt;/span\u0026gt;));\n     Singleton* singleton = Singleton::\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;GetInstance\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;BAR\u0026quot;\u0026lt;/span\u0026gt;);\n     std::cout \u0026amp;lt;\u0026amp;lt; singleton-\u0026amp;gt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;value\u0026lt;/span\u0026gt;() \u0026amp;lt;\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;\\n\u0026quot;\u0026lt;/span\u0026gt;;\n }\n\n \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;main\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt;\n \u0026lt;/span\u0026gt;{\n     std::cout \u0026amp;lt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;If you see the same value, then singleton was reused (yay!\\n\u0026quot;\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026amp;lt;\n                 \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;If you see different values, then 2 singletons were created (booo!!)\\n\\n\u0026quot;\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026amp;lt;\n                 \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;RESULT:\\n\u0026quot;\u0026lt;/span\u0026gt;;\n     \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;std::thread \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;t1\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(ThreadFoo)\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;;\n     \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;std::thread \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;t2\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(ThreadBar)\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;;\n     t1.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;join\u0026lt;/span\u0026gt;();\n     t2.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;join\u0026lt;/span\u0026gt;();\n     std::cout \u0026amp;lt;\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Complete!\u0026quot;\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026amp;lt; std::endl;\n\n     \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;;\n }\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;It is indeed probably allocated from the heap, but without the sources there is no way of knowing.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;The typical implementation (taken from some code I have in emacs already) would be:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;Singleton * \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;Singleton::getInstance\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt; \u0026lt;/span\u0026gt;{\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (!instance) {\n        instance = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;Singleton\u0026lt;/span\u0026gt;();\n    };\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; instance;\n};\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;...and rely on the program going out of scope to clean up afterwards.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;If you work on a platform where cleanup must be done manually, I\u0026apos;d probably add a manual cleanup routine.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Another issue with doing it this way is that it isn\u0026apos;t thread-safe. In a multithreaded environment, two threads could get through the \u0026quot;if\u0026quot; before either has a chance to allocate the new instance (so both would). This still isn\u0026apos;t too big of a deal if you are relying on program termination to clean up anyway.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;In addition to the other discussion here, it may be worth noting that you can have global-ness, without limiting usage to one instance. For example, consider the case of reference counting something...\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Store\u0026lt;/span\u0026gt;{\n   std::array\u0026amp;lt;Something, 1024\u0026amp;gt; data;\n   \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;size_t\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;get\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;size_t\u0026lt;/span\u0026gt; idx)\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;{ \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;/* ... */\u0026lt;/span\u0026gt; }\n   \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;incr_ref\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;size_t\u0026lt;/span\u0026gt; idx)\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;{ \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;/* ... */\u0026lt;/span\u0026gt;}\n   \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;decr_ref\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;size_t\u0026lt;/span\u0026gt; idx)\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;{ \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;/* ... */\u0026lt;/span\u0026gt;}\n};\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt;\u0026amp;lt;Store* store_p\u0026amp;gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;ItemRef\u0026lt;/span\u0026gt;{\n   \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;size_t\u0026lt;/span\u0026gt; idx;\n   \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;auto\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;get\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;{ \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; store_p-\u0026amp;gt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;get\u0026lt;/span\u0026gt;(idx); };\n   \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;ItemRef\u0026lt;/span\u0026gt;() { store_p-\u0026amp;gt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;incr_ref\u0026lt;/span\u0026gt;(idx); };\n   ~\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;ItemRef\u0026lt;/span\u0026gt;() { store_p-\u0026amp;gt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;decr_ref\u0026lt;/span\u0026gt;(idx); };\n};\n\nStore store1_g;\nStore store2_g; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// we don\u0026apos;t restrict the number of global Store instances\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Now somewhere inside a function (such as \u0026lt;code\u0026gt;main\u0026lt;/code\u0026gt;) you can do:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;auto\u0026lt;/span\u0026gt; ref1_a = \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;ItemRef\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026amp;amp;store1_g\u0026amp;gt;(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;101\u0026lt;/span\u0026gt;);\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;auto\u0026lt;/span\u0026gt; ref2_a = \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;ItemRef\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026amp;amp;store2_g\u0026amp;gt;(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;201\u0026lt;/span\u0026gt;); \n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;The refs don\u0026apos;t need to store a pointer back to their respective \u0026lt;code\u0026gt;Store\u0026lt;/code\u0026gt; because that information is supplied at compile-time. You also don\u0026apos;t have to worry about the \u0026lt;code\u0026gt;Store\u0026lt;/code\u0026gt;\u0026apos;s lifetime because the compiler requires that it is global.  If there is indeed only one instance of \u0026lt;code\u0026gt;Store\u0026lt;/code\u0026gt; then there\u0026apos;s no overhead in this approach; with more than one instance it\u0026apos;s up to the compiler to be clever about code generation. If necessary, the \u0026lt;code\u0026gt;ItemRef\u0026lt;/code\u0026gt; class can even be made a \u0026lt;code\u0026gt;friend\u0026lt;/code\u0026gt; of \u0026lt;code\u0026gt;Store\u0026lt;/code\u0026gt; (you can have templated friends!).\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;If \u0026lt;code\u0026gt;Store\u0026lt;/code\u0026gt; itself is a templated class then things get messier, but it is still possible to use this method, perhaps by implementing a helper class with the following signature:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; Store_t, Store_t* store_p\u0026amp;gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;StoreWrapper\u0026lt;/span\u0026gt;{ \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;/* stuff to access store_p, e.g. methods returning \n                       instances of ItemRef\u0026amp;lt;Store_t, store_p\u0026amp;gt;. */\u0026lt;/span\u0026gt; };\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;The user can now create a \u0026lt;code\u0026gt;StoreWrapper\u0026lt;/code\u0026gt; type (and global instance) for each global \u0026lt;code\u0026gt;Store\u0026lt;/code\u0026gt; instance, and always access the stores via their wrapper instance (thus forgetting about the gory details of the template parameters needed for using \u0026lt;code\u0026gt;Store\u0026lt;/code\u0026gt;).\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Here is a \u0026lt;a href=\u0026quot;https://github.com/canonical/multipass/blob/7d3de5fb1a4402b4438dae4806677fdd6c776450/include/multipass/singleton.h\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;mockable singleton\u0026lt;/a\u0026gt; using \u0026lt;a href=\u0026quot;https://en.wikipedia.org/wiki/Curiously_recurring_template_pattern\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;CRTP\u0026lt;/a\u0026gt;. It relies on \u0026lt;a href=\u0026quot;https://github.com/canonical/multipass/blob/7d3de5fb1a4402b4438dae4806677fdd6c776450/include/multipass/private_pass_provider.h\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;a little helper\u0026lt;/a\u0026gt; to enforce a single object at any one time (at most). To enforce a single object over program execution, remove the reset (which we find useful for tests).\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;A \u0026lt;code\u0026gt;ConcreteSinleton\u0026lt;/code\u0026gt; can be implemented like this:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;ConcreteSingleton\u0026lt;/span\u0026gt; : \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; Singleton\u0026amp;lt;ConcreteSingleton\u0026amp;gt;\n{\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt;:\n  \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;ConcreteSingleton\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; Singleton\u0026amp;lt;ConcreteSingleton\u0026amp;gt;::PrivatePass\u0026amp;amp;)\n      : Singleton\u0026amp;lt;StandardPaths\u0026amp;gt;::Singleton{pass}\n  {}\n  \n  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// ... concrete interface\u0026lt;/span\u0026gt;\n  \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;f\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; \u0026lt;/span\u0026gt;{\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;42\u0026lt;/span\u0026gt;;}\n\n};\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;And then used with\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;ConcreteSingleton::\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;instance\u0026lt;/span\u0026gt;().\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;f\u0026lt;/span\u0026gt;();\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;This is about object life-time management. Suppose you have more than singletons in your software. And they depend on Logger singleton. During application destruction, suppose another singleton object uses Logger to log its destruction steps. You have to guarantee that Logger should be cleaned up last. Therefore, please also check out this paper:\n\u0026lt;a href=\u0026quot;http://www.cs.wustl.edu/~schmidt/PDF/ObjMan.pdf\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;http://www.cs.wustl.edu/~schmidt/PDF/ObjMan.pdf\u0026lt;/a\u0026gt; \u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;My implementation is similar to Galik\u0026apos;s. The difference is my implementation allows the shared pointers to clean up allocated memory, as opposed to holding onto the memory until the application is exited and the static pointers are cleaned up.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;pragma\u0026lt;/span\u0026gt; once\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;memory\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; T\u0026amp;gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Singleton\u0026lt;/span\u0026gt;\n{\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;private\u0026lt;/span\u0026gt;:\n  \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;static\u0026lt;/span\u0026gt; std::weak_ptr\u0026amp;lt;T\u0026amp;gt; _singleton;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt;:\n  \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;static\u0026lt;/span\u0026gt; std::shared_ptr\u0026amp;lt;T\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;singleton\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt;\n  \u0026lt;/span\u0026gt;{\n    std::shared_ptr\u0026amp;lt;T\u0026amp;gt; singleton = _singleton.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;lock\u0026lt;/span\u0026gt;();\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (!singleton) \n    {\n      singleton.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;reset\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;T\u0026lt;/span\u0026gt;());\n      _singleton = singleton;\n    }\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; singleton;\n  }\n};\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; T\u0026amp;gt;\nstd::weak_ptr\u0026amp;lt;T\u0026amp;gt; Singleton\u0026amp;lt;T\u0026amp;gt;::_singleton;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Your code is correct, except that \u0026lt;em\u0026gt;you didn\u0026apos;t declare the instance pointer outside the class\u0026lt;/em\u0026gt;. The inside class declarations of static variables are not considered declarations in C++, however this is allowed in other languages like \u0026lt;strong\u0026gt;C#\u0026lt;/strong\u0026gt; or \u0026lt;strong\u0026gt;Java\u0026lt;/strong\u0026gt; etc.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Singleton\u0026lt;/span\u0026gt;\n{\n   \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt;:\n       \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;static\u0026lt;/span\u0026gt; Singleton* \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;getInstance\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;( )\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;;\n   \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;private\u0026lt;/span\u0026gt;:\n       \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;Singleton\u0026lt;/span\u0026gt;( );\n       \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;static\u0026lt;/span\u0026gt; Singleton* instance;\n};\nSingleton* Singleton::instance; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//we need to declare outside because static variables are global\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;You must know that Singleton instance \u0026lt;em\u0026gt;doesn\u0026apos;t need to be manually deleted by us\u0026lt;/em\u0026gt;. We need a single object of it throughout the whole program, so \u0026lt;em\u0026gt;at the end of program execution, it will be automatically deallocated.\u0026lt;/em\u0026gt;\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Here is my view on how to do proper singletons (and other non-trivial static objects): \u0026lt;a href=\u0026quot;https://github.com/alex4747-pub/proper_singleton\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;https://github.com/alex4747-pub/proper_singleton\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Summary:\u0026lt;/p\u0026gt;\n\u0026lt;ol\u0026gt;\n\u0026lt;li\u0026gt;Use static initialization list to instantiate singletons at the right time: after entering main and before enabling multi-threading\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Add minor improvements to make it unit-test friendly.\u0026lt;/li\u0026gt;\n\u0026lt;/ol\u0026gt;\n    ","\n\u0026lt;p\u0026gt;I would like to show here another example of a singleton in C++. It makes sense to use template programming. Besides, it makes sense to derive your singleton class from a not copyable and not movabe classes. Here how it looks like in the code:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;iostream\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;string\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;DoNotCopy\u0026lt;/span\u0026gt;\n{\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;protected\u0026lt;/span\u0026gt;:\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;DoNotCopy\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt;) = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;default\u0026lt;/span\u0026gt;;\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;DoNotCopy\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; DoNotCopy\u0026amp;amp;) = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;delete\u0026lt;/span\u0026gt;;\n    DoNotCopy\u0026amp;amp; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;operator\u0026lt;/span\u0026gt;=(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; DoNotCopy\u0026amp;amp;) = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;delete\u0026lt;/span\u0026gt;;\n};\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;DoNotMove\u0026lt;/span\u0026gt;\n{\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;protected\u0026lt;/span\u0026gt;:\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;DoNotMove\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt;) = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;default\u0026lt;/span\u0026gt;;\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;DoNotMove\u0026lt;/span\u0026gt;(DoNotMove\u0026amp;amp;\u0026amp;amp;) = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;delete\u0026lt;/span\u0026gt;;\n    DoNotMove\u0026amp;amp; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;operator\u0026lt;/span\u0026gt;=(DoNotMove\u0026amp;amp;\u0026amp;amp;) = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;delete\u0026lt;/span\u0026gt;;\n};\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;DoNotCopyMove\u0026lt;/span\u0026gt; : \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; DoNotCopy,\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; DoNotMove\n{\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;protected\u0026lt;/span\u0026gt;:\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;DoNotCopyMove\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt;) = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;default\u0026lt;/span\u0026gt;;\n};\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;T\u0026lt;/span\u0026gt;\u0026amp;gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Singleton\u0026lt;/span\u0026gt; : \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; DoNotCopyMove\n{\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt;:\n    \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;static\u0026lt;/span\u0026gt; T\u0026amp;amp; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;Instance\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt;)\u0026lt;/span\u0026gt;\n    \u0026lt;/span\u0026gt;{\n        \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;static\u0026lt;/span\u0026gt; T instance;\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; instance;\n    }\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;protected\u0026lt;/span\u0026gt;:\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;Singleton\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt;) = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;default\u0026lt;/span\u0026gt;;\n};\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Logger\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;final\u0026lt;/span\u0026gt;: \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; Singleton\u0026amp;lt;Logger\u0026amp;gt;\n{\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt;:\n    \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;log\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; std::string\u0026amp;amp; str)\u0026lt;/span\u0026gt; \u0026lt;/span\u0026gt;{ std::cout \u0026amp;lt;\u0026amp;lt; str \u0026amp;lt;\u0026amp;lt; std::endl; }\n};\n\n\n\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;main\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt;\n\u0026lt;/span\u0026gt;{\n    Logger::\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;Instance\u0026lt;/span\u0026gt;().\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;log\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;xx\u0026quot;\u0026lt;/span\u0026gt;);\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;The splitting into NotCopyable and NotMovable clases allows you to define your singleton more specific (sometimes you want to move your single instance).\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;It restrict instantiation of a class to one object. This is useful when exactly one object is needed to coordinate actions across the system\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Singleton\u0026lt;/span\u0026gt; {\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;private\u0026lt;/span\u0026gt;:\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; data;\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;static\u0026lt;/span\u0026gt; Singleton* instance;\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;Singleton\u0026lt;/span\u0026gt;();\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt;:\n    \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;static\u0026lt;/span\u0026gt; Singleton* \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;getInstance\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;;\n};\nSingleton* Singleton::instance = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;;\nSingleton::\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;Singleton\u0026lt;/span\u0026gt;()\n{\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;this\u0026lt;/span\u0026gt;-\u0026amp;gt;data = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;;\n    cout \u0026amp;lt;\u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;constructor called..\u0026quot;\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026amp;lt; endl;\n}\n\n \n\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;Singleton* \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;Singleton::getInstance\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt; \u0026lt;/span\u0026gt;{\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (!instance) {\n        instance = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;Singleton\u0026lt;/span\u0026gt;();\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; instance;\n    }\n}\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;main\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt; \u0026lt;/span\u0026gt;{\n    Singleton *s = s-\u0026amp;gt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;getInstance\u0026lt;/span\u0026gt;();\n    Singleton *s1 =s1-\u0026amp;gt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;getInstance\u0026lt;/span\u0026gt;();\n    }\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;The paper that was linked to above describes the shortcoming of double checked locking is that the compiler may allocate the memory for the object and set a pointer to the address of the allocated memory, before the object\u0026apos;s constructor has been called. It is quite easy in c++ however to use allocaters to allocate the memory manually, and then use a construct call to initialize the memory. Using this appraoch, the double-checked locking works just fine.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Simple singleton class, This must be your header class file\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;ifndef\u0026lt;/span\u0026gt; SC_SINGLETON_CLASS_H\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;define\u0026lt;/span\u0026gt; SC_SINGLETON_CLASS_H\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;SingletonClass\u0026lt;/span\u0026gt;\n{\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt;:\n        \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;static\u0026lt;/span\u0026gt; SingletonClass* \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;Instance\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt;\n        \u0026lt;/span\u0026gt;{\n           \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;static\u0026lt;/span\u0026gt; SingletonClass* instance = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;SingletonClass\u0026lt;/span\u0026gt;();\n           \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; instance;\n        }\n\n        \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;Relocate\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; X, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; Y, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; Z)\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;;\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;private\u0026lt;/span\u0026gt;:\n        \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;SingletonClass\u0026lt;/span\u0026gt;();\n        ~\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;SingletonClass\u0026lt;/span\u0026gt;();\n};\n\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;define\u0026lt;/span\u0026gt; sSingletonClass SingletonClass::Instance()\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;endif\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Access your singleton like this:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;sSingletonClass-\u0026amp;gt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;Relocate\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;5\u0026lt;/span\u0026gt;);\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;define\u0026lt;/span\u0026gt; INS(c) private:void operator=(c const\u0026amp;amp;){};public:static c\u0026amp;amp; I(){static c _instance;return _instance;}\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Example:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;   \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;CCtrl\u0026lt;/span\u0026gt;\n    {\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;private\u0026lt;/span\u0026gt;:\n        \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;CCtrl\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt;);\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;virtual\u0026lt;/span\u0026gt; ~\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;CCtrl\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt;);\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt;:\n        \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;INS\u0026lt;/span\u0026gt;(CCtrl);\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    "],"id":388,"title":"C++ Singleton design pattern","content":"\n                \n\u0026lt;p\u0026gt;Recently I\u0026apos;ve bumped into a realization/implementation of the Singleton design pattern for C++. It has looked like this (I have adopted it from the real-life example):\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// a lot of methods are omitted here\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Singleton\u0026lt;/span\u0026gt;\n{\n   \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt;:\n       \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;static\u0026lt;/span\u0026gt; Singleton* \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;getInstance\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;( )\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;;\n       ~\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;Singleton\u0026lt;/span\u0026gt;( );\n   \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;private\u0026lt;/span\u0026gt;:\n       \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;Singleton\u0026lt;/span\u0026gt;( );\n       \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;static\u0026lt;/span\u0026gt; Singleton* instance;\n};\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;From this declaration, I can deduce that the instance field is initiated on the heap. That means there is a memory allocation. What is completely unclear for me is when exactly the memory is going to be deallocated? Or is there a bug and memory leak? It seems like there is a problem with the implementation.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;My main question is, how do I implement it in the right way?\u0026lt;/p\u0026gt;\n    ","slug":"c++-singleton-design-pattern-1657387830040","postType":"QUESTION","createdAt":"2022-07-09T17:30:30.000Z","updatedAt":"2022-07-09T17:30:30.000Z","tags":[],"relatedQuestions":[]},"randomQuestions":[{"title":"The difference between bracket [ ] and double bracket [[ ]] for accessing the elements of a list or dataframe","slug":"the-difference-between-bracket-and-double-bracket-for-accessing-the-elements-of-a-list-or-dataframe-1657388451711"},{"title":"How do I print my Java object without getting \"SomeType@2f92e0f4\"?","slug":"how-do-i-print-my-java-object-without-getting-\"sometype@2f92e0f4\"-1657384731950"},{"title":"How to replace all occurrences of a string in JavaScript","slug":"how-to-replace-all-occurrences-of-a-string-in-javascript-1657384895467"},{"title":"Why does this UnboundLocalError occur (closure)? [duplicate]","slug":"why-does-this-unboundlocalerror-occur-(closure)-duplicate-1657388531538"},{"title":"Merge/flatten an array of arrays","slug":"mergeflatten-an-array-of-arrays-1657387827427"},{"title":"re.findall behaves weird","slug":"re.findall-behaves-weird-1657388408049"},{"title":"How do I declare a 2d array in C++ using new?","slug":"how-do-i-declare-a-2d-array-in-c++-using-new-1657388441163"},{"title":"Transpose / reshape dataframe without \"timevar\" from long to wide format","slug":"transpose-reshape-dataframe-without-\"timevar\"-from-long-to-wide-format-1657388213347"},{"title":"Why does a RegExp with global flag give wrong results?","slug":"why-does-a-regexp-with-global-flag-give-wrong-results-1657387788550"},{"title":"How can I access and process nested objects, arrays, or JSON?","slug":"how-can-i-access-and-process-nested-objects-arrays-or-json-1657384332823"},{"title":"How to unnest (explode) a column in a pandas DataFrame, into multiple rows","slug":"how-to-unnest-(explode)-a-column-in-a-pandas-dataframe-into-multiple-rows-1657387806735"},{"title":"Why are mutable structs “evil”?","slug":"why-are-mutable-structs-\"evil\"-1657388508974"},{"title":"What are good ways to prevent SQL injection? [duplicate]","slug":"what-are-good-ways-to-prevent-sql-injection-duplicate-1657388431570"},{"title":"How can I combine two strings together in PHP?","slug":"how-can-i-combine-two-strings-together-in-php-1657388279401"},{"title":"PHP - Failed to open stream : No such file or directory","slug":"php-failed-to-open-stream-:-no-such-file-or-directory-1657387872896"},{"title":"Sorting object property by values","slug":"sorting-object-property-by-values-1657388367300"},{"title":"The useState set method is not reflecting a change immediately","slug":"the-usestate-set-method-is-not-reflecting-a-change-immediately-1657384524775"},{"title":"How do I make a list of data frames?","slug":"how-do-i-make-a-list-of-data-frames-1657385480437"},{"title":"What is dependency injection?","slug":"what-is-dependency-injection-1657387953056"},{"title":"Change the maximum upload file size","slug":"change-the-maximum-upload-file-size-1657388495156"}]},"__N_SSG":true},"page":"/questions/[slug]","query":{"slug":"c++-singleton-design-pattern-1657387830040"},"buildId":"eGqQHYKGZKE-nXShFn8wX","isFallback":false,"gsp":true,"locale":"en","locales":["en"],"defaultLocale":"en","scriptLoader":[]}</script></body></html>