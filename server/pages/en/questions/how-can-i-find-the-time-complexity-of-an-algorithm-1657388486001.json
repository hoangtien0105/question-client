{"pageProps":{"data":{"answer":["\n&lt;blockquote&gt;\n  &lt;p&gt;How to find time complexity of an algorithm&lt;/p&gt;\n&lt;/blockquote&gt;\n\n&lt;p&gt;You add up how many machine instructions it will execute as a function of the size of its input, and then simplify the expression to the largest (when N is very large) term  and can include any simplifying constant factor.&lt;/p&gt;\n\n&lt;p&gt;For example, lets see how we simplify &lt;code&gt;2N + 2&lt;/code&gt; machine instructions to describe this as just &lt;code&gt;O(N)&lt;/code&gt;.&lt;/p&gt;\n\n&lt;p&gt;&lt;strong&gt;Why do we remove the two &lt;code&gt;2&lt;/code&gt;s ?&lt;/strong&gt;&lt;/p&gt;\n\n&lt;p&gt;We are interested in the performance of the algorithm as N becomes large.&lt;/p&gt;\n\n&lt;p&gt;Consider the two terms 2N and 2. &lt;/p&gt;\n\n&lt;p&gt;What is the relative influence of these two terms as N becomes large? Suppose N is a million.&lt;/p&gt;\n\n&lt;p&gt;Then the first term is 2 million and the second term is only 2.&lt;/p&gt;\n\n&lt;p&gt;For this reason, we drop all but the largest terms for large N.&lt;/p&gt;\n\n&lt;p&gt;So, now we have gone from &lt;code&gt;2N + 2&lt;/code&gt; to &lt;code&gt;2N&lt;/code&gt;.&lt;/p&gt;\n\n&lt;p&gt;Traditionally, we are only interested in performance &lt;em&gt;up to constant factors&lt;/em&gt;. &lt;/p&gt;\n\n&lt;p&gt;This means that we don&apos;t really care if there is some constant multiple of difference in performance when N is large.  The unit of 2N is not well-defined in the first place anyway.  So we can multiply or divide by a constant factor to get to the simplest expression.&lt;/p&gt;\n\n&lt;p&gt;So &lt;code&gt;2N&lt;/code&gt; becomes just &lt;code&gt;N&lt;/code&gt;.&lt;/p&gt;\n    ","\n&lt;p&gt;This is an excellent article: &lt;em&gt;&lt;a href=&quot;http://www.daniweb.com/software-development/computer-science/threads/13488/time-complexity-of-algorithm&quot; rel=&quot;nofollow noreferrer&quot;&gt;Time complexity of algorithm&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;The below answer is copied from above (in case the excellent link goes bust)&lt;/strong&gt;&lt;/p&gt;\n&lt;p&gt;The most common metric for calculating time complexity is Big O notation. This removes all constant factors so that the running time can be estimated in relation to N as N approaches infinity. In general you can think of it like this:&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;statement;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;Is constant. The running time of the statement will not change in relation to N.&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;for ( i = 0; i &amp;lt; N; i++ )\n     statement;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;Is linear. The running time of the loop is directly proportional to N. When N doubles, so does the running time.&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;for ( i = 0; i &amp;lt; N; i++ ) {\n  for ( j = 0; j &amp;lt; N; j++ )\n    statement;\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;Is quadratic. The running time of the two loops is proportional to the square of N. When N doubles, the running time increases by N * N.&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;while ( low &amp;lt;= high ) {\n  mid = ( low + high ) / 2;\n  if ( target &amp;lt; list[mid] )\n    high = mid - 1;\n  else if ( target &amp;gt; list[mid] )\n    low = mid + 1;\n  else break;\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;Is logarithmic. The running time of the algorithm is proportional to the number of times N can be divided by 2. This is because the algorithm divides the working area in half with each iteration.&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;void quicksort (int list[], int left, int right)\n{\n  int pivot = partition (list, left, right);\n  quicksort(list, left, pivot - 1);\n  quicksort(list, pivot + 1, right);\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;Is N * log (N). The running time consists of N loops (iterative or recursive) that are logarithmic, thus the algorithm is a combination of linear and logarithmic.&lt;/p&gt;\n&lt;p&gt;In general, doing something with every item in one dimension is linear, doing something with every item in two dimensions is quadratic, and dividing the working area in half is logarithmic. There are other Big O measures such as cubic, exponential, and square root, but they&apos;re not nearly as common. Big O notation is described as &lt;code&gt;O ( &amp;lt;type&amp;gt; )&lt;/code&gt; where &lt;code&gt;&amp;lt;type&amp;gt;&lt;/code&gt; is the measure. The quicksort algorithm would be described as &lt;code&gt;O (N * log(N ))&lt;/code&gt;.&lt;/p&gt;\n&lt;p&gt;Note that none of this has taken into account best, average, and worst case measures. Each would have its own Big O notation. Also note that this is a VERY simplistic explanation. Big O is the most common, but it&apos;s also more complex that I&apos;ve shown. There are also other notations such as big omega, little o, and big theta. You probably won&apos;t encounter them outside of an algorithm analysis course. ;)&lt;/p&gt;\n    ","\n&lt;p&gt;Taken from here - &lt;a href=&quot;https://web.archive.org/web/20140929181245/http://careerbaba.in/2014/01/introduction-to-time-complexity-of-an-algorithm/&quot; rel=&quot;nofollow noreferrer&quot;&gt;Introduction to Time Complexity of an Algorithm&lt;/a&gt;&lt;/p&gt;\n&lt;h2&gt;1. Introduction&lt;/h2&gt;\n&lt;p&gt;In computer science, the time complexity of an algorithm quantifies the amount of time taken by an algorithm to run as a function of the length of the string representing the input.&lt;/p&gt;\n&lt;h2&gt;2. Big O notation&lt;/h2&gt;\n&lt;p&gt;The time complexity of an algorithm is commonly expressed using big O notation, which excludes coefficients and lower order terms. When expressed this way, the time complexity is said to be described asymptotically, i.e., as the input size goes to infinity.&lt;/p&gt;\n&lt;p&gt;For example, if the time required by an algorithm on all inputs of size n is at most 5n&lt;sup&gt;3&lt;/sup&gt; + 3n, the asymptotic time complexity is O(n&lt;sup&gt;3&lt;/sup&gt;). More on that later.&lt;/p&gt;\n&lt;p&gt;A few more examples:&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;1 = O(n)&lt;/li&gt;\n&lt;li&gt;n = O(n&lt;sup&gt;2&lt;/sup&gt;)&lt;/li&gt;\n&lt;li&gt;log(n) = O(n)&lt;/li&gt;\n&lt;li&gt;2 n + 1 = O(n)&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h2&gt;3. O(1) constant time:&lt;/h2&gt;\n&lt;p&gt;An algorithm is said to run in constant time if it requires the same amount of time regardless of the input size.&lt;/p&gt;\n&lt;p&gt;Examples:&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;array: accessing any element&lt;/li&gt;\n&lt;li&gt;fixed-size stack: push and pop methods&lt;/li&gt;\n&lt;li&gt;fixed-size queue: enqueue and dequeue methods&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h2&gt;4. O(n) linear time&lt;/h2&gt;\n&lt;p&gt;An algorithm is said to run in linear time if its time execution is directly proportional to the input size, i.e. time grows linearly as input size increases.&lt;/p&gt;\n&lt;p&gt;Consider the following examples. Below I am linearly searching for an element, and this has a time complexity of O(n).&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;int find = 66;\nvar numbers = new int[] { 33, 435, 36, 37, 43, 45, 66, 656, 2232 };\nfor (int i = 0; i &amp;lt; numbers.Length - 1; i++)\n{\n    if(find == numbers[i])\n    {\n        return;\n    }\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;More Examples:&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;Array: Linear Search, Traversing, Find minimum etc&lt;/li&gt;\n&lt;li&gt;ArrayList: contains method&lt;/li&gt;\n&lt;li&gt;Queue: contains method&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h2&gt;5. O(log n) logarithmic time:&lt;/h2&gt;\n&lt;p&gt;An algorithm is said to run in logarithmic time if its time execution is proportional to the logarithm of the input size.&lt;/p&gt;\n&lt;p&gt;Example: &lt;a href=&quot;http://en.wikipedia.org/wiki/Binary_search&quot; rel=&quot;nofollow noreferrer&quot;&gt;Binary Search&lt;/a&gt;&lt;/p&gt;\n&lt;p&gt;Recall the &quot;twenty questions&quot; game - the task is to guess the value of a hidden number in an interval. Each time you make a guess, you are told whether your guess is too high or too low. Twenty questions game implies a strategy that uses your guess number to halve the interval size. This is an example of the general problem-solving method known as binary search.&lt;/p&gt;\n&lt;h2&gt;6. O(n&lt;sup&gt;2&lt;/sup&gt;) quadratic time&lt;/h2&gt;\n&lt;p&gt;An algorithm is said to run in quadratic time if its time execution is proportional to the square of the input size.&lt;/p&gt;\n&lt;p&gt;Examples:&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Bubble_sort&quot; rel=&quot;nofollow noreferrer&quot;&gt;Bubble Sort&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Selection_sort&quot; rel=&quot;nofollow noreferrer&quot;&gt;Selection Sort&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Insertion_Sort&quot; rel=&quot;nofollow noreferrer&quot;&gt;Insertion Sort&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h2&gt;7. Some useful links&lt;/h2&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=&quot;http://ssp.impulsetrain.com/big-o.html&quot; rel=&quot;nofollow noreferrer&quot;&gt;Big-O Misconceptions&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=&quot;http://philipstel.wordpress.com/2011/03/07/determining-the-complexity-of-an-algorithm-the-basic-part/&quot; rel=&quot;nofollow noreferrer&quot;&gt;Determining The Complexity Of Algorithm&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=&quot;http://bigocheatsheet.com/&quot; rel=&quot;nofollow noreferrer&quot;&gt;Big O Cheat Sheet&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n    ","\n&lt;p&gt;Several examples of &lt;em&gt;loop&lt;/em&gt;.&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;O(n)&lt;/strong&gt; &lt;em&gt;time complexity&lt;/em&gt; of a loop is considered as &lt;em&gt;O(n)&lt;/em&gt; if the loop variables is incremented / decremented by a constant amount. For example following functions have &lt;em&gt;O(n)&lt;/em&gt; time complexity.&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;  // Here c is a positive integer constant\n  for (int i = 1; i &amp;lt;= n; i += c) {\n      // some O(1) expressions\n  }\n\n  for (int i = n; i &amp;gt; 0; i -= c) {\n      // some O(1) expressions\n  }\n&lt;/code&gt;&lt;/pre&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;O(n&lt;sup&gt;c&lt;/sup&gt;)&lt;/strong&gt; time complexity of nested loops is equal to the number of times the innermost statement is executed. For example, the following sample loops have &lt;em&gt;O(n&lt;sup&gt;2&lt;/sup&gt;)&lt;/em&gt; time complexity&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;  for (int i = 1; i &amp;lt;=n; i += c) {\n     for (int j = 1; j &amp;lt;=n; j += c) {\n        // some O(1) expressions\n     }\n  }\n\n  for (int i = n; i &amp;gt; 0; i += c) {\n     for (int j = i+1; j &amp;lt;=n; j += c) {\n        // some O(1) expressions\n  }\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;For example, &lt;a href=&quot;https://en.wikipedia.org/wiki/Selection_sort&quot; rel=&quot;nofollow noreferrer&quot;&gt;selection sort&lt;/a&gt; and &lt;a href=&quot;https://en.wikipedia.org/wiki/Insertion_sort&quot; rel=&quot;nofollow noreferrer&quot;&gt;insertion sort&lt;/a&gt; have &lt;em&gt;O(n&lt;sup&gt;2&lt;/sup&gt;)&lt;/em&gt; time complexity.&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;O(log n)&lt;/strong&gt; time complexity of a loop is considered as &lt;em&gt;O(log&amp;nbsp;n)&lt;/em&gt; if the loop variables is divided / multiplied by a constant amount.&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;  for (int i = 1; i &amp;lt;=n; i *= c) {\n     // some O(1) expressions\n  }\n  for (int i = n; i &amp;gt; 0; i /= c) {\n     // some O(1) expressions\n  }\n\nFor example, [binary search][3] has _O(log&amp;amp;nbsp;n)_ time complexity.\n&lt;/code&gt;&lt;/pre&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;O(log log n)&lt;/strong&gt; time complexity of a loop is considered as &lt;em&gt;O(log&amp;nbsp;log&amp;nbsp;n)&lt;/em&gt; if the loop variables is reduced / increased exponentially by a constant amount.&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;  // Here c is a constant greater than 1\n  for (int i = 2; i &amp;lt;=n; i = pow(i, c)) {\n     // some O(1) expressions\n  }\n  //Here fun is sqrt or cuberoot or any other constant root\n  for (int i = n; i &amp;gt; 0; i = fun(i)) {\n     // some O(1) expressions\n  }\n&lt;/code&gt;&lt;/pre&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;hr&gt;\n&lt;p&gt;One example of time complexity analysis&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;int fun(int n)\n{\n    for (int i = 1; i &amp;lt;= n; i++)\n    {\n        for (int j = 1; j &amp;lt; n; j += i)\n        {\n            // Some O(1) task\n        }\n    }\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;&lt;strong&gt;Analysis&lt;/strong&gt;:&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;For i = 1, the inner loop is executed n times.\nFor i = 2, the inner loop is executed approximately n/2 times.\nFor i = 3, the inner loop is executed approximately n/3 times.\nFor i = 4, the inner loop is executed approximately n/4 times.\n.\nFor i = n, the inner loop is executed approximately n/n times.\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;So the total time complexity of the above algorithm is &lt;code&gt;(n + n/2 + n/3 +  + n/n)&lt;/code&gt;, which becomes &lt;code&gt;n * (1/1 + 1/2 + 1/3 +  + 1/n)&lt;/code&gt;&lt;/p&gt;\n&lt;p&gt;The important thing about series &lt;code&gt;(1/1 + 1/2 + 1/3 +  + 1/n)&lt;/code&gt; is around to &lt;em&gt;O(log&amp;nbsp;n)&lt;/em&gt;. So the time complexity of the above code is &lt;em&gt;O(n·log&amp;nbsp;n)&lt;/em&gt;.&lt;/p&gt;\n&lt;hr&gt;\n&lt;p&gt;References:&lt;/p&gt;\n&lt;p&gt;&lt;a href=&quot;http://discrete.gr/complexity/&quot; rel=&quot;nofollow noreferrer&quot;&gt;1&lt;/a&gt;\n&lt;a href=&quot;http://www.geeksforgeeks.org/analysis-of-algorithms-set-4-analysis-of-loops/&quot; rel=&quot;nofollow noreferrer&quot;&gt;2&lt;/a&gt;\n&lt;a href=&quot;http://www.geeksforgeeks.org/interesting-time-complexity-question/&quot; rel=&quot;nofollow noreferrer&quot;&gt;3&lt;/a&gt;&lt;/p&gt;\n    ","\n&lt;h2&gt;Time complexity with examples&lt;/h2&gt;\n&lt;p&gt;1 - Basic operations (arithmetic, comparisons, accessing arrays elements, assignment): The running time is always constant O(1)&lt;/p&gt;\n&lt;p&gt;Example:&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;read(x)                               // O(1)\na = 10;                               // O(1)\na = 1,000,000,000,000,000,000         // O(1)\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;2 - If then else statement: Only taking the maximum running time from two or more possible statements.&lt;/p&gt;\n&lt;p&gt;Example:&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;age = read(x)                               // (1+1) = 2\nif age &amp;lt; 17 then begin                      // 1\n      status = &quot;Not allowed!&quot;;              // 1\nend else begin\n      status = &quot;Welcome! Please come in&quot;;   // 1\n      visitors = visitors + 1;              // 1+1 = 2\nend;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;So, the complexity of the above pseudo code is T(n) = 2 + 1 + max(1, 1+2) = 6. Thus, its big oh is still constant T(n) = O(1).&lt;/p&gt;\n&lt;p&gt;3 - Looping (&lt;em&gt;for&lt;/em&gt;, &lt;em&gt;while&lt;/em&gt;, &lt;em&gt;repeat&lt;/em&gt;): Running time for this statement is the number of loops multiplied by the number of operations inside that looping.&lt;/p&gt;\n&lt;p&gt;Example:&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;total = 0;                                  // 1\nfor i = 1 to n do begin                     // (1+1)*n = 2n\n      total = total + i;                    // (1+1)*n = 2n\nend;\nwriteln(total);                             // 1\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;So, its complexity is T(n) = 1+4n+1 = 4n + 2. Thus, T(n) = O(n).&lt;/p&gt;\n&lt;p&gt;4 - Nested loop (looping inside looping): Since there is at least one looping inside the main looping, running time of this statement used O(n^2) or O(n^3).&lt;/p&gt;\n&lt;p&gt;Example:&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;for i = 1 to n do begin                     // (1+1)*n  = 2n\n   for j = 1 to n do begin                  // (1+1)n*n = 2n^2\n       x = x + 1;                           // (1+1)n*n = 2n^2\n       print(x);                            // (n*n)    = n^2\n   end;\nend;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2&gt;Common running time&lt;/h2&gt;\n&lt;p&gt;There are some common running times when analyzing an algorithm:&lt;/p&gt;\n&lt;ol&gt;\n&lt;li&gt;&lt;p&gt;O(1)  Constant time&lt;/p&gt;\n&lt;p&gt;Constant time means the running time is constant, its &lt;em&gt;not affected by the input size&lt;/em&gt;.&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;p&gt;O(n)  Linear time&lt;/p&gt;\n&lt;p&gt;When an algorithm accepts n input size, it would perform n operations as well.&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;p&gt;O(log n)  Logarithmic time&lt;/p&gt;\n&lt;p&gt;Algorithm that has running time O(log n) is slight faster than O(n). Commonly, algorithm divides the problem into sub problems with the same size. Example: binary search algorithm, binary conversion algorithm.&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;p&gt;O(n log n)  &lt;a href=&quot;https://en.wiktionary.org/wiki/linearithmic#Adjective&quot; rel=&quot;nofollow noreferrer&quot;&gt;Linearithmic&lt;/a&gt; time&lt;/p&gt;\n&lt;p&gt;This running time is often found in &quot;divide &amp;amp; conquer algorithms&quot; which divide the problem into sub problems recursively and then merge them in n time. Example: Merge Sort algorithm.&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;p&gt;O(n&lt;sup&gt;2&lt;/sup&gt;)  Quadratic time&lt;/p&gt;\n&lt;p&gt;Look Bubble Sort algorithm!&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;p&gt;O(n&lt;sup&gt;3&lt;/sup&gt;)  Cubic time&lt;/p&gt;\n&lt;p&gt;It has the same principle with O(n&lt;sup&gt;2&lt;/sup&gt;).&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;p&gt;O(2&lt;sup&gt;n&lt;/sup&gt;)  Exponential time&lt;/p&gt;\n&lt;p&gt;It is very slow as input get larger, if n = 1,000,000, T(n) would be 21,000,000. Brute Force algorithm has this running time.&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;p&gt;O(n!)  Factorial time&lt;/p&gt;\n&lt;p&gt;&lt;em&gt;The slowest&lt;/em&gt;!!! Example: &lt;a href=&quot;https://en.wikipedia.org/wiki/Travelling_salesman_problem&quot; rel=&quot;nofollow noreferrer&quot;&gt;Travelling salesman problem&lt;/a&gt; (TSP)&lt;/p&gt;\n&lt;/li&gt;\n&lt;/ol&gt;\n&lt;p&gt;It is taken from &lt;a href=&quot;http://philipstel.wordpress.com/2011/03/07/determining-the-complexity-of-an-algorithm-the-basic-part/&quot; rel=&quot;nofollow noreferrer&quot;&gt;this article&lt;/a&gt;. It is very well explained and you should give it a read.&lt;/p&gt;\n    ","\n&lt;p&gt;When you&apos;re analyzing  code, you have to analyse it line by line, counting every operation/recognizing time complexity. In the end, you have to sum it to get whole picture.&lt;/p&gt;\n&lt;p&gt;For example, you can have one simple loop with &lt;em&gt;linear complexity&lt;/em&gt;, but later in that same program you can have a triple loop that has &lt;em&gt;cubic complexity&lt;/em&gt;, so your program will have &lt;strong&gt;cubic complexity&lt;/strong&gt;. Function order of growth comes into play right here.&lt;/p&gt;\n&lt;p&gt;Let&apos;s look at what are possibilities for time complexity of an algorithm, you can see order of growth I mentioned above:&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;p&gt;&lt;em&gt;&lt;strong&gt;Constant time&lt;/strong&gt;&lt;/em&gt; has an order of growth &lt;em&gt;1&lt;/em&gt;, for example: &lt;em&gt;a = b + c&lt;/em&gt;.&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;p&gt;&lt;em&gt;&lt;strong&gt;Logarithmic time&lt;/strong&gt;&lt;/em&gt; has an order of growth &lt;em&gt;log N&lt;/em&gt;. It usually occurs when you&apos;re dividing something in half (&lt;a href=&quot;https://en.wikipedia.org/wiki/Binary_search_algorithm&quot; rel=&quot;nofollow noreferrer&quot;&gt;binary search&lt;/a&gt;, trees, and even loops), or multiplying something in same way.&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;p&gt;&lt;em&gt;&lt;strong&gt;Linear&lt;/strong&gt;&lt;/em&gt;. The order of growth is &lt;em&gt;N&lt;/em&gt;, for example&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt; int p = 0;\n for (int i = 1; i &amp;lt; N; i++)\n   p = p + 2;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;p&gt;&lt;em&gt;&lt;strong&gt;&lt;a href=&quot;https://en.wiktionary.org/wiki/linearithmic#Adjective&quot; rel=&quot;nofollow noreferrer&quot;&gt;Linearithmic&lt;/a&gt;&lt;/strong&gt;&lt;/em&gt;. The order of growth is &lt;em&gt;n·log N&lt;/em&gt;. It usually occurs in &lt;a href=&quot;https://en.wikipedia.org/wiki/Divide-and-conquer_algorithm&quot; rel=&quot;nofollow noreferrer&quot;&gt;divide-and-conquer algorithms&lt;/a&gt;.&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;p&gt;&lt;em&gt;&lt;strong&gt;Cubic&lt;/strong&gt;&lt;/em&gt;. The order of growth is &lt;em&gt;N&lt;sup&gt;3&lt;/sup&gt;&lt;/em&gt;. A classic example is a triple loop where you check all triplets:&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt; int x = 0;\n for (int i = 0; i &amp;lt; N; i++)\n    for (int j = 0; j &amp;lt; N; j++)\n       for (int k = 0; k &amp;lt; N; k++)\n           x = x + 2\n&lt;/code&gt;&lt;/pre&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;p&gt;&lt;em&gt;&lt;strong&gt;Exponential&lt;/strong&gt;&lt;/em&gt;. The order of growth is 2&lt;sup&gt;N&lt;/sup&gt;. It usually occurs when you do exhaustive search, for example, check subsets of some set.&lt;/p&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n    ","\n&lt;p&gt;Loosely speaking, time complexity is a way of summarising how the number of operations or run-time of an algorithm grows as the input size increases.&lt;/p&gt;\n\n&lt;p&gt;Like most things in life, a cocktail party can help us understand.&lt;/p&gt;\n\n&lt;p&gt;&lt;strong&gt;O(N)&lt;/strong&gt;&lt;/p&gt;\n\n&lt;p&gt;When you arrive at the party, you have to shake everyone&apos;s hand (do an operation on every item). As the number of attendees &lt;code&gt;N&lt;/code&gt; increases, the time/work it will take you to shake everyone&apos;s hand increases as &lt;code&gt;O(N)&lt;/code&gt;.&lt;/p&gt;\n\n&lt;p&gt;&lt;strong&gt;Why &lt;code&gt;O(N)&lt;/code&gt; and not &lt;code&gt;cN&lt;/code&gt;?&lt;/strong&gt;&lt;/p&gt;\n\n&lt;p&gt;There&apos;s variation in the amount of time it takes to shake hands with people. You could average this out and capture it in a constant &lt;code&gt;c&lt;/code&gt;. But the fundamental operation here --- shaking hands with everyone --- would always be proportional to &lt;code&gt;O(N)&lt;/code&gt;, no matter what &lt;code&gt;c&lt;/code&gt; was. When debating whether we should go to a cocktail party, we&apos;re often more interested in the fact that we&apos;ll have to meet everyone than in the minute details of what those meetings look like.&lt;/p&gt;\n\n&lt;p&gt;&lt;strong&gt;O(N^2)&lt;/strong&gt;&lt;/p&gt;\n\n&lt;p&gt;The host of the cocktail party wants you to play a silly game where everyone meets everyone else. Therefore, you must meet &lt;code&gt;N-1&lt;/code&gt; other people and, because the next person has already met you, they must meet &lt;code&gt;N-2&lt;/code&gt; people, and so on. The sum of this series is &lt;code&gt;x^2/2+x/2&lt;/code&gt;. As the number of attendees grows, the &lt;code&gt;x^2&lt;/code&gt; term gets big &lt;em&gt;fast&lt;/em&gt;, so we just drop everything else.&lt;/p&gt;\n\n&lt;p&gt;&lt;strong&gt;O(N^3)&lt;/strong&gt;&lt;/p&gt;\n\n&lt;p&gt;You have to meet everyone else and, during each meeting, you must talk about everyone else in the room.&lt;/p&gt;\n\n&lt;p&gt;&lt;strong&gt;O(1)&lt;/strong&gt;&lt;/p&gt;\n\n&lt;p&gt;The host wants to announce something. They ding a wineglass and speak loudly. Everyone hears them. It turns out it doesn&apos;t matter how many attendees there are, this operation always takes the same amount of time.&lt;/p&gt;\n\n&lt;p&gt;&lt;strong&gt;O(log N)&lt;/strong&gt;&lt;/p&gt;\n\n&lt;p&gt;The host has laid everyone out at the table in alphabetical order. Where is Dan? You reason that he must be somewhere between Adam and Mandy (certainly not between Mandy and Zach!). Given that, is he between George and Mandy? No. He must be between Adam and Fred, and between Cindy and Fred. And so on... we can efficiently locate Dan by looking at half the set and then half of that set. Ultimately, we look at &lt;strong&gt;O(log_2 N)&lt;/strong&gt; individuals.&lt;/p&gt;\n\n&lt;p&gt;&lt;strong&gt;O(N log N)&lt;/strong&gt;&lt;/p&gt;\n\n&lt;p&gt;You could find where to sit down at the table using the algorithm above. If a large number of people came to the table, one at a time, and all did this, that would take &lt;strong&gt;O(N log N)&lt;/strong&gt; time. This turns out to be how long it takes to sort any collection of items when they must be compared.&lt;/p&gt;\n\n&lt;p&gt;&lt;strong&gt;Best/Worst Case&lt;/strong&gt;&lt;/p&gt;\n\n&lt;p&gt;You arrive at the party and need to find Inigo - how long will it take? It depends on when you arrive. If everyone is milling around you&apos;ve hit the worst-case: it will take &lt;code&gt;O(N)&lt;/code&gt; time. However, if everyone is sitting down at the table, it will take only &lt;code&gt;O(log N)&lt;/code&gt; time. Or maybe you can leverage the host&apos;s wineglass-shouting power and it will take only &lt;code&gt;O(1)&lt;/code&gt; time.&lt;/p&gt;\n\n&lt;p&gt;Assuming the host is unavailable, we can say that the Inigo-finding algorithm has a lower-bound of &lt;code&gt;O(log N)&lt;/code&gt; and an upper-bound of &lt;code&gt;O(N)&lt;/code&gt;, depending on the state of the party when you arrive.&lt;/p&gt;\n\n&lt;p&gt;&lt;strong&gt;Space &amp;amp; Communication&lt;/strong&gt;&lt;/p&gt;\n\n&lt;p&gt;The same ideas can be applied to understanding how algorithms use space or communication.&lt;/p&gt;\n\n&lt;p&gt;Knuth has written a nice paper about the former entitled &lt;a href=&quot;https://www.cs.utexas.edu/users/arvindn/misc/knuth_song_complexity.pdf&quot;&gt;&quot;The Complexity of Songs&quot;&lt;/a&gt;.&lt;/p&gt;\n\n&lt;blockquote&gt;\n  &lt;p&gt;Theorem 2: There exist arbitrarily long songs of complexity O(1).&lt;/p&gt;\n  \n  &lt;p&gt;PROOF: (due to Casey and the Sunshine Band). Consider the songs Sk defined by (15), but with&lt;/p&gt;\n&lt;/blockquote&gt;\n\n&lt;pre&gt;&lt;code&gt;V_k = &apos;That&apos;s the way,&apos; U &apos;I like it, &apos; U\nU   = &apos;uh huh,&apos; &apos;uh huh&apos;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;blockquote&gt;\n  &lt;p&gt;for all k. &lt;/p&gt;\n&lt;/blockquote&gt;\n    ","\n&lt;p&gt;For the mathematically-minded people: The &lt;a href=&quot;https://en.wikipedia.org/wiki/Master_theorem_(analysis_of_algorithms)&quot; rel=&quot;nofollow noreferrer&quot;&gt;master theorem&lt;/a&gt; is another useful thing to know when studying complexity.&lt;/p&gt;\n    ","\n&lt;p&gt;O(n) is big O notation used for writing time complexity of an algorithm. When you add up the number of executions in an algorithm, you&apos;ll get an expression in result like 2N+2. In this expression, N is the dominating term (the term having largest effect on expression if its value increases or decreases). Now O(N) is the time complexity while N is dominating term.&lt;/p&gt;\n&lt;h3&gt;Example&lt;/h3&gt;\n&lt;pre&gt;&lt;code&gt;For i = 1 to n;\n  j = 0;\nwhile(j &amp;lt;= n);\n  j = j + 1;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;Here the total number of executions for the inner loop are n+1 and the total number of executions for the outer loop are n(n+1)/2, so the total number of executions for the whole algorithm are n + 1 + n(n+1/2) = (n&lt;sub&gt;2&lt;/sub&gt; + 3n)/2.\nHere n^2 is the dominating term so the time complexity for this algorithm is O(n&lt;sub&gt;2&lt;/sub&gt;).&lt;/p&gt;\n    "],"id":584,"title":"How can I find the time complexity of an algorithm?","content":"\n                \n&lt;p&gt;I have gone through &lt;a href=&quot;https://www.google.co.in/search?aq=f&amp;amp;sugexp=chrome,mod=19&amp;amp;sourceid=chrome&amp;amp;ie=UTF-8&amp;amp;q=How%20to%20find%20time%20complexity%20of%20an%20algorithm&quot; rel=&quot;noreferrer&quot;&gt;Google&lt;/a&gt; and &lt;a href=&quot;https://stackoverflow.com/search?q=how%20to%20calculate%20time%20complexity%20of%20an%20algorithm&quot;&gt;Stack Overflow&lt;/a&gt; search, but nowhere I was able to find a clear and straightforward explanation for how to calculate time complexity.&lt;/p&gt;\n&lt;h3&gt;What do I know already?&lt;/h3&gt;\n&lt;p&gt;Say for code as simple as the one below:&lt;/p&gt;\n&lt;pre class=&quot;lang-cs s-code-block&quot;&gt;&lt;code class=&quot;hljs language-csharp&quot;&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;char&lt;/span&gt; h = &lt;span class=&quot;hljs-string&quot;&gt;&apos;y&apos;&lt;/span&gt;; &lt;span class=&quot;hljs-comment&quot;&gt;// This will be executed 1 time&lt;/span&gt;\n&lt;span class=&quot;hljs-built_in&quot;&gt;int&lt;/span&gt; abc = &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;; &lt;span class=&quot;hljs-comment&quot;&gt;// This will be executed 1 time&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;Say for a loop like the one below:&lt;/p&gt;\n&lt;pre class=&quot;lang-cs s-code-block&quot;&gt;&lt;code class=&quot;hljs language-csharp&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;hljs-built_in&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;; i &amp;lt; N; i++) {\n    Console.Write(&lt;span class=&quot;hljs-string&quot;&gt;&apos;Hello, World!!&apos;&lt;/span&gt;);\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;code&gt;int i=0;&lt;/code&gt; This will be executed only &lt;strong&gt;once&lt;/strong&gt;.&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;The time is actually calculated to &lt;code&gt;i=0&lt;/code&gt; and not the declaration.&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;code&gt;i &amp;lt; N;&lt;/code&gt; This will be executed &lt;strong&gt;N+1&lt;/strong&gt; times&lt;/li&gt;\n&lt;li&gt;&lt;code&gt;i++&lt;/code&gt; This will be executed &lt;strong&gt;N&lt;/strong&gt; times&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;So the number of operations required by this loop are &lt;strong&gt;{1+(N+1)+N} = 2N+2&lt;/strong&gt;. (But this still may be wrong, as I am not confident about my understanding.)&lt;/p&gt;\n&lt;p&gt;OK, so these small basic calculations I think I know, but in most cases I have seen the time complexity as &lt;strong&gt;O(N), O(n^2), O(log n), O(n!)&lt;/strong&gt;, and &lt;a href=&quot;http://en.wikipedia.org/wiki/Time_complexity&quot; rel=&quot;noreferrer&quot;&gt;many others&lt;/a&gt;.&lt;/p&gt;\n    ","slug":"how-can-i-find-the-time-complexity-of-an-algorithm-1657388486001","postType":"QUESTION","createdAt":"2022-07-09T17:41:26.000Z","updatedAt":"2022-07-09T17:41:26.000Z","tags":[],"relatedQuestions":[]},"randomQuestions":[{"title":"Why aren't variable-length arrays part of the C++ standard?","slug":"why-aren't-variable-length-arrays-part-of-the-c++-standard-1657384712975"},{"title":"How can I group an array of objects by key?","slug":"how-can-i-group-an-array-of-objects-by-key-1657388065372"},{"title":"How to make good reproducible pandas examples","slug":"how-to-make-good-reproducible-pandas-examples-1657384310402"},{"title":"Example images for code and mark-up Q&As [closed]","slug":"example-images-for-code-and-mark-up-qandas-closed-1657387690222"},{"title":"Why use getters and setters/accessors?","slug":"why-use-getters-and-settersaccessors-1657387343971"},{"title":"Why does the order in which libraries are linked sometimes cause errors in GCC?","slug":"why-does-the-order-in-which-libraries-are-linked-sometimes-cause-errors-in-gcc-1657387609554"},{"title":"How do I clone a list so that it doesn't change unexpectedly after assignment?","slug":"how-do-i-clone-a-list-so-that-it-doesn't-change-unexpectedly-after-assignment-1657384423195"},{"title":"How to remove items from a list while iterating?","slug":"how-to-remove-items-from-a-list-while-iterating-1657384496375"},{"title":"Arrays, linked lists and other data structures in cmd.exe (batch) script","slug":"arrays-linked-lists-and-other-data-structures-in-cmd.exe-(batch)-script-1657387558484"},{"title":"I just assigned a variable, but echo $variable shows something else","slug":"i-just-assigned-a-variable-but-echo-dollarvariable-shows-something-else-1657387574561"},{"title":"Iterating through a Collection, avoiding ConcurrentModificationException when removing objects in a loop","slug":"iterating-through-a-collection-avoiding-concurrentmodificationexception-when-removing-objects-in-a-loop-1657387311824"},{"title":"How can I merge properties of two JavaScript objects dynamically?","slug":"how-can-i-merge-properties-of-two-javascript-objects-dynamically-1657387492535"},{"title":"How to manage startActivityForResult on Android","slug":"how-to-manage-startactivityforresult-on-android-1657387967393"},{"title":"Are dictionaries ordered in Python 3.6+?","slug":"are-dictionaries-ordered-in-python-3.6+-1657387834234"},{"title":"Strange result when removing item from a list while iterating over it [duplicate]","slug":"strange-result-when-removing-item-from-a-list-while-iterating-over-it-duplicate-1657387735759"},{"title":"How does JavaScript .prototype work?","slug":"how-does-javascript-.prototype-work-1657388169270"},{"title":"Deserialize JSON into C# dynamic object?","slug":"deserialize-json-into-c-dynamic-object-1657388568720"},{"title":"How do I import a module given the full path?","slug":"how-do-i-import-a-module-given-the-full-path-1657388139965"},{"title":"Javascript infamous Loop issue? [duplicate]","slug":"javascript-infamous-loop-issue-duplicate-1657387498530"},{"title":"Prototypical inheritance - writing up [duplicate]","slug":"prototypical-inheritance-writing-up-duplicate-1657385478064"}]},"__N_SSG":true}