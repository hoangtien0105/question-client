<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><meta name="twitter:card" content="summary_large_image"/><meta name="twitter:site" content="@solutionschecker.com"/><meta name="twitter:creator" content="@solutionschecker.com"/><meta property="og:url" content="https://solutionschecker.com"/><meta property="og:type" content="website"/><meta property="og:image" content="https://solutionschecker.com/solutions-checker-banner.png"/><meta property="og:image:alt" content="Find solution for coding, HTML, CSS, JAVASCRIPT, MYSQL, PHP, PYTHON,... quickly. - solutionschecker.com"/><script type="application/ld+json">{"@context":"https://schema.org","@type":"Organization","logo":"/logo.svg","url":"https://solutionschecker.com"}</script><title>What to do Regular expression pattern doesn&#x27;t match anywhere in string? | Solutions Checker</title><meta name="robots" content="index,follow"/><meta name="description" content="I am trying to match &lt;input&gt; type “hidden” fields using this pattern:

/&lt;input type=&quot;hidden&quot; name=&quot;([^&quot;]*?)&quot; value=&quot;([^&quot;]*?)&quot; /&gt;/


This is sample form data:

&lt;input type=&quot;hidden&quot; name=&quot;SaveRequired&quot; value=&quot;False&quot; /&gt;&lt;input type=&quot;hidden&quot; name=&quot;__VIEWSTATE1&quot; value=&quot;1H4sIAAtzrkX7QfL5VEGj6nGi+nP&quot; /&gt;&lt;input type=&quot;hidden&quot; name=&quot;__VIEWSTATE2&quot; value=&quot;0351118MK&quot; /&gt;&lt;input type=&quot;hidden&quot; name=&quot;__VIEWSTATE3&quot; value=&quot;ZVVV91yjY&quot; /&gt;&lt;input type=&quot;hidden&quot; name=&quot;__VIEWSTATE0&quot; value=&quot;3&quot; /&gt;&lt;input type=&quot;hidden&quot; name=&quot;__VIEWSTATE&quot; value=&quot;&quot; /&gt;&lt;input type=&quot;hidden&quot; name=&quot;__VIEWSTATE&quot; value=&quot;&quot; /&gt;


But I am not sure that the type, name, and value attributes will always appear in the same order. If the type attribute comes last, the match will fail because in my pattern it’s at the start.

Question:
How can I change my pattern so it will match regardless of the positions of the attributes in the &lt;input&gt; tag?

P.S.: By the way I am using the Adobe Air based RegEx Desktop Tool for testing regular expressions.
    "/><meta property="og:title" content="What to do Regular expression pattern doesn&#x27;t match anywhere in string? | Solutions Checker"/><meta property="og:description" content="I am trying to match &lt;input&gt; type “hidden” fields using this pattern:

/&lt;input type=&quot;hidden&quot; name=&quot;([^&quot;]*?)&quot; value=&quot;([^&quot;]*?)&quot; /&gt;/


This is sample form data:

&lt;input type=&quot;hidden&quot; name=&quot;SaveRequired&quot; value=&quot;False&quot; /&gt;&lt;input type=&quot;hidden&quot; name=&quot;__VIEWSTATE1&quot; value=&quot;1H4sIAAtzrkX7QfL5VEGj6nGi+nP&quot; /&gt;&lt;input type=&quot;hidden&quot; name=&quot;__VIEWSTATE2&quot; value=&quot;0351118MK&quot; /&gt;&lt;input type=&quot;hidden&quot; name=&quot;__VIEWSTATE3&quot; value=&quot;ZVVV91yjY&quot; /&gt;&lt;input type=&quot;hidden&quot; name=&quot;__VIEWSTATE0&quot; value=&quot;3&quot; /&gt;&lt;input type=&quot;hidden&quot; name=&quot;__VIEWSTATE&quot; value=&quot;&quot; /&gt;&lt;input type=&quot;hidden&quot; name=&quot;__VIEWSTATE&quot; value=&quot;&quot; /&gt;


But I am not sure that the type, name, and value attributes will always appear in the same order. If the type attribute comes last, the match will fail because in my pattern it’s at the start.

Question:
How can I change my pattern so it will match regardless of the positions of the attributes in the &lt;input&gt; tag?

P.S.: By the way I am using the Adobe Air based RegEx Desktop Tool for testing regular expressions.
    "/><script type="application/ld+json">{"@context":"https://schema.org","@type":"QAPage","mainEntity":{"name":"What to do Regular expression pattern doesn&apos;t match anywhere in string?","text":"I am trying to match &lt;input&gt; type “hidden” fields using this pattern:\n\n/&lt;input type=&quot;hidden&quot; name=&quot;([^&quot;]*?)&quot; value=&quot;([^&quot;]*?)&quot; /&gt;/\n\n\nThis is sample form data:\n\n&lt;input type=&quot;hidden&quot; name=&quot;SaveRequired&quot; value=&quot;False&quot; /&gt;&lt;input type=&quot;hidden&quot; name=&quot;__VIEWSTATE1&quot; value=&quot;1H4sIAAtzrkX7QfL5VEGj6nGi+nP&quot; /&gt;&lt;input type=&quot;hidden&quot; name=&quot;__VIEWSTATE2&quot; value=&quot;0351118MK&quot; /&gt;&lt;input type=&quot;hidden&quot; name=&quot;__VIEWSTATE3&quot; value=&quot;ZVVV91yjY&quot; /&gt;&lt;input type=&quot;hidden&quot; name=&quot;__VIEWSTATE0&quot; value=&quot;3&quot; /&gt;&lt;input type=&quot;hidden&quot; name=&quot;__VIEWSTATE&quot; value=&quot;&quot; /&gt;&lt;input type=&quot;hidden&quot; name=&quot;__VIEWSTATE&quot; value=&quot;&quot; /&gt;\n\n\nBut I am not sure that the type, name, and value attributes will always appear in the same order. If the type attribute comes last, the match will fail because in my pattern it’s at the start.\n\nQuestion:\nHow can I change my pattern so it will match regardless of the positions of the attributes in the &lt;input&gt; tag?\n\nP.S.: By the way I am using the Adobe Air based RegEx Desktop Tool for testing regular expressions.\n    ","answerCount":8,"upVoteCount":500,"suggestedAnswer":[{"text":"Oh Yes You Can Use Regexes to Parse HTML!\nFor the task you are attempting, regexes are perfectly fine!\nIt is true that most people underestimate the difficulty of parsing HTML with regular expressions and therefore do so poorly.\nBut this is not some fundamental flaw related to computational theory. That silliness is parroted a lot around here, but dont you believe them.\nSo while it certainly can be done (this posting serves as an existence proof of this incontrovertible fact), that doesnt mean it should be.\nYou must decide for yourself whether youre up to the task of writing what amounts to a dedicated, special-purpose HTML parser out of regexes. Most people are not.\nBut I am. \n\nGeneral Regex-Based HTML Parsing Solutions\nFirst Ill show how easy it is to parse arbitrary HTML with regexes. The full programs at the end of this posting, but the heart of the parser is:\nfor (;;) {\n  given ($html) {\n    last                    when (pos || 0) &gt;= length;\n    printf &quot;\\@%d=&quot;,              (pos || 0);\n    print  &quot;doctype &quot;   when / \\G (?&amp;doctype)  $RX_SUBS  /xgc;\n    print  &quot;cdata &quot;     when / \\G (?&amp;cdata)    $RX_SUBS  /xgc;\n    print  &quot;xml &quot;       when / \\G (?&amp;xml)      $RX_SUBS  /xgc;\n    print  &quot;xhook &quot;     when / \\G (?&amp;xhook)    $RX_SUBS  /xgc;\n    print  &quot;script &quot;    when / \\G (?&amp;script)   $RX_SUBS  /xgc;\n    print  &quot;style &quot;     when / \\G (?&amp;style)    $RX_SUBS  /xgc;\n    print  &quot;comment &quot;   when / \\G (?&amp;comment)  $RX_SUBS  /xgc;\n    print  &quot;tag &quot;       when / \\G (?&amp;tag)      $RX_SUBS  /xgc;\n    print  &quot;untag &quot;     when / \\G (?&amp;untag)    $RX_SUBS  /xgc;\n    print  &quot;nasty &quot;     when / \\G (?&amp;nasty)    $RX_SUBS  /xgc;\n    print  &quot;text &quot;      when / \\G (?&amp;nontag)   $RX_SUBS  /xgc;\n    default {\n      die &quot;UNCLASSIFIED: &quot; .\n        substr($_, pos || 0, (length &gt; 65) ? 65 : length);\n    }\n  }\n}\n\nSee how easy that is to read?\nAs written, it identifies each piece of HTML and tells  where it found that piece. You could easily modify it to do whatever else you want with any given type of piece, or for more particular types than these.\nI have no failing test cases (left :): Ive successfully run this code on more than 100,000 HTML files  every single one I could quickly and easily get my hands on. Beyond those, Ive also run it on files specifically constructed to break naïve parsers.\nThis is not a naïve parser.\nOh, Im sure it isnt perfect, but I havent managed to break it yet.  I figure that even if something did, the fix would be easy to fit in because of the programs clear structure. Even regex-heavy programs should have stucture.\nNow that thats out of the way, let me address the OPs question.\nDemo of Solving the OPs Task Using Regexes\nThe little html_input_rx program I include below produces the following output, so that you can see that parsing HTML with regexes works just fine for what you wish to do:\n% html_input_rx Amazon.com-_Online_Shopping_for_Electronics,_Apparel,_Computers,_Books,_DVDs_\\&amp;_more.htm \ninput tag #1 at character 9955:\n       class =&gt; &quot;searchSelect&quot;\n          id =&gt; &quot;twotabsearchtextbox&quot;\n        name =&gt; &quot;field-keywords&quot;\n        size =&gt; &quot;50&quot;\n       style =&gt; &quot;width:100%; background-color: #FFF;&quot;\n       title =&gt; &quot;Search for&quot;\n        type =&gt; &quot;text&quot;\n       value =&gt; &quot;&quot;\n\ninput tag #2 at character 10335:\n         alt =&gt; &quot;Go&quot;\n         src =&gt; &quot;http://g-ecx.images-amazon.com/images/G/01/x-locale/common/transparent-pixel._V192234675_.gif&quot;\n        type =&gt; &quot;image&quot;\n\nParse Input Tags, See No Evil Input\nHeres the source for the program that produced the output above.\n#!/usr/bin/env perl\n#\n# html_input_rx - pull out all &lt;input&gt; tags from (X)HTML src\n#                  via simple regex processing\n#\n# Tom Christiansen &lt;tchrist@perl.com&gt;\n# Sat Nov 20 10:17:31 MST 2010\n#\n################################################################\n\nuse 5.012;\n\nuse strict;\nuse autodie;\nuse warnings FATAL =&gt; &quot;all&quot;;    \nuse subs qw{\n    see_no_evil\n    parse_input_tags\n    input descape dequote\n    load_patterns\n};    \nuse open        &quot;:std&quot;,\n          IN =&gt; &quot;:bytes&quot;,\n         OUT =&gt; &quot;:utf8&quot;;    \nuse Encode qw&lt; encode decode &gt;;\n\n    ###########################################################\n\n                        parse_input_tags \n                           see_no_evil \n                              input  \n\n    ###########################################################\n\nuntil eof(); sub parse_input_tags {\n    my $_ = shift();\n    our($Input_Tag_Rx, $Pull_Attr_Rx);\n    my $count = 0;\n    while (/$Input_Tag_Rx/pig) {\n        my $input_tag = $+{TAG};\n        my $place     = pos() - length ${^MATCH};\n        printf &quot;input tag #%d at character %d:\\n&quot;, ++$count, $place;\n        my %attr = ();\n        while ($input_tag =~ /$Pull_Attr_Rx/g) {\n            my ($name, $value) = @+{ qw&lt; NAME VALUE &gt; };\n            $value = dequote($value);\n            if (exists $attr{$name}) {\n                printf &quot;Discarding dup attr value &apos;%s&apos; on %s attr\\n&quot;,\n                    $attr{$name} // &quot;&lt;undef&gt;&quot;, $name;\n            } \n            $attr{$name} = $value;\n        } \n        for my $name (sort keys %attr) {\n            printf &quot;  %10s =&gt; &quot;, $name;\n            my $value = descape $attr{$name};\n            my  @Q; given ($value) {\n                @Q = qw[  &quot; &quot;  ]  when !/&apos;/ &amp;&amp; !/&quot;/;\n                @Q = qw[  &quot; &quot;  ]  when  /&apos;/ &amp;&amp; !/&quot;/;\n                @Q = qw[  &apos; &apos;  ]  when !/&apos;/ &amp;&amp;  /&quot;/;\n                @Q = qw[ q( )  ]  when  /&apos;/ &amp;&amp;  /&quot;/;\n                default { die &quot;NOTREACHED&quot; }\n            } \n            say $Q[0], $value, $Q[1];\n        } \n        print &quot;\\n&quot;;\n    } \n\n}\n\nsub dequote {\n    my $_ = $_[0];\n    s{\n        (?&lt;quote&gt;   [&quot;&apos;]      )\n        (?&lt;BODY&gt;    \n          (?s: (?! \\k&lt;quote&gt; ) . ) * \n        )\n        \\k&lt;quote&gt; \n    }{$+{BODY}}six;\n    return $_;\n} \n\nsub descape {\n    my $string = $_[0];\n    for my $_ ($string) {\n        s{\n            (?&lt;! % )\n            % ( \\p{Hex_Digit} {2} )\n        }{\n            chr hex $1;\n        }gsex;\n        s{\n            &amp; \\043 \n            ( [0-9]+ )\n            (?: ; \n              | (?= [^0-9] )\n            )\n        }{\n            chr     $1;\n        }gsex;\n        s{\n            &amp; \\043 x\n            ( \\p{ASCII_HexDigit} + )\n            (?: ; \n              | (?= \\P{ASCII_HexDigit} )\n            )\n        }{\n            chr hex $1;\n        }gsex;\n\n    }\n    return $string;\n} \n\nsub input { \n    our ($RX_SUBS, $Meta_Tag_Rx);\n    my $_ = do { local $/; &lt;&gt; };  \n    my $encoding = &quot;iso-8859-1&quot;;  # web default; wish we had the HTTP headers :(\n    while (/$Meta_Tag_Rx/gi) {\n        my $meta = $+{META};\n        next unless $meta =~ m{             $RX_SUBS\n            (?= http-equiv ) \n            (?&amp;name) \n            (?&amp;equals) \n            (?= (?&amp;quote)? content-type )\n            (?&amp;value)    \n        }six;\n        next unless $meta =~ m{             $RX_SUBS\n            (?= content ) (?&amp;name) \n                          (?&amp;equals) \n            (?&lt;CONTENT&gt;   (?&amp;value)    )\n        }six;\n        next unless $+{CONTENT} =~ m{       $RX_SUBS\n            (?= charset ) (?&amp;name) \n                          (?&amp;equals) \n            (?&lt;CHARSET&gt;   (?&amp;value)    )\n        }six;\n        if (lc $encoding ne lc $+{CHARSET}) {\n            say &quot;[RESETTING ENCODING $encoding =&gt; $+{CHARSET}]&quot;;\n            $encoding = $+{CHARSET};\n        }\n    } \n    return decode($encoding, $_);\n}\n\nsub see_no_evil {\n    my $_ = shift();\n\n    s{ &lt;!    DOCTYPE  .*?         &gt; }{}sx; \n    s{ &lt;! \\[ CDATA \\[ .*?    \\]\\] &gt; }{}gsx; \n\n    s{ &lt;script&gt; .*?  &lt;/script&gt; }{}gsix; \n    s{ &lt;!--     .*?        --&gt; }{}gsx;\n\n    return $_;\n}\n\nsub load_patterns { \n\n    our $RX_SUBS = qr{ (?(DEFINE)\n        (?&lt;nv_pair&gt;         (?&amp;name) (?&amp;equals) (?&amp;value)         ) \n        (?&lt;name&gt;            \\b (?=  \\pL ) [\\w\\-] + (?&lt;= \\pL ) \\b  )\n        (?&lt;equals&gt;          (?&amp;might_white)  = (?&amp;might_white)    )\n        (?&lt;value&gt;           (?&amp;quoted_value) | (?&amp;unquoted_value) )\n        (?&lt;unwhite_chunk&gt;   (?: (?! &gt; ) \\S ) +                    )\n        (?&lt;unquoted_value&gt;  [\\w\\-] *                              )\n        (?&lt;might_white&gt;     \\s *                                  )\n        (?&lt;quoted_value&gt;\n            (?&lt;quote&gt;   [&quot;&apos;]      )\n            (?: (?! \\k&lt;quote&gt; ) . ) *\n            \\k&lt;quote&gt; \n        )\n        (?&lt;start_tag&gt;  &lt; (?&amp;might_white) )\n        (?&lt;end_tag&gt;          \n            (?&amp;might_white)\n            (?: (?&amp;html_end_tag) \n              | (?&amp;xhtml_end_tag) \n             )\n        )\n        (?&lt;html_end_tag&gt;       &gt;  )\n        (?&lt;xhtml_end_tag&gt;    / &gt;  )\n    ) }six; \n\n    our $Meta_Tag_Rx = qr{                          $RX_SUBS \n        (?&lt;META&gt; \n            (?&amp;start_tag) meta \\b\n            (?:\n                (?&amp;might_white) (?&amp;nv_pair) \n            ) +\n            (?&amp;end_tag)\n        )\n    }six;\n\n    our $Pull_Attr_Rx = qr{                         $RX_SUBS\n        (?&lt;NAME&gt;  (?&amp;name)      )\n                  (?&amp;equals) \n        (?&lt;VALUE&gt; (?&amp;value)     )\n    }six;\n\n    our $Input_Tag_Rx = qr{                         $RX_SUBS \n\n        (?&lt;TAG&gt; (?&amp;input_tag) )\n\n        (?(DEFINE)\n\n            (?&lt;input_tag&gt;\n                (?&amp;start_tag)\n                input\n                (?&amp;might_white) \n                (?&amp;attributes) \n                (?&amp;might_white) \n                (?&amp;end_tag)\n            )\n\n            (?&lt;attributes&gt;\n                (?: \n                    (?&amp;might_white) \n                    (?&amp;one_attribute) \n                ) *\n            )\n\n            (?&lt;one_attribute&gt;\n                \\b\n                (?&amp;legal_attribute)\n                (?&amp;might_white) = (?&amp;might_white) \n                (?:\n                    (?&amp;quoted_value)\n                  | (?&amp;unquoted_value)\n                )\n            )\n\n            (?&lt;legal_attribute&gt; \n                (?: (?&amp;optional_attribute)\n                  | (?&amp;standard_attribute)\n                  | (?&amp;event_attribute)\n            # for LEGAL parse only, comment out next line \n                  | (?&amp;illegal_attribute)\n                )\n            )\n\n            (?&lt;illegal_attribute&gt;  (?&amp;name) )\n\n            (?&lt;required_attribute&gt; (?#no required attributes) )\n\n            (?&lt;optional_attribute&gt;\n                (?&amp;permitted_attribute)\n              | (?&amp;deprecated_attribute)\n            )\n\n            # NB: The white space in string literals \n            #     below DOES NOT COUNT!   It&apos;s just \n            #     there for legibility.\n\n            (?&lt;permitted_attribute&gt;\n                  accept\n                | alt\n                | bottom\n                | check box\n                | checked\n                | disabled\n                | file\n                | hidden\n                | image\n                | max length\n                | middle\n                | name\n                | password\n                | radio\n                | read only\n                | reset\n                | right\n                | size\n                | src\n                | submit\n                | text\n                | top\n                | type\n                | value\n            )\n\n            (?&lt;deprecated_attribute&gt;\n                  align\n            )\n\n            (?&lt;standard_attribute&gt;\n                  access key\n                | class\n                | dir\n                | ltr\n                | id\n                | lang\n                | style\n                | tab index\n                | title\n                | xml:lang\n            )\n\n            (?&lt;event_attribute&gt;\n                  on blur\n                | on change\n                | on click\n                | on dbl   click\n                | on focus\n                | on mouse down\n                | on mouse move\n                | on mouse out\n                | on mouse over\n                | on mouse up\n                | on key   down\n                | on key   press\n                | on key   up\n                | on select\n            )\n        )\n    }six;\n\n}\n\nUNITCHECK {\n    load_patterns();\n} \n\nEND {\n    close(STDOUT) \n        || die &quot;can&apos;t close stdout: $!&quot;;\n} \n\nThere you go! Nothing to it! :)\nOnly  you can judge whether your skill with regexes is up to any particular parsing task. Everyones level of skill is different, and every new task is different. For jobs where you have a well-defined input set, regexes are obviously the right choice, because it is trivial to put some together when you have a restricted subset of HTML to deal with. Even regex beginners should be handle those jobs with regexes.  Anything else is overkill.\nHowever, once the HTML starts becoming less nailed down, once it starts to ramify in ways you cannot predict but which are perfectly legal, once you have to match more different sorts of things or with more complex dependencies, you will eventually reach a point where you have to work harder to effect a solution that uses regexes than you would have to using a parsing class. Where that break-even point falls  depends again on your own comfort level with regexes.\nSo What Should I Do?\nIm not going to tell you what you must do or what you cannot do.  I think thats Wrong. I just want to present you with possibilties, open your eyes a bit. You get to choose what you want to do and how you want to do it. There are no absolutes  and nobody else knows your own situation as well as you yourself do. If something seems like its too much work, well, maybe it is.  Programming should be fun, you know. If it isnt, you may be doing it wrong.\nOne can look at my html_input_rx program in any number of valid ways.  One such is that you indeed can parse HTML with regular expressions. But another is that it is much, much, much harder than almost anyone ever thinks it is. This can easily lead to the conclusion that my program is a testament to what you should not do, because it really is too hard.\nI wont disagree with that.  Certainly if everything I do in my program doesnt make sense to you after some study, then you should not be attempting to use regexes for this kind of task. For specific HTML, regexes are great, but for generic HTML, theyre tantamount to madness. I use parsing classes all the time, especially if its HTML I havent generated myself.\nRegexes  optimal for small HTML parsing problems,  pessimal for large ones\nEven if my program is taken as  illustrative of why you should not use regexes for parsing general HTML  which is OK, because I kinda meant for it to be that    it still should be an eye-opener so more people break the terribly common and nasty, nasty habit of writing unreadable, unstructured, and unmaintainable patterns.\nPatterns do not have to be ugly, and they do not have to be hard. If you create ugly patterns, it is a reflection on you, not them.\nPhenomenally Exquisite Regex Language\nIve been asked to point out that my proferred solution to your problem has been written in Perl. Are you surprised? Did you not notice? Is this revelation a bombshell?\nIt is true that not all other tools and programming languages are quite as convenient, expressive, and powerful when it comes to regexes as Perl is. Theres a big spectrum out there, with some being more suitable than others.  In general, the languages that have expressed regexes as part of the core language instead of as a library are easier to work with. Ive done nothing with regexes that you couldnt do in, say, PCRE, although you would structure the program differently if you were using C.\nEventually other languages will be catch up with where Perl is now in terms of regexes.  I say this because back when Perl started, nobody else had anything like Perls regexes. Say anything you like, but this is where Perl clearly won: everybody copied Perls regexes albeit at varying stages of their development.  Perl pioneered almost (not quite all, but almost) everything that you have come to rely on in modern patterns today, no matter what tool or language you use.  So eventually the others will catch up.\nBut theyll only catch up to where Perl was sometime in the past, just as it is now.  Everything advances.  In regexes if nothing else, where Perl leads, others follow. Where will Perl be once everybody else finally catches up to where Perl is now?  I have no idea, but I know we too will have moved. Probably well be closer to Perls style of crafting patterns.\nIf you like that kind  of thing but would like to use it in Perl,  you might be interested in Damian Conways wonderful Regexp::Grammars module. Its completely awesome, and makes what Ive done here in my program seem just as primitive as mine makes the patterns that people cram together without whitespace or alphabetic identifiers.  Check it out!\n\nSimple HTML Chunker\nHere is the complete source to the parser I showed the centerpiece from at the beginning of this posting.\nI am not suggesting that you should use this over a rigorously tested parsing class. But I am tired of people pretending that nobody can parse HTML with regexes just because they cant. You clearly can, and this program is proof of that assertion.\nSure,  it isnt easy, but it is possible!\nAnd trying to do so is a terrible waste of time, because good parsing classes exist which you should use for this task.  The right answer to people trying to parse arbitrary HTML is not that it is impossible.  That is a facile and disingenuous answer.  The correct and honest answer is that they shouldnt attempt it because it is too much of a bother to figure out from scratch; they should not  break their back striving to reïnvent a wheel that works perfectly well.\nOn the other hand, HTML that falls within a predicable subset is ultra-easy to parse with regexes. Its no wonder people try to use them, because for small problems, toy problems perhaps, nothing could be easier. Thats why its so important to distinguish the two tasks  specific vs generic  as these do not necessarily demand the same approach.\nI hope in the future here to see a more fair and honest treatment of questions about HTML and regexes.\nHeres my HTML lexer.  It doesnt try to do a validating parse; it just identifies the lexical elements. You might think of it more as an HTML chunker than an HTML parser. It isnt very forgiving of broken HTML, although it makes some very small allowances in that direction.\nEven if you never parse full HTML yourself (and why should you? its a solved problem!), this program has lots of cool regex bits that I believe a lot of people can learn a lot from.  Enjoy!\n#!/usr/bin/env perl\n#\n# chunk_HTML - a regex-based HTML chunker\n#\n# Tom Christiansen &lt;tchrist@perl.com\n#   Sun Nov 21 19:16:02 MST 2010\n########################################\n\nuse 5.012;\n\nuse strict;\nuse autodie;\nuse warnings qw&lt; FATAL all &gt;;\nuse open     qw&lt; IN :bytes OUT :utf8 :std &gt;;\n\nMAIN: {\n  $| = 1;\n  lex_html(my $page = slurpy());\n  exit();\n}\n\n########################################################################\nsub lex_html {\n    our $RX_SUBS;                                        ###############\n    my  $html = shift();                                 # Am I...     #\n    for (;;) {                                           # forgiven? :)#\n        given ($html) {                                  ###############\n            last                when (pos || 0) &gt;= length;\n            printf &quot;\\@%d=&quot;,          (pos || 0);\n            print  &quot;doctype &quot;   when / \\G (?&amp;doctype)  $RX_SUBS  /xgc;\n            print  &quot;cdata &quot;     when / \\G (?&amp;cdata)    $RX_SUBS  /xgc;\n            print  &quot;xml &quot;       when / \\G (?&amp;xml)      $RX_SUBS  /xgc;\n            print  &quot;xhook &quot;     when / \\G (?&amp;xhook)    $RX_SUBS  /xgc;\n            print  &quot;script &quot;    when / \\G (?&amp;script)   $RX_SUBS  /xgc;\n            print  &quot;style &quot;     when / \\G (?&amp;style)    $RX_SUBS  /xgc;\n            print  &quot;comment &quot;   when / \\G (?&amp;comment)  $RX_SUBS  /xgc;\n            print  &quot;tag &quot;       when / \\G (?&amp;tag)      $RX_SUBS  /xgc;\n            print  &quot;untag &quot;     when / \\G (?&amp;untag)    $RX_SUBS  /xgc;\n            print  &quot;nasty &quot;     when / \\G (?&amp;nasty)    $RX_SUBS  /xgc;\n            print  &quot;text &quot;      when / \\G (?&amp;nontag)   $RX_SUBS  /xgc;\n            default {\n                die &quot;UNCLASSIFIED: &quot; .\n                  substr($_, pos || 0, (length &gt; 65) ? 65 : length);\n            }\n        }\n    }\n    say &quot;.&quot;;\n}\n#####################\n# Return correctly decoded contents of next complete\n# file slurped in from the &lt;ARGV&gt; stream.\n#\nsub slurpy {\n    our ($RX_SUBS, $Meta_Tag_Rx);\n    my $_ = do { local $/; &lt;ARGV&gt; };   # read all input\n\n    return unless length;\n\n    use Encode   qw&lt; decode &gt;;\n\n    my $bom = &quot;&quot;;\n    given ($_) {\n        $bom = &quot;UTF-32LE&quot; when / ^ \\xFf \\xFe \\0   \\0   /x;  # LE\n        $bom = &quot;UTF-32BE&quot; when / ^ \\0   \\0   \\xFe \\xFf /x;  #   BE\n        $bom = &quot;UTF-16LE&quot; when / ^ \\xFf \\xFe           /x;  # le\n        $bom = &quot;UTF-16BE&quot; when / ^ \\xFe \\xFf           /x;  #   be\n        $bom = &quot;UTF-8&quot;    when / ^ \\xEF \\xBB \\xBF      /x;  # st00pid\n    }\n    if ($bom) {\n        say &quot;[BOM $bom]&quot;;\n        s/^...// if $bom eq &quot;UTF-8&quot;;                        # st00pid\n\n        # Must use UTF-(16|32) w/o -[BL]E to strip BOM.\n        $bom =~ s/-[LB]E//;\n\n        return decode($bom, $_);\n\n        # if BOM found, don&apos;t fall through to look\n        #  for embedded encoding spec\n    }\n\n    # Latin1 is web default if not otherwise specified.\n    # No way to do this correctly if it was overridden\n    # in the HTTP header, since we assume stream contains\n    # HTML only, not also the HTTP header.\n    my $encoding = &quot;iso-8859-1&quot;;\n    while (/ (?&amp;xml) $RX_SUBS /pgx) {\n        my $xml = ${^MATCH};\n        next unless $xml =~ m{              $RX_SUBS\n            (?= encoding )  (?&amp;name)\n                            (?&amp;equals)\n                            (?&amp;quote) ?\n            (?&lt;ENCODING&gt;    (?&amp;value)       )\n        }sx;\n        if (lc $encoding ne lc $+{ENCODING}) {\n            say &quot;[XML ENCODING $encoding =&gt; $+{ENCODING}]&quot;;\n            $encoding = $+{ENCODING};\n        }\n    }\n\n    while (/$Meta_Tag_Rx/gi) {\n        my $meta = $+{META};\n\n        next unless $meta =~ m{             $RX_SUBS\n            (?= http-equiv )    (?&amp;name)\n                                (?&amp;equals)\n            (?= (?&amp;quote)? content-type )\n                                (?&amp;value)\n        }six;\n\n        next unless $meta =~ m{             $RX_SUBS\n            (?= content )       (?&amp;name)\n                                (?&amp;equals)\n            (?&lt;CONTENT&gt;         (?&amp;value)    )\n        }six;\n\n        next unless $+{CONTENT} =~ m{       $RX_SUBS\n            (?= charset )       (?&amp;name)\n                                (?&amp;equals)\n            (?&lt;CHARSET&gt;         (?&amp;value)    )\n        }six;\n\n        if (lc $encoding ne lc $+{CHARSET}) {\n            say &quot;[HTTP-EQUIV ENCODING $encoding =&gt; $+{CHARSET}]&quot;;\n            $encoding = $+{CHARSET};\n        }\n    }\n\n    return decode($encoding, $_);\n}\n########################################################################\n# Make sure to this function is called\n# as soon as source unit has been compiled.\nUNITCHECK { load_rxsubs() }\n\n# useful regex subroutines for HTML parsing\nsub load_rxsubs {\n\n    our $RX_SUBS = qr{\n      (?(DEFINE)\n\n        (?&lt;WS&gt; \\s *  )\n\n        (?&lt;any_nv_pair&gt;     (?&amp;name) (?&amp;equals) (?&amp;value)         )\n        (?&lt;name&gt;            \\b (?=  \\pL ) [\\w:\\-] +  \\b           )\n        (?&lt;equals&gt;          (?&amp;WS)  = (?&amp;WS)    )\n        (?&lt;value&gt;           (?&amp;quoted_value) | (?&amp;unquoted_value) )\n        (?&lt;unwhite_chunk&gt;   (?: (?! &gt; ) \\S ) +                    )\n\n        (?&lt;unquoted_value&gt;  [\\w:\\-] *                             )\n\n        (?&lt;any_quote&gt;  [&quot;&apos;]      )\n\n        (?&lt;quoted_value&gt;\n            (?&lt;quote&gt;   (?&amp;any_quote)  )\n            (?: (?! \\k&lt;quote&gt; ) . ) *\n            \\k&lt;quote&gt;\n        )\n\n        (?&lt;start_tag&gt;       &lt; (?&amp;WS)      )\n        (?&lt;html_end_tag&gt;      &gt;           )\n        (?&lt;xhtml_end_tag&gt;   / &gt;           )\n        (?&lt;end_tag&gt;\n            (?&amp;WS)\n            (?: (?&amp;html_end_tag)\n              | (?&amp;xhtml_end_tag) )\n         )\n\n        (?&lt;tag&gt;\n            (?&amp;start_tag)\n            (?&amp;name)\n            (?:\n                (?&amp;WS)\n                (?&amp;any_nv_pair)\n            ) *\n            (?&amp;end_tag)\n        )\n\n        (?&lt;untag&gt; &lt;/ (?&amp;name) &gt; )\n\n        # starts like a tag, but has screwed up quotes inside it\n        (?&lt;nasty&gt;\n            (?&amp;start_tag)\n            (?&amp;name)\n            .*?\n            (?&amp;end_tag)\n        )\n\n        (?&lt;nontag&gt;    [^&lt;] +            )\n\n        (?&lt;string&gt; (?&amp;quoted_value)     )\n        (?&lt;word&gt;   (?&amp;name)             )\n\n        (?&lt;doctype&gt;\n            &lt;!DOCTYPE\n                # please don&apos;t feed me nonHTML\n                ### (?&amp;WS) HTML\n            [^&gt;]* &gt;\n        )\n\n        (?&lt;cdata&gt;   &lt;!\\[CDATA\\[     .*?     \\]\\]    &gt; )\n        (?&lt;script&gt;  (?= &lt;script ) (?&amp;tag)   .*?     &lt;/script&gt; )\n        (?&lt;style&gt;   (?= &lt;style  ) (?&amp;tag)   .*?     &lt;/style&gt; )\n        (?&lt;comment&gt; &lt;!--            .*?           --&gt; )\n\n        (?&lt;xml&gt;\n            &lt; \\? xml\n            (?:\n                (?&amp;WS)\n                (?&amp;any_nv_pair)\n            ) *\n            (?&amp;WS)\n            \\? &gt;\n        )\n\n        (?&lt;xhook&gt; &lt; \\? .*? \\? &gt; )\n\n      )\n\n    }six;\n\n    our $Meta_Tag_Rx = qr{                          $RX_SUBS\n        (?&lt;META&gt;\n            (?&amp;start_tag) meta \\b\n            (?:\n                (?&amp;WS) (?&amp;any_nv_pair)\n            ) +\n            (?&amp;end_tag)\n        )\n    }six;\n\n}\n\n# nobody *ever* remembers to do this!\nEND { close STDOUT }\n\n    ","url":"/questions/[slug]#solution1","@type":"Answer","upvoteCount":0},{"text":"\nYou can write a novel like tchrist did\nYou can use a DOM library, load the HTML and use xpath and just use //input[@type=&quot;hidden&quot;]. Or if you don&apos;t want to use xpath, just get all inputs and filter which ones are hidden with getAttribute.\n\n\nI prefer #2.\n\n&lt;?php\n\n$d = new DOMDocument();\n$d-&gt;loadHTML(\n    &apos;\n    &lt;p&gt;fsdjl&lt;/p&gt;\n    &lt;form&gt;&lt;div&gt;fdsjl&lt;/div&gt;&lt;/form&gt;\n    &lt;input type=&quot;hidden&quot; name=&quot;blah&quot; value=&quot;hide yo kids&quot;&gt;\n    &lt;input type=&quot;text&quot; name=&quot;blah&quot; value=&quot;hide yo kids&quot;&gt;\n    &lt;input type=&quot;hidden&quot; name=&quot;blah&quot; value=&quot;hide yo wife&quot;&gt;\n&apos;);\n$x = new DOMXpath($d);\n$inputs = $x-&gt;evaluate(&apos;//input[@type=&quot;hidden&quot;]&apos;);\n\nforeach ( $inputs as $input ) {\n    echo $input-&gt;getAttribute(&apos;value&apos;), &apos;&lt;br&gt;&apos;;\n}\n\n\nResult:\n\nhide yo kids&lt;br&gt;hide yo wife&lt;br&gt;\n\n    ","url":"/questions/[slug]#solution2","@type":"Answer","upvoteCount":0},{"text":"Contrary to all the answers here, for what you&apos;re trying to do regex is a perfectly valid solution. This is because you are NOT trying to match balanced tags-- THAT would be impossible with regex! But you are only matching what&apos;s in one tag, and that&apos;s perfectly regular.\n\nHere&apos;s the problem, though. You can&apos;t do it with just one regex... you need to do one match to capture an &lt;input&gt; tag, then do further processing on that. Note that this will only work if none of the attribute values have a &gt; character in them, so it&apos;s not perfect, but it should suffice for sane inputs.\n\nHere&apos;s some Perl (pseudo)code to show you what I mean:\n\nmy $html = readLargeInputFile();\n\nmy @input_tags = $html =~ m/\n    (\n        &lt;input                      # Starts with &quot;&lt;input&quot;\n        (?=[^&gt;]*?type=&quot;hidden&quot;)     # Use lookahead to make sure that type=&quot;hidden&quot;\n        [^&gt;]+                       # Grab the rest of the tag...\n        \\/&gt;                         # ...except for the /&gt;, which is grabbed here\n    )/xgm;\n\n# Now each member of @input_tags is something like &lt;input type=&quot;hidden&quot; name=&quot;SaveRequired&quot; value=&quot;False&quot; /&gt;\n\nforeach my $input_tag (@input_tags)\n{\n  my $hash_ref = {};\n  # Now extract each of the fields one at a time.\n\n  ($hash_ref-&gt;{&quot;name&quot;}) = $input_tag =~ /name=&quot;([^&quot;]*)&quot;/;\n  ($hash_ref-&gt;{&quot;value&quot;}) = $input_tag =~ /value=&quot;([^&quot;]*)&quot;/;\n\n  # Put $hash_ref in a list or something, or otherwise process it\n}\n\n\nThe basic principle here is, don&apos;t try to do too much with one regular expression. As you noticed, regular expressions enforce a certain amount of order. So what you need to do instead is to first match the CONTEXT of what you&apos;re trying to extract, then do submatching on the data you want.\n\nEDIT: However, I will agree that in general, using an HTML parser is probably easier and better and you really should consider redesigning your code or re-examining your objectives. :-) But I had to post this answer as a counter to the knee-jerk reaction that parsing any subset of HTML is impossible: HTML and XML are both irregular when you consider the entire specification, but the specification of a tag is decently regular, certainly within the power of PCRE.\n    ","url":"/questions/[slug]#solution3","@type":"Answer","upvoteCount":0},{"text":"In the spirit of Tom Christiansen&apos;s lexer solution, here&apos;s a link to Robert Cameron&apos;s seemingly forgotten 1998 article, REX: XML Shallow Parsing with Regular Expressions.\n\nhttp://www.cs.sfu.ca/~cameron/REX.html\n\n\n  Abstract\n  \n  The syntax of XML is simple enough that it is possible to parse an XML document into a list of its markup and text items using a single regular expression. Such a shallow parse of an XML document can be very useful for the construction of a variety of lightweight XML processing tools. However, complex regular expressions can be difficult to construct and even more difficult to read. Using a form of literate programming for regular expressions, this paper documents a set of XML shallow parsing expressions that can be used a basis for simple, correct, efficient, robust and language-independent XML shallow parsing. Complete shallow parser implementations of less than 50 lines each in Perl, JavaScript and Lex/Flex are also given.\n\n\nIf you enjoy reading about regular expressions, Cameron&apos;s paper is fascinating. His writing is concise, thorough, and very detailed. He&apos;s not simply showing you how to construct the REX regular expression but also an approach for building up any complex regex from smaller parts.\n\nI&apos;ve been using the REX regular expression on and off for 10 years to solve the sort of problem the initial poster asked about (how do I match this particular tag but not some other very similar tag?). I&apos;ve found the regex he developed to be completely reliable.\n\nREX is particularly useful when you&apos;re focusing on lexical details of a document -- for example, when transforming one kind of text document (e.g., plain text, XML, SGML, HTML) into another, where the document may not be valid, well formed, or even parsable for most of the transformation. It lets you target islands of markup anywhere within a document without disturbing the rest of the document.\n    ","url":"/questions/[slug]#solution4","@type":"Answer","upvoteCount":0},{"text":"While I love the contents of the rest of these answers, they didn&apos;t really answer the question directly or as correctly.  Even Platinum&apos;s answer was overly complicated, and also less efficient.  So I was forced to put this.\n\nI&apos;m a huge proponent of Regex, when used correctly.  But because of stigma (and performance), I always state that well-formed XML or HTML should use an XML Parser.  And even better performance would be string-parsing, though there&apos;s a line between readability if that gets too out-of-hand.  However, that isn&apos;t the question.  The question is how to match a hidden-type input tag.  The answer is:\n\n&lt;input[^&gt;]*type=&quot;hidden&quot;[^&gt;]*&gt;\n\n\nDepending on your flavor, the only regex option you&apos;d need to include is the ignorecase option.\n    ","url":"/questions/[slug]#solution5","@type":"Answer","upvoteCount":0},{"text":"you can try this :\n\n&lt;[A-Za-z =&quot;/_0-9+]*&gt;\n\n\nand for closer result you can try this :\n\n&lt;[ ]*input[ ]+type=&quot;hidden&quot;[ ]*name=[A-Za-z =&quot;_0-9+]*[ ]*[/]*&gt;\n\n\nyou can test your regex pattern here http://regexpal.com/\n\nthese pattens are good for this:\n\n&lt;input type=&quot;hidden&quot; name=&quot;SaveRequired&quot; value=&quot;False&quot; /&gt;&lt;input type=&quot;hidden&quot; name=&quot;__VIEWSTATE1&quot; value=&quot;1H4sIAAtzrkX7QfL5VEGj6nGi+nP&quot; /&gt;&lt;input type=&quot;hidden&quot; name=&quot;__VIEWSTATE2&quot; value=&quot;0351118MK&quot; /&gt;&lt;input type=&quot;hidden&quot; name=&quot;__VIEWSTATE3&quot; value=&quot;ZVVV91yjY&quot; /&gt;\n\n\n\n\nand for random order of type , name and value u can use this :\n\n&lt;[ ]*input[ ]*[A-Za-z =&quot;_0-9+/]*&gt;\n\n\nor\n\n&lt;[ ]*input[ ]*[A-Za-z =&quot;_0-9+/]*[ ]*[/]&gt;\n\n\non this :\n\n&lt;input  name=&quot;SaveRequired&quot; type=&quot;hidden&quot; value=&quot;False&quot; /&gt;&lt;input type=&quot;hidden&quot; name=&quot;__VIEWSTATE1&quot; value=&quot;1H4sIAAtzrkX7QfL5VEGj6nGi+nP&quot; /&gt;&lt;input type=&quot;hidden&quot; name=&quot;__VIEWSTATE2&quot; value=&quot;0351118MK&quot; /&gt;&lt;input  name=&quot;__VIEWSTATE3&quot; type=&quot;hidden&quot; value=&quot;ZVVV91yjY&quot; /&gt;\n\n\n\n`\n\nby the way i think you want something like this :\n\n&lt;[ ]*input(([ ]*type=&quot;hidden&quot;[ ]*name=[A-Za-z0-9_+&quot;]*[ ]*value=[A-Za-z0-9_+&quot;]*[ ]*)+)[ ]*/&gt;|&lt;[ ]*input(([ ]*type=&quot;hidden&quot;[ ]*value=[A-Za-z0-9_+&quot;]*[ ]*name=[A-Za-z0-9_+&quot;]*[ ]*)+)[ ]*/&gt;|&lt;[ ]*input(([ ]*name=[A-Za-z0-9_+&quot;]*[ ]*type=&quot;hidden&quot;[ ]*value=[A-Za-z0-9_+&quot;]*[ ]*)+)[ ]*/&gt;|&lt;[ ]*input(([ ]*value=[A-Za-z0-9_+&quot;]*[ ]*type=&quot;hidden&quot;[ ]*name=[A-Za-z0-9_+&quot;]*[ ]*)+)[ ]*/&gt;|&lt;[ ]*input(([ ]*name=[A-Za-z0-9_+&quot;]*[ ]*value=[A-Za-z0-9_+&quot;]*[ ]*type=&quot;hidden&quot;[ ]*)+)[ ]*/&gt;|&lt;[ ]*input(([ ]*value=[A-Za-z0-9_+&quot;]*[ ]*name=[A-Za-z0-9_+&quot;]*[ ]*type=&quot;hidden&quot;[ ]*)+)[ ]*/&gt;\n\n\nits not good but it works in any way.\n\ntest it in : http://regexpal.com/\n    ","url":"/questions/[slug]#solution6","@type":"Answer","upvoteCount":0},{"text":"I would like to use **DOMDocument** to extract the html code.\n\n$dom = new DOMDocument();\n$dom -&gt;loadHTML($input);\n$x = new DOMXpath($dom );\n$results = $x-&gt;evaluate(&apos;//input[@type=&quot;hidden&quot;]&apos;);\n\nforeach ( $results as $item) {\n    print_r( $item-&gt;getAttribute(&apos;value&apos;) );\n}\n\n\nBTW, you can test it in here - regex101.com. It shows the result at real time.\nSome rules about Regexp: http://www.eclipse.org/tptp/home/downloads/installguide/gla_42/ref/rregexp.html\nReader.\n    ","url":"/questions/[slug]#solution7","@type":"Answer","upvoteCount":0},{"text":"suppose your html content is stored in string html then in order to get every input that contain type hidden you can use regular expression\n\nvar regex = /(&lt;input.*?type\\s?=\\s?[&quot;&apos;]hidden[&quot;&apos;].*?&gt;)/g;\nhtml.match(regex);\n\n\nthe above regex find &lt;input followed by any number of characters until it gets type=&quot;hidden&quot; or type=&apos;hidden&apos; followed by any number of characters till it gets &gt;\n\n/g tell regular expression to find every substring that matches to the given pattern.\n    ","url":"/questions/[slug]#solution8","@type":"Answer","upvoteCount":0}],"@type":"Question"}}</script><meta name="next-head-count" content="16"/><link rel="preload" href="/_next/static/css/08bcc42a26fe5c92.css" as="style"/><link rel="stylesheet" href="/_next/static/css/08bcc42a26fe5c92.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-0d1b80a048d4787e.js"></script><script src="/_next/static/chunks/webpack-42cdea76c8170223.js" defer=""></script><script src="/_next/static/chunks/framework-4556c45dd113b893.js" defer=""></script><script src="/_next/static/chunks/main-ccfab947c79712f4.js" defer=""></script><script src="/_next/static/chunks/pages/_app-08d1a634dea6705e.js" defer=""></script><script src="/_next/static/chunks/29107295-fbcfe2172188e46f.js" defer=""></script><script src="/_next/static/chunks/150-b06815e21c943e0d.js" defer=""></script><script src="/_next/static/chunks/490-7f0418bb4354ac73.js" defer=""></script><script src="/_next/static/chunks/108-87de33c23337ff53.js" defer=""></script><script src="/_next/static/chunks/pages/questions/%5Bslug%5D-79a1437acf654019.js" defer=""></script><script src="/_next/static/TQ2eYlCSdocSK-hq6gkM0/_buildManifest.js" defer=""></script><script src="/_next/static/TQ2eYlCSdocSK-hq6gkM0/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="wrapper"><header><nav class="bg-white border-gray-200 px-4 lg:px-6 py-2.5 dark:bg-gray-800"><div class="flex flex-wrap justify-between items-center mx-auto max-w-screen-xl"><a class="flex items-center" href="/"><img src="/logo-second.png" class="mr-3 h-6 sm:h-9" alt="Solution Checker Logo"/><h4 class="self-center text-xl font-semibold whitespace-nowrap dark:text-white">Solution Checker</h4></a><div class="flex items-center lg:order-2"><button data-collapse-toggle="mobile-menu-2" type="button" class="inline-flex items-center p-2 ml-1 text-sm text-gray-500 rounded-lg lg:hidden hover:bg-gray-100 focus:outline-none focus:ring-2 focus:ring-gray-200 dark:text-gray-400 dark:hover:bg-gray-700 dark:focus:ring-gray-600" aria-controls="mobile-menu-2" aria-expanded="false"><span class="sr-only">Open main menu</span><svg class="w-6 h-6" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M3 5a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM3 10a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM3 15a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1z" clip-rule="evenodd"></path></svg><svg class="hidden w-6 h-6" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z" clip-rule="evenodd"></path></svg></button></div><div class="hidden justify-between items-center w-full lg:flex lg:w-auto lg:order-1" id="mobile-menu-2"><ul class="flex flex-col mt-4 font-medium lg:flex-row lg:space-x-8 lg:mt-0"><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" aria-current="page" href="/">Home</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/questions?tab=news">Questions</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/post?tab=news">Post</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/questions/what-to-do-regular-expression-pattern-doesn&#x27;t-match-anywhere-in-string-1657388095896#">Coding</a></li></ul></div></div></nav></header><div class="main-content"><div class="question my-5"><div class="flex question-header items-center m-auto justify-center"><div class="rounded-xl w-full border p-5 shadow-md bg-white"><div class="flex w-full items-center justify-between border-b pb-3"><div class="flex items-center space-x-3"><div class="text-lg font-bold text-slate-700"><a href="/questions/what-to-do-regular-expression-pattern-doesn&#x27;t-match-anywhere-in-string-1657388095896"><h1>What to do Regular expression pattern doesn&#x27;t match anywhere in string?</h1></a></div></div><div class="flex flex-wrap h-auto justify-end items-center space-x-8"></div></div><div class="question-content mt-5">
                
<p>I am trying to match <code>&lt;input&gt;</code> type “hidden” fields using this pattern:</p>

<pre class="lang-html s-code-block"><code class="hljs language-xml">/<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"hidden"</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"([^"</span>]*?)" <span class="hljs-attr">value</span>=<span class="hljs-string">"([^"</span>]*?)" /&gt;</span>/
</code></pre>

<p>This is sample form data:</p>

<pre class="lang-html s-code-block"><code class="hljs language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"hidden"</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"SaveRequired"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"False"</span> /&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"hidden"</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"__VIEWSTATE1"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"1H4sIAAtzrkX7QfL5VEGj6nGi+nP"</span> /&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"hidden"</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"__VIEWSTATE2"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"0351118MK"</span> /&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"hidden"</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"__VIEWSTATE3"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"ZVVV91yjY"</span> /&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"hidden"</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"__VIEWSTATE0"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"3"</span> /&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"hidden"</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"__VIEWSTATE"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">""</span> /&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"hidden"</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"__VIEWSTATE"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">""</span> /&gt;</span>
</code></pre>

<p>But I am not sure that the <code>type</code>, <code>name</code>, and <code>value</code> attributes will always appear in the same order. If the <code>type</code> attribute comes last, the match will fail because in my pattern it’s at the start.</p>

<p><strong>Question:</strong><br>
How can I change my pattern so it will match regardless of the positions of the attributes in the <code>&lt;input&gt;</code> tag?</p>

<p><strong>P.S.:</strong> By the way I am using the <em>Adobe Air</em> based <a href="http://gskinner.com/RegExr/desktop/" rel="noreferrer" title="RegEx Desktop tool"><em>RegEx Desktop Tool</em></a> for testing regular expressions.</p>
    </div></div></div><div class="solution-section"><nav class="flex pagination-solution flex-col justify-end"><ul class="inline-flex -space-x-px overflow-auto"><li class="pagination-solution-item"><span data-id="#solution1" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">1</span></li><li class="pagination-solution-item"><span data-id="#solution2" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">2</span></li><li class="pagination-solution-item"><span data-id="#solution3" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">3</span></li><li class="pagination-solution-item"><span data-id="#solution4" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">4</span></li><li class="pagination-solution-item"><span data-id="#solution5" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">5</span></li><li class="pagination-solution-item"><span data-id="#solution6" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">6</span></li><li class="pagination-solution-item"><span data-id="#solution7" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">7</span></li><li class="pagination-solution-item"><span data-id="#solution8" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">8</span></li></ul></nav><div id="solution1" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 1</h4><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<h2><em>Oh Yes You Can</em> Use Regexes to Parse HTML!</h2>
<p>For the task you are attempting, regexes are <strong><em>perfectly fine!</em></strong></p>
<p>It <em>is</em> true that most people underestimate the difficulty of parsing HTML with regular expressions and therefore do so poorly.</p>
<p>But this is not some fundamental flaw related to computational theory. <a href="https://stackoverflow.com/a/1732454/459233">That silliness is parroted a lot around here</a>, but dont you believe them.</p>
<p>So while it certainly can be done (this posting serves as an existence proof of this incontrovertible fact), that doesnt mean it&nbsp;<strong><em>should</em></strong>&nbsp;be.</p>
<p>You must decide for yourself whether youre up to the task of writing what amounts to a dedicated, special-purpose HTML parser out of regexes. Most people are not.</p>
<p>But <em>I</em> am. </p>
<hr>
<h2>General Regex-Based HTML Parsing Solutions</h2>
<p>First Ill show how easy it is to parse <strong>arbitrary</strong> HTML with regexes. The full programs at the end of this posting, but the heart of the parser is:</p>
<pre class="lang-perl s-code-block"><code class="hljs language-perl"><span class="hljs-keyword">for</span> (;;) {
  <span class="hljs-keyword">given</span> ($html) {
    <span class="hljs-keyword">last</span>                    <span class="hljs-keyword">when</span> (<span class="hljs-keyword">pos</span> || <span class="hljs-number">0</span>) &gt;= <span class="hljs-keyword">length</span>;
    <span class="hljs-keyword">printf</span> <span class="hljs-string">"\@%d="</span>,              (<span class="hljs-keyword">pos</span> || <span class="hljs-number">0</span>);
    <span class="hljs-keyword">print</span>  <span class="hljs-string">"doctype "</span>   <span class="hljs-keyword">when</span> / \G (?&amp;doctype)  $RX_SUBS  /xgc;
    <span class="hljs-keyword">print</span>  <span class="hljs-string">"cdata "</span>     <span class="hljs-keyword">when</span> / \G (?&amp;cdata)    $RX_SUBS  /xgc;
    <span class="hljs-keyword">print</span>  <span class="hljs-string">"xml "</span>       <span class="hljs-keyword">when</span> / \G (?&amp;xml)      $RX_SUBS  /xgc;
    <span class="hljs-keyword">print</span>  <span class="hljs-string">"xhook "</span>     <span class="hljs-keyword">when</span> / \G (?&amp;xhook)    $RX_SUBS  /xgc;
    <span class="hljs-keyword">print</span>  <span class="hljs-string">"script "</span>    <span class="hljs-keyword">when</span> / \G (?&amp;script)   $RX_SUBS  /xgc;
    <span class="hljs-keyword">print</span>  <span class="hljs-string">"style "</span>     <span class="hljs-keyword">when</span> / \G (?&amp;style)    $RX_SUBS  /xgc;
    <span class="hljs-keyword">print</span>  <span class="hljs-string">"comment "</span>   <span class="hljs-keyword">when</span> / \G (?&amp;comment)  $RX_SUBS  /xgc;
    <span class="hljs-keyword">print</span>  <span class="hljs-string">"tag "</span>       <span class="hljs-keyword">when</span> / \G (?&amp;tag)      $RX_SUBS  /xgc;
    <span class="hljs-keyword">print</span>  <span class="hljs-string">"untag "</span>     <span class="hljs-keyword">when</span> / \G (?&amp;untag)    $RX_SUBS  /xgc;
    <span class="hljs-keyword">print</span>  <span class="hljs-string">"nasty "</span>     <span class="hljs-keyword">when</span> / \G (?&amp;nasty)    $RX_SUBS  /xgc;
    <span class="hljs-keyword">print</span>  <span class="hljs-string">"text "</span>      <span class="hljs-keyword">when</span> / \G (?&amp;nontag)   $RX_SUBS  /xgc;
    default {
      <span class="hljs-keyword">die</span> <span class="hljs-string">"UNCLASSIFIED: "</span> .
        <span class="hljs-keyword">substr</span>($_, <span class="hljs-keyword">pos</span> || <span class="hljs-number">0</span>, (<span class="hljs-keyword">length</span> &gt; <span class="hljs-number">65</span>) ? <span class="hljs-number">65</span> : <span class="hljs-keyword">length</span>);
    }
  }
}
</code></pre>
<p>See how <em>easy</em> that is to read?</p>
<p>As written, it identifies each piece of HTML and tells  where it found that piece. You could easily modify it to do whatever else you want with any given type of piece, or for more particular types than these.</p>
<p>I have no failing test cases (left :): Ive successfully run this code on more than 100,000 HTML files  every single one I could quickly and easily get my hands on. Beyond those, Ive also run it on files <em>specifically constructed</em> to break naïve parsers.</p>
<p>This is <em>not</em> a naïve parser.</p>
<p>Oh, Im sure it isnt perfect, but I havent managed to break it yet.  I figure that even if something did, the fix would be easy to fit in because of the programs clear structure. Even regex-heavy programs should have stucture.</p>
<p>Now that thats out of the way, let me address the OPs question.</p>
<h2>Demo of Solving the OPs Task Using Regexes</h2>
<p>The little <code>html_input_rx</code> program I include below produces the following output, so that you can see that parsing HTML with regexes works just fine for what you wish to do:</p>
<pre class="lang-html s-code-block"><code class="hljs language-xml">% html_input_rx Amazon.com-_Online_Shopping_for_Electronics,_Apparel,_Computers,_Books,_DVDs_\&amp;_more.htm 
input tag #1 at character 9955:
       class =&gt; "searchSelect"
          id =&gt; "twotabsearchtextbox"
        name =&gt; "field-keywords"
        size =&gt; "50"
       style =&gt; "width:100%; background-color: #FFF;"
       title =&gt; "Search for"
        type =&gt; "text"
       value =&gt; ""

input tag #2 at character 10335:
         alt =&gt; "Go"
         src =&gt; "http://g-ecx.images-amazon.com/images/G/01/x-locale/common/transparent-pixel._V192234675_.gif"
        type =&gt; "image"
</code></pre>
<h2><em>Parse Input Tags, See No Evil Input</em></h2>
<p>Heres the source for the program that produced the output above.</p>
<pre class="lang-perl s-code-block"><code class="hljs language-perl"><span class="hljs-comment">#!/usr/bin/env perl</span>
<span class="hljs-comment">#</span>
<span class="hljs-comment"># html_input_rx - pull out all &lt;input&gt; tags from (X)HTML src</span>
<span class="hljs-comment">#                  via simple regex processing</span>
<span class="hljs-comment">#</span>
<span class="hljs-comment"># Tom Christiansen &lt;tchrist@perl.com&gt;</span>
<span class="hljs-comment"># Sat Nov 20 10:17:31 MST 2010</span>
<span class="hljs-comment">#</span>
<span class="hljs-comment">################################################################</span>

<span class="hljs-keyword">use</span> <span class="hljs-number">5.012</span>;

<span class="hljs-keyword">use</span> strict;
<span class="hljs-keyword">use</span> autodie;
<span class="hljs-keyword">use</span> warnings <span class="hljs-string">FATAL =&gt;</span> <span class="hljs-string">"all"</span>;    
<span class="hljs-keyword">use</span> subs <span class="hljs-string">qw{
    see_no_evil
    parse_input_tags
    input descape dequote
    load_patterns
}</span>;    
<span class="hljs-keyword">use</span> <span class="hljs-keyword">open</span>        <span class="hljs-string">":std"</span>,
          <span class="hljs-string">IN =&gt;</span> <span class="hljs-string">":bytes"</span>,
         <span class="hljs-string">OUT =&gt;</span> <span class="hljs-string">":utf8"</span>;    
<span class="hljs-keyword">use</span> Encode <span class="hljs-string">qw&lt; encode decode &gt;</span>;

    <span class="hljs-comment">###########################################################</span>

                        parse_input_tags 
                           see_no_evil 
                              input  

    <span class="hljs-comment">###########################################################</span>

<span class="hljs-keyword">until</span> <span class="hljs-keyword">eof</span>(); <span class="hljs-function"><span class="hljs-keyword">sub</span> <span class="hljs-title">parse_input_tags</span> </span>{
    <span class="hljs-keyword">my</span> $_ = <span class="hljs-keyword">shift</span>();
    <span class="hljs-keyword">our</span>($Input_Tag_Rx, $Pull_Attr_Rx);
    <span class="hljs-keyword">my</span> $count = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">while</span> (<span class="hljs-regexp">/$Input_Tag_Rx/pig</span>) {
        <span class="hljs-keyword">my</span> $input_tag = $+<span class="hljs-string">{TAG}</span>;
        <span class="hljs-keyword">my</span> $place     = <span class="hljs-keyword">pos</span>() - <span class="hljs-keyword">length</span> ${^MATCH};
        <span class="hljs-keyword">printf</span> <span class="hljs-string">"input tag #%d at character %d:\n"</span>, ++$count, $place;
        <span class="hljs-keyword">my</span> %attr = ();
        <span class="hljs-keyword">while</span> ($input_tag =~ <span class="hljs-regexp">/$Pull_Attr_Rx/g</span>) {
            <span class="hljs-keyword">my</span> ($name, $value) = @+{ <span class="hljs-string">qw&lt; NAME VALUE &gt;</span> };
            $value = dequote($value);
            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">exists</span> $attr{$name}) {
                <span class="hljs-keyword">printf</span> <span class="hljs-string">"Discarding dup attr value '%s' on %s attr\n"</span>,
                    $attr{$name} // <span class="hljs-string">"&lt;undef&gt;"</span>, $name;
            } 
            $attr{$name} = $value;
        } 
        <span class="hljs-keyword">for</span> <span class="hljs-keyword">my</span> $name (<span class="hljs-keyword">sort</span> <span class="hljs-keyword">keys</span> %attr) {
            <span class="hljs-keyword">printf</span> <span class="hljs-string">"  %10s =&gt; "</span>, $name;
            <span class="hljs-keyword">my</span> $value = descape $attr{$name};
            <span class="hljs-keyword">my</span>  @Q; <span class="hljs-keyword">given</span> ($value) {
                @Q = <span class="hljs-string">qw[  " "  ]</span>  <span class="hljs-keyword">when</span> !<span class="hljs-regexp">/'/</span> &amp;&amp; !<span class="hljs-regexp">/"/</span>;
                @Q = <span class="hljs-string">qw[  " "  ]</span>  <span class="hljs-keyword">when</span>  /<span class="hljs-string">'/ &amp;&amp; !/"/;
                @Q = qw[  '</span> <span class="hljs-string">'  ]  when !/'</span>/ &amp;&amp;  <span class="hljs-regexp">/"/</span>;
                @Q = <span class="hljs-string">qw[ q( )  ]</span>  <span class="hljs-keyword">when</span>  /<span class="hljs-string">'/ &amp;&amp;  /"/;
                default { die "NOTREACHED" }
            } 
            say $Q[0], $value, $Q[1];
        } 
        print "\n";
    } 

}

sub dequote {
    my $_ = $_[0];
    s{
        (?&lt;quote&gt;   ["'</span>]      )
        (?&lt;BODY&gt;    
          (?s: (?! \k&lt;quote&gt; ) . ) * 
        )
        \k&lt;quote&gt; 
    }{$+<span class="hljs-string">{BODY}</span>}six;
    <span class="hljs-keyword">return</span> $_;
} 

<span class="hljs-function"><span class="hljs-keyword">sub</span> <span class="hljs-title">descape</span> </span>{
    <span class="hljs-keyword">my</span> $string = $_[<span class="hljs-number">0</span>];
    <span class="hljs-keyword">for</span> <span class="hljs-keyword">my</span> $_ ($string) {
        <span class="hljs-regexp">s{
            (?&lt;! % )
            % ( \p{Hex_Digit} {2} )
        }{
            chr hex $1;
        }gs</span>ex;
        <span class="hljs-regexp">s{
            &amp; \043 
            ( [0-9]+ )
            (?: ; 
              | (?= [^0-9] )
            )
        }{
            chr     $1;
        }gs</span>ex;
        <span class="hljs-regexp">s{
            &amp; \043 x
            ( \p{ASCII_HexDigit} + )
            (?: ; 
              | (?= \P{ASCII_HexDigit} )
            )
        }{
            chr hex $1;
        }gs</span>ex;

    }
    <span class="hljs-keyword">return</span> $string;
} 

<span class="hljs-function"><span class="hljs-keyword">sub</span> <span class="hljs-title">input</span> </span>{ 
    <span class="hljs-keyword">our</span> ($RX_SUBS, $Meta_Tag_Rx);
    <span class="hljs-keyword">my</span> $_ = <span class="hljs-keyword">do</span> { <span class="hljs-keyword">local</span> $/; &lt;&gt; };  
    <span class="hljs-keyword">my</span> $encoding = <span class="hljs-string">"iso-8859-1"</span>;  <span class="hljs-comment"># web default; wish we had the HTTP headers :(</span>
    <span class="hljs-keyword">while</span> (<span class="hljs-regexp">/$Meta_Tag_Rx/gi</span>) {
        <span class="hljs-keyword">my</span> $meta = $+<span class="hljs-string">{META}</span>;
        <span class="hljs-keyword">next</span> <span class="hljs-keyword">unless</span> $meta =~ <span class="hljs-regexp">m{             $RX_SUBS
            (?= http-equiv ) 
            (?&amp;name) 
            (?&amp;equals) 
            (?= (?&amp;quote)? content-type )
            (?&amp;value)    
        }six</span>;
        <span class="hljs-keyword">next</span> <span class="hljs-keyword">unless</span> $meta =~ <span class="hljs-regexp">m{             $RX_SUBS
            (?= content ) (?&amp;name) 
                          (?&amp;equals) 
            (?&lt;CONTENT&gt;   (?&amp;value)    )
        }six</span>;
        <span class="hljs-keyword">next</span> <span class="hljs-keyword">unless</span> $+<span class="hljs-string">{CONTENT}</span> =~ <span class="hljs-regexp">m{       $RX_SUBS
            (?= charset ) (?&amp;name) 
                          (?&amp;equals) 
            (?&lt;CHARSET&gt;   (?&amp;value)    )
        }six</span>;
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">lc</span> $encoding <span class="hljs-keyword">ne</span> <span class="hljs-keyword">lc</span> $+<span class="hljs-string">{CHARSET}</span>) {
            <span class="hljs-keyword">say</span> <span class="hljs-string">"[RESETTING ENCODING $encoding =&gt; $+{CHARSET}]"</span>;
            $encoding = $+<span class="hljs-string">{CHARSET}</span>;
        }
    } 
    <span class="hljs-keyword">return</span> decode($encoding, $_);
}

<span class="hljs-function"><span class="hljs-keyword">sub</span> <span class="hljs-title">see_no_evil</span> </span>{
    <span class="hljs-keyword">my</span> $_ = <span class="hljs-keyword">shift</span>();

    <span class="hljs-regexp">s{ &lt;!    DOCTYPE  .*?         &gt; }{}sx</span>; 
    <span class="hljs-regexp">s{ &lt;! \[ CDATA \[ .*?    \]\] &gt; }{}gsx</span>; 

    s{ &lt;script&gt; .*?  &lt;<span class="hljs-regexp">/script&gt; }{}gsix; 
    s{ &lt;!--     .*?        --&gt; }{}gsx;

    return $_;
}

sub load_patterns { 

    our $RX_SUBS = qr{ (?(DEFINE)
        (?&lt;nv_pair&gt;         (?&amp;name) (?&amp;equals) (?&amp;value)         ) 
        (?&lt;name&gt;            \b (?=  \pL ) [\w\-] + (?&lt;= \pL ) \b  )
        (?&lt;equals&gt;          (?&amp;might_white)  = (?&amp;might_white)    )
        (?&lt;value&gt;           (?&amp;quoted_value) | (?&amp;unquoted_value) )
        (?&lt;unwhite_chunk&gt;   (?: (?! &gt; ) \S ) +                    )
        (?&lt;unquoted_value&gt;  [\w\-] *                              )
        (?&lt;might_white&gt;     \s *                                  )
        (?&lt;quoted_value&gt;
            (?&lt;quote&gt;   ["']      )
            (?: (?! \k&lt;quote&gt; ) . ) *
            \k&lt;quote&gt; 
        )
        (?&lt;start_tag&gt;  &lt; (?&amp;might_white) )
        (?&lt;end_tag&gt;          
            (?&amp;might_white)
            (?: (?&amp;html_end_tag) 
              | (?&amp;xhtml_end_tag) 
             )
        )
        (?&lt;html_end_tag&gt;       &gt;  )
        (?&lt;xhtml_end_tag&gt;    /</span> &gt;  )
    ) }six; 

    <span class="hljs-keyword">our</span> $Meta_Tag_Rx = <span class="hljs-regexp">qr{                          $RX_SUBS 
        (?&lt;META&gt; 
            (?&amp;start_tag) meta \b
            (?:
                (?&amp;might_white) (?&amp;nv_pair) 
            ) +
            (?&amp;end_tag)
        )
    }six</span>;

    <span class="hljs-keyword">our</span> $Pull_Attr_Rx = <span class="hljs-regexp">qr{                         $RX_SUBS
        (?&lt;NAME&gt;  (?&amp;name)      )
                  (?&amp;equals) 
        (?&lt;VALUE&gt; (?&amp;value)     )
    }six</span>;

    <span class="hljs-keyword">our</span> $Input_Tag_Rx = <span class="hljs-regexp">qr{                         $RX_SUBS 

        (?&lt;TAG&gt; (?&amp;input_tag) )

        (?(DEFINE)

            (?&lt;input_tag&gt;
                (?&amp;start_tag)
                input
                (?&amp;might_white) 
                (?&amp;attributes) 
                (?&amp;might_white) 
                (?&amp;end_tag)
            )

            (?&lt;attributes&gt;
                (?: 
                    (?&amp;might_white) 
                    (?&amp;one_attribute) 
                ) *
            )

            (?&lt;one_attribute&gt;
                \b
                (?&amp;legal_attribute)
                (?&amp;might_white) = (?&amp;might_white) 
                (?:
                    (?&amp;quoted_value)
                  | (?&amp;unquoted_value)
                )
            )

            (?&lt;legal_attribute&gt; 
                (?: (?&amp;optional_attribute)
                  | (?&amp;standard_attribute)
                  | (?&amp;event_attribute)
            # for LEGAL parse only, comment out next line 
                  | (?&amp;illegal_attribute)
                )
            )

            (?&lt;illegal_attribute&gt;  (?&amp;name) )

            (?&lt;required_attribute&gt; (?#no required attributes) )

            (?&lt;optional_attribute&gt;
                (?&amp;permitted_attribute)
              | (?&amp;deprecated_attribute)
            )

            # NB: The white space in string literals 
            #     below DOES NOT COUNT!   It's just 
            #     there for legibility.

            (?&lt;permitted_attribute&gt;
                  accept
                | alt
                | bottom
                | check box
                | checked
                | disabled
                | file
                | hidden
                | image
                | max length
                | middle
                | name
                | password
                | radio
                | read only
                | reset
                | right
                | size
                | src
                | submit
                | text
                | top
                | type
                | value
            )

            (?&lt;deprecated_attribute&gt;
                  align
            )

            (?&lt;standard_attribute&gt;
                  access key
                | class
                | dir
                | ltr
                | id
                | lang
                | style
                | tab index
                | title
                | xml:lang
            )

            (?&lt;event_attribute&gt;
                  on blur
                | on change
                | on click
                | on dbl   click
                | on focus
                | on mouse down
                | on mouse move
                | on mouse out
                | on mouse over
                | on mouse up
                | on key   down
                | on key   press
                | on key   up
                | on select
            )
        )
    }six</span>;

}

UNITCHECK {
    load_patterns();
} 

END {
    <span class="hljs-keyword">close</span>(STDOUT) 
        || <span class="hljs-keyword">die</span> <span class="hljs-string">"can't close stdout: $!"</span>;
} 
</code></pre>
<p>There you go! Nothing to it! :)</p>
<p>Only  <strong><em>you</em></strong> can judge whether your skill with regexes is up to any particular parsing task. Everyones level of skill is different, and every new task is different. For jobs where you have a well-defined input set, regexes are obviously the right choice, because it is trivial to put some together when you have a restricted subset of HTML to deal with. Even regex beginners should be handle those jobs with regexes.  Anything else is overkill.</p>
<p><strong>However</strong>, once the HTML starts becoming less nailed down, once it starts to ramify in ways you cannot predict but which are perfectly legal, once you have to match more different sorts of things or with more complex dependencies, you will eventually reach a point where you have to work harder to effect a solution that uses regexes than you would have to using a parsing class. Where that break-even point falls  depends again on your own comfort level with regexes.</p>
<h2>So What Should I Do?</h2>
<p>Im not going to tell you what you <em>must</em> do or what you <em>cannot</em> do.  I think thats Wrong. I just want to present you with possibilties, open your eyes a bit. You get to choose what you want to do and how you want to do it. There are no absolutes  and nobody else knows your own situation as well as you yourself do. If something seems like its too much work, well, maybe it is.  Programming should be <strong><em>fun</em></strong>, you know. If it isnt, you may be doing it wrong.</p>
<p>One can look at my <code>html_input_rx</code> program in any number of valid ways.  One such is that you indeed <em>can</em> parse HTML with regular expressions. But another is that it is much, much, much harder than almost anyone ever thinks it is. This can easily lead to the conclusion that my program is a testament to what you should <em>not</em> do, because it really is too hard.</p>
<p>I wont disagree with that.  Certainly if everything I do in my program doesnt make sense to you after some study, then you should not be attempting to use regexes for this kind of task. For specific HTML, regexes are great, but for generic HTML, theyre tantamount to madness. I use parsing classes all the time, especially if its HTML I havent generated myself.</p>
<h2>Regexes  optimal for <em>small</em> HTML parsing problems,  pessimal for large ones</h2>
<p>Even if my program is taken as  illustrative of why you should <strong>not</strong> use regexes for parsing general HTML  which is OK, because I kinda meant for it to be that    it still should be an eye-opener so more people break the terribly common and nasty, nasty habit of writing unreadable, unstructured, and unmaintainable patterns.</p>
<p>Patterns do not have to be ugly, and they do not have to be hard. If you create ugly patterns, it is a reflection on you, not them.</p>
<h2>Phenomenally Exquisite Regex Language</h2>
<p>Ive been asked to point out that my proferred solution to your problem has been written in Perl. Are you surprised? Did you not notice? Is this revelation a bombshell?</p>
<p>It is true that not all other tools and programming languages are quite as convenient, expressive, and powerful when it comes to regexes as Perl is. Theres a big spectrum out there, with some being more suitable than others.  In general, the languages that have expressed regexes as part of the core language instead of as a library are easier to work with. Ive done nothing with regexes that you couldnt do in, say, PCRE, although you would structure the program differently if you were using C.</p>
<p>Eventually other languages will be catch up with where Perl is now in terms of regexes.  I say this because back when Perl started, nobody else had anything like Perls regexes. Say anything you like, but this is where Perl clearly won: everybody copied Perls regexes albeit at varying stages of their development.  Perl pioneered almost (not quite all, but almost) everything that you have come to rely on in modern patterns today, no matter what tool or language you use.  So eventually the others <em>will</em> catch up.</p>
<p>But theyll only catch up to where Perl was sometime in the past, just as it is now.  Everything advances.  In regexes if nothing else, where Perl leads, others follow. Where will Perl be once everybody else finally catches up to where Perl is now?  I have no idea, but I know we too will have moved. Probably well be closer to <a href="http://perlcabal.org/syn/S05.html" rel="noreferrer">Perls style of crafting patterns</a>.</p>
<p>If you like that kind  of thing but would like to use it in Perl,  you might be interested in <a href="http://search.cpan.org/search?query=regexp+grammars&amp;mode=module" rel="noreferrer">Damian Conways <strong>wonderful</strong> Regexp::Grammars</a> module. Its completely awesome, and makes what Ive done here in my program seem just as primitive as mine makes the patterns that people cram together without whitespace or alphabetic identifiers.  Check it out!</p>
<hr>
<h2>Simple HTML Chunker</h2>
<p>Here is the complete source to the parser I showed the centerpiece from at the beginning of this posting.</p>
<p>I am <em>not</em> suggesting that you should use this over a rigorously tested parsing class. But I am tired of people pretending that nobody can parse HTML with regexes just because <em>they</em> cant. You clearly can, and this program is proof of that assertion.</p>
<p>Sure,  it isnt easy, but <strong>it <em>is</em> possible!</strong></p>
<p>And trying to do so is a terrible waste of time, because good parsing classes exist which you <em>should</em> use for this task.  The right answer to people trying to parse <em>arbitrary</em> HTML is <strong>not</strong> that it is impossible.  That is a facile and disingenuous answer.  The correct and honest answer is that they shouldnt attempt it because it is too much of a bother to figure out from scratch; they should not  break their back striving to reïnvent a wheel that works perfectly well.</p>
<p>On the other hand, HTML that falls <em>within a predicable subset</em> is ultra-easy to parse with regexes. Its no wonder people try to use them, because for small problems, toy problems perhaps, nothing could be easier. Thats why its so important to distinguish the two tasks  specific vs generic  as these do not necessarily demand the same approach.</p>
<p>I hope in the future here to see a more fair and honest treatment of questions about HTML and regexes.</p>
<p>Heres my HTML lexer.  It doesnt try to do a validating parse; it just identifies the lexical elements. You might think of it more as <strong>an HTML chunker</strong> than an HTML parser. It isnt very forgiving of broken HTML, although it makes some very small allowances in that direction.</p>
<p>Even if you never parse full HTML yourself (and why should you? its a solved problem!), this program has lots of cool regex bits that I believe a lot of people can learn a lot from.  Enjoy!</p>
<pre class="lang-perl s-code-block"><code class="hljs language-perl"><span class="hljs-comment">#!/usr/bin/env perl</span>
<span class="hljs-comment">#</span>
<span class="hljs-comment"># chunk_HTML - a regex-based HTML chunker</span>
<span class="hljs-comment">#</span>
<span class="hljs-comment"># Tom Christiansen &lt;tchrist@perl.com</span>
<span class="hljs-comment">#   Sun Nov 21 19:16:02 MST 2010</span>
<span class="hljs-comment">########################################</span>

<span class="hljs-keyword">use</span> <span class="hljs-number">5.012</span>;

<span class="hljs-keyword">use</span> strict;
<span class="hljs-keyword">use</span> autodie;
<span class="hljs-keyword">use</span> warnings <span class="hljs-string">qw&lt; FATAL all &gt;</span>;
<span class="hljs-keyword">use</span> <span class="hljs-keyword">open</span>     <span class="hljs-string">qw&lt; IN :bytes OUT :utf8 :std &gt;</span>;

MAIN: {
  $| = <span class="hljs-number">1</span>;
  lex_html(<span class="hljs-keyword">my</span> $page = slurpy());
  <span class="hljs-keyword">exit</span>();
}

<span class="hljs-comment">########################################################################</span>
<span class="hljs-function"><span class="hljs-keyword">sub</span> <span class="hljs-title">lex_html</span> </span>{
    <span class="hljs-keyword">our</span> $RX_SUBS;                                        <span class="hljs-comment">###############</span>
    <span class="hljs-keyword">my</span>  $html = <span class="hljs-keyword">shift</span>();                                 <span class="hljs-comment"># Am I...     #</span>
    <span class="hljs-keyword">for</span> (;;) {                                           <span class="hljs-comment"># forgiven? :)#</span>
        <span class="hljs-keyword">given</span> ($html) {                                  <span class="hljs-comment">###############</span>
            <span class="hljs-keyword">last</span>                <span class="hljs-keyword">when</span> (<span class="hljs-keyword">pos</span> || <span class="hljs-number">0</span>) &gt;= <span class="hljs-keyword">length</span>;
            <span class="hljs-keyword">printf</span> <span class="hljs-string">"\@%d="</span>,          (<span class="hljs-keyword">pos</span> || <span class="hljs-number">0</span>);
            <span class="hljs-keyword">print</span>  <span class="hljs-string">"doctype "</span>   <span class="hljs-keyword">when</span> / \G (?&amp;doctype)  $RX_SUBS  /xgc;
            <span class="hljs-keyword">print</span>  <span class="hljs-string">"cdata "</span>     <span class="hljs-keyword">when</span> / \G (?&amp;cdata)    $RX_SUBS  /xgc;
            <span class="hljs-keyword">print</span>  <span class="hljs-string">"xml "</span>       <span class="hljs-keyword">when</span> / \G (?&amp;xml)      $RX_SUBS  /xgc;
            <span class="hljs-keyword">print</span>  <span class="hljs-string">"xhook "</span>     <span class="hljs-keyword">when</span> / \G (?&amp;xhook)    $RX_SUBS  /xgc;
            <span class="hljs-keyword">print</span>  <span class="hljs-string">"script "</span>    <span class="hljs-keyword">when</span> / \G (?&amp;script)   $RX_SUBS  /xgc;
            <span class="hljs-keyword">print</span>  <span class="hljs-string">"style "</span>     <span class="hljs-keyword">when</span> / \G (?&amp;style)    $RX_SUBS  /xgc;
            <span class="hljs-keyword">print</span>  <span class="hljs-string">"comment "</span>   <span class="hljs-keyword">when</span> / \G (?&amp;comment)  $RX_SUBS  /xgc;
            <span class="hljs-keyword">print</span>  <span class="hljs-string">"tag "</span>       <span class="hljs-keyword">when</span> / \G (?&amp;tag)      $RX_SUBS  /xgc;
            <span class="hljs-keyword">print</span>  <span class="hljs-string">"untag "</span>     <span class="hljs-keyword">when</span> / \G (?&amp;untag)    $RX_SUBS  /xgc;
            <span class="hljs-keyword">print</span>  <span class="hljs-string">"nasty "</span>     <span class="hljs-keyword">when</span> / \G (?&amp;nasty)    $RX_SUBS  /xgc;
            <span class="hljs-keyword">print</span>  <span class="hljs-string">"text "</span>      <span class="hljs-keyword">when</span> / \G (?&amp;nontag)   $RX_SUBS  /xgc;
            default {
                <span class="hljs-keyword">die</span> <span class="hljs-string">"UNCLASSIFIED: "</span> .
                  <span class="hljs-keyword">substr</span>($_, <span class="hljs-keyword">pos</span> || <span class="hljs-number">0</span>, (<span class="hljs-keyword">length</span> &gt; <span class="hljs-number">65</span>) ? <span class="hljs-number">65</span> : <span class="hljs-keyword">length</span>);
            }
        }
    }
    <span class="hljs-keyword">say</span> <span class="hljs-string">"."</span>;
}
<span class="hljs-comment">#####################</span>
<span class="hljs-comment"># Return correctly decoded contents of next complete</span>
<span class="hljs-comment"># file slurped in from the &lt;ARGV&gt; stream.</span>
<span class="hljs-comment">#</span>
<span class="hljs-function"><span class="hljs-keyword">sub</span> <span class="hljs-title">slurpy</span> </span>{
    <span class="hljs-keyword">our</span> ($RX_SUBS, $Meta_Tag_Rx);
    <span class="hljs-keyword">my</span> $_ = <span class="hljs-keyword">do</span> { <span class="hljs-keyword">local</span> $/; &lt;ARGV&gt; };   <span class="hljs-comment"># read all input</span>

    <span class="hljs-keyword">return</span> <span class="hljs-keyword">unless</span> <span class="hljs-keyword">length</span>;

    <span class="hljs-keyword">use</span> Encode   <span class="hljs-string">qw&lt; decode &gt;</span>;

    <span class="hljs-keyword">my</span> $bom = <span class="hljs-string">""</span>;
    <span class="hljs-keyword">given</span> ($_) {
        $bom = <span class="hljs-string">"UTF-32LE"</span> <span class="hljs-keyword">when</span> / ^ \xFf \xFe \<span class="hljs-number">0</span>   \<span class="hljs-number">0</span>   /<span class="hljs-keyword">x</span>;  <span class="hljs-comment"># LE</span>
        $bom = <span class="hljs-string">"UTF-32BE"</span> <span class="hljs-keyword">when</span> / ^ \<span class="hljs-number">0</span>   \<span class="hljs-number">0</span>   \xFe \xFf /<span class="hljs-keyword">x</span>;  <span class="hljs-comment">#   BE</span>
        $bom = <span class="hljs-string">"UTF-16LE"</span> <span class="hljs-keyword">when</span> / ^ \xFf \xFe           /<span class="hljs-keyword">x</span>;  <span class="hljs-comment"># le</span>
        $bom = <span class="hljs-string">"UTF-16BE"</span> <span class="hljs-keyword">when</span> / ^ \xFe \xFf           /<span class="hljs-keyword">x</span>;  <span class="hljs-comment">#   be</span>
        $bom = <span class="hljs-string">"UTF-8"</span>    <span class="hljs-keyword">when</span> / ^ \xEF \xBB \xBF      /<span class="hljs-keyword">x</span>;  <span class="hljs-comment"># st00pid</span>
    }
    <span class="hljs-keyword">if</span> ($bom) {
        <span class="hljs-keyword">say</span> <span class="hljs-string">"[BOM $bom]"</span>;
        <span class="hljs-regexp">s/^...//</span> <span class="hljs-keyword">if</span> $bom eq <span class="hljs-string">"UTF-8"</span>;                        <span class="hljs-comment"># st00pid</span>

        <span class="hljs-comment"># Must use UTF-(16|32) w/o -[BL]E to strip BOM.</span>
        $bom =~ <span class="hljs-regexp">s/-[LB]E//</span>;

        <span class="hljs-keyword">return</span> decode($bom, $_);

        <span class="hljs-comment"># if BOM found, don't fall through to look</span>
        <span class="hljs-comment">#  for embedded encoding spec</span>
    }

    <span class="hljs-comment"># Latin1 is web default if not otherwise specified.</span>
    <span class="hljs-comment"># No way to do this correctly if it was overridden</span>
    <span class="hljs-comment"># in the HTTP header, since we assume stream contains</span>
    <span class="hljs-comment"># HTML only, not also the HTTP header.</span>
    <span class="hljs-keyword">my</span> $encoding = <span class="hljs-string">"iso-8859-1"</span>;
    <span class="hljs-keyword">while</span> (<span class="hljs-regexp">/ (?&amp;xml) $RX_SUBS /pgx</span>) {
        <span class="hljs-keyword">my</span> $xml = ${^MATCH};
        <span class="hljs-keyword">next</span> <span class="hljs-keyword">unless</span> $xml =~ <span class="hljs-regexp">m{              $RX_SUBS
            (?= encoding )  (?&amp;name)
                            (?&amp;equals)
                            (?&amp;quote) ?
            (?&lt;ENCODING&gt;    (?&amp;value)       )
        }sx</span>;
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">lc</span> $encoding <span class="hljs-keyword">ne</span> <span class="hljs-keyword">lc</span> $+<span class="hljs-string">{ENCODING}</span>) {
            <span class="hljs-keyword">say</span> <span class="hljs-string">"[XML ENCODING $encoding =&gt; $+{ENCODING}]"</span>;
            $encoding = $+<span class="hljs-string">{ENCODING}</span>;
        }
    }

    <span class="hljs-keyword">while</span> (<span class="hljs-regexp">/$Meta_Tag_Rx/gi</span>) {
        <span class="hljs-keyword">my</span> $meta = $+<span class="hljs-string">{META}</span>;

        <span class="hljs-keyword">next</span> <span class="hljs-keyword">unless</span> $meta =~ <span class="hljs-regexp">m{             $RX_SUBS
            (?= http-equiv )    (?&amp;name)
                                (?&amp;equals)
            (?= (?&amp;quote)? content-type )
                                (?&amp;value)
        }six</span>;

        <span class="hljs-keyword">next</span> <span class="hljs-keyword">unless</span> $meta =~ <span class="hljs-regexp">m{             $RX_SUBS
            (?= content )       (?&amp;name)
                                (?&amp;equals)
            (?&lt;CONTENT&gt;         (?&amp;value)    )
        }six</span>;

        <span class="hljs-keyword">next</span> <span class="hljs-keyword">unless</span> $+<span class="hljs-string">{CONTENT}</span> =~ <span class="hljs-regexp">m{       $RX_SUBS
            (?= charset )       (?&amp;name)
                                (?&amp;equals)
            (?&lt;CHARSET&gt;         (?&amp;value)    )
        }six</span>;

        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">lc</span> $encoding <span class="hljs-keyword">ne</span> <span class="hljs-keyword">lc</span> $+<span class="hljs-string">{CHARSET}</span>) {
            <span class="hljs-keyword">say</span> <span class="hljs-string">"[HTTP-EQUIV ENCODING $encoding =&gt; $+{CHARSET}]"</span>;
            $encoding = $+<span class="hljs-string">{CHARSET}</span>;
        }
    }

    <span class="hljs-keyword">return</span> decode($encoding, $_);
}
<span class="hljs-comment">########################################################################</span>
<span class="hljs-comment"># Make sure to this function is called</span>
<span class="hljs-comment"># as soon as source unit has been compiled.</span>
UNITCHECK { load_rxsubs() }

<span class="hljs-comment"># useful regex subroutines for HTML parsing</span>
<span class="hljs-function"><span class="hljs-keyword">sub</span> <span class="hljs-title">load_rxsubs</span> </span>{

    <span class="hljs-keyword">our</span> $RX_SUBS = <span class="hljs-string">qr{
      (?(DEFINE)

        (?&lt;WS&gt; \s *  )

        (?&lt;any_nv_pair&gt;     (?&amp;name) (?&amp;equals) (?&amp;value)         )
        (?&lt;name&gt;            \b (?=  \pL ) [\w:\-] +  \b           )
        (?&lt;equals&gt;          (?&amp;WS)  = (?&amp;WS)    )
        (?&lt;value&gt;           (?&amp;quoted_value) | (?&amp;unquoted_value) )
        (?&lt;unwhite_chunk&gt;   (?: (?! &gt; ) \S ) +                    )

        (?&lt;unquoted_value&gt;  [\w:\-] *                             )

        (?&lt;any_quote&gt;  ["']      )

        (?&lt;quoted_value&gt;
            (?&lt;quote&gt;   (?&amp;any_quote)  )
            (?: (?! \k&lt;quote&gt; ) . ) *
            \k&lt;quote&gt;
        )

        (?&lt;start_tag&gt;       &lt; (?&amp;WS)      )
        (?&lt;html_end_tag&gt;      &gt;           )
        (?&lt;xhtml_end_tag&gt;   / &gt;           )
        (?&lt;end_tag&gt;
            (?&amp;WS)
            (?: (?&amp;html_end_tag)
              | (?&amp;xhtml_end_tag) )
         )

        (?&lt;tag&gt;
            (?&amp;start_tag)
            (?&amp;name)
            (?:
                (?&amp;WS)
                (?&amp;any_nv_pair)
            ) *
            (?&amp;end_tag)
        )

        (?&lt;untag&gt; &lt;/ (?&amp;name) &gt; )

        # starts like a tag, but has screwed up quotes inside it
        (?&lt;nasty&gt;
            (?&amp;start_tag)
            (?&amp;name)
            .*?
            (?&amp;end_tag)
        )

        (?&lt;nontag&gt;    [^&lt;] +            )

        (?&lt;string&gt; (?&amp;quoted_value)     )
        (?&lt;word&gt;   (?&amp;name)             )

        (?&lt;doctype&gt;
            &lt;!DOCTYPE
                # please don't feed me nonHTML
                ### (?&amp;WS) HTML
            [^&gt;]* &gt;
        )

        (?&lt;cdata&gt;   &lt;!\[CDATA\[     .*?     \]\]    &gt; )
        (?&lt;script&gt;  (?= &lt;script ) (?&amp;tag)   .*?     &lt;/script&gt; )
        (?&lt;style&gt;   (?= &lt;style  ) (?&amp;tag)   .*?     &lt;/style&gt; )
        (?&lt;comment&gt; &lt;!--            .*?           --&gt; )

        (?&lt;xml&gt;
            &lt; \? xml
            (?:
                (?&amp;WS)
                (?&amp;any_nv_pair)
            ) *
            (?&amp;WS)
            \? &gt;
        )

        (?&lt;xhook&gt; &lt; \? .*? \? &gt; )

      )

    }</span>six;

    <span class="hljs-keyword">our</span> $Meta_Tag_Rx = <span class="hljs-regexp">qr{                          $RX_SUBS
        (?&lt;META&gt;
            (?&amp;start_tag) meta \b
            (?:
                (?&amp;WS) (?&amp;any_nv_pair)
            ) +
            (?&amp;end_tag)
        )
    }six</span>;

}

<span class="hljs-comment"># nobody *ever* remembers to do this!</span>
END { <span class="hljs-keyword">close</span> STDOUT }
</code></pre>
    </div></div></div></div><div id="solution2" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 2</h4><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<ol>
<li>You can write a novel like tchrist did</li>
<li>You can use a DOM library, load the HTML and use xpath and just use <code>//input[@type="hidden"]</code>. Or if you don't want to use xpath, just get all inputs and filter which ones are hidden with <code>getAttribute</code>.</li>
</ol>

<p>I prefer #2.</p>

<pre class="lang-html s-code-block"><code class="hljs language-xml"><span class="hljs-meta">&lt;?php

$d = new DOMDocument();
$d-&gt;loadHTML(
    '
    &lt;p&gt;fsdjl&lt;/p&gt;
    &lt;form&gt;&lt;div&gt;fdsjl&lt;/div&gt;&lt;/form&gt;
    &lt;input type="hidden" name="blah" value="hide yo kids"&gt;
    &lt;input type="text" name="blah" value="hide yo kids"&gt;
    &lt;input type="hidden" name="blah" value="hide yo wife"&gt;
');
$x = new DOMXpath($d);
$inputs = $x-&gt;evaluate('//input[@type="hidden"]');

foreach ( $inputs as $input ) {
    echo $input-&gt;getAttribute('value'), '&lt;br&gt;';
}
</span></code></pre>

<p>Result:</p>

<pre class="lang-html s-code-block"><code class="hljs language-xml">hide yo kids<span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span>hide yo wife<span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span>
</code></pre>
    </div></div></div></div><div id="solution3" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 3</h4><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Contrary to all the answers here, for what you're trying to do regex is a perfectly valid solution. This is because you are NOT trying to match balanced tags-- THAT would be impossible with regex! But you are only matching what's in one tag, and that's perfectly regular.</p>

<p>Here's the problem, though. You can't do it with just one regex... you need to do one match to capture an <code>&lt;input&gt;</code> tag, then do further processing on that. Note that this will only work if none of the attribute values have a <code>&gt;</code> character in them, so it's not perfect, but it should suffice for sane inputs.</p>

<p>Here's some Perl (pseudo)code to show you what I mean:</p>

<pre class="lang-html s-code-block"><code class="hljs language-xml">my $html = readLargeInputFile();

my @input_tags = $html =~ m/
    (
        <span class="hljs-tag">&lt;<span class="hljs-name">input</span>                      # <span class="hljs-attr">Starts</span> <span class="hljs-attr">with</span> "&lt;<span class="hljs-attr">input</span>"
        (?=<span class="hljs-string">[^</span>&gt;</span>]*?type="hidden")     # Use lookahead to make sure that type="hidden"
        [^&gt;]+                       # Grab the rest of the tag...
        \/&gt;                         # ...except for the /&gt;, which is grabbed here
    )/xgm;

# Now each member of @input_tags is something like <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"hidden"</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"SaveRequired"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"False"</span> /&gt;</span>

foreach my $input_tag (@input_tags)
{
  my $hash_ref = {};
  # Now extract each of the fields one at a time.

  ($hash_ref-&gt;{"name"}) = $input_tag =~ /name="([^"]*)"/;
  ($hash_ref-&gt;{"value"}) = $input_tag =~ /value="([^"]*)"/;

  # Put $hash_ref in a list or something, or otherwise process it
}
</code></pre>

<p>The basic principle here is, don't try to do too much with one regular expression. As you noticed, regular expressions enforce a certain amount of order. So what you need to do instead is to first match the CONTEXT of what you're trying to extract, then do submatching on the data you want.</p>

<p><b>EDIT:</b> However, I will agree that in general, using an HTML parser is probably easier and better and you really should consider redesigning your code or re-examining your objectives. :-) But I had to post this answer as a counter to the knee-jerk reaction that parsing any subset of HTML is impossible: HTML and XML are both irregular when you consider the entire specification, but the specification of a tag is decently regular, certainly within the power of PCRE.</p>
    </div></div></div></div><div id="solution4" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 4</h4><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>In the spirit of Tom Christiansen's lexer solution, here's a link to Robert Cameron's seemingly forgotten 1998 article, <em>REX: XML Shallow Parsing with Regular Expressions.</em></p>

<p><a href="http://www.cs.sfu.ca/~cameron/REX.html">http://www.cs.sfu.ca/~cameron/REX.html</a></p>

<blockquote>
  <p>Abstract</p>
  
  <p>The syntax of XML is simple enough that it is possible to parse an XML document into a list of its markup and text items using a single regular expression. Such a shallow parse of an XML document can be very useful for the construction of a variety of lightweight XML processing tools. However, complex regular expressions can be difficult to construct and even more difficult to read. Using a form of literate programming for regular expressions, this paper documents a set of XML shallow parsing expressions that can be used a basis for simple, correct, efficient, robust and language-independent XML shallow parsing. Complete shallow parser implementations of less than 50 lines each in Perl, JavaScript and Lex/Flex are also given.</p>
</blockquote>

<p>If you enjoy reading about regular expressions, Cameron's paper is fascinating. His writing is concise, thorough, and very detailed. He's not simply showing you how to construct the REX regular expression but also an approach for building up any complex regex from smaller parts.</p>

<p>I've been using the REX regular expression on and off for 10 years to solve the sort of problem the initial poster asked about (how do I match this particular tag but not some other very similar tag?). I've found the regex he developed to be completely reliable.</p>

<p>REX is particularly useful when you're focusing on lexical details of a document -- for example, when transforming one kind of text document (e.g., plain text, XML, SGML, HTML) into another, where the document may not be valid, well formed, or even parsable for most of the transformation. It lets you target islands of markup anywhere within a document without disturbing the rest of the document.</p>
    </div></div></div></div><div id="solution5" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 5</h4><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>While I love the contents of the rest of these answers, they didn't really answer the question directly or as correctly.  Even Platinum's answer was overly complicated, and also less efficient.  So I was forced to put this.</p>

<p>I'm a huge proponent of Regex, when used correctly.  But because of stigma (and performance), I always state that well-formed XML or HTML should use an XML Parser.  And even better performance would be string-parsing, though there's a line between readability if that gets too out-of-hand.  However, that isn't the question.  The question is how to match a hidden-type input tag.  The answer is:</p>

<pre class="lang-html s-code-block"><code class="hljs language-xml">&lt;input[^&gt;]*type="hidden"[^&gt;]*&gt;
</code></pre>

<p>Depending on your flavor, the only regex option you'd need to include is the ignorecase option.</p>
    </div></div></div></div><div id="solution6" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 6</h4><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>you can try this :</p>

<pre class="lang-html s-code-block"><code class="hljs language-xml">&lt;[A-Za-z ="/_0-9+]*&gt;
</code></pre>

<p>and for closer result you can try this :</p>

<pre class="lang-html s-code-block"><code class="hljs language-xml">&lt;[ ]*input[ ]+type="hidden"[ ]*name=[A-Za-z ="_0-9+]*[ ]*[/]*&gt;
</code></pre>

<p>you can test your regex pattern here <a href="http://regexpal.com/" rel="nofollow">http://regexpal.com/</a></p>

<p>these pattens are good for this:</p>

<pre class="lang-html s-code-block"><code class="hljs language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"hidden"</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"SaveRequired"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"False"</span> /&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"hidden"</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"__VIEWSTATE1"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"1H4sIAAtzrkX7QfL5VEGj6nGi+nP"</span> /&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"hidden"</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"__VIEWSTATE2"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"0351118MK"</span> /&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"hidden"</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"__VIEWSTATE3"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"ZVVV91yjY"</span> /&gt;</span>
</code></pre>

<p></p>

<p>and for random order of <code>type</code> , <code>name</code> and <code>value</code> u can use this :</p>

<pre class="lang-html s-code-block"><code class="hljs language-xml">&lt;[ ]*input[ ]*[A-Za-z ="_0-9+/]*&gt;
</code></pre>

<p>or</p>

<pre class="lang-html s-code-block"><code class="hljs language-xml">&lt;[ ]*input[ ]*[A-Za-z ="_0-9+/]*[ ]*[/]&gt;
</code></pre>

<p>on this :</p>

<pre class="lang-html s-code-block"><code class="hljs language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">input</span>  <span class="hljs-attr">name</span>=<span class="hljs-string">"SaveRequired"</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"hidden"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"False"</span> /&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"hidden"</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"__VIEWSTATE1"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"1H4sIAAtzrkX7QfL5VEGj6nGi+nP"</span> /&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"hidden"</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"__VIEWSTATE2"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"0351118MK"</span> /&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">input</span>  <span class="hljs-attr">name</span>=<span class="hljs-string">"__VIEWSTATE3"</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"hidden"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"ZVVV91yjY"</span> /&gt;</span>
</code></pre>

<p>
`</p>

<p>by the way i think you want something like this :</p>

<pre class="lang-html s-code-block"><code class="hljs language-xml">&lt;[ ]*input(([ ]*type="hidden"[ ]*name=[A-Za-z0-9_+"]*[ ]*value=[A-Za-z0-9_+"]*[ ]*)+)[ ]*/&gt;|&lt;[ ]*input(([ ]*type="hidden"[ ]*value=[A-Za-z0-9_+"]*[ ]*name=[A-Za-z0-9_+"]*[ ]*)+)[ ]*/&gt;|&lt;[ ]*input(([ ]*name=[A-Za-z0-9_+"]*[ ]*type="hidden"[ ]*value=[A-Za-z0-9_+"]*[ ]*)+)[ ]*/&gt;|&lt;[ ]*input(([ ]*value=[A-Za-z0-9_+"]*[ ]*type="hidden"[ ]*name=[A-Za-z0-9_+"]*[ ]*)+)[ ]*/&gt;|&lt;[ ]*input(([ ]*name=[A-Za-z0-9_+"]*[ ]*value=[A-Za-z0-9_+"]*[ ]*type="hidden"[ ]*)+)[ ]*/&gt;|&lt;[ ]*input(([ ]*value=[A-Za-z0-9_+"]*[ ]*name=[A-Za-z0-9_+"]*[ ]*type="hidden"[ ]*)+)[ ]*/&gt;
</code></pre>

<p>its not good but it works in any way.</p>

<p>test it in : <a href="http://regexpal.com/" rel="nofollow">http://regexpal.com/</a></p>
    </div></div></div></div><div id="solution7" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 7</h4><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>I would like to use <code>**DOMDocument**</code> to extract the html code.</p>

<pre class="lang-html s-code-block"><code class="hljs language-xml">$dom = new DOMDocument();
$dom -&gt;loadHTML($input);
$x = new DOMXpath($dom );
$results = $x-&gt;evaluate('//input[@type="hidden"]');

foreach ( $results as $item) {
    print_r( $item-&gt;getAttribute('value') );
}
</code></pre>

<p>BTW, you can test it in here - regex101.com. It shows the result at real time.
Some rules about Regexp: <a href="http://www.eclipse.org/tptp/home/downloads/installguide/gla_42/ref/rregexp.html" rel="nofollow">http://www.eclipse.org/tptp/home/downloads/installguide/gla_42/ref/rregexp.html</a>
<a href="http://note.taable.com" rel="nofollow">Reader</a>.</p>
    </div></div></div></div><div id="solution8" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 8</h4><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>suppose your html content is stored in string html then in order to get every input that contain type hidden you can use regular expression</p>

<pre class="lang-html s-code-block"><code class="hljs language-xml">var regex = /(&lt;input.*?type\s?=\s?["']hidden["'].*?&gt;)/g;
html.match(regex);
</code></pre>

<p>the above regex find <code>&lt;input</code> followed by any number of characters until it gets <code>type="hidden"</code> or type='hidden' followed by any number of characters till it gets <code>&gt;</code></p>

<p>/g tell regular expression to find every substring that matches to the given pattern.</p>
    </div></div></div></div></div></div><div class="widget"><a href="/questions/javascript-closure-inside-loops-simple-practical-example-1657384278449">JavaScript closure inside loops – simple practical example</a><a href="/questions/sort-arraylist-of-custom-objects-by-property-1657387678339">Sort ArrayList of custom Objects by property</a><a href="/questions/what-is-the-difference-between-client-side-and-server-side-programming-1657384372926">What is the difference between client-side and server-side programming?</a><a href="/questions/c++-singleton-design-pattern-1657387830040">C++ Singleton design pattern</a><a href="/questions/how-to-make-good-reproducible-pandas-examples-1657384310402">How to make good reproducible pandas examples</a><a href="/questions/how-to-print-a-number-with-commas-as-thousands-separators-in-javascript-1657387777379">How to print a number with commas as thousands separators in JavaScript</a><a href="/questions/official-locator-strategies-for-the-webdriver-1657384353174">Official locator strategies for the webdriver</a><a href="/questions/convert-rows-to-columns-using-&#x27;pivot&#x27;-in-sql-server-1657388372528">Convert Rows to columns using &#x27;Pivot&#x27; in SQL Server</a><a href="/questions/what-does-%22fatal-error:-unexpectedly-found-nil-while-unwrapping-an-optional-value%22-mean-1657384593944">What does &quot;Fatal error: Unexpectedly found nil while unwrapping an Optional value&quot; mean?</a><a href="/questions/what-is-the-difference-between-const-int*-const-int-*-const-and-int-const-*-1657388184604">What is the difference between const int*, const int * const, and int const *?</a><a href="/questions/addeventlistener-vs-onclick-1657388191429">addEventListener vs onclick</a><a href="/questions/how-to-reshape-data-from-long-to-wide-format-1657384486421">How to reshape data from long to wide format</a><a href="/questions/correctly-allocating-multi-dimensional-arrays-1657387733756">Correctly allocating multi-dimensional arrays</a><a href="/questions/is-it-safe-to-expose-firebase-apikey-to-the-public-1657388268111">Is it safe to expose Firebase apiKey to the public?</a><a href="/questions/how-to-make-a-div-100percent-height-of-the-browser-window-1657388265955">How to make a div 100% height of the browser window</a><a href="/questions/how-to-use-regular-expressions-(regex)-in-microsoft-excel-both-in-cell-and-loops-1657387487287">How to use Regular Expressions (Regex) in Microsoft Excel both in-cell and loops</a><a href="/questions/why-should-i-not-include-lessbitsstdc++.hgreater-1657384470484">Why should I not #include &lt;bits/stdc++.h&gt;?</a><a href="/questions/where-do-i-find-the-current-c-or-c++-standard-documents-1657388006897">Where do I find the current C or C++ standard documents?</a><a href="/questions/convert-columns-into-rows-with-pandas-1657388374964">Convert columns into rows with Pandas</a><a href="/questions/how-can-i-validate-an-email-address-in-javascript-1657385475959">How can I validate an email address in JavaScript?</a></div></div><span class="cursor-pointer text-lg p-2" style="position:fixed;bottom:20px;left:20px;background:#000;z-index:2000;color:white">Go go top</span></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"data":{"answer":["\n\u0026lt;h2\u0026gt;\u0026lt;em\u0026gt;Oh Yes You Can\u0026lt;/em\u0026gt; Use Regexes to Parse HTML!\u0026lt;/h2\u0026gt;\n\u0026lt;p\u0026gt;For the task you are attempting, regexes are \u0026lt;strong\u0026gt;\u0026lt;em\u0026gt;perfectly fine!\u0026lt;/em\u0026gt;\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;It \u0026lt;em\u0026gt;is\u0026lt;/em\u0026gt; true that most people underestimate the difficulty of parsing HTML with regular expressions and therefore do so poorly.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;But this is not some fundamental flaw related to computational theory. \u0026lt;a href=\u0026quot;https://stackoverflow.com/a/1732454/459233\u0026quot;\u0026gt;That silliness is parroted a lot around here\u0026lt;/a\u0026gt;, but dont you believe them.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;So while it certainly can be done (this posting serves as an existence proof of this incontrovertible fact), that doesnt mean it\u0026amp;nbsp;\u0026lt;strong\u0026gt;\u0026lt;em\u0026gt;should\u0026lt;/em\u0026gt;\u0026lt;/strong\u0026gt;\u0026amp;nbsp;be.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;You must decide for yourself whether youre up to the task of writing what amounts to a dedicated, special-purpose HTML parser out of regexes. Most people are not.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;But \u0026lt;em\u0026gt;I\u0026lt;/em\u0026gt; am. \u0026lt;/p\u0026gt;\n\u0026lt;hr\u0026gt;\n\u0026lt;h2\u0026gt;General Regex-Based HTML Parsing Solutions\u0026lt;/h2\u0026gt;\n\u0026lt;p\u0026gt;First Ill show how easy it is to parse \u0026lt;strong\u0026gt;arbitrary\u0026lt;/strong\u0026gt; HTML with regexes. The full programs at the end of this posting, but the heart of the parser is:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-perl s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-perl\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt; (;;) {\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;given\u0026lt;/span\u0026gt; ($html) {\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;last\u0026lt;/span\u0026gt;                    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;when\u0026lt;/span\u0026gt; (\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;pos\u0026lt;/span\u0026gt; || \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;) \u0026amp;gt;= \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;length\u0026lt;/span\u0026gt;;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;printf\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;\\@%d=\u0026quot;\u0026lt;/span\u0026gt;,              (\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;pos\u0026lt;/span\u0026gt; || \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;);\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt;  \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;doctype \u0026quot;\u0026lt;/span\u0026gt;   \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;when\u0026lt;/span\u0026gt; / \\G (?\u0026amp;amp;doctype)  $RX_SUBS  /xgc;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt;  \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;cdata \u0026quot;\u0026lt;/span\u0026gt;     \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;when\u0026lt;/span\u0026gt; / \\G (?\u0026amp;amp;cdata)    $RX_SUBS  /xgc;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt;  \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;xml \u0026quot;\u0026lt;/span\u0026gt;       \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;when\u0026lt;/span\u0026gt; / \\G (?\u0026amp;amp;xml)      $RX_SUBS  /xgc;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt;  \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;xhook \u0026quot;\u0026lt;/span\u0026gt;     \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;when\u0026lt;/span\u0026gt; / \\G (?\u0026amp;amp;xhook)    $RX_SUBS  /xgc;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt;  \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;script \u0026quot;\u0026lt;/span\u0026gt;    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;when\u0026lt;/span\u0026gt; / \\G (?\u0026amp;amp;script)   $RX_SUBS  /xgc;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt;  \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;style \u0026quot;\u0026lt;/span\u0026gt;     \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;when\u0026lt;/span\u0026gt; / \\G (?\u0026amp;amp;style)    $RX_SUBS  /xgc;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt;  \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;comment \u0026quot;\u0026lt;/span\u0026gt;   \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;when\u0026lt;/span\u0026gt; / \\G (?\u0026amp;amp;comment)  $RX_SUBS  /xgc;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt;  \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;tag \u0026quot;\u0026lt;/span\u0026gt;       \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;when\u0026lt;/span\u0026gt; / \\G (?\u0026amp;amp;tag)      $RX_SUBS  /xgc;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt;  \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;untag \u0026quot;\u0026lt;/span\u0026gt;     \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;when\u0026lt;/span\u0026gt; / \\G (?\u0026amp;amp;untag)    $RX_SUBS  /xgc;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt;  \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;nasty \u0026quot;\u0026lt;/span\u0026gt;     \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;when\u0026lt;/span\u0026gt; / \\G (?\u0026amp;amp;nasty)    $RX_SUBS  /xgc;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt;  \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;text \u0026quot;\u0026lt;/span\u0026gt;      \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;when\u0026lt;/span\u0026gt; / \\G (?\u0026amp;amp;nontag)   $RX_SUBS  /xgc;\n    default {\n      \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;die\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;UNCLASSIFIED: \u0026quot;\u0026lt;/span\u0026gt; .\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;substr\u0026lt;/span\u0026gt;($_, \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;pos\u0026lt;/span\u0026gt; || \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;, (\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;length\u0026lt;/span\u0026gt; \u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;65\u0026lt;/span\u0026gt;) ? \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;65\u0026lt;/span\u0026gt; : \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;length\u0026lt;/span\u0026gt;);\n    }\n  }\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;See how \u0026lt;em\u0026gt;easy\u0026lt;/em\u0026gt; that is to read?\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;As written, it identifies each piece of HTML and tells  where it found that piece. You could easily modify it to do whatever else you want with any given type of piece, or for more particular types than these.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;I have no failing test cases (left :): Ive successfully run this code on more than 100,000 HTML files  every single one I could quickly and easily get my hands on. Beyond those, Ive also run it on files \u0026lt;em\u0026gt;specifically constructed\u0026lt;/em\u0026gt; to break naïve parsers.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;This is \u0026lt;em\u0026gt;not\u0026lt;/em\u0026gt; a naïve parser.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Oh, Im sure it isnt perfect, but I havent managed to break it yet.  I figure that even if something did, the fix would be easy to fit in because of the programs clear structure. Even regex-heavy programs should have stucture.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Now that thats out of the way, let me address the OPs question.\u0026lt;/p\u0026gt;\n\u0026lt;h2\u0026gt;Demo of Solving the OPs Task Using Regexes\u0026lt;/h2\u0026gt;\n\u0026lt;p\u0026gt;The little \u0026lt;code\u0026gt;html_input_rx\u0026lt;/code\u0026gt; program I include below produces the following output, so that you can see that parsing HTML with regexes works just fine for what you wish to do:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-html s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-xml\u0026quot;\u0026gt;% html_input_rx Amazon.com-_Online_Shopping_for_Electronics,_Apparel,_Computers,_Books,_DVDs_\\\u0026amp;amp;_more.htm \ninput tag #1 at character 9955:\n       class =\u0026amp;gt; \u0026quot;searchSelect\u0026quot;\n          id =\u0026amp;gt; \u0026quot;twotabsearchtextbox\u0026quot;\n        name =\u0026amp;gt; \u0026quot;field-keywords\u0026quot;\n        size =\u0026amp;gt; \u0026quot;50\u0026quot;\n       style =\u0026amp;gt; \u0026quot;width:100%; background-color: #FFF;\u0026quot;\n       title =\u0026amp;gt; \u0026quot;Search for\u0026quot;\n        type =\u0026amp;gt; \u0026quot;text\u0026quot;\n       value =\u0026amp;gt; \u0026quot;\u0026quot;\n\ninput tag #2 at character 10335:\n         alt =\u0026amp;gt; \u0026quot;Go\u0026quot;\n         src =\u0026amp;gt; \u0026quot;http://g-ecx.images-amazon.com/images/G/01/x-locale/common/transparent-pixel._V192234675_.gif\u0026quot;\n        type =\u0026amp;gt; \u0026quot;image\u0026quot;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;h2\u0026gt;\u0026lt;em\u0026gt;Parse Input Tags, See No Evil Input\u0026lt;/em\u0026gt;\u0026lt;/h2\u0026gt;\n\u0026lt;p\u0026gt;Heres the source for the program that produced the output above.\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-perl s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-perl\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;#!/usr/bin/env perl\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;#\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;# html_input_rx - pull out all \u0026amp;lt;input\u0026amp;gt; tags from (X)HTML src\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;#                  via simple regex processing\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;#\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;# Tom Christiansen \u0026amp;lt;tchrist@perl.com\u0026amp;gt;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;# Sat Nov 20 10:17:31 MST 2010\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;#\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;################################################################\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;use\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;5.012\u0026lt;/span\u0026gt;;\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;use\u0026lt;/span\u0026gt; strict;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;use\u0026lt;/span\u0026gt; autodie;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;use\u0026lt;/span\u0026gt; warnings \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;FATAL =\u0026amp;gt;\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;all\u0026quot;\u0026lt;/span\u0026gt;;    \n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;use\u0026lt;/span\u0026gt; subs \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;qw{\n    see_no_evil\n    parse_input_tags\n    input descape dequote\n    load_patterns\n}\u0026lt;/span\u0026gt;;    \n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;use\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;open\u0026lt;/span\u0026gt;        \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;:std\u0026quot;\u0026lt;/span\u0026gt;,\n          \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;IN =\u0026amp;gt;\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;:bytes\u0026quot;\u0026lt;/span\u0026gt;,\n         \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;OUT =\u0026amp;gt;\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;:utf8\u0026quot;\u0026lt;/span\u0026gt;;    \n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;use\u0026lt;/span\u0026gt; Encode \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;qw\u0026amp;lt; encode decode \u0026amp;gt;\u0026lt;/span\u0026gt;;\n\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;###########################################################\u0026lt;/span\u0026gt;\n\n                        parse_input_tags \n                           see_no_evil \n                              input  \n\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;###########################################################\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;until\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;eof\u0026lt;/span\u0026gt;(); \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;sub\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;parse_input_tags\u0026lt;/span\u0026gt; \u0026lt;/span\u0026gt;{\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;my\u0026lt;/span\u0026gt; $_ = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;shift\u0026lt;/span\u0026gt;();\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;our\u0026lt;/span\u0026gt;($Input_Tag_Rx, $Pull_Attr_Rx);\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;my\u0026lt;/span\u0026gt; $count = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;while\u0026lt;/span\u0026gt; (\u0026lt;span class=\u0026quot;hljs-regexp\u0026quot;\u0026gt;/$Input_Tag_Rx/pig\u0026lt;/span\u0026gt;) {\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;my\u0026lt;/span\u0026gt; $input_tag = $+\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;{TAG}\u0026lt;/span\u0026gt;;\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;my\u0026lt;/span\u0026gt; $place     = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;pos\u0026lt;/span\u0026gt;() - \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;length\u0026lt;/span\u0026gt; ${^MATCH};\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;printf\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;input tag #%d at character %d:\\n\u0026quot;\u0026lt;/span\u0026gt;, ++$count, $place;\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;my\u0026lt;/span\u0026gt; %attr = ();\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;while\u0026lt;/span\u0026gt; ($input_tag =~ \u0026lt;span class=\u0026quot;hljs-regexp\u0026quot;\u0026gt;/$Pull_Attr_Rx/g\u0026lt;/span\u0026gt;) {\n            \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;my\u0026lt;/span\u0026gt; ($name, $value) = @+{ \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;qw\u0026amp;lt; NAME VALUE \u0026amp;gt;\u0026lt;/span\u0026gt; };\n            $value = dequote($value);\n            \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;exists\u0026lt;/span\u0026gt; $attr{$name}) {\n                \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;printf\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Discarding dup attr value \u0026apos;%s\u0026apos; on %s attr\\n\u0026quot;\u0026lt;/span\u0026gt;,\n                    $attr{$name} // \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;\u0026amp;lt;undef\u0026amp;gt;\u0026quot;\u0026lt;/span\u0026gt;, $name;\n            } \n            $attr{$name} = $value;\n        } \n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;my\u0026lt;/span\u0026gt; $name (\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;sort\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;keys\u0026lt;/span\u0026gt; %attr) {\n            \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;printf\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;  %10s =\u0026amp;gt; \u0026quot;\u0026lt;/span\u0026gt;, $name;\n            \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;my\u0026lt;/span\u0026gt; $value = descape $attr{$name};\n            \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;my\u0026lt;/span\u0026gt;  @Q; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;given\u0026lt;/span\u0026gt; ($value) {\n                @Q = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;qw[  \u0026quot; \u0026quot;  ]\u0026lt;/span\u0026gt;  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;when\u0026lt;/span\u0026gt; !\u0026lt;span class=\u0026quot;hljs-regexp\u0026quot;\u0026gt;/\u0026apos;/\u0026lt;/span\u0026gt; \u0026amp;amp;\u0026amp;amp; !\u0026lt;span class=\u0026quot;hljs-regexp\u0026quot;\u0026gt;/\u0026quot;/\u0026lt;/span\u0026gt;;\n                @Q = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;qw[  \u0026quot; \u0026quot;  ]\u0026lt;/span\u0026gt;  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;when\u0026lt;/span\u0026gt;  /\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;/ \u0026amp;amp;\u0026amp;amp; !/\u0026quot;/;\n                @Q = qw[  \u0026apos;\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;  ]  when !/\u0026apos;\u0026lt;/span\u0026gt;/ \u0026amp;amp;\u0026amp;amp;  \u0026lt;span class=\u0026quot;hljs-regexp\u0026quot;\u0026gt;/\u0026quot;/\u0026lt;/span\u0026gt;;\n                @Q = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;qw[ q( )  ]\u0026lt;/span\u0026gt;  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;when\u0026lt;/span\u0026gt;  /\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;/ \u0026amp;amp;\u0026amp;amp;  /\u0026quot;/;\n                default { die \u0026quot;NOTREACHED\u0026quot; }\n            } \n            say $Q[0], $value, $Q[1];\n        } \n        print \u0026quot;\\n\u0026quot;;\n    } \n\n}\n\nsub dequote {\n    my $_ = $_[0];\n    s{\n        (?\u0026amp;lt;quote\u0026amp;gt;   [\u0026quot;\u0026apos;\u0026lt;/span\u0026gt;]      )\n        (?\u0026amp;lt;BODY\u0026amp;gt;    \n          (?s: (?! \\k\u0026amp;lt;quote\u0026amp;gt; ) . ) * \n        )\n        \\k\u0026amp;lt;quote\u0026amp;gt; \n    }{$+\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;{BODY}\u0026lt;/span\u0026gt;}six;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; $_;\n} \n\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;sub\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;descape\u0026lt;/span\u0026gt; \u0026lt;/span\u0026gt;{\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;my\u0026lt;/span\u0026gt; $string = $_[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;];\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;my\u0026lt;/span\u0026gt; $_ ($string) {\n        \u0026lt;span class=\u0026quot;hljs-regexp\u0026quot;\u0026gt;s{\n            (?\u0026amp;lt;! % )\n            % ( \\p{Hex_Digit} {2} )\n        }{\n            chr hex $1;\n        }gs\u0026lt;/span\u0026gt;ex;\n        \u0026lt;span class=\u0026quot;hljs-regexp\u0026quot;\u0026gt;s{\n            \u0026amp;amp; \\043 \n            ( [0-9]+ )\n            (?: ; \n              | (?= [^0-9] )\n            )\n        }{\n            chr     $1;\n        }gs\u0026lt;/span\u0026gt;ex;\n        \u0026lt;span class=\u0026quot;hljs-regexp\u0026quot;\u0026gt;s{\n            \u0026amp;amp; \\043 x\n            ( \\p{ASCII_HexDigit} + )\n            (?: ; \n              | (?= \\P{ASCII_HexDigit} )\n            )\n        }{\n            chr hex $1;\n        }gs\u0026lt;/span\u0026gt;ex;\n\n    }\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; $string;\n} \n\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;sub\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;input\u0026lt;/span\u0026gt; \u0026lt;/span\u0026gt;{ \n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;our\u0026lt;/span\u0026gt; ($RX_SUBS, $Meta_Tag_Rx);\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;my\u0026lt;/span\u0026gt; $_ = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;do\u0026lt;/span\u0026gt; { \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;local\u0026lt;/span\u0026gt; $/; \u0026amp;lt;\u0026amp;gt; };  \n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;my\u0026lt;/span\u0026gt; $encoding = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;iso-8859-1\u0026quot;\u0026lt;/span\u0026gt;;  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;# web default; wish we had the HTTP headers :(\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;while\u0026lt;/span\u0026gt; (\u0026lt;span class=\u0026quot;hljs-regexp\u0026quot;\u0026gt;/$Meta_Tag_Rx/gi\u0026lt;/span\u0026gt;) {\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;my\u0026lt;/span\u0026gt; $meta = $+\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;{META}\u0026lt;/span\u0026gt;;\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;next\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;unless\u0026lt;/span\u0026gt; $meta =~ \u0026lt;span class=\u0026quot;hljs-regexp\u0026quot;\u0026gt;m{             $RX_SUBS\n            (?= http-equiv ) \n            (?\u0026amp;amp;name) \n            (?\u0026amp;amp;equals) \n            (?= (?\u0026amp;amp;quote)? content-type )\n            (?\u0026amp;amp;value)    \n        }six\u0026lt;/span\u0026gt;;\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;next\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;unless\u0026lt;/span\u0026gt; $meta =~ \u0026lt;span class=\u0026quot;hljs-regexp\u0026quot;\u0026gt;m{             $RX_SUBS\n            (?= content ) (?\u0026amp;amp;name) \n                          (?\u0026amp;amp;equals) \n            (?\u0026amp;lt;CONTENT\u0026amp;gt;   (?\u0026amp;amp;value)    )\n        }six\u0026lt;/span\u0026gt;;\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;next\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;unless\u0026lt;/span\u0026gt; $+\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;{CONTENT}\u0026lt;/span\u0026gt; =~ \u0026lt;span class=\u0026quot;hljs-regexp\u0026quot;\u0026gt;m{       $RX_SUBS\n            (?= charset ) (?\u0026amp;amp;name) \n                          (?\u0026amp;amp;equals) \n            (?\u0026amp;lt;CHARSET\u0026amp;gt;   (?\u0026amp;amp;value)    )\n        }six\u0026lt;/span\u0026gt;;\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;lc\u0026lt;/span\u0026gt; $encoding \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;ne\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;lc\u0026lt;/span\u0026gt; $+\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;{CHARSET}\u0026lt;/span\u0026gt;) {\n            \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;say\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;[RESETTING ENCODING $encoding =\u0026amp;gt; $+{CHARSET}]\u0026quot;\u0026lt;/span\u0026gt;;\n            $encoding = $+\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;{CHARSET}\u0026lt;/span\u0026gt;;\n        }\n    } \n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; decode($encoding, $_);\n}\n\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;sub\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;see_no_evil\u0026lt;/span\u0026gt; \u0026lt;/span\u0026gt;{\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;my\u0026lt;/span\u0026gt; $_ = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;shift\u0026lt;/span\u0026gt;();\n\n    \u0026lt;span class=\u0026quot;hljs-regexp\u0026quot;\u0026gt;s{ \u0026amp;lt;!    DOCTYPE  .*?         \u0026amp;gt; }{}sx\u0026lt;/span\u0026gt;; \n    \u0026lt;span class=\u0026quot;hljs-regexp\u0026quot;\u0026gt;s{ \u0026amp;lt;! \\[ CDATA \\[ .*?    \\]\\] \u0026amp;gt; }{}gsx\u0026lt;/span\u0026gt;; \n\n    s{ \u0026amp;lt;script\u0026amp;gt; .*?  \u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-regexp\u0026quot;\u0026gt;/script\u0026amp;gt; }{}gsix; \n    s{ \u0026amp;lt;!--     .*?        --\u0026amp;gt; }{}gsx;\n\n    return $_;\n}\n\nsub load_patterns { \n\n    our $RX_SUBS = qr{ (?(DEFINE)\n        (?\u0026amp;lt;nv_pair\u0026amp;gt;         (?\u0026amp;amp;name) (?\u0026amp;amp;equals) (?\u0026amp;amp;value)         ) \n        (?\u0026amp;lt;name\u0026amp;gt;            \\b (?=  \\pL ) [\\w\\-] + (?\u0026amp;lt;= \\pL ) \\b  )\n        (?\u0026amp;lt;equals\u0026amp;gt;          (?\u0026amp;amp;might_white)  = (?\u0026amp;amp;might_white)    )\n        (?\u0026amp;lt;value\u0026amp;gt;           (?\u0026amp;amp;quoted_value) | (?\u0026amp;amp;unquoted_value) )\n        (?\u0026amp;lt;unwhite_chunk\u0026amp;gt;   (?: (?! \u0026amp;gt; ) \\S ) +                    )\n        (?\u0026amp;lt;unquoted_value\u0026amp;gt;  [\\w\\-] *                              )\n        (?\u0026amp;lt;might_white\u0026amp;gt;     \\s *                                  )\n        (?\u0026amp;lt;quoted_value\u0026amp;gt;\n            (?\u0026amp;lt;quote\u0026amp;gt;   [\u0026quot;\u0026apos;]      )\n            (?: (?! \\k\u0026amp;lt;quote\u0026amp;gt; ) . ) *\n            \\k\u0026amp;lt;quote\u0026amp;gt; \n        )\n        (?\u0026amp;lt;start_tag\u0026amp;gt;  \u0026amp;lt; (?\u0026amp;amp;might_white) )\n        (?\u0026amp;lt;end_tag\u0026amp;gt;          \n            (?\u0026amp;amp;might_white)\n            (?: (?\u0026amp;amp;html_end_tag) \n              | (?\u0026amp;amp;xhtml_end_tag) \n             )\n        )\n        (?\u0026amp;lt;html_end_tag\u0026amp;gt;       \u0026amp;gt;  )\n        (?\u0026amp;lt;xhtml_end_tag\u0026amp;gt;    /\u0026lt;/span\u0026gt; \u0026amp;gt;  )\n    ) }six; \n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;our\u0026lt;/span\u0026gt; $Meta_Tag_Rx = \u0026lt;span class=\u0026quot;hljs-regexp\u0026quot;\u0026gt;qr{                          $RX_SUBS \n        (?\u0026amp;lt;META\u0026amp;gt; \n            (?\u0026amp;amp;start_tag) meta \\b\n            (?:\n                (?\u0026amp;amp;might_white) (?\u0026amp;amp;nv_pair) \n            ) +\n            (?\u0026amp;amp;end_tag)\n        )\n    }six\u0026lt;/span\u0026gt;;\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;our\u0026lt;/span\u0026gt; $Pull_Attr_Rx = \u0026lt;span class=\u0026quot;hljs-regexp\u0026quot;\u0026gt;qr{                         $RX_SUBS\n        (?\u0026amp;lt;NAME\u0026amp;gt;  (?\u0026amp;amp;name)      )\n                  (?\u0026amp;amp;equals) \n        (?\u0026amp;lt;VALUE\u0026amp;gt; (?\u0026amp;amp;value)     )\n    }six\u0026lt;/span\u0026gt;;\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;our\u0026lt;/span\u0026gt; $Input_Tag_Rx = \u0026lt;span class=\u0026quot;hljs-regexp\u0026quot;\u0026gt;qr{                         $RX_SUBS \n\n        (?\u0026amp;lt;TAG\u0026amp;gt; (?\u0026amp;amp;input_tag) )\n\n        (?(DEFINE)\n\n            (?\u0026amp;lt;input_tag\u0026amp;gt;\n                (?\u0026amp;amp;start_tag)\n                input\n                (?\u0026amp;amp;might_white) \n                (?\u0026amp;amp;attributes) \n                (?\u0026amp;amp;might_white) \n                (?\u0026amp;amp;end_tag)\n            )\n\n            (?\u0026amp;lt;attributes\u0026amp;gt;\n                (?: \n                    (?\u0026amp;amp;might_white) \n                    (?\u0026amp;amp;one_attribute) \n                ) *\n            )\n\n            (?\u0026amp;lt;one_attribute\u0026amp;gt;\n                \\b\n                (?\u0026amp;amp;legal_attribute)\n                (?\u0026amp;amp;might_white) = (?\u0026amp;amp;might_white) \n                (?:\n                    (?\u0026amp;amp;quoted_value)\n                  | (?\u0026amp;amp;unquoted_value)\n                )\n            )\n\n            (?\u0026amp;lt;legal_attribute\u0026amp;gt; \n                (?: (?\u0026amp;amp;optional_attribute)\n                  | (?\u0026amp;amp;standard_attribute)\n                  | (?\u0026amp;amp;event_attribute)\n            # for LEGAL parse only, comment out next line \n                  | (?\u0026amp;amp;illegal_attribute)\n                )\n            )\n\n            (?\u0026amp;lt;illegal_attribute\u0026amp;gt;  (?\u0026amp;amp;name) )\n\n            (?\u0026amp;lt;required_attribute\u0026amp;gt; (?#no required attributes) )\n\n            (?\u0026amp;lt;optional_attribute\u0026amp;gt;\n                (?\u0026amp;amp;permitted_attribute)\n              | (?\u0026amp;amp;deprecated_attribute)\n            )\n\n            # NB: The white space in string literals \n            #     below DOES NOT COUNT!   It\u0026apos;s just \n            #     there for legibility.\n\n            (?\u0026amp;lt;permitted_attribute\u0026amp;gt;\n                  accept\n                | alt\n                | bottom\n                | check box\n                | checked\n                | disabled\n                | file\n                | hidden\n                | image\n                | max length\n                | middle\n                | name\n                | password\n                | radio\n                | read only\n                | reset\n                | right\n                | size\n                | src\n                | submit\n                | text\n                | top\n                | type\n                | value\n            )\n\n            (?\u0026amp;lt;deprecated_attribute\u0026amp;gt;\n                  align\n            )\n\n            (?\u0026amp;lt;standard_attribute\u0026amp;gt;\n                  access key\n                | class\n                | dir\n                | ltr\n                | id\n                | lang\n                | style\n                | tab index\n                | title\n                | xml:lang\n            )\n\n            (?\u0026amp;lt;event_attribute\u0026amp;gt;\n                  on blur\n                | on change\n                | on click\n                | on dbl   click\n                | on focus\n                | on mouse down\n                | on mouse move\n                | on mouse out\n                | on mouse over\n                | on mouse up\n                | on key   down\n                | on key   press\n                | on key   up\n                | on select\n            )\n        )\n    }six\u0026lt;/span\u0026gt;;\n\n}\n\nUNITCHECK {\n    load_patterns();\n} \n\nEND {\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;close\u0026lt;/span\u0026gt;(STDOUT) \n        || \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;die\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;can\u0026apos;t close stdout: $!\u0026quot;\u0026lt;/span\u0026gt;;\n} \n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;There you go! Nothing to it! :)\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Only  \u0026lt;strong\u0026gt;\u0026lt;em\u0026gt;you\u0026lt;/em\u0026gt;\u0026lt;/strong\u0026gt; can judge whether your skill with regexes is up to any particular parsing task. Everyones level of skill is different, and every new task is different. For jobs where you have a well-defined input set, regexes are obviously the right choice, because it is trivial to put some together when you have a restricted subset of HTML to deal with. Even regex beginners should be handle those jobs with regexes.  Anything else is overkill.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;However\u0026lt;/strong\u0026gt;, once the HTML starts becoming less nailed down, once it starts to ramify in ways you cannot predict but which are perfectly legal, once you have to match more different sorts of things or with more complex dependencies, you will eventually reach a point where you have to work harder to effect a solution that uses regexes than you would have to using a parsing class. Where that break-even point falls  depends again on your own comfort level with regexes.\u0026lt;/p\u0026gt;\n\u0026lt;h2\u0026gt;So What Should I Do?\u0026lt;/h2\u0026gt;\n\u0026lt;p\u0026gt;Im not going to tell you what you \u0026lt;em\u0026gt;must\u0026lt;/em\u0026gt; do or what you \u0026lt;em\u0026gt;cannot\u0026lt;/em\u0026gt; do.  I think thats Wrong. I just want to present you with possibilties, open your eyes a bit. You get to choose what you want to do and how you want to do it. There are no absolutes  and nobody else knows your own situation as well as you yourself do. If something seems like its too much work, well, maybe it is.  Programming should be \u0026lt;strong\u0026gt;\u0026lt;em\u0026gt;fun\u0026lt;/em\u0026gt;\u0026lt;/strong\u0026gt;, you know. If it isnt, you may be doing it wrong.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;One can look at my \u0026lt;code\u0026gt;html_input_rx\u0026lt;/code\u0026gt; program in any number of valid ways.  One such is that you indeed \u0026lt;em\u0026gt;can\u0026lt;/em\u0026gt; parse HTML with regular expressions. But another is that it is much, much, much harder than almost anyone ever thinks it is. This can easily lead to the conclusion that my program is a testament to what you should \u0026lt;em\u0026gt;not\u0026lt;/em\u0026gt; do, because it really is too hard.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;I wont disagree with that.  Certainly if everything I do in my program doesnt make sense to you after some study, then you should not be attempting to use regexes for this kind of task. For specific HTML, regexes are great, but for generic HTML, theyre tantamount to madness. I use parsing classes all the time, especially if its HTML I havent generated myself.\u0026lt;/p\u0026gt;\n\u0026lt;h2\u0026gt;Regexes  optimal for \u0026lt;em\u0026gt;small\u0026lt;/em\u0026gt; HTML parsing problems,  pessimal for large ones\u0026lt;/h2\u0026gt;\n\u0026lt;p\u0026gt;Even if my program is taken as  illustrative of why you should \u0026lt;strong\u0026gt;not\u0026lt;/strong\u0026gt; use regexes for parsing general HTML  which is OK, because I kinda meant for it to be that    it still should be an eye-opener so more people break the terribly common and nasty, nasty habit of writing unreadable, unstructured, and unmaintainable patterns.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Patterns do not have to be ugly, and they do not have to be hard. If you create ugly patterns, it is a reflection on you, not them.\u0026lt;/p\u0026gt;\n\u0026lt;h2\u0026gt;Phenomenally Exquisite Regex Language\u0026lt;/h2\u0026gt;\n\u0026lt;p\u0026gt;Ive been asked to point out that my proferred solution to your problem has been written in Perl. Are you surprised? Did you not notice? Is this revelation a bombshell?\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;It is true that not all other tools and programming languages are quite as convenient, expressive, and powerful when it comes to regexes as Perl is. Theres a big spectrum out there, with some being more suitable than others.  In general, the languages that have expressed regexes as part of the core language instead of as a library are easier to work with. Ive done nothing with regexes that you couldnt do in, say, PCRE, although you would structure the program differently if you were using C.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Eventually other languages will be catch up with where Perl is now in terms of regexes.  I say this because back when Perl started, nobody else had anything like Perls regexes. Say anything you like, but this is where Perl clearly won: everybody copied Perls regexes albeit at varying stages of their development.  Perl pioneered almost (not quite all, but almost) everything that you have come to rely on in modern patterns today, no matter what tool or language you use.  So eventually the others \u0026lt;em\u0026gt;will\u0026lt;/em\u0026gt; catch up.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;But theyll only catch up to where Perl was sometime in the past, just as it is now.  Everything advances.  In regexes if nothing else, where Perl leads, others follow. Where will Perl be once everybody else finally catches up to where Perl is now?  I have no idea, but I know we too will have moved. Probably well be closer to \u0026lt;a href=\u0026quot;http://perlcabal.org/syn/S05.html\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;Perls style of crafting patterns\u0026lt;/a\u0026gt;.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;If you like that kind  of thing but would like to use it in Perl,  you might be interested in \u0026lt;a href=\u0026quot;http://search.cpan.org/search?query=regexp+grammars\u0026amp;amp;mode=module\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;Damian Conways \u0026lt;strong\u0026gt;wonderful\u0026lt;/strong\u0026gt; Regexp::Grammars\u0026lt;/a\u0026gt; module. Its completely awesome, and makes what Ive done here in my program seem just as primitive as mine makes the patterns that people cram together without whitespace or alphabetic identifiers.  Check it out!\u0026lt;/p\u0026gt;\n\u0026lt;hr\u0026gt;\n\u0026lt;h2\u0026gt;Simple HTML Chunker\u0026lt;/h2\u0026gt;\n\u0026lt;p\u0026gt;Here is the complete source to the parser I showed the centerpiece from at the beginning of this posting.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;I am \u0026lt;em\u0026gt;not\u0026lt;/em\u0026gt; suggesting that you should use this over a rigorously tested parsing class. But I am tired of people pretending that nobody can parse HTML with regexes just because \u0026lt;em\u0026gt;they\u0026lt;/em\u0026gt; cant. You clearly can, and this program is proof of that assertion.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Sure,  it isnt easy, but \u0026lt;strong\u0026gt;it \u0026lt;em\u0026gt;is\u0026lt;/em\u0026gt; possible!\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;And trying to do so is a terrible waste of time, because good parsing classes exist which you \u0026lt;em\u0026gt;should\u0026lt;/em\u0026gt; use for this task.  The right answer to people trying to parse \u0026lt;em\u0026gt;arbitrary\u0026lt;/em\u0026gt; HTML is \u0026lt;strong\u0026gt;not\u0026lt;/strong\u0026gt; that it is impossible.  That is a facile and disingenuous answer.  The correct and honest answer is that they shouldnt attempt it because it is too much of a bother to figure out from scratch; they should not  break their back striving to reïnvent a wheel that works perfectly well.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;On the other hand, HTML that falls \u0026lt;em\u0026gt;within a predicable subset\u0026lt;/em\u0026gt; is ultra-easy to parse with regexes. Its no wonder people try to use them, because for small problems, toy problems perhaps, nothing could be easier. Thats why its so important to distinguish the two tasks  specific vs generic  as these do not necessarily demand the same approach.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;I hope in the future here to see a more fair and honest treatment of questions about HTML and regexes.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Heres my HTML lexer.  It doesnt try to do a validating parse; it just identifies the lexical elements. You might think of it more as \u0026lt;strong\u0026gt;an HTML chunker\u0026lt;/strong\u0026gt; than an HTML parser. It isnt very forgiving of broken HTML, although it makes some very small allowances in that direction.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Even if you never parse full HTML yourself (and why should you? its a solved problem!), this program has lots of cool regex bits that I believe a lot of people can learn a lot from.  Enjoy!\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-perl s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-perl\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;#!/usr/bin/env perl\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;#\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;# chunk_HTML - a regex-based HTML chunker\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;#\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;# Tom Christiansen \u0026amp;lt;tchrist@perl.com\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;#   Sun Nov 21 19:16:02 MST 2010\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;########################################\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;use\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;5.012\u0026lt;/span\u0026gt;;\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;use\u0026lt;/span\u0026gt; strict;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;use\u0026lt;/span\u0026gt; autodie;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;use\u0026lt;/span\u0026gt; warnings \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;qw\u0026amp;lt; FATAL all \u0026amp;gt;\u0026lt;/span\u0026gt;;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;use\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;open\u0026lt;/span\u0026gt;     \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;qw\u0026amp;lt; IN :bytes OUT :utf8 :std \u0026amp;gt;\u0026lt;/span\u0026gt;;\n\nMAIN: {\n  $| = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;;\n  lex_html(\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;my\u0026lt;/span\u0026gt; $page = slurpy());\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;exit\u0026lt;/span\u0026gt;();\n}\n\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;########################################################################\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;sub\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;lex_html\u0026lt;/span\u0026gt; \u0026lt;/span\u0026gt;{\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;our\u0026lt;/span\u0026gt; $RX_SUBS;                                        \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;###############\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;my\u0026lt;/span\u0026gt;  $html = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;shift\u0026lt;/span\u0026gt;();                                 \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;# Am I...     #\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt; (;;) {                                           \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;# forgiven? :)#\u0026lt;/span\u0026gt;\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;given\u0026lt;/span\u0026gt; ($html) {                                  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;###############\u0026lt;/span\u0026gt;\n            \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;last\u0026lt;/span\u0026gt;                \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;when\u0026lt;/span\u0026gt; (\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;pos\u0026lt;/span\u0026gt; || \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;) \u0026amp;gt;= \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;length\u0026lt;/span\u0026gt;;\n            \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;printf\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;\\@%d=\u0026quot;\u0026lt;/span\u0026gt;,          (\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;pos\u0026lt;/span\u0026gt; || \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;);\n            \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt;  \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;doctype \u0026quot;\u0026lt;/span\u0026gt;   \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;when\u0026lt;/span\u0026gt; / \\G (?\u0026amp;amp;doctype)  $RX_SUBS  /xgc;\n            \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt;  \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;cdata \u0026quot;\u0026lt;/span\u0026gt;     \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;when\u0026lt;/span\u0026gt; / \\G (?\u0026amp;amp;cdata)    $RX_SUBS  /xgc;\n            \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt;  \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;xml \u0026quot;\u0026lt;/span\u0026gt;       \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;when\u0026lt;/span\u0026gt; / \\G (?\u0026amp;amp;xml)      $RX_SUBS  /xgc;\n            \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt;  \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;xhook \u0026quot;\u0026lt;/span\u0026gt;     \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;when\u0026lt;/span\u0026gt; / \\G (?\u0026amp;amp;xhook)    $RX_SUBS  /xgc;\n            \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt;  \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;script \u0026quot;\u0026lt;/span\u0026gt;    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;when\u0026lt;/span\u0026gt; / \\G (?\u0026amp;amp;script)   $RX_SUBS  /xgc;\n            \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt;  \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;style \u0026quot;\u0026lt;/span\u0026gt;     \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;when\u0026lt;/span\u0026gt; / \\G (?\u0026amp;amp;style)    $RX_SUBS  /xgc;\n            \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt;  \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;comment \u0026quot;\u0026lt;/span\u0026gt;   \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;when\u0026lt;/span\u0026gt; / \\G (?\u0026amp;amp;comment)  $RX_SUBS  /xgc;\n            \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt;  \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;tag \u0026quot;\u0026lt;/span\u0026gt;       \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;when\u0026lt;/span\u0026gt; / \\G (?\u0026amp;amp;tag)      $RX_SUBS  /xgc;\n            \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt;  \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;untag \u0026quot;\u0026lt;/span\u0026gt;     \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;when\u0026lt;/span\u0026gt; / \\G (?\u0026amp;amp;untag)    $RX_SUBS  /xgc;\n            \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt;  \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;nasty \u0026quot;\u0026lt;/span\u0026gt;     \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;when\u0026lt;/span\u0026gt; / \\G (?\u0026amp;amp;nasty)    $RX_SUBS  /xgc;\n            \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt;  \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;text \u0026quot;\u0026lt;/span\u0026gt;      \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;when\u0026lt;/span\u0026gt; / \\G (?\u0026amp;amp;nontag)   $RX_SUBS  /xgc;\n            default {\n                \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;die\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;UNCLASSIFIED: \u0026quot;\u0026lt;/span\u0026gt; .\n                  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;substr\u0026lt;/span\u0026gt;($_, \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;pos\u0026lt;/span\u0026gt; || \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;, (\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;length\u0026lt;/span\u0026gt; \u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;65\u0026lt;/span\u0026gt;) ? \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;65\u0026lt;/span\u0026gt; : \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;length\u0026lt;/span\u0026gt;);\n            }\n        }\n    }\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;say\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;.\u0026quot;\u0026lt;/span\u0026gt;;\n}\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;#####################\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;# Return correctly decoded contents of next complete\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;# file slurped in from the \u0026amp;lt;ARGV\u0026amp;gt; stream.\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;#\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;sub\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;slurpy\u0026lt;/span\u0026gt; \u0026lt;/span\u0026gt;{\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;our\u0026lt;/span\u0026gt; ($RX_SUBS, $Meta_Tag_Rx);\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;my\u0026lt;/span\u0026gt; $_ = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;do\u0026lt;/span\u0026gt; { \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;local\u0026lt;/span\u0026gt; $/; \u0026amp;lt;ARGV\u0026amp;gt; };   \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;# read all input\u0026lt;/span\u0026gt;\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;unless\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;length\u0026lt;/span\u0026gt;;\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;use\u0026lt;/span\u0026gt; Encode   \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;qw\u0026amp;lt; decode \u0026amp;gt;\u0026lt;/span\u0026gt;;\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;my\u0026lt;/span\u0026gt; $bom = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;\u0026quot;\u0026lt;/span\u0026gt;;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;given\u0026lt;/span\u0026gt; ($_) {\n        $bom = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;UTF-32LE\u0026quot;\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;when\u0026lt;/span\u0026gt; / ^ \\xFf \\xFe \\\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;   \\\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;   /\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;x\u0026lt;/span\u0026gt;;  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;# LE\u0026lt;/span\u0026gt;\n        $bom = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;UTF-32BE\u0026quot;\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;when\u0026lt;/span\u0026gt; / ^ \\\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;   \\\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;   \\xFe \\xFf /\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;x\u0026lt;/span\u0026gt;;  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;#   BE\u0026lt;/span\u0026gt;\n        $bom = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;UTF-16LE\u0026quot;\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;when\u0026lt;/span\u0026gt; / ^ \\xFf \\xFe           /\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;x\u0026lt;/span\u0026gt;;  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;# le\u0026lt;/span\u0026gt;\n        $bom = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;UTF-16BE\u0026quot;\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;when\u0026lt;/span\u0026gt; / ^ \\xFe \\xFf           /\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;x\u0026lt;/span\u0026gt;;  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;#   be\u0026lt;/span\u0026gt;\n        $bom = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;UTF-8\u0026quot;\u0026lt;/span\u0026gt;    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;when\u0026lt;/span\u0026gt; / ^ \\xEF \\xBB \\xBF      /\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;x\u0026lt;/span\u0026gt;;  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;# st00pid\u0026lt;/span\u0026gt;\n    }\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; ($bom) {\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;say\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;[BOM $bom]\u0026quot;\u0026lt;/span\u0026gt;;\n        \u0026lt;span class=\u0026quot;hljs-regexp\u0026quot;\u0026gt;s/^...//\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; $bom eq \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;UTF-8\u0026quot;\u0026lt;/span\u0026gt;;                        \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;# st00pid\u0026lt;/span\u0026gt;\n\n        \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;# Must use UTF-(16|32) w/o -[BL]E to strip BOM.\u0026lt;/span\u0026gt;\n        $bom =~ \u0026lt;span class=\u0026quot;hljs-regexp\u0026quot;\u0026gt;s/-[LB]E//\u0026lt;/span\u0026gt;;\n\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; decode($bom, $_);\n\n        \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;# if BOM found, don\u0026apos;t fall through to look\u0026lt;/span\u0026gt;\n        \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;#  for embedded encoding spec\u0026lt;/span\u0026gt;\n    }\n\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;# Latin1 is web default if not otherwise specified.\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;# No way to do this correctly if it was overridden\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;# in the HTTP header, since we assume stream contains\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;# HTML only, not also the HTTP header.\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;my\u0026lt;/span\u0026gt; $encoding = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;iso-8859-1\u0026quot;\u0026lt;/span\u0026gt;;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;while\u0026lt;/span\u0026gt; (\u0026lt;span class=\u0026quot;hljs-regexp\u0026quot;\u0026gt;/ (?\u0026amp;amp;xml) $RX_SUBS /pgx\u0026lt;/span\u0026gt;) {\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;my\u0026lt;/span\u0026gt; $xml = ${^MATCH};\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;next\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;unless\u0026lt;/span\u0026gt; $xml =~ \u0026lt;span class=\u0026quot;hljs-regexp\u0026quot;\u0026gt;m{              $RX_SUBS\n            (?= encoding )  (?\u0026amp;amp;name)\n                            (?\u0026amp;amp;equals)\n                            (?\u0026amp;amp;quote) ?\n            (?\u0026amp;lt;ENCODING\u0026amp;gt;    (?\u0026amp;amp;value)       )\n        }sx\u0026lt;/span\u0026gt;;\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;lc\u0026lt;/span\u0026gt; $encoding \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;ne\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;lc\u0026lt;/span\u0026gt; $+\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;{ENCODING}\u0026lt;/span\u0026gt;) {\n            \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;say\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;[XML ENCODING $encoding =\u0026amp;gt; $+{ENCODING}]\u0026quot;\u0026lt;/span\u0026gt;;\n            $encoding = $+\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;{ENCODING}\u0026lt;/span\u0026gt;;\n        }\n    }\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;while\u0026lt;/span\u0026gt; (\u0026lt;span class=\u0026quot;hljs-regexp\u0026quot;\u0026gt;/$Meta_Tag_Rx/gi\u0026lt;/span\u0026gt;) {\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;my\u0026lt;/span\u0026gt; $meta = $+\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;{META}\u0026lt;/span\u0026gt;;\n\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;next\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;unless\u0026lt;/span\u0026gt; $meta =~ \u0026lt;span class=\u0026quot;hljs-regexp\u0026quot;\u0026gt;m{             $RX_SUBS\n            (?= http-equiv )    (?\u0026amp;amp;name)\n                                (?\u0026amp;amp;equals)\n            (?= (?\u0026amp;amp;quote)? content-type )\n                                (?\u0026amp;amp;value)\n        }six\u0026lt;/span\u0026gt;;\n\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;next\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;unless\u0026lt;/span\u0026gt; $meta =~ \u0026lt;span class=\u0026quot;hljs-regexp\u0026quot;\u0026gt;m{             $RX_SUBS\n            (?= content )       (?\u0026amp;amp;name)\n                                (?\u0026amp;amp;equals)\n            (?\u0026amp;lt;CONTENT\u0026amp;gt;         (?\u0026amp;amp;value)    )\n        }six\u0026lt;/span\u0026gt;;\n\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;next\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;unless\u0026lt;/span\u0026gt; $+\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;{CONTENT}\u0026lt;/span\u0026gt; =~ \u0026lt;span class=\u0026quot;hljs-regexp\u0026quot;\u0026gt;m{       $RX_SUBS\n            (?= charset )       (?\u0026amp;amp;name)\n                                (?\u0026amp;amp;equals)\n            (?\u0026amp;lt;CHARSET\u0026amp;gt;         (?\u0026amp;amp;value)    )\n        }six\u0026lt;/span\u0026gt;;\n\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;lc\u0026lt;/span\u0026gt; $encoding \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;ne\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;lc\u0026lt;/span\u0026gt; $+\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;{CHARSET}\u0026lt;/span\u0026gt;) {\n            \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;say\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;[HTTP-EQUIV ENCODING $encoding =\u0026amp;gt; $+{CHARSET}]\u0026quot;\u0026lt;/span\u0026gt;;\n            $encoding = $+\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;{CHARSET}\u0026lt;/span\u0026gt;;\n        }\n    }\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; decode($encoding, $_);\n}\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;########################################################################\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;# Make sure to this function is called\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;# as soon as source unit has been compiled.\u0026lt;/span\u0026gt;\nUNITCHECK { load_rxsubs() }\n\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;# useful regex subroutines for HTML parsing\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;sub\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;load_rxsubs\u0026lt;/span\u0026gt; \u0026lt;/span\u0026gt;{\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;our\u0026lt;/span\u0026gt; $RX_SUBS = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;qr{\n      (?(DEFINE)\n\n        (?\u0026amp;lt;WS\u0026amp;gt; \\s *  )\n\n        (?\u0026amp;lt;any_nv_pair\u0026amp;gt;     (?\u0026amp;amp;name) (?\u0026amp;amp;equals) (?\u0026amp;amp;value)         )\n        (?\u0026amp;lt;name\u0026amp;gt;            \\b (?=  \\pL ) [\\w:\\-] +  \\b           )\n        (?\u0026amp;lt;equals\u0026amp;gt;          (?\u0026amp;amp;WS)  = (?\u0026amp;amp;WS)    )\n        (?\u0026amp;lt;value\u0026amp;gt;           (?\u0026amp;amp;quoted_value) | (?\u0026amp;amp;unquoted_value) )\n        (?\u0026amp;lt;unwhite_chunk\u0026amp;gt;   (?: (?! \u0026amp;gt; ) \\S ) +                    )\n\n        (?\u0026amp;lt;unquoted_value\u0026amp;gt;  [\\w:\\-] *                             )\n\n        (?\u0026amp;lt;any_quote\u0026amp;gt;  [\u0026quot;\u0026apos;]      )\n\n        (?\u0026amp;lt;quoted_value\u0026amp;gt;\n            (?\u0026amp;lt;quote\u0026amp;gt;   (?\u0026amp;amp;any_quote)  )\n            (?: (?! \\k\u0026amp;lt;quote\u0026amp;gt; ) . ) *\n            \\k\u0026amp;lt;quote\u0026amp;gt;\n        )\n\n        (?\u0026amp;lt;start_tag\u0026amp;gt;       \u0026amp;lt; (?\u0026amp;amp;WS)      )\n        (?\u0026amp;lt;html_end_tag\u0026amp;gt;      \u0026amp;gt;           )\n        (?\u0026amp;lt;xhtml_end_tag\u0026amp;gt;   / \u0026amp;gt;           )\n        (?\u0026amp;lt;end_tag\u0026amp;gt;\n            (?\u0026amp;amp;WS)\n            (?: (?\u0026amp;amp;html_end_tag)\n              | (?\u0026amp;amp;xhtml_end_tag) )\n         )\n\n        (?\u0026amp;lt;tag\u0026amp;gt;\n            (?\u0026amp;amp;start_tag)\n            (?\u0026amp;amp;name)\n            (?:\n                (?\u0026amp;amp;WS)\n                (?\u0026amp;amp;any_nv_pair)\n            ) *\n            (?\u0026amp;amp;end_tag)\n        )\n\n        (?\u0026amp;lt;untag\u0026amp;gt; \u0026amp;lt;/ (?\u0026amp;amp;name) \u0026amp;gt; )\n\n        # starts like a tag, but has screwed up quotes inside it\n        (?\u0026amp;lt;nasty\u0026amp;gt;\n            (?\u0026amp;amp;start_tag)\n            (?\u0026amp;amp;name)\n            .*?\n            (?\u0026amp;amp;end_tag)\n        )\n\n        (?\u0026amp;lt;nontag\u0026amp;gt;    [^\u0026amp;lt;] +            )\n\n        (?\u0026amp;lt;string\u0026amp;gt; (?\u0026amp;amp;quoted_value)     )\n        (?\u0026amp;lt;word\u0026amp;gt;   (?\u0026amp;amp;name)             )\n\n        (?\u0026amp;lt;doctype\u0026amp;gt;\n            \u0026amp;lt;!DOCTYPE\n                # please don\u0026apos;t feed me nonHTML\n                ### (?\u0026amp;amp;WS) HTML\n            [^\u0026amp;gt;]* \u0026amp;gt;\n        )\n\n        (?\u0026amp;lt;cdata\u0026amp;gt;   \u0026amp;lt;!\\[CDATA\\[     .*?     \\]\\]    \u0026amp;gt; )\n        (?\u0026amp;lt;script\u0026amp;gt;  (?= \u0026amp;lt;script ) (?\u0026amp;amp;tag)   .*?     \u0026amp;lt;/script\u0026amp;gt; )\n        (?\u0026amp;lt;style\u0026amp;gt;   (?= \u0026amp;lt;style  ) (?\u0026amp;amp;tag)   .*?     \u0026amp;lt;/style\u0026amp;gt; )\n        (?\u0026amp;lt;comment\u0026amp;gt; \u0026amp;lt;!--            .*?           --\u0026amp;gt; )\n\n        (?\u0026amp;lt;xml\u0026amp;gt;\n            \u0026amp;lt; \\? xml\n            (?:\n                (?\u0026amp;amp;WS)\n                (?\u0026amp;amp;any_nv_pair)\n            ) *\n            (?\u0026amp;amp;WS)\n            \\? \u0026amp;gt;\n        )\n\n        (?\u0026amp;lt;xhook\u0026amp;gt; \u0026amp;lt; \\? .*? \\? \u0026amp;gt; )\n\n      )\n\n    }\u0026lt;/span\u0026gt;six;\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;our\u0026lt;/span\u0026gt; $Meta_Tag_Rx = \u0026lt;span class=\u0026quot;hljs-regexp\u0026quot;\u0026gt;qr{                          $RX_SUBS\n        (?\u0026amp;lt;META\u0026amp;gt;\n            (?\u0026amp;amp;start_tag) meta \\b\n            (?:\n                (?\u0026amp;amp;WS) (?\u0026amp;amp;any_nv_pair)\n            ) +\n            (?\u0026amp;amp;end_tag)\n        )\n    }six\u0026lt;/span\u0026gt;;\n\n}\n\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;# nobody *ever* remembers to do this!\u0026lt;/span\u0026gt;\nEND { \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;close\u0026lt;/span\u0026gt; STDOUT }\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;ol\u0026gt;\n\u0026lt;li\u0026gt;You can write a novel like tchrist did\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;You can use a DOM library, load the HTML and use xpath and just use \u0026lt;code\u0026gt;//input[@type=\u0026quot;hidden\u0026quot;]\u0026lt;/code\u0026gt;. Or if you don\u0026apos;t want to use xpath, just get all inputs and filter which ones are hidden with \u0026lt;code\u0026gt;getAttribute\u0026lt;/code\u0026gt;.\u0026lt;/li\u0026gt;\n\u0026lt;/ol\u0026gt;\n\n\u0026lt;p\u0026gt;I prefer #2.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-html s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-xml\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;\u0026amp;lt;?php\n\n$d = new DOMDocument();\n$d-\u0026amp;gt;loadHTML(\n    \u0026apos;\n    \u0026amp;lt;p\u0026amp;gt;fsdjl\u0026amp;lt;/p\u0026amp;gt;\n    \u0026amp;lt;form\u0026amp;gt;\u0026amp;lt;div\u0026amp;gt;fdsjl\u0026amp;lt;/div\u0026amp;gt;\u0026amp;lt;/form\u0026amp;gt;\n    \u0026amp;lt;input type=\u0026quot;hidden\u0026quot; name=\u0026quot;blah\u0026quot; value=\u0026quot;hide yo kids\u0026quot;\u0026amp;gt;\n    \u0026amp;lt;input type=\u0026quot;text\u0026quot; name=\u0026quot;blah\u0026quot; value=\u0026quot;hide yo kids\u0026quot;\u0026amp;gt;\n    \u0026amp;lt;input type=\u0026quot;hidden\u0026quot; name=\u0026quot;blah\u0026quot; value=\u0026quot;hide yo wife\u0026quot;\u0026amp;gt;\n\u0026apos;);\n$x = new DOMXpath($d);\n$inputs = $x-\u0026amp;gt;evaluate(\u0026apos;//input[@type=\u0026quot;hidden\u0026quot;]\u0026apos;);\n\nforeach ( $inputs as $input ) {\n    echo $input-\u0026amp;gt;getAttribute(\u0026apos;value\u0026apos;), \u0026apos;\u0026amp;lt;br\u0026amp;gt;\u0026apos;;\n}\n\u0026lt;/span\u0026gt;\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Result:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-html s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-xml\u0026quot;\u0026gt;hide yo kids\u0026lt;span class=\u0026quot;hljs-tag\u0026quot;\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;br\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026lt;/span\u0026gt;hide yo wife\u0026lt;span class=\u0026quot;hljs-tag\u0026quot;\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;br\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Contrary to all the answers here, for what you\u0026apos;re trying to do regex is a perfectly valid solution. This is because you are NOT trying to match balanced tags-- THAT would be impossible with regex! But you are only matching what\u0026apos;s in one tag, and that\u0026apos;s perfectly regular.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Here\u0026apos;s the problem, though. You can\u0026apos;t do it with just one regex... you need to do one match to capture an \u0026lt;code\u0026gt;\u0026amp;lt;input\u0026amp;gt;\u0026lt;/code\u0026gt; tag, then do further processing on that. Note that this will only work if none of the attribute values have a \u0026lt;code\u0026gt;\u0026amp;gt;\u0026lt;/code\u0026gt; character in them, so it\u0026apos;s not perfect, but it should suffice for sane inputs.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Here\u0026apos;s some Perl (pseudo)code to show you what I mean:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-html s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-xml\u0026quot;\u0026gt;my $html = readLargeInputFile();\n\nmy @input_tags = $html =~ m/\n    (\n        \u0026lt;span class=\u0026quot;hljs-tag\u0026quot;\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;input\u0026lt;/span\u0026gt;                      # \u0026lt;span class=\u0026quot;hljs-attr\u0026quot;\u0026gt;Starts\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-attr\u0026quot;\u0026gt;with\u0026lt;/span\u0026gt; \u0026quot;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-attr\u0026quot;\u0026gt;input\u0026lt;/span\u0026gt;\u0026quot;\n        (?=\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;[^\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026lt;/span\u0026gt;]*?type=\u0026quot;hidden\u0026quot;)     # Use lookahead to make sure that type=\u0026quot;hidden\u0026quot;\n        [^\u0026amp;gt;]+                       # Grab the rest of the tag...\n        \\/\u0026amp;gt;                         # ...except for the /\u0026amp;gt;, which is grabbed here\n    )/xgm;\n\n# Now each member of @input_tags is something like \u0026lt;span class=\u0026quot;hljs-tag\u0026quot;\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;input\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-attr\u0026quot;\u0026gt;type\u0026lt;/span\u0026gt;=\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;hidden\u0026quot;\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-attr\u0026quot;\u0026gt;name\u0026lt;/span\u0026gt;=\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;SaveRequired\u0026quot;\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-attr\u0026quot;\u0026gt;value\u0026lt;/span\u0026gt;=\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;False\u0026quot;\u0026lt;/span\u0026gt; /\u0026amp;gt;\u0026lt;/span\u0026gt;\n\nforeach my $input_tag (@input_tags)\n{\n  my $hash_ref = {};\n  # Now extract each of the fields one at a time.\n\n  ($hash_ref-\u0026amp;gt;{\u0026quot;name\u0026quot;}) = $input_tag =~ /name=\u0026quot;([^\u0026quot;]*)\u0026quot;/;\n  ($hash_ref-\u0026amp;gt;{\u0026quot;value\u0026quot;}) = $input_tag =~ /value=\u0026quot;([^\u0026quot;]*)\u0026quot;/;\n\n  # Put $hash_ref in a list or something, or otherwise process it\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;The basic principle here is, don\u0026apos;t try to do too much with one regular expression. As you noticed, regular expressions enforce a certain amount of order. So what you need to do instead is to first match the CONTEXT of what you\u0026apos;re trying to extract, then do submatching on the data you want.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;b\u0026gt;EDIT:\u0026lt;/b\u0026gt; However, I will agree that in general, using an HTML parser is probably easier and better and you really should consider redesigning your code or re-examining your objectives. :-) But I had to post this answer as a counter to the knee-jerk reaction that parsing any subset of HTML is impossible: HTML and XML are both irregular when you consider the entire specification, but the specification of a tag is decently regular, certainly within the power of PCRE.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;In the spirit of Tom Christiansen\u0026apos;s lexer solution, here\u0026apos;s a link to Robert Cameron\u0026apos;s seemingly forgotten 1998 article, \u0026lt;em\u0026gt;REX: XML Shallow Parsing with Regular Expressions.\u0026lt;/em\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;a href=\u0026quot;http://www.cs.sfu.ca/~cameron/REX.html\u0026quot;\u0026gt;http://www.cs.sfu.ca/~cameron/REX.html\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;Abstract\u0026lt;/p\u0026gt;\n  \n  \u0026lt;p\u0026gt;The syntax of XML is simple enough that it is possible to parse an XML document into a list of its markup and text items using a single regular expression. Such a shallow parse of an XML document can be very useful for the construction of a variety of lightweight XML processing tools. However, complex regular expressions can be difficult to construct and even more difficult to read. Using a form of literate programming for regular expressions, this paper documents a set of XML shallow parsing expressions that can be used a basis for simple, correct, efficient, robust and language-independent XML shallow parsing. Complete shallow parser implementations of less than 50 lines each in Perl, JavaScript and Lex/Flex are also given.\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;p\u0026gt;If you enjoy reading about regular expressions, Cameron\u0026apos;s paper is fascinating. His writing is concise, thorough, and very detailed. He\u0026apos;s not simply showing you how to construct the REX regular expression but also an approach for building up any complex regex from smaller parts.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;I\u0026apos;ve been using the REX regular expression on and off for 10 years to solve the sort of problem the initial poster asked about (how do I match this particular tag but not some other very similar tag?). I\u0026apos;ve found the regex he developed to be completely reliable.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;REX is particularly useful when you\u0026apos;re focusing on lexical details of a document -- for example, when transforming one kind of text document (e.g., plain text, XML, SGML, HTML) into another, where the document may not be valid, well formed, or even parsable for most of the transformation. It lets you target islands of markup anywhere within a document without disturbing the rest of the document.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;While I love the contents of the rest of these answers, they didn\u0026apos;t really answer the question directly or as correctly.  Even Platinum\u0026apos;s answer was overly complicated, and also less efficient.  So I was forced to put this.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;I\u0026apos;m a huge proponent of Regex, when used correctly.  But because of stigma (and performance), I always state that well-formed XML or HTML should use an XML Parser.  And even better performance would be string-parsing, though there\u0026apos;s a line between readability if that gets too out-of-hand.  However, that isn\u0026apos;t the question.  The question is how to match a hidden-type input tag.  The answer is:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-html s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-xml\u0026quot;\u0026gt;\u0026amp;lt;input[^\u0026amp;gt;]*type=\u0026quot;hidden\u0026quot;[^\u0026amp;gt;]*\u0026amp;gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Depending on your flavor, the only regex option you\u0026apos;d need to include is the ignorecase option.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;you can try this :\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-html s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-xml\u0026quot;\u0026gt;\u0026amp;lt;[A-Za-z =\u0026quot;/_0-9+]*\u0026amp;gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;and for closer result you can try this :\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-html s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-xml\u0026quot;\u0026gt;\u0026amp;lt;[ ]*input[ ]+type=\u0026quot;hidden\u0026quot;[ ]*name=[A-Za-z =\u0026quot;_0-9+]*[ ]*[/]*\u0026amp;gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;you can test your regex pattern here \u0026lt;a href=\u0026quot;http://regexpal.com/\u0026quot; rel=\u0026quot;nofollow\u0026quot;\u0026gt;http://regexpal.com/\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;these pattens are good for this:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-html s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-xml\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-tag\u0026quot;\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;input\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-attr\u0026quot;\u0026gt;type\u0026lt;/span\u0026gt;=\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;hidden\u0026quot;\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-attr\u0026quot;\u0026gt;name\u0026lt;/span\u0026gt;=\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;SaveRequired\u0026quot;\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-attr\u0026quot;\u0026gt;value\u0026lt;/span\u0026gt;=\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;False\u0026quot;\u0026lt;/span\u0026gt; /\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-tag\u0026quot;\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;input\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-attr\u0026quot;\u0026gt;type\u0026lt;/span\u0026gt;=\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;hidden\u0026quot;\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-attr\u0026quot;\u0026gt;name\u0026lt;/span\u0026gt;=\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;__VIEWSTATE1\u0026quot;\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-attr\u0026quot;\u0026gt;value\u0026lt;/span\u0026gt;=\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;1H4sIAAtzrkX7QfL5VEGj6nGi+nP\u0026quot;\u0026lt;/span\u0026gt; /\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-tag\u0026quot;\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;input\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-attr\u0026quot;\u0026gt;type\u0026lt;/span\u0026gt;=\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;hidden\u0026quot;\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-attr\u0026quot;\u0026gt;name\u0026lt;/span\u0026gt;=\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;__VIEWSTATE2\u0026quot;\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-attr\u0026quot;\u0026gt;value\u0026lt;/span\u0026gt;=\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;0351118MK\u0026quot;\u0026lt;/span\u0026gt; /\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-tag\u0026quot;\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;input\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-attr\u0026quot;\u0026gt;type\u0026lt;/span\u0026gt;=\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;hidden\u0026quot;\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-attr\u0026quot;\u0026gt;name\u0026lt;/span\u0026gt;=\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;__VIEWSTATE3\u0026quot;\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-attr\u0026quot;\u0026gt;value\u0026lt;/span\u0026gt;=\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;ZVVV91yjY\u0026quot;\u0026lt;/span\u0026gt; /\u0026amp;gt;\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;and for random order of \u0026lt;code\u0026gt;type\u0026lt;/code\u0026gt; , \u0026lt;code\u0026gt;name\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;value\u0026lt;/code\u0026gt; u can use this :\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-html s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-xml\u0026quot;\u0026gt;\u0026amp;lt;[ ]*input[ ]*[A-Za-z =\u0026quot;_0-9+/]*\u0026amp;gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;or\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-html s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-xml\u0026quot;\u0026gt;\u0026amp;lt;[ ]*input[ ]*[A-Za-z =\u0026quot;_0-9+/]*[ ]*[/]\u0026amp;gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;on this :\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-html s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-xml\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-tag\u0026quot;\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;input\u0026lt;/span\u0026gt;  \u0026lt;span class=\u0026quot;hljs-attr\u0026quot;\u0026gt;name\u0026lt;/span\u0026gt;=\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;SaveRequired\u0026quot;\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-attr\u0026quot;\u0026gt;type\u0026lt;/span\u0026gt;=\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;hidden\u0026quot;\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-attr\u0026quot;\u0026gt;value\u0026lt;/span\u0026gt;=\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;False\u0026quot;\u0026lt;/span\u0026gt; /\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-tag\u0026quot;\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;input\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-attr\u0026quot;\u0026gt;type\u0026lt;/span\u0026gt;=\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;hidden\u0026quot;\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-attr\u0026quot;\u0026gt;name\u0026lt;/span\u0026gt;=\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;__VIEWSTATE1\u0026quot;\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-attr\u0026quot;\u0026gt;value\u0026lt;/span\u0026gt;=\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;1H4sIAAtzrkX7QfL5VEGj6nGi+nP\u0026quot;\u0026lt;/span\u0026gt; /\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-tag\u0026quot;\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;input\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-attr\u0026quot;\u0026gt;type\u0026lt;/span\u0026gt;=\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;hidden\u0026quot;\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-attr\u0026quot;\u0026gt;name\u0026lt;/span\u0026gt;=\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;__VIEWSTATE2\u0026quot;\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-attr\u0026quot;\u0026gt;value\u0026lt;/span\u0026gt;=\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;0351118MK\u0026quot;\u0026lt;/span\u0026gt; /\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-tag\u0026quot;\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;input\u0026lt;/span\u0026gt;  \u0026lt;span class=\u0026quot;hljs-attr\u0026quot;\u0026gt;name\u0026lt;/span\u0026gt;=\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;__VIEWSTATE3\u0026quot;\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-attr\u0026quot;\u0026gt;type\u0026lt;/span\u0026gt;=\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;hidden\u0026quot;\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-attr\u0026quot;\u0026gt;value\u0026lt;/span\u0026gt;=\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;ZVVV91yjY\u0026quot;\u0026lt;/span\u0026gt; /\u0026amp;gt;\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;\n`\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;by the way i think you want something like this :\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-html s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-xml\u0026quot;\u0026gt;\u0026amp;lt;[ ]*input(([ ]*type=\u0026quot;hidden\u0026quot;[ ]*name=[A-Za-z0-9_+\u0026quot;]*[ ]*value=[A-Za-z0-9_+\u0026quot;]*[ ]*)+)[ ]*/\u0026amp;gt;|\u0026amp;lt;[ ]*input(([ ]*type=\u0026quot;hidden\u0026quot;[ ]*value=[A-Za-z0-9_+\u0026quot;]*[ ]*name=[A-Za-z0-9_+\u0026quot;]*[ ]*)+)[ ]*/\u0026amp;gt;|\u0026amp;lt;[ ]*input(([ ]*name=[A-Za-z0-9_+\u0026quot;]*[ ]*type=\u0026quot;hidden\u0026quot;[ ]*value=[A-Za-z0-9_+\u0026quot;]*[ ]*)+)[ ]*/\u0026amp;gt;|\u0026amp;lt;[ ]*input(([ ]*value=[A-Za-z0-9_+\u0026quot;]*[ ]*type=\u0026quot;hidden\u0026quot;[ ]*name=[A-Za-z0-9_+\u0026quot;]*[ ]*)+)[ ]*/\u0026amp;gt;|\u0026amp;lt;[ ]*input(([ ]*name=[A-Za-z0-9_+\u0026quot;]*[ ]*value=[A-Za-z0-9_+\u0026quot;]*[ ]*type=\u0026quot;hidden\u0026quot;[ ]*)+)[ ]*/\u0026amp;gt;|\u0026amp;lt;[ ]*input(([ ]*value=[A-Za-z0-9_+\u0026quot;]*[ ]*name=[A-Za-z0-9_+\u0026quot;]*[ ]*type=\u0026quot;hidden\u0026quot;[ ]*)+)[ ]*/\u0026amp;gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;its not good but it works in any way.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;test it in : \u0026lt;a href=\u0026quot;http://regexpal.com/\u0026quot; rel=\u0026quot;nofollow\u0026quot;\u0026gt;http://regexpal.com/\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;I would like to use \u0026lt;code\u0026gt;**DOMDocument**\u0026lt;/code\u0026gt; to extract the html code.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-html s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-xml\u0026quot;\u0026gt;$dom = new DOMDocument();\n$dom -\u0026amp;gt;loadHTML($input);\n$x = new DOMXpath($dom );\n$results = $x-\u0026amp;gt;evaluate(\u0026apos;//input[@type=\u0026quot;hidden\u0026quot;]\u0026apos;);\n\nforeach ( $results as $item) {\n    print_r( $item-\u0026amp;gt;getAttribute(\u0026apos;value\u0026apos;) );\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;BTW, you can test it in here - regex101.com. It shows the result at real time.\nSome rules about Regexp: \u0026lt;a href=\u0026quot;http://www.eclipse.org/tptp/home/downloads/installguide/gla_42/ref/rregexp.html\u0026quot; rel=\u0026quot;nofollow\u0026quot;\u0026gt;http://www.eclipse.org/tptp/home/downloads/installguide/gla_42/ref/rregexp.html\u0026lt;/a\u0026gt;\n\u0026lt;a href=\u0026quot;http://note.taable.com\u0026quot; rel=\u0026quot;nofollow\u0026quot;\u0026gt;Reader\u0026lt;/a\u0026gt;.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;suppose your html content is stored in string html then in order to get every input that contain type hidden you can use regular expression\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-html s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-xml\u0026quot;\u0026gt;var regex = /(\u0026amp;lt;input.*?type\\s?=\\s?[\u0026quot;\u0026apos;]hidden[\u0026quot;\u0026apos;].*?\u0026amp;gt;)/g;\nhtml.match(regex);\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;the above regex find \u0026lt;code\u0026gt;\u0026amp;lt;input\u0026lt;/code\u0026gt; followed by any number of characters until it gets \u0026lt;code\u0026gt;type=\u0026quot;hidden\u0026quot;\u0026lt;/code\u0026gt; or type=\u0026apos;hidden\u0026apos; followed by any number of characters till it gets \u0026lt;code\u0026gt;\u0026amp;gt;\u0026lt;/code\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;/g tell regular expression to find every substring that matches to the given pattern.\u0026lt;/p\u0026gt;\n    "],"id":471,"title":"What to do Regular expression pattern doesn't match anywhere in string?","content":"\n                \n\u0026lt;p\u0026gt;I am trying to match \u0026lt;code\u0026gt;\u0026amp;lt;input\u0026amp;gt;\u0026lt;/code\u0026gt; type “hidden” fields using this pattern:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-html s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-xml\u0026quot;\u0026gt;/\u0026lt;span class=\u0026quot;hljs-tag\u0026quot;\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;input\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-attr\u0026quot;\u0026gt;type\u0026lt;/span\u0026gt;=\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;hidden\u0026quot;\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-attr\u0026quot;\u0026gt;name\u0026lt;/span\u0026gt;=\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;([^\u0026quot;\u0026lt;/span\u0026gt;]*?)\u0026quot; \u0026lt;span class=\u0026quot;hljs-attr\u0026quot;\u0026gt;value\u0026lt;/span\u0026gt;=\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;([^\u0026quot;\u0026lt;/span\u0026gt;]*?)\u0026quot; /\u0026amp;gt;\u0026lt;/span\u0026gt;/\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;This is sample form data:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-html s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-xml\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-tag\u0026quot;\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;input\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-attr\u0026quot;\u0026gt;type\u0026lt;/span\u0026gt;=\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;hidden\u0026quot;\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-attr\u0026quot;\u0026gt;name\u0026lt;/span\u0026gt;=\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;SaveRequired\u0026quot;\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-attr\u0026quot;\u0026gt;value\u0026lt;/span\u0026gt;=\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;False\u0026quot;\u0026lt;/span\u0026gt; /\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-tag\u0026quot;\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;input\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-attr\u0026quot;\u0026gt;type\u0026lt;/span\u0026gt;=\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;hidden\u0026quot;\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-attr\u0026quot;\u0026gt;name\u0026lt;/span\u0026gt;=\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;__VIEWSTATE1\u0026quot;\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-attr\u0026quot;\u0026gt;value\u0026lt;/span\u0026gt;=\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;1H4sIAAtzrkX7QfL5VEGj6nGi+nP\u0026quot;\u0026lt;/span\u0026gt; /\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-tag\u0026quot;\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;input\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-attr\u0026quot;\u0026gt;type\u0026lt;/span\u0026gt;=\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;hidden\u0026quot;\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-attr\u0026quot;\u0026gt;name\u0026lt;/span\u0026gt;=\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;__VIEWSTATE2\u0026quot;\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-attr\u0026quot;\u0026gt;value\u0026lt;/span\u0026gt;=\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;0351118MK\u0026quot;\u0026lt;/span\u0026gt; /\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-tag\u0026quot;\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;input\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-attr\u0026quot;\u0026gt;type\u0026lt;/span\u0026gt;=\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;hidden\u0026quot;\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-attr\u0026quot;\u0026gt;name\u0026lt;/span\u0026gt;=\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;__VIEWSTATE3\u0026quot;\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-attr\u0026quot;\u0026gt;value\u0026lt;/span\u0026gt;=\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;ZVVV91yjY\u0026quot;\u0026lt;/span\u0026gt; /\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-tag\u0026quot;\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;input\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-attr\u0026quot;\u0026gt;type\u0026lt;/span\u0026gt;=\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;hidden\u0026quot;\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-attr\u0026quot;\u0026gt;name\u0026lt;/span\u0026gt;=\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;__VIEWSTATE0\u0026quot;\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-attr\u0026quot;\u0026gt;value\u0026lt;/span\u0026gt;=\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;3\u0026quot;\u0026lt;/span\u0026gt; /\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-tag\u0026quot;\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;input\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-attr\u0026quot;\u0026gt;type\u0026lt;/span\u0026gt;=\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;hidden\u0026quot;\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-attr\u0026quot;\u0026gt;name\u0026lt;/span\u0026gt;=\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;__VIEWSTATE\u0026quot;\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-attr\u0026quot;\u0026gt;value\u0026lt;/span\u0026gt;=\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;\u0026quot;\u0026lt;/span\u0026gt; /\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-tag\u0026quot;\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-name\u0026quot;\u0026gt;input\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-attr\u0026quot;\u0026gt;type\u0026lt;/span\u0026gt;=\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;hidden\u0026quot;\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-attr\u0026quot;\u0026gt;name\u0026lt;/span\u0026gt;=\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;__VIEWSTATE\u0026quot;\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-attr\u0026quot;\u0026gt;value\u0026lt;/span\u0026gt;=\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;\u0026quot;\u0026lt;/span\u0026gt; /\u0026amp;gt;\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;But I am not sure that the \u0026lt;code\u0026gt;type\u0026lt;/code\u0026gt;, \u0026lt;code\u0026gt;name\u0026lt;/code\u0026gt;, and \u0026lt;code\u0026gt;value\u0026lt;/code\u0026gt; attributes will always appear in the same order. If the \u0026lt;code\u0026gt;type\u0026lt;/code\u0026gt; attribute comes last, the match will fail because in my pattern it’s at the start.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Question:\u0026lt;/strong\u0026gt;\u0026lt;br\u0026gt;\nHow can I change my pattern so it will match regardless of the positions of the attributes in the \u0026lt;code\u0026gt;\u0026amp;lt;input\u0026amp;gt;\u0026lt;/code\u0026gt; tag?\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;P.S.:\u0026lt;/strong\u0026gt; By the way I am using the \u0026lt;em\u0026gt;Adobe Air\u0026lt;/em\u0026gt; based \u0026lt;a href=\u0026quot;http://gskinner.com/RegExr/desktop/\u0026quot; rel=\u0026quot;noreferrer\u0026quot; title=\u0026quot;RegEx Desktop tool\u0026quot;\u0026gt;\u0026lt;em\u0026gt;RegEx Desktop Tool\u0026lt;/em\u0026gt;\u0026lt;/a\u0026gt; for testing regular expressions.\u0026lt;/p\u0026gt;\n    ","slug":"what-to-do-regular-expression-pattern-doesn't-match-anywhere-in-string-1657388095896","postType":"QUESTION","createdAt":"2022-07-09T17:34:55.000Z","updatedAt":"2022-07-09T17:34:55.000Z","tags":[],"relatedQuestions":[]},"randomQuestions":[{"title":"JavaScript closure inside loops – simple practical example","slug":"javascript-closure-inside-loops-simple-practical-example-1657384278449"},{"title":"Sort ArrayList of custom Objects by property","slug":"sort-arraylist-of-custom-objects-by-property-1657387678339"},{"title":"What is the difference between client-side and server-side programming?","slug":"what-is-the-difference-between-client-side-and-server-side-programming-1657384372926"},{"title":"C++ Singleton design pattern","slug":"c++-singleton-design-pattern-1657387830040"},{"title":"How to make good reproducible pandas examples","slug":"how-to-make-good-reproducible-pandas-examples-1657384310402"},{"title":"How to print a number with commas as thousands separators in JavaScript","slug":"how-to-print-a-number-with-commas-as-thousands-separators-in-javascript-1657387777379"},{"title":"Official locator strategies for the webdriver","slug":"official-locator-strategies-for-the-webdriver-1657384353174"},{"title":"Convert Rows to columns using 'Pivot' in SQL Server","slug":"convert-rows-to-columns-using-'pivot'-in-sql-server-1657388372528"},{"title":"What does \"Fatal error: Unexpectedly found nil while unwrapping an Optional value\" mean?","slug":"what-does-\"fatal-error:-unexpectedly-found-nil-while-unwrapping-an-optional-value\"-mean-1657384593944"},{"title":"What is the difference between const int*, const int * const, and int const *?","slug":"what-is-the-difference-between-const-int*-const-int-*-const-and-int-const-*-1657388184604"},{"title":"addEventListener vs onclick","slug":"addeventlistener-vs-onclick-1657388191429"},{"title":"How to reshape data from long to wide format","slug":"how-to-reshape-data-from-long-to-wide-format-1657384486421"},{"title":"Correctly allocating multi-dimensional arrays","slug":"correctly-allocating-multi-dimensional-arrays-1657387733756"},{"title":"Is it safe to expose Firebase apiKey to the public?","slug":"is-it-safe-to-expose-firebase-apikey-to-the-public-1657388268111"},{"title":"How to make a div 100% height of the browser window","slug":"how-to-make-a-div-100percent-height-of-the-browser-window-1657388265955"},{"title":"How to use Regular Expressions (Regex) in Microsoft Excel both in-cell and loops","slug":"how-to-use-regular-expressions-(regex)-in-microsoft-excel-both-in-cell-and-loops-1657387487287"},{"title":"Why should I not #include \u003cbits/stdc++.h\u003e?","slug":"why-should-i-not-include-lessbitsstdc++.hgreater-1657384470484"},{"title":"Where do I find the current C or C++ standard documents?","slug":"where-do-i-find-the-current-c-or-c++-standard-documents-1657388006897"},{"title":"Convert columns into rows with Pandas","slug":"convert-columns-into-rows-with-pandas-1657388374964"},{"title":"How can I validate an email address in JavaScript?","slug":"how-can-i-validate-an-email-address-in-javascript-1657385475959"}]},"__N_SSG":true},"page":"/questions/[slug]","query":{"slug":"what-to-do-regular-expression-pattern-doesn't-match-anywhere-in-string-1657388095896"},"buildId":"TQ2eYlCSdocSK-hq6gkM0","isFallback":false,"gsp":true,"locale":"en","locales":["en"],"defaultLocale":"en","scriptLoader":[]}</script></body></html>