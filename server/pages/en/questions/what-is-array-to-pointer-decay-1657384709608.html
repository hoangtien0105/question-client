<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><meta name="twitter:card" content="summary_large_image"/><meta name="twitter:site" content="@solutionschecker.com"/><meta name="twitter:creator" content="@solutionschecker.com"/><meta property="og:url" content="https://solutionschecker.com"/><meta property="og:type" content="website"/><meta property="og:image" content="https://solutionschecker.com/solutions-checker-banner.png"/><meta property="og:image:alt" content="Find solution for coding, HTML, CSS, JAVASCRIPT, MYSQL, PHP, PYTHON,... quickly. - solutionschecker.com"/><script type="application/ld+json">{"@context":"https://schema.org","@type":"Organization","logo":"/logo.svg","url":"https://solutionschecker.com"}</script><title>What is array to pointer decay? | Solutions Checker</title><meta name="robots" content="index,follow"/><meta name="description" content="What is array to pointer decay? Is there any relation to array pointers?
    "/><meta property="og:title" content="What is array to pointer decay? | Solutions Checker"/><meta property="og:description" content="What is array to pointer decay? Is there any relation to array pointers?
    "/><script type="application/ld+json">{"@context":"https://schema.org","@type":"QAPage","mainEntity":{"name":"What is array to pointer decay?","text":"What is array to pointer decay? Is there any relation to array pointers?\n    ","answerCount":11,"upVoteCount":500,"suggestedAnswer":[{"text":"It&apos;s said that arrays &quot;decay&quot; into pointers.  A C++ array declared as int numbers [5] cannot be re-pointed, i.e. you can&apos;t say numbers = 0x5a5aff23. More importantly the term decay signifies loss of type and dimension; numbers decay into int* by losing the dimension information (count 5) and the type is not int [5] any more. Look here for cases where the decay doesn&apos;t happen.\n\nIf you&apos;re passing an array by value, what you&apos;re really doing is copying a pointer - a pointer to the array&apos;s first element is copied to the parameter (whose type should also be a pointer the array element&apos;s type). This works due to array&apos;s decaying nature; once decayed, sizeof no longer gives the complete array&apos;s size, because it essentially becomes a pointer.  This is why it&apos;s preferred (among other reasons) to pass by reference or pointer.\n\nThree ways to pass in an array1:\n\nvoid by_value(const T* array)   // const T array[] means the same\nvoid by_pointer(const T (*array)[U])\nvoid by_reference(const T (&amp;array)[U])\n\n\nThe last two will give proper sizeof info, while the first one won&apos;t since the array argument has decayed to be assigned to the parameter.\n\n1 The constant U should be known at compile-time.\n    ","url":"/questions/[slug]#solution1","@type":"Answer","upvoteCount":0},{"text":"Arrays are basically the same as pointers in C/C++, but not quite. Once you convert an array:\n\nconst int a[] = { 2, 3, 5, 7, 11 };\n\n\ninto a pointer (which works without casting, and therefore can happen unexpectedly in some cases):\n\nconst int* p = a;\n\n\nyou lose the ability of the sizeof operator to count elements in the array:\n\nassert( sizeof(p) != sizeof(a) );  // sizes are not equal\n\n\nThis lost ability is referred to as &quot;decay&quot;.\n\nFor more details, check out this article about array decay.\n    ","url":"/questions/[slug]#solution2","@type":"Answer","upvoteCount":0},{"text":"Here&apos;s what the standard says (C99 6.3.2.1/3 - Other operands - Lvalues, arrays, and function designators):\n\n\n  Except when it is the operand of the sizeof operator or the unary &amp; operator, or is a\n  string literal used to initialize an array, an expression that has type array of type is\n  converted to an expression with type pointer to type that points to the initial element of\n  the array object and is not an lvalue.\n\n\nThis means that pretty much anytime the array name is used in an expression, it is automatically converted to a pointer to the 1st item in the array.\n\nNote that function names act in a similar way, but function pointers are used far less and in a much more specialized way that it doesn&apos;t cause nearly as much confusion as the automatic conversion of array names to pointers.\n\nThe C++ standard (4.2 Array-to-pointer conversion) loosens the conversion requirement to (emphasis mine):\n\n\n  An lvalue or rvalue of type array of N T or array of unknown bound of T can be converted to an rvalue\n  of type pointer to T.\n\n\nSo the conversion doesn&apos;t have to happen like it pretty much always does in C (this lets functions overload or templates match on the array type).\n\nThis is also why in C you should avoid using array parameters in function prototypes/definitions (in my opinion - I&apos;m not sure if there&apos;s any general agreement).  They cause confusion and are a fiction anyway - use pointer parameters and the confusion might not go away entirely, but at least the parameter declaration isn&apos;t lying.\n    ","url":"/questions/[slug]#solution3","@type":"Answer","upvoteCount":0},{"text":"&quot;Decay&quot; refers to the implicit conversion of an expression from an array type to a pointer type.  In most contexts, when the compiler sees an array expression it converts the type of the expression from &quot;N-element array of T&quot; to &quot;pointer to T&quot; and sets the value of the expression to the address of the first element of the array.  The exceptions to this rule are when an array is an operand of either the sizeof or &amp; operators, or the array is a string literal being used as an initializer in a declaration.\nAssume the following code:\nchar a[80];\nstrcpy(a, &quot;This is a test&quot;);\n\nThe expression a is of type &quot;80-element array of char&quot; and the expression &quot;This is a test&quot; is of type &quot;15-element array of char&quot; (in C; in C++ string literals are arrays of const char).  However, in the call to strcpy(), neither expression is an operand of sizeof or &amp;, so their types are implicitly converted to &quot;pointer to char&quot;, and their values are set to the address of the first element in each.  What strcpy() receives are not arrays, but pointers, as seen in its prototype:\nchar *strcpy(char *dest, const char *src);\n\nThis is not the same thing as an array pointer.  For example:\nchar a[80];\nchar *ptr_to_first_element = a;\nchar (*ptr_to_array)[80] = &amp;a;\n\nBoth ptr_to_first_element and ptr_to_array have the same value; the base address of a.  However, they are different types and are treated differently, as shown below:\na[i] == ptr_to_first_element[i] == (*ptr_to_array)[i] != *ptr_to_array[i] != ptr_to_array[i]\n\nRemember that the expression a[i] is interpreted as *(a+i) (which only works if the array type is converted to a pointer type), so both a[i] and ptr_to_first_element[i] work the same. The expression (*ptr_to_array)[i] is interpreted as *(*a+i).  The expressions *ptr_to_array[i] and ptr_to_array[i] may lead to compiler warnings or errors depending on the context; they&apos;ll definitely do the wrong thing if you&apos;re expecting them to evaluate to a[i].\nsizeof a == sizeof *ptr_to_array == 80\n\nAgain, when an array is an operand of sizeof, it&apos;s not converted to a pointer type.\nsizeof *ptr_to_first_element == sizeof (char) == 1\nsizeof ptr_to_first_element == sizeof (char *) == whatever the pointer size\n                                                  is on your platform\n\nptr_to_first_element is a simple pointer to char.\n    ","url":"/questions/[slug]#solution4","@type":"Answer","upvoteCount":0},{"text":"Arrays, in C, have no value.\n\nWherever the value of an object is expected but the object is an array, the address of its first element is used instead, with type pointer to (type of array elements).\n\nIn a function, all parameters are passed by value (arrays are no exception). When you pass an array in a function it &quot;decays into a pointer&quot; (sic); when you compare an array to something else, again it &quot;decays into a pointer&quot; (sic); ...\n\nvoid foo(int arr[]);\n\n\nFunction foo expects the value of an array. But, in C, arrays have no value! So foo gets instead the address of the first element of the array.\n\nint arr[5];\nint *ip = &amp;(arr[1]);\nif (arr == ip) { /* something; */ }\n\n\nIn the comparison above, arr has no value, so it becomes a pointer. It becomes a pointer to int. That pointer can be compared with the variable ip.\n\nIn the array indexing syntax you are used to seeing, again, the arr is &apos;decayed to a pointer&apos;\n\narr[42];\n/* same as *(arr + 42); */\n/* same as *(&amp;(arr[0]) + 42); */\n\n\nThe only times an array doesn&apos;t decay into a pointer are when it is the operand of the sizeof operator, or the &amp; operator (the &apos;address of&apos; operator), or as a string literal used to initialize a character array.\n    ","url":"/questions/[slug]#solution5","@type":"Answer","upvoteCount":0},{"text":"It&apos;s when array rots and is being pointed at ;-)\n\nActually, it&apos;s just that if you want to pass an array somewhere, but the pointer is passed instead (because who the hell would pass the whole array for you), people say that poor array decayed to pointer.\n    ","url":"/questions/[slug]#solution6","@type":"Answer","upvoteCount":0},{"text":"Array decaying means that, when an array is passed as a parameter to a function, it&apos;s treated identically to (&quot;decays to&quot;) a pointer.\n\nvoid do_something(int *array) {\n  // We don&apos;t know how big array is here, because it&apos;s decayed to a pointer.\n  printf(&quot;%i\\n&quot;, sizeof(array));  // always prints 4 on a 32-bit machine\n}\n\nint main (int argc, char **argv) {\n    int a[10];\n    int b[20];\n    int *c;\n    printf(&quot;%zu\\n&quot;, sizeof(a)); //prints 40 on a 32-bit machine\n    printf(&quot;%zu\\n&quot;, sizeof(b)); //prints 80 on a 32-bit machine\n    printf(&quot;%zu\\n&quot;, sizeof(c)); //prints 4 on a 32-bit machine\n    do_something(a);\n    do_something(b);\n    do_something(c);\n}\n\n\nThere are two complications or exceptions to the above.\n\nFirst, when dealing with multidimensional arrays in C and C++, only the first dimension is lost.  This is because arrays are layed out contiguously in memory, so the compiler must know all but the first dimension to be able to calculate offsets into that block of memory.\n\nvoid do_something(int array[][10])\n{\n    // We don&apos;t know how big the first dimension is.\n}\n\nint main(int argc, char *argv[]) {\n    int a[5][10];\n    int b[20][10];\n    do_something(a);\n    do_something(b);\n    return 0;\n}\n\n\nSecond, in C++, you can use templates to deduce the size of arrays.  Microsoft uses this for the C++ versions of Secure CRT functions like strcpy_s, and you can use a similar trick to reliably get the number of elements in an array.\n    ","url":"/questions/[slug]#solution7","@type":"Answer","upvoteCount":0},{"text":"tl;dr: When you use an array you&apos;ve defined, you&apos;ll actually be using a pointer to its first element.\nThus:\n\nWhen you write arr[idx] you&apos;re really just saying *(arr + idx).\nfunctions never really take arrays as parameters, only pointers - either directly, when you specify an array parameter, or indirectly, if you pass a reference to an array.\n\nSort-of exceptions to this rule:\n\nYou can pass fixed-length arrays to functions within a struct.\nsizeof() gives the size taken up by the array, not the size of a pointer.\n\n    ","url":"/questions/[slug]#solution8","@type":"Answer","upvoteCount":0},{"text":"Arrays are automatically passed by pointer in C. The rationale behind it can only be speculated.\nint a[5], int *a and int (*a)[5] are all glorified addresses meaning that the compiler treats arithmetic and deference operators on them differently depending on the type, so when they refer to the same address they are not treated the same by the compiler. int a[5] is different to the other 2 in that the address is implicit and does not manifest on the stack or the executable as part of the array itself, it is only used by the compiler to resolve certain arithmetic operations, like taking its address or pointer arithmetic. int a[5] is therefore an array as well as an implicit address, but as soon as you talk about the address itself and place it on the stack, the address itself is no longer an array, and can only be a pointer to an array or a decayed array i.e. a pointer to the first member of the array.\nFor instance, on int (*a)[5], the first dereference on a will produce an int * (so the same address, just a different type, and note not int a[5]), and pointer arithmetic on a i.e. a+1 or *(a+1) will be in terms of the size of an array of 5 ints (which is the data type it points to), and the second dereference will produce the int. On int a[5] however, the first dereference will produce the int and the pointer arithmetic will be in terms of the size of an int.\nTo a function, you can only pass int * and int (*)[5], and the function casts it to whatever the parameter type is, so within the function you have a choice whether to treat an address that is being passed as a decayed array or a pointer to an array (where the function has to specify the size of the array being passed). If you pass a to a function and a is defined int a[5], then as a resolves to an address, you are passing an address, and an address can only be a pointer type. In the function, the parameter it accesses is then an address on the stack or in a register, which can only be a pointer type and not an array type -- this is because it&apos;s an actual address on the stack and is therefore clearly not the array itself.\nYou lose the size of the array because the type of the parameter, being an address, is a pointer and not an array, which does not have an array size, as can be seen when using sizeof, which works on the type of the value being passed to it. The parameter type int a[5] instead of int *a is allowed but is treated as int * instead of disallowing it outright, though it should be disallowed, because it is misleading, because it makes you think that the size information can be used, but you can only do this by casting it to int (*a)[5], and of course, the function has to specify the size of the array because there is no way to pass the size of the array because the size of the array needs to be a compile-time constant.\n    ","url":"/questions/[slug]#solution9","@type":"Answer","upvoteCount":0},{"text":"I might be so bold to think there are four (4) ways to pass an array as the function argument. Also here is the short but working code for your perusal.\n\n#include &lt;iostream&gt;\n#include &lt;string&gt;\n#include &lt;vector&gt;\n#include &lt;cassert&gt;\n\nusing namespace std;\n\n// test data\n// notice native array init with no copy aka &quot;=&quot;\n// not possible in C\n const char* specimen[]{ __TIME__, __DATE__, __TIMESTAMP__ };\n\n// ONE\n// simple, dangerous and useless\ntemplate&lt;typename T&gt;\nvoid as_pointer(const T* array) { \n    // a pointer\n    assert(array != nullptr); \n} ;\n\n// TWO\n// for above const T array[] means the same\n// but and also , minimum array size indication might be given too\n// this also does not stop the array decay into T *\n// thus size information is lost\ntemplate&lt;typename T&gt;\nvoid by_value_no_size(const T array[0xFF]) { \n    // decayed to a pointer\n    assert( array != nullptr ); \n}\n\n// THREE\n// size information is preserved\n// but pointer is asked for\ntemplate&lt;typename T, size_t N&gt;\nvoid pointer_to_array(const T (*array)[N])\n{\n   // dealing with native pointer \n    assert( array != nullptr ); \n}\n\n// FOUR\n// no C equivalent\n// array by reference\n// size is preserved\ntemplate&lt;typename T, size_t N&gt;\nvoid reference_to_array(const T (&amp;array)[N])\n{\n    // array is not a pointer here\n    // it is (almost) a container\n    // most of the std:: lib algorithms \n    // do work on array reference, for example\n    // range for requires std::begin() and std::end()\n    // on the type passed as range to iterate over\n    for (auto &amp;&amp; elem : array )\n    {\n        cout &lt;&lt; endl &lt;&lt; elem ;\n    }\n}\n\nint main()\n{\n     // ONE\n     as_pointer(specimen);\n     // TWO\n     by_value_no_size(specimen);\n     // THREE\n     pointer_to_array(&amp;specimen);\n     // FOUR\n     reference_to_array( specimen ) ;\n}\n\n\nI might also think this shows the superiority of C++ vs C. At least in reference (pun intended) of passing an array by reference.\n\nOf course there are extremely strict projects with no heap allocation, no exceptions and no std:: lib. C++ native array handling is mission critical language feature, one might say.\n    ","url":"/questions/[slug]#solution10","@type":"Answer","upvoteCount":0},{"text":"Try this code\n\nvoid f(double a[10]) {\n    printf(&quot;in function: %d&quot;, sizeof(a));\n    printf(&quot;pointer size: %d\\n&quot;, sizeof(double *));\n}\n\nint main() {\n    double a[10];\n    printf(&quot;in main: %d&quot;, sizeof(a));\n    f(a);\n}\n\nand you will see that the size of the array inside the function is not equal to the size of the array in main, but it is equal to the size of a pointer.\nYou probably heard that &quot;arrays are pointers&quot;, but, this is not exactly true (the sizeof inside main prints the correct size). However, when passed, the array decays to pointer. That is, regardless of what the syntax shows, you actually pass a pointer, and the function actually receives a pointer.\nIn this case, the definition void f(double a[10] is implicitly transformed by the compiler to void f(double *a). You could have equivalently declared the function argument directly as *a. You could have even written a[100] or a[1], instead of a[10], since it is never actually compiled that way (however, you shouldn&apos;t do it obviously, it would confuse the reader).\n    ","url":"/questions/[slug]#solution11","@type":"Answer","upvoteCount":0}],"@type":"Question"}}</script><meta name="next-head-count" content="16"/><link rel="preload" href="/_next/static/css/08bcc42a26fe5c92.css" as="style"/><link rel="stylesheet" href="/_next/static/css/08bcc42a26fe5c92.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-0d1b80a048d4787e.js"></script><script src="/_next/static/chunks/webpack-42cdea76c8170223.js" defer=""></script><script src="/_next/static/chunks/framework-4556c45dd113b893.js" defer=""></script><script src="/_next/static/chunks/main-ccfab947c79712f4.js" defer=""></script><script src="/_next/static/chunks/pages/_app-08d1a634dea6705e.js" defer=""></script><script src="/_next/static/chunks/29107295-fbcfe2172188e46f.js" defer=""></script><script src="/_next/static/chunks/150-b06815e21c943e0d.js" defer=""></script><script src="/_next/static/chunks/490-7f0418bb4354ac73.js" defer=""></script><script src="/_next/static/chunks/108-87de33c23337ff53.js" defer=""></script><script src="/_next/static/chunks/pages/questions/%5Bslug%5D-79a1437acf654019.js" defer=""></script><script src="/_next/static/Zo3C7AOWQzKM9qqyzx2hf/_buildManifest.js" defer=""></script><script src="/_next/static/Zo3C7AOWQzKM9qqyzx2hf/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="wrapper"><header><nav class="bg-white border-gray-200 px-4 lg:px-6 py-2.5 dark:bg-gray-800"><div class="flex flex-wrap justify-between items-center mx-auto max-w-screen-xl"><a class="flex items-center" href="/"><img src="/logo-second.png" class="mr-3 h-6 sm:h-9" alt="Solution Checker Logo"/><h4 class="self-center text-xl font-semibold whitespace-nowrap dark:text-white">Solution Checker</h4></a><div class="flex items-center lg:order-2"><button data-collapse-toggle="mobile-menu-2" type="button" class="inline-flex items-center p-2 ml-1 text-sm text-gray-500 rounded-lg lg:hidden hover:bg-gray-100 focus:outline-none focus:ring-2 focus:ring-gray-200 dark:text-gray-400 dark:hover:bg-gray-700 dark:focus:ring-gray-600" aria-controls="mobile-menu-2" aria-expanded="false"><span class="sr-only">Open main menu</span><svg class="w-6 h-6" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M3 5a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM3 10a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM3 15a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1z" clip-rule="evenodd"></path></svg><svg class="hidden w-6 h-6" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z" clip-rule="evenodd"></path></svg></button></div><div class="hidden justify-between items-center w-full lg:flex lg:w-auto lg:order-1" id="mobile-menu-2"><ul class="flex flex-col mt-4 font-medium lg:flex-row lg:space-x-8 lg:mt-0"><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" aria-current="page" href="/">Home</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/questions?tab=news">Questions</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/post?tab=news">Post</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/questions/what-is-array-to-pointer-decay-1657384709608#">Coding</a></li></ul></div></div></nav></header><div class="main-content"><div class="question my-5"><div class="flex question-header items-center m-auto justify-center"><div class="rounded-xl w-full border p-5 shadow-md bg-white"><div class="flex w-full items-center justify-between border-b pb-3"><div class="flex items-center space-x-3"><div class="text-lg font-bold text-slate-700"><a href="/questions/what-is-array-to-pointer-decay-1657384709608"><h1>What is array to pointer decay?</h1></a></div></div><div class="flex flex-wrap h-auto justify-end items-center space-x-8"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold" href="/questions/tag/pointers">pointers</a></div></div><div class="question-content mt-5">
                
<p>What is array to pointer decay? Is there any relation to array pointers?</p>
    </div></div></div><div class="solution-section"><nav class="flex pagination-solution flex-col justify-end"><ul class="inline-flex -space-x-px overflow-auto"><li class="pagination-solution-item"><span data-id="#solution1" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">1</span></li><li class="pagination-solution-item"><span data-id="#solution2" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">2</span></li><li class="pagination-solution-item"><span data-id="#solution3" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">3</span></li><li class="pagination-solution-item"><span data-id="#solution4" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">4</span></li><li class="pagination-solution-item"><span data-id="#solution5" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">5</span></li><li class="pagination-solution-item"><span data-id="#solution6" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">6</span></li><li class="pagination-solution-item"><span data-id="#solution7" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">7</span></li><li class="pagination-solution-item"><span data-id="#solution8" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">8</span></li><li class="pagination-solution-item"><span data-id="#solution9" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">9</span></li><li class="pagination-solution-item"><span data-id="#solution10" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">10</span></li><li class="pagination-solution-item"><span data-id="#solution11" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">11</span></li></ul></nav><div id="solution1" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 1</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/pointers">pointers</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>It's said that arrays "decay" into pointers.  A C++ array declared as <code>int numbers [5]</code> cannot be re-pointed, i.e. you can't say <code>numbers = 0x5a5aff23</code>. More importantly the term decay signifies loss of type and dimension; <code>numbers</code> decay into <code>int*</code> by losing the dimension information (count 5) and the type is not <code>int [5]</code> any more. Look here for <a href="https://stackoverflow.com/questions/17752978/exception-to-array-not-decaying-into-a-pointer">cases where the decay doesn't happen</a>.</p>

<p>If you're passing an array by value, what you're really doing is copying a pointer - a pointer to the array's first element is copied to the parameter (whose type should also be a pointer the array element's type). This works due to array's decaying nature; once decayed, <code>sizeof</code> no longer gives the complete array's size, because it essentially becomes a pointer.  This is why it's preferred (among other reasons) to pass by reference or pointer.</p>

<p>Three ways to pass in an array<sup>1</sup>:</p>

<pre class="default s-code-block"><code class="hljs language-php"><span class="hljs-keyword">void</span> <span class="hljs-title function_ invoke__">by_value</span>(<span class="hljs-keyword">const</span> T* <span class="hljs-keyword">array</span>)   <span class="hljs-comment">// const T array[] means the same</span>
<span class="hljs-keyword">void</span> <span class="hljs-title function_ invoke__">by_pointer</span>(<span class="hljs-keyword">const</span> <span class="hljs-title function_ invoke__">T</span> (*<span class="hljs-keyword">array</span>)[U])
<span class="hljs-keyword">void</span> <span class="hljs-title function_ invoke__">by_reference</span>(<span class="hljs-keyword">const</span> <span class="hljs-title function_ invoke__">T</span> (&amp;<span class="hljs-keyword">array</span>)[U])
</code></pre>

<p>The last two will give proper <code>sizeof</code> info, while the first one won't since the array argument has decayed to be assigned to the parameter.</p>

<p><sup>1 The constant U should be known at compile-time.</sup></p>
    </div></div></div></div><div id="solution2" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 2</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/pointers">pointers</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Arrays are basically the same as pointers in C/C++, but not quite. Once you convert an array:</p>

<pre class="default s-code-block"><code class="hljs language-csharp"><span class="hljs-keyword">const</span> <span class="hljs-built_in">int</span> a[] = { <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>, <span class="hljs-number">11</span> };
</code></pre>

<p>into a pointer (which works without casting, and therefore can happen unexpectedly in some cases):</p>

<pre class="default s-code-block"><code class="hljs language-csharp"><span class="hljs-keyword">const</span> <span class="hljs-built_in">int</span>* p = a;
</code></pre>

<p>you lose the ability of the <code>sizeof</code> operator to count elements in the array:</p>

<pre class="default s-code-block"><code class="hljs language-csharp">assert( <span class="hljs-keyword">sizeof</span>(p) != <span class="hljs-keyword">sizeof</span>(a) );  <span class="hljs-comment">// sizes are not equal</span>
</code></pre>

<p>This lost ability is referred to as "decay".</p>

<p>For more details, check out this <a href="http://web.archive.org/web/20081208122434/http://www.transcendentaxis.com/dthompson/blog/archives/9" rel="noreferrer">article about array decay</a>.</p>
    </div></div></div></div><div id="solution3" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 3</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/pointers">pointers</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Here's what the standard says (C99 6.3.2.1/3 - Other operands - Lvalues, arrays, and function designators):</p>

<blockquote>
  <p>Except when it is the operand of the sizeof operator or the unary &amp; operator, or is a
  string literal used to initialize an array, an expression that has type array of type is
  converted to an expression with type pointer to type that points to the initial element of
  the array object and is not an lvalue.</p>
</blockquote>

<p>This means that pretty much anytime the array name is used in an expression, it is automatically converted to a pointer to the 1st item in the array.</p>

<p>Note that function names act in a similar way, but function pointers are used far less and in a much more specialized way that it doesn't cause nearly as much confusion as the automatic conversion of array names to pointers.</p>

<p>The C++ standard (4.2 Array-to-pointer conversion) loosens the conversion requirement to (emphasis mine):</p>

<blockquote>
  <p>An lvalue or rvalue of type array of N T or array of unknown bound of T <strong>can</strong> be converted to an rvalue
  of type pointer to T.</p>
</blockquote>

<p>So the conversion doesn't <em>have</em> to happen like it pretty much always does in C (this lets functions overload or templates match on the array type).</p>

<p>This is also why in C you should avoid using array parameters in function prototypes/definitions (in my opinion - I'm not sure if there's any general agreement).  They cause confusion and are a fiction anyway - use pointer parameters and the confusion might not go away entirely, but at least the parameter declaration isn't lying.</p>
    </div></div></div></div><div id="solution4" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 4</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/pointers">pointers</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>"Decay" refers to the implicit conversion of an expression from an array type to a pointer type.  In most contexts, when the compiler sees an array expression it converts the type of the expression from "N-element array of T" to "pointer to T" and sets the value of the expression to the address of the first element of the array.  The exceptions to this rule are when an array is an operand of either the <code>sizeof</code> or <code>&amp;</code> operators, or the array is a string literal being used as an initializer in a declaration.</p>
<p>Assume the following code:</p>
<pre class="default s-code-block"><code class="hljs language-css">char <span class="hljs-selector-tag">a</span><span class="hljs-selector-attr">[80]</span>;
strcpy(<span class="hljs-selector-tag">a</span>, "This is <span class="hljs-selector-tag">a</span> test");
</code></pre>
<p>The expression <code>a</code> is of type "80-element array of char" and the expression "This is a test" is of type "15-element array of char" (in C; in C++ string literals are arrays of const char).  However, in the call to <code>strcpy()</code>, neither expression is an operand of <code>sizeof</code> or <code>&amp;</code>, so their types are implicitly converted to "pointer to char", and their values are set to the address of the first element in each.  What <code>strcpy()</code> receives are not arrays, but pointers, as seen in its prototype:</p>
<pre class="default s-code-block"><code class="hljs language-cpp"><span class="hljs-function"><span class="hljs-type">char</span> *<span class="hljs-title">strcpy</span><span class="hljs-params">(<span class="hljs-type">char</span> *dest, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *src)</span></span>;
</code></pre>
<p>This is not the same thing as an array pointer.  For example:</p>
<pre class="default s-code-block"><code class="hljs language-csharp"><span class="hljs-built_in">char</span> a[<span class="hljs-number">80</span>];
<span class="hljs-built_in">char</span> *ptr_to_first_element = a;
<span class="hljs-built_in">char</span> (*ptr_to_array)[<span class="hljs-number">80</span>] = &amp;a;
</code></pre>
<p>Both <code>ptr_to_first_element</code> and <code>ptr_to_array</code> have the same <em>value</em>; the base address of a.  However, they are different types and are treated differently, as shown below:</p>
<pre class="default s-code-block"><code class="hljs language-yaml"><span class="hljs-string">a[i]</span> <span class="hljs-string">==</span> <span class="hljs-string">ptr_to_first_element[i]</span> <span class="hljs-string">==</span> <span class="hljs-string">(*ptr_to_array)[i]</span> <span class="hljs-type">!=</span> <span class="hljs-string">*ptr_to_array[i]</span> <span class="hljs-type">!=</span> <span class="hljs-string">ptr_to_array[i]</span>
</code></pre>
<p>Remember that the expression <code>a[i]</code> is interpreted as <code>*(a+i)</code> (which only works if the array type is converted to a pointer type), so both <code>a[i]</code> and <code>ptr_to_first_element[i]</code> work the same. The expression <code>(*ptr_to_array)[i]</code> is interpreted as <code>*(*a+i)</code>.  The expressions <code>*ptr_to_array[i]</code> and <code>ptr_to_array[i]</code> may lead to compiler warnings or errors depending on the context; they'll definitely do the wrong thing if you're expecting them to evaluate to <code>a[i]</code>.</p>
<pre class="default s-code-block"><code class="hljs language-csharp"><span class="hljs-keyword">sizeof</span> a == <span class="hljs-keyword">sizeof</span> *ptr_to_array == <span class="hljs-number">80</span>
</code></pre>
<p>Again, when an array is an operand of <code>sizeof</code>, it's not converted to a pointer type.</p>
<pre class="default s-code-block"><code class="hljs language-csharp"><span class="hljs-keyword">sizeof</span> *ptr_to_first_element == <span class="hljs-keyword">sizeof</span> (<span class="hljs-built_in">char</span>) == <span class="hljs-number">1</span>
<span class="hljs-keyword">sizeof</span> ptr_to_first_element == <span class="hljs-keyword">sizeof</span> (<span class="hljs-built_in">char</span> *) == whatever the pointer size
                                                  <span class="hljs-keyword">is</span> <span class="hljs-keyword">on</span> your platform
</code></pre>
<p><code>ptr_to_first_element</code> is a simple pointer to char.</p>
    </div></div></div></div><div id="solution5" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 5</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/pointers">pointers</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p><b>Arrays, in C, have no value.</b></p>

<p>Wherever the value of an object is expected but the object is an array, the address of its first element is used instead, with type <code>pointer to (type of array elements)</code>.</p>

<p>In a function, all parameters are passed by value (arrays are no exception). When you pass an array in a function it "decays into a pointer" (sic); when you compare an array to something else, again it "decays into a pointer" (sic); ...</p>

<pre class="default s-code-block"><code class="hljs language-csharp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">foo</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> arr[]</span>)</span>;
</code></pre>

<p>Function foo expects the value of an array. But, in C, arrays have no value! So <code>foo</code> gets instead the address of the first element of the array.</p>

<pre class="default s-code-block"><code class="hljs language-csharp"><span class="hljs-built_in">int</span> arr[<span class="hljs-number">5</span>];
<span class="hljs-built_in">int</span> *ip = &amp;(arr[<span class="hljs-number">1</span>]);
<span class="hljs-keyword">if</span> (arr == ip) { <span class="hljs-comment">/* something; */</span> }
</code></pre>

<p>In the comparison above, <code>arr</code> has no value, so it becomes a pointer. It becomes a pointer to int. That pointer can be compared with the variable <code>ip</code>.</p>

<p>In the array indexing syntax you are used to seeing, again, the arr is 'decayed to a pointer'</p>

<pre class="default s-code-block"><code class="hljs language-css">arr<span class="hljs-selector-attr">[42]</span>;
<span class="hljs-comment">/* same as *(arr + 42); */</span>
<span class="hljs-comment">/* same as *(&amp;(arr[0]) + 42); */</span>
</code></pre>

<p>The only times an array doesn't decay into a pointer are when it is the operand of the sizeof operator, or the &amp; operator (the 'address of' operator), or as a string literal used to initialize a character array.</p>
    </div></div></div></div><div id="solution6" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 6</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/pointers">pointers</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>It's when array rots and is being pointed at ;-)</p>

<p>Actually, it's just that if you want to pass an array somewhere, but the pointer is passed instead (because who the hell would pass the whole array for you), people say that poor array decayed to pointer.</p>
    </div></div></div></div><div id="solution7" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 7</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/pointers">pointers</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Array decaying means that, when an array is passed as a parameter to a function, it's treated identically to ("decays to") a pointer.</p>

<pre class="default s-code-block"><code class="hljs language-scss">void <span class="hljs-built_in">do_something</span>(int *array) {
  <span class="hljs-comment">// We don't know how big array is here, because it's decayed to a pointer.</span>
  <span class="hljs-built_in">printf</span>("%i\n", sizeof(array));  <span class="hljs-comment">// always prints 4 on a 32-bit machine</span>
}

int <span class="hljs-selector-tag">main</span> (int argc, char **argv) {
    int <span class="hljs-selector-tag">a</span><span class="hljs-selector-attr">[10]</span>;
    int <span class="hljs-selector-tag">b</span><span class="hljs-selector-attr">[20]</span>;
    int *c;
    <span class="hljs-built_in">printf</span>("%zu\n", sizeof(a)); <span class="hljs-comment">//prints 40 on a 32-bit machine</span>
    <span class="hljs-built_in">printf</span>("%zu\n", sizeof(b)); <span class="hljs-comment">//prints 80 on a 32-bit machine</span>
    <span class="hljs-built_in">printf</span>("%zu\n", sizeof(c)); <span class="hljs-comment">//prints 4 on a 32-bit machine</span>
    <span class="hljs-built_in">do_something</span>(a);
    <span class="hljs-built_in">do_something</span>(b);
    <span class="hljs-built_in">do_something</span>(c);
}
</code></pre>

<p>There are two complications or exceptions to the above.</p>

<p>First, when dealing with multidimensional arrays in C and C++, only the first dimension is lost.  This is because arrays are layed out contiguously in memory, so the compiler must know all but the first dimension to be able to calculate offsets into that block of memory.</p>

<pre class="default s-code-block"><code class="hljs language-scss">void <span class="hljs-built_in">do_something</span>(int array[][<span class="hljs-number">10</span>])
{
    <span class="hljs-comment">// We don't know how big the first dimension is.</span>
}

int <span class="hljs-selector-tag">main</span>(int argc, char *argv[]) {
    int <span class="hljs-selector-tag">a</span><span class="hljs-selector-attr">[5]</span><span class="hljs-selector-attr">[10]</span>;
    int <span class="hljs-selector-tag">b</span><span class="hljs-selector-attr">[20]</span><span class="hljs-selector-attr">[10]</span>;
    <span class="hljs-built_in">do_something</span>(a);
    <span class="hljs-built_in">do_something</span>(b);
    return <span class="hljs-number">0</span>;
}
</code></pre>

<p>Second, in C++, you can use templates to deduce the size of arrays.  Microsoft uses this for the C++ versions of Secure CRT functions like <a href="http://msdn.microsoft.com/en-us/library/td1esda9%28VS.80%29.aspx" rel="nofollow noreferrer">strcpy_s</a>, and you can use a similar trick to reliably <a href="https://stackoverflow.com/questions/469696/what-is-your-most-useful-c-c-snippet/470221#470221">get the number of elements in an array</a>.</p>
    </div></div></div></div><div id="solution8" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 8</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/pointers">pointers</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<h3>tl;dr: When you use an array you've defined, you'll actually be using a pointer to its first element.</h3>
<p>Thus:</p>
<ul>
<li>When you write <code>arr[idx]</code> you're really just saying <code>*(arr + idx)</code>.</li>
<li>functions never really take arrays as parameters, only pointers - either directly, when you specify an array parameter, or indirectly, if you pass a reference to an array.</li>
</ul>
<p>Sort-of exceptions to this rule:</p>
<ul>
<li>You can pass fixed-length arrays to functions within a <code>struct</code>.</li>
<li><code>sizeof()</code> gives the size taken up by the array, not the size of a pointer.</li>
</ul>
    </div></div></div></div><div id="solution9" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 9</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/pointers">pointers</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Arrays are automatically passed by pointer in C. <a href="https://stackoverflow.com/a/671348/7194773">The rationale behind it can only be speculated</a>.</p>
<p><code>int a[5]</code>, <code>int *a</code> and <code>int (*a)[5]</code> are all glorified addresses meaning that the compiler treats arithmetic and deference operators on them differently depending on the type, so when they refer to the same address they are not treated the same by the compiler. <code>int a[5]</code> is different to the other 2 in that the address is implicit and does not manifest on the stack or the executable as part of the array itself, it is only used by the compiler to resolve certain arithmetic operations, like taking its address or pointer arithmetic. <code>int a[5]</code> is therefore an array as well as an implicit address, but as soon as you talk about the address itself and place it on the stack, the address itself is no longer an array, and can only be a pointer to an array or a decayed array i.e. a pointer to the first member of the array.</p>
<p>For instance, on <code>int (*a)[5]</code>, the first dereference on <code>a</code> will produce an <code>int *</code> (so the same address, just a different type, and note not <code>int a[5]</code>), and pointer arithmetic on <code>a</code> i.e. <code>a+1</code> or <code>*(a+1)</code> will be in terms of the size of an array of 5 ints (which is the data type it points to), and the second dereference will produce the <code>int</code>. On <code>int a[5]</code> however, the first dereference will produce the <code>int</code> and the pointer arithmetic will be in terms of the size of an <code>int</code>.</p>
<p>To a function, you can only pass <code>int *</code> and <code>int (*)[5]</code>, and the function casts it to whatever the parameter type is, so within the function you have a choice whether to treat an address that is being passed as a decayed array or a pointer to an array (where the function has to specify the size of the array being passed). If you pass <code>a</code> to a function and <code>a</code> is defined <code>int a[5]</code>, then as <code>a</code> resolves to an address, you are passing an address, and an address can only be a pointer type. In the function, the parameter it accesses is then an address on the stack or in a register, which can only be a pointer type and not an array type -- this is because it's an actual address on the stack and is therefore clearly not the array itself.</p>
<p>You lose the size of the array because the type of the parameter, being an address, is a pointer and not an array, which does not have an array size, as can be seen when using <code>sizeof</code>, which works on the type of the value being passed to it. The parameter type <code>int a[5]</code> instead of <code>int *a</code> is allowed but is treated as <code>int *</code> instead of disallowing it outright, though it should be disallowed, because it is misleading, because it makes you think that the size information can be used, but you can only do this by casting it to <code>int (*a)[5]</code>, and of course, the function has to specify the size of the array because there is no way to pass the size of the array because the size of the array needs to be a compile-time constant.</p>
    </div></div></div></div><div id="solution10" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 10</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/pointers">pointers</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>I might be so bold to think there are four (4) ways to pass an array as the function argument. Also here is the short but working code for your perusal.</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cassert&gt;</span></span>

<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;

<span class="hljs-comment">// test data</span>
<span class="hljs-comment">// notice native array init with no copy aka "="</span>
<span class="hljs-comment">// not possible in C</span>
 <span class="hljs-type">const</span> <span class="hljs-type">char</span>* specimen[]{ __TIME__, __DATE__, __TIMESTAMP__ };

<span class="hljs-comment">// ONE</span>
<span class="hljs-comment">// simple, dangerous and useless</span>
<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-type">void</span> <span class="hljs-title">as_pointer</span><span class="hljs-params">(<span class="hljs-type">const</span> T* array)</span> </span>{ 
    <span class="hljs-comment">// a pointer</span>
    <span class="hljs-built_in">assert</span>(array != <span class="hljs-literal">nullptr</span>); 
} ;

<span class="hljs-comment">// TWO</span>
<span class="hljs-comment">// for above const T array[] means the same</span>
<span class="hljs-comment">// but and also , minimum array size indication might be given too</span>
<span class="hljs-comment">// this also does not stop the array decay into T *</span>
<span class="hljs-comment">// thus size information is lost</span>
<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-type">void</span> <span class="hljs-title">by_value_no_size</span><span class="hljs-params">(<span class="hljs-type">const</span> T array[<span class="hljs-number">0xFF</span>])</span> </span>{ 
    <span class="hljs-comment">// decayed to a pointer</span>
    <span class="hljs-built_in">assert</span>( array != <span class="hljs-literal">nullptr</span> ); 
}

<span class="hljs-comment">// THREE</span>
<span class="hljs-comment">// size information is preserved</span>
<span class="hljs-comment">// but pointer is asked for</span>
<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-type">size_t</span> N&gt;
<span class="hljs-type">void</span> <span class="hljs-title">pointer_to_array</span><span class="hljs-params">(<span class="hljs-type">const</span> T (*array)[N])</span>
</span>{
   <span class="hljs-comment">// dealing with native pointer </span>
    <span class="hljs-built_in">assert</span>( array != <span class="hljs-literal">nullptr</span> ); 
}

<span class="hljs-comment">// FOUR</span>
<span class="hljs-comment">// no C equivalent</span>
<span class="hljs-comment">// array by reference</span>
<span class="hljs-comment">// size is preserved</span>
<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-type">size_t</span> N&gt;
<span class="hljs-type">void</span> <span class="hljs-title">reference_to_array</span><span class="hljs-params">(<span class="hljs-type">const</span> T (&amp;array)[N])</span>
</span>{
    <span class="hljs-comment">// array is not a pointer here</span>
    <span class="hljs-comment">// it is (almost) a container</span>
    <span class="hljs-comment">// most of the std:: lib algorithms </span>
    <span class="hljs-comment">// do work on array reference, for example</span>
    <span class="hljs-comment">// range for requires std::begin() and std::end()</span>
    <span class="hljs-comment">// on the type passed as range to iterate over</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;&amp; elem : array )
    {
        cout &lt;&lt; endl &lt;&lt; elem ;
    }
}

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
     <span class="hljs-comment">// ONE</span>
     <span class="hljs-built_in">as_pointer</span>(specimen);
     <span class="hljs-comment">// TWO</span>
     <span class="hljs-built_in">by_value_no_size</span>(specimen);
     <span class="hljs-comment">// THREE</span>
     <span class="hljs-built_in">pointer_to_array</span>(&amp;specimen);
     <span class="hljs-comment">// FOUR</span>
     <span class="hljs-built_in">reference_to_array</span>( specimen ) ;
}
</code></pre>

<p>I might also think this shows the superiority of C++ vs C. At least in reference (pun intended) of passing an array by reference.</p>

<p>Of course there are extremely strict projects with no heap allocation, no exceptions and no std:: lib. C++ native array handling is mission critical language feature, one might say.</p>
    </div></div></div></div><div id="solution11" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 11</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/pointers">pointers</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Try this code</p>
<pre class="default s-code-block"><code class="hljs language-csharp">
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">f</span>(<span class="hljs-params"><span class="hljs-built_in">double</span> a[<span class="hljs-number">10</span>]</span>)</span> {
    printf(<span class="hljs-string">"in function: %d"</span>, <span class="hljs-keyword">sizeof</span>(a));
    printf(<span class="hljs-string">"pointer size: %d\n"</span>, <span class="hljs-keyword">sizeof</span>(<span class="hljs-built_in">double</span> *));
}

<span class="hljs-function"><span class="hljs-built_in">int</span> <span class="hljs-title">main</span>()</span> {
    <span class="hljs-built_in">double</span> a[<span class="hljs-number">10</span>];
    printf(<span class="hljs-string">"in main: %d"</span>, <span class="hljs-keyword">sizeof</span>(a));
    f(a);
}
</code></pre>
<p>and you will see that the size of the array inside the function is not equal to the size of the array in main, but it is equal to the size of a pointer.</p>
<p>You probably heard that "arrays are pointers", but, this is not exactly true (the <code>sizeof</code> inside <code>main</code> prints the correct size). However, when passed, the array <em>decays</em> to pointer. That is, regardless of what the syntax shows, you actually pass a pointer, and the function actually receives a pointer.</p>
<p>In this case, the definition <code>void f(double a[10]</code> is implicitly transformed by the compiler to <code>void f(double *a)</code>. You could have equivalently declared the function argument directly as <code>*a</code>. You could have even written <code>a[100]</code> or <code>a[1]</code>, instead of <code>a[10]</code>, since it is never actually compiled that way (however, you shouldn't do it obviously, it would confuse the reader).</p>
    </div></div></div></div></div></div><div class="widget"><a href="/questions/what&#x27;s-the-simplest-way-to-print-a-java-array-1657384702397">What&#x27;s the simplest way to print a Java array?</a><a href="/questions/in-css-flexbox-why-are-there-no-%22justify-items%22-and-%22justify-self%22-properties-1657384782711">In CSS Flexbox, why are there no &quot;justify-items&quot; and &quot;justify-self&quot; properties?</a><a href="/questions/mysql-pivot-row-into-dynamic-number-of-columns-1657387981930">MySQL pivot row into dynamic number of columns</a><a href="/questions/how-to-make-a-div-100percent-height-of-the-browser-window-1657388265955">How to make a div 100% height of the browser window</a><a href="/questions/unboundlocalerror-on-local-variable-when-reassigned-after-first-use-1657387685248">UnboundLocalError on local variable when reassigned after first use</a><a href="/questions/what-is-pecs-(producer-extends-consumer-super)-1657384828870">What is PECS (Producer Extends Consumer Super)?</a><a href="/questions/what-is-the-difference-between-client-side-and-server-side-programming-1657384372926">What is the difference between client-side and server-side programming?</a><a href="/questions/how-can-i-pivot-a-dataframe-1657384433802">How can I pivot a dataframe?</a><a href="/questions/are-&#x27;arrow-functions&#x27;-and-&#x27;functions&#x27;-equivalent-interchangeable-1657384527873">Are &#x27;Arrow Functions&#x27; and &#x27;Functions&#x27; equivalent / interchangeable?</a><a href="/questions/what-does-enctype&#x27;multipartform-data&#x27;-mean-1657388229352">What does enctype=&#x27;multipart/form-data&#x27; mean?</a><a href="/questions/get-the-row(s)-which-have-the-max-value-in-groups-using-groupby-1657388014787">Get the row(s) which have the max value in groups using groupby</a><a href="/questions/selenium-%22selenium.common.exceptions.nosuchelementexception%22-when-using-chrome-1657388136699">Selenium &quot;selenium.common.exceptions.NoSuchElementException&quot; when using Chrome</a><a href="/questions/dollar(document).ready-equivalent-without-jquery-1657388504115">$(document).ready equivalent without jQuery</a><a href="/questions/official-locator-strategies-for-the-webdriver-1657384353174">Official locator strategies for the webdriver</a><a href="/questions/converting-string-into-datetime-1657387717295">Converting string into datetime</a><a href="/questions/how-does-javascript-.prototype-work-1657388169270">How does JavaScript .prototype work?</a><a href="/questions/what-does-a-space-mean-in-a-css-selector-i.e.-what-is-the-difference-between-.classa.classb-and-.classa-.classb-1657387912095">What does a space mean in a CSS selector? i.e. What is the difference between .classA.classB and .classA .classB?</a><a href="/questions/where-and-why-do-i-have-to-put-the-%22template%22-and-%22typename%22-keywords-1657384467606">Where and why do I have to put the &quot;template&quot; and &quot;typename&quot; keywords?</a><a href="/questions/where-do-i-find-the-current-c-or-c++-standard-documents-1657388006897">Where do I find the current C or C++ standard documents?</a><a href="/questions/how-to-generate-a-self-signed-ssl-certificate-using-openssl-closed-1657388298626">How to generate a self-signed SSL certificate using OpenSSL? [closed]</a></div></div><span class="cursor-pointer text-lg p-2" style="position:fixed;bottom:20px;left:20px;background:#000;z-index:2000;color:white">Go go top</span></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"data":{"answer":["\n\u0026lt;p\u0026gt;It\u0026apos;s said that arrays \u0026quot;decay\u0026quot; into pointers.  A C++ array declared as \u0026lt;code\u0026gt;int numbers [5]\u0026lt;/code\u0026gt; cannot be re-pointed, i.e. you can\u0026apos;t say \u0026lt;code\u0026gt;numbers = 0x5a5aff23\u0026lt;/code\u0026gt;. More importantly the term decay signifies loss of type and dimension; \u0026lt;code\u0026gt;numbers\u0026lt;/code\u0026gt; decay into \u0026lt;code\u0026gt;int*\u0026lt;/code\u0026gt; by losing the dimension information (count 5) and the type is not \u0026lt;code\u0026gt;int [5]\u0026lt;/code\u0026gt; any more. Look here for \u0026lt;a href=\u0026quot;https://stackoverflow.com/questions/17752978/exception-to-array-not-decaying-into-a-pointer\u0026quot;\u0026gt;cases where the decay doesn\u0026apos;t happen\u0026lt;/a\u0026gt;.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;If you\u0026apos;re passing an array by value, what you\u0026apos;re really doing is copying a pointer - a pointer to the array\u0026apos;s first element is copied to the parameter (whose type should also be a pointer the array element\u0026apos;s type). This works due to array\u0026apos;s decaying nature; once decayed, \u0026lt;code\u0026gt;sizeof\u0026lt;/code\u0026gt; no longer gives the complete array\u0026apos;s size, because it essentially becomes a pointer.  This is why it\u0026apos;s preferred (among other reasons) to pass by reference or pointer.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Three ways to pass in an array\u0026lt;sup\u0026gt;1\u0026lt;/sup\u0026gt;:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;default s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-php\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_ invoke__\u0026quot;\u0026gt;by_value\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; T* \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;array\u0026lt;/span\u0026gt;)   \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// const T array[] means the same\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_ invoke__\u0026quot;\u0026gt;by_pointer\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_ invoke__\u0026quot;\u0026gt;T\u0026lt;/span\u0026gt; (*\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;array\u0026lt;/span\u0026gt;)[U])\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_ invoke__\u0026quot;\u0026gt;by_reference\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_ invoke__\u0026quot;\u0026gt;T\u0026lt;/span\u0026gt; (\u0026amp;amp;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;array\u0026lt;/span\u0026gt;)[U])\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;The last two will give proper \u0026lt;code\u0026gt;sizeof\u0026lt;/code\u0026gt; info, while the first one won\u0026apos;t since the array argument has decayed to be assigned to the parameter.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;sup\u0026gt;1 The constant U should be known at compile-time.\u0026lt;/sup\u0026gt;\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Arrays are basically the same as pointers in C/C++, but not quite. Once you convert an array:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;default s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-csharp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; a[] = { \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;5\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;7\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;11\u0026lt;/span\u0026gt; };\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;into a pointer (which works without casting, and therefore can happen unexpectedly in some cases):\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;default s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-csharp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;* p = a;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;you lose the ability of the \u0026lt;code\u0026gt;sizeof\u0026lt;/code\u0026gt; operator to count elements in the array:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;default s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-csharp\u0026quot;\u0026gt;assert( \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;sizeof\u0026lt;/span\u0026gt;(p) != \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;sizeof\u0026lt;/span\u0026gt;(a) );  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// sizes are not equal\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;This lost ability is referred to as \u0026quot;decay\u0026quot;.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;For more details, check out this \u0026lt;a href=\u0026quot;http://web.archive.org/web/20081208122434/http://www.transcendentaxis.com/dthompson/blog/archives/9\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;article about array decay\u0026lt;/a\u0026gt;.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Here\u0026apos;s what the standard says (C99 6.3.2.1/3 - Other operands - Lvalues, arrays, and function designators):\u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;Except when it is the operand of the sizeof operator or the unary \u0026amp;amp; operator, or is a\n  string literal used to initialize an array, an expression that has type array of type is\n  converted to an expression with type pointer to type that points to the initial element of\n  the array object and is not an lvalue.\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;p\u0026gt;This means that pretty much anytime the array name is used in an expression, it is automatically converted to a pointer to the 1st item in the array.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Note that function names act in a similar way, but function pointers are used far less and in a much more specialized way that it doesn\u0026apos;t cause nearly as much confusion as the automatic conversion of array names to pointers.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;The C++ standard (4.2 Array-to-pointer conversion) loosens the conversion requirement to (emphasis mine):\u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;An lvalue or rvalue of type array of N T or array of unknown bound of T \u0026lt;strong\u0026gt;can\u0026lt;/strong\u0026gt; be converted to an rvalue\n  of type pointer to T.\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;p\u0026gt;So the conversion doesn\u0026apos;t \u0026lt;em\u0026gt;have\u0026lt;/em\u0026gt; to happen like it pretty much always does in C (this lets functions overload or templates match on the array type).\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;This is also why in C you should avoid using array parameters in function prototypes/definitions (in my opinion - I\u0026apos;m not sure if there\u0026apos;s any general agreement).  They cause confusion and are a fiction anyway - use pointer parameters and the confusion might not go away entirely, but at least the parameter declaration isn\u0026apos;t lying.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;\u0026quot;Decay\u0026quot; refers to the implicit conversion of an expression from an array type to a pointer type.  In most contexts, when the compiler sees an array expression it converts the type of the expression from \u0026quot;N-element array of T\u0026quot; to \u0026quot;pointer to T\u0026quot; and sets the value of the expression to the address of the first element of the array.  The exceptions to this rule are when an array is an operand of either the \u0026lt;code\u0026gt;sizeof\u0026lt;/code\u0026gt; or \u0026lt;code\u0026gt;\u0026amp;amp;\u0026lt;/code\u0026gt; operators, or the array is a string literal being used as an initializer in a declaration.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Assume the following code:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;default s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-css\u0026quot;\u0026gt;char \u0026lt;span class=\u0026quot;hljs-selector-tag\u0026quot;\u0026gt;a\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-selector-attr\u0026quot;\u0026gt;[80]\u0026lt;/span\u0026gt;;\nstrcpy(\u0026lt;span class=\u0026quot;hljs-selector-tag\u0026quot;\u0026gt;a\u0026lt;/span\u0026gt;, \u0026quot;This is \u0026lt;span class=\u0026quot;hljs-selector-tag\u0026quot;\u0026gt;a\u0026lt;/span\u0026gt; test\u0026quot;);\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;The expression \u0026lt;code\u0026gt;a\u0026lt;/code\u0026gt; is of type \u0026quot;80-element array of char\u0026quot; and the expression \u0026quot;This is a test\u0026quot; is of type \u0026quot;15-element array of char\u0026quot; (in C; in C++ string literals are arrays of const char).  However, in the call to \u0026lt;code\u0026gt;strcpy()\u0026lt;/code\u0026gt;, neither expression is an operand of \u0026lt;code\u0026gt;sizeof\u0026lt;/code\u0026gt; or \u0026lt;code\u0026gt;\u0026amp;amp;\u0026lt;/code\u0026gt;, so their types are implicitly converted to \u0026quot;pointer to char\u0026quot;, and their values are set to the address of the first element in each.  What \u0026lt;code\u0026gt;strcpy()\u0026lt;/code\u0026gt; receives are not arrays, but pointers, as seen in its prototype:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;default s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; *\u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;strcpy\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; *dest, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; *src)\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;This is not the same thing as an array pointer.  For example:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;default s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-csharp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; a[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;80\u0026lt;/span\u0026gt;];\n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; *ptr_to_first_element = a;\n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; (*ptr_to_array)[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;80\u0026lt;/span\u0026gt;] = \u0026amp;amp;a;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;Both \u0026lt;code\u0026gt;ptr_to_first_element\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;ptr_to_array\u0026lt;/code\u0026gt; have the same \u0026lt;em\u0026gt;value\u0026lt;/em\u0026gt;; the base address of a.  However, they are different types and are treated differently, as shown below:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;default s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-yaml\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;a[i]\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;==\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;ptr_to_first_element[i]\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;==\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;(*ptr_to_array)[i]\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;!=\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;*ptr_to_array[i]\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;!=\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;ptr_to_array[i]\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;Remember that the expression \u0026lt;code\u0026gt;a[i]\u0026lt;/code\u0026gt; is interpreted as \u0026lt;code\u0026gt;*(a+i)\u0026lt;/code\u0026gt; (which only works if the array type is converted to a pointer type), so both \u0026lt;code\u0026gt;a[i]\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;ptr_to_first_element[i]\u0026lt;/code\u0026gt; work the same. The expression \u0026lt;code\u0026gt;(*ptr_to_array)[i]\u0026lt;/code\u0026gt; is interpreted as \u0026lt;code\u0026gt;*(*a+i)\u0026lt;/code\u0026gt;.  The expressions \u0026lt;code\u0026gt;*ptr_to_array[i]\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;ptr_to_array[i]\u0026lt;/code\u0026gt; may lead to compiler warnings or errors depending on the context; they\u0026apos;ll definitely do the wrong thing if you\u0026apos;re expecting them to evaluate to \u0026lt;code\u0026gt;a[i]\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;default s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-csharp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;sizeof\u0026lt;/span\u0026gt; a == \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;sizeof\u0026lt;/span\u0026gt; *ptr_to_array == \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;80\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;Again, when an array is an operand of \u0026lt;code\u0026gt;sizeof\u0026lt;/code\u0026gt;, it\u0026apos;s not converted to a pointer type.\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;default s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-csharp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;sizeof\u0026lt;/span\u0026gt; *ptr_to_first_element == \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;sizeof\u0026lt;/span\u0026gt; (\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt;) == \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;sizeof\u0026lt;/span\u0026gt; ptr_to_first_element == \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;sizeof\u0026lt;/span\u0026gt; (\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; *) == whatever the pointer size\n                                                  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;is\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;on\u0026lt;/span\u0026gt; your platform\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;code\u0026gt;ptr_to_first_element\u0026lt;/code\u0026gt; is a simple pointer to char.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;\u0026lt;b\u0026gt;Arrays, in C, have no value.\u0026lt;/b\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Wherever the value of an object is expected but the object is an array, the address of its first element is used instead, with type \u0026lt;code\u0026gt;pointer to (type of array elements)\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;In a function, all parameters are passed by value (arrays are no exception). When you pass an array in a function it \u0026quot;decays into a pointer\u0026quot; (sic); when you compare an array to something else, again it \u0026quot;decays into a pointer\u0026quot; (sic); ...\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;default s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-csharp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;foo\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; arr[]\u0026lt;/span\u0026gt;)\u0026lt;/span\u0026gt;;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Function foo expects the value of an array. But, in C, arrays have no value! So \u0026lt;code\u0026gt;foo\u0026lt;/code\u0026gt; gets instead the address of the first element of the array.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;default s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-csharp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; arr[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;5\u0026lt;/span\u0026gt;];\n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; *ip = \u0026amp;amp;(arr[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;]);\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (arr == ip) { \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;/* something; */\u0026lt;/span\u0026gt; }\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;In the comparison above, \u0026lt;code\u0026gt;arr\u0026lt;/code\u0026gt; has no value, so it becomes a pointer. It becomes a pointer to int. That pointer can be compared with the variable \u0026lt;code\u0026gt;ip\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;In the array indexing syntax you are used to seeing, again, the arr is \u0026apos;decayed to a pointer\u0026apos;\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;default s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-css\u0026quot;\u0026gt;arr\u0026lt;span class=\u0026quot;hljs-selector-attr\u0026quot;\u0026gt;[42]\u0026lt;/span\u0026gt;;\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;/* same as *(arr + 42); */\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;/* same as *(\u0026amp;amp;(arr[0]) + 42); */\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;The only times an array doesn\u0026apos;t decay into a pointer are when it is the operand of the sizeof operator, or the \u0026amp;amp; operator (the \u0026apos;address of\u0026apos; operator), or as a string literal used to initialize a character array.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;It\u0026apos;s when array rots and is being pointed at ;-)\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Actually, it\u0026apos;s just that if you want to pass an array somewhere, but the pointer is passed instead (because who the hell would pass the whole array for you), people say that poor array decayed to pointer.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Array decaying means that, when an array is passed as a parameter to a function, it\u0026apos;s treated identically to (\u0026quot;decays to\u0026quot;) a pointer.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;default s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-scss\u0026quot;\u0026gt;void \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;do_something\u0026lt;/span\u0026gt;(int *array) {\n  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// We don\u0026apos;t know how big array is here, because it\u0026apos;s decayed to a pointer.\u0026lt;/span\u0026gt;\n  \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;printf\u0026lt;/span\u0026gt;(\u0026quot;%i\\n\u0026quot;, sizeof(array));  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// always prints 4 on a 32-bit machine\u0026lt;/span\u0026gt;\n}\n\nint \u0026lt;span class=\u0026quot;hljs-selector-tag\u0026quot;\u0026gt;main\u0026lt;/span\u0026gt; (int argc, char **argv) {\n    int \u0026lt;span class=\u0026quot;hljs-selector-tag\u0026quot;\u0026gt;a\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-selector-attr\u0026quot;\u0026gt;[10]\u0026lt;/span\u0026gt;;\n    int \u0026lt;span class=\u0026quot;hljs-selector-tag\u0026quot;\u0026gt;b\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-selector-attr\u0026quot;\u0026gt;[20]\u0026lt;/span\u0026gt;;\n    int *c;\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;printf\u0026lt;/span\u0026gt;(\u0026quot;%zu\\n\u0026quot;, sizeof(a)); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//prints 40 on a 32-bit machine\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;printf\u0026lt;/span\u0026gt;(\u0026quot;%zu\\n\u0026quot;, sizeof(b)); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//prints 80 on a 32-bit machine\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;printf\u0026lt;/span\u0026gt;(\u0026quot;%zu\\n\u0026quot;, sizeof(c)); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//prints 4 on a 32-bit machine\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;do_something\u0026lt;/span\u0026gt;(a);\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;do_something\u0026lt;/span\u0026gt;(b);\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;do_something\u0026lt;/span\u0026gt;(c);\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;There are two complications or exceptions to the above.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;First, when dealing with multidimensional arrays in C and C++, only the first dimension is lost.  This is because arrays are layed out contiguously in memory, so the compiler must know all but the first dimension to be able to calculate offsets into that block of memory.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;default s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-scss\u0026quot;\u0026gt;void \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;do_something\u0026lt;/span\u0026gt;(int array[][\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;10\u0026lt;/span\u0026gt;])\n{\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// We don\u0026apos;t know how big the first dimension is.\u0026lt;/span\u0026gt;\n}\n\nint \u0026lt;span class=\u0026quot;hljs-selector-tag\u0026quot;\u0026gt;main\u0026lt;/span\u0026gt;(int argc, char *argv[]) {\n    int \u0026lt;span class=\u0026quot;hljs-selector-tag\u0026quot;\u0026gt;a\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-selector-attr\u0026quot;\u0026gt;[5]\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-selector-attr\u0026quot;\u0026gt;[10]\u0026lt;/span\u0026gt;;\n    int \u0026lt;span class=\u0026quot;hljs-selector-tag\u0026quot;\u0026gt;b\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-selector-attr\u0026quot;\u0026gt;[20]\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-selector-attr\u0026quot;\u0026gt;[10]\u0026lt;/span\u0026gt;;\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;do_something\u0026lt;/span\u0026gt;(a);\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;do_something\u0026lt;/span\u0026gt;(b);\n    return \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Second, in C++, you can use templates to deduce the size of arrays.  Microsoft uses this for the C++ versions of Secure CRT functions like \u0026lt;a href=\u0026quot;http://msdn.microsoft.com/en-us/library/td1esda9%28VS.80%29.aspx\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;strcpy_s\u0026lt;/a\u0026gt;, and you can use a similar trick to reliably \u0026lt;a href=\u0026quot;https://stackoverflow.com/questions/469696/what-is-your-most-useful-c-c-snippet/470221#470221\u0026quot;\u0026gt;get the number of elements in an array\u0026lt;/a\u0026gt;.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;h3\u0026gt;tl;dr: When you use an array you\u0026apos;ve defined, you\u0026apos;ll actually be using a pointer to its first element.\u0026lt;/h3\u0026gt;\n\u0026lt;p\u0026gt;Thus:\u0026lt;/p\u0026gt;\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;When you write \u0026lt;code\u0026gt;arr[idx]\u0026lt;/code\u0026gt; you\u0026apos;re really just saying \u0026lt;code\u0026gt;*(arr + idx)\u0026lt;/code\u0026gt;.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;functions never really take arrays as parameters, only pointers - either directly, when you specify an array parameter, or indirectly, if you pass a reference to an array.\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;p\u0026gt;Sort-of exceptions to this rule:\u0026lt;/p\u0026gt;\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;You can pass fixed-length arrays to functions within a \u0026lt;code\u0026gt;struct\u0026lt;/code\u0026gt;.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;code\u0026gt;sizeof()\u0026lt;/code\u0026gt; gives the size taken up by the array, not the size of a pointer.\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Arrays are automatically passed by pointer in C. \u0026lt;a href=\u0026quot;https://stackoverflow.com/a/671348/7194773\u0026quot;\u0026gt;The rationale behind it can only be speculated\u0026lt;/a\u0026gt;.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;code\u0026gt;int a[5]\u0026lt;/code\u0026gt;, \u0026lt;code\u0026gt;int *a\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;int (*a)[5]\u0026lt;/code\u0026gt; are all glorified addresses meaning that the compiler treats arithmetic and deference operators on them differently depending on the type, so when they refer to the same address they are not treated the same by the compiler. \u0026lt;code\u0026gt;int a[5]\u0026lt;/code\u0026gt; is different to the other 2 in that the address is implicit and does not manifest on the stack or the executable as part of the array itself, it is only used by the compiler to resolve certain arithmetic operations, like taking its address or pointer arithmetic. \u0026lt;code\u0026gt;int a[5]\u0026lt;/code\u0026gt; is therefore an array as well as an implicit address, but as soon as you talk about the address itself and place it on the stack, the address itself is no longer an array, and can only be a pointer to an array or a decayed array i.e. a pointer to the first member of the array.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;For instance, on \u0026lt;code\u0026gt;int (*a)[5]\u0026lt;/code\u0026gt;, the first dereference on \u0026lt;code\u0026gt;a\u0026lt;/code\u0026gt; will produce an \u0026lt;code\u0026gt;int *\u0026lt;/code\u0026gt; (so the same address, just a different type, and note not \u0026lt;code\u0026gt;int a[5]\u0026lt;/code\u0026gt;), and pointer arithmetic on \u0026lt;code\u0026gt;a\u0026lt;/code\u0026gt; i.e. \u0026lt;code\u0026gt;a+1\u0026lt;/code\u0026gt; or \u0026lt;code\u0026gt;*(a+1)\u0026lt;/code\u0026gt; will be in terms of the size of an array of 5 ints (which is the data type it points to), and the second dereference will produce the \u0026lt;code\u0026gt;int\u0026lt;/code\u0026gt;. On \u0026lt;code\u0026gt;int a[5]\u0026lt;/code\u0026gt; however, the first dereference will produce the \u0026lt;code\u0026gt;int\u0026lt;/code\u0026gt; and the pointer arithmetic will be in terms of the size of an \u0026lt;code\u0026gt;int\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;To a function, you can only pass \u0026lt;code\u0026gt;int *\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;int (*)[5]\u0026lt;/code\u0026gt;, and the function casts it to whatever the parameter type is, so within the function you have a choice whether to treat an address that is being passed as a decayed array or a pointer to an array (where the function has to specify the size of the array being passed). If you pass \u0026lt;code\u0026gt;a\u0026lt;/code\u0026gt; to a function and \u0026lt;code\u0026gt;a\u0026lt;/code\u0026gt; is defined \u0026lt;code\u0026gt;int a[5]\u0026lt;/code\u0026gt;, then as \u0026lt;code\u0026gt;a\u0026lt;/code\u0026gt; resolves to an address, you are passing an address, and an address can only be a pointer type. In the function, the parameter it accesses is then an address on the stack or in a register, which can only be a pointer type and not an array type -- this is because it\u0026apos;s an actual address on the stack and is therefore clearly not the array itself.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;You lose the size of the array because the type of the parameter, being an address, is a pointer and not an array, which does not have an array size, as can be seen when using \u0026lt;code\u0026gt;sizeof\u0026lt;/code\u0026gt;, which works on the type of the value being passed to it. The parameter type \u0026lt;code\u0026gt;int a[5]\u0026lt;/code\u0026gt; instead of \u0026lt;code\u0026gt;int *a\u0026lt;/code\u0026gt; is allowed but is treated as \u0026lt;code\u0026gt;int *\u0026lt;/code\u0026gt; instead of disallowing it outright, though it should be disallowed, because it is misleading, because it makes you think that the size information can be used, but you can only do this by casting it to \u0026lt;code\u0026gt;int (*a)[5]\u0026lt;/code\u0026gt;, and of course, the function has to specify the size of the array because there is no way to pass the size of the array because the size of the array needs to be a compile-time constant.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;I might be so bold to think there are four (4) ways to pass an array as the function argument. Also here is the short but working code for your perusal.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;iostream\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;string\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;vector\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;cassert\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;using\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;namespace\u0026lt;/span\u0026gt; std;\n\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// test data\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// notice native array init with no copy aka \u0026quot;=\u0026quot;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// not possible in C\u0026lt;/span\u0026gt;\n \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt;* specimen[]{ __TIME__, __DATE__, __TIMESTAMP__ };\n\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// ONE\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// simple, dangerous and useless\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; T\u0026amp;gt;\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;as_pointer\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; T* array)\u0026lt;/span\u0026gt; \u0026lt;/span\u0026gt;{ \n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// a pointer\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;assert\u0026lt;/span\u0026gt;(array != \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;nullptr\u0026lt;/span\u0026gt;); \n} ;\n\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// TWO\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// for above const T array[] means the same\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// but and also , minimum array size indication might be given too\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// this also does not stop the array decay into T *\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// thus size information is lost\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; T\u0026amp;gt;\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;by_value_no_size\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; T array[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0xFF\u0026lt;/span\u0026gt;])\u0026lt;/span\u0026gt; \u0026lt;/span\u0026gt;{ \n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// decayed to a pointer\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;assert\u0026lt;/span\u0026gt;( array != \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;nullptr\u0026lt;/span\u0026gt; ); \n}\n\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// THREE\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// size information is preserved\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// but pointer is asked for\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; T, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;size_t\u0026lt;/span\u0026gt; N\u0026amp;gt;\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;pointer_to_array\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; T (*array)[N])\u0026lt;/span\u0026gt;\n\u0026lt;/span\u0026gt;{\n   \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// dealing with native pointer \u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;assert\u0026lt;/span\u0026gt;( array != \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;nullptr\u0026lt;/span\u0026gt; ); \n}\n\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// FOUR\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// no C equivalent\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// array by reference\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// size is preserved\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typename\u0026lt;/span\u0026gt; T, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;size_t\u0026lt;/span\u0026gt; N\u0026amp;gt;\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;reference_to_array\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; T (\u0026amp;amp;array)[N])\u0026lt;/span\u0026gt;\n\u0026lt;/span\u0026gt;{\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// array is not a pointer here\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// it is (almost) a container\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// most of the std:: lib algorithms \u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// do work on array reference, for example\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// range for requires std::begin() and std::end()\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// on the type passed as range to iterate over\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt; (\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;auto\u0026lt;/span\u0026gt; \u0026amp;amp;\u0026amp;amp; elem : array )\n    {\n        cout \u0026amp;lt;\u0026amp;lt; endl \u0026amp;lt;\u0026amp;lt; elem ;\n    }\n}\n\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;main\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt;\n\u0026lt;/span\u0026gt;{\n     \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// ONE\u0026lt;/span\u0026gt;\n     \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;as_pointer\u0026lt;/span\u0026gt;(specimen);\n     \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// TWO\u0026lt;/span\u0026gt;\n     \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;by_value_no_size\u0026lt;/span\u0026gt;(specimen);\n     \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// THREE\u0026lt;/span\u0026gt;\n     \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;pointer_to_array\u0026lt;/span\u0026gt;(\u0026amp;amp;specimen);\n     \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// FOUR\u0026lt;/span\u0026gt;\n     \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;reference_to_array\u0026lt;/span\u0026gt;( specimen ) ;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;I might also think this shows the superiority of C++ vs C. At least in reference (pun intended) of passing an array by reference.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Of course there are extremely strict projects with no heap allocation, no exceptions and no std:: lib. C++ native array handling is mission critical language feature, one might say.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Try this code\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;default s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-csharp\u0026quot;\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;f\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;double\u0026lt;/span\u0026gt; a[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;10\u0026lt;/span\u0026gt;]\u0026lt;/span\u0026gt;)\u0026lt;/span\u0026gt; {\n    printf(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;in function: %d\u0026quot;\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;sizeof\u0026lt;/span\u0026gt;(a));\n    printf(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;pointer size: %d\\n\u0026quot;\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;sizeof\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;double\u0026lt;/span\u0026gt; *));\n}\n\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;main\u0026lt;/span\u0026gt;()\u0026lt;/span\u0026gt; {\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;double\u0026lt;/span\u0026gt; a[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;10\u0026lt;/span\u0026gt;];\n    printf(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;in main: %d\u0026quot;\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;sizeof\u0026lt;/span\u0026gt;(a));\n    f(a);\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;and you will see that the size of the array inside the function is not equal to the size of the array in main, but it is equal to the size of a pointer.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;You probably heard that \u0026quot;arrays are pointers\u0026quot;, but, this is not exactly true (the \u0026lt;code\u0026gt;sizeof\u0026lt;/code\u0026gt; inside \u0026lt;code\u0026gt;main\u0026lt;/code\u0026gt; prints the correct size). However, when passed, the array \u0026lt;em\u0026gt;decays\u0026lt;/em\u0026gt; to pointer. That is, regardless of what the syntax shows, you actually pass a pointer, and the function actually receives a pointer.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;In this case, the definition \u0026lt;code\u0026gt;void f(double a[10]\u0026lt;/code\u0026gt; is implicitly transformed by the compiler to \u0026lt;code\u0026gt;void f(double *a)\u0026lt;/code\u0026gt;. You could have equivalently declared the function argument directly as \u0026lt;code\u0026gt;*a\u0026lt;/code\u0026gt;. You could have even written \u0026lt;code\u0026gt;a[100]\u0026lt;/code\u0026gt; or \u0026lt;code\u0026gt;a[1]\u0026lt;/code\u0026gt;, instead of \u0026lt;code\u0026gt;a[10]\u0026lt;/code\u0026gt;, since it is never actually compiled that way (however, you shouldn\u0026apos;t do it obviously, it would confuse the reader).\u0026lt;/p\u0026gt;\n    "],"id":129,"title":"What is array to pointer decay?","content":"\n                \n\u0026lt;p\u0026gt;What is array to pointer decay? Is there any relation to array pointers?\u0026lt;/p\u0026gt;\n    ","slug":"what-is-array-to-pointer-decay-1657384709608","postType":"QUESTION","createdAt":"2022-07-09T16:38:29.000Z","updatedAt":"2022-07-09T16:38:29.000Z","tags":[{"id":471,"name":"pointers","slug":"pointers","createdAt":"2022-07-09T16:38:29.000Z","updatedAt":"2022-07-09T16:38:29.000Z","Questions_Tags":{"questionId":129,"tagId":471}}],"relatedQuestions":[{"title":"What is array to pointer decay?","slug":"what-is-array-to-pointer-decay-1657384709608","tags":[{"name":"pointers","Questions_Tags":{"questionId":129,"tagId":471}}]}]},"randomQuestions":[{"title":"What's the simplest way to print a Java array?","slug":"what's-the-simplest-way-to-print-a-java-array-1657384702397"},{"title":"In CSS Flexbox, why are there no \"justify-items\" and \"justify-self\" properties?","slug":"in-css-flexbox-why-are-there-no-\"justify-items\"-and-\"justify-self\"-properties-1657384782711"},{"title":"MySQL pivot row into dynamic number of columns","slug":"mysql-pivot-row-into-dynamic-number-of-columns-1657387981930"},{"title":"How to make a div 100% height of the browser window","slug":"how-to-make-a-div-100percent-height-of-the-browser-window-1657388265955"},{"title":"UnboundLocalError on local variable when reassigned after first use","slug":"unboundlocalerror-on-local-variable-when-reassigned-after-first-use-1657387685248"},{"title":"What is PECS (Producer Extends Consumer Super)?","slug":"what-is-pecs-(producer-extends-consumer-super)-1657384828870"},{"title":"What is the difference between client-side and server-side programming?","slug":"what-is-the-difference-between-client-side-and-server-side-programming-1657384372926"},{"title":"How can I pivot a dataframe?","slug":"how-can-i-pivot-a-dataframe-1657384433802"},{"title":"Are 'Arrow Functions' and 'Functions' equivalent / interchangeable?","slug":"are-'arrow-functions'-and-'functions'-equivalent-interchangeable-1657384527873"},{"title":"What does enctype='multipart/form-data' mean?","slug":"what-does-enctype'multipartform-data'-mean-1657388229352"},{"title":"Get the row(s) which have the max value in groups using groupby","slug":"get-the-row(s)-which-have-the-max-value-in-groups-using-groupby-1657388014787"},{"title":"Selenium \"selenium.common.exceptions.NoSuchElementException\" when using Chrome","slug":"selenium-\"selenium.common.exceptions.nosuchelementexception\"-when-using-chrome-1657388136699"},{"title":"$(document).ready equivalent without jQuery","slug":"dollar(document).ready-equivalent-without-jquery-1657388504115"},{"title":"Official locator strategies for the webdriver","slug":"official-locator-strategies-for-the-webdriver-1657384353174"},{"title":"Converting string into datetime","slug":"converting-string-into-datetime-1657387717295"},{"title":"How does JavaScript .prototype work?","slug":"how-does-javascript-.prototype-work-1657388169270"},{"title":"What does a space mean in a CSS selector? i.e. What is the difference between .classA.classB and .classA .classB?","slug":"what-does-a-space-mean-in-a-css-selector-i.e.-what-is-the-difference-between-.classa.classb-and-.classa-.classb-1657387912095"},{"title":"Where and why do I have to put the \"template\" and \"typename\" keywords?","slug":"where-and-why-do-i-have-to-put-the-\"template\"-and-\"typename\"-keywords-1657384467606"},{"title":"Where do I find the current C or C++ standard documents?","slug":"where-do-i-find-the-current-c-or-c++-standard-documents-1657388006897"},{"title":"How to generate a self-signed SSL certificate using OpenSSL? [closed]","slug":"how-to-generate-a-self-signed-ssl-certificate-using-openssl-closed-1657388298626"}]},"__N_SSG":true},"page":"/questions/[slug]","query":{"slug":"what-is-array-to-pointer-decay-1657384709608"},"buildId":"Zo3C7AOWQzKM9qqyzx2hf","isFallback":false,"gsp":true,"locale":"en","locales":["en"],"defaultLocale":"en","scriptLoader":[]}</script></body></html>