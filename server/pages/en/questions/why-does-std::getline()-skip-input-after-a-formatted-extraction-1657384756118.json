{"pageProps":{"data":{"answer":["\n&lt;h1&gt;Why does this happen?&lt;/h1&gt;\n&lt;p&gt;This has little to do with the input you provided yourself but rather with the default behavior &lt;code&gt;std::getline()&lt;/code&gt; has. When you provided your input for the age (&lt;code&gt;std::cin &amp;gt;&amp;gt; age&lt;/code&gt;), you not only submitted the following characters, but also an implicit newline was appended to the stream when you typed &lt;kbd&gt;Enter&lt;/kbd&gt;:&lt;/p&gt;\n&lt;blockquote&gt;\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-string&quot;&gt;&quot;10\\n&quot;&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;/blockquote&gt;\n&lt;p&gt;A newline is always appended to your input when you select &lt;kbd&gt;Enter&lt;/kbd&gt; or &lt;kbd&gt;Return&lt;/kbd&gt; when submitting from a terminal. It is also used in files for moving toward the next line. The newline is left in the buffer after the extraction into &lt;code&gt;age&lt;/code&gt; until the next I/O operation where it is either discarded or read. When the flow of control reaches &lt;code&gt;std::getline()&lt;/code&gt;, it will see &lt;code&gt;&quot;\\nMr. Whiskers&quot;&lt;/code&gt; and the newline at the beginning will be discarded, but the input operation will stop immediately. The reason this happens is because the job of &lt;code&gt;std::getline()&lt;/code&gt; is to attempt to read characters and stop when it finds a newline. So the rest of your input is left in the buffer unread.&lt;/p&gt;\n&lt;h1&gt;Solution&lt;/h1&gt;\n&lt;h2&gt;&lt;code&gt;cin.ignore()&lt;/code&gt;&lt;/h2&gt;\n&lt;p&gt;To fix this, one option is to skip over the newline before doing &lt;code&gt;std::getline()&lt;/code&gt;. You can do this by calling &lt;code&gt;std::cin.ignore()&lt;/code&gt; after the first input operation. It will discard the next character (the newline character) so that it is no longer in the way.&lt;/p&gt;\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;std::cin &amp;gt;&amp;gt; age;\nstd::cin.&lt;span class=&quot;hljs-built_in&quot;&gt;ignore&lt;/span&gt;();\nstd::&lt;span class=&quot;hljs-built_in&quot;&gt;getline&lt;/span&gt;(std::cin, name);\n\n&lt;span class=&quot;hljs-built_in&quot;&gt;assert&lt;/span&gt;(std::cin); \n&lt;span class=&quot;hljs-comment&quot;&gt;// Success!&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2&gt;&lt;code&gt;std::ws&lt;/code&gt;&lt;/h2&gt;\n&lt;p&gt;Another way to discard the whitespace is to use the &lt;code&gt;std::ws&lt;/code&gt; function which is a manipulator designed to extract and discard leading whitespace from the beginning of an input stream:&lt;/p&gt;\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;std::cin &amp;gt;&amp;gt; age;\nstd::&lt;span class=&quot;hljs-built_in&quot;&gt;getline&lt;/span&gt;(std::cin &amp;gt;&amp;gt; std::ws, name);\n\n&lt;span class=&quot;hljs-built_in&quot;&gt;assert&lt;/span&gt;(std::cin);\n&lt;span class=&quot;hljs-comment&quot;&gt;// Success!&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;The &lt;code&gt;std::cin &amp;gt;&amp;gt; std::ws&lt;/code&gt; expression is executed before the &lt;code&gt;std::getline()&lt;/code&gt; call (and after the &lt;code&gt;std::cin &amp;gt;&amp;gt; age&lt;/code&gt; call) so that the newline character is removed.&lt;/p&gt;\n&lt;p&gt;The difference is that &lt;code&gt;ignore()&lt;/code&gt; discards only 1 character (or N characters when given a parameter), and &lt;code&gt;std::ws&lt;/code&gt; continues to ignore whitespace until it finds a non-whitespace character. So if you don&apos;t know how much whitespace will precede the next token you should consider using this.&lt;/p&gt;\n&lt;h2&gt;Match the operations&lt;/h2&gt;\n&lt;p&gt;When you run into an issue like this it&apos;s usually because you&apos;re combining formatted input operations with unformatted input operations. A formatted input operation is when you take input and format it for a certain type. That&apos;s what &lt;code&gt;operator&amp;gt;&amp;gt;()&lt;/code&gt; is for. Unformatted input operations are anything other than that, like &lt;code&gt;std::getline()&lt;/code&gt;, &lt;code&gt;std::cin.read()&lt;/code&gt;, &lt;code&gt;std::cin.get()&lt;/code&gt;, etc. Those functions don&apos;t care about the format of the input and only process raw text.&lt;/p&gt;\n&lt;p&gt;If you stick to using a single type of formatting then you can avoid this annoying issue:&lt;/p&gt;\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-comment&quot;&gt;// Unformatted I/O&lt;/span&gt;\nstd::string age, name;\nstd::&lt;span class=&quot;hljs-built_in&quot;&gt;getline&lt;/span&gt;(std::cin, age);\nstd::&lt;span class=&quot;hljs-built_in&quot;&gt;getline&lt;/span&gt;(std::cin, name);\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;or&lt;/p&gt;\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-comment&quot;&gt;// Formatted I/O&lt;/span&gt;\n&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; age;\nstd::string firstName, lastName;\nstd::cin &amp;gt;&amp;gt; age &amp;gt;&amp;gt; firstName &amp;gt;&amp;gt; lastName;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;If you choose to read everything as strings using the unformatted operations you can convert them into the appropriate types afterwards.&lt;/p&gt;\n    ","\n&lt;p&gt;Everything will be OK if you change your initial code in the following way:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; ((cin &amp;gt;&amp;gt; name).&lt;span class=&quot;hljs-built_in&quot;&gt;get&lt;/span&gt;() &amp;amp;&amp;amp; std::&lt;span class=&quot;hljs-built_in&quot;&gt;getline&lt;/span&gt;(cin, state))\n&lt;/code&gt;&lt;/pre&gt;\n    ","\n&lt;p&gt;This happens because an implicit line feed also known as newline character &lt;code&gt;\\n&lt;/code&gt; is appended to all user input from a terminal as it&apos;s telling the stream to start a new line. You can safely account for this by using &lt;a href=&quot;http://en.cppreference.com/w/cpp/string/basic_string/getline&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;code&gt;std::getline&lt;/code&gt;&lt;/a&gt; when checking for multiple lines of user input. The default behavior of &lt;code&gt;std::getline&lt;/code&gt; will read everything up to and including the newline character &lt;code&gt;\\n&lt;/code&gt; from the input stream object which is &lt;code&gt;std::cin&lt;/code&gt; in this case.&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&amp;lt;string&amp;gt;&lt;/span&gt;&lt;/span&gt;\n\n&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt;\n&lt;/span&gt;{\n    std::string name;\n    std::string state;\n\n    &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (std::&lt;span class=&quot;hljs-built_in&quot;&gt;getline&lt;/span&gt;(std::cin, name) &amp;amp;&amp;amp; std::&lt;span class=&quot;hljs-built_in&quot;&gt;getline&lt;/span&gt;(std::cin, state))\n    {\n        std::cout &amp;lt;&amp;lt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;Your name is &quot;&lt;/span&gt; &amp;lt;&amp;lt; name &amp;lt;&amp;lt; &lt;span class=&quot;hljs-string&quot;&gt;&quot; and you live in &quot;&lt;/span&gt; &amp;lt;&amp;lt; state;\n    }\n    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;;\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;blockquote&gt;\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;Input:\n\n&lt;span class=&quot;hljs-string&quot;&gt;&quot;John&quot;&lt;/span&gt;\n&lt;span class=&quot;hljs-string&quot;&gt;&quot;New Hampshire&quot;&lt;/span&gt;\n\nOutput:\n\n&lt;span class=&quot;hljs-string&quot;&gt;&quot;Your name is John and you live in New Hampshire&quot;&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;/blockquote&gt;\n    ","\n&lt;p&gt;Since everyone above has answered the problem for input &lt;code&gt;10\\nMr Whisker\\n&lt;/code&gt;, I would like to answer a different approach. all the solution above published the code for if the buffer is like &lt;code&gt;10\\nMr Whisker\\n&lt;/code&gt;. but what if we don&apos;t know how user will behave giving input. the user might type &lt;code&gt;10\\n\\nMr. Whisker\\n&lt;/code&gt; or &lt;code&gt;10 \\n\\n Mr. whisker\\n&lt;/code&gt; by mistake. in that case, codes above may not work. so, I use the function below to take string input to address the problem.&lt;/p&gt;\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;string &lt;span class=&quot;hljs-title&quot;&gt;StringInput&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt;  &lt;span class=&quot;hljs-comment&quot;&gt;//returns null-terminated string&lt;/span&gt;\n&lt;/span&gt;{\n    string input;\n    &lt;span class=&quot;hljs-built_in&quot;&gt;getline&lt;/span&gt;(cin, input);\n    &lt;span class=&quot;hljs-keyword&quot;&gt;while&lt;/span&gt;(input.&lt;span class=&quot;hljs-built_in&quot;&gt;length&lt;/span&gt;()==&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;)&lt;span class=&quot;hljs-comment&quot;&gt;//keep taking input until valid string is taken&lt;/span&gt;\n    {\n        &lt;span class=&quot;hljs-built_in&quot;&gt;getline&lt;/span&gt;(cin, input);\n    }\n    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; input.&lt;span class=&quot;hljs-built_in&quot;&gt;c_str&lt;/span&gt;();\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;So, the answer would be:&lt;/p&gt;\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&amp;lt;string&amp;gt;&lt;/span&gt;&lt;/span&gt;\n\n&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt;\n&lt;/span&gt;{\n    &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; age;\n    std::string name;\n\n    std::cin &amp;gt;&amp;gt; age;\n    name = &lt;span class=&quot;hljs-built_in&quot;&gt;StringInput&lt;/span&gt;();\n    \n    std::cout &amp;lt;&amp;lt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;My cat is &quot;&lt;/span&gt; &amp;lt;&amp;lt; age &amp;lt;&amp;lt; &lt;span class=&quot;hljs-string&quot;&gt;&quot; years old and their name is &quot;&lt;/span&gt; &amp;lt;&amp;lt; name &amp;lt;&amp;lt; std::endl;\n    \n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;&lt;strong&gt;Extra:&lt;/strong&gt;&lt;/p&gt;\n&lt;p&gt;If user inputs &lt;code&gt;a \\n10\\n \\nmr. whiskey&lt;/code&gt;;\nTo check whether &lt;code&gt;int&lt;/code&gt; input is valid or not, this function can be used to check &lt;code&gt;int&lt;/code&gt; input (program will have undefined behavior if &lt;code&gt;char&lt;/code&gt; is given as input instead of &lt;code&gt;int&lt;/code&gt;):&lt;/p&gt;\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;\n&lt;span class=&quot;hljs-comment&quot;&gt;//instead of &quot;std::cin&amp;gt;&amp;gt;age;&quot; use &quot;get_untill_int(&amp;amp;age);&quot; in main function.&lt;/span&gt;\n&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;get_Untill_Int&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt;* pInput)&lt;/span&gt;&lt;span class=&quot;hljs-comment&quot;&gt;//keep taking input untill input is `int or float`&lt;/span&gt;\n&lt;/span&gt;{\n    cin&amp;gt;&amp;gt; *pInput;\n    &lt;span class=&quot;hljs-comment&quot;&gt;/*-----------check input validation----------------*/&lt;/span&gt;\n    &lt;span class=&quot;hljs-keyword&quot;&gt;while&lt;/span&gt; (!cin) \n    {\n        cin.&lt;span class=&quot;hljs-built_in&quot;&gt;clear&lt;/span&gt;();\n        cin.&lt;span class=&quot;hljs-built_in&quot;&gt;ignore&lt;/span&gt;(&lt;span class=&quot;hljs-number&quot;&gt;100&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&apos;\\n&apos;&lt;/span&gt;);\n        cout&amp;lt;&amp;lt;&lt;span class=&quot;hljs-string&quot;&gt;&quot;Invalid Input Type.\\nEnter again: &quot;&lt;/span&gt;;\n        cin &amp;gt;&amp;gt;*pInput;\n    }\n    &lt;span class=&quot;hljs-comment&quot;&gt;/*-----------checked input validation-------------*/&lt;/span&gt;\n}\n&lt;/code&gt;&lt;/pre&gt;\n    ","\n&lt;p&gt;I am really wondering. C++ has a dedicated function for eating up any remaining or whatever white spaces. It is called &lt;a href=&quot;https://en.cppreference.com/w/cpp/io/manip/ws&quot; rel=&quot;nofollow noreferrer&quot;&gt;std::ws&lt;/a&gt;. And then, you can simply use&lt;/p&gt;\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;std::&lt;span class=&quot;hljs-built_in&quot;&gt;getline&lt;/span&gt;(std::cin &amp;gt;&amp;gt; std::ws, name);\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;That should be the idomatic approach. For each transistion between formatted to unformatted input that should be used.&lt;/p&gt;\n&lt;p&gt;If we are not talking about white spaces, but entering for example letters where a number is expected, then we should follow the CPP reference and use&lt;/p&gt;\n&lt;p&gt;&lt;code&gt;.ignore(std::numeric_limits&amp;lt;std::streamsize&amp;gt;::max(), &apos;\\n&apos;);&lt;/code&gt; to eliminate the wrong stuff.&lt;/p&gt;\n&lt;p&gt;Please read &lt;a href=&quot;https://en.cppreference.com/w/cpp/io/basic_istream/ignore&quot; rel=&quot;nofollow noreferrer&quot;&gt;here&lt;/a&gt;&lt;/p&gt;\n    "],"id":145,"title":"Why does std::getline() skip input after a formatted extraction?","content":"\n                \n&lt;p&gt;I have the following piece of code that prompts the user for their cat&apos;s age and name:&lt;/p&gt;\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&amp;lt;string&amp;gt;&lt;/span&gt;&lt;/span&gt;\n\n&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt;\n&lt;/span&gt;{\n    &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; age;\n    std::string name;\n\n    std::cin &amp;gt;&amp;gt; age;\n    std::&lt;span class=&quot;hljs-built_in&quot;&gt;getline&lt;/span&gt;(std::cin, name);\n    \n    &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (std::cin)\n    {\n        std::cout &amp;lt;&amp;lt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;My cat is &quot;&lt;/span&gt; &amp;lt;&amp;lt; age &amp;lt;&amp;lt; &lt;span class=&quot;hljs-string&quot;&gt;&quot; years old and their name is &quot;&lt;/span&gt; &amp;lt;&amp;lt; name &amp;lt;&amp;lt; std::endl;\n    }\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;What I find is that the age has been successfully read, but not the name. Here is the input and output:&lt;/p&gt;\n&lt;blockquote&gt;\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;Input:\n\n&lt;span class=&quot;hljs-string&quot;&gt;&quot;10&quot;&lt;/span&gt;\n&lt;span class=&quot;hljs-string&quot;&gt;&quot;Mr. Whiskers&quot;&lt;/span&gt;\n\nOutput:\n\n&lt;span class=&quot;hljs-string&quot;&gt;&quot;My cat is 10 years old and their name is &quot;&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;/blockquote&gt;\n&lt;p&gt;Why has the name been omitted from the output? I&apos;ve given the proper input, but the code somehow ignores it. Why does this happen?&lt;/p&gt;\n    ","slug":"why-does-std::getline()-skip-input-after-a-formatted-extraction-1657384756118","postType":"QUESTION","createdAt":"2022-07-09T16:39:16.000Z","updatedAt":"2022-07-09T16:39:16.000Z","tags":[{"id":528,"name":"istream","slug":"istream","createdAt":"2022-07-09T16:39:16.000Z","updatedAt":"2022-07-09T16:39:16.000Z","Questions_Tags":{"questionId":145,"tagId":528}}],"relatedQuestions":[{"title":"Why does std::getline() skip input after a formatted extraction?","slug":"why-does-std::getline()-skip-input-after-a-formatted-extraction-1657384756118","tags":[{"name":"istream","Questions_Tags":{"questionId":145,"tagId":528}}]}]},"randomQuestions":[{"title":"mysqli or die, does it have to die?","slug":"mysqli-or-die-does-it-have-to-die-1657388533922"},{"title":"Is there a \"previous sibling\" selector?","slug":"is-there-a-\"previous-sibling\"-selector-1657384771067"},{"title":"Why is \"using namespace std;\" considered bad practice?","slug":"why-is-\"using-namespace-std\"-considered-bad-practice-1657384296377"},{"title":"Why do I need to override the equals and hashCode methods in Java?","slug":"why-do-i-need-to-override-the-equals-and-hashcode-methods-in-java-1657388359877"},{"title":"jQuery Ajax POST example with PHP","slug":"jquery-ajax-post-example-with-php-1657387402634"},{"title":"Sorting object property by values","slug":"sorting-object-property-by-values-1657388367300"},{"title":"What Is Selenium And What Is WebDriver?","slug":"what-is-selenium-and-what-is-webdriver-1657385470372"},{"title":"How can I pivot a dataframe?","slug":"how-can-i-pivot-a-dataframe-1657384433802"},{"title":"Convert one date format into another in PHP","slug":"convert-one-date-format-into-another-in-php-1657384566234"},{"title":"How do I execute a program or call a system command?","slug":"how-do-i-execute-a-program-or-call-a-system-command-1657385465629"},{"title":"How does the Java 'for each' loop work?","slug":"how-does-the-java-'for-each'-loop-work-1657388423749"},{"title":"Firebase query if child of child contains a value","slug":"firebase-query-if-child-of-child-contains-a-value-1657387841291"},{"title":"Error: could not find function ... in R","slug":"error:-could-not-find-function-...-in-r-1657388476492"},{"title":"How do I check if an array includes a value in JavaScript?","slug":"how-do-i-check-if-an-array-includes-a-value-in-javascript-1657387421185"},{"title":"How to return value from an asynchronous callback function? [duplicate]","slug":"how-to-return-value-from-an-asynchronous-callback-function-duplicate-1657387545611"},{"title":"What is a clearfix?","slug":"what-is-a-clearfix-1657387337825"},{"title":"Passing data between view controllers","slug":"passing-data-between-view-controllers-1657384540021"},{"title":"What is the copy-and-swap idiom?","slug":"what-is-the-copy-and-swap-idiom-1657384840329"},{"title":"Is there any way to kill a Thread?","slug":"is-there-any-way-to-kill-a-thread-1657387859831"},{"title":"Are global variables thread-safe in Flask? How do I share data between requests?","slug":"are-global-variables-thread-safe-in-flask-how-do-i-share-data-between-requests-1657387949951"}]},"__N_SSG":true}