{"pageProps":{"data":{"answer":["\n&lt;h1&gt;Why does this happen?&lt;/h1&gt;\n&lt;p&gt;This has little to do with the input you provided yourself but rather with the default behavior &lt;code&gt;std::getline()&lt;/code&gt; has. When you provided your input for the age (&lt;code&gt;std::cin &amp;gt;&amp;gt; age&lt;/code&gt;), you not only submitted the following characters, but also an implicit newline was appended to the stream when you typed &lt;kbd&gt;Enter&lt;/kbd&gt;:&lt;/p&gt;\n&lt;blockquote&gt;\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-string&quot;&gt;&quot;10\\n&quot;&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;/blockquote&gt;\n&lt;p&gt;A newline is always appended to your input when you select &lt;kbd&gt;Enter&lt;/kbd&gt; or &lt;kbd&gt;Return&lt;/kbd&gt; when submitting from a terminal. It is also used in files for moving toward the next line. The newline is left in the buffer after the extraction into &lt;code&gt;age&lt;/code&gt; until the next I/O operation where it is either discarded or read. When the flow of control reaches &lt;code&gt;std::getline()&lt;/code&gt;, it will see &lt;code&gt;&quot;\\nMr. Whiskers&quot;&lt;/code&gt; and the newline at the beginning will be discarded, but the input operation will stop immediately. The reason this happens is because the job of &lt;code&gt;std::getline()&lt;/code&gt; is to attempt to read characters and stop when it finds a newline. So the rest of your input is left in the buffer unread.&lt;/p&gt;\n&lt;h1&gt;Solution&lt;/h1&gt;\n&lt;h2&gt;&lt;code&gt;cin.ignore()&lt;/code&gt;&lt;/h2&gt;\n&lt;p&gt;To fix this, one option is to skip over the newline before doing &lt;code&gt;std::getline()&lt;/code&gt;. You can do this by calling &lt;code&gt;std::cin.ignore()&lt;/code&gt; after the first input operation. It will discard the next character (the newline character) so that it is no longer in the way.&lt;/p&gt;\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;std::cin &amp;gt;&amp;gt; age;\nstd::cin.&lt;span class=&quot;hljs-built_in&quot;&gt;ignore&lt;/span&gt;();\nstd::&lt;span class=&quot;hljs-built_in&quot;&gt;getline&lt;/span&gt;(std::cin, name);\n\n&lt;span class=&quot;hljs-built_in&quot;&gt;assert&lt;/span&gt;(std::cin); \n&lt;span class=&quot;hljs-comment&quot;&gt;// Success!&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2&gt;&lt;code&gt;std::ws&lt;/code&gt;&lt;/h2&gt;\n&lt;p&gt;Another way to discard the whitespace is to use the &lt;code&gt;std::ws&lt;/code&gt; function which is a manipulator designed to extract and discard leading whitespace from the beginning of an input stream:&lt;/p&gt;\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;std::cin &amp;gt;&amp;gt; age;\nstd::&lt;span class=&quot;hljs-built_in&quot;&gt;getline&lt;/span&gt;(std::cin &amp;gt;&amp;gt; std::ws, name);\n\n&lt;span class=&quot;hljs-built_in&quot;&gt;assert&lt;/span&gt;(std::cin);\n&lt;span class=&quot;hljs-comment&quot;&gt;// Success!&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;The &lt;code&gt;std::cin &amp;gt;&amp;gt; std::ws&lt;/code&gt; expression is executed before the &lt;code&gt;std::getline()&lt;/code&gt; call (and after the &lt;code&gt;std::cin &amp;gt;&amp;gt; age&lt;/code&gt; call) so that the newline character is removed.&lt;/p&gt;\n&lt;p&gt;The difference is that &lt;code&gt;ignore()&lt;/code&gt; discards only 1 character (or N characters when given a parameter), and &lt;code&gt;std::ws&lt;/code&gt; continues to ignore whitespace until it finds a non-whitespace character. So if you don&apos;t know how much whitespace will precede the next token you should consider using this.&lt;/p&gt;\n&lt;h2&gt;Match the operations&lt;/h2&gt;\n&lt;p&gt;When you run into an issue like this it&apos;s usually because you&apos;re combining formatted input operations with unformatted input operations. A formatted input operation is when you take input and format it for a certain type. That&apos;s what &lt;code&gt;operator&amp;gt;&amp;gt;()&lt;/code&gt; is for. Unformatted input operations are anything other than that, like &lt;code&gt;std::getline()&lt;/code&gt;, &lt;code&gt;std::cin.read()&lt;/code&gt;, &lt;code&gt;std::cin.get()&lt;/code&gt;, etc. Those functions don&apos;t care about the format of the input and only process raw text.&lt;/p&gt;\n&lt;p&gt;If you stick to using a single type of formatting then you can avoid this annoying issue:&lt;/p&gt;\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-comment&quot;&gt;// Unformatted I/O&lt;/span&gt;\nstd::string age, name;\nstd::&lt;span class=&quot;hljs-built_in&quot;&gt;getline&lt;/span&gt;(std::cin, age);\nstd::&lt;span class=&quot;hljs-built_in&quot;&gt;getline&lt;/span&gt;(std::cin, name);\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;or&lt;/p&gt;\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-comment&quot;&gt;// Formatted I/O&lt;/span&gt;\n&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; age;\nstd::string firstName, lastName;\nstd::cin &amp;gt;&amp;gt; age &amp;gt;&amp;gt; firstName &amp;gt;&amp;gt; lastName;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;If you choose to read everything as strings using the unformatted operations you can convert them into the appropriate types afterwards.&lt;/p&gt;\n    ","\n&lt;p&gt;Everything will be OK if you change your initial code in the following way:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; ((cin &amp;gt;&amp;gt; name).&lt;span class=&quot;hljs-built_in&quot;&gt;get&lt;/span&gt;() &amp;amp;&amp;amp; std::&lt;span class=&quot;hljs-built_in&quot;&gt;getline&lt;/span&gt;(cin, state))\n&lt;/code&gt;&lt;/pre&gt;\n    ","\n&lt;p&gt;This happens because an implicit line feed also known as newline character &lt;code&gt;\\n&lt;/code&gt; is appended to all user input from a terminal as it&apos;s telling the stream to start a new line. You can safely account for this by using &lt;a href=&quot;http://en.cppreference.com/w/cpp/string/basic_string/getline&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;code&gt;std::getline&lt;/code&gt;&lt;/a&gt; when checking for multiple lines of user input. The default behavior of &lt;code&gt;std::getline&lt;/code&gt; will read everything up to and including the newline character &lt;code&gt;\\n&lt;/code&gt; from the input stream object which is &lt;code&gt;std::cin&lt;/code&gt; in this case.&lt;/p&gt;\n\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&amp;lt;string&amp;gt;&lt;/span&gt;&lt;/span&gt;\n\n&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt;\n&lt;/span&gt;{\n    std::string name;\n    std::string state;\n\n    &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (std::&lt;span class=&quot;hljs-built_in&quot;&gt;getline&lt;/span&gt;(std::cin, name) &amp;amp;&amp;amp; std::&lt;span class=&quot;hljs-built_in&quot;&gt;getline&lt;/span&gt;(std::cin, state))\n    {\n        std::cout &amp;lt;&amp;lt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;Your name is &quot;&lt;/span&gt; &amp;lt;&amp;lt; name &amp;lt;&amp;lt; &lt;span class=&quot;hljs-string&quot;&gt;&quot; and you live in &quot;&lt;/span&gt; &amp;lt;&amp;lt; state;\n    }\n    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;;\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;blockquote&gt;\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;Input:\n\n&lt;span class=&quot;hljs-string&quot;&gt;&quot;John&quot;&lt;/span&gt;\n&lt;span class=&quot;hljs-string&quot;&gt;&quot;New Hampshire&quot;&lt;/span&gt;\n\nOutput:\n\n&lt;span class=&quot;hljs-string&quot;&gt;&quot;Your name is John and you live in New Hampshire&quot;&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;/blockquote&gt;\n    ","\n&lt;p&gt;Since everyone above has answered the problem for input &lt;code&gt;10\\nMr Whisker\\n&lt;/code&gt;, I would like to answer a different approach. all the solution above published the code for if the buffer is like &lt;code&gt;10\\nMr Whisker\\n&lt;/code&gt;. but what if we don&apos;t know how user will behave giving input. the user might type &lt;code&gt;10\\n\\nMr. Whisker\\n&lt;/code&gt; or &lt;code&gt;10 \\n\\n Mr. whisker\\n&lt;/code&gt; by mistake. in that case, codes above may not work. so, I use the function below to take string input to address the problem.&lt;/p&gt;\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;string &lt;span class=&quot;hljs-title&quot;&gt;StringInput&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt;  &lt;span class=&quot;hljs-comment&quot;&gt;//returns null-terminated string&lt;/span&gt;\n&lt;/span&gt;{\n    string input;\n    &lt;span class=&quot;hljs-built_in&quot;&gt;getline&lt;/span&gt;(cin, input);\n    &lt;span class=&quot;hljs-keyword&quot;&gt;while&lt;/span&gt;(input.&lt;span class=&quot;hljs-built_in&quot;&gt;length&lt;/span&gt;()==&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;)&lt;span class=&quot;hljs-comment&quot;&gt;//keep taking input until valid string is taken&lt;/span&gt;\n    {\n        &lt;span class=&quot;hljs-built_in&quot;&gt;getline&lt;/span&gt;(cin, input);\n    }\n    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; input.&lt;span class=&quot;hljs-built_in&quot;&gt;c_str&lt;/span&gt;();\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;So, the answer would be:&lt;/p&gt;\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&amp;lt;string&amp;gt;&lt;/span&gt;&lt;/span&gt;\n\n&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt;\n&lt;/span&gt;{\n    &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; age;\n    std::string name;\n\n    std::cin &amp;gt;&amp;gt; age;\n    name = &lt;span class=&quot;hljs-built_in&quot;&gt;StringInput&lt;/span&gt;();\n    \n    std::cout &amp;lt;&amp;lt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;My cat is &quot;&lt;/span&gt; &amp;lt;&amp;lt; age &amp;lt;&amp;lt; &lt;span class=&quot;hljs-string&quot;&gt;&quot; years old and their name is &quot;&lt;/span&gt; &amp;lt;&amp;lt; name &amp;lt;&amp;lt; std::endl;\n    \n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;&lt;strong&gt;Extra:&lt;/strong&gt;&lt;/p&gt;\n&lt;p&gt;If user inputs &lt;code&gt;a \\n10\\n \\nmr. whiskey&lt;/code&gt;;\nTo check whether &lt;code&gt;int&lt;/code&gt; input is valid or not, this function can be used to check &lt;code&gt;int&lt;/code&gt; input (program will have undefined behavior if &lt;code&gt;char&lt;/code&gt; is given as input instead of &lt;code&gt;int&lt;/code&gt;):&lt;/p&gt;\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;\n&lt;span class=&quot;hljs-comment&quot;&gt;//instead of &quot;std::cin&amp;gt;&amp;gt;age;&quot; use &quot;get_untill_int(&amp;amp;age);&quot; in main function.&lt;/span&gt;\n&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;get_Untill_Int&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt;* pInput)&lt;/span&gt;&lt;span class=&quot;hljs-comment&quot;&gt;//keep taking input untill input is `int or float`&lt;/span&gt;\n&lt;/span&gt;{\n    cin&amp;gt;&amp;gt; *pInput;\n    &lt;span class=&quot;hljs-comment&quot;&gt;/*-----------check input validation----------------*/&lt;/span&gt;\n    &lt;span class=&quot;hljs-keyword&quot;&gt;while&lt;/span&gt; (!cin) \n    {\n        cin.&lt;span class=&quot;hljs-built_in&quot;&gt;clear&lt;/span&gt;();\n        cin.&lt;span class=&quot;hljs-built_in&quot;&gt;ignore&lt;/span&gt;(&lt;span class=&quot;hljs-number&quot;&gt;100&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&apos;\\n&apos;&lt;/span&gt;);\n        cout&amp;lt;&amp;lt;&lt;span class=&quot;hljs-string&quot;&gt;&quot;Invalid Input Type.\\nEnter again: &quot;&lt;/span&gt;;\n        cin &amp;gt;&amp;gt;*pInput;\n    }\n    &lt;span class=&quot;hljs-comment&quot;&gt;/*-----------checked input validation-------------*/&lt;/span&gt;\n}\n&lt;/code&gt;&lt;/pre&gt;\n    ","\n&lt;p&gt;I am really wondering. C++ has a dedicated function for eating up any remaining or whatever white spaces. It is called &lt;a href=&quot;https://en.cppreference.com/w/cpp/io/manip/ws&quot; rel=&quot;nofollow noreferrer&quot;&gt;std::ws&lt;/a&gt;. And then, you can simply use&lt;/p&gt;\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;std::&lt;span class=&quot;hljs-built_in&quot;&gt;getline&lt;/span&gt;(std::cin &amp;gt;&amp;gt; std::ws, name);\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;That should be the idomatic approach. For each transistion between formatted to unformatted input that should be used.&lt;/p&gt;\n&lt;p&gt;If we are not talking about white spaces, but entering for example letters where a number is expected, then we should follow the CPP reference and use&lt;/p&gt;\n&lt;p&gt;&lt;code&gt;.ignore(std::numeric_limits&amp;lt;std::streamsize&amp;gt;::max(), &apos;\\n&apos;);&lt;/code&gt; to eliminate the wrong stuff.&lt;/p&gt;\n&lt;p&gt;Please read &lt;a href=&quot;https://en.cppreference.com/w/cpp/io/basic_istream/ignore&quot; rel=&quot;nofollow noreferrer&quot;&gt;here&lt;/a&gt;&lt;/p&gt;\n    "],"id":145,"title":"Why does std::getline() skip input after a formatted extraction?","content":"\n                \n&lt;p&gt;I have the following piece of code that prompts the user for their cat&apos;s age and name:&lt;/p&gt;\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&amp;lt;string&amp;gt;&lt;/span&gt;&lt;/span&gt;\n\n&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt;\n&lt;/span&gt;{\n    &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; age;\n    std::string name;\n\n    std::cin &amp;gt;&amp;gt; age;\n    std::&lt;span class=&quot;hljs-built_in&quot;&gt;getline&lt;/span&gt;(std::cin, name);\n    \n    &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (std::cin)\n    {\n        std::cout &amp;lt;&amp;lt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;My cat is &quot;&lt;/span&gt; &amp;lt;&amp;lt; age &amp;lt;&amp;lt; &lt;span class=&quot;hljs-string&quot;&gt;&quot; years old and their name is &quot;&lt;/span&gt; &amp;lt;&amp;lt; name &amp;lt;&amp;lt; std::endl;\n    }\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;What I find is that the age has been successfully read, but not the name. Here is the input and output:&lt;/p&gt;\n&lt;blockquote&gt;\n&lt;pre class=&quot;lang-cpp s-code-block&quot;&gt;&lt;code class=&quot;hljs language-cpp&quot;&gt;Input:\n\n&lt;span class=&quot;hljs-string&quot;&gt;&quot;10&quot;&lt;/span&gt;\n&lt;span class=&quot;hljs-string&quot;&gt;&quot;Mr. Whiskers&quot;&lt;/span&gt;\n\nOutput:\n\n&lt;span class=&quot;hljs-string&quot;&gt;&quot;My cat is 10 years old and their name is &quot;&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;/blockquote&gt;\n&lt;p&gt;Why has the name been omitted from the output? I&apos;ve given the proper input, but the code somehow ignores it. Why does this happen?&lt;/p&gt;\n    ","slug":"why-does-std::getline()-skip-input-after-a-formatted-extraction-1657384756118","postType":"QUESTION","createdAt":"2022-07-09T16:39:16.000Z","updatedAt":"2022-07-09T16:39:16.000Z","tags":[{"id":528,"name":"istream","slug":"istream","createdAt":"2022-07-09T16:39:16.000Z","updatedAt":"2022-07-09T16:39:16.000Z","Questions_Tags":{"questionId":145,"tagId":528}}],"relatedQuestions":[{"title":"Why does std::getline() skip input after a formatted extraction?","slug":"why-does-std::getline()-skip-input-after-a-formatted-extraction-1657384756118","tags":[{"name":"istream","Questions_Tags":{"questionId":145,"tagId":528}}]}]},"randomQuestions":[{"title":"When should static_cast, dynamic_cast, const_cast, and reinterpret_cast be used?","slug":"when-should-static_cast-dynamic_cast-const_cast-and-reinterpret_cast-be-used-1657388406205"},{"title":"Where should I put <script> tags in HTML markup?","slug":"where-should-i-put-lessscriptgreater-tags-in-html-markup-1657388350798"},{"title":"How does JavaScript .prototype work?","slug":"how-does-javascript-.prototype-work-1657388169270"},{"title":"How do I expire a PHP session after 30 minutes?","slug":"how-do-i-expire-a-php-session-after-30-minutes-1657387990658"},{"title":"WebDriverWait not working as expected","slug":"webdriverwait-not-working-as-expected-1657387373148"},{"title":"Generating random whole numbers in JavaScript in a specific range","slug":"generating-random-whole-numbers-in-javascript-in-a-specific-range-1657388112728"},{"title":"Is JavaScript a pass-by-reference or pass-by-value language?","slug":"is-javascript-a-pass-by-reference-or-pass-by-value-language-1657384675679"},{"title":"How do I split a delimited string so I can access individual items?","slug":"how-do-i-split-a-delimited-string-so-i-can-access-individual-items-1657388042385"},{"title":"What is SQL injection? [duplicate]","slug":"what-is-sql-injection-duplicate-1657387944486"},{"title":"How do I convert an existing callback API to promises?","slug":"how-do-i-convert-an-existing-callback-api-to-promises-1657384694006"},{"title":"How to avoid using Select in Excel VBA","slug":"how-to-avoid-using-select-in-excel-vba-1657384286300"},{"title":"How to compare arrays in JavaScript?","slug":"how-to-compare-arrays-in-javascript-1657387352277"},{"title":"Alternatives to gprof [closed]","slug":"alternatives-to-gprof-closed-1657388336554"},{"title":"How do I use extern to share variables between source files?","slug":"how-do-i-use-extern-to-share-variables-between-source-files-1657387453605"},{"title":"How to create RecyclerView with multiple view types","slug":"how-to-create-recyclerview-with-multiple-view-types-1657388121512"},{"title":"How can I group an array of objects by key?","slug":"how-can-i-group-an-array-of-objects-by-key-1657388065372"},{"title":"Flatten an irregular list of lists","slug":"flatten-an-irregular-list-of-lists-1657387315571"},{"title":"What does it mean to \"program to an interface\"?","slug":"what-does-it-mean-to-\"program-to-an-interface\"-1657384671665"},{"title":"How to generate all permutations of a list","slug":"how-to-generate-all-permutations-of-a-list-1657388537371"},{"title":"\"Notice: Undefined variable\", \"Notice: Undefined index\", \"Warning: Undefined array key\", and \"Notice: Undefined offset\" using PHP","slug":"\"notice:-undefined-variable\"-\"notice:-undefined-index\"-\"warning:-undefined-array-key\"-and-\"notice:-undefined-offset\"-using-php-1657384250748"}]},"__N_SSG":true}