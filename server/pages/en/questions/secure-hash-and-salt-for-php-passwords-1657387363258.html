<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><meta name="twitter:card" content="summary_large_image"/><meta name="twitter:site" content="@solutionschecker.com"/><meta name="twitter:creator" content="@solutionschecker.com"/><meta property="og:url" content="https://solutionschecker.com"/><meta property="og:type" content="website"/><meta property="og:image" content="https://solutionschecker.com/solutions-checker-banner.png"/><meta property="og:image:alt" content="Find solution for coding, HTML, CSS, JAVASCRIPT, MYSQL, PHP, PYTHON,... quickly. - solutionschecker.com"/><script type="application/ld+json">{"@context":"https://schema.org","@type":"Organization","logo":"/logo.svg","url":"https://solutionschecker.com"}</script><title>Secure hash and salt for PHP passwords | Solutions Checker</title><meta name="robots" content="index,follow"/><meta name="description" content="It is currently said that MD5 is partially unsafe. Taking this into consideration, I&#x27;d like to know which mechanism to use for password protection.

This question, Is “double hashing” a password less secure than just hashing it once? 
suggests that hashing multiple times may be a good idea, whereas How to implement password protection for individual files? suggests using salt.

I&#x27;m using PHP. I want a safe and fast password encryption system. Hashing a password a million times may be safer, but also slower. How to achieve a good balance between speed and safety? Also, I&#x27;d prefer the result to have a constant number of characters.


The hashing mechanism must be available in PHP
It must be safe
It can use salt (in this case, are all salts equally good? Is there any way to generate good salts?)


Also, should I store two fields in the database (one using MD5 and another one using SHA, for example)? Would it make it safer or unsafer?

In case I wasn&#x27;t clear enough, I want to know which hashing function(s) to use and how to pick a good salt in order to have a safe and fast password protection mechanism.

Related questions that don&#x27;t quite cover my question:

What&#x27;s the difference between SHA and MD5 in PHP
Simple Password Encryption
Secure methods of storing keys, passwords for asp.net
How would you implement salted passwords in Tomcat 5.5
    "/><meta property="og:title" content="Secure hash and salt for PHP passwords | Solutions Checker"/><meta property="og:description" content="It is currently said that MD5 is partially unsafe. Taking this into consideration, I&#x27;d like to know which mechanism to use for password protection.

This question, Is “double hashing” a password less secure than just hashing it once? 
suggests that hashing multiple times may be a good idea, whereas How to implement password protection for individual files? suggests using salt.

I&#x27;m using PHP. I want a safe and fast password encryption system. Hashing a password a million times may be safer, but also slower. How to achieve a good balance between speed and safety? Also, I&#x27;d prefer the result to have a constant number of characters.


The hashing mechanism must be available in PHP
It must be safe
It can use salt (in this case, are all salts equally good? Is there any way to generate good salts?)


Also, should I store two fields in the database (one using MD5 and another one using SHA, for example)? Would it make it safer or unsafer?

In case I wasn&#x27;t clear enough, I want to know which hashing function(s) to use and how to pick a good salt in order to have a safe and fast password protection mechanism.

Related questions that don&#x27;t quite cover my question:

What&#x27;s the difference between SHA and MD5 in PHP
Simple Password Encryption
Secure methods of storing keys, passwords for asp.net
How would you implement salted passwords in Tomcat 5.5
    "/><script type="application/ld+json">{"@context":"https://schema.org","@type":"QAPage","mainEntity":{"name":"Secure hash and salt for PHP passwords","text":"It is currently said that MD5 is partially unsafe. Taking this into consideration, I&apos;d like to know which mechanism to use for password protection.\n\nThis question, Is “double hashing” a password less secure than just hashing it once? \nsuggests that hashing multiple times may be a good idea, whereas How to implement password protection for individual files? suggests using salt.\n\nI&apos;m using PHP. I want a safe and fast password encryption system. Hashing a password a million times may be safer, but also slower. How to achieve a good balance between speed and safety? Also, I&apos;d prefer the result to have a constant number of characters.\n\n\nThe hashing mechanism must be available in PHP\nIt must be safe\nIt can use salt (in this case, are all salts equally good? Is there any way to generate good salts?)\n\n\nAlso, should I store two fields in the database (one using MD5 and another one using SHA, for example)? Would it make it safer or unsafer?\n\nIn case I wasn&apos;t clear enough, I want to know which hashing function(s) to use and how to pick a good salt in order to have a safe and fast password protection mechanism.\n\nRelated questions that don&apos;t quite cover my question:\n\nWhat&apos;s the difference between SHA and MD5 in PHP\nSimple Password Encryption\nSecure methods of storing keys, passwords for asp.net\nHow would you implement salted passwords in Tomcat 5.5\n    ","answerCount":14,"upVoteCount":500,"suggestedAnswer":[{"text":"\n  DISCLAIMER: This answer was written in 2008.\n  \n  Since then, PHP has given us password_hash and password_verify and, since their introduction, they are the recommended password hashing &amp; checking method.\n  \n  The theory of the answer is still a good read though.\n\n\nTL;DR\n\nDon&apos;ts\n\n\nDon&apos;t limit what characters users can enter for passwords. Only idiots do this.\nDon&apos;t limit the length of a password. If your users want a sentence with supercalifragilisticexpialidocious in it, don&apos;t prevent them from using it.\nDon&apos;t strip or escape HTML and special characters in the password.\nNever store your user&apos;s password in plain-text.\nNever email a password to your user except when they have lost theirs, and you sent a temporary one.\nNever, ever log passwords in any manner.\nNever hash passwords with SHA1 or MD5 or even SHA256! Modern crackers can exceed 60 and 180 billion hashes/second (respectively).\nDon&apos;t mix bcrypt and with the raw output of hash(), either use hex output or base64_encode it. (This applies to any input that may have a rogue \\0 in it, which can seriously weaken security.)\n\n\nDos\n\n\nUse scrypt when you can; bcrypt if you cannot.\nUse PBKDF2 if you cannot use either bcrypt or scrypt, with SHA2 hashes.\nReset everyone&apos;s passwords when the database is compromised.\nImplement a reasonable 8-10 character minimum length, plus require at least 1 upper case letter, 1 lower case letter, a number, and a symbol. This will improve the entropy of the password, in turn making it harder to crack. (See the &quot;What makes a good password?&quot; section for some debate.)\n\n\nWhy hash passwords anyway?\n\nThe objective behind hashing passwords is simple: preventing malicious access to user accounts by compromising the database. So the goal of password hashing is to deter a hacker or cracker by costing them too much time or money to calculate the plain-text passwords. And time/cost are the best deterrents in your arsenal.\n\nAnother reason that you want a good, robust hash on a user accounts is to give you enough time to change all the passwords in the system. If your database is compromised you will need enough time to at least lock the system down, if not change every password in the database.\n\nJeremiah Grossman, CTO of Whitehat Security, stated on White Hat Security blog after a recent password recovery that required brute-force breaking of his password protection:\n\n\n  Interestingly, in living out this nightmare, I learned A LOT I didnt know about password cracking, storage, and complexity. Ive come to appreciate why password storage is ever so much more important than password complexity. If you dont know how your password is stored, then all you really can depend upon is complexity. This might be common knowledge to password and crypto pros, but for the average InfoSec or Web Security expert, I highly doubt it.\n\n\n(Emphasis mine.)\n\nWhat makes a good password anyway?\n\nEntropy. (Not that I fully subscribe to Randall&apos;s viewpoint.)\n\nIn short, entropy is how much variation is within the password. When a password is only lowercase roman letters, that&apos;s only 26 characters. That isn&apos;t much variation. Alpha-numeric passwords are better, with 36 characters. But allowing upper and lower case, with symbols, is roughly 96 characters. That&apos;s a lot better than just letters. One problem is, to make our passwords memorable we insert patternswhich reduces entropy. Oops!\n\nPassword entropy is approximated easily. Using the full range of ascii characters (roughly 96 typeable characters) yields an entropy of 6.6 per character, which at 8 characters for a password is still too low (52.679 bits of entropy) for future security. But the good news is: longer passwords, and passwords with unicode characters, really increase the entropy of a password and make it harder to crack.\n\nThere&apos;s a longer discussion of password entropy on the Crypto StackExchange site. A good Google search will also turn up a lot of results.\n\nIn the comments I talked with @popnoodles, who pointed out that enforcing a password policy of X length with X many letters, numbers, symbols, etc, can actually reduce entropy by making the password scheme more predictable. I do agree. Randomess, as truly random as possible, is always the safest but least memorable solution.\n\nSo far as I&apos;ve been able to tell, making the world&apos;s best password is a Catch-22. Either its not memorable, too predictable, too short, too many unicode characters (hard to type on a Windows/Mobile device), too long, etc. No password is truly good enough for our purposes, so we must protect them as though they were in Fort Knox.\n\nBest practices\n\nBcrypt and scrypt are the current best practices. Scrypt will be better than bcrypt in time, but it hasn&apos;t seen adoption as a standard by Linux/Unix or by webservers, and hasn&apos;t had in-depth reviews of its algorithm posted yet. But still, the future of the algorithm does look promising. If you are working with Ruby there is an scrypt gem that will help you out, and Node.js now has its own scrypt package. You can use Scrypt in PHP either via the Scrypt extension or the Libsodium extension (both are available in PECL).\n\nI highly suggest reading the documentation for the crypt function if you want to understand how to use bcrypt, or finding yourself a good wrapper or use something like PHPASS for a more legacy implementation. I recommend a minimum of 12 rounds of bcrypt, if not 15 to 18.\n\nI changed my mind about using bcrypt when I learned that bcrypt only uses blowfish&apos;s key schedule, with a variable cost mechanism. The latter lets you increase the cost to brute-force a password by increasing blowfish&apos;s already expensive key schedule.\n\nAverage practices\n\nI almost can&apos;t imagine this situation anymore. PHPASS supports PHP 3.0.18 through 5.3, so it is usable on almost every installation imaginableand should be used if you don&apos;t know for certain that your environment supports bcrypt.\n\nBut suppose that you cannot use bcrypt or PHPASS at all. What then?\n\nTry an implementation of PDKBF2 with the maximum number of rounds that your environment/application/user-perception can tolerate. The lowest number I&apos;d recommend is 2500 rounds. Also, make sure to use hash_hmac() if it is available to make the operation harder to reproduce.\n\nFuture Practices\n\nComing in PHP 5.5 is a full password protection library that abstracts away any pains of working with bcrypt. While most of us are stuck with PHP 5.2 and 5.3 in most common environments, especially shared hosts, @ircmaxell has built a compatibility layer for the coming API that is backward compatible to PHP 5.3.7.\n\nCryptography Recap &amp; Disclaimer\n\nThe computational power required to actually crack a hashed password doesn&apos;t exist. The only way for computers to &quot;crack&quot; a password is to recreate it and simulate the hashing algorithm used to secure it. The speed of the hash is linearly related to its ability to be brute-forced. Worse still, most hash algorithms can be easily parallelized to perform even faster. This is why costly schemes like bcrypt and scrypt are so important.\n\nYou cannot possibly foresee all threats or avenues of attack, and so you must make your best effort to protect your users up front. If you do not, then you might even miss the fact that you were attacked until it&apos;s too late... and you&apos;re liable. To avoid that situation, act paranoid to begin with. Attack your own software (internally) and attempt to steal user credentials, or modify other user&apos;s accounts or access their data. If you don&apos;t test the security of your system, then you cannot blame anyone but yourself.\n\nLastly: I am not a cryptographer. Whatever I&apos;ve said is my opinion, but I happen to think it&apos;s based on good ol&apos; common sense ... and lots of reading. Remember, be as paranoid as possible, make things as hard to intrude as possible, and then, if you are still worried, contact a white-hat hacker or cryptographer to see what they say about your code/system.\n    ","url":"/questions/[slug]#solution1","@type":"Answer","upvoteCount":0},{"text":"A much shorter and safer answer - don&apos;t write your own password mechanism at all, use a tried and tested mechanism.\n\nPHP 5.5 or higher: password_hash() is good quality and part of PHP core.\nPHP 4.x (obsolete): OpenWall&apos;s phpass library is much better than most custom code - used in WordPress, Drupal, etc.\n\nMost programmers just don&apos;t have the expertise to write crypto related code safely without introducing vulnerabilities.\nQuick self-test: what is password stretching and how many iterations should you use?  If you don&apos;t know the answer, you should use password_hash(), as password stretching is now a critical feature of password mechanisms due to much faster CPUs and the use of GPUs and FPGAs to crack passwords at rates of billions of guesses per second (with GPUs).\nAs of 2012, you could crack all 8-character Windows passwords in 6 hours using 25 GPUs installed in 5 desktop PCs.  This is brute-forcing i.e. enumerating and checking every 8-character Windows password, including special characters, and is not a dictionary attack. With modern GPUs, you can of course crack more passwords or use fewer GPUs - or rent the GPUs in the cloud for a few hours at reasonable cost.\nThere are also many rainbow table attacks on Windows passwords that run on ordinary CPUs and are very fast.\nAll this is because Windows still doesn&apos;t salt or stretch its passwords, even in Windows 10.  This is still true in 2021.  Don&apos;t make the same mistake as Microsoft did!\nSee also:\n\nexcellent answer with more about why password_hash() or phpass are the best way to go.\ngood blog article giving recommmended &apos;work factors&apos; (number of iterations) for main algorithms including bcrypt, scrypt and PBKDF2.\n\n    ","url":"/questions/[slug]#solution2","@type":"Answer","upvoteCount":0},{"text":"I would not store the password hashed in two different ways, because then the system is at least as weak as the weakest of the hash algorithms in use.\n    ","url":"/questions/[slug]#solution3","@type":"Answer","upvoteCount":0},{"text":"As of PHP 5.5, PHP has simple, secure functions for hashing and verifying passwords, password_hash() and password_verify()\n\n$password = &apos;anna&apos;;\n$hash = password_hash($password, PASSWORD_DEFAULT);\n$expensiveHash = password_hash($password, PASSWORD_DEFAULT, array(&apos;cost&apos; =&gt; 20));\n\npassword_verify(&apos;anna&apos;, $hash); //Returns true\npassword_verify(&apos;anna&apos;, $expensiveHash); //Also returns true\npassword_verify(&apos;elsa&apos;, $hash); //Returns false\n\n\nWhen password_hash() is used, it generates a random salt and includes it in the outputted hash (along with the the cost and algorithm used.) password_verify() then reads that hash and determines the salt and encryption method used, and verifies it against the provided plaintext password.\n\nProviding the PASSWORD_DEFAULT instructs PHP to use the default hashing algorithm of the installed version of PHP. Exactly which algorithm that means is intended to change over time in future versions, so that it will always be one of the strongest available algorithms.\n\nIncreasing cost (which defaults to 10) makes the hash harder to brute-force but also means generating hashes and verifying passwords against them will be more work for your server&apos;s CPU.\n\nNote that even though the default hashing algorithm may change, old hashes will continue to verify just fine because the algorithm used is stored in the hash and password_verify() picks up on it.\n    ","url":"/questions/[slug]#solution4","@type":"Answer","upvoteCount":0},{"text":"Though the question has been answered, I just want to reiterate that salts used for hashing should be random and not like email address as suggested in first answer. \n\nMore explanation is available at- http://www.pivotalsecurity.com/blog/password-hashing-salt-should-it-be-random/\n\n\n  Recently I had a discussion whether password hashes salted with random\n  bits are more secure than the one salted with guessable or known\n  salts. Lets see: If the system storing password is compromised as\n  well as the system which stores the random salt, the attacker will\n  have access to hash as well as salt, so whether the salt is random or\n  not, doesnt matter. The attacker will can generate pre-computed\n  rainbow tables to crack the hash. Here comes the interesting part- it\n  is not so trivial to generate pre-computed tables. Let us take example\n  of WPA security model. Your WPA password is actually never sent to\n  Wireless Access Point. Instead, it is hashed with your SSID (the\n  network name- like Linksys, Dlink etc). A very good explanation of how\n  this works is here. In order to retrieve password from hash, you will\n  need to know the password as well as salt (network name). Church of\n  Wifi has already pre-computed hash tables which has top 1000 SSIDs and\n  about 1 million passwords. The size is of all tables is about 40 GB.\n  As you can read on their site, someone used 15 FGPA arrays for 3 days\n  to generate  these tables. Assuming victim is using the SSID as\n  a387csf3 and password as 123456, will it be cracked by those\n  tables? No! .. it cannot. Even if the password is weak, the tables\n  dont have hashes for SSID a387csf3.  This is the beauty of having\n  random salt. It will deter crackers who thrive upon pre-computed\n  tables. Can it stop a determined hacker? Probably not. But using\n  random salts does provide additional layer of defense. While we are on\n  this topic, let us discuss additional advantage of storing random\n  salts on a separate system. Scenario #1 : Password hashes are stored\n  on system X and salt values used for hashing are stored on system Y.\n  These salt values are guessable or known (e.g. username) Scenario#2 :\n  Password hashes are stored on system X and salt values used for\n  hashing are stored on system Y. These salt values are random. In case\n  system X has been compromised, as you can guess, there is a huge\n  advantage of using random salt on a separate system (Scenario #2) .\n  The attacker will need to guess addition values to be able to crack\n  hashes. If a 32 bit salt is used, 2^32= 4,294,967,296 (about 4.2\n  billion) iterations will can be required for each password guessed.\n\n    ","url":"/questions/[slug]#solution5","@type":"Answer","upvoteCount":0},{"text":"I just want to point out that PHP 5.5 includes a password hashing API that provides a wrapper around crypt(). This API significantly simplifies the task of hashing, verifying and rehashing password hashes. The author has also released a compatibility pack (in the form of a single password.php file that you simply require to use), for those using PHP 5.3.7 and later and want to use this right now.\n\nIt only supports BCRYPT for now, but it aims to be easily extended to include other password hashing techniques and because the technique and cost is stored as part of the hash, changes to your prefered hashing technique/cost will not invalidate current hashes, the framework will automagically, use the correct technique/cost when validating. It also handles generating a &quot;secure&quot; salt if you do not explicitly define your own.\n\nThe API exposes four functions:\n\n\npassword_get_info() - returns information about the given hash\npassword_hash() - creates a password hash\npassword_needs_rehash() - checks if the given hash matches the given options. Useful to check if the hash conforms to your current technique/cost scheme allowing you to rehash if necessary\npassword_verify() - verifies that a password matches a hash\n\n\nAt the moment these functions accept the PASSWORD_BCRYPT and PASSWORD_DEFAULT password constants, which are synonymous at the moment, the difference being that PASSWORD_DEFAULT &quot;may change in newer PHP releases when newer, stronger hashing algorithms are supported.&quot; Using PASSWORD_DEFAULT and password_needs_rehash() on login (and rehashing if necessary) should ensure that your hashes are reasonably resilient to brute-force attacks with little to no work for you.\n\nEDIT: I just realised that this is mentioned briefly in Robert K&apos;s answer. I&apos;ll leave this answer here since I think it provides a bit more information about how it works and the ease of use it provides for those who don&apos;t know security.\n    ","url":"/questions/[slug]#solution6","@type":"Answer","upvoteCount":0},{"text":"I&apos;m using Phpass which is a simple one-file PHP class that could be implemented very easily in nearly every PHP project. See also The H.\n\nBy default it used strongest available encryption that is implemented in Phpass, which is bcrypt and falls back to other encryptions down to MD5 to provide backward compatibility to frameworks like Wordpress.\n\nThe returned hash could be stored in database as it is. Sample use for generating hash is:\n\n$t_hasher = new PasswordHash(8, FALSE);\n$hash = $t_hasher-&gt;HashPassword($password);\n\n\nTo verify password, one can use:\n\n$t_hasher = new PasswordHash(8, FALSE);\n$check = $t_hasher-&gt;CheckPassword($password, $hash);\n\n    ","url":"/questions/[slug]#solution7","@type":"Answer","upvoteCount":0},{"text":"THINGS TO REMEMBER\n\nA lot has been said about Password encryption for PHP, most of which is very good advice, but before you even start the process of using PHP for password encryption make sure you have the following implemented or ready to be implemented.\n\nSERVER\n\nPORTS\n\nNo matter how good your encryption is if you don&apos;t properly secure the server that runs the PHP and DB all your efforts are worthless. Most servers function relatively the same way, they have ports assigned to allow you to access them remotely either through ftp or shell. Make sure that you change the default port of which ever remote connection you have active. By not doing this you in effect have made the attacker do one less step in accessing your system. \n\nUSERNAME\n\nFor all that is good in the world do not use the username admin, root or something similar. Also if you are on a unix based system DO NOT make the root account login accessible, it should always be sudo only.\n\nPASSWORD\n\nYou tell your users to make good passwords to avoid getting hacked, do the same. What is the point in going through all the effort of locking your front door when you have the backdoor wide open.\n\nDATABASE\n\nSERVER\n\nIdeally you want your DB and APPLICATION on separate servers. This is not always possible due to cost, but it does allow for some safety as the attacker will have to go through two steps to fully access the system.\n\nUSER\n\nAlways have your application have its own account to access the DB, and only give it the privileges it will need. \n\nThen have a separate user account for you that is not stored anywhere on the server, not even in the application. \n\nLike always DO NOT make this root or something similar.\n\nPASSWORD\n\nFollow the same guidelines as with all good passwords. Also don&apos;t reuse the same password on any SERVER or DB accounts on the same system.\n\nPHP\n\nPASSWORD\n\nNEVER EVER store a password in your DB, instead store the hash and unique salt, I will explain why later.\n\nHASHING\n\nONE WAY HASHING!!!!!!!, Never hash a password in a way that it can be reversed, Hashes should be one way, meaning you don&apos;t reverse them and compare them to the password, you instead hash the entered password the same way and compare the two hashes. This means that even if an attacker gets access to the DB he doesn&apos;t know what the actually password is, just its resulting hash. Which means more security for your users in the worst possible scenario.\n\nThere are a lot of good hashing functions out there (password_hash, hash, etc...) but you need to select a good algorithm for the hash to be effective. (bcrypt and ones similar to it are decent algorithms.) \n\nWhen hashing speed is the key, the slower the more resistant to Brute Force attacks. \n\nOne of the most common mistakes in hashing is that hashes are not unique to the users. This is mainly because salts are not uniquely generated.\n\nSALTING\n\nPasswords should always be salted before hashed. Salting adds a random string to the password so similar passwords don&apos;t appear the same in the DB. However if the salt is not unique to each user (ie: you use a hard coded salt) than you pretty much have made your salt worthless. Because once an attacker figures out one password salt he has the salt for all of them. \n\nWhen you create a salt make sure it is unique to the password it is salting, then store both the completed hash and salt in your DB. What this will do is make it so that an attacker will have to individually crack each salt and hash before they can gain access. This means a lot more work and time for the attacker. \n\nUSERS CREATING PASSWORDS\n\nIf the user is creating a password through the frontend that means it has to be sent to the server. This opens up a security issue because that means the unencrypted password is being sent to the server and if a attacker is able to listen and access that all your security in PHP is worthless. ALWAYS transmit the data SECURELY, this is done through SSL, but be weary even SSL is not flawless (OpenSSL&apos;s Heartbleed flaw is an example of this). \n\nAlso make the user create a secure password, it is simple and should always be done, the user will be grateful for it in the end.\n\nFinally, no matter the security measures you take nothing is 100% secure, the more advanced the technology to protect becomes the more advanced the attacks become. But following these steps will make your site more secure and far less desirable for attackers to go after.\n\nHere is a PHP class that creates a hash and salt for a password easily\n\nhttp://git.io/mSJqpw\n    ","url":"/questions/[slug]#solution8","@type":"Answer","upvoteCount":0},{"text":"Google says SHA256 is available to PHP.\n\nYou should definitely use a salt. I&apos;d recommend using random bytes (and not restrict yourself to characters and numbers). As usually, the longer you choose, the safer, slower it gets. 64 bytes ought to be fine, i guess.\n    ","url":"/questions/[slug]#solution9","@type":"Answer","upvoteCount":0},{"text":"In the end, double-hashing, mathematically, provides no benefit.  In practice, however, it is useful for preventing rainbow table-based attacks.  In other words, it is of no more benefit than hashing with a salt, which takes far less processor time in your application or on your server.\n    ","url":"/questions/[slug]#solution10","@type":"Answer","upvoteCount":0},{"text":"I found perfect topic on this matter here: https://crackstation.net/hashing-security.htm, I wanted you to get benefit from it, here is source code also that provided prevention against time-based attack also.\n\n&lt;?php\n/*\n * Password hashing with PBKDF2.\n * Author: havoc AT defuse.ca\n * www: https://defuse.ca/php-pbkdf2.htm\n */\n\n// These constants may be changed without breaking existing hashes.\ndefine(&quot;PBKDF2_HASH_ALGORITHM&quot;, &quot;sha256&quot;);\ndefine(&quot;PBKDF2_ITERATIONS&quot;, 1000);\ndefine(&quot;PBKDF2_SALT_BYTES&quot;, 24);\ndefine(&quot;PBKDF2_HASH_BYTES&quot;, 24);\n\ndefine(&quot;HASH_SECTIONS&quot;, 4);\ndefine(&quot;HASH_ALGORITHM_INDEX&quot;, 0);\ndefine(&quot;HASH_ITERATION_INDEX&quot;, 1);\ndefine(&quot;HASH_SALT_INDEX&quot;, 2);\ndefine(&quot;HASH_PBKDF2_INDEX&quot;, 3);\n\nfunction create_hash($password)\n{\n    // format: algorithm:iterations:salt:hash\n    $salt = base64_encode(mcrypt_create_iv(PBKDF2_SALT_BYTES, MCRYPT_DEV_URANDOM));\n    return PBKDF2_HASH_ALGORITHM . &quot;:&quot; . PBKDF2_ITERATIONS . &quot;:&quot; .  $salt . &quot;:&quot; . \n        base64_encode(pbkdf2(\n            PBKDF2_HASH_ALGORITHM,\n            $password,\n            $salt,\n            PBKDF2_ITERATIONS,\n            PBKDF2_HASH_BYTES,\n            true\n        ));\n}\n\nfunction validate_password($password, $good_hash)\n{\n    $params = explode(&quot;:&quot;, $good_hash);\n    if(count($params) &lt; HASH_SECTIONS)\n       return false; \n    $pbkdf2 = base64_decode($params[HASH_PBKDF2_INDEX]);\n    return slow_equals(\n        $pbkdf2,\n        pbkdf2(\n            $params[HASH_ALGORITHM_INDEX],\n            $password,\n            $params[HASH_SALT_INDEX],\n            (int)$params[HASH_ITERATION_INDEX],\n            strlen($pbkdf2),\n            true\n        )\n    );\n}\n\n// Compares two strings $a and $b in length-constant time.\nfunction slow_equals($a, $b)\n{\n    $diff = strlen($a) ^ strlen($b);\n    for($i = 0; $i &lt; strlen($a) &amp;&amp; $i &lt; strlen($b); $i++)\n    {\n        $diff |= ord($a[$i]) ^ ord($b[$i]);\n    }\n    return $diff === 0; \n}\n\n/*\n * PBKDF2 key derivation function as defined by RSA&apos;s PKCS #5: https://www.ietf.org/rfc/rfc2898.txt\n * $algorithm - The hash algorithm to use. Recommended: SHA256\n * $password - The password.\n * $salt - A salt that is unique to the password.\n * $count - Iteration count. Higher is better, but slower. Recommended: At least 1000.\n * $key_length - The length of the derived key in bytes.\n * $raw_output - If true, the key is returned in raw binary format. Hex encoded otherwise.\n * Returns: A $key_length-byte key derived from the password and salt.\n *\n * Test vectors can be found here: https://www.ietf.org/rfc/rfc6070.txt\n *\n * This implementation of PBKDF2 was originally created by https://defuse.ca\n * With improvements by http://www.variations-of-shadow.com\n */\nfunction pbkdf2($algorithm, $password, $salt, $count, $key_length, $raw_output = false)\n{\n    $algorithm = strtolower($algorithm);\n    if(!in_array($algorithm, hash_algos(), true))\n        die(&apos;PBKDF2 ERROR: Invalid hash algorithm.&apos;);\n    if($count &lt;= 0 || $key_length &lt;= 0)\n        die(&apos;PBKDF2 ERROR: Invalid parameters.&apos;);\n\n    $hash_length = strlen(hash($algorithm, &quot;&quot;, true));\n    $block_count = ceil($key_length / $hash_length);\n\n    $output = &quot;&quot;;\n    for($i = 1; $i &lt;= $block_count; $i++) {\n        // $i encoded as 4 bytes, big endian.\n        $last = $salt . pack(&quot;N&quot;, $i);\n        // first iteration\n        $last = $xorsum = hash_hmac($algorithm, $last, $password, true);\n        // perform the other $count - 1 iterations\n        for ($j = 1; $j &lt; $count; $j++) {\n            $xorsum ^= ($last = hash_hmac($algorithm, $last, $password, true));\n        }\n        $output .= $xorsum;\n    }\n\n    if($raw_output)\n        return substr($output, 0, $key_length);\n    else\n        return bin2hex(substr($output, 0, $key_length));\n}\n?&gt;\n\n    ","url":"/questions/[slug]#solution11","@type":"Answer","upvoteCount":0},{"text":"I usually use SHA1 and salt with the user ID (or some other user-specific piece of information), and sometimes I additionally use a constant salt (so I have 2 parts to the salt).\n\nSHA1 is now also considered somewhat compromised, but to a far lesser degree than MD5.  By using a salt (any salt), you&apos;re preventing the use of a generic rainbow table to attack your hashes (some people have even had success using Google as a sort of rainbow table by searching for the hash).  An attacker could conceivably generate a rainbow table using your salt, so that&apos;s why you should include a user-specific salt.  That way, they will have to generate a rainbow table for each and every record in your system, not just one for your entire system!  With that type of salting, even MD5 is decently secure.\n    ","url":"/questions/[slug]#solution12","@type":"Answer","upvoteCount":0},{"text":"SHA1 and a salt should suffice (depending, naturally, on whether you are coding something for Fort Knox or a login system for your shopping list) for the foreseeable future. If SHA1 isn&apos;t good enough for you, use SHA256.\n\nThe idea of a salt is to throw the hashing results off balance, so to say. It is known, for example, that the MD5-hash of an empty string is d41d8cd98f00b204e9800998ecf8427e. So, if someone with good enough a memory would see that hash and know that it&apos;s the hash of an empty string. But if the string is salted (say, with the string &quot;MY_PERSONAL_SALT&quot;), the hash for the &apos;empty string&apos; (i.e. &quot;MY_PERSONAL_SALT&quot;) becomes aeac2612626724592271634fb14d3ea6, hence non-obvious to backtrace. What I&apos;m trying to say, that it&apos;s better to use any salt, than not to. Therefore, it&apos;s not too much of an importance to know which salt to use.\n\nThere are actually websites that do just this - you can feed it a (md5) hash, and it spits out a known plaintext that generates that particular hash. If you would get access to a database that stores plain md5-hashes, it would be trivial for you to enter the hash for the admin to such a service, and log in. But, if the passwords were salted, such a service would become ineffective.\n\nAlso, double-hashing is generally regarded as bad method, because it diminishes the result space. All popular hashes are fixed-length. Thus, you can have only a finite values of this fixed length, and the results become less varied. This could be regarded as another form of salting, but I wouldn&apos;t recommend it.\n    ","url":"/questions/[slug]#solution13","@type":"Answer","upvoteCount":0},{"text":"ok\nin the fitsy we need salt\nsalt must be unique\nso let generate it\n\n   /**\n     * Generating string\n     * @param $size\n     * @return string\n     */\n    function Uniwur_string($size){\n        $text = md5(uniqid(rand(), TRUE));\n        RETURN substr($text, 0, $size);\n    }\n\n\nalso we need the hash\nI`m using sha512\nit is the best and it is in php \n\n   /**\n     * Hashing string\n     * @param $string\n     * @return string\n     */\n    function hash($string){\n        return hash(&apos;sha512&apos;, $string);\n    }\n\n\nso now we can use this functions to generate safe password\n\n// generating unique password\n$password = Uniwur_string(20); // or you can add manual password\n// generating 32 character salt\n$salt = Uniwur_string(32);\n// now we can manipulate this informations\n\n// hashin salt for safe\n$hash_salt = hash($salt);\n// hashing password\n$hash_psw = hash($password.$hash_salt);\n\n\nnow we need to save in database our $hash_psw variable value and $salt variable\n\nand for authorize we will use same steps...\n\nit is the best way to safe our clients passwords...\n\nP.s. for last 2 steps you can use your own algorithm...\nbut be sure that you can generate this hashed password in the future \nwhen you need to authorize user...\n    ","url":"/questions/[slug]#solution14","@type":"Answer","upvoteCount":0}],"@type":"Question"}}</script><meta name="next-head-count" content="16"/><link rel="preload" href="/_next/static/css/08bcc42a26fe5c92.css" as="style"/><link rel="stylesheet" href="/_next/static/css/08bcc42a26fe5c92.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-0d1b80a048d4787e.js"></script><script src="/_next/static/chunks/webpack-42cdea76c8170223.js" defer=""></script><script src="/_next/static/chunks/framework-4556c45dd113b893.js" defer=""></script><script src="/_next/static/chunks/main-ccfab947c79712f4.js" defer=""></script><script src="/_next/static/chunks/pages/_app-08d1a634dea6705e.js" defer=""></script><script src="/_next/static/chunks/29107295-fbcfe2172188e46f.js" defer=""></script><script src="/_next/static/chunks/150-b06815e21c943e0d.js" defer=""></script><script src="/_next/static/chunks/490-7f0418bb4354ac73.js" defer=""></script><script src="/_next/static/chunks/108-87de33c23337ff53.js" defer=""></script><script src="/_next/static/chunks/pages/questions/%5Bslug%5D-79a1437acf654019.js" defer=""></script><script src="/_next/static/TQ2eYlCSdocSK-hq6gkM0/_buildManifest.js" defer=""></script><script src="/_next/static/TQ2eYlCSdocSK-hq6gkM0/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="wrapper"><header><nav class="bg-white border-gray-200 px-4 lg:px-6 py-2.5 dark:bg-gray-800"><div class="flex flex-wrap justify-between items-center mx-auto max-w-screen-xl"><a class="flex items-center" href="/"><img src="/logo-second.png" class="mr-3 h-6 sm:h-9" alt="Solution Checker Logo"/><h4 class="self-center text-xl font-semibold whitespace-nowrap dark:text-white">Solution Checker</h4></a><div class="flex items-center lg:order-2"><button data-collapse-toggle="mobile-menu-2" type="button" class="inline-flex items-center p-2 ml-1 text-sm text-gray-500 rounded-lg lg:hidden hover:bg-gray-100 focus:outline-none focus:ring-2 focus:ring-gray-200 dark:text-gray-400 dark:hover:bg-gray-700 dark:focus:ring-gray-600" aria-controls="mobile-menu-2" aria-expanded="false"><span class="sr-only">Open main menu</span><svg class="w-6 h-6" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M3 5a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM3 10a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM3 15a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1z" clip-rule="evenodd"></path></svg><svg class="hidden w-6 h-6" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z" clip-rule="evenodd"></path></svg></button></div><div class="hidden justify-between items-center w-full lg:flex lg:w-auto lg:order-1" id="mobile-menu-2"><ul class="flex flex-col mt-4 font-medium lg:flex-row lg:space-x-8 lg:mt-0"><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" aria-current="page" href="/">Home</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/questions?tab=news">Questions</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/post?tab=news">Post</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/questions/secure-hash-and-salt-for-php-passwords-1657387363258#">Coding</a></li></ul></div></div></nav></header><div class="main-content"><div class="question my-5"><div class="flex question-header items-center m-auto justify-center"><div class="rounded-xl w-full border p-5 shadow-md bg-white"><div class="flex w-full items-center justify-between border-b pb-3"><div class="flex items-center space-x-3"><div class="text-lg font-bold text-slate-700"><a href="/questions/secure-hash-and-salt-for-php-passwords-1657387363258"><h1>Secure hash and salt for PHP passwords</h1></a></div></div><div class="flex flex-wrap h-auto justify-end items-center space-x-8"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold" href="/questions/tag/hash">hash</a></div></div><div class="question-content mt-5">
                
<p>It is currently said that MD5 is partially unsafe. Taking this into consideration, I'd like to know which mechanism to use for password protection.</p>

<p>This question, <a href="https://stackoverflow.com/questions/348109/is-double-hashing-a-password-less-secure-than-just-hashing-it-once">Is “double hashing” a password less secure than just hashing it once?</a> 
suggests that hashing multiple times may be a good idea, whereas <a href="https://stackoverflow.com/questions/55862/how-to-implement-password-protection-for-individual-files#55904">How to implement password protection for individual files?</a> suggests using salt.</p>

<p>I'm using PHP. I want a safe and fast password encryption system. Hashing a password a million times may be safer, but also slower. How to achieve a good balance between speed and safety? Also, I'd prefer the result to have a constant number of characters.</p>

<ol>
<li>The hashing mechanism must be available in PHP</li>
<li>It must be safe</li>
<li>It can use salt (in this case, are all salts equally good? Is there any way to generate good salts?)</li>
</ol>

<p>Also, should I store two fields in the database (one using MD5 and another one using SHA, for example)? Would it make it safer or unsafer?</p>

<p>In case I wasn't clear enough, I want to know which hashing function(s) to use and how to pick a good salt in order to have a safe and fast password protection mechanism.</p>

<p><em>Related questions that don't quite cover my question:</em></p>

<p><a href="https://stackoverflow.com/questions/157998/whats-the-difference-between-sha-and-md5-in-php">What's the difference between SHA and MD5 in PHP</a><br>
<a href="https://stackoverflow.com/questions/30946/simple-password-encryption">Simple Password Encryption</a><br>
<a href="https://stackoverflow.com/questions/198803/secure-methods-of-storing-keys-passwords-for-asp-net">Secure methods of storing keys, passwords for asp.net</a><br>
<a href="https://stackoverflow.com/questions/205153/how-would-you-implement-salted-passwords-in-tomcat-5-5">How would you implement salted passwords in Tomcat 5.5</a></p>
    </div></div></div><div class="solution-section"><nav class="flex pagination-solution flex-col justify-end"><ul class="inline-flex -space-x-px overflow-auto"><li class="pagination-solution-item"><span data-id="#solution1" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">1</span></li><li class="pagination-solution-item"><span data-id="#solution2" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">2</span></li><li class="pagination-solution-item"><span data-id="#solution3" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">3</span></li><li class="pagination-solution-item"><span data-id="#solution4" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">4</span></li><li class="pagination-solution-item"><span data-id="#solution5" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">5</span></li><li class="pagination-solution-item"><span data-id="#solution6" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">6</span></li><li class="pagination-solution-item"><span data-id="#solution7" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">7</span></li><li class="pagination-solution-item"><span data-id="#solution8" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">8</span></li><li class="pagination-solution-item"><span data-id="#solution9" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">9</span></li><li class="pagination-solution-item"><span data-id="#solution10" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">10</span></li><li class="pagination-solution-item"><span data-id="#solution11" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">11</span></li><li class="pagination-solution-item"><span data-id="#solution12" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">12</span></li><li class="pagination-solution-item"><span data-id="#solution13" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">13</span></li><li class="pagination-solution-item"><span data-id="#solution14" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">14</span></li></ul></nav><div id="solution1" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 1</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/hash">hash</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<blockquote>
  <p><strong>DISCLAIMER</strong>: This answer was written in 2008.</p>
  
  <p>Since then, PHP has given us <a href="http://php.net/manual/en/function.password-hash.php" rel="noreferrer"><code>password_hash</code></a> and <a href="http://php.net/manual/en/function.password-verify.php" rel="noreferrer"><code>password_verify</code></a> and, since their introduction, they are the recommended password hashing &amp; checking method.</p>
  
  <p>The theory of the answer is still a good read though.</p>
</blockquote>

<h2>TL;DR</h2>

<h3>Don'ts</h3>

<ul>
<li>Don't limit what characters users can enter for passwords. Only idiots do this.</li>
<li>Don't limit the length of a password. If your users want a sentence with supercalifragilisticexpialidocious in it, don't prevent them from using it.</li>
<li>Don't strip or escape HTML and special characters in the password.</li>
<li>Never store your user's password in plain-text.</li>
<li>Never email a password to your user <em>except when they have lost theirs, and you sent a temporary one.</em></li>
<li>Never, ever log passwords in any manner.</li>
<li>Never hash passwords with <a href="http://arstechnica.com/security/2012/12/oh-great-new-attack-makes-some-password-cracking-faster-easier-than-ever/" rel="noreferrer">SHA1</a> or MD5 or even SHA256! <a href="http://securityledger.com/new-25-gpu-monster-devours-passwords-in-seconds/" rel="noreferrer">Modern crackers</a> can exceed 60 and 180 billion hashes/second (respectively).</li>
<li>Don't mix <a href="http://blog.ircmaxell.com/2015/03/security-issue-combining-bcrypt-with.html" rel="noreferrer">bcrypt and with the <em>raw</em> output of hash()</a>, either use hex output or base64_encode it. (This applies to any input that may have a rogue <code>\0</code> in it, which can seriously weaken security.)</li>
</ul>

<h3>Dos</h3>

<ul>
<li>Use scrypt when you can; bcrypt if you cannot.</li>
<li>Use PBKDF2 if you cannot use either bcrypt or scrypt, with SHA2 hashes.</li>
<li>Reset everyone's passwords when the database is compromised.</li>
<li>Implement a reasonable 8-10 character minimum length, plus require at least 1 upper case letter, 1 lower case letter, a number, and a symbol. This will improve the entropy of the password, in turn making it harder to crack. (See the "What makes a good password?" section for some debate.)</li>
</ul>

<h2>Why hash passwords anyway?</h2>

<p>The objective behind hashing passwords is simple: preventing malicious access to user accounts by compromising the database. So the goal of password hashing is to deter a hacker or cracker by costing them too much time or money to calculate the plain-text passwords. And time/cost are the best deterrents in your arsenal.</p>

<p>Another reason that you want a good, robust hash on a user accounts is to give you enough time to change all the passwords in the system. If your database is compromised you will need enough time to at <em>least</em> lock the system down, if not change every password in the database.</p>

<p>Jeremiah Grossman, CTO of Whitehat Security, <a href="https://www.whitehatsec.com/blog/cracking-aes-256-dmgs-and-epic-self-pwnage/" rel="noreferrer">stated on White Hat Security blog</a> after a recent password recovery that required brute-force breaking of his password protection:</p>

<blockquote>
  <p>Interestingly, in living out this nightmare, I learned A LOT I didnt know about password cracking, storage, and complexity. <em>Ive come to appreciate why password storage is ever so much more important than password complexity. If you dont know how your password is stored, then all you really can depend upon is complexity.</em> This might be common knowledge to password and crypto pros, but for the average InfoSec or Web Security expert, I highly doubt it.</p>
</blockquote>

<p>(Emphasis mine.)</p>

<h2>What makes a <em>good</em> password anyway?</h2>

<p><a href="http://xkcd.com/936/" rel="noreferrer">Entropy</a>. (Not that I fully subscribe to Randall's viewpoint.)</p>

<p>In short, entropy is how much variation is within the password. When a password is only lowercase roman letters, that's only 26 characters. That isn't much variation. Alpha-numeric passwords are better, with 36 characters. But allowing upper and lower case, with symbols, is roughly 96 characters. That's a lot better than just letters. One problem is, to make our passwords memorable we insert patternswhich reduces entropy. Oops!</p>

<p>Password entropy is <a href="https://ritcyberselfdefense.wordpress.com/2011/09/24/how-to-calculate-password-entropy/" rel="noreferrer">approximated</a> easily. Using the full range of ascii characters (roughly 96 typeable characters) yields an entropy of 6.6 per character, which at 8 characters for a password is still too low (52.679 bits of entropy) for future security. But the good news is: longer passwords, and passwords with unicode characters, really increase the entropy of a password and make it harder to crack.</p>

<p>There's a longer discussion of password entropy on the <a href="https://crypto.stackexchange.com/questions/374/how-should-i-calculate-the-entropy-of-a-password">Crypto StackExchange</a> site. A good Google search will also turn up a lot of results.</p>

<p>In the comments I talked with @popnoodles, who pointed out that <em>enforcing</em> a password policy of X length with X many letters, numbers, symbols, etc, can actually reduce entropy by making the password scheme more predictable. I do agree. Randomess, as truly random as possible, is always the safest but least memorable solution.</p>

<p>So far as I've been able to tell, making the world's best password is a Catch-22. Either its not memorable, too predictable, too short, too many unicode characters (hard to type on a Windows/Mobile device), too long, etc. No password is truly good enough for our purposes, so we must protect them as though they were in Fort Knox.</p>

<h2>Best practices</h2>

<p>Bcrypt and <a href="http://www.tarsnap.com/scrypt.html" rel="noreferrer">scrypt</a> are the current best practices. <a href="http://www.tarsnap.com/scrypt.html" rel="noreferrer">Scrypt</a> will be better than bcrypt in time, but it hasn't seen adoption as a standard by Linux/Unix or by webservers, and hasn't had in-depth reviews of its algorithm posted yet. But still, the future of the algorithm does look promising. If you are working with Ruby there is an <a href="http://rubygems.org/gems/scrypt" rel="noreferrer">scrypt gem</a> that will help you out, and Node.js now has its own <a href="https://npmjs.org/package/scrypt" rel="noreferrer">scrypt</a> package. You can use Scrypt in PHP either via the <a href="https://pecl.php.net/package/scrypt" rel="noreferrer">Scrypt</a> extension or the <a href="https://paragonie.com/book/pecl-libsodium/read/07-password-hashing.md" rel="noreferrer">Libsodium</a> extension (both are available in PECL).</p>

<p>I highly suggest reading the documentation for the <a href="http://us.php.net/crypt" rel="noreferrer">crypt function</a> if you want to understand how to use bcrypt, or finding yourself a <a href="https://stackoverflow.com/questions/4795385/how-do-you-use-bcrypt-for-hashing-passwords-in-php/6337021#6337021">good</a> <a href="https://gist.github.com/1070401" rel="noreferrer">wrapper</a> or use something like <a href="http://www.openwall.com/phpass/" rel="noreferrer">PHPASS</a> for a more legacy implementation. I recommend a minimum of 12 rounds of bcrypt, if not 15 to 18.</p>

<p>I changed my mind about using bcrypt when I learned that bcrypt only uses blowfish's key schedule, with a variable cost mechanism. The latter lets you increase the cost to brute-force a password by increasing blowfish's already expensive key schedule.</p>

<h2>Average practices</h2>

<p>I almost can't imagine this situation anymore. <a href="http://www.openwall.com/phpass/" rel="noreferrer">PHPASS</a> supports PHP 3.0.18 through 5.3, so it is usable on almost every installation imaginableand should be used if you don't <em>know for certain</em> that your environment supports bcrypt.</p>

<p>But suppose that you cannot use bcrypt or PHPASS at all. What then?</p>

<p>Try an implementation of <a href="http://www.itnewb.com/tutorial/Encrypting-Passwords-with-PHP-for-Storage-Using-the-RSA-PBKDF2-Standard" rel="noreferrer">PDKBF2</a> with the <a href="https://security.stackexchange.com/questions/3959/recommended-of-iterations-when-using-pkbdf2-sha256">maximum number of rounds</a> that your environment/application/user-perception can tolerate. The lowest number I'd recommend is 2500 rounds. Also, make sure to use <a href="http://php.net/hash_hmac" rel="noreferrer">hash_hmac()</a> if it is available to make the operation harder to reproduce.</p>

<h2>Future Practices</h2>

<p>Coming in PHP 5.5 is a <a href="http://php.net/manual/en/ref.password.php" rel="noreferrer">full password protection library</a> that abstracts away any pains of working with bcrypt. While most of us are stuck with PHP 5.2 and 5.3 in most common environments, especially shared hosts, @ircmaxell has built a <a href="https://github.com/ircmaxell/password_compat" rel="noreferrer">compatibility layer</a> for the coming API that is backward compatible to PHP 5.3.7.</p>

<h2>Cryptography Recap &amp; Disclaimer</h2>

<p>The computational power required to actually <em>crack</em> a hashed password doesn't exist. The only way for computers to "crack" a password is to recreate it and simulate the hashing algorithm used to secure it. The speed of the hash is linearly related to its ability to be brute-forced. Worse still, most hash algorithms can be easily parallelized to perform even faster. This is why costly schemes like bcrypt and scrypt are so important.</p>

<p>You cannot possibly foresee all threats or avenues of attack, and so you must make your best effort to protect your users <strong>up front</strong>. If you do not, then you might even miss the fact that you were attacked until it's too late... <em>and you're liable</em>. To avoid that situation, act paranoid to begin with. Attack your own software (internally) and attempt to steal user credentials, or modify other user's accounts or access their data. If you don't test the security of your system, then you cannot blame anyone but yourself.</p>

<p>Lastly: I am not a cryptographer. Whatever I've said is my opinion, but I happen to think it's based on good ol' common sense ... and lots of reading. Remember, be as paranoid as possible, make things as hard to intrude as possible, and then, if you are still worried, contact a white-hat hacker or cryptographer to see what they say about your code/system.</p>
    </div></div></div></div><div id="solution2" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 2</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/hash">hash</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>A much shorter and safer answer - <strong>don't write your own password mechanism at all</strong>, use a tried and tested mechanism.</p>
<ul>
<li>PHP 5.5 or higher: <a href="http://php.net/manual/en/function.password-hash.php" rel="nofollow noreferrer">password_hash()</a> is good quality and part of PHP core.</li>
<li>PHP 4.x (obsolete): OpenWall's <a href="http://www.openwall.com/phpass/" rel="nofollow noreferrer">phpass</a> library is much better than most custom code - used in WordPress, Drupal, etc.</li>
</ul>
<p>Most programmers just don't have the expertise to write crypto related code safely without introducing vulnerabilities.</p>
<p><strong>Quick self-test:</strong> what is password stretching and how many iterations should you use?  If you don't know the answer, you should use <code>password_hash()</code>, as password stretching is now a critical feature of password mechanisms due to much faster CPUs and the use of <a href="http://blog.crackpassword.com/2012/07/accelerating-password-recovery-the-addition-of-fpga/" rel="nofollow noreferrer">GPUs and FPGAs</a> to crack passwords at rates of <a href="http://en.wikipedia.org/wiki/Password_cracking#Time_needed_for_password_searches" rel="nofollow noreferrer">billions of guesses per second</a> (with GPUs).</p>
<p>As of 2012, you could <a href="http://arstechnica.com/security/2012/12/25-gpu-cluster-cracks-every-standard-windows-password-in-6-hours/" rel="nofollow noreferrer">crack all 8-character Windows passwords in 6 hours</a> using 25 GPUs installed in 5 desktop PCs.  This is brute-forcing i.e. enumerating and checking <em>every 8-character Windows password</em>, including special characters, and is not a dictionary attack. With modern GPUs, you can of course crack more passwords or use fewer GPUs - or rent the GPUs in the cloud for a few hours at reasonable cost.</p>
<p>There are also many rainbow table attacks on Windows passwords that run on ordinary CPUs and are very fast.</p>
<p>All this is because Windows <em>still</em> <a href="https://docs.microsoft.com/en-us/windows-server/security/kerberos/passwords-technical-overview" rel="nofollow noreferrer">doesn't salt or stretch</a> its passwords, <a href="https://www.guidingtech.com/61991/cracking-windows-10-password-prevent/" rel="nofollow noreferrer">even in Windows 10</a>.  This is still true in 2021.  Don't make the same mistake as Microsoft did!</p>
<p><strong>See also:</strong></p>
<ul>
<li><a href="https://stackoverflow.com/questions/1581610/how-can-i-store-my-users-passwords-safely/1581919#1581919">excellent answer</a> with more about why <code>password_hash()</code> or <code>phpass</code> are the best way to go.</li>
<li><a href="https://www.nccgroup.trust/us/about-us/newsroom-and-events/blog/2015/march/enough-with-the-salts-updates-on-secure-password-schemes/" rel="nofollow noreferrer">good blog article</a> giving recommmended 'work factors' (number of iterations) for main algorithms including bcrypt, scrypt and PBKDF2.</li>
</ul>
    </div></div></div></div><div id="solution3" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 3</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/hash">hash</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>I would not store the password hashed in two different ways, because then the system is at least as weak as the weakest of the hash algorithms in use.</p>
    </div></div></div></div><div id="solution4" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 4</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/hash">hash</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>As of PHP 5.5, PHP has simple, secure functions for hashing and verifying passwords, <a href="http://php.net/manual/en/function.password-hash.php" rel="noreferrer">password_hash()</a> and <a href="http://php.net/manual/en/function.password-verify.php" rel="noreferrer">password_verify()</a></p>

<pre class="lang-php s-code-block"><code class="hljs language-php"><span class="hljs-variable">$password</span> = <span class="hljs-string">'anna'</span>;
<span class="hljs-variable">$hash</span> = <span class="hljs-title function_ invoke__">password_hash</span>(<span class="hljs-variable">$password</span>, PASSWORD_DEFAULT);
<span class="hljs-variable">$expensiveHash</span> = <span class="hljs-title function_ invoke__">password_hash</span>(<span class="hljs-variable">$password</span>, PASSWORD_DEFAULT, <span class="hljs-keyword">array</span>(<span class="hljs-string">'cost'</span> =&gt; <span class="hljs-number">20</span>));

<span class="hljs-title function_ invoke__">password_verify</span>(<span class="hljs-string">'anna'</span>, <span class="hljs-variable">$hash</span>); <span class="hljs-comment">//Returns true</span>
<span class="hljs-title function_ invoke__">password_verify</span>(<span class="hljs-string">'anna'</span>, <span class="hljs-variable">$expensiveHash</span>); <span class="hljs-comment">//Also returns true</span>
<span class="hljs-title function_ invoke__">password_verify</span>(<span class="hljs-string">'elsa'</span>, <span class="hljs-variable">$hash</span>); <span class="hljs-comment">//Returns false</span>
</code></pre>

<p>When <code>password_hash()</code> is used, it generates a random salt and includes it in the outputted hash (along with the the cost and algorithm used.) <code>password_verify()</code> then reads that hash and determines the salt and encryption method used, and verifies it against the provided plaintext password.</p>

<p>Providing the <code>PASSWORD_DEFAULT</code> instructs PHP to use the default hashing algorithm of the installed version of PHP. Exactly which algorithm that means is intended to change over time in future versions, so that it will always be one of the strongest available algorithms.</p>

<p>Increasing cost (which defaults to 10) makes the hash harder to brute-force but also means generating hashes and verifying passwords against them will be more work for your server's CPU.</p>

<p>Note that even though the default hashing algorithm may change, old hashes will continue to verify just fine because the algorithm used is stored in the hash and <code>password_verify()</code> picks up on it.</p>
    </div></div></div></div><div id="solution5" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 5</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/hash">hash</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Though the question has been answered, I just want to reiterate that salts used for hashing should be random and not like email address as suggested in first answer. </p>

<p>More explanation is available at- <a href="http://www.pivotalsecurity.com/blog/password-hashing-salt-should-it-be-random/" rel="noreferrer">http://www.pivotalsecurity.com/blog/password-hashing-salt-should-it-be-random/</a></p>

<blockquote>
  <p>Recently I had a discussion whether password hashes salted with random
  bits are more secure than the one salted with guessable or known
  salts. Lets see: If the system storing password is compromised as
  well as the system which stores the random salt, the attacker will
  have access to hash as well as salt, so whether the salt is random or
  not, doesnt matter. The attacker will can generate pre-computed
  rainbow tables to crack the hash. Here comes the interesting part- it
  is not so trivial to generate pre-computed tables. Let us take example
  of WPA security model. Your WPA password is actually never sent to
  Wireless Access Point. Instead, it is hashed with your SSID (the
  network name- like Linksys, Dlink etc). A very good explanation of how
  this works is here. In order to retrieve password from hash, you will
  need to know the password as well as salt (network name). Church of
  Wifi has already pre-computed hash tables which has top 1000 SSIDs and
  about 1 million passwords. The size is of all tables is about 40 GB.
  As you can read on their site, someone used 15 FGPA arrays for 3 days
  to generate  these tables. Assuming victim is using the SSID as
  a387csf3 and password as 123456, will it be cracked by those
  tables? No! .. it cannot. Even if the password is weak, the tables
  dont have hashes for SSID a387csf3.  This is the beauty of having
  random salt. It will deter crackers who thrive upon pre-computed
  tables. Can it stop a determined hacker? Probably not. But using
  random salts does provide additional layer of defense. While we are on
  this topic, let us discuss additional advantage of storing random
  salts on a separate system. Scenario #1 : Password hashes are stored
  on system X and salt values used for hashing are stored on system Y.
  These salt values are guessable or known (e.g. username) Scenario#2 :
  Password hashes are stored on system X and salt values used for
  hashing are stored on system Y. These salt values are random. In case
  system X has been compromised, as you can guess, there is a huge
  advantage of using random salt on a separate system (Scenario #2) .
  The attacker will need to guess addition values to be able to crack
  hashes. If a 32 bit salt is used, 2^32= 4,294,967,296 (about 4.2
  billion) iterations will can be required for each password guessed.</p>
</blockquote>
    </div></div></div></div><div id="solution6" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 6</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/hash">hash</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>I just want to point out that PHP 5.5 includes a <a href="http://www.php.net/manual/en/ref.password.php">password hashing API</a> that provides a wrapper around <code>crypt()</code>. This API significantly simplifies the task of hashing, verifying and rehashing password hashes. The author has also released a <a href="https://github.com/ircmaxell/password_compat">compatibility pack</a> (in the form of a single password.php file that you simply <code>require</code> to use), for those using PHP 5.3.7 and later and want to use this right now.</p>

<p>It only supports BCRYPT for now, but it aims to be easily extended to include other password hashing techniques and because the technique and cost is stored as part of the hash, changes to your prefered hashing technique/cost will not invalidate current hashes, the framework will automagically, use the correct technique/cost when validating. It also handles generating a "secure" salt if you do not explicitly define your own.</p>

<p>The API exposes four functions:</p>

<ul>
<li><code>password_get_info()</code> - returns information about the given hash</li>
<li><code>password_hash()</code> - creates a password hash</li>
<li><code>password_needs_rehash()</code> - checks if the given hash matches the given options. Useful to check if the hash conforms to your current technique/cost scheme allowing you to rehash if necessary</li>
<li><code>password_verify()</code> - verifies that a password matches a hash</li>
</ul>

<p>At the moment these functions accept the PASSWORD_BCRYPT and PASSWORD_DEFAULT password constants, which are synonymous at the moment, the difference being that PASSWORD_DEFAULT "may change in newer PHP releases when newer, stronger hashing algorithms are supported." Using PASSWORD_DEFAULT and password_needs_rehash() on login (and rehashing if necessary) should ensure that your hashes are reasonably resilient to brute-force attacks with little to no work for you.</p>

<p>EDIT: I just realised that this is mentioned briefly in Robert K's answer. I'll leave this answer here since I think it provides a bit more information about how it works and the ease of use it provides for those who don't know security.</p>
    </div></div></div></div><div id="solution7" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 7</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/hash">hash</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>I'm using <a href="http://www.openwall.com/phpass/">Phpass</a> which is a simple one-file PHP class that could be implemented very easily in nearly every PHP project. See also <a href="http://www.h-online.com/security/features/Storing-passwords-in-uncrackable-form-1255576.html?page=4">The H</a>.</p>

<p>By default it used strongest available encryption that is implemented in Phpass, which is <code>bcrypt</code> and falls back to other encryptions down to MD5 to provide backward compatibility to frameworks like Wordpress.</p>

<p>The returned hash could be stored in database as it is. Sample use for generating hash is:</p>

<pre class="lang-php s-code-block"><code class="hljs language-php"><span class="hljs-variable">$t_hasher</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PasswordHash</span>(<span class="hljs-number">8</span>, <span class="hljs-literal">FALSE</span>);
<span class="hljs-variable">$hash</span> = <span class="hljs-variable">$t_hasher</span>-&gt;<span class="hljs-title function_ invoke__">HashPassword</span>(<span class="hljs-variable">$password</span>);
</code></pre>

<p>To verify password, one can use:</p>

<pre class="lang-php s-code-block"><code class="hljs language-php"><span class="hljs-variable">$t_hasher</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PasswordHash</span>(<span class="hljs-number">8</span>, <span class="hljs-literal">FALSE</span>);
<span class="hljs-variable">$check</span> = <span class="hljs-variable">$t_hasher</span>-&gt;<span class="hljs-title function_ invoke__">CheckPassword</span>(<span class="hljs-variable">$password</span>, <span class="hljs-variable">$hash</span>);
</code></pre>
    </div></div></div></div><div id="solution8" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 8</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/hash">hash</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p><strong>THINGS TO REMEMBER</strong></p>

<p>A lot has been said about Password encryption for PHP, most of which is very good advice, but before you even start the process of using PHP for password encryption make sure you have the following implemented or ready to be implemented.</p>

<p><strong>SERVER</strong></p>

<p><em>PORTS</em></p>

<p>No matter how good your encryption is if you don't properly secure the server that runs the PHP and DB all your efforts are worthless. Most servers function relatively the same way, they have ports assigned to allow you to access them remotely either through ftp or shell. Make sure that you change the default port of which ever remote connection you have active. By not doing this you in effect have made the attacker do one less step in accessing your system. </p>

<p><em>USERNAME</em></p>

<p>For all that is good in the world do not use the username admin, root or something similar. Also if you are on a unix based system DO NOT make the root account login accessible, it should always be sudo only.</p>

<p><em>PASSWORD</em></p>

<p>You tell your users to make good passwords to avoid getting hacked, do the same. What is the point in going through all the effort of locking your front door when you have the backdoor wide open.</p>

<p><strong>DATABASE</strong></p>

<p><em>SERVER</em></p>

<p>Ideally you want your DB and APPLICATION on separate servers. This is not always possible due to cost, but it does allow for some safety as the attacker will have to go through two steps to fully access the system.</p>

<p><em>USER</em></p>

<p>Always have your application have its own account to access the DB, and only give it the privileges it will need. </p>

<p>Then have a separate user account for you that is not stored anywhere on the server, not even in the application. </p>

<p>Like always DO NOT make this root or something similar.</p>

<p><em>PASSWORD</em></p>

<p>Follow the same guidelines as with all good passwords. Also don't reuse the same password on any SERVER or DB accounts on the same system.</p>

<p><strong>PHP</strong></p>

<p><em>PASSWORD</em></p>

<p>NEVER EVER store a password in your DB, instead store the hash and unique salt, I will explain why later.</p>

<p><em>HASHING</em></p>

<p>ONE WAY HASHING!!!!!!!, Never hash a password in a way that it can be reversed, Hashes should be one way, meaning you don't reverse them and compare them to the password, you instead hash the entered password the same way and compare the two hashes. This means that even if an attacker gets access to the DB he doesn't know what the actually password is, just its resulting hash. Which means more security for your users in the worst possible scenario.</p>

<p>There are a lot of good hashing functions out there (<code>password_hash</code>, <code>hash</code>, etc...) but you need to select a good algorithm for the hash to be effective. (bcrypt and ones similar to it are decent algorithms.) </p>

<p>When hashing speed is the key, the slower the more resistant to Brute Force attacks. </p>

<p>One of the most common mistakes in hashing is that hashes are not unique to the users. This is mainly because salts are not uniquely generated.</p>

<p><em>SALTING</em></p>

<p>Passwords should always be salted before hashed. Salting adds a random string to the password so similar passwords don't appear the same in the DB. However if the salt is not unique to each user (ie: you use a hard coded salt) than you pretty much have made your salt worthless. Because once an attacker figures out one password salt he has the salt for all of them. </p>

<p>When you create a salt make sure it is unique to the password it is salting, then store both the completed hash and salt in your DB. What this will do is make it so that an attacker will have to individually crack each salt and hash before they can gain access. This means a lot more work and time for the attacker. </p>

<p><em>USERS CREATING PASSWORDS</em></p>

<p>If the user is creating a password through the frontend that means it has to be sent to the server. This opens up a security issue because that means the unencrypted password is being sent to the server and if a attacker is able to listen and access that all your security in PHP is worthless. ALWAYS transmit the data SECURELY, this is done through SSL, but be weary even SSL is not flawless (OpenSSL's Heartbleed flaw is an example of this). </p>

<p>Also make the user create a secure password, it is simple and should always be done, the user will be grateful for it in the end.</p>

<p>Finally, no matter the security measures you take nothing is 100% secure, the more advanced the technology to protect becomes the more advanced the attacks become. But following these steps will make your site more secure and far less desirable for attackers to go after.</p>

<p>Here is a PHP class that creates a hash and salt for a password easily</p>

<p><a href="http://git.io/mSJqpw">http://git.io/mSJqpw</a></p>
    </div></div></div></div><div id="solution9" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 9</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/hash">hash</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Google says SHA256 is available to PHP.</p>

<p>You should definitely use a salt. I'd recommend using random bytes (and not restrict yourself to characters and numbers). As usually, the longer you choose, the safer, slower it gets. 64 bytes ought to be fine, i guess.</p>
    </div></div></div></div><div id="solution10" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 10</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/hash">hash</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>In the end, double-hashing, mathematically, provides no benefit.  In practice, however, it is useful for preventing rainbow table-based attacks.  In other words, it is of no more benefit than hashing with a salt, which takes far less processor time in your application or on your server.</p>
    </div></div></div></div><div id="solution11" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 11</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/hash">hash</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>I found perfect topic on this matter here: <a href="https://crackstation.net/hashing-security.htm" rel="noreferrer">https://crackstation.net/hashing-security.htm</a>, I wanted you to get benefit from it, here is source code also that provided prevention against time-based attack also.</p>

<pre class="lang-php s-code-block"><code class="hljs language-php"><span class="hljs-meta">&lt;?php</span>
<span class="hljs-comment">/*
 * Password hashing with PBKDF2.
 * Author: havoc AT defuse.ca
 * www: https://defuse.ca/php-pbkdf2.htm
 */</span>

<span class="hljs-comment">// These constants may be changed without breaking existing hashes.</span>
<span class="hljs-title function_ invoke__">define</span>(<span class="hljs-string">"PBKDF2_HASH_ALGORITHM"</span>, <span class="hljs-string">"sha256"</span>);
<span class="hljs-title function_ invoke__">define</span>(<span class="hljs-string">"PBKDF2_ITERATIONS"</span>, <span class="hljs-number">1000</span>);
<span class="hljs-title function_ invoke__">define</span>(<span class="hljs-string">"PBKDF2_SALT_BYTES"</span>, <span class="hljs-number">24</span>);
<span class="hljs-title function_ invoke__">define</span>(<span class="hljs-string">"PBKDF2_HASH_BYTES"</span>, <span class="hljs-number">24</span>);

<span class="hljs-title function_ invoke__">define</span>(<span class="hljs-string">"HASH_SECTIONS"</span>, <span class="hljs-number">4</span>);
<span class="hljs-title function_ invoke__">define</span>(<span class="hljs-string">"HASH_ALGORITHM_INDEX"</span>, <span class="hljs-number">0</span>);
<span class="hljs-title function_ invoke__">define</span>(<span class="hljs-string">"HASH_ITERATION_INDEX"</span>, <span class="hljs-number">1</span>);
<span class="hljs-title function_ invoke__">define</span>(<span class="hljs-string">"HASH_SALT_INDEX"</span>, <span class="hljs-number">2</span>);
<span class="hljs-title function_ invoke__">define</span>(<span class="hljs-string">"HASH_PBKDF2_INDEX"</span>, <span class="hljs-number">3</span>);

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">create_hash</span>(<span class="hljs-params"><span class="hljs-variable">$password</span></span>)
</span>{
    <span class="hljs-comment">// format: algorithm:iterations:salt:hash</span>
    <span class="hljs-variable">$salt</span> = <span class="hljs-title function_ invoke__">base64_encode</span>(<span class="hljs-title function_ invoke__">mcrypt_create_iv</span>(PBKDF2_SALT_BYTES, MCRYPT_DEV_URANDOM));
    <span class="hljs-keyword">return</span> PBKDF2_HASH_ALGORITHM . <span class="hljs-string">":"</span> . PBKDF2_ITERATIONS . <span class="hljs-string">":"</span> .  <span class="hljs-variable">$salt</span> . <span class="hljs-string">":"</span> . 
        <span class="hljs-title function_ invoke__">base64_encode</span>(<span class="hljs-title function_ invoke__">pbkdf2</span>(
            PBKDF2_HASH_ALGORITHM,
            <span class="hljs-variable">$password</span>,
            <span class="hljs-variable">$salt</span>,
            PBKDF2_ITERATIONS,
            PBKDF2_HASH_BYTES,
            <span class="hljs-literal">true</span>
        ));
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">validate_password</span>(<span class="hljs-params"><span class="hljs-variable">$password</span>, <span class="hljs-variable">$good_hash</span></span>)
</span>{
    <span class="hljs-variable">$params</span> = <span class="hljs-title function_ invoke__">explode</span>(<span class="hljs-string">":"</span>, <span class="hljs-variable">$good_hash</span>);
    <span class="hljs-keyword">if</span>(<span class="hljs-title function_ invoke__">count</span>(<span class="hljs-variable">$params</span>) &lt; HASH_SECTIONS)
       <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; 
    <span class="hljs-variable">$pbkdf2</span> = <span class="hljs-title function_ invoke__">base64_decode</span>(<span class="hljs-variable">$params</span>[HASH_PBKDF2_INDEX]);
    <span class="hljs-keyword">return</span> <span class="hljs-title function_ invoke__">slow_equals</span>(
        <span class="hljs-variable">$pbkdf2</span>,
        <span class="hljs-title function_ invoke__">pbkdf2</span>(
            <span class="hljs-variable">$params</span>[HASH_ALGORITHM_INDEX],
            <span class="hljs-variable">$password</span>,
            <span class="hljs-variable">$params</span>[HASH_SALT_INDEX],
            (<span class="hljs-keyword">int</span>)<span class="hljs-variable">$params</span>[HASH_ITERATION_INDEX],
            <span class="hljs-title function_ invoke__">strlen</span>(<span class="hljs-variable">$pbkdf2</span>),
            <span class="hljs-literal">true</span>
        )
    );
}

<span class="hljs-comment">// Compares two strings $a and $b in length-constant time.</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">slow_equals</span>(<span class="hljs-params"><span class="hljs-variable">$a</span>, <span class="hljs-variable">$b</span></span>)
</span>{
    <span class="hljs-variable">$diff</span> = <span class="hljs-title function_ invoke__">strlen</span>(<span class="hljs-variable">$a</span>) ^ <span class="hljs-title function_ invoke__">strlen</span>(<span class="hljs-variable">$b</span>);
    <span class="hljs-keyword">for</span>(<span class="hljs-variable">$i</span> = <span class="hljs-number">0</span>; <span class="hljs-variable">$i</span> &lt; <span class="hljs-title function_ invoke__">strlen</span>(<span class="hljs-variable">$a</span>) &amp;&amp; <span class="hljs-variable">$i</span> &lt; <span class="hljs-title function_ invoke__">strlen</span>(<span class="hljs-variable">$b</span>); <span class="hljs-variable">$i</span>++)
    {
        <span class="hljs-variable">$diff</span> |= <span class="hljs-title function_ invoke__">ord</span>(<span class="hljs-variable">$a</span>[<span class="hljs-variable">$i</span>]) ^ <span class="hljs-title function_ invoke__">ord</span>(<span class="hljs-variable">$b</span>[<span class="hljs-variable">$i</span>]);
    }
    <span class="hljs-keyword">return</span> <span class="hljs-variable">$diff</span> === <span class="hljs-number">0</span>; 
}

<span class="hljs-comment">/*
 * PBKDF2 key derivation function as defined by RSA's PKCS #5: https://www.ietf.org/rfc/rfc2898.txt
 * $algorithm - The hash algorithm to use. Recommended: SHA256
 * $password - The password.
 * $salt - A salt that is unique to the password.
 * $count - Iteration count. Higher is better, but slower. Recommended: At least 1000.
 * $key_length - The length of the derived key in bytes.
 * $raw_output - If true, the key is returned in raw binary format. Hex encoded otherwise.
 * Returns: A $key_length-byte key derived from the password and salt.
 *
 * Test vectors can be found here: https://www.ietf.org/rfc/rfc6070.txt
 *
 * This implementation of PBKDF2 was originally created by https://defuse.ca
 * With improvements by http://www.variations-of-shadow.com
 */</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">pbkdf2</span>(<span class="hljs-params"><span class="hljs-variable">$algorithm</span>, <span class="hljs-variable">$password</span>, <span class="hljs-variable">$salt</span>, <span class="hljs-variable">$count</span>, <span class="hljs-variable">$key_length</span>, <span class="hljs-variable">$raw_output</span> = <span class="hljs-literal">false</span></span>)
</span>{
    <span class="hljs-variable">$algorithm</span> = <span class="hljs-title function_ invoke__">strtolower</span>(<span class="hljs-variable">$algorithm</span>);
    <span class="hljs-keyword">if</span>(!<span class="hljs-title function_ invoke__">in_array</span>(<span class="hljs-variable">$algorithm</span>, <span class="hljs-title function_ invoke__">hash_algos</span>(), <span class="hljs-literal">true</span>))
        <span class="hljs-keyword">die</span>(<span class="hljs-string">'PBKDF2 ERROR: Invalid hash algorithm.'</span>);
    <span class="hljs-keyword">if</span>(<span class="hljs-variable">$count</span> &lt;= <span class="hljs-number">0</span> || <span class="hljs-variable">$key_length</span> &lt;= <span class="hljs-number">0</span>)
        <span class="hljs-keyword">die</span>(<span class="hljs-string">'PBKDF2 ERROR: Invalid parameters.'</span>);

    <span class="hljs-variable">$hash_length</span> = <span class="hljs-title function_ invoke__">strlen</span>(<span class="hljs-title function_ invoke__">hash</span>(<span class="hljs-variable">$algorithm</span>, <span class="hljs-string">""</span>, <span class="hljs-literal">true</span>));
    <span class="hljs-variable">$block_count</span> = <span class="hljs-title function_ invoke__">ceil</span>(<span class="hljs-variable">$key_length</span> / <span class="hljs-variable">$hash_length</span>);

    <span class="hljs-variable">$output</span> = <span class="hljs-string">""</span>;
    <span class="hljs-keyword">for</span>(<span class="hljs-variable">$i</span> = <span class="hljs-number">1</span>; <span class="hljs-variable">$i</span> &lt;= <span class="hljs-variable">$block_count</span>; <span class="hljs-variable">$i</span>++) {
        <span class="hljs-comment">// $i encoded as 4 bytes, big endian.</span>
        <span class="hljs-variable">$last</span> = <span class="hljs-variable">$salt</span> . <span class="hljs-title function_ invoke__">pack</span>(<span class="hljs-string">"N"</span>, <span class="hljs-variable">$i</span>);
        <span class="hljs-comment">// first iteration</span>
        <span class="hljs-variable">$last</span> = <span class="hljs-variable">$xorsum</span> = <span class="hljs-title function_ invoke__">hash_hmac</span>(<span class="hljs-variable">$algorithm</span>, <span class="hljs-variable">$last</span>, <span class="hljs-variable">$password</span>, <span class="hljs-literal">true</span>);
        <span class="hljs-comment">// perform the other $count - 1 iterations</span>
        <span class="hljs-keyword">for</span> (<span class="hljs-variable">$j</span> = <span class="hljs-number">1</span>; <span class="hljs-variable">$j</span> &lt; <span class="hljs-variable">$count</span>; <span class="hljs-variable">$j</span>++) {
            <span class="hljs-variable">$xorsum</span> ^= (<span class="hljs-variable">$last</span> = <span class="hljs-title function_ invoke__">hash_hmac</span>(<span class="hljs-variable">$algorithm</span>, <span class="hljs-variable">$last</span>, <span class="hljs-variable">$password</span>, <span class="hljs-literal">true</span>));
        }
        <span class="hljs-variable">$output</span> .= <span class="hljs-variable">$xorsum</span>;
    }

    <span class="hljs-keyword">if</span>(<span class="hljs-variable">$raw_output</span>)
        <span class="hljs-keyword">return</span> <span class="hljs-title function_ invoke__">substr</span>(<span class="hljs-variable">$output</span>, <span class="hljs-number">0</span>, <span class="hljs-variable">$key_length</span>);
    <span class="hljs-keyword">else</span>
        <span class="hljs-keyword">return</span> <span class="hljs-title function_ invoke__">bin2hex</span>(<span class="hljs-title function_ invoke__">substr</span>(<span class="hljs-variable">$output</span>, <span class="hljs-number">0</span>, <span class="hljs-variable">$key_length</span>));
}
<span class="hljs-meta">?&gt;</span>
</code></pre>
    </div></div></div></div><div id="solution12" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 12</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/hash">hash</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>I usually use SHA1 and salt with the user ID (or some other user-specific piece of information), and sometimes I additionally use a constant salt (so I have 2 parts to the salt).</p>

<p>SHA1 is now also considered somewhat compromised, but to a far lesser degree than MD5.  By using a salt (any salt), you're preventing the use of a generic <a href="http://en.wikipedia.org/wiki/Rainbow_table" rel="noreferrer">rainbow table</a> to attack your hashes (some people have even had success using Google as a sort of rainbow table by searching for the hash).  An attacker could conceivably generate a rainbow table using your salt, so that's why you should include a user-specific salt.  That way, they will have to generate a rainbow table for each and every record in your system, not just one for your entire system!  With that type of salting, even MD5 is decently secure.</p>
    </div></div></div></div><div id="solution13" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 13</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/hash">hash</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p><a href="http://php.net/sha1" rel="noreferrer">SHA1</a> and a salt should suffice (depending, naturally, on whether you are coding something for <a href="http://en.wikipedia.org/wiki/United_States_Bullion_Depository" rel="noreferrer">Fort Knox</a> or a login system for your shopping list) for the foreseeable future. If SHA1 isn't good enough for you, use <a href="http://php.net/manual/en/function.hash.php" rel="noreferrer">SHA256</a>.</p>

<p>The idea of a salt is to throw the hashing results off balance, so to say. It is known, for example, that the MD5-hash of an empty string is <code>d41d8cd98f00b204e9800998ecf8427e</code>. So, if someone with good enough a memory would see that hash and know that it's the hash of an empty string. But if the string is salted (say, with the string "<code>MY_PERSONAL_SALT</code>"), the hash for the 'empty string' (i.e. "<code>MY_PERSONAL_SALT</code>") becomes <code>aeac2612626724592271634fb14d3ea6</code>, hence non-obvious to backtrace. What I'm trying to say, that it's better to use <em>any</em> salt, than not to. Therefore, it's not too much of an importance to know <em>which</em> salt to use.</p>

<p>There are actually <a href="http://gdataonline.com/seekhash.php" rel="noreferrer">websites that do just this</a> - you can feed it a (md5) hash, and it spits out a known plaintext that generates that particular hash. If you would get access to a database that stores plain md5-hashes, it would be trivial for you to enter the hash for the admin to such a service, and log in. But, if the passwords were salted, such a service would become ineffective.</p>

<p>Also, double-hashing is generally regarded as bad method, because it diminishes the result space. All popular hashes are fixed-length. Thus, you can have only a finite values of this fixed length, and the results become less varied. This <em>could</em> be regarded as another form of salting, but I wouldn't recommend it.</p>
    </div></div></div></div><div id="solution14" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 14</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/hash">hash</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>ok
in the fitsy we need salt
salt must be unique
so let generate it</p>

<pre class="lang-php s-code-block"><code class="hljs language-php">   <span class="hljs-comment">/**
     * Generating string
     * <span class="hljs-doctag">@param</span> $size
     * <span class="hljs-doctag">@return</span> string
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Uniwur_string</span>(<span class="hljs-params"><span class="hljs-variable">$size</span></span>)</span>{
        <span class="hljs-variable">$text</span> = <span class="hljs-title function_ invoke__">md5</span>(<span class="hljs-title function_ invoke__">uniqid</span>(<span class="hljs-title function_ invoke__">rand</span>(), <span class="hljs-literal">TRUE</span>));
        RETURN <span class="hljs-title function_ invoke__">substr</span>(<span class="hljs-variable">$text</span>, <span class="hljs-number">0</span>, <span class="hljs-variable">$size</span>);
    }
</code></pre>

<p>also we need the hash
I`m using sha512
it is the best and it is in php </p>

<pre class="lang-php s-code-block"><code class="hljs language-php">   <span class="hljs-comment">/**
     * Hashing string
     * <span class="hljs-doctag">@param</span> $string
     * <span class="hljs-doctag">@return</span> string
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">hash</span>(<span class="hljs-params"><span class="hljs-variable">$string</span></span>)</span>{
        <span class="hljs-keyword">return</span> <span class="hljs-title function_ invoke__">hash</span>(<span class="hljs-string">'sha512'</span>, <span class="hljs-variable">$string</span>);
    }
</code></pre>

<p>so now we can use this functions to generate safe password</p>

<pre class="lang-php s-code-block"><code class="hljs language-php"><span class="hljs-comment">// generating unique password</span>
<span class="hljs-variable">$password</span> = <span class="hljs-title function_ invoke__">Uniwur_string</span>(<span class="hljs-number">20</span>); <span class="hljs-comment">// or you can add manual password</span>
<span class="hljs-comment">// generating 32 character salt</span>
<span class="hljs-variable">$salt</span> = <span class="hljs-title function_ invoke__">Uniwur_string</span>(<span class="hljs-number">32</span>);
<span class="hljs-comment">// now we can manipulate this informations</span>

<span class="hljs-comment">// hashin salt for safe</span>
<span class="hljs-variable">$hash_salt</span> = <span class="hljs-title function_ invoke__">hash</span>(<span class="hljs-variable">$salt</span>);
<span class="hljs-comment">// hashing password</span>
<span class="hljs-variable">$hash_psw</span> = <span class="hljs-title function_ invoke__">hash</span>(<span class="hljs-variable">$password</span>.<span class="hljs-variable">$hash_salt</span>);
</code></pre>

<p>now we need to save in database our $hash_psw variable value and $salt variable</p>

<p>and for authorize we will use same steps...</p>

<p>it is the best way to safe our clients passwords...</p>

<p>P.s. for last 2 steps you can use your own algorithm...
but be sure that you can generate this hashed password in the future 
when you need to authorize user...</p>
    </div></div></div></div></div></div><div class="widget"><a href="/questions/what-are-the-rules-about-using-an-underscore-in-a-c++-identifier-1657384557197">What are the rules about using an underscore in a C++ identifier?</a><a href="/questions/how-can-i-vertically-center-a-div-element-for-all-browsers-using-css-1657385488425">How can I vertically center a div element for all browsers using CSS?</a><a href="/questions/%22least-astonishment%22-and-the-mutable-default-argument-1657384412508">&quot;Least Astonishment&quot; and the Mutable Default Argument</a><a href="/questions/is-there-a-built-in-function-for-string-natural-sort-1657388069553">Is there a built in function for string natural sort?</a><a href="/questions/how-can-i-vertically-align-elements-in-a-div-1657385504431">How can I vertically align elements in a div?</a><a href="/questions/using-limit-within-group-by-to-get-n-results-per-group-1657388324167">Using LIMIT within GROUP BY to get N results per group?</a><a href="/questions/how-can-i-upload-files-to-a-server-using-jspservlet-1657384847658">How can I upload files to a server using JSP/Servlet?</a><a href="/questions/how-do-you-convert-a-byte-array-to-a-hexadecimal-string-and-vice-versa-1657388010428">How do you convert a byte array to a hexadecimal string, and vice versa?</a><a href="/questions/when-to-use-virtual-destructors-1657388152135">When to use virtual destructors?</a><a href="/questions/how-to-return-value-from-an-asynchronous-callback-function-duplicate-1657387545611">How to return value from an asynchronous callback function? [duplicate]</a><a href="/questions/the-difference-between-bracket-and-double-bracket-for-accessing-the-elements-of-a-list-or-dataframe-1657388451711">The difference between bracket [ ] and double bracket [[ ]] for accessing the elements of a list or dataframe</a><a href="/questions/most-efficient-method-to-groupby-on-an-array-of-objects-1657387580538">Most efficient method to groupby on an array of objects</a><a href="/questions/why-are-these-numbers-not-equal-1657384729559">Why are these numbers not equal?</a><a href="/questions/reshaping-multiple-sets-of-measurement-columns-(wide-format)-into-single-columns-(long-format)-1657388016983">Reshaping multiple sets of measurement columns (wide format) into single columns (long format)</a><a href="/questions/how-do-i-set-clear-and-toggle-a-single-bit-1657388227052">How do I set, clear, and toggle a single bit?</a><a href="/questions/how-do-i-select-rows-from-a-dataframe-based-on-column-values-1657384901065">How do I select rows from a DataFrame based on column values?</a><a href="/questions/how-do-you-parse-and-process-htmlxml-in-php-1657384351267">How do you parse and process HTML/XML in PHP?</a><a href="/questions/parsing-a-string-to-a-date-in-javascript-1657387782497">Parsing a string to a date in JavaScript</a><a href="/questions/sort-a-maplesskey-valuegreater-by-values-1657387443904">Sort a Map&lt;Key, Value&gt; by values</a><a href="/questions/non-static-variable-cannot-be-referenced-from-a-static-context-1657387386240">Non-static variable cannot be referenced from a static context</a></div></div><span class="cursor-pointer text-lg p-2" style="position:fixed;bottom:20px;left:20px;background:#000;z-index:2000;color:white">Go go top</span></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"data":{"answer":["\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;DISCLAIMER\u0026lt;/strong\u0026gt;: This answer was written in 2008.\u0026lt;/p\u0026gt;\n  \n  \u0026lt;p\u0026gt;Since then, PHP has given us \u0026lt;a href=\u0026quot;http://php.net/manual/en/function.password-hash.php\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;\u0026lt;code\u0026gt;password_hash\u0026lt;/code\u0026gt;\u0026lt;/a\u0026gt; and \u0026lt;a href=\u0026quot;http://php.net/manual/en/function.password-verify.php\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;\u0026lt;code\u0026gt;password_verify\u0026lt;/code\u0026gt;\u0026lt;/a\u0026gt; and, since their introduction, they are the recommended password hashing \u0026amp;amp; checking method.\u0026lt;/p\u0026gt;\n  \n  \u0026lt;p\u0026gt;The theory of the answer is still a good read though.\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;h2\u0026gt;TL;DR\u0026lt;/h2\u0026gt;\n\n\u0026lt;h3\u0026gt;Don\u0026apos;ts\u0026lt;/h3\u0026gt;\n\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;Don\u0026apos;t limit what characters users can enter for passwords. Only idiots do this.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Don\u0026apos;t limit the length of a password. If your users want a sentence with supercalifragilisticexpialidocious in it, don\u0026apos;t prevent them from using it.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Don\u0026apos;t strip or escape HTML and special characters in the password.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Never store your user\u0026apos;s password in plain-text.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Never email a password to your user \u0026lt;em\u0026gt;except when they have lost theirs, and you sent a temporary one.\u0026lt;/em\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Never, ever log passwords in any manner.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Never hash passwords with \u0026lt;a href=\u0026quot;http://arstechnica.com/security/2012/12/oh-great-new-attack-makes-some-password-cracking-faster-easier-than-ever/\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;SHA1\u0026lt;/a\u0026gt; or MD5 or even SHA256! \u0026lt;a href=\u0026quot;http://securityledger.com/new-25-gpu-monster-devours-passwords-in-seconds/\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;Modern crackers\u0026lt;/a\u0026gt; can exceed 60 and 180 billion hashes/second (respectively).\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Don\u0026apos;t mix \u0026lt;a href=\u0026quot;http://blog.ircmaxell.com/2015/03/security-issue-combining-bcrypt-with.html\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;bcrypt and with the \u0026lt;em\u0026gt;raw\u0026lt;/em\u0026gt; output of hash()\u0026lt;/a\u0026gt;, either use hex output or base64_encode it. (This applies to any input that may have a rogue \u0026lt;code\u0026gt;\\0\u0026lt;/code\u0026gt; in it, which can seriously weaken security.)\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\n\u0026lt;h3\u0026gt;Dos\u0026lt;/h3\u0026gt;\n\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;Use scrypt when you can; bcrypt if you cannot.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Use PBKDF2 if you cannot use either bcrypt or scrypt, with SHA2 hashes.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Reset everyone\u0026apos;s passwords when the database is compromised.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Implement a reasonable 8-10 character minimum length, plus require at least 1 upper case letter, 1 lower case letter, a number, and a symbol. This will improve the entropy of the password, in turn making it harder to crack. (See the \u0026quot;What makes a good password?\u0026quot; section for some debate.)\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\n\u0026lt;h2\u0026gt;Why hash passwords anyway?\u0026lt;/h2\u0026gt;\n\n\u0026lt;p\u0026gt;The objective behind hashing passwords is simple: preventing malicious access to user accounts by compromising the database. So the goal of password hashing is to deter a hacker or cracker by costing them too much time or money to calculate the plain-text passwords. And time/cost are the best deterrents in your arsenal.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Another reason that you want a good, robust hash on a user accounts is to give you enough time to change all the passwords in the system. If your database is compromised you will need enough time to at \u0026lt;em\u0026gt;least\u0026lt;/em\u0026gt; lock the system down, if not change every password in the database.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Jeremiah Grossman, CTO of Whitehat Security, \u0026lt;a href=\u0026quot;https://www.whitehatsec.com/blog/cracking-aes-256-dmgs-and-epic-self-pwnage/\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;stated on White Hat Security blog\u0026lt;/a\u0026gt; after a recent password recovery that required brute-force breaking of his password protection:\u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;Interestingly, in living out this nightmare, I learned A LOT I didnt know about password cracking, storage, and complexity. \u0026lt;em\u0026gt;Ive come to appreciate why password storage is ever so much more important than password complexity. If you dont know how your password is stored, then all you really can depend upon is complexity.\u0026lt;/em\u0026gt; This might be common knowledge to password and crypto pros, but for the average InfoSec or Web Security expert, I highly doubt it.\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;p\u0026gt;(Emphasis mine.)\u0026lt;/p\u0026gt;\n\n\u0026lt;h2\u0026gt;What makes a \u0026lt;em\u0026gt;good\u0026lt;/em\u0026gt; password anyway?\u0026lt;/h2\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;a href=\u0026quot;http://xkcd.com/936/\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;Entropy\u0026lt;/a\u0026gt;. (Not that I fully subscribe to Randall\u0026apos;s viewpoint.)\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;In short, entropy is how much variation is within the password. When a password is only lowercase roman letters, that\u0026apos;s only 26 characters. That isn\u0026apos;t much variation. Alpha-numeric passwords are better, with 36 characters. But allowing upper and lower case, with symbols, is roughly 96 characters. That\u0026apos;s a lot better than just letters. One problem is, to make our passwords memorable we insert patternswhich reduces entropy. Oops!\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Password entropy is \u0026lt;a href=\u0026quot;https://ritcyberselfdefense.wordpress.com/2011/09/24/how-to-calculate-password-entropy/\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;approximated\u0026lt;/a\u0026gt; easily. Using the full range of ascii characters (roughly 96 typeable characters) yields an entropy of 6.6 per character, which at 8 characters for a password is still too low (52.679 bits of entropy) for future security. But the good news is: longer passwords, and passwords with unicode characters, really increase the entropy of a password and make it harder to crack.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;There\u0026apos;s a longer discussion of password entropy on the \u0026lt;a href=\u0026quot;https://crypto.stackexchange.com/questions/374/how-should-i-calculate-the-entropy-of-a-password\u0026quot;\u0026gt;Crypto StackExchange\u0026lt;/a\u0026gt; site. A good Google search will also turn up a lot of results.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;In the comments I talked with @popnoodles, who pointed out that \u0026lt;em\u0026gt;enforcing\u0026lt;/em\u0026gt; a password policy of X length with X many letters, numbers, symbols, etc, can actually reduce entropy by making the password scheme more predictable. I do agree. Randomess, as truly random as possible, is always the safest but least memorable solution.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;So far as I\u0026apos;ve been able to tell, making the world\u0026apos;s best password is a Catch-22. Either its not memorable, too predictable, too short, too many unicode characters (hard to type on a Windows/Mobile device), too long, etc. No password is truly good enough for our purposes, so we must protect them as though they were in Fort Knox.\u0026lt;/p\u0026gt;\n\n\u0026lt;h2\u0026gt;Best practices\u0026lt;/h2\u0026gt;\n\n\u0026lt;p\u0026gt;Bcrypt and \u0026lt;a href=\u0026quot;http://www.tarsnap.com/scrypt.html\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;scrypt\u0026lt;/a\u0026gt; are the current best practices. \u0026lt;a href=\u0026quot;http://www.tarsnap.com/scrypt.html\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;Scrypt\u0026lt;/a\u0026gt; will be better than bcrypt in time, but it hasn\u0026apos;t seen adoption as a standard by Linux/Unix or by webservers, and hasn\u0026apos;t had in-depth reviews of its algorithm posted yet. But still, the future of the algorithm does look promising. If you are working with Ruby there is an \u0026lt;a href=\u0026quot;http://rubygems.org/gems/scrypt\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;scrypt gem\u0026lt;/a\u0026gt; that will help you out, and Node.js now has its own \u0026lt;a href=\u0026quot;https://npmjs.org/package/scrypt\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;scrypt\u0026lt;/a\u0026gt; package. You can use Scrypt in PHP either via the \u0026lt;a href=\u0026quot;https://pecl.php.net/package/scrypt\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;Scrypt\u0026lt;/a\u0026gt; extension or the \u0026lt;a href=\u0026quot;https://paragonie.com/book/pecl-libsodium/read/07-password-hashing.md\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;Libsodium\u0026lt;/a\u0026gt; extension (both are available in PECL).\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;I highly suggest reading the documentation for the \u0026lt;a href=\u0026quot;http://us.php.net/crypt\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;crypt function\u0026lt;/a\u0026gt; if you want to understand how to use bcrypt, or finding yourself a \u0026lt;a href=\u0026quot;https://stackoverflow.com/questions/4795385/how-do-you-use-bcrypt-for-hashing-passwords-in-php/6337021#6337021\u0026quot;\u0026gt;good\u0026lt;/a\u0026gt; \u0026lt;a href=\u0026quot;https://gist.github.com/1070401\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;wrapper\u0026lt;/a\u0026gt; or use something like \u0026lt;a href=\u0026quot;http://www.openwall.com/phpass/\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;PHPASS\u0026lt;/a\u0026gt; for a more legacy implementation. I recommend a minimum of 12 rounds of bcrypt, if not 15 to 18.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;I changed my mind about using bcrypt when I learned that bcrypt only uses blowfish\u0026apos;s key schedule, with a variable cost mechanism. The latter lets you increase the cost to brute-force a password by increasing blowfish\u0026apos;s already expensive key schedule.\u0026lt;/p\u0026gt;\n\n\u0026lt;h2\u0026gt;Average practices\u0026lt;/h2\u0026gt;\n\n\u0026lt;p\u0026gt;I almost can\u0026apos;t imagine this situation anymore. \u0026lt;a href=\u0026quot;http://www.openwall.com/phpass/\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;PHPASS\u0026lt;/a\u0026gt; supports PHP 3.0.18 through 5.3, so it is usable on almost every installation imaginableand should be used if you don\u0026apos;t \u0026lt;em\u0026gt;know for certain\u0026lt;/em\u0026gt; that your environment supports bcrypt.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;But suppose that you cannot use bcrypt or PHPASS at all. What then?\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Try an implementation of \u0026lt;a href=\u0026quot;http://www.itnewb.com/tutorial/Encrypting-Passwords-with-PHP-for-Storage-Using-the-RSA-PBKDF2-Standard\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;PDKBF2\u0026lt;/a\u0026gt; with the \u0026lt;a href=\u0026quot;https://security.stackexchange.com/questions/3959/recommended-of-iterations-when-using-pkbdf2-sha256\u0026quot;\u0026gt;maximum number of rounds\u0026lt;/a\u0026gt; that your environment/application/user-perception can tolerate. The lowest number I\u0026apos;d recommend is 2500 rounds. Also, make sure to use \u0026lt;a href=\u0026quot;http://php.net/hash_hmac\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;hash_hmac()\u0026lt;/a\u0026gt; if it is available to make the operation harder to reproduce.\u0026lt;/p\u0026gt;\n\n\u0026lt;h2\u0026gt;Future Practices\u0026lt;/h2\u0026gt;\n\n\u0026lt;p\u0026gt;Coming in PHP 5.5 is a \u0026lt;a href=\u0026quot;http://php.net/manual/en/ref.password.php\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;full password protection library\u0026lt;/a\u0026gt; that abstracts away any pains of working with bcrypt. While most of us are stuck with PHP 5.2 and 5.3 in most common environments, especially shared hosts, @ircmaxell has built a \u0026lt;a href=\u0026quot;https://github.com/ircmaxell/password_compat\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;compatibility layer\u0026lt;/a\u0026gt; for the coming API that is backward compatible to PHP 5.3.7.\u0026lt;/p\u0026gt;\n\n\u0026lt;h2\u0026gt;Cryptography Recap \u0026amp;amp; Disclaimer\u0026lt;/h2\u0026gt;\n\n\u0026lt;p\u0026gt;The computational power required to actually \u0026lt;em\u0026gt;crack\u0026lt;/em\u0026gt; a hashed password doesn\u0026apos;t exist. The only way for computers to \u0026quot;crack\u0026quot; a password is to recreate it and simulate the hashing algorithm used to secure it. The speed of the hash is linearly related to its ability to be brute-forced. Worse still, most hash algorithms can be easily parallelized to perform even faster. This is why costly schemes like bcrypt and scrypt are so important.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;You cannot possibly foresee all threats or avenues of attack, and so you must make your best effort to protect your users \u0026lt;strong\u0026gt;up front\u0026lt;/strong\u0026gt;. If you do not, then you might even miss the fact that you were attacked until it\u0026apos;s too late... \u0026lt;em\u0026gt;and you\u0026apos;re liable\u0026lt;/em\u0026gt;. To avoid that situation, act paranoid to begin with. Attack your own software (internally) and attempt to steal user credentials, or modify other user\u0026apos;s accounts or access their data. If you don\u0026apos;t test the security of your system, then you cannot blame anyone but yourself.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Lastly: I am not a cryptographer. Whatever I\u0026apos;ve said is my opinion, but I happen to think it\u0026apos;s based on good ol\u0026apos; common sense ... and lots of reading. Remember, be as paranoid as possible, make things as hard to intrude as possible, and then, if you are still worried, contact a white-hat hacker or cryptographer to see what they say about your code/system.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;A much shorter and safer answer - \u0026lt;strong\u0026gt;don\u0026apos;t write your own password mechanism at all\u0026lt;/strong\u0026gt;, use a tried and tested mechanism.\u0026lt;/p\u0026gt;\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;PHP 5.5 or higher: \u0026lt;a href=\u0026quot;http://php.net/manual/en/function.password-hash.php\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;password_hash()\u0026lt;/a\u0026gt; is good quality and part of PHP core.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;PHP 4.x (obsolete): OpenWall\u0026apos;s \u0026lt;a href=\u0026quot;http://www.openwall.com/phpass/\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;phpass\u0026lt;/a\u0026gt; library is much better than most custom code - used in WordPress, Drupal, etc.\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;p\u0026gt;Most programmers just don\u0026apos;t have the expertise to write crypto related code safely without introducing vulnerabilities.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Quick self-test:\u0026lt;/strong\u0026gt; what is password stretching and how many iterations should you use?  If you don\u0026apos;t know the answer, you should use \u0026lt;code\u0026gt;password_hash()\u0026lt;/code\u0026gt;, as password stretching is now a critical feature of password mechanisms due to much faster CPUs and the use of \u0026lt;a href=\u0026quot;http://blog.crackpassword.com/2012/07/accelerating-password-recovery-the-addition-of-fpga/\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;GPUs and FPGAs\u0026lt;/a\u0026gt; to crack passwords at rates of \u0026lt;a href=\u0026quot;http://en.wikipedia.org/wiki/Password_cracking#Time_needed_for_password_searches\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;billions of guesses per second\u0026lt;/a\u0026gt; (with GPUs).\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;As of 2012, you could \u0026lt;a href=\u0026quot;http://arstechnica.com/security/2012/12/25-gpu-cluster-cracks-every-standard-windows-password-in-6-hours/\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;crack all 8-character Windows passwords in 6 hours\u0026lt;/a\u0026gt; using 25 GPUs installed in 5 desktop PCs.  This is brute-forcing i.e. enumerating and checking \u0026lt;em\u0026gt;every 8-character Windows password\u0026lt;/em\u0026gt;, including special characters, and is not a dictionary attack. With modern GPUs, you can of course crack more passwords or use fewer GPUs - or rent the GPUs in the cloud for a few hours at reasonable cost.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;There are also many rainbow table attacks on Windows passwords that run on ordinary CPUs and are very fast.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;All this is because Windows \u0026lt;em\u0026gt;still\u0026lt;/em\u0026gt; \u0026lt;a href=\u0026quot;https://docs.microsoft.com/en-us/windows-server/security/kerberos/passwords-technical-overview\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;doesn\u0026apos;t salt or stretch\u0026lt;/a\u0026gt; its passwords, \u0026lt;a href=\u0026quot;https://www.guidingtech.com/61991/cracking-windows-10-password-prevent/\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;even in Windows 10\u0026lt;/a\u0026gt;.  This is still true in 2021.  Don\u0026apos;t make the same mistake as Microsoft did!\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;See also:\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;a href=\u0026quot;https://stackoverflow.com/questions/1581610/how-can-i-store-my-users-passwords-safely/1581919#1581919\u0026quot;\u0026gt;excellent answer\u0026lt;/a\u0026gt; with more about why \u0026lt;code\u0026gt;password_hash()\u0026lt;/code\u0026gt; or \u0026lt;code\u0026gt;phpass\u0026lt;/code\u0026gt; are the best way to go.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;a href=\u0026quot;https://www.nccgroup.trust/us/about-us/newsroom-and-events/blog/2015/march/enough-with-the-salts-updates-on-secure-password-schemes/\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;good blog article\u0026lt;/a\u0026gt; giving recommmended \u0026apos;work factors\u0026apos; (number of iterations) for main algorithms including bcrypt, scrypt and PBKDF2.\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n    ","\n\u0026lt;p\u0026gt;I would not store the password hashed in two different ways, because then the system is at least as weak as the weakest of the hash algorithms in use.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;As of PHP 5.5, PHP has simple, secure functions for hashing and verifying passwords, \u0026lt;a href=\u0026quot;http://php.net/manual/en/function.password-hash.php\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;password_hash()\u0026lt;/a\u0026gt; and \u0026lt;a href=\u0026quot;http://php.net/manual/en/function.password-verify.php\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;password_verify()\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-php s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-php\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$password\u0026lt;/span\u0026gt; = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;anna\u0026apos;\u0026lt;/span\u0026gt;;\n\u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$hash\u0026lt;/span\u0026gt; = \u0026lt;span class=\u0026quot;hljs-title function_ invoke__\u0026quot;\u0026gt;password_hash\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$password\u0026lt;/span\u0026gt;, PASSWORD_DEFAULT);\n\u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$expensiveHash\u0026lt;/span\u0026gt; = \u0026lt;span class=\u0026quot;hljs-title function_ invoke__\u0026quot;\u0026gt;password_hash\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$password\u0026lt;/span\u0026gt;, PASSWORD_DEFAULT, \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;array\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;cost\u0026apos;\u0026lt;/span\u0026gt; =\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;20\u0026lt;/span\u0026gt;));\n\n\u0026lt;span class=\u0026quot;hljs-title function_ invoke__\u0026quot;\u0026gt;password_verify\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;anna\u0026apos;\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$hash\u0026lt;/span\u0026gt;); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//Returns true\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-title function_ invoke__\u0026quot;\u0026gt;password_verify\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;anna\u0026apos;\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$expensiveHash\u0026lt;/span\u0026gt;); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//Also returns true\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-title function_ invoke__\u0026quot;\u0026gt;password_verify\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;elsa\u0026apos;\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$hash\u0026lt;/span\u0026gt;); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//Returns false\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;When \u0026lt;code\u0026gt;password_hash()\u0026lt;/code\u0026gt; is used, it generates a random salt and includes it in the outputted hash (along with the the cost and algorithm used.) \u0026lt;code\u0026gt;password_verify()\u0026lt;/code\u0026gt; then reads that hash and determines the salt and encryption method used, and verifies it against the provided plaintext password.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Providing the \u0026lt;code\u0026gt;PASSWORD_DEFAULT\u0026lt;/code\u0026gt; instructs PHP to use the default hashing algorithm of the installed version of PHP. Exactly which algorithm that means is intended to change over time in future versions, so that it will always be one of the strongest available algorithms.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Increasing cost (which defaults to 10) makes the hash harder to brute-force but also means generating hashes and verifying passwords against them will be more work for your server\u0026apos;s CPU.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Note that even though the default hashing algorithm may change, old hashes will continue to verify just fine because the algorithm used is stored in the hash and \u0026lt;code\u0026gt;password_verify()\u0026lt;/code\u0026gt; picks up on it.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Though the question has been answered, I just want to reiterate that salts used for hashing should be random and not like email address as suggested in first answer. \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;More explanation is available at- \u0026lt;a href=\u0026quot;http://www.pivotalsecurity.com/blog/password-hashing-salt-should-it-be-random/\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;http://www.pivotalsecurity.com/blog/password-hashing-salt-should-it-be-random/\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;Recently I had a discussion whether password hashes salted with random\n  bits are more secure than the one salted with guessable or known\n  salts. Lets see: If the system storing password is compromised as\n  well as the system which stores the random salt, the attacker will\n  have access to hash as well as salt, so whether the salt is random or\n  not, doesnt matter. The attacker will can generate pre-computed\n  rainbow tables to crack the hash. Here comes the interesting part- it\n  is not so trivial to generate pre-computed tables. Let us take example\n  of WPA security model. Your WPA password is actually never sent to\n  Wireless Access Point. Instead, it is hashed with your SSID (the\n  network name- like Linksys, Dlink etc). A very good explanation of how\n  this works is here. In order to retrieve password from hash, you will\n  need to know the password as well as salt (network name). Church of\n  Wifi has already pre-computed hash tables which has top 1000 SSIDs and\n  about 1 million passwords. The size is of all tables is about 40 GB.\n  As you can read on their site, someone used 15 FGPA arrays for 3 days\n  to generate  these tables. Assuming victim is using the SSID as\n  a387csf3 and password as 123456, will it be cracked by those\n  tables? No! .. it cannot. Even if the password is weak, the tables\n  dont have hashes for SSID a387csf3.  This is the beauty of having\n  random salt. It will deter crackers who thrive upon pre-computed\n  tables. Can it stop a determined hacker? Probably not. But using\n  random salts does provide additional layer of defense. While we are on\n  this topic, let us discuss additional advantage of storing random\n  salts on a separate system. Scenario #1 : Password hashes are stored\n  on system X and salt values used for hashing are stored on system Y.\n  These salt values are guessable or known (e.g. username) Scenario#2 :\n  Password hashes are stored on system X and salt values used for\n  hashing are stored on system Y. These salt values are random. In case\n  system X has been compromised, as you can guess, there is a huge\n  advantage of using random salt on a separate system (Scenario #2) .\n  The attacker will need to guess addition values to be able to crack\n  hashes. If a 32 bit salt is used, 2^32= 4,294,967,296 (about 4.2\n  billion) iterations will can be required for each password guessed.\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n    ","\n\u0026lt;p\u0026gt;I just want to point out that PHP 5.5 includes a \u0026lt;a href=\u0026quot;http://www.php.net/manual/en/ref.password.php\u0026quot;\u0026gt;password hashing API\u0026lt;/a\u0026gt; that provides a wrapper around \u0026lt;code\u0026gt;crypt()\u0026lt;/code\u0026gt;. This API significantly simplifies the task of hashing, verifying and rehashing password hashes. The author has also released a \u0026lt;a href=\u0026quot;https://github.com/ircmaxell/password_compat\u0026quot;\u0026gt;compatibility pack\u0026lt;/a\u0026gt; (in the form of a single password.php file that you simply \u0026lt;code\u0026gt;require\u0026lt;/code\u0026gt; to use), for those using PHP 5.3.7 and later and want to use this right now.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;It only supports BCRYPT for now, but it aims to be easily extended to include other password hashing techniques and because the technique and cost is stored as part of the hash, changes to your prefered hashing technique/cost will not invalidate current hashes, the framework will automagically, use the correct technique/cost when validating. It also handles generating a \u0026quot;secure\u0026quot; salt if you do not explicitly define your own.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;The API exposes four functions:\u0026lt;/p\u0026gt;\n\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;code\u0026gt;password_get_info()\u0026lt;/code\u0026gt; - returns information about the given hash\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;code\u0026gt;password_hash()\u0026lt;/code\u0026gt; - creates a password hash\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;code\u0026gt;password_needs_rehash()\u0026lt;/code\u0026gt; - checks if the given hash matches the given options. Useful to check if the hash conforms to your current technique/cost scheme allowing you to rehash if necessary\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;code\u0026gt;password_verify()\u0026lt;/code\u0026gt; - verifies that a password matches a hash\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\n\u0026lt;p\u0026gt;At the moment these functions accept the PASSWORD_BCRYPT and PASSWORD_DEFAULT password constants, which are synonymous at the moment, the difference being that PASSWORD_DEFAULT \u0026quot;may change in newer PHP releases when newer, stronger hashing algorithms are supported.\u0026quot; Using PASSWORD_DEFAULT and password_needs_rehash() on login (and rehashing if necessary) should ensure that your hashes are reasonably resilient to brute-force attacks with little to no work for you.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;EDIT: I just realised that this is mentioned briefly in Robert K\u0026apos;s answer. I\u0026apos;ll leave this answer here since I think it provides a bit more information about how it works and the ease of use it provides for those who don\u0026apos;t know security.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;I\u0026apos;m using \u0026lt;a href=\u0026quot;http://www.openwall.com/phpass/\u0026quot;\u0026gt;Phpass\u0026lt;/a\u0026gt; which is a simple one-file PHP class that could be implemented very easily in nearly every PHP project. See also \u0026lt;a href=\u0026quot;http://www.h-online.com/security/features/Storing-passwords-in-uncrackable-form-1255576.html?page=4\u0026quot;\u0026gt;The H\u0026lt;/a\u0026gt;.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;By default it used strongest available encryption that is implemented in Phpass, which is \u0026lt;code\u0026gt;bcrypt\u0026lt;/code\u0026gt; and falls back to other encryptions down to MD5 to provide backward compatibility to frameworks like Wordpress.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;The returned hash could be stored in database as it is. Sample use for generating hash is:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-php s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-php\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$t_hasher\u0026lt;/span\u0026gt; = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;PasswordHash\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;8\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;FALSE\u0026lt;/span\u0026gt;);\n\u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$hash\u0026lt;/span\u0026gt; = \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$t_hasher\u0026lt;/span\u0026gt;-\u0026amp;gt;\u0026lt;span class=\u0026quot;hljs-title function_ invoke__\u0026quot;\u0026gt;HashPassword\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$password\u0026lt;/span\u0026gt;);\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;To verify password, one can use:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-php s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-php\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$t_hasher\u0026lt;/span\u0026gt; = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;PasswordHash\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;8\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;FALSE\u0026lt;/span\u0026gt;);\n\u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$check\u0026lt;/span\u0026gt; = \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$t_hasher\u0026lt;/span\u0026gt;-\u0026amp;gt;\u0026lt;span class=\u0026quot;hljs-title function_ invoke__\u0026quot;\u0026gt;CheckPassword\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$password\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$hash\u0026lt;/span\u0026gt;);\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;THINGS TO REMEMBER\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;A lot has been said about Password encryption for PHP, most of which is very good advice, but before you even start the process of using PHP for password encryption make sure you have the following implemented or ready to be implemented.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;SERVER\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;em\u0026gt;PORTS\u0026lt;/em\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;No matter how good your encryption is if you don\u0026apos;t properly secure the server that runs the PHP and DB all your efforts are worthless. Most servers function relatively the same way, they have ports assigned to allow you to access them remotely either through ftp or shell. Make sure that you change the default port of which ever remote connection you have active. By not doing this you in effect have made the attacker do one less step in accessing your system. \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;em\u0026gt;USERNAME\u0026lt;/em\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;For all that is good in the world do not use the username admin, root or something similar. Also if you are on a unix based system DO NOT make the root account login accessible, it should always be sudo only.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;em\u0026gt;PASSWORD\u0026lt;/em\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;You tell your users to make good passwords to avoid getting hacked, do the same. What is the point in going through all the effort of locking your front door when you have the backdoor wide open.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;DATABASE\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;em\u0026gt;SERVER\u0026lt;/em\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Ideally you want your DB and APPLICATION on separate servers. This is not always possible due to cost, but it does allow for some safety as the attacker will have to go through two steps to fully access the system.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;em\u0026gt;USER\u0026lt;/em\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Always have your application have its own account to access the DB, and only give it the privileges it will need. \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Then have a separate user account for you that is not stored anywhere on the server, not even in the application. \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Like always DO NOT make this root or something similar.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;em\u0026gt;PASSWORD\u0026lt;/em\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Follow the same guidelines as with all good passwords. Also don\u0026apos;t reuse the same password on any SERVER or DB accounts on the same system.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;PHP\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;em\u0026gt;PASSWORD\u0026lt;/em\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;NEVER EVER store a password in your DB, instead store the hash and unique salt, I will explain why later.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;em\u0026gt;HASHING\u0026lt;/em\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;ONE WAY HASHING!!!!!!!, Never hash a password in a way that it can be reversed, Hashes should be one way, meaning you don\u0026apos;t reverse them and compare them to the password, you instead hash the entered password the same way and compare the two hashes. This means that even if an attacker gets access to the DB he doesn\u0026apos;t know what the actually password is, just its resulting hash. Which means more security for your users in the worst possible scenario.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;There are a lot of good hashing functions out there (\u0026lt;code\u0026gt;password_hash\u0026lt;/code\u0026gt;, \u0026lt;code\u0026gt;hash\u0026lt;/code\u0026gt;, etc...) but you need to select a good algorithm for the hash to be effective. (bcrypt and ones similar to it are decent algorithms.) \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;When hashing speed is the key, the slower the more resistant to Brute Force attacks. \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;One of the most common mistakes in hashing is that hashes are not unique to the users. This is mainly because salts are not uniquely generated.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;em\u0026gt;SALTING\u0026lt;/em\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Passwords should always be salted before hashed. Salting adds a random string to the password so similar passwords don\u0026apos;t appear the same in the DB. However if the salt is not unique to each user (ie: you use a hard coded salt) than you pretty much have made your salt worthless. Because once an attacker figures out one password salt he has the salt for all of them. \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;When you create a salt make sure it is unique to the password it is salting, then store both the completed hash and salt in your DB. What this will do is make it so that an attacker will have to individually crack each salt and hash before they can gain access. This means a lot more work and time for the attacker. \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;em\u0026gt;USERS CREATING PASSWORDS\u0026lt;/em\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;If the user is creating a password through the frontend that means it has to be sent to the server. This opens up a security issue because that means the unencrypted password is being sent to the server and if a attacker is able to listen and access that all your security in PHP is worthless. ALWAYS transmit the data SECURELY, this is done through SSL, but be weary even SSL is not flawless (OpenSSL\u0026apos;s Heartbleed flaw is an example of this). \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Also make the user create a secure password, it is simple and should always be done, the user will be grateful for it in the end.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Finally, no matter the security measures you take nothing is 100% secure, the more advanced the technology to protect becomes the more advanced the attacks become. But following these steps will make your site more secure and far less desirable for attackers to go after.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Here is a PHP class that creates a hash and salt for a password easily\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;a href=\u0026quot;http://git.io/mSJqpw\u0026quot;\u0026gt;http://git.io/mSJqpw\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Google says SHA256 is available to PHP.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;You should definitely use a salt. I\u0026apos;d recommend using random bytes (and not restrict yourself to characters and numbers). As usually, the longer you choose, the safer, slower it gets. 64 bytes ought to be fine, i guess.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;In the end, double-hashing, mathematically, provides no benefit.  In practice, however, it is useful for preventing rainbow table-based attacks.  In other words, it is of no more benefit than hashing with a salt, which takes far less processor time in your application or on your server.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;I found perfect topic on this matter here: \u0026lt;a href=\u0026quot;https://crackstation.net/hashing-security.htm\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;https://crackstation.net/hashing-security.htm\u0026lt;/a\u0026gt;, I wanted you to get benefit from it, here is source code also that provided prevention against time-based attack also.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-php s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-php\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;\u0026amp;lt;?php\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;/*\n * Password hashing with PBKDF2.\n * Author: havoc AT defuse.ca\n * www: https://defuse.ca/php-pbkdf2.htm\n */\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// These constants may be changed without breaking existing hashes.\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-title function_ invoke__\u0026quot;\u0026gt;define\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;PBKDF2_HASH_ALGORITHM\u0026quot;\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;sha256\u0026quot;\u0026lt;/span\u0026gt;);\n\u0026lt;span class=\u0026quot;hljs-title function_ invoke__\u0026quot;\u0026gt;define\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;PBKDF2_ITERATIONS\u0026quot;\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1000\u0026lt;/span\u0026gt;);\n\u0026lt;span class=\u0026quot;hljs-title function_ invoke__\u0026quot;\u0026gt;define\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;PBKDF2_SALT_BYTES\u0026quot;\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;24\u0026lt;/span\u0026gt;);\n\u0026lt;span class=\u0026quot;hljs-title function_ invoke__\u0026quot;\u0026gt;define\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;PBKDF2_HASH_BYTES\u0026quot;\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;24\u0026lt;/span\u0026gt;);\n\n\u0026lt;span class=\u0026quot;hljs-title function_ invoke__\u0026quot;\u0026gt;define\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;HASH_SECTIONS\u0026quot;\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;4\u0026lt;/span\u0026gt;);\n\u0026lt;span class=\u0026quot;hljs-title function_ invoke__\u0026quot;\u0026gt;define\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;HASH_ALGORITHM_INDEX\u0026quot;\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;);\n\u0026lt;span class=\u0026quot;hljs-title function_ invoke__\u0026quot;\u0026gt;define\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;HASH_ITERATION_INDEX\u0026quot;\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;);\n\u0026lt;span class=\u0026quot;hljs-title function_ invoke__\u0026quot;\u0026gt;define\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;HASH_SALT_INDEX\u0026quot;\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;);\n\u0026lt;span class=\u0026quot;hljs-title function_ invoke__\u0026quot;\u0026gt;define\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;HASH_PBKDF2_INDEX\u0026quot;\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3\u0026lt;/span\u0026gt;);\n\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;create_hash\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$password\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;)\n\u0026lt;/span\u0026gt;{\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// format: algorithm:iterations:salt:hash\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$salt\u0026lt;/span\u0026gt; = \u0026lt;span class=\u0026quot;hljs-title function_ invoke__\u0026quot;\u0026gt;base64_encode\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-title function_ invoke__\u0026quot;\u0026gt;mcrypt_create_iv\u0026lt;/span\u0026gt;(PBKDF2_SALT_BYTES, MCRYPT_DEV_URANDOM));\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; PBKDF2_HASH_ALGORITHM . \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;:\u0026quot;\u0026lt;/span\u0026gt; . PBKDF2_ITERATIONS . \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;:\u0026quot;\u0026lt;/span\u0026gt; .  \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$salt\u0026lt;/span\u0026gt; . \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;:\u0026quot;\u0026lt;/span\u0026gt; . \n        \u0026lt;span class=\u0026quot;hljs-title function_ invoke__\u0026quot;\u0026gt;base64_encode\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-title function_ invoke__\u0026quot;\u0026gt;pbkdf2\u0026lt;/span\u0026gt;(\n            PBKDF2_HASH_ALGORITHM,\n            \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$password\u0026lt;/span\u0026gt;,\n            \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$salt\u0026lt;/span\u0026gt;,\n            PBKDF2_ITERATIONS,\n            PBKDF2_HASH_BYTES,\n            \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;true\u0026lt;/span\u0026gt;\n        ));\n}\n\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;validate_password\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$password\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$good_hash\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;)\n\u0026lt;/span\u0026gt;{\n    \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$params\u0026lt;/span\u0026gt; = \u0026lt;span class=\u0026quot;hljs-title function_ invoke__\u0026quot;\u0026gt;explode\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;:\u0026quot;\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$good_hash\u0026lt;/span\u0026gt;);\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-title function_ invoke__\u0026quot;\u0026gt;count\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$params\u0026lt;/span\u0026gt;) \u0026amp;lt; HASH_SECTIONS)\n       \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;false\u0026lt;/span\u0026gt;; \n    \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$pbkdf2\u0026lt;/span\u0026gt; = \u0026lt;span class=\u0026quot;hljs-title function_ invoke__\u0026quot;\u0026gt;base64_decode\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$params\u0026lt;/span\u0026gt;[HASH_PBKDF2_INDEX]);\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_ invoke__\u0026quot;\u0026gt;slow_equals\u0026lt;/span\u0026gt;(\n        \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$pbkdf2\u0026lt;/span\u0026gt;,\n        \u0026lt;span class=\u0026quot;hljs-title function_ invoke__\u0026quot;\u0026gt;pbkdf2\u0026lt;/span\u0026gt;(\n            \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$params\u0026lt;/span\u0026gt;[HASH_ALGORITHM_INDEX],\n            \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$password\u0026lt;/span\u0026gt;,\n            \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$params\u0026lt;/span\u0026gt;[HASH_SALT_INDEX],\n            (\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;)\u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$params\u0026lt;/span\u0026gt;[HASH_ITERATION_INDEX],\n            \u0026lt;span class=\u0026quot;hljs-title function_ invoke__\u0026quot;\u0026gt;strlen\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$pbkdf2\u0026lt;/span\u0026gt;),\n            \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;true\u0026lt;/span\u0026gt;\n        )\n    );\n}\n\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Compares two strings $a and $b in length-constant time.\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;slow_equals\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$a\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$b\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;)\n\u0026lt;/span\u0026gt;{\n    \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$diff\u0026lt;/span\u0026gt; = \u0026lt;span class=\u0026quot;hljs-title function_ invoke__\u0026quot;\u0026gt;strlen\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$a\u0026lt;/span\u0026gt;) ^ \u0026lt;span class=\u0026quot;hljs-title function_ invoke__\u0026quot;\u0026gt;strlen\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$b\u0026lt;/span\u0026gt;);\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$i\u0026lt;/span\u0026gt; = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;; \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$i\u0026lt;/span\u0026gt; \u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-title function_ invoke__\u0026quot;\u0026gt;strlen\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$a\u0026lt;/span\u0026gt;) \u0026amp;amp;\u0026amp;amp; \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$i\u0026lt;/span\u0026gt; \u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-title function_ invoke__\u0026quot;\u0026gt;strlen\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$b\u0026lt;/span\u0026gt;); \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$i\u0026lt;/span\u0026gt;++)\n    {\n        \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$diff\u0026lt;/span\u0026gt; |= \u0026lt;span class=\u0026quot;hljs-title function_ invoke__\u0026quot;\u0026gt;ord\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$a\u0026lt;/span\u0026gt;[\u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$i\u0026lt;/span\u0026gt;]) ^ \u0026lt;span class=\u0026quot;hljs-title function_ invoke__\u0026quot;\u0026gt;ord\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$b\u0026lt;/span\u0026gt;[\u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$i\u0026lt;/span\u0026gt;]);\n    }\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$diff\u0026lt;/span\u0026gt; === \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;; \n}\n\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;/*\n * PBKDF2 key derivation function as defined by RSA\u0026apos;s PKCS #5: https://www.ietf.org/rfc/rfc2898.txt\n * $algorithm - The hash algorithm to use. Recommended: SHA256\n * $password - The password.\n * $salt - A salt that is unique to the password.\n * $count - Iteration count. Higher is better, but slower. Recommended: At least 1000.\n * $key_length - The length of the derived key in bytes.\n * $raw_output - If true, the key is returned in raw binary format. Hex encoded otherwise.\n * Returns: A $key_length-byte key derived from the password and salt.\n *\n * Test vectors can be found here: https://www.ietf.org/rfc/rfc6070.txt\n *\n * This implementation of PBKDF2 was originally created by https://defuse.ca\n * With improvements by http://www.variations-of-shadow.com\n */\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;pbkdf2\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$algorithm\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$password\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$salt\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$count\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$key_length\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$raw_output\u0026lt;/span\u0026gt; = \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;false\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;)\n\u0026lt;/span\u0026gt;{\n    \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$algorithm\u0026lt;/span\u0026gt; = \u0026lt;span class=\u0026quot;hljs-title function_ invoke__\u0026quot;\u0026gt;strtolower\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$algorithm\u0026lt;/span\u0026gt;);\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt;(!\u0026lt;span class=\u0026quot;hljs-title function_ invoke__\u0026quot;\u0026gt;in_array\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$algorithm\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-title function_ invoke__\u0026quot;\u0026gt;hash_algos\u0026lt;/span\u0026gt;(), \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;true\u0026lt;/span\u0026gt;))\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;die\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;PBKDF2 ERROR: Invalid hash algorithm.\u0026apos;\u0026lt;/span\u0026gt;);\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$count\u0026lt;/span\u0026gt; \u0026amp;lt;= \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt; || \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$key_length\u0026lt;/span\u0026gt; \u0026amp;lt;= \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;)\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;die\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;PBKDF2 ERROR: Invalid parameters.\u0026apos;\u0026lt;/span\u0026gt;);\n\n    \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$hash_length\u0026lt;/span\u0026gt; = \u0026lt;span class=\u0026quot;hljs-title function_ invoke__\u0026quot;\u0026gt;strlen\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-title function_ invoke__\u0026quot;\u0026gt;hash\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$algorithm\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;\u0026quot;\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;true\u0026lt;/span\u0026gt;));\n    \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$block_count\u0026lt;/span\u0026gt; = \u0026lt;span class=\u0026quot;hljs-title function_ invoke__\u0026quot;\u0026gt;ceil\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$key_length\u0026lt;/span\u0026gt; / \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$hash_length\u0026lt;/span\u0026gt;);\n\n    \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$output\u0026lt;/span\u0026gt; = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;\u0026quot;\u0026lt;/span\u0026gt;;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$i\u0026lt;/span\u0026gt; = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;; \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$i\u0026lt;/span\u0026gt; \u0026amp;lt;= \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$block_count\u0026lt;/span\u0026gt;; \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$i\u0026lt;/span\u0026gt;++) {\n        \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// $i encoded as 4 bytes, big endian.\u0026lt;/span\u0026gt;\n        \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$last\u0026lt;/span\u0026gt; = \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$salt\u0026lt;/span\u0026gt; . \u0026lt;span class=\u0026quot;hljs-title function_ invoke__\u0026quot;\u0026gt;pack\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;N\u0026quot;\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$i\u0026lt;/span\u0026gt;);\n        \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// first iteration\u0026lt;/span\u0026gt;\n        \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$last\u0026lt;/span\u0026gt; = \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$xorsum\u0026lt;/span\u0026gt; = \u0026lt;span class=\u0026quot;hljs-title function_ invoke__\u0026quot;\u0026gt;hash_hmac\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$algorithm\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$last\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$password\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;true\u0026lt;/span\u0026gt;);\n        \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// perform the other $count - 1 iterations\u0026lt;/span\u0026gt;\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt; (\u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$j\u0026lt;/span\u0026gt; = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;; \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$j\u0026lt;/span\u0026gt; \u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$count\u0026lt;/span\u0026gt;; \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$j\u0026lt;/span\u0026gt;++) {\n            \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$xorsum\u0026lt;/span\u0026gt; ^= (\u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$last\u0026lt;/span\u0026gt; = \u0026lt;span class=\u0026quot;hljs-title function_ invoke__\u0026quot;\u0026gt;hash_hmac\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$algorithm\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$last\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$password\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;true\u0026lt;/span\u0026gt;));\n        }\n        \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$output\u0026lt;/span\u0026gt; .= \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$xorsum\u0026lt;/span\u0026gt;;\n    }\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$raw_output\u0026lt;/span\u0026gt;)\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_ invoke__\u0026quot;\u0026gt;substr\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$output\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$key_length\u0026lt;/span\u0026gt;);\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;else\u0026lt;/span\u0026gt;\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_ invoke__\u0026quot;\u0026gt;bin2hex\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-title function_ invoke__\u0026quot;\u0026gt;substr\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$output\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$key_length\u0026lt;/span\u0026gt;));\n}\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;?\u0026amp;gt;\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;I usually use SHA1 and salt with the user ID (or some other user-specific piece of information), and sometimes I additionally use a constant salt (so I have 2 parts to the salt).\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;SHA1 is now also considered somewhat compromised, but to a far lesser degree than MD5.  By using a salt (any salt), you\u0026apos;re preventing the use of a generic \u0026lt;a href=\u0026quot;http://en.wikipedia.org/wiki/Rainbow_table\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;rainbow table\u0026lt;/a\u0026gt; to attack your hashes (some people have even had success using Google as a sort of rainbow table by searching for the hash).  An attacker could conceivably generate a rainbow table using your salt, so that\u0026apos;s why you should include a user-specific salt.  That way, they will have to generate a rainbow table for each and every record in your system, not just one for your entire system!  With that type of salting, even MD5 is decently secure.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;\u0026lt;a href=\u0026quot;http://php.net/sha1\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;SHA1\u0026lt;/a\u0026gt; and a salt should suffice (depending, naturally, on whether you are coding something for \u0026lt;a href=\u0026quot;http://en.wikipedia.org/wiki/United_States_Bullion_Depository\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;Fort Knox\u0026lt;/a\u0026gt; or a login system for your shopping list) for the foreseeable future. If SHA1 isn\u0026apos;t good enough for you, use \u0026lt;a href=\u0026quot;http://php.net/manual/en/function.hash.php\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;SHA256\u0026lt;/a\u0026gt;.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;The idea of a salt is to throw the hashing results off balance, so to say. It is known, for example, that the MD5-hash of an empty string is \u0026lt;code\u0026gt;d41d8cd98f00b204e9800998ecf8427e\u0026lt;/code\u0026gt;. So, if someone with good enough a memory would see that hash and know that it\u0026apos;s the hash of an empty string. But if the string is salted (say, with the string \u0026quot;\u0026lt;code\u0026gt;MY_PERSONAL_SALT\u0026lt;/code\u0026gt;\u0026quot;), the hash for the \u0026apos;empty string\u0026apos; (i.e. \u0026quot;\u0026lt;code\u0026gt;MY_PERSONAL_SALT\u0026lt;/code\u0026gt;\u0026quot;) becomes \u0026lt;code\u0026gt;aeac2612626724592271634fb14d3ea6\u0026lt;/code\u0026gt;, hence non-obvious to backtrace. What I\u0026apos;m trying to say, that it\u0026apos;s better to use \u0026lt;em\u0026gt;any\u0026lt;/em\u0026gt; salt, than not to. Therefore, it\u0026apos;s not too much of an importance to know \u0026lt;em\u0026gt;which\u0026lt;/em\u0026gt; salt to use.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;There are actually \u0026lt;a href=\u0026quot;http://gdataonline.com/seekhash.php\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;websites that do just this\u0026lt;/a\u0026gt; - you can feed it a (md5) hash, and it spits out a known plaintext that generates that particular hash. If you would get access to a database that stores plain md5-hashes, it would be trivial for you to enter the hash for the admin to such a service, and log in. But, if the passwords were salted, such a service would become ineffective.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Also, double-hashing is generally regarded as bad method, because it diminishes the result space. All popular hashes are fixed-length. Thus, you can have only a finite values of this fixed length, and the results become less varied. This \u0026lt;em\u0026gt;could\u0026lt;/em\u0026gt; be regarded as another form of salting, but I wouldn\u0026apos;t recommend it.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;ok\nin the fitsy we need salt\nsalt must be unique\nso let generate it\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-php s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-php\u0026quot;\u0026gt;   \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;/**\n     * Generating string\n     * \u0026lt;span class=\u0026quot;hljs-doctag\u0026quot;\u0026gt;@param\u0026lt;/span\u0026gt; $size\n     * \u0026lt;span class=\u0026quot;hljs-doctag\u0026quot;\u0026gt;@return\u0026lt;/span\u0026gt; string\n     */\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;Uniwur_string\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$size\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;)\u0026lt;/span\u0026gt;{\n        \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$text\u0026lt;/span\u0026gt; = \u0026lt;span class=\u0026quot;hljs-title function_ invoke__\u0026quot;\u0026gt;md5\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-title function_ invoke__\u0026quot;\u0026gt;uniqid\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-title function_ invoke__\u0026quot;\u0026gt;rand\u0026lt;/span\u0026gt;(), \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;TRUE\u0026lt;/span\u0026gt;));\n        RETURN \u0026lt;span class=\u0026quot;hljs-title function_ invoke__\u0026quot;\u0026gt;substr\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$text\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$size\u0026lt;/span\u0026gt;);\n    }\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;also we need the hash\nI`m using sha512\nit is the best and it is in php \u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-php s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-php\u0026quot;\u0026gt;   \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;/**\n     * Hashing string\n     * \u0026lt;span class=\u0026quot;hljs-doctag\u0026quot;\u0026gt;@param\u0026lt;/span\u0026gt; $string\n     * \u0026lt;span class=\u0026quot;hljs-doctag\u0026quot;\u0026gt;@return\u0026lt;/span\u0026gt; string\n     */\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;hash\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$string\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;)\u0026lt;/span\u0026gt;{\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_ invoke__\u0026quot;\u0026gt;hash\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;sha512\u0026apos;\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$string\u0026lt;/span\u0026gt;);\n    }\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;so now we can use this functions to generate safe password\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-php s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-php\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// generating unique password\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$password\u0026lt;/span\u0026gt; = \u0026lt;span class=\u0026quot;hljs-title function_ invoke__\u0026quot;\u0026gt;Uniwur_string\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;20\u0026lt;/span\u0026gt;); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// or you can add manual password\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// generating 32 character salt\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$salt\u0026lt;/span\u0026gt; = \u0026lt;span class=\u0026quot;hljs-title function_ invoke__\u0026quot;\u0026gt;Uniwur_string\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;32\u0026lt;/span\u0026gt;);\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// now we can manipulate this informations\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// hashin salt for safe\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$hash_salt\u0026lt;/span\u0026gt; = \u0026lt;span class=\u0026quot;hljs-title function_ invoke__\u0026quot;\u0026gt;hash\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$salt\u0026lt;/span\u0026gt;);\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// hashing password\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$hash_psw\u0026lt;/span\u0026gt; = \u0026lt;span class=\u0026quot;hljs-title function_ invoke__\u0026quot;\u0026gt;hash\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$password\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;$hash_salt\u0026lt;/span\u0026gt;);\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;now we need to save in database our $hash_psw variable value and $salt variable\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;and for authorize we will use same steps...\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;it is the best way to safe our clients passwords...\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;P.s. for last 2 steps you can use your own algorithm...\nbut be sure that you can generate this hashed password in the future \nwhen you need to authorize user...\u0026lt;/p\u0026gt;\n    "],"id":236,"title":"Secure hash and salt for PHP passwords","content":"\n                \n\u0026lt;p\u0026gt;It is currently said that MD5 is partially unsafe. Taking this into consideration, I\u0026apos;d like to know which mechanism to use for password protection.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;This question, \u0026lt;a href=\u0026quot;https://stackoverflow.com/questions/348109/is-double-hashing-a-password-less-secure-than-just-hashing-it-once\u0026quot;\u0026gt;Is “double hashing” a password less secure than just hashing it once?\u0026lt;/a\u0026gt; \nsuggests that hashing multiple times may be a good idea, whereas \u0026lt;a href=\u0026quot;https://stackoverflow.com/questions/55862/how-to-implement-password-protection-for-individual-files#55904\u0026quot;\u0026gt;How to implement password protection for individual files?\u0026lt;/a\u0026gt; suggests using salt.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;I\u0026apos;m using PHP. I want a safe and fast password encryption system. Hashing a password a million times may be safer, but also slower. How to achieve a good balance between speed and safety? Also, I\u0026apos;d prefer the result to have a constant number of characters.\u0026lt;/p\u0026gt;\n\n\u0026lt;ol\u0026gt;\n\u0026lt;li\u0026gt;The hashing mechanism must be available in PHP\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;It must be safe\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;It can use salt (in this case, are all salts equally good? Is there any way to generate good salts?)\u0026lt;/li\u0026gt;\n\u0026lt;/ol\u0026gt;\n\n\u0026lt;p\u0026gt;Also, should I store two fields in the database (one using MD5 and another one using SHA, for example)? Would it make it safer or unsafer?\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;In case I wasn\u0026apos;t clear enough, I want to know which hashing function(s) to use and how to pick a good salt in order to have a safe and fast password protection mechanism.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;em\u0026gt;Related questions that don\u0026apos;t quite cover my question:\u0026lt;/em\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;a href=\u0026quot;https://stackoverflow.com/questions/157998/whats-the-difference-between-sha-and-md5-in-php\u0026quot;\u0026gt;What\u0026apos;s the difference between SHA and MD5 in PHP\u0026lt;/a\u0026gt;\u0026lt;br\u0026gt;\n\u0026lt;a href=\u0026quot;https://stackoverflow.com/questions/30946/simple-password-encryption\u0026quot;\u0026gt;Simple Password Encryption\u0026lt;/a\u0026gt;\u0026lt;br\u0026gt;\n\u0026lt;a href=\u0026quot;https://stackoverflow.com/questions/198803/secure-methods-of-storing-keys-passwords-for-asp-net\u0026quot;\u0026gt;Secure methods of storing keys, passwords for asp.net\u0026lt;/a\u0026gt;\u0026lt;br\u0026gt;\n\u0026lt;a href=\u0026quot;https://stackoverflow.com/questions/205153/how-would-you-implement-salted-passwords-in-tomcat-5-5\u0026quot;\u0026gt;How would you implement salted passwords in Tomcat 5.5\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n    ","slug":"secure-hash-and-salt-for-php-passwords-1657387363258","postType":"QUESTION","createdAt":"2022-07-09T17:22:43.000Z","updatedAt":"2022-07-09T17:22:43.000Z","tags":[{"id":1569,"name":"hash","slug":"hash","createdAt":"2022-07-09T17:22:43.000Z","updatedAt":"2022-07-09T17:22:43.000Z","Questions_Tags":{"questionId":236,"tagId":1569}}],"relatedQuestions":[{"title":"Secure hash and salt for PHP passwords","slug":"secure-hash-and-salt-for-php-passwords-1657387363258","tags":[{"name":"hash","Questions_Tags":{"questionId":236,"tagId":1569}}]}]},"randomQuestions":[{"title":"What are the rules about using an underscore in a C++ identifier?","slug":"what-are-the-rules-about-using-an-underscore-in-a-c++-identifier-1657384557197"},{"title":"How can I vertically center a div element for all browsers using CSS?","slug":"how-can-i-vertically-center-a-div-element-for-all-browsers-using-css-1657385488425"},{"title":"\"Least Astonishment\" and the Mutable Default Argument","slug":"\"least-astonishment\"-and-the-mutable-default-argument-1657384412508"},{"title":"Is there a built in function for string natural sort?","slug":"is-there-a-built-in-function-for-string-natural-sort-1657388069553"},{"title":"How can I vertically align elements in a div?","slug":"how-can-i-vertically-align-elements-in-a-div-1657385504431"},{"title":"Using LIMIT within GROUP BY to get N results per group?","slug":"using-limit-within-group-by-to-get-n-results-per-group-1657388324167"},{"title":"How can I upload files to a server using JSP/Servlet?","slug":"how-can-i-upload-files-to-a-server-using-jspservlet-1657384847658"},{"title":"How do you convert a byte array to a hexadecimal string, and vice versa?","slug":"how-do-you-convert-a-byte-array-to-a-hexadecimal-string-and-vice-versa-1657388010428"},{"title":"When to use virtual destructors?","slug":"when-to-use-virtual-destructors-1657388152135"},{"title":"How to return value from an asynchronous callback function? [duplicate]","slug":"how-to-return-value-from-an-asynchronous-callback-function-duplicate-1657387545611"},{"title":"The difference between bracket [ ] and double bracket [[ ]] for accessing the elements of a list or dataframe","slug":"the-difference-between-bracket-and-double-bracket-for-accessing-the-elements-of-a-list-or-dataframe-1657388451711"},{"title":"Most efficient method to groupby on an array of objects","slug":"most-efficient-method-to-groupby-on-an-array-of-objects-1657387580538"},{"title":"Why are these numbers not equal?","slug":"why-are-these-numbers-not-equal-1657384729559"},{"title":"Reshaping multiple sets of measurement columns (wide format) into single columns (long format)","slug":"reshaping-multiple-sets-of-measurement-columns-(wide-format)-into-single-columns-(long-format)-1657388016983"},{"title":"How do I set, clear, and toggle a single bit?","slug":"how-do-i-set-clear-and-toggle-a-single-bit-1657388227052"},{"title":"How do I select rows from a DataFrame based on column values?","slug":"how-do-i-select-rows-from-a-dataframe-based-on-column-values-1657384901065"},{"title":"How do you parse and process HTML/XML in PHP?","slug":"how-do-you-parse-and-process-htmlxml-in-php-1657384351267"},{"title":"Parsing a string to a date in JavaScript","slug":"parsing-a-string-to-a-date-in-javascript-1657387782497"},{"title":"Sort a Map\u003cKey, Value\u003e by values","slug":"sort-a-maplesskey-valuegreater-by-values-1657387443904"},{"title":"Non-static variable cannot be referenced from a static context","slug":"non-static-variable-cannot-be-referenced-from-a-static-context-1657387386240"}]},"__N_SSG":true},"page":"/questions/[slug]","query":{"slug":"secure-hash-and-salt-for-php-passwords-1657387363258"},"buildId":"TQ2eYlCSdocSK-hq6gkM0","isFallback":false,"gsp":true,"locale":"en","locales":["en"],"defaultLocale":"en","scriptLoader":[]}</script></body></html>