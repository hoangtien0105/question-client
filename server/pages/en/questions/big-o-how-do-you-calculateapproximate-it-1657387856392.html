<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><meta name="twitter:card" content="summary_large_image"/><meta name="twitter:site" content="@solutionschecker.com"/><meta name="twitter:creator" content="@solutionschecker.com"/><meta property="og:url" content="https://solutionschecker.com"/><meta property="og:type" content="website"/><meta property="og:image" content="https://solutionschecker.com/solutions-checker-banner.png"/><meta property="og:image:alt" content="Find the solution to any question. We focus on finding the fastest possible solution for users. Main topics like coding, learning. - solutionschecker.com"/><link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png"/><link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png"/><link rel="manifest" href="/site.webmanifest"/><script type="application/ld+json">{"@context":"https://schema.org","@type":"Organization","logo":"/logo.svg","url":"https://solutionschecker.com"}</script><link name="keywords" content="solutions checker, solution checker, how to, solution for, check for solution, resolve question, what is, what solution for, find solution"/><script type="application/ld+json">{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"item":{"@id":"https://solutionschecker.com","name":"Home"}},{"@type":"ListItem","position":2,"item":{"@id":"https://solutionschecker.com/questions","name":"Questions"}},{"@type":"ListItem","position":3,"item":{"@id":"https://solutionschecker.com/questions/big-o-how-do-you-calculateapproximate-it-1657387856392","name":"Questions"}}]}</script><title>Big O, how do you calculate/approximate it? | Solution Checker</title><meta name="robots" content="index,follow"/><meta name="description" content="Most people with a degree in CS will certainly know what Big O stands for.
It helps us to measure how well an algorithm scales. 

But I&#x27;m curious, how do you calculate or approximate the complexity of your algorithms?
    "/><meta property="og:title" content="Big O, how do you calculate/approximate it? | Solution Checker"/><meta property="og:description" content="Most people with a degree in CS will certainly know what Big O stands for.
It helps us to measure how well an algorithm scales. 

But I&#x27;m curious, how do you calculate or approximate the complexity of your algorithms?
    "/><script type="application/ld+json">{"@context":"https://schema.org","@type":"QAPage","mainEntity":{"name":"Big O, how do you calculate/approximate it?","text":"Most people with a degree in CS will certainly know what Big O stands for.\nIt helps us to measure how well an algorithm scales. \n\nBut I&apos;m curious, how do you calculate or approximate the complexity of your algorithms?\n    ","answerCount":24,"upVoteCount":500,"suggestedAnswer":[{"text":"I&apos;ll do my best to explain it here on simple terms, but be warned that this topic takes my students a couple of months to finally grasp. You can find more information on the Chapter 2 of the Data Structures and Algorithms in Java book.\n\n\n\nThere is no mechanical procedure that can be used to get the BigOh.\n\nAs a &quot;cookbook&quot;, to obtain the BigOh from a piece of code you first need to realize that you are creating a math formula to count how many steps of computations get executed given an input of some size.\n\nThe purpose is simple: to compare algorithms from a theoretical point of view, without the need to execute the code. The lesser the number of steps, the faster the algorithm.\n\nFor example, let&apos;s say you have this piece of code:\n\nint sum(int* data, int N) {\n    int result = 0;               // 1\n\n    for (int i = 0; i &lt; N; i++) { // 2\n        result += data[i];        // 3\n    }\n\n    return result;                // 4\n}\n\n\nThis function returns the sum of all the elements of the array, and we want to create a formula to count the computational complexity of that function:\n\nNumber_Of_Steps = f(N)\n\n\nSo we have f(N), a function to count the number of computational steps. The input of the function is the size of the structure to process. It means that this function is called such as:\n\nNumber_Of_Steps = f(data.length)\n\n\nThe parameter N takes the data.length value. Now we need the actual definition of the function f(). This is done from the source code, in which each interesting line is numbered from 1 to 4.\n\nThere are many ways to calculate the BigOh. From this point forward we are going to assume that every sentence that doesn&apos;t depend on the size of the input data takes a constant C number computational steps.\n\nWe are going to add the individual number of steps of the function, and neither the local variable declaration nor the return statement depends on the size of the data array.\n\nThat means that lines 1 and 4 takes C amount of steps each, and the function is somewhat like this:\n\nf(N) = C + ??? + C\n\n\nThe next part is to define the value of the for statement. Remember that we are counting the number of computational steps, meaning that the body of the for statement gets executed N times. That&apos;s the same as adding C, N times:\n\nf(N) = C + (C + C + ... + C) + C = C + N * C + C\n\n\nThere is no mechanical rule to count how many times the body of the for gets executed, you need to count it by looking at what does the code do. To simplify the calculations, we are ignoring the variable initialization, condition and increment parts of the for statement.\n\nTo get the actual BigOh we need the Asymptotic analysis of the function. This is roughly done like this:\n\n\nTake away all the constants C.\nFrom f() get the polynomium in its standard form.\nDivide the terms of the polynomium and sort them by the rate of growth.\nKeep the one that grows bigger when N approaches infinity.\n\n\nOur f() has two terms:\n\nf(N) = 2 * C * N ^ 0 + 1 * C * N ^ 1\n\n\nTaking away all the C constants and redundant parts:\n\nf(N) = 1 + N ^ 1\n\n\nSince the last term is the one which grows bigger when f() approaches infinity (think on limits) this is the BigOh argument, and the sum() function has a BigOh of:\n\nO(N)\n\n\n\n\nThere are a few tricks to solve some tricky ones: use summations whenever you can.\n\nAs an example, this code can be easily solved using summations:\n\nfor (i = 0; i &lt; 2*n; i += 2) {  // 1\n    for (j=n; j &gt; i; j--) {     // 2\n        foo();                  // 3\n    }\n}\n\n\nThe first thing you needed to be asked is the order of execution of foo(). While the usual is to be O(1), you need to ask your professors about it. O(1) means (almost, mostly) constant C, independent of the size N.\n\nThe for statement on the sentence number one is tricky. While the index ends at 2 * N, the increment is done by two. That means that the first for gets executed only N steps, and we need to divide the count by two.\n\nf(N) = Summation(i from 1 to 2 * N / 2)( ... ) = \n     = Summation(i from 1 to N)( ... )\n\n\nThe sentence number two is even trickier since it depends on the value of i. Take a look: the index i takes the values: 0, 2, 4, 6, 8, ..., 2 * N, and the second for get executed: N times the first one, N - 2 the second, N - 4 the third... up to the N / 2 stage, on which the second for never gets executed.\n\nOn formula, that means:\n\nf(N) = Summation(i from 1 to N)( Summation(j = ???)(  ) )\n\n\nAgain, we are counting the number of steps. And by definition, every summation should always start at one, and end at a number bigger-or-equal than one.\n\nf(N) = Summation(i from 1 to N)( Summation(j = 1 to (N - (i - 1) * 2)( C ) )\n\n\n(We are assuming that foo() is O(1) and takes C steps.)\n\nWe have a problem here: when i takes the value N / 2 + 1 upwards, the inner Summation ends at a negative number! That&apos;s impossible and wrong. We need to split the summation in two, being the pivotal point the moment i takes N / 2 + 1.\n\nf(N) = Summation(i from 1 to N / 2)( Summation(j = 1 to (N - (i - 1) * 2)) * ( C ) ) + Summation(i from 1 to N / 2) * ( C )\n\n\nSince the pivotal moment i &gt; N / 2, the inner for won&apos;t get executed, and we are assuming a constant C execution complexity on its body.\n\nNow the summations can be simplified using some identity rules:\n\n\nSummation(w from 1 to N)( C ) = N * C\nSummation(w from 1 to N)( A (+/-) B ) = Summation(w from 1 to N)( A ) (+/-) Summation(w from 1 to N)( B )\nSummation(w from 1 to N)( w * C ) = C * Summation(w from 1 to N)( w ) (C is a constant, independent of w)\nSummation(w from 1 to N)( w ) = (N * (N + 1)) / 2\n\n\nApplying some algebra:\n\nf(N) = Summation(i from 1 to N / 2)( (N - (i - 1) * 2) * ( C ) ) + (N / 2)( C )\n\nf(N) = C * Summation(i from 1 to N / 2)( (N - (i - 1) * 2)) + (N / 2)( C )\n\nf(N) = C * (Summation(i from 1 to N / 2)( N ) - Summation(i from 1 to N / 2)( (i - 1) * 2)) + (N / 2)( C )\n\nf(N) = C * (( N ^ 2 / 2 ) - 2 * Summation(i from 1 to N / 2)( i - 1 )) + (N / 2)( C )\n\n=&gt; Summation(i from 1 to N / 2)( i - 1 ) = Summation(i from 1 to N / 2 - 1)( i )\n\nf(N) = C * (( N ^ 2 / 2 ) - 2 * Summation(i from 1 to N / 2 - 1)( i )) + (N / 2)( C )\n\nf(N) = C * (( N ^ 2 / 2 ) - 2 * ( (N / 2 - 1) * (N / 2 - 1 + 1) / 2) ) + (N / 2)( C )\n\n=&gt; (N / 2 - 1) * (N / 2 - 1 + 1) / 2 = \n\n   (N / 2 - 1) * (N / 2) / 2 = \n\n   ((N ^ 2 / 4) - (N / 2)) / 2 = \n\n   (N ^ 2 / 8) - (N / 4)\n\nf(N) = C * (( N ^ 2 / 2 ) - 2 * ( (N ^ 2 / 8) - (N / 4) )) + (N / 2)( C )\n\nf(N) = C * (( N ^ 2 / 2 ) - ( (N ^ 2 / 4) - (N / 2) )) + (N / 2)( C )\n\nf(N) = C * (( N ^ 2 / 2 ) - (N ^ 2 / 4) + (N / 2)) + (N / 2)( C )\n\nf(N) = C * ( N ^ 2 / 4 ) + C * (N / 2) + C * (N / 2)\n\nf(N) = C * ( N ^ 2 / 4 ) + 2 * C * (N / 2)\n\nf(N) = C * ( N ^ 2 / 4 ) + C * N\n\nf(N) = C * 1/4 * N ^ 2 + C * N\n\n\nAnd the BigOh is:\n\nO(N²)\n\n    ","url":"https://solutionschecker.com/questions/big-o-how-do-you-calculateapproximate-it-1657387856392#solution1","@type":"Answer","upvoteCount":0},{"text":"Big O gives the upper bound for time complexity of an algorithm.  It is usually used in conjunction with processing data sets (lists) but can be used elsewhere.  \n\nA few examples of how it&apos;s used in C code.\n\nSay we have an array of n elements\n\nint array[n];\n\n\nIf we wanted to access the first element of the array this would be O(1) since it doesn&apos;t matter how big the array is, it always takes the same constant time to get the first item.\n\nx = array[0];\n\n\nIf we wanted to find a number in the list:\n\nfor(int i = 0; i &lt; n; i++){\n    if(array[i] == numToFind){ return i; }\n}\n\n\nThis would be O(n) since at most we would have to look through the entire list to find our number.  The Big-O is still O(n) even though we might find our number the first try and run through the loop once because Big-O describes the upper bound for an algorithm (omega is for lower bound and theta is for tight bound).\n\nWhen we get to nested loops:\n\nfor(int i = 0; i &lt; n; i++){\n    for(int j = i; j &lt; n; j++){\n        array[j] += 2;\n    }\n}\n\n\nThis is O(n^2) since for each pass of the outer loop ( O(n) ) we have to go through the entire list again so the n&apos;s multiply leaving us with n squared.\n\nThis is barely scratching the surface but when you get to analyzing more complex algorithms complex math involving proofs comes into play.  Hope this familiarizes you with the basics at least though.\n    ","url":"https://solutionschecker.com/questions/big-o-how-do-you-calculateapproximate-it-1657387856392#solution2","@type":"Answer","upvoteCount":0},{"text":"While knowing how to figure out the Big O time for your particular problem is useful, knowing some general cases can go a long way in helping you make decisions in your algorithm.\n\nHere are some of the most common cases, lifted from http://en.wikipedia.org/wiki/Big_O_notation#Orders_of_common_functions:\n\nO(1) - Determining if a number is even or odd; using a constant-size lookup table or hash table\n\nO(logn) - Finding an item in a sorted array with a binary search\n\nO(n) - Finding an item in an unsorted list; adding two n-digit numbers\n\nO(n2) - Multiplying two n-digit numbers by a simple algorithm; adding two n×n matrices; bubble sort or insertion sort\n\nO(n3) - Multiplying two n×n matrices by simple algorithm\n\nO(cn) - Finding the (exact) solution to the traveling salesman problem using dynamic programming; determining if two logical statements are equivalent using brute force\n\nO(n!) - Solving the traveling salesman problem via brute-force search\n\nO(nn) - Often used instead of O(n!) to derive simpler formulas for asymptotic complexity\n    ","url":"https://solutionschecker.com/questions/big-o-how-do-you-calculateapproximate-it-1657387856392#solution3","@type":"Answer","upvoteCount":0},{"text":"Small reminder: the big O notation is used to denote asymptotic complexity (that is, when the size of the problem grows to infinity), and it hides a constant.\n\nThis means that between an algorithm in O(n) and one in O(n2), the fastest is not always the first one (though there always exists a value of n such that for problems of size &gt;n, the first algorithm is the fastest).\n\nNote that the hidden constant very much depends on the implementation!\n\nAlso, in some cases, the runtime is not a deterministic function of the size n of the input. Take sorting using quick sort for example: the time needed to sort an array of n elements is not a constant but depends on the starting configuration of the array. \n\nThere are different time complexities: \n\n\nWorst case (usually the simplest to figure out, though not always very meaningful)\nAverage case (usually much harder to figure out...)\n...\n\n\nA good introduction is An Introduction to the Analysis of Algorithms by R. Sedgewick and P. Flajolet.\n\nAs you say, premature optimisation is the root of all evil, and (if possible) profiling really should always be used when optimising code. It can even help you determine the complexity of your algorithms.\n    ","url":"https://solutionschecker.com/questions/big-o-how-do-you-calculateapproximate-it-1657387856392#solution4","@type":"Answer","upvoteCount":0},{"text":"Seeing the answers here I think we can conclude that most of us do indeed approximate the order of the algorithm by looking at it and use common sense instead of calculating it with, for example, the master method as we were thought at university.\nWith that said I must add that even the professor encouraged us (later on) to actually think about it instead of just calculating it.\n\nAlso I would like to add how it is done for recursive functions:\n\nsuppose we have a function like (scheme code):\n\n(define (fac n)\n    (if (= n 0)\n        1\n            (* n (fac (- n 1)))))\n\n\nwhich recursively calculates the factorial of the given number.\n\nThe first step is to try and determine the performance characteristic for the body of the function only in this case, nothing special is done in the body, just a multiplication (or the return of the value 1).\n\nSo the performance for the body is: O(1) (constant).\n\nNext try and determine this for the number of recursive calls. In this case we have n-1 recursive calls.\n\nSo the performance for the recursive calls is: O(n-1) (order is n, as we throw away the insignificant parts).\n\nThen put those two together and you then have the performance for the whole recursive function:  \n\n1 * (n-1) = O(n)\n\n\n\nPeter, to answer your raised issues; the method I describe here actually handles this quite well. But keep in mind that this is still an approximation and not a full mathematically correct answer. The method described here is also one of the methods we were taught at university, and if I remember correctly was used for far more advanced algorithms than the factorial I used in this example.\nOf course it all depends on how well you can estimate the running time of the body of the function and the number of recursive calls, but that is just as true for the other methods.\n    ","url":"https://solutionschecker.com/questions/big-o-how-do-you-calculateapproximate-it-1657387856392#solution5","@type":"Answer","upvoteCount":0},{"text":"If your cost is a polynomial, just keep the highest-order term, without its multiplier. E.g.:\n\n\n  O((n/2 + 1)*(n/2)) = O(n2/4 + n/2) = O(n2/4) = O(n2)\n\n\nThis doesn&apos;t work for infinite series, mind you. There is no single recipe for the general case, though for some common cases, the following inequalities apply:\n\n\n  O(log N) &lt; O(N) &lt; O(N log N) &lt; O(N2) &lt; O(Nk) &lt; O(en) &lt; O(n!)\n\n    ","url":"https://solutionschecker.com/questions/big-o-how-do-you-calculateapproximate-it-1657387856392#solution6","@type":"Answer","upvoteCount":0},{"text":"I think about it in terms of information. Any problem consists of learning a certain number of bits.\n\nYour basic tool is the concept of decision points and their entropy. The entropy of a decision point is the average information it will give you. For example, if a program contains a decision point with two branches, it&apos;s entropy is the sum of the probability of each branch times the log2 of the inverse probability of that branch. That&apos;s how much you learn by executing that decision.\n\nFor example, an if statement having two branches, both equally likely, has an entropy of 1/2 * log(2/1) + 1/2 * log(2/1) = 1/2 * 1 + 1/2 * 1 = 1. So its entropy is 1 bit.\n\nSuppose you are searching a table of N items, like N=1024. That is a 10-bit problem because log(1024) = 10 bits. So if you can search it with IF statements that have equally likely outcomes, it should take 10 decisions.\n\nThat&apos;s what you get with binary search.\n\nSuppose you are doing linear search. You look at the first element and ask if it&apos;s the one you want. The probabilities are 1/1024 that it is, and 1023/1024 that it isn&apos;t. The entropy of that decision is 1/1024*log(1024/1) + 1023/1024 * log(1024/1023) = 1/1024 * 10 + 1023/1024 * about 0 = about .01 bit. You&apos;ve learned very little! The second decision isn&apos;t much better. That is why linear search is so slow. In fact it&apos;s exponential in the number of bits you need to learn.\n\nSuppose you are doing indexing. Suppose the table is pre-sorted into a lot of bins, and you use some of all of the bits in the key to index directly to the table entry. If there are 1024 bins, the entropy is 1/1024 * log(1024) + 1/1024 * log(1024) + ... for all 1024 possible outcomes. This is 1/1024 * 10 times 1024 outcomes, or 10 bits of entropy for that one indexing operation. That is why indexing search is fast.\n\nNow think about sorting.  You have N items, and you have a list. For each item, you have to search for where the item goes in the list, and then add it to the list. So sorting takes roughly N times the number of steps of the underlying search.\n\nSo sorts based on binary decisions having roughly equally likely outcomes all take about O(N log N) steps. An O(N) sort algorithm is possible if it is based on indexing search.\n\nI&apos;ve found that nearly all algorithmic performance issues can be looked at in this way.\n    ","url":"https://solutionschecker.com/questions/big-o-how-do-you-calculateapproximate-it-1657387856392#solution7","@type":"Answer","upvoteCount":0},{"text":"Lets start from the beginning.\n\nFirst of all, accept the principle that certain simple operations on data can be done in O(1) time, that is, in time that is independent of the size of the input. These primitive operations in C consist of\n\n\nArithmetic operations (e.g. + or %).\nLogical operations (e.g., &amp;&amp;).\nComparison operations (e.g., &lt;=).\nStructure accessing operations (e.g. array-indexing like A[i], or pointer fol-\nlowing with the -&gt; operator).\nSimple assignment such as copying a value into a variable.\nCalls to library functions (e.g., scanf, printf).\n\n\nThe justification for this principle requires a detailed study of the machine instructions (primitive steps) of a typical computer. Each of the described operations can be done with some small number of machine instructions; often only one or two instructions are needed.\nAs a consequence, several kinds of statements in C can be executed in O(1) time, that is, in some constant amount of time independent of input. These simple include\n\n\nAssignment statements that do not involve function calls in their expressions.\nRead statements.\nWrite statements that do not require function calls to evaluate arguments.\nThe jump statements break, continue, goto, and return expression, where\nexpression does not contain a function call.\n\n\nIn C, many for-loops are formed by initializing an index variable to some value and\nincrementing that variable by 1 each time around the loop. The for-loop ends when\nthe index reaches some limit. For instance, the for-loop \n\nfor (i = 0; i &lt; n-1; i++) \n{\n    small = i;\n    for (j = i+1; j &lt; n; j++)\n        if (A[j] &lt; A[small])\n            small = j;\n    temp = A[small];\n    A[small] = A[i];\n    A[i] = temp;\n}\n\n\nuses index variable i. It increments i by 1 each time around the loop, and the iterations\nstop when i reaches n  1.\n\nHowever, for the moment, focus on the simple form of for-loop, where the difference between the final and initial values, divided by the amount by which the index variable is incremented tells us how many times we go around the loop. That count is exact, unless there are ways to exit the loop via a jump statement; it is an upper bound on the number of iterations in any case. \n\nFor instance, the for-loop iterates ((n  1)  0)/1 = n  1 times,\nsince 0 is the initial value of i, n  1 is the highest value reached by i (i.e., when i\nreaches n1, the loop stops and no iteration occurs with i = n1), and 1 is added\nto i at each iteration of the loop.\n\nIn the simplest case, where the time spent in the loop body is the same for each\niteration, we can multiply the big-oh upper bound for the body by the number of\ntimes around the loop. Strictly speaking, we must then add O(1) time to initialize\nthe loop index and O(1) time for the first comparison of the loop index with the\nlimit, because we test one more time than we go around the loop. However, unless\nit is possible to execute the loop zero times, the time to initialize the loop and test\nthe limit once is a low-order term that can be dropped by the summation rule.\n\n\n\nNow consider this example:\n\n(1) for (j = 0; j &lt; n; j++)\n(2)   A[i][j] = 0;\n\n\nWe know that line (1) takes O(1) time. Clearly, we go around the loop n times, as\nwe can determine by subtracting the lower limit from the upper limit found on line\n(1) and then adding 1. Since the body, line (2), takes O(1) time, we can neglect the\ntime to increment j and the time to compare j with n, both of which are also O(1).\nThus, the running time of lines (1) and (2) is the product of n and O(1), which is O(n).\n\nSimilarly, we can bound the running time of the outer loop consisting of lines\n(2) through (4), which is\n\n(2) for (i = 0; i &lt; n; i++)\n(3)     for (j = 0; j &lt; n; j++)\n(4)         A[i][j] = 0;\n\n\nWe have already established that the loop of lines (3) and (4) takes O(n) time.\nThus, we can neglect the O(1) time to increment i and to test whether i &lt; n in\neach iteration, concluding that each iteration of the outer loop takes O(n) time.\n\nThe initialization i = 0 of the outer loop and the (n + 1)st test of the condition\ni &lt; n likewise take O(1) time and can be neglected. Finally, we observe that we go\naround the outer loop n times, taking O(n) time for each iteration, giving a total\nO(n^2) running time.\n\n\n\nA more practical example.\n\n\n    ","url":"https://solutionschecker.com/questions/big-o-how-do-you-calculateapproximate-it-1657387856392#solution8","@type":"Answer","upvoteCount":0},{"text":"If you want to estimate the order of your code empirically rather than by analyzing the code, you could stick in a series of increasing values of n and time your code.  Plot your timings on a log scale.  If the code is O(x^n), the values should fall on a line of slope n.\n\nThis has several advantages over just studying the code.  For one thing, you can see whether you&apos;re in the range where the run time approaches its asymptotic order. Also, you may find that some code that you thought was order O(x) is really order O(x^2), for example, because of time spent in library calls.\n    ","url":"https://solutionschecker.com/questions/big-o-how-do-you-calculateapproximate-it-1657387856392#solution9","@type":"Answer","upvoteCount":0},{"text":"Basically the thing that crops up 90% of the time is just analyzing loops.  Do you have single, double, triple nested loops?  The you have O(n), O(n^2), O(n^3) running time.\n\nVery rarely (unless you are writing a platform with an extensive base library (like for instance, the .NET BCL, or C++&apos;s STL) you will encounter anything that is more difficult than just looking at your loops (for statements, while, goto, etc...)\n    ","url":"https://solutionschecker.com/questions/big-o-how-do-you-calculateapproximate-it-1657387856392#solution10","@type":"Answer","upvoteCount":0},{"text":"Less useful generally, I think, but for the sake of completeness there is also a Big Omega Ω, which defines a lower-bound on an algorithm&apos;s complexity, and a Big Theta Θ, which defines both an upper and lower bound.\n    ","url":"https://solutionschecker.com/questions/big-o-how-do-you-calculateapproximate-it-1657387856392#solution11","@type":"Answer","upvoteCount":0},{"text":"Big O notation is useful because it&apos;s easy to work with and hides unnecessary complications and details (for some definition of unnecessary). One nice way of working out the complexity of divide and conquer algorithms is the tree method. Let&apos;s say you have a version of quicksort with the median procedure, so you split the array into perfectly balanced subarrays every time.\n\nNow build a tree corresponding to all the arrays you work with. At the root you have the original array, the root has two children which are the subarrays. Repeat this until you have single element arrays at the bottom. \n\nSince we can find the median in O(n) time and split the array in two parts in O(n) time, the work done at each node is O(k) where k is the size of the array. Each level of the tree contains (at most) the entire array so the work per level is O(n) (the sizes of the subarrays add up to n, and since we have O(k) per level we can add this up). There are only log(n) levels in the tree since each time we halve the input.\n\nTherefore we can upper bound the amount of work by O(n*log(n)). \n\nHowever, Big O hides some details which we sometimes can&apos;t ignore. Consider computing the Fibonacci sequence with\n\na=0;\nb=1;\nfor (i = 0; i &lt;n; i++) {\n    tmp = b;\n    b = a + b;\n    a = tmp;\n}\n\n\nand lets just assume the a and b are BigIntegers in Java or something that can handle arbitrarily large numbers. Most people would say this is an O(n) algorithm without flinching. The reasoning is that you have n iterations in the for loop and O(1) work in side the loop. \n\nBut Fibonacci numbers are large, the n-th Fibonacci number is exponential in n so just storing it will take on the order of n bytes. Performing addition with big integers will take O(n) amount of work. So the total amount of work done in this procedure is \n\n1 + 2 + 3 + ... + n = n(n-1)/2 = O(n^2)\n\nSo this algorithm runs in quadradic time!\n    ","url":"https://solutionschecker.com/questions/big-o-how-do-you-calculateapproximate-it-1657387856392#solution12","@type":"Answer","upvoteCount":0},{"text":"Familiarity with the algorithms/data structures I use and/or quick glance analysis of iteration nesting.  The difficulty is when you call a library function, possibly multiple times - you can often be unsure of whether you are calling the function unnecessarily at times or what implementation they are using.  Maybe library functions should have a complexity/efficiency measure, whether that be Big O or some other metric, that is available in documentation or even IntelliSense.\n    ","url":"https://solutionschecker.com/questions/big-o-how-do-you-calculateapproximate-it-1657387856392#solution13","@type":"Answer","upvoteCount":0},{"text":"Break down the algorithm into pieces you know the big O notation for, and combine through big O operators. That&apos;s the only way I know of.\n\nFor more information, check the Wikipedia page on the subject.\n    ","url":"https://solutionschecker.com/questions/big-o-how-do-you-calculateapproximate-it-1657387856392#solution14","@type":"Answer","upvoteCount":0},{"text":"As to &quot;how do you calculate&quot; Big O, this is part of Computational complexity theory. For some (many) special cases you may be able to come with some simple heuristics (like multiplying loop counts for nested loops), esp. when all you want is any upper bound estimation, and you do not mind if it is too pessimistic - which I guess is probably what your question is about.\n\nIf you really want to answer your question for any algorithm the best you can do is to apply the theory. Besides of simplistic &quot;worst case&quot; analysis I have found Amortized analysis very useful in practice.\n    ","url":"https://solutionschecker.com/questions/big-o-how-do-you-calculateapproximate-it-1657387856392#solution15","@type":"Answer","upvoteCount":0},{"text":"For the 1st case, the inner loop is executed n-i times, so the total number of executions is the sum for i going from 0 to n-1 (because lower than, not lower than or equal) of the n-i. You get finally n*(n + 1) / 2, so O(n²/2) = O(n²).\n\nFor the 2nd loop, i is between 0 and n included for the outer loop; then the inner loop is executed when j is strictly greater than n, which is then impossible.\n    ","url":"https://solutionschecker.com/questions/big-o-how-do-you-calculateapproximate-it-1657387856392#solution16","@type":"Answer","upvoteCount":0},{"text":"In addition to using the master method (or one of its specializations), I test my algorithms experimentally.  This can&apos;t prove that any particular complexity class is achieved, but it can provide reassurance that the mathematical analysis is appropriate.  To help with this reassurance, I use code coverage tools in conjunction with my experiments, to ensure that I&apos;m exercising all the cases.\n\nAs a very simple example say you wanted to do a sanity check on the speed of the .NET framework&apos;s list sort.  You could write something like the following, then analyze the results in Excel to make sure they did not exceed an n*log(n) curve.\n\nIn this example I measure the number of comparisons, but it&apos;s also prudent to examine the actual time required for each sample size.  However then you must be even more careful that you are just measuring the algorithm and not including artifacts from your test infrastructure.\n\nint nCmp = 0;\nSystem.Random rnd = new System.Random();\n\n// measure the time required to sort a list of n integers\nvoid DoTest(int n)\n{\n   List&lt;int&gt; lst = new List&lt;int&gt;(n);\n   for( int i=0; i&lt;n; i++ )\n      lst[i] = rnd.Next(0,1000);\n\n   // as we sort, keep track of the number of comparisons performed!\n   nCmp = 0;\n   lst.Sort( delegate( int a, int b ) { nCmp++; return (a&lt;b)?-1:((a&gt;b)?1:0)); }\n\n   System.Console.Writeline( &quot;{0},{1}&quot;, n, nCmp );\n}\n\n\n// Perform measurement for a variety of sample sizes.\n// It would be prudent to check multiple random samples of each size, but this is OK for a quick sanity check\nfor( int n = 0; n&lt;1000; n++ )\n   DoTest(n);\n\n    ","url":"https://solutionschecker.com/questions/big-o-how-do-you-calculateapproximate-it-1657387856392#solution17","@type":"Answer","upvoteCount":0},{"text":"Don&apos;t forget to also allow for space complexities that can also be a cause for concern if one has limited memory resources.  So for example you may hear someone wanting a constant space algorithm which is basically a way of saying that the amount of space taken by the algorithm doesn&apos;t depend on any factors inside the code.\n\nSometimes the complexity can come from how many times is something called, how often is a loop executed, how often is memory allocated, and so on is another part to answer this question.\n\nLastly, big O can be used for worst case, best case, and amortization cases where generally it is the worst case that is used for describing how bad an algorithm may be.\n    ","url":"https://solutionschecker.com/questions/big-o-how-do-you-calculateapproximate-it-1657387856392#solution18","@type":"Answer","upvoteCount":0},{"text":"I would like to explain the Big-O in a little bit different aspect.\n\nBig-O is just to compare the complexity of the programs which means how fast are they growing when the inputs are increasing and not the exact time which is spend to do the action.\n\nIMHO in the big-O formulas you better not to use more complex equations (you might just stick to the ones in the following graph.) However you still might use other more precise formula (like 3^n, n^3, ...) but more than that can be sometimes misleading! So better to keep it as simple as possible.\n\n\n\nI would like to emphasize once again that here we don&apos;t want to get an exact formula for our algorithm. We only want to show how it grows when the inputs are growing and compare with the other algorithms in that sense. Otherwise you would better use different methods like bench-marking.\n    ","url":"https://solutionschecker.com/questions/big-o-how-do-you-calculateapproximate-it-1657387856392#solution19","@type":"Answer","upvoteCount":0},{"text":"What often gets overlooked is the expected behavior of your algorithms. It doesn&apos;t change the Big-O of your algorithm, but it does relate to the statement &quot;premature optimization. . ..&quot;\n\nExpected behavior of your algorithm is -- very dumbed down -- how fast you can expect your algorithm to work on data you&apos;re most likely to see. \n\nFor instance, if you&apos;re searching for a value in a list, it&apos;s O(n), but if you know that most lists you see have your value up front, typical behavior of your algorithm is faster. \n\nTo really nail it down, you need to be able to describe the probability distribution of your &quot;input space&quot; (if you need to sort a list, how often is that list already going to be sorted? how often is it totally reversed? how often is it mostly sorted?) It&apos;s not always feasible that you know that, but sometimes you do. \n    ","url":"https://solutionschecker.com/questions/big-o-how-do-you-calculateapproximate-it-1657387856392#solution20","@type":"Answer","upvoteCount":0},{"text":"great question!\n\nDisclaimer: this answer contains false statements see the comments below.\n\nIf you&apos;re using the Big O, you&apos;re talking about the worse case (more on what that means later). Additionally, there is capital theta for average case and a big omega for best case.\n\nCheck out this site for a lovely formal definition of Big O: https://xlinux.nist.gov/dads/HTML/bigOnotation.html\n\n\n  f(n) = O(g(n)) means there are positive constants c and k, such that 0  f(n)  cg(n) for all n  k. The values of c and k must be fixed for the function f and must not depend on n. \n\n\n\n\nOk, so now what do we mean by &quot;best-case&quot; and &quot;worst-case&quot; complexities?\n\nThis is probably most clearly illustrated through examples. For example if we are using linear search to find a number in a sorted array then the worst case is when we decide to search for the last element of the array as this would take as many steps as there are items in the array. The best case would be when we search for the first element since we would be done after the first check.\n\nThe point of all these adjective-case complexities is that we&apos;re looking for a way to graph the amount of time a hypothetical program runs to completion in terms of the size of particular variables. However for many algorithms you can argue that there is not a single time for a particular size of input. Notice that this contradicts with the fundamental requirement of a function, any input should have no more than one output. So we come up with multiple functions to describe an algorithm&apos;s complexity. Now, even though searching an array of size n may take varying amounts of time depending on what you&apos;re looking for in the array and depending proportionally to n, we can create an informative description of the algorithm using best-case, average-case, and worst-case classes.\n\nSorry this is so poorly written and lacks much technical information. But hopefully it&apos;ll make time complexity classes easier to think about. Once you become comfortable with these it becomes a simple matter of parsing through your program and looking for things like for-loops that depend on array sizes and reasoning based on your data structures what kind of input would result in trivial cases and what input would result in worst-cases.\n    ","url":"https://solutionschecker.com/questions/big-o-how-do-you-calculateapproximate-it-1657387856392#solution21","@type":"Answer","upvoteCount":0},{"text":"First of all, the accepted answer is trying to explain nice fancy stuff, \nbut I think, intentionally complicating Big-Oh is not the solution,\nwhich programmers (or at least, people like me) search for.\nBig Oh (in short)\nfunction f(text) {\n  var n = text.length;\n  for (var i = 0; i &lt; n; i++) {\n    f(text.slice(0, n-1))\n  }\n  // ... other JS logic here, which we can ignore ...\n}\n\nBig Oh of above is f(n) = O(n!) where n represents number of items in input set,\nand f represents operation done per item.\n\nBig-Oh notation is the asymptotic upper-bound of the complexity of an algorithm.\nIn programming: The assumed worst-case time taken,\nor assumed maximum repeat count of logic, for size of the input.\nCalculation\nKeep in mind (from above meaning) that; We just need worst-case time and/or maximum repeat count affected by N (size of input),\nThen take another look at (accepted answer&apos;s) example:\nfor (i = 0; i &lt; 2*n; i += 2) {  // line 123\n    for (j=n; j &gt; i; j--) {     // line 124\n        foo();                  // line 125\n    }\n}\n\n\nBegin with this search-pattern:\n\nFind first line that N caused repeat behavior,\nOr caused increase of logic executed,\nBut constant or not, ignore anything before that line.\n\n\nSeems line hundred-twenty-three is what we are searching ;-)\n\nOn first sight, line seems to have 2*n max-looping.\nBut looking again, we see i += 2 (and that half is skipped).\nSo, max repeat is simply n, write it down, like f(n) = O( n  but don&apos;t close parenthesis yet.\n\n\nRepeat search till method&apos;s end, and find next line matching our search-pattern, here that&apos;s line 124\n\nWhich is tricky, because strange condition, and reverse looping.\nBut after remembering that we just need to consider maximum repeat count (or worst-case time taken).\nIt&apos;s as easy as saying &quot;Reverse-Loop j starts with j=n, am I right? yes, n seems to be maximum possible repeat count&quot;, so:\n\nAdd n to previous write down&apos;s end,\nbut like &quot;( n &quot;  instead of &quot;+ n&quot; (as this is inside previous loop),\nand close parenthesis only if we find something outside of previous loop.\n\n\n\n\n\nSearch Done! why? because line 125 (or any other line after) does not match our search-pattern.\nWe can now close any parenthesis (left-open in our write down), resulting in below:\nf(n) = O( n( n ) )\n\nTry to further shorten &quot;n( n )&quot; part, like:\n\nn( n ) = n * n\n= n2\nFinally, just wrap it with Big Oh notation, like O(n2) or O(n^2) without formatting.\n\n    ","url":"https://solutionschecker.com/questions/big-o-how-do-you-calculateapproximate-it-1657387856392#solution22","@type":"Answer","upvoteCount":0},{"text":"I don&apos;t know how to programmatically solve this, but the first thing people do is that we sample the algorithm for certain patterns in the number of operations done, say 4n^2 + 2n + 1 we have 2 rules:\n\n\nIf we have a sum of terms, the term with the largest growth rate is kept, with other terms omitted.\n\nIf we have a product of several factors constant factors are omitted.\n\n\n If we simplify f(x), where f(x) is the formula for number of operations done, (4n^2 + 2n + 1 explained above), we obtain the big-O value [O(n^2) in this case]. But this would have to account for Lagrange interpolation in the program, which may be hard to implement. And what if the real big-O value was O(2^n), and we might have something like O(x^n), so this algorithm probably wouldn&apos;t be programmable. But if someone proves me wrong, give me the code . . . .\n    ","url":"https://solutionschecker.com/questions/big-o-how-do-you-calculateapproximate-it-1657387856392#solution23","@type":"Answer","upvoteCount":0},{"text":"For code A, the outer loop will execute for n+1 times, the &apos;1&apos; time means the process which checks the whether i still meets the requirement. And inner loop runs n times, n-2 times.... Thus,0+2+..+(n-2)+n= (0+n)(n+1)/2= O(n²).\n\nFor code B, though inner loop wouldn&apos;t step in and execute the foo(), the inner loop will be executed for n times depend on outer loop execution time, which is O(n)\n    ","url":"https://solutionschecker.com/questions/big-o-how-do-you-calculateapproximate-it-1657387856392#solution24","@type":"Answer","upvoteCount":0}],"@type":"Question"}}</script><meta name="next-head-count" content="22"/><script id="google-analytics" data-nscript="beforeInteractive">(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
})(window,document,'script','dataLayer','GTM-NXVLL8B');</script><link rel="preload" href="/_next/static/css/c116652e2d6f4ad0.css" as="style"/><link rel="stylesheet" href="/_next/static/css/c116652e2d6f4ad0.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-0d1b80a048d4787e.js"></script><script src="/_next/static/chunks/webpack-42cdea76c8170223.js" defer=""></script><script src="/_next/static/chunks/framework-4556c45dd113b893.js" defer=""></script><script src="/_next/static/chunks/main-ccfab947c79712f4.js" defer=""></script><script src="/_next/static/chunks/pages/_app-862498b6ec7885c3.js" defer=""></script><script src="/_next/static/chunks/294-106ef8570fa99deb.js" defer=""></script><script src="/_next/static/chunks/490-7f0418bb4354ac73.js" defer=""></script><script src="/_next/static/chunks/pages/questions/%5Bslug%5D-47289857226115f9.js" defer=""></script><script src="/_next/static/xZs8haGjOP63QuDE0kxeX/_buildManifest.js" defer=""></script><script src="/_next/static/xZs8haGjOP63QuDE0kxeX/_ssgManifest.js" defer=""></script></head><body><noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-NXVLL8B"
        height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript><div id="__next"><div class="wrapper"><header><nav class="bg-white border-gray-200 px-4 lg:px-6 py-2.5 dark:bg-gray-800"><div class="flex flex-wrap justify-between items-center mx-auto max-w-screen-xl"><a class="flex items-center" href="/"><img src="/logo-second.png" class="mr-3 h-6 sm:h-9" alt="Solution Checker Logo"/><h1 class="self-center text-xl font-semibold whitespace-nowrap dark:text-white">Solution Checker</h1></a><div class="flex items-center lg:order-2"><button data-collapse-toggle="mobile-menu-2" type="button" class="inline-flex items-center p-2 ml-1 text-sm text-gray-500 rounded-lg lg:hidden hover:bg-gray-100 focus:outline-none focus:ring-2 focus:ring-gray-200 dark:text-gray-400 dark:hover:bg-gray-700 dark:focus:ring-gray-600" aria-controls="mobile-menu-2" aria-expanded="false"><span class="sr-only">Open main menu</span><svg class="w-6 h-6" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M3 5a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM3 10a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM3 15a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1z" clip-rule="evenodd"></path></svg><svg class="hidden w-6 h-6" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z" clip-rule="evenodd"></path></svg></button></div><div class="hidden justify-between items-center w-full lg:flex lg:w-auto lg:order-1" id="mobile-menu-2"><ul class="flex flex-col mt-4 font-medium lg:flex-row lg:space-x-8 lg:mt-0"><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" aria-current="page" href="/">Home</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/questions?tab=news">Questions</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/post?tab=news">Post</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/questions/big-o-how-do-you-calculateapproximate-it-1657387856392#">Coding</a></li></ul></div></div></nav></header><div class="main-content"><div class="question my-5"><div class="flex question-header items-center m-auto justify-center"><div class="rounded-xl w-full border p-5 shadow-md bg-white"><div class="flex w-full items-center justify-between border-b pb-3"><div class="flex items-center space-x-3"><div class="text-lg font-bold text-slate-700"><a href="/questions/big-o-how-do-you-calculateapproximate-it-1657387856392"><h1>Big O, how do you calculate/approximate it?</h1></a></div></div><div class="flex flex-wrap h-auto justify-end items-center space-x-8"></div></div><div class="question-content mt-5">
                
<p>Most people with a degree in CS will certainly know what <a href="http://www.nist.gov/dads/HTML/bigOnotation.html" rel="noreferrer">Big O stands for</a>.
It helps us to measure how well an algorithm scales. </p>

<p>But I'm curious, how do <em>you</em> calculate or approximate the complexity of your algorithms?</p>
    </div></div></div><div class="solution-section"><nav class="flex pagination-solution flex-col justify-end"><h1 class="text-lg font-semibold mb-5">Navigate to solutions: </h1><ul class="inline-flex -space-x-px overflow-auto"><li class="pagination-solution-item"><span data-id="#solution1" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">1</span></li><li class="pagination-solution-item"><span data-id="#solution2" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">2</span></li><li class="pagination-solution-item"><span data-id="#solution3" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">3</span></li><li class="pagination-solution-item"><span data-id="#solution4" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">4</span></li><li class="pagination-solution-item"><span data-id="#solution5" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">5</span></li><li class="pagination-solution-item"><span data-id="#solution6" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">6</span></li><li class="pagination-solution-item"><span data-id="#solution7" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">7</span></li><li class="pagination-solution-item"><span data-id="#solution8" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">8</span></li><li class="pagination-solution-item"><span data-id="#solution9" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">9</span></li><li class="pagination-solution-item"><span data-id="#solution10" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">10</span></li><li class="pagination-solution-item"><span data-id="#solution11" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">11</span></li><li class="pagination-solution-item"><span data-id="#solution12" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">12</span></li><li class="pagination-solution-item"><span data-id="#solution13" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">13</span></li><li class="pagination-solution-item"><span data-id="#solution14" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">14</span></li><li class="pagination-solution-item"><span data-id="#solution15" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">15</span></li><li class="pagination-solution-item"><span data-id="#solution16" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">16</span></li><li class="pagination-solution-item"><span data-id="#solution17" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">17</span></li><li class="pagination-solution-item"><span data-id="#solution18" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">18</span></li><li class="pagination-solution-item"><span data-id="#solution19" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">19</span></li><li class="pagination-solution-item"><span data-id="#solution20" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">20</span></li><li class="pagination-solution-item"><span data-id="#solution21" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">21</span></li><li class="pagination-solution-item"><span data-id="#solution22" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">22</span></li><li class="pagination-solution-item"><span data-id="#solution23" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">23</span></li><li class="pagination-solution-item"><span data-id="#solution24" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">24</span></li></ul></nav><div id="solution1" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 1</h1><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>I'll do my best to explain it here on simple terms, but be warned that this topic takes my students a couple of months to finally grasp. You can find more information on the Chapter 2 of the <a href="https://rads.stackoverflow.com/amzn/click/com/0321370139" rel="noreferrer">Data Structures and Algorithms in Java</a> book.</p>

<hr>

<p>There is no <a href="http://en.wikipedia.org/wiki/Halting_problem" rel="noreferrer">mechanical procedure</a> that can be used to get the BigOh.</p>

<p>As a "cookbook", to obtain the <a href="http://en.wikipedia.org/wiki/Big_Oh_notation" rel="noreferrer">BigOh</a> from a piece of code you first need to realize that you are creating a math formula to count how many steps of computations get executed given an input of some size.</p>

<p>The purpose is simple: to compare algorithms from a theoretical point of view, without the need to execute the code. The lesser the number of steps, the faster the algorithm.</p>

<p>For example, let's say you have this piece of code:</p>

<pre><code>int sum(int* data, int N) {
    int result = 0;               // 1

    for (int i = 0; i &lt; N; i++) { // 2
        result += data[i];        // 3
    }

    return result;                // 4
}
</code></pre>

<p>This function returns the sum of all the elements of the array, and we want to create a formula to count the <a href="http://en.wikipedia.org/wiki/Computational_complexity_theory" rel="noreferrer">computational complexity</a> of that function:</p>

<pre><code>Number_Of_Steps = f(N)
</code></pre>

<p>So we have <code>f(N)</code>, a function to count the number of computational steps. The input of the function is the size of the structure to process. It means that this function is called such as:</p>

<pre><code>Number_Of_Steps = f(data.length)
</code></pre>

<p>The parameter <code>N</code> takes the <code>data.length</code> value. Now we need the actual definition of the function <code>f()</code>. This is done from the source code, in which each interesting line is numbered from 1 to 4.</p>

<p>There are many ways to calculate the BigOh. From this point forward we are going to assume that every sentence that doesn't depend on the size of the input data takes a constant <code>C</code> number computational steps.</p>

<p>We are going to add the individual number of steps of the function, and neither the local variable declaration nor the return statement depends on the size of the <code>data</code> array.</p>

<p>That means that lines 1 and 4 takes C amount of steps each, and the function is somewhat like this:</p>

<pre><code>f(N) = C + ??? + C
</code></pre>

<p>The next part is to define the value of the <code>for</code> statement. Remember that we are counting the number of computational steps, meaning that the body of the <code>for</code> statement gets executed <code>N</code> times. That's the same as adding <code>C</code>, <code>N</code> times:</p>

<pre><code>f(N) = C + (C + C + ... + C) + C = C + N * C + C
</code></pre>

<p>There is no mechanical rule to count how many times the body of the <code>for</code> gets executed, you need to count it by looking at what does the code do. To simplify the calculations, we are ignoring the variable initialization, condition and increment parts of the <code>for</code> statement.</p>

<p>To get the actual BigOh we need the <a href="http://en.wikipedia.org/wiki/Asymptotic_analysis" rel="noreferrer">Asymptotic analysis</a> of the function. This is roughly done like this:</p>

<ol>
<li>Take away all the constants <code>C</code>.</li>
<li>From <code>f()</code> get the <a href="http://en.wikipedia.org/wiki/Polynomial" rel="noreferrer">polynomium</a> in its <code>standard form</code>.</li>
<li>Divide the terms of the polynomium and sort them by the rate of growth.</li>
<li>Keep the one that grows bigger when <code>N</code> approaches <code>infinity</code>.</li>
</ol>

<p>Our <code>f()</code> has two terms:</p>

<pre><code>f(N) = 2 * C * N ^ 0 + 1 * C * N ^ 1
</code></pre>

<p>Taking away all the <code>C</code> constants and redundant parts:</p>

<pre><code>f(N) = 1 + N ^ 1
</code></pre>

<p>Since the last term is the one which grows bigger when <code>f()</code> approaches infinity (think on <a href="http://en.wikipedia.org/wiki/Limit_%28mathematics%29" rel="noreferrer">limits</a>) this is the BigOh argument, and the <code>sum()</code> function has a BigOh of:</p>

<pre><code>O(N)
</code></pre>

<hr>

<p>There are a few tricks to solve some tricky ones: use <a href="http://en.wikipedia.org/wiki/Summation" rel="noreferrer">summations</a> whenever you can.</p>

<p>As an example, this code can be easily solved using summations:</p>

<pre><code>for (i = 0; i &lt; 2*n; i += 2) {  // 1
    for (j=n; j &gt; i; j--) {     // 2
        foo();                  // 3
    }
}
</code></pre>

<p>The first thing you needed to be asked is the order of execution of <code>foo()</code>. While the usual is to be <code>O(1)</code>, you need to ask your professors about it. <code>O(1)</code> means (almost, mostly) constant <code>C</code>, independent of the size <code>N</code>.</p>

<p>The <code>for</code> statement on the sentence number one is tricky. While the index ends at <code>2 * N</code>, the increment is done by two. That means that the first <code>for</code> gets executed only <code>N</code> steps, and we need to divide the count by two.</p>

<pre><code>f(N) = Summation(i from 1 to 2 * N / 2)( ... ) = 
     = Summation(i from 1 to N)( ... )
</code></pre>

<p>The sentence number <em>two</em> is even trickier since it depends on the value of <code>i</code>. Take a look: the index i takes the values: 0, 2, 4, 6, 8, ..., 2 * N, and the second <code>for</code> get executed: N times the first one, N - 2 the second, N - 4 the third... up to the N / 2 stage, on which the second <code>for</code> never gets executed.</p>

<p>On formula, that means:</p>

<pre><code>f(N) = Summation(i from 1 to N)( Summation(j = ???)(  ) )
</code></pre>

<p>Again, we are counting <strong>the number of steps</strong>. And by definition, every summation should always start at one, and end at a number bigger-or-equal than one.</p>

<pre><code>f(N) = Summation(i from 1 to N)( Summation(j = 1 to (N - (i - 1) * 2)( C ) )
</code></pre>

<p>(We are assuming that <code>foo()</code> is <code>O(1)</code> and takes <code>C</code> steps.)</p>

<p>We have a problem here: when <code>i</code> takes the value <code>N / 2 + 1</code> upwards, the inner Summation ends at a negative number! That's impossible and wrong. We need to split the summation in two, being the pivotal point the moment <code>i</code> takes <code>N / 2 + 1</code>.</p>

<pre><code>f(N) = Summation(i from 1 to N / 2)( Summation(j = 1 to (N - (i - 1) * 2)) * ( C ) ) + Summation(i from 1 to N / 2) * ( C )
</code></pre>

<p>Since the pivotal moment <code>i &gt; N / 2</code>, the inner <code>for</code> won't get executed, and we are assuming a constant C execution complexity on its body.</p>

<p>Now the summations can be simplified using some identity rules:</p>

<ol>
<li>Summation(w from 1 to N)( C ) = N * C</li>
<li>Summation(w from 1 to N)( A (+/-) B ) = Summation(w from 1 to N)( A ) (+/-) Summation(w from 1 to N)( B )</li>
<li>Summation(w from 1 to N)( w * C ) = C * Summation(w from 1 to N)( w ) (C is a constant, independent of <code>w</code>)</li>
<li>Summation(w from 1 to N)( w ) = (N * (N + 1)) / 2</li>
</ol>

<p>Applying some algebra:</p>

<pre><code>f(N) = Summation(i from 1 to N / 2)( (N - (i - 1) * 2) * ( C ) ) + (N / 2)( C )

f(N) = C * Summation(i from 1 to N / 2)( (N - (i - 1) * 2)) + (N / 2)( C )

f(N) = C * (Summation(i from 1 to N / 2)( N ) - Summation(i from 1 to N / 2)( (i - 1) * 2)) + (N / 2)( C )

f(N) = C * (( N ^ 2 / 2 ) - 2 * Summation(i from 1 to N / 2)( i - 1 )) + (N / 2)( C )

=&gt; Summation(i from 1 to N / 2)( i - 1 ) = Summation(i from 1 to N / 2 - 1)( i )

f(N) = C * (( N ^ 2 / 2 ) - 2 * Summation(i from 1 to N / 2 - 1)( i )) + (N / 2)( C )

f(N) = C * (( N ^ 2 / 2 ) - 2 * ( (N / 2 - 1) * (N / 2 - 1 + 1) / 2) ) + (N / 2)( C )

=&gt; (N / 2 - 1) * (N / 2 - 1 + 1) / 2 = 

   (N / 2 - 1) * (N / 2) / 2 = 

   ((N ^ 2 / 4) - (N / 2)) / 2 = 

   (N ^ 2 / 8) - (N / 4)

f(N) = C * (( N ^ 2 / 2 ) - 2 * ( (N ^ 2 / 8) - (N / 4) )) + (N / 2)( C )

f(N) = C * (( N ^ 2 / 2 ) - ( (N ^ 2 / 4) - (N / 2) )) + (N / 2)( C )

f(N) = C * (( N ^ 2 / 2 ) - (N ^ 2 / 4) + (N / 2)) + (N / 2)( C )

f(N) = C * ( N ^ 2 / 4 ) + C * (N / 2) + C * (N / 2)

f(N) = C * ( N ^ 2 / 4 ) + 2 * C * (N / 2)

f(N) = C * ( N ^ 2 / 4 ) + C * N

f(N) = C * 1/4 * N ^ 2 + C * N
</code></pre>

<p>And the BigOh is:</p>

<pre><code>O(N²)
</code></pre>
    </div></div></div></div><div id="solution2" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 2</h1><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Big O gives the upper bound for time complexity of an algorithm.  It is usually used in conjunction with processing data sets (lists) but can be used elsewhere.  </p>

<p>A few examples of how it's used in C code.</p>

<p>Say we have an array of n elements</p>

<pre><code>int array[n];
</code></pre>

<p>If we wanted to access the first element of the array this would be O(1) since it doesn't matter how big the array is, it always takes the same constant time to get the first item.</p>

<pre><code>x = array[0];
</code></pre>

<p>If we wanted to find a number in the list:</p>

<pre><code>for(int i = 0; i &lt; n; i++){
    if(array[i] == numToFind){ return i; }
}
</code></pre>

<p>This would be O(n) since at most we would have to look through the entire list to find our number.  The Big-O is still O(n) even though we might find our number the first try and run through the loop once because Big-O describes the upper bound for an algorithm (omega is for lower bound and theta is for tight bound).</p>

<p>When we get to nested loops:</p>

<pre><code>for(int i = 0; i &lt; n; i++){
    for(int j = i; j &lt; n; j++){
        array[j] += 2;
    }
}
</code></pre>

<p>This is O(n^2) since for each pass of the outer loop ( O(n) ) we have to go through the entire list again so the n's multiply leaving us with n squared.</p>

<p>This is barely scratching the surface but when you get to analyzing more complex algorithms complex math involving proofs comes into play.  Hope this familiarizes you with the basics at least though.</p>
    </div></div></div></div><div id="solution3" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 3</h1><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>While knowing how to figure out the Big O time for your particular problem is useful, knowing some general cases can go a long way in helping you make decisions in your algorithm.</p>

<p>Here are some of the most common cases, lifted from <a href="http://en.wikipedia.org/wiki/Big_O_notation#Orders_of_common_functions" rel="noreferrer">http://en.wikipedia.org/wiki/Big_O_notation#Orders_of_common_functions</a>:</p>

<p>O(1) - Determining if a number is even or odd; using a constant-size lookup table or hash table</p>

<p>O(logn) - Finding an item in a sorted array with a binary search</p>

<p>O(n) - Finding an item in an unsorted list; adding two n-digit numbers</p>

<p>O(n<sup>2</sup>) - Multiplying two n-digit numbers by a simple algorithm; adding two n×n matrices; bubble sort or insertion sort</p>

<p>O(n<sup>3</sup>) - Multiplying two n×n matrices by simple algorithm</p>

<p>O(c<sup>n</sup>) - Finding the (exact) solution to the traveling salesman problem using dynamic programming; determining if two logical statements are equivalent using brute force</p>

<p>O(n!) - Solving the traveling salesman problem via brute-force search</p>

<p>O(n<sup>n</sup>) - Often used instead of O(n!) to derive simpler formulas for asymptotic complexity</p>
    </div></div></div></div><div id="solution4" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 4</h1><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Small reminder: the <code>big O</code> notation is used to denote <em>asymptotic</em> complexity (that is, when the size of the problem grows to infinity), <em>and</em> it hides a constant.</p>

<p>This means that between an algorithm in O(n) and one in O(n<sup>2</sup>), the fastest is not always the first one (though there always exists a value of n such that for problems of size &gt;n, the first algorithm is the fastest).</p>

<p>Note that the hidden constant very much depends on the implementation!</p>

<p>Also, in some cases, the runtime is not a deterministic function of the <em>size</em> n of the input. Take sorting using quick sort for example: the time needed to sort an array of n elements is not a constant but depends on the starting configuration of the array. </p>

<p>There are different time complexities: </p>

<ul>
<li>Worst case (usually the simplest to figure out, though not always very meaningful)</li>
<li><p>Average case (usually much harder to figure out...)</p></li>
<li><p>...</p></li>
</ul>

<p>A good introduction is <em>An Introduction to the Analysis of Algorithms</em> by R. Sedgewick and P. Flajolet.</p>

<p>As you say, <code>premature optimisation is the root of all evil</code>, and (if possible) <em>profiling</em> really should always be used when optimising code. It can even help you determine the complexity of your algorithms.</p>
    </div></div></div></div><div id="solution5" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 5</h1><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Seeing the answers here I think we can conclude that most of us do indeed approximate the order of the algorithm by <em>looking</em> at it and use common sense instead of calculating it with, for example, the <a href="http://en.wikipedia.org/wiki/Master_theorem" rel="noreferrer">master method</a> as we were thought at university.
With that said I must add that even the professor encouraged us (later on) to actually <em>think</em> about it instead of just calculating it.</p>

<p>Also I would like to add how it is done for <strong>recursive functions</strong>:</p>

<p>suppose we have a function like (<a href="http://plt-scheme.org/" rel="noreferrer">scheme code</a>):</p>

<pre><code>(define (fac n)
    (if (= n 0)
        1
            (* n (fac (- n 1)))))
</code></pre>

<p>which recursively calculates the factorial of the given number.</p>

<p>The first step is to try and determine the performance characteristic for <em>the body of the function only</em> in this case, nothing special is done in the body, just a multiplication (or the return of the value 1).</p>

<p>So the <strong>performance for the body is: O(1)</strong> (constant).</p>

<p>Next try and determine this for the <em>number of recursive calls</em>. In this case we have n-1 recursive calls.</p>

<p>So the <strong>performance for the recursive calls is: O(n-1)</strong> (order is n, as we throw away the insignificant parts).</p>

<p>Then put those two together and you then have the performance for the whole recursive function:  </p>

<p><strong>1 * (n-1) = O(n)</strong></p>

<hr>

<p><a href="https://stackoverflow.com/users/1192/peter-holmdahl">Peter</a>, to answer <a href="https://stackoverflow.com/questions/3255/big-o-how-do-you-calculateapproximate-it#12001">your raised issues;</a> the method I describe here actually handles this quite well. But keep in mind that this is still an <em>approximation</em> and not a full mathematically correct answer. The method described here is also one of the methods we were taught at university, and if I remember correctly was used for far more advanced algorithms than the factorial I used in this example.<br>
Of course it all depends on how well you can estimate the running time of the body of the function and the number of recursive calls, but that is just as true for the other methods.</p>
    </div></div></div></div><div id="solution6" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 6</h1><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>If your cost is a polynomial, just keep the highest-order term, without its multiplier. E.g.:</p>

<blockquote>
  <p>O((n/2 + 1)*(n/2)) = O(n<sup>2</sup>/4 + n/2) = O(n<sup>2</sup>/4) = O(n<sup>2</sup>)</p>
</blockquote>

<p>This doesn't work for infinite series, mind you. There is no single recipe for the general case, though for some common cases, the following inequalities apply:</p>

<blockquote>
  <p>O(log <em>N</em>) &lt; O(<em>N</em>) &lt; O(<em>N</em> log <em>N</em>) &lt; O(<em>N</em><sup>2</sup>) &lt; O(<em>N</em><sup>k</sup>) &lt; O(e<sup><em>n</em></sup>) &lt; O(<em>n</em>!)</p>
</blockquote>
    </div></div></div></div><div id="solution7" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 7</h1><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>I think about it in terms of information. Any problem consists of learning a certain number of bits.</p>

<p>Your basic tool is the concept of decision points and their entropy. The entropy of a decision point is the average information it will give you. For example, if a program contains a decision point with two branches, it's entropy is the sum of the probability of each branch times the log<sub>2</sub> of the inverse probability of that branch. That's how much you learn by executing that decision.</p>

<p>For example, an <code>if</code> statement having two branches, both equally likely, has an entropy of 1/2 * log(2/1) + 1/2 * log(2/1) = 1/2 * 1 + 1/2 * 1 = 1. So its entropy is 1 bit.</p>

<p>Suppose you are searching a table of N items, like N=1024. That is a 10-bit problem because log(1024) = 10 bits. So if you can search it with IF statements that have equally likely outcomes, it should take 10 decisions.</p>

<p>That's what you get with binary search.</p>

<p>Suppose you are doing linear search. You look at the first element and ask if it's the one you want. The probabilities are 1/1024 that it is, and 1023/1024 that it isn't. The entropy of that decision is 1/1024*log(1024/1) + 1023/1024 * log(1024/1023) = 1/1024 * 10 + 1023/1024 * about 0 = about .01 bit. You've learned very little! The second decision isn't much better. That is why linear search is so slow. In fact it's exponential in the number of bits you need to learn.</p>

<p>Suppose you are doing indexing. Suppose the table is pre-sorted into a lot of bins, and you use some of all of the bits in the key to index directly to the table entry. If there are 1024 bins, the entropy is 1/1024 * log(1024) + 1/1024 * log(1024) + ... for all 1024 possible outcomes. This is 1/1024 * 10 times 1024 outcomes, or 10 bits of entropy for that one indexing operation. That is why indexing search is fast.</p>

<p>Now think about sorting.  You have N items, and you have a list. For each item, you have to search for where the item goes in the list, and then add it to the list. So sorting takes roughly N times the number of steps of the underlying search.</p>

<p>So sorts based on binary decisions having roughly equally likely outcomes all take about O(N log N) steps. An O(N) sort algorithm is possible if it is based on indexing search.</p>

<p>I've found that nearly all algorithmic performance issues can be looked at in this way.</p>
    </div></div></div></div><div id="solution8" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 8</h1><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Lets start from the beginning.</p>

<p>First of all, accept the principle that certain simple operations on data can be done in <code>O(1)</code> time, that is, in time that is independent of the size of the input. These primitive operations in C consist of</p>

<ol>
<li>Arithmetic operations (e.g. + or %).</li>
<li>Logical operations (e.g., &amp;&amp;).</li>
<li>Comparison operations (e.g., &lt;=).</li>
<li>Structure accessing operations (e.g. array-indexing like A[i], or pointer fol-
lowing with the -&gt; operator).</li>
<li>Simple assignment such as copying a value into a variable.</li>
<li>Calls to library functions (e.g., scanf, printf).</li>
</ol>

<p>The justification for this principle requires a detailed study of the machine instructions (primitive steps) of a typical computer. Each of the described operations can be done with some small number of machine instructions; often only one or two instructions are needed.
As a consequence, several kinds of statements in C can be executed in <code>O(1)</code> time, that is, in some constant amount of time independent of input. These simple include</p>

<ol>
<li>Assignment statements that do not involve function calls in their expressions.</li>
<li>Read statements.</li>
<li>Write statements that do not require function calls to evaluate arguments.</li>
<li>The jump statements break, continue, goto, and return expression, where
expression does not contain a function call.</li>
</ol>

<p>In C, many for-loops are formed by initializing an index variable to some value and
incrementing that variable by 1 each time around the loop. The for-loop ends when
the index reaches some limit. For instance, the for-loop </p>

<pre><code>for (i = 0; i &lt; n-1; i++) 
{
    small = i;
    for (j = i+1; j &lt; n; j++)
        if (A[j] &lt; A[small])
            small = j;
    temp = A[small];
    A[small] = A[i];
    A[i] = temp;
}
</code></pre>

<p>uses index variable i. It increments i by 1 each time around the loop, and the iterations
stop when i reaches n  1.</p>

<p>However, for the moment, focus on the simple form of for-loop, where the <strong>difference between the final and initial values, divided by the amount by which the index variable is incremented tells us how many times we go around the loop</strong>. That count is exact, unless there are ways to exit the loop via a jump statement; it is an upper bound on the number of iterations in any case. </p>

<p>For instance, the for-loop iterates <code>((n  1)  0)/1 = n  1 times</code>,
since 0 is the initial value of i, n  1 is the highest value reached by i (i.e., when i
reaches n1, the loop stops and no iteration occurs with i = n1), and 1 is added
to i at each iteration of the loop.</p>

<p>In the simplest case, where the time spent in the loop body is the same for each
iteration, <strong>we can multiply the big-oh upper bound for the body by the number of
times around the loop</strong>. Strictly speaking, we must then <strong>add O(1) time to initialize
the loop index and O(1) time for the first comparison of the loop index with the
limit</strong>, because we test one more time than we go around the loop. However, unless
it is possible to execute the loop zero times, the time to initialize the loop and test
the limit once is a low-order term that can be dropped by the summation rule.</p>

<hr>

<p>Now consider this example:</p>

<pre><code>(1) for (j = 0; j &lt; n; j++)
(2)   A[i][j] = 0;
</code></pre>

<p>We know that <strong>line (1)</strong> takes <code>O(1)</code> time. Clearly, we go around the loop n times, as
we can determine by subtracting the lower limit from the upper limit found on line
(1) and then adding 1. Since the body, line (2), takes O(1) time, we can neglect the
time to increment j and the time to compare j with n, both of which are also O(1).
Thus, the running time of lines (1) and (2) is the <strong>product of n and O(1)</strong>, which is <code>O(n)</code>.</p>

<p>Similarly, we can bound the running time of the outer loop consisting of lines
(2) through (4), which is</p>

<pre><code>(2) for (i = 0; i &lt; n; i++)
(3)     for (j = 0; j &lt; n; j++)
(4)         A[i][j] = 0;
</code></pre>

<p>We have already established that the loop of lines (3) and (4) takes O(n) time.
Thus, we can neglect the O(1) time to increment i and to test whether i &lt; n in
each iteration, concluding that each iteration of the outer loop takes O(n) time.</p>

<p>The initialization i = 0 of the outer loop and the (n + 1)st test of the condition
i &lt; n likewise take O(1) time and can be neglected. Finally, we observe that we go
around the outer loop n times, taking O(n) time for each iteration, giving a total
<code>O(n^2)</code> running time.</p>

<hr>

<p>A more practical example.</p>

<p><img src="https://i.stack.imgur.com/ceoAc.png" alt="enter image description here"></p>
    </div></div></div></div><div id="solution9" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 9</h1><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>If you want to estimate the order of your code empirically rather than by analyzing the code, you could stick in a series of increasing values of n and time your code.  Plot your timings on a log scale.  If the code is O(x^n), the values should fall on a line of slope n.</p>

<p>This has several advantages over just studying the code.  For one thing, you can see whether you're in the range where the run time approaches its asymptotic order. Also, you may find that some code that you thought was order O(x) is really order O(x^2), for example, because of time spent in library calls.</p>
    </div></div></div></div><div id="solution10" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 10</h1><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Basically the thing that crops up 90% of the time is just analyzing loops.  Do you have single, double, triple nested loops?  The you have O(n), O(n^2), O(n^3) running time.</p>

<p>Very rarely (unless you are writing a platform with an extensive base library (like for instance, the .NET BCL, or C++'s STL) you will encounter anything that is more difficult than just looking at your loops (for statements, while, goto, etc...)</p>
    </div></div></div></div><div id="solution11" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 11</h1><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Less useful generally, I think, but for the sake of completeness there is also a <a href="http://en.wikipedia.org/wiki/Big_O_notation#Family_of_Bachmann.E2.80.93Landau_notations" rel="noreferrer">Big Omega Ω</a>, which defines a lower-bound on an algorithm's complexity, and a <a href="http://en.wikipedia.org/wiki/Big_O_notation#Related_asymptotic_notations" rel="noreferrer">Big Theta Θ</a>, which defines both an upper and lower bound.</p>
    </div></div></div></div><div id="solution12" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 12</h1><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Big O notation is useful because it's easy to work with and hides unnecessary complications and details (for some definition of unnecessary). One nice way of working out the complexity of divide and conquer algorithms is the tree method. Let's say you have a version of quicksort with the median procedure, so you split the array into perfectly balanced subarrays every time.</p>

<p>Now build a tree corresponding to all the arrays you work with. At the root you have the original array, the root has two children which are the subarrays. Repeat this until you have single element arrays at the bottom. </p>

<p>Since we can find the median in O(n) time and split the array in two parts in O(n) time, the work done at each node is O(k) where k is the size of the array. Each level of the tree contains (at most) the entire array so the work per level is O(n) (the sizes of the subarrays add up to n, and since we have O(k) per level we can add this up). There are only log(n) levels in the tree since each time we halve the input.</p>

<p>Therefore we can upper bound the amount of work by O(n*log(n)). </p>

<p>However, Big O hides some details which we sometimes can't ignore. Consider computing the Fibonacci sequence with</p>

<pre><code>a=0;
b=1;
for (i = 0; i &lt;n; i++) {
    tmp = b;
    b = a + b;
    a = tmp;
}
</code></pre>

<p>and lets just assume the a and b are BigIntegers in Java or something that can handle arbitrarily large numbers. Most people would say this is an O(n) algorithm without flinching. The reasoning is that you have n iterations in the for loop and O(1) work in side the loop. </p>

<p>But Fibonacci numbers are large, the n-th Fibonacci number is exponential in n so just storing it will take on the order of n bytes. Performing addition with big integers will take O(n) amount of work. So the total amount of work done in this procedure is </p>

<p>1 + 2 + 3 + ... + n = n(n-1)/2 = O(n^2)</p>

<p>So this algorithm runs in quadradic time!</p>
    </div></div></div></div><div id="solution13" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 13</h1><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Familiarity with the algorithms/data structures I use and/or quick glance analysis of iteration nesting.  The difficulty is when you call a library function, possibly multiple times - you can often be unsure of whether you are calling the function unnecessarily at times or what implementation they are using.  Maybe library functions should have a complexity/efficiency measure, whether that be Big O or some other metric, that is available in documentation or even <a href="http://en.wikipedia.org/wiki/IntelliSense" rel="noreferrer">IntelliSense</a>.</p>
    </div></div></div></div><div id="solution14" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 14</h1><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Break down the algorithm into pieces you know the big O notation for, and combine through big O operators. That's the only way I know of.</p>

<p>For more information, check the <a href="http://en.wikipedia.org/wiki/Big_O_notation" rel="noreferrer">Wikipedia page</a> on the subject.</p>
    </div></div></div></div><div id="solution15" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 15</h1><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>As to "how do you calculate" Big O, this is part of <a href="http://en.wikipedia.org/wiki/Computational_complexity_theory" rel="noreferrer">Computational complexity theory</a>. For some (many) special cases you may be able to come with some simple heuristics (like multiplying loop counts for nested loops), esp. when all you want is any upper bound estimation, and you do not mind if it is too pessimistic - which I guess is probably what your question is about.</p>

<p>If you really want to answer your question for any algorithm the best you can do is to apply the theory. Besides of simplistic "worst case" analysis I have found <a href="http://en.wikipedia.org/wiki/Amortized_analysis" rel="noreferrer">Amortized analysis</a> very useful in practice.</p>
    </div></div></div></div><div id="solution16" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 16</h1><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>For the 1st case, the inner loop is executed <code>n-i</code> times, so the total number of executions is the sum for <code>i</code> going from <code>0</code> to <code>n-1</code> (because lower than, not lower than or equal) of the <code>n-i</code>. You get finally <code>n*(n + 1) / 2</code>, so <code>O(n²/2) = O(n²)</code>.</p>

<p>For the 2nd loop, <code>i</code> is between <code>0</code> and <code>n</code> included for the outer loop; then the inner loop is executed when <code>j</code> is strictly greater than <code>n</code>, which is then impossible.</p>
    </div></div></div></div><div id="solution17" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 17</h1><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>In addition to using the master method (or one of its specializations), I test my algorithms experimentally.  This can't <em>prove</em> that any particular complexity class is achieved, but it can provide reassurance that the mathematical analysis is appropriate.  To help with this reassurance, I use code coverage tools in conjunction with my experiments, to ensure that I'm exercising all the cases.</p>

<p>As a very simple example say you wanted to do a sanity check on the speed of the .NET framework's list sort.  You could write something like the following, then analyze the results in Excel to make sure they did not exceed an n*log(n) curve.</p>

<p>In this example I measure the number of comparisons, but it's also prudent to examine the actual time required for each sample size.  However then you must be even more careful that you are just measuring the algorithm and not including artifacts from your test infrastructure.</p>

<pre><code>int nCmp = 0;
System.Random rnd = new System.Random();

// measure the time required to sort a list of n integers
void DoTest(int n)
{
   List&lt;int&gt; lst = new List&lt;int&gt;(n);
   for( int i=0; i&lt;n; i++ )
      lst[i] = rnd.Next(0,1000);

   // as we sort, keep track of the number of comparisons performed!
   nCmp = 0;
   lst.Sort( delegate( int a, int b ) { nCmp++; return (a&lt;b)?-1:((a&gt;b)?1:0)); }

   System.Console.Writeline( "{0},{1}", n, nCmp );
}


// Perform measurement for a variety of sample sizes.
// It would be prudent to check multiple random samples of each size, but this is OK for a quick sanity check
for( int n = 0; n&lt;1000; n++ )
   DoTest(n);
</code></pre>
    </div></div></div></div><div id="solution18" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 18</h1><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Don't forget to also allow for space complexities that can also be a cause for concern if one has limited memory resources.  So for example you may hear someone wanting a constant space algorithm which is basically a way of saying that the amount of space taken by the algorithm doesn't depend on any factors inside the code.</p>

<p>Sometimes the complexity can come from how many times is something called, how often is a loop executed, how often is memory allocated, and so on is another part to answer this question.</p>

<p>Lastly, big O can be used for worst case, best case, and amortization cases where generally it is the worst case that is used for describing how bad an algorithm may be.</p>
    </div></div></div></div><div id="solution19" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 19</h1><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>I would like to explain the Big-O in a little bit different aspect.</p>

<p>Big-O is just to compare the complexity of the programs which means how fast are they growing when the inputs are increasing and not the exact time which is spend to do the action.</p>

<p>IMHO in the big-O formulas you better not to use more complex equations (you might just stick to the ones in the following graph.) However you still might use other more precise formula (like 3^n, n^3, ...) but more than that can be sometimes misleading! So better to keep it as simple as possible.</p>

<p><a href="https://i.stack.imgur.com/ZEmZ6.png" rel="noreferrer"><img src="https://i.stack.imgur.com/ZEmZ6.png" alt="enter image description here"></a></p>

<p>I would like to emphasize once again that here we don't want to get an exact formula for our algorithm. We only want to show how it grows when the inputs are growing and compare with the other algorithms in that sense. Otherwise you would better use different methods like bench-marking.</p>
    </div></div></div></div><div id="solution20" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 20</h1><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>What often gets overlooked is the <em>expected</em> behavior of your algorithms. <strong>It doesn't change the Big-O of your algorithm</strong>, but it does relate to the statement "premature optimization. . .."</p>

<p>Expected behavior of your algorithm is -- very dumbed down -- how fast you can expect your algorithm to work on data you're most likely to see. </p>

<p>For instance, if you're searching for a value in a list, it's O(n), but if you know that most lists you see have your value up front, typical behavior of your algorithm is faster. </p>

<p>To really nail it down, you need to be able to describe the probability distribution of your "input space" (if you need to sort a list, how often is that list already going to be sorted? how often is it totally reversed? how often is it mostly sorted?) It's not always feasible that you know that, but sometimes you do. </p>
    </div></div></div></div><div id="solution21" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 21</h1><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>great question!</p>

<p><strong>Disclaimer: this answer contains false statements see the comments below.</strong></p>

<p>If you're using the Big O, you're talking about the worse case (more on what that means later). Additionally, there is capital theta for average case and a big omega for best case.</p>

<p>Check out this site for a lovely formal definition of Big O: <a href="https://xlinux.nist.gov/dads/HTML/bigOnotation.html" rel="nofollow noreferrer">https://xlinux.nist.gov/dads/HTML/bigOnotation.html</a></p>

<blockquote>
  <p>f(n) = O(g(n)) means there are positive constants c and k, such that 0  f(n)  cg(n) for all n  k. The values of c and k must be fixed for the function f and must not depend on n. </p>
</blockquote>

<hr>

<p>Ok, so now what do we mean by "best-case" and "worst-case" complexities?</p>

<p>This is probably most clearly illustrated through examples. For example if we are using linear search to find a number in a sorted array then the <strong>worst case</strong> is when we decide to <strong>search for the last element</strong> of the array as this would take as many steps as there are items in the array. The <strong>best case</strong> would be when we search for the <strong>first element</strong> since we would be done after the first check.</p>

<p>The point of all these <em>adjective</em>-case complexities is that we're looking for a way to graph the amount of time a hypothetical program runs to completion in terms of the size of particular variables. However for many algorithms you can argue that there is not a single time for a particular size of input. Notice that this contradicts with the fundamental requirement of a function, any input should have no more than one output. So we come up with <em>multiple</em> functions to describe an algorithm's complexity. Now, even though searching an array of size n may take varying amounts of time depending on what you're looking for in the array and depending proportionally to n, we can create an informative description of the algorithm using best-case, average-case, and worst-case classes.</p>

<p>Sorry this is so poorly written and lacks much technical information. But hopefully it'll make time complexity classes easier to think about. Once you become comfortable with these it becomes a simple matter of parsing through your program and looking for things like for-loops that depend on array sizes and reasoning based on your data structures what kind of input would result in trivial cases and what input would result in worst-cases.</p>
    </div></div></div></div><div id="solution22" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 22</h1><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>First of all, the accepted answer is trying to explain nice fancy stuff, <br>
but I think, <em>intentionally</em> complicating Big-Oh is not the solution,<br>
which programmers (or at least, people like me) search for.</p>
<h2>Big Oh (in short)</h2>
<pre class="lang-js s-code-block"><code class="hljs language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">f</span>(<span class="hljs-params">text</span>) {
  <span class="hljs-keyword">var</span> n = text.<span class="hljs-property">length</span>;
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) {
    <span class="hljs-title function_">f</span>(text.<span class="hljs-title function_">slice</span>(<span class="hljs-number">0</span>, n-<span class="hljs-number">1</span>))
  }
  <span class="hljs-comment">// ... other JS logic here, which we can ignore ...</span>
}
</code></pre>
<p>Big Oh of above is f(n) = <strong>O(n!)</strong> where <strong>n</strong> represents <code>number</code> of items in input set,
and <strong>f</strong> represents <code>operation</code> done per item.</p>
<hr>
<p>Big-Oh notation is the asymptotic upper-bound of the complexity of an algorithm.<br>
In programming: The assumed worst-case time taken,<br>
or assumed maximum repeat count of logic, for size of the input.</p>
<h2>Calculation</h2>
<p>Keep in mind (from above meaning) that; We just need <strong>worst-case time</strong> and/or <strong>maximum repeat count</strong> affected by <strong>N</strong> (size of input),<br>
Then take another look at (accepted answer's) example:</p>
<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">2</span>*n; i += <span class="hljs-number">2</span>) {  <span class="hljs-comment">// line 123</span>
    <span class="hljs-keyword">for</span> (j=n; j &gt; i; j--) {     <span class="hljs-comment">// line 124</span>
        foo();                  <span class="hljs-comment">// line 125</span>
    }
}
</code></pre>
<ol>
<li><p>Begin with this search-pattern:</p>
<ul>
<li>Find first line that <strong>N</strong> caused repeat behavior,</li>
<li>Or caused increase of logic executed,</li>
<li>But constant or not, ignore anything before that line.</li>
</ul>
</li>
<li><p>Seems line hundred-twenty-three is what we are searching ;-)</p>
<ul>
<li>On first sight, line seems to have <code>2*n</code> max-looping.</li>
<li>But looking again, we see <code>i += 2</code> (and that half is skipped).</li>
<li>So, max repeat is simply <strong>n</strong>, write it down, like <code>f(n) = O( n </code> but don't close parenthesis yet.</li>
</ul>
</li>
<li><p>Repeat search till method's end, and find next line matching our search-pattern, here that's line 124</p>
<ul>
<li>Which is tricky, because strange condition, and reverse looping.</li>
<li>But after remembering that we just need to consider maximum repeat count (or worst-case time taken).</li>
<li>It's as easy as saying "Reverse-Loop <code>j</code> starts with <code>j=n</code>, am I right? yes, <strong>n</strong> seems to be maximum possible repeat count", so:
<ul>
<li>Add <code>n</code> to previous write down's end,</li>
<li>but like "<code>( n </code>"  instead of "<code>+ n</code>" (as this is inside previous loop),</li>
<li>and close parenthesis only if we find something outside of previous loop.</li>
</ul>
</li>
</ul>
</li>
</ol>
<p>Search Done! why? because line 125 (or any other line after) does not match our search-pattern.<br>
We can now close any parenthesis (left-open in our write down), resulting in below:</p>
<pre><code>f(n) = O( n( n ) )
</code></pre>
<p>Try to further shorten "<code>n( n )</code>" part, like:</p>
<ul>
<li><strong>n( n ) = n * n</strong></li>
<li><strong>= n<sup>2</sup></strong></li>
<li>Finally, just wrap it with Big Oh notation, like <strong>O(n<sup>2</sup>)</strong> or O(n^2) without formatting.</li>
</ul>
    </div></div></div></div><div id="solution23" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 23</h1><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>I don't know how to programmatically solve this, but the first thing people do is that we sample the algorithm for certain patterns in the number of operations done, say 4n^2 + 2n + 1 we have 2 rules:</p>

<ol>
<li>If we have a sum of terms, the term with the largest growth rate is kept, with other terms omitted.
<br></li>
<li>If we have a product of several factors constant factors are omitted.</li>
</ol>

<p> If we simplify f(x), where f(x) is the formula for number of operations done, (4n^2 + 2n + 1 explained above), we obtain the big-O value [O(n^2) in this case]. But this would have to account for Lagrange interpolation in the program, which may be hard to implement. And what if the real big-O value was O(2^n), and we might have something like O(x^n), so this algorithm probably wouldn't be programmable. But if someone proves me wrong, give me the code . . . .</p>
    </div></div></div></div><div id="solution24" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 24</h1><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>For code A, the outer loop will execute for <code>n+1</code> times, the '1' time means the process which checks the whether i still meets the requirement. And inner loop runs <code>n</code> times, <code>n-2</code> times.... Thus,<code>0+2+..+(n-2)+n= (0+n)(n+1)/2= O(n²)</code>.</p>

<p>For code B, though inner loop wouldn't step in and execute the foo(), the inner loop will be executed for n times depend on outer loop execution time, which is O(n)</p>
    </div></div></div></div></div></div><div class="widget"><a href="/questions/php-code-is-not-being-executed-but-the-code-shows-in-the-browser-source-code-1657384553581">PHP code is not being executed, but the code shows in the browser source code</a><a href="/questions/using-global-variables-in-a-function-1657384796002">Using global variables in a function</a><a href="/questions/how-to-serve-static-files-in-flask-1657387862496">How to serve static files in Flask</a><a href="/questions/how-do-i-execute-a-program-or-call-a-system-command-1657385465629">How do I execute a program or call a system command?</a><a href="/questions/convert-one-date-format-into-another-in-php-1657384566234">Convert one date format into another in PHP</a><a href="/questions/iterating-over-dictionaries-using-&#x27;for&#x27;-loops-1657388334481">Iterating over dictionaries using &#x27;for&#x27; loops</a><a href="/questions/selecting-and-manipulating-css-pseudo-elements-such-as-::before-and-::after-using-javascript-(or-jquery)-1657387406132">Selecting and manipulating CSS pseudo-elements such as ::before and ::after using javascript (or jQuery)</a><a href="/questions/android-permission-doesn&#x27;t-work-even-if-i-have-declared-it-1657387726990">Android permission doesn&#x27;t work even if I have declared it</a><a href="/questions/why-jsf-calls-getters-multiple-times-1657388244489">Why JSF calls getters multiple times</a><a href="/questions/get-the-values-from-the-%22get%22-parameters-(javascript)-duplicate-1657387656693">Get the values from the &quot;GET&quot; parameters (JavaScript) [duplicate]</a><a href="/questions/why-are-floating-point-numbers-inaccurate-1657387346111">Why are floating point numbers inaccurate?</a><a href="/questions/performance-optimization-strategies-of-last-resort-closed-1657388420614">Performance optimization strategies of last resort [closed]</a><a href="/questions/how-do-i-split-a-list-into-equally-sized-chunks-1657384580399">How do I split a list into equally-sized chunks?</a><a href="/questions/how-should-i-use-servlets-and-ajax-1657385492684">How should I use servlets and Ajax?</a><a href="/questions/why-are-these-constructs-using-pre-and-post-increment-undefined-behavior-1657384520109">Why are these constructs using pre and post-increment undefined behavior?</a><a href="/questions/how-do-i-write-a-correct-micro-benchmark-in-java-1657384488725">How do I write a correct micro-benchmark in Java?</a><a href="/questions/how-do-i-modify-the-url-without-reloading-the-page-1657387509731">How do I modify the URL without reloading the page?</a><a href="/questions/why-use-getters-and-settersaccessors-1657387343971">Why use getters and setters/accessors?</a><a href="/questions/what-is-the-difference-between-a-definition-and-a-declaration-1657387851618">What is the difference between a definition and a declaration?</a><a href="/questions/how-do-i-vertically-center-text-with-css-duplicate-1657387645821">How do I vertically center text with CSS? [duplicate]</a></div></div><span class="cursor-pointer text-lg p-2" style="position:fixed;bottom:20px;left:20px;background:#000;z-index:2000;color:white">Go go top</span></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"data":{"answer":["\n\u0026lt;p\u0026gt;I\u0026apos;ll do my best to explain it here on simple terms, but be warned that this topic takes my students a couple of months to finally grasp. You can find more information on the Chapter 2 of the \u0026lt;a href=\u0026quot;https://rads.stackoverflow.com/amzn/click/com/0321370139\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;Data Structures and Algorithms in Java\u0026lt;/a\u0026gt; book.\u0026lt;/p\u0026gt;\n\n\u0026lt;hr\u0026gt;\n\n\u0026lt;p\u0026gt;There is no \u0026lt;a href=\u0026quot;http://en.wikipedia.org/wiki/Halting_problem\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;mechanical procedure\u0026lt;/a\u0026gt; that can be used to get the BigOh.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;As a \u0026quot;cookbook\u0026quot;, to obtain the \u0026lt;a href=\u0026quot;http://en.wikipedia.org/wiki/Big_Oh_notation\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;BigOh\u0026lt;/a\u0026gt; from a piece of code you first need to realize that you are creating a math formula to count how many steps of computations get executed given an input of some size.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;The purpose is simple: to compare algorithms from a theoretical point of view, without the need to execute the code. The lesser the number of steps, the faster the algorithm.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;For example, let\u0026apos;s say you have this piece of code:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;int sum(int* data, int N) {\n    int result = 0;               // 1\n\n    for (int i = 0; i \u0026amp;lt; N; i++) { // 2\n        result += data[i];        // 3\n    }\n\n    return result;                // 4\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;This function returns the sum of all the elements of the array, and we want to create a formula to count the \u0026lt;a href=\u0026quot;http://en.wikipedia.org/wiki/Computational_complexity_theory\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;computational complexity\u0026lt;/a\u0026gt; of that function:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;Number_Of_Steps = f(N)\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;So we have \u0026lt;code\u0026gt;f(N)\u0026lt;/code\u0026gt;, a function to count the number of computational steps. The input of the function is the size of the structure to process. It means that this function is called such as:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;Number_Of_Steps = f(data.length)\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;The parameter \u0026lt;code\u0026gt;N\u0026lt;/code\u0026gt; takes the \u0026lt;code\u0026gt;data.length\u0026lt;/code\u0026gt; value. Now we need the actual definition of the function \u0026lt;code\u0026gt;f()\u0026lt;/code\u0026gt;. This is done from the source code, in which each interesting line is numbered from 1 to 4.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;There are many ways to calculate the BigOh. From this point forward we are going to assume that every sentence that doesn\u0026apos;t depend on the size of the input data takes a constant \u0026lt;code\u0026gt;C\u0026lt;/code\u0026gt; number computational steps.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;We are going to add the individual number of steps of the function, and neither the local variable declaration nor the return statement depends on the size of the \u0026lt;code\u0026gt;data\u0026lt;/code\u0026gt; array.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;That means that lines 1 and 4 takes C amount of steps each, and the function is somewhat like this:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;f(N) = C + ??? + C\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;The next part is to define the value of the \u0026lt;code\u0026gt;for\u0026lt;/code\u0026gt; statement. Remember that we are counting the number of computational steps, meaning that the body of the \u0026lt;code\u0026gt;for\u0026lt;/code\u0026gt; statement gets executed \u0026lt;code\u0026gt;N\u0026lt;/code\u0026gt; times. That\u0026apos;s the same as adding \u0026lt;code\u0026gt;C\u0026lt;/code\u0026gt;, \u0026lt;code\u0026gt;N\u0026lt;/code\u0026gt; times:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;f(N) = C + (C + C + ... + C) + C = C + N * C + C\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;There is no mechanical rule to count how many times the body of the \u0026lt;code\u0026gt;for\u0026lt;/code\u0026gt; gets executed, you need to count it by looking at what does the code do. To simplify the calculations, we are ignoring the variable initialization, condition and increment parts of the \u0026lt;code\u0026gt;for\u0026lt;/code\u0026gt; statement.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;To get the actual BigOh we need the \u0026lt;a href=\u0026quot;http://en.wikipedia.org/wiki/Asymptotic_analysis\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;Asymptotic analysis\u0026lt;/a\u0026gt; of the function. This is roughly done like this:\u0026lt;/p\u0026gt;\n\n\u0026lt;ol\u0026gt;\n\u0026lt;li\u0026gt;Take away all the constants \u0026lt;code\u0026gt;C\u0026lt;/code\u0026gt;.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;From \u0026lt;code\u0026gt;f()\u0026lt;/code\u0026gt; get the \u0026lt;a href=\u0026quot;http://en.wikipedia.org/wiki/Polynomial\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;polynomium\u0026lt;/a\u0026gt; in its \u0026lt;code\u0026gt;standard form\u0026lt;/code\u0026gt;.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Divide the terms of the polynomium and sort them by the rate of growth.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Keep the one that grows bigger when \u0026lt;code\u0026gt;N\u0026lt;/code\u0026gt; approaches \u0026lt;code\u0026gt;infinity\u0026lt;/code\u0026gt;.\u0026lt;/li\u0026gt;\n\u0026lt;/ol\u0026gt;\n\n\u0026lt;p\u0026gt;Our \u0026lt;code\u0026gt;f()\u0026lt;/code\u0026gt; has two terms:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;f(N) = 2 * C * N ^ 0 + 1 * C * N ^ 1\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Taking away all the \u0026lt;code\u0026gt;C\u0026lt;/code\u0026gt; constants and redundant parts:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;f(N) = 1 + N ^ 1\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Since the last term is the one which grows bigger when \u0026lt;code\u0026gt;f()\u0026lt;/code\u0026gt; approaches infinity (think on \u0026lt;a href=\u0026quot;http://en.wikipedia.org/wiki/Limit_%28mathematics%29\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;limits\u0026lt;/a\u0026gt;) this is the BigOh argument, and the \u0026lt;code\u0026gt;sum()\u0026lt;/code\u0026gt; function has a BigOh of:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;O(N)\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;hr\u0026gt;\n\n\u0026lt;p\u0026gt;There are a few tricks to solve some tricky ones: use \u0026lt;a href=\u0026quot;http://en.wikipedia.org/wiki/Summation\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;summations\u0026lt;/a\u0026gt; whenever you can.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;As an example, this code can be easily solved using summations:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;for (i = 0; i \u0026amp;lt; 2*n; i += 2) {  // 1\n    for (j=n; j \u0026amp;gt; i; j--) {     // 2\n        foo();                  // 3\n    }\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;The first thing you needed to be asked is the order of execution of \u0026lt;code\u0026gt;foo()\u0026lt;/code\u0026gt;. While the usual is to be \u0026lt;code\u0026gt;O(1)\u0026lt;/code\u0026gt;, you need to ask your professors about it. \u0026lt;code\u0026gt;O(1)\u0026lt;/code\u0026gt; means (almost, mostly) constant \u0026lt;code\u0026gt;C\u0026lt;/code\u0026gt;, independent of the size \u0026lt;code\u0026gt;N\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;The \u0026lt;code\u0026gt;for\u0026lt;/code\u0026gt; statement on the sentence number one is tricky. While the index ends at \u0026lt;code\u0026gt;2 * N\u0026lt;/code\u0026gt;, the increment is done by two. That means that the first \u0026lt;code\u0026gt;for\u0026lt;/code\u0026gt; gets executed only \u0026lt;code\u0026gt;N\u0026lt;/code\u0026gt; steps, and we need to divide the count by two.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;f(N) = Summation(i from 1 to 2 * N / 2)( ... ) = \n     = Summation(i from 1 to N)( ... )\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;The sentence number \u0026lt;em\u0026gt;two\u0026lt;/em\u0026gt; is even trickier since it depends on the value of \u0026lt;code\u0026gt;i\u0026lt;/code\u0026gt;. Take a look: the index i takes the values: 0, 2, 4, 6, 8, ..., 2 * N, and the second \u0026lt;code\u0026gt;for\u0026lt;/code\u0026gt; get executed: N times the first one, N - 2 the second, N - 4 the third... up to the N / 2 stage, on which the second \u0026lt;code\u0026gt;for\u0026lt;/code\u0026gt; never gets executed.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;On formula, that means:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;f(N) = Summation(i from 1 to N)( Summation(j = ???)(  ) )\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Again, we are counting \u0026lt;strong\u0026gt;the number of steps\u0026lt;/strong\u0026gt;. And by definition, every summation should always start at one, and end at a number bigger-or-equal than one.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;f(N) = Summation(i from 1 to N)( Summation(j = 1 to (N - (i - 1) * 2)( C ) )\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;(We are assuming that \u0026lt;code\u0026gt;foo()\u0026lt;/code\u0026gt; is \u0026lt;code\u0026gt;O(1)\u0026lt;/code\u0026gt; and takes \u0026lt;code\u0026gt;C\u0026lt;/code\u0026gt; steps.)\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;We have a problem here: when \u0026lt;code\u0026gt;i\u0026lt;/code\u0026gt; takes the value \u0026lt;code\u0026gt;N / 2 + 1\u0026lt;/code\u0026gt; upwards, the inner Summation ends at a negative number! That\u0026apos;s impossible and wrong. We need to split the summation in two, being the pivotal point the moment \u0026lt;code\u0026gt;i\u0026lt;/code\u0026gt; takes \u0026lt;code\u0026gt;N / 2 + 1\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;f(N) = Summation(i from 1 to N / 2)( Summation(j = 1 to (N - (i - 1) * 2)) * ( C ) ) + Summation(i from 1 to N / 2) * ( C )\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Since the pivotal moment \u0026lt;code\u0026gt;i \u0026amp;gt; N / 2\u0026lt;/code\u0026gt;, the inner \u0026lt;code\u0026gt;for\u0026lt;/code\u0026gt; won\u0026apos;t get executed, and we are assuming a constant C execution complexity on its body.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Now the summations can be simplified using some identity rules:\u0026lt;/p\u0026gt;\n\n\u0026lt;ol\u0026gt;\n\u0026lt;li\u0026gt;Summation(w from 1 to N)( C ) = N * C\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Summation(w from 1 to N)( A (+/-) B ) = Summation(w from 1 to N)( A ) (+/-) Summation(w from 1 to N)( B )\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Summation(w from 1 to N)( w * C ) = C * Summation(w from 1 to N)( w ) (C is a constant, independent of \u0026lt;code\u0026gt;w\u0026lt;/code\u0026gt;)\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Summation(w from 1 to N)( w ) = (N * (N + 1)) / 2\u0026lt;/li\u0026gt;\n\u0026lt;/ol\u0026gt;\n\n\u0026lt;p\u0026gt;Applying some algebra:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;f(N) = Summation(i from 1 to N / 2)( (N - (i - 1) * 2) * ( C ) ) + (N / 2)( C )\n\nf(N) = C * Summation(i from 1 to N / 2)( (N - (i - 1) * 2)) + (N / 2)( C )\n\nf(N) = C * (Summation(i from 1 to N / 2)( N ) - Summation(i from 1 to N / 2)( (i - 1) * 2)) + (N / 2)( C )\n\nf(N) = C * (( N ^ 2 / 2 ) - 2 * Summation(i from 1 to N / 2)( i - 1 )) + (N / 2)( C )\n\n=\u0026amp;gt; Summation(i from 1 to N / 2)( i - 1 ) = Summation(i from 1 to N / 2 - 1)( i )\n\nf(N) = C * (( N ^ 2 / 2 ) - 2 * Summation(i from 1 to N / 2 - 1)( i )) + (N / 2)( C )\n\nf(N) = C * (( N ^ 2 / 2 ) - 2 * ( (N / 2 - 1) * (N / 2 - 1 + 1) / 2) ) + (N / 2)( C )\n\n=\u0026amp;gt; (N / 2 - 1) * (N / 2 - 1 + 1) / 2 = \n\n   (N / 2 - 1) * (N / 2) / 2 = \n\n   ((N ^ 2 / 4) - (N / 2)) / 2 = \n\n   (N ^ 2 / 8) - (N / 4)\n\nf(N) = C * (( N ^ 2 / 2 ) - 2 * ( (N ^ 2 / 8) - (N / 4) )) + (N / 2)( C )\n\nf(N) = C * (( N ^ 2 / 2 ) - ( (N ^ 2 / 4) - (N / 2) )) + (N / 2)( C )\n\nf(N) = C * (( N ^ 2 / 2 ) - (N ^ 2 / 4) + (N / 2)) + (N / 2)( C )\n\nf(N) = C * ( N ^ 2 / 4 ) + C * (N / 2) + C * (N / 2)\n\nf(N) = C * ( N ^ 2 / 4 ) + 2 * C * (N / 2)\n\nf(N) = C * ( N ^ 2 / 4 ) + C * N\n\nf(N) = C * 1/4 * N ^ 2 + C * N\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;And the BigOh is:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;O(N²)\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Big O gives the upper bound for time complexity of an algorithm.  It is usually used in conjunction with processing data sets (lists) but can be used elsewhere.  \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;A few examples of how it\u0026apos;s used in C code.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Say we have an array of n elements\u0026lt;/p\u0026gt;\n\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;int array[n];\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;If we wanted to access the first element of the array this would be O(1) since it doesn\u0026apos;t matter how big the array is, it always takes the same constant time to get the first item.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;x = array[0];\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;If we wanted to find a number in the list:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;for(int i = 0; i \u0026amp;lt; n; i++){\n    if(array[i] == numToFind){ return i; }\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;This would be O(n) since at most we would have to look through the entire list to find our number.  The Big-O is still O(n) even though we might find our number the first try and run through the loop once because Big-O describes the upper bound for an algorithm (omega is for lower bound and theta is for tight bound).\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;When we get to nested loops:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;for(int i = 0; i \u0026amp;lt; n; i++){\n    for(int j = i; j \u0026amp;lt; n; j++){\n        array[j] += 2;\n    }\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;This is O(n^2) since for each pass of the outer loop ( O(n) ) we have to go through the entire list again so the n\u0026apos;s multiply leaving us with n squared.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;This is barely scratching the surface but when you get to analyzing more complex algorithms complex math involving proofs comes into play.  Hope this familiarizes you with the basics at least though.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;While knowing how to figure out the Big O time for your particular problem is useful, knowing some general cases can go a long way in helping you make decisions in your algorithm.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Here are some of the most common cases, lifted from \u0026lt;a href=\u0026quot;http://en.wikipedia.org/wiki/Big_O_notation#Orders_of_common_functions\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;http://en.wikipedia.org/wiki/Big_O_notation#Orders_of_common_functions\u0026lt;/a\u0026gt;:\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;O(1) - Determining if a number is even or odd; using a constant-size lookup table or hash table\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;O(logn) - Finding an item in a sorted array with a binary search\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;O(n) - Finding an item in an unsorted list; adding two n-digit numbers\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;O(n\u0026lt;sup\u0026gt;2\u0026lt;/sup\u0026gt;) - Multiplying two n-digit numbers by a simple algorithm; adding two n×n matrices; bubble sort or insertion sort\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;O(n\u0026lt;sup\u0026gt;3\u0026lt;/sup\u0026gt;) - Multiplying two n×n matrices by simple algorithm\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;O(c\u0026lt;sup\u0026gt;n\u0026lt;/sup\u0026gt;) - Finding the (exact) solution to the traveling salesman problem using dynamic programming; determining if two logical statements are equivalent using brute force\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;O(n!) - Solving the traveling salesman problem via brute-force search\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;O(n\u0026lt;sup\u0026gt;n\u0026lt;/sup\u0026gt;) - Often used instead of O(n!) to derive simpler formulas for asymptotic complexity\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Small reminder: the \u0026lt;code\u0026gt;big O\u0026lt;/code\u0026gt; notation is used to denote \u0026lt;em\u0026gt;asymptotic\u0026lt;/em\u0026gt; complexity (that is, when the size of the problem grows to infinity), \u0026lt;em\u0026gt;and\u0026lt;/em\u0026gt; it hides a constant.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;This means that between an algorithm in O(n) and one in O(n\u0026lt;sup\u0026gt;2\u0026lt;/sup\u0026gt;), the fastest is not always the first one (though there always exists a value of n such that for problems of size \u0026amp;gt;n, the first algorithm is the fastest).\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Note that the hidden constant very much depends on the implementation!\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Also, in some cases, the runtime is not a deterministic function of the \u0026lt;em\u0026gt;size\u0026lt;/em\u0026gt; n of the input. Take sorting using quick sort for example: the time needed to sort an array of n elements is not a constant but depends on the starting configuration of the array. \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;There are different time complexities: \u0026lt;/p\u0026gt;\n\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;Worst case (usually the simplest to figure out, though not always very meaningful)\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;Average case (usually much harder to figure out...)\u0026lt;/p\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;...\u0026lt;/p\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\n\u0026lt;p\u0026gt;A good introduction is \u0026lt;em\u0026gt;An Introduction to the Analysis of Algorithms\u0026lt;/em\u0026gt; by R. Sedgewick and P. Flajolet.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;As you say, \u0026lt;code\u0026gt;premature optimisation is the root of all evil\u0026lt;/code\u0026gt;, and (if possible) \u0026lt;em\u0026gt;profiling\u0026lt;/em\u0026gt; really should always be used when optimising code. It can even help you determine the complexity of your algorithms.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Seeing the answers here I think we can conclude that most of us do indeed approximate the order of the algorithm by \u0026lt;em\u0026gt;looking\u0026lt;/em\u0026gt; at it and use common sense instead of calculating it with, for example, the \u0026lt;a href=\u0026quot;http://en.wikipedia.org/wiki/Master_theorem\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;master method\u0026lt;/a\u0026gt; as we were thought at university.\nWith that said I must add that even the professor encouraged us (later on) to actually \u0026lt;em\u0026gt;think\u0026lt;/em\u0026gt; about it instead of just calculating it.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Also I would like to add how it is done for \u0026lt;strong\u0026gt;recursive functions\u0026lt;/strong\u0026gt;:\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;suppose we have a function like (\u0026lt;a href=\u0026quot;http://plt-scheme.org/\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;scheme code\u0026lt;/a\u0026gt;):\u0026lt;/p\u0026gt;\n\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;(define (fac n)\n    (if (= n 0)\n        1\n            (* n (fac (- n 1)))))\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;which recursively calculates the factorial of the given number.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;The first step is to try and determine the performance characteristic for \u0026lt;em\u0026gt;the body of the function only\u0026lt;/em\u0026gt; in this case, nothing special is done in the body, just a multiplication (or the return of the value 1).\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;So the \u0026lt;strong\u0026gt;performance for the body is: O(1)\u0026lt;/strong\u0026gt; (constant).\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Next try and determine this for the \u0026lt;em\u0026gt;number of recursive calls\u0026lt;/em\u0026gt;. In this case we have n-1 recursive calls.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;So the \u0026lt;strong\u0026gt;performance for the recursive calls is: O(n-1)\u0026lt;/strong\u0026gt; (order is n, as we throw away the insignificant parts).\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Then put those two together and you then have the performance for the whole recursive function:  \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;1 * (n-1) = O(n)\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;hr\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;a href=\u0026quot;https://stackoverflow.com/users/1192/peter-holmdahl\u0026quot;\u0026gt;Peter\u0026lt;/a\u0026gt;, to answer \u0026lt;a href=\u0026quot;https://stackoverflow.com/questions/3255/big-o-how-do-you-calculateapproximate-it#12001\u0026quot;\u0026gt;your raised issues;\u0026lt;/a\u0026gt; the method I describe here actually handles this quite well. But keep in mind that this is still an \u0026lt;em\u0026gt;approximation\u0026lt;/em\u0026gt; and not a full mathematically correct answer. The method described here is also one of the methods we were taught at university, and if I remember correctly was used for far more advanced algorithms than the factorial I used in this example.\u0026lt;br\u0026gt;\nOf course it all depends on how well you can estimate the running time of the body of the function and the number of recursive calls, but that is just as true for the other methods.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;If your cost is a polynomial, just keep the highest-order term, without its multiplier. E.g.:\u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;O((n/2 + 1)*(n/2)) = O(n\u0026lt;sup\u0026gt;2\u0026lt;/sup\u0026gt;/4 + n/2) = O(n\u0026lt;sup\u0026gt;2\u0026lt;/sup\u0026gt;/4) = O(n\u0026lt;sup\u0026gt;2\u0026lt;/sup\u0026gt;)\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;p\u0026gt;This doesn\u0026apos;t work for infinite series, mind you. There is no single recipe for the general case, though for some common cases, the following inequalities apply:\u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;O(log \u0026lt;em\u0026gt;N\u0026lt;/em\u0026gt;) \u0026amp;lt; O(\u0026lt;em\u0026gt;N\u0026lt;/em\u0026gt;) \u0026amp;lt; O(\u0026lt;em\u0026gt;N\u0026lt;/em\u0026gt; log \u0026lt;em\u0026gt;N\u0026lt;/em\u0026gt;) \u0026amp;lt; O(\u0026lt;em\u0026gt;N\u0026lt;/em\u0026gt;\u0026lt;sup\u0026gt;2\u0026lt;/sup\u0026gt;) \u0026amp;lt; O(\u0026lt;em\u0026gt;N\u0026lt;/em\u0026gt;\u0026lt;sup\u0026gt;k\u0026lt;/sup\u0026gt;) \u0026amp;lt; O(e\u0026lt;sup\u0026gt;\u0026lt;em\u0026gt;n\u0026lt;/em\u0026gt;\u0026lt;/sup\u0026gt;) \u0026amp;lt; O(\u0026lt;em\u0026gt;n\u0026lt;/em\u0026gt;!)\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n    ","\n\u0026lt;p\u0026gt;I think about it in terms of information. Any problem consists of learning a certain number of bits.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Your basic tool is the concept of decision points and their entropy. The entropy of a decision point is the average information it will give you. For example, if a program contains a decision point with two branches, it\u0026apos;s entropy is the sum of the probability of each branch times the log\u0026lt;sub\u0026gt;2\u0026lt;/sub\u0026gt; of the inverse probability of that branch. That\u0026apos;s how much you learn by executing that decision.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;For example, an \u0026lt;code\u0026gt;if\u0026lt;/code\u0026gt; statement having two branches, both equally likely, has an entropy of 1/2 * log(2/1) + 1/2 * log(2/1) = 1/2 * 1 + 1/2 * 1 = 1. So its entropy is 1 bit.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Suppose you are searching a table of N items, like N=1024. That is a 10-bit problem because log(1024) = 10 bits. So if you can search it with IF statements that have equally likely outcomes, it should take 10 decisions.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;That\u0026apos;s what you get with binary search.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Suppose you are doing linear search. You look at the first element and ask if it\u0026apos;s the one you want. The probabilities are 1/1024 that it is, and 1023/1024 that it isn\u0026apos;t. The entropy of that decision is 1/1024*log(1024/1) + 1023/1024 * log(1024/1023) = 1/1024 * 10 + 1023/1024 * about 0 = about .01 bit. You\u0026apos;ve learned very little! The second decision isn\u0026apos;t much better. That is why linear search is so slow. In fact it\u0026apos;s exponential in the number of bits you need to learn.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Suppose you are doing indexing. Suppose the table is pre-sorted into a lot of bins, and you use some of all of the bits in the key to index directly to the table entry. If there are 1024 bins, the entropy is 1/1024 * log(1024) + 1/1024 * log(1024) + ... for all 1024 possible outcomes. This is 1/1024 * 10 times 1024 outcomes, or 10 bits of entropy for that one indexing operation. That is why indexing search is fast.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Now think about sorting.  You have N items, and you have a list. For each item, you have to search for where the item goes in the list, and then add it to the list. So sorting takes roughly N times the number of steps of the underlying search.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;So sorts based on binary decisions having roughly equally likely outcomes all take about O(N log N) steps. An O(N) sort algorithm is possible if it is based on indexing search.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;I\u0026apos;ve found that nearly all algorithmic performance issues can be looked at in this way.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Lets start from the beginning.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;First of all, accept the principle that certain simple operations on data can be done in \u0026lt;code\u0026gt;O(1)\u0026lt;/code\u0026gt; time, that is, in time that is independent of the size of the input. These primitive operations in C consist of\u0026lt;/p\u0026gt;\n\n\u0026lt;ol\u0026gt;\n\u0026lt;li\u0026gt;Arithmetic operations (e.g. + or %).\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Logical operations (e.g., \u0026amp;amp;\u0026amp;amp;).\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Comparison operations (e.g., \u0026amp;lt;=).\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Structure accessing operations (e.g. array-indexing like A[i], or pointer fol-\nlowing with the -\u0026amp;gt; operator).\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Simple assignment such as copying a value into a variable.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Calls to library functions (e.g., scanf, printf).\u0026lt;/li\u0026gt;\n\u0026lt;/ol\u0026gt;\n\n\u0026lt;p\u0026gt;The justification for this principle requires a detailed study of the machine instructions (primitive steps) of a typical computer. Each of the described operations can be done with some small number of machine instructions; often only one or two instructions are needed.\nAs a consequence, several kinds of statements in C can be executed in \u0026lt;code\u0026gt;O(1)\u0026lt;/code\u0026gt; time, that is, in some constant amount of time independent of input. These simple include\u0026lt;/p\u0026gt;\n\n\u0026lt;ol\u0026gt;\n\u0026lt;li\u0026gt;Assignment statements that do not involve function calls in their expressions.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Read statements.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Write statements that do not require function calls to evaluate arguments.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;The jump statements break, continue, goto, and return expression, where\nexpression does not contain a function call.\u0026lt;/li\u0026gt;\n\u0026lt;/ol\u0026gt;\n\n\u0026lt;p\u0026gt;In C, many for-loops are formed by initializing an index variable to some value and\nincrementing that variable by 1 each time around the loop. The for-loop ends when\nthe index reaches some limit. For instance, the for-loop \u0026lt;/p\u0026gt;\n\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;for (i = 0; i \u0026amp;lt; n-1; i++) \n{\n    small = i;\n    for (j = i+1; j \u0026amp;lt; n; j++)\n        if (A[j] \u0026amp;lt; A[small])\n            small = j;\n    temp = A[small];\n    A[small] = A[i];\n    A[i] = temp;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;uses index variable i. It increments i by 1 each time around the loop, and the iterations\nstop when i reaches n  1.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;However, for the moment, focus on the simple form of for-loop, where the \u0026lt;strong\u0026gt;difference between the final and initial values, divided by the amount by which the index variable is incremented tells us how many times we go around the loop\u0026lt;/strong\u0026gt;. That count is exact, unless there are ways to exit the loop via a jump statement; it is an upper bound on the number of iterations in any case. \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;For instance, the for-loop iterates \u0026lt;code\u0026gt;((n  1)  0)/1 = n  1 times\u0026lt;/code\u0026gt;,\nsince 0 is the initial value of i, n  1 is the highest value reached by i (i.e., when i\nreaches n1, the loop stops and no iteration occurs with i = n1), and 1 is added\nto i at each iteration of the loop.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;In the simplest case, where the time spent in the loop body is the same for each\niteration, \u0026lt;strong\u0026gt;we can multiply the big-oh upper bound for the body by the number of\ntimes around the loop\u0026lt;/strong\u0026gt;. Strictly speaking, we must then \u0026lt;strong\u0026gt;add O(1) time to initialize\nthe loop index and O(1) time for the first comparison of the loop index with the\nlimit\u0026lt;/strong\u0026gt;, because we test one more time than we go around the loop. However, unless\nit is possible to execute the loop zero times, the time to initialize the loop and test\nthe limit once is a low-order term that can be dropped by the summation rule.\u0026lt;/p\u0026gt;\n\n\u0026lt;hr\u0026gt;\n\n\u0026lt;p\u0026gt;Now consider this example:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;(1) for (j = 0; j \u0026amp;lt; n; j++)\n(2)   A[i][j] = 0;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;We know that \u0026lt;strong\u0026gt;line (1)\u0026lt;/strong\u0026gt; takes \u0026lt;code\u0026gt;O(1)\u0026lt;/code\u0026gt; time. Clearly, we go around the loop n times, as\nwe can determine by subtracting the lower limit from the upper limit found on line\n(1) and then adding 1. Since the body, line (2), takes O(1) time, we can neglect the\ntime to increment j and the time to compare j with n, both of which are also O(1).\nThus, the running time of lines (1) and (2) is the \u0026lt;strong\u0026gt;product of n and O(1)\u0026lt;/strong\u0026gt;, which is \u0026lt;code\u0026gt;O(n)\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Similarly, we can bound the running time of the outer loop consisting of lines\n(2) through (4), which is\u0026lt;/p\u0026gt;\n\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;(2) for (i = 0; i \u0026amp;lt; n; i++)\n(3)     for (j = 0; j \u0026amp;lt; n; j++)\n(4)         A[i][j] = 0;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;We have already established that the loop of lines (3) and (4) takes O(n) time.\nThus, we can neglect the O(1) time to increment i and to test whether i \u0026amp;lt; n in\neach iteration, concluding that each iteration of the outer loop takes O(n) time.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;The initialization i = 0 of the outer loop and the (n + 1)st test of the condition\ni \u0026amp;lt; n likewise take O(1) time and can be neglected. Finally, we observe that we go\naround the outer loop n times, taking O(n) time for each iteration, giving a total\n\u0026lt;code\u0026gt;O(n^2)\u0026lt;/code\u0026gt; running time.\u0026lt;/p\u0026gt;\n\n\u0026lt;hr\u0026gt;\n\n\u0026lt;p\u0026gt;A more practical example.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;img src=\u0026quot;https://i.stack.imgur.com/ceoAc.png\u0026quot; alt=\u0026quot;enter image description here\u0026quot;\u0026gt;\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;If you want to estimate the order of your code empirically rather than by analyzing the code, you could stick in a series of increasing values of n and time your code.  Plot your timings on a log scale.  If the code is O(x^n), the values should fall on a line of slope n.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;This has several advantages over just studying the code.  For one thing, you can see whether you\u0026apos;re in the range where the run time approaches its asymptotic order. Also, you may find that some code that you thought was order O(x) is really order O(x^2), for example, because of time spent in library calls.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Basically the thing that crops up 90% of the time is just analyzing loops.  Do you have single, double, triple nested loops?  The you have O(n), O(n^2), O(n^3) running time.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Very rarely (unless you are writing a platform with an extensive base library (like for instance, the .NET BCL, or C++\u0026apos;s STL) you will encounter anything that is more difficult than just looking at your loops (for statements, while, goto, etc...)\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Less useful generally, I think, but for the sake of completeness there is also a \u0026lt;a href=\u0026quot;http://en.wikipedia.org/wiki/Big_O_notation#Family_of_Bachmann.E2.80.93Landau_notations\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;Big Omega Ω\u0026lt;/a\u0026gt;, which defines a lower-bound on an algorithm\u0026apos;s complexity, and a \u0026lt;a href=\u0026quot;http://en.wikipedia.org/wiki/Big_O_notation#Related_asymptotic_notations\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;Big Theta Θ\u0026lt;/a\u0026gt;, which defines both an upper and lower bound.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Big O notation is useful because it\u0026apos;s easy to work with and hides unnecessary complications and details (for some definition of unnecessary). One nice way of working out the complexity of divide and conquer algorithms is the tree method. Let\u0026apos;s say you have a version of quicksort with the median procedure, so you split the array into perfectly balanced subarrays every time.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Now build a tree corresponding to all the arrays you work with. At the root you have the original array, the root has two children which are the subarrays. Repeat this until you have single element arrays at the bottom. \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Since we can find the median in O(n) time and split the array in two parts in O(n) time, the work done at each node is O(k) where k is the size of the array. Each level of the tree contains (at most) the entire array so the work per level is O(n) (the sizes of the subarrays add up to n, and since we have O(k) per level we can add this up). There are only log(n) levels in the tree since each time we halve the input.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Therefore we can upper bound the amount of work by O(n*log(n)). \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;However, Big O hides some details which we sometimes can\u0026apos;t ignore. Consider computing the Fibonacci sequence with\u0026lt;/p\u0026gt;\n\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;a=0;\nb=1;\nfor (i = 0; i \u0026amp;lt;n; i++) {\n    tmp = b;\n    b = a + b;\n    a = tmp;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;and lets just assume the a and b are BigIntegers in Java or something that can handle arbitrarily large numbers. Most people would say this is an O(n) algorithm without flinching. The reasoning is that you have n iterations in the for loop and O(1) work in side the loop. \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;But Fibonacci numbers are large, the n-th Fibonacci number is exponential in n so just storing it will take on the order of n bytes. Performing addition with big integers will take O(n) amount of work. So the total amount of work done in this procedure is \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;1 + 2 + 3 + ... + n = n(n-1)/2 = O(n^2)\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;So this algorithm runs in quadradic time!\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Familiarity with the algorithms/data structures I use and/or quick glance analysis of iteration nesting.  The difficulty is when you call a library function, possibly multiple times - you can often be unsure of whether you are calling the function unnecessarily at times or what implementation they are using.  Maybe library functions should have a complexity/efficiency measure, whether that be Big O or some other metric, that is available in documentation or even \u0026lt;a href=\u0026quot;http://en.wikipedia.org/wiki/IntelliSense\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;IntelliSense\u0026lt;/a\u0026gt;.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Break down the algorithm into pieces you know the big O notation for, and combine through big O operators. That\u0026apos;s the only way I know of.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;For more information, check the \u0026lt;a href=\u0026quot;http://en.wikipedia.org/wiki/Big_O_notation\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;Wikipedia page\u0026lt;/a\u0026gt; on the subject.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;As to \u0026quot;how do you calculate\u0026quot; Big O, this is part of \u0026lt;a href=\u0026quot;http://en.wikipedia.org/wiki/Computational_complexity_theory\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;Computational complexity theory\u0026lt;/a\u0026gt;. For some (many) special cases you may be able to come with some simple heuristics (like multiplying loop counts for nested loops), esp. when all you want is any upper bound estimation, and you do not mind if it is too pessimistic - which I guess is probably what your question is about.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;If you really want to answer your question for any algorithm the best you can do is to apply the theory. Besides of simplistic \u0026quot;worst case\u0026quot; analysis I have found \u0026lt;a href=\u0026quot;http://en.wikipedia.org/wiki/Amortized_analysis\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;Amortized analysis\u0026lt;/a\u0026gt; very useful in practice.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;For the 1st case, the inner loop is executed \u0026lt;code\u0026gt;n-i\u0026lt;/code\u0026gt; times, so the total number of executions is the sum for \u0026lt;code\u0026gt;i\u0026lt;/code\u0026gt; going from \u0026lt;code\u0026gt;0\u0026lt;/code\u0026gt; to \u0026lt;code\u0026gt;n-1\u0026lt;/code\u0026gt; (because lower than, not lower than or equal) of the \u0026lt;code\u0026gt;n-i\u0026lt;/code\u0026gt;. You get finally \u0026lt;code\u0026gt;n*(n + 1) / 2\u0026lt;/code\u0026gt;, so \u0026lt;code\u0026gt;O(n²/2) = O(n²)\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;For the 2nd loop, \u0026lt;code\u0026gt;i\u0026lt;/code\u0026gt; is between \u0026lt;code\u0026gt;0\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;n\u0026lt;/code\u0026gt; included for the outer loop; then the inner loop is executed when \u0026lt;code\u0026gt;j\u0026lt;/code\u0026gt; is strictly greater than \u0026lt;code\u0026gt;n\u0026lt;/code\u0026gt;, which is then impossible.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;In addition to using the master method (or one of its specializations), I test my algorithms experimentally.  This can\u0026apos;t \u0026lt;em\u0026gt;prove\u0026lt;/em\u0026gt; that any particular complexity class is achieved, but it can provide reassurance that the mathematical analysis is appropriate.  To help with this reassurance, I use code coverage tools in conjunction with my experiments, to ensure that I\u0026apos;m exercising all the cases.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;As a very simple example say you wanted to do a sanity check on the speed of the .NET framework\u0026apos;s list sort.  You could write something like the following, then analyze the results in Excel to make sure they did not exceed an n*log(n) curve.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;In this example I measure the number of comparisons, but it\u0026apos;s also prudent to examine the actual time required for each sample size.  However then you must be even more careful that you are just measuring the algorithm and not including artifacts from your test infrastructure.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;int nCmp = 0;\nSystem.Random rnd = new System.Random();\n\n// measure the time required to sort a list of n integers\nvoid DoTest(int n)\n{\n   List\u0026amp;lt;int\u0026amp;gt; lst = new List\u0026amp;lt;int\u0026amp;gt;(n);\n   for( int i=0; i\u0026amp;lt;n; i++ )\n      lst[i] = rnd.Next(0,1000);\n\n   // as we sort, keep track of the number of comparisons performed!\n   nCmp = 0;\n   lst.Sort( delegate( int a, int b ) { nCmp++; return (a\u0026amp;lt;b)?-1:((a\u0026amp;gt;b)?1:0)); }\n\n   System.Console.Writeline( \u0026quot;{0},{1}\u0026quot;, n, nCmp );\n}\n\n\n// Perform measurement for a variety of sample sizes.\n// It would be prudent to check multiple random samples of each size, but this is OK for a quick sanity check\nfor( int n = 0; n\u0026amp;lt;1000; n++ )\n   DoTest(n);\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Don\u0026apos;t forget to also allow for space complexities that can also be a cause for concern if one has limited memory resources.  So for example you may hear someone wanting a constant space algorithm which is basically a way of saying that the amount of space taken by the algorithm doesn\u0026apos;t depend on any factors inside the code.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Sometimes the complexity can come from how many times is something called, how often is a loop executed, how often is memory allocated, and so on is another part to answer this question.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Lastly, big O can be used for worst case, best case, and amortization cases where generally it is the worst case that is used for describing how bad an algorithm may be.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;I would like to explain the Big-O in a little bit different aspect.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Big-O is just to compare the complexity of the programs which means how fast are they growing when the inputs are increasing and not the exact time which is spend to do the action.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;IMHO in the big-O formulas you better not to use more complex equations (you might just stick to the ones in the following graph.) However you still might use other more precise formula (like 3^n, n^3, ...) but more than that can be sometimes misleading! So better to keep it as simple as possible.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;a href=\u0026quot;https://i.stack.imgur.com/ZEmZ6.png\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;\u0026lt;img src=\u0026quot;https://i.stack.imgur.com/ZEmZ6.png\u0026quot; alt=\u0026quot;enter image description here\u0026quot;\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;I would like to emphasize once again that here we don\u0026apos;t want to get an exact formula for our algorithm. We only want to show how it grows when the inputs are growing and compare with the other algorithms in that sense. Otherwise you would better use different methods like bench-marking.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;What often gets overlooked is the \u0026lt;em\u0026gt;expected\u0026lt;/em\u0026gt; behavior of your algorithms. \u0026lt;strong\u0026gt;It doesn\u0026apos;t change the Big-O of your algorithm\u0026lt;/strong\u0026gt;, but it does relate to the statement \u0026quot;premature optimization. . ..\u0026quot;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Expected behavior of your algorithm is -- very dumbed down -- how fast you can expect your algorithm to work on data you\u0026apos;re most likely to see. \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;For instance, if you\u0026apos;re searching for a value in a list, it\u0026apos;s O(n), but if you know that most lists you see have your value up front, typical behavior of your algorithm is faster. \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;To really nail it down, you need to be able to describe the probability distribution of your \u0026quot;input space\u0026quot; (if you need to sort a list, how often is that list already going to be sorted? how often is it totally reversed? how often is it mostly sorted?) It\u0026apos;s not always feasible that you know that, but sometimes you do. \u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;great question!\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Disclaimer: this answer contains false statements see the comments below.\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;If you\u0026apos;re using the Big O, you\u0026apos;re talking about the worse case (more on what that means later). Additionally, there is capital theta for average case and a big omega for best case.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Check out this site for a lovely formal definition of Big O: \u0026lt;a href=\u0026quot;https://xlinux.nist.gov/dads/HTML/bigOnotation.html\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;https://xlinux.nist.gov/dads/HTML/bigOnotation.html\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;f(n) = O(g(n)) means there are positive constants c and k, such that 0  f(n)  cg(n) for all n  k. The values of c and k must be fixed for the function f and must not depend on n. \u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;hr\u0026gt;\n\n\u0026lt;p\u0026gt;Ok, so now what do we mean by \u0026quot;best-case\u0026quot; and \u0026quot;worst-case\u0026quot; complexities?\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;This is probably most clearly illustrated through examples. For example if we are using linear search to find a number in a sorted array then the \u0026lt;strong\u0026gt;worst case\u0026lt;/strong\u0026gt; is when we decide to \u0026lt;strong\u0026gt;search for the last element\u0026lt;/strong\u0026gt; of the array as this would take as many steps as there are items in the array. The \u0026lt;strong\u0026gt;best case\u0026lt;/strong\u0026gt; would be when we search for the \u0026lt;strong\u0026gt;first element\u0026lt;/strong\u0026gt; since we would be done after the first check.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;The point of all these \u0026lt;em\u0026gt;adjective\u0026lt;/em\u0026gt;-case complexities is that we\u0026apos;re looking for a way to graph the amount of time a hypothetical program runs to completion in terms of the size of particular variables. However for many algorithms you can argue that there is not a single time for a particular size of input. Notice that this contradicts with the fundamental requirement of a function, any input should have no more than one output. So we come up with \u0026lt;em\u0026gt;multiple\u0026lt;/em\u0026gt; functions to describe an algorithm\u0026apos;s complexity. Now, even though searching an array of size n may take varying amounts of time depending on what you\u0026apos;re looking for in the array and depending proportionally to n, we can create an informative description of the algorithm using best-case, average-case, and worst-case classes.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Sorry this is so poorly written and lacks much technical information. But hopefully it\u0026apos;ll make time complexity classes easier to think about. Once you become comfortable with these it becomes a simple matter of parsing through your program and looking for things like for-loops that depend on array sizes and reasoning based on your data structures what kind of input would result in trivial cases and what input would result in worst-cases.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;First of all, the accepted answer is trying to explain nice fancy stuff, \u0026lt;br\u0026gt;\nbut I think, \u0026lt;em\u0026gt;intentionally\u0026lt;/em\u0026gt; complicating Big-Oh is not the solution,\u0026lt;br\u0026gt;\nwhich programmers (or at least, people like me) search for.\u0026lt;/p\u0026gt;\n\u0026lt;h2\u0026gt;Big Oh (in short)\u0026lt;/h2\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;f\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;text\u0026lt;/span\u0026gt;) {\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; n = text.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;length\u0026lt;/span\u0026gt;;\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt; (\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; i = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;; i \u0026amp;lt; n; i++) {\n    \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;f\u0026lt;/span\u0026gt;(text.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;slice\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;, n-\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;))\n  }\n  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// ... other JS logic here, which we can ignore ...\u0026lt;/span\u0026gt;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;Big Oh of above is f(n) = \u0026lt;strong\u0026gt;O(n!)\u0026lt;/strong\u0026gt; where \u0026lt;strong\u0026gt;n\u0026lt;/strong\u0026gt; represents \u0026lt;code\u0026gt;number\u0026lt;/code\u0026gt; of items in input set,\nand \u0026lt;strong\u0026gt;f\u0026lt;/strong\u0026gt; represents \u0026lt;code\u0026gt;operation\u0026lt;/code\u0026gt; done per item.\u0026lt;/p\u0026gt;\n\u0026lt;hr\u0026gt;\n\u0026lt;p\u0026gt;Big-Oh notation is the asymptotic upper-bound of the complexity of an algorithm.\u0026lt;br\u0026gt;\nIn programming: The assumed worst-case time taken,\u0026lt;br\u0026gt;\nor assumed maximum repeat count of logic, for size of the input.\u0026lt;/p\u0026gt;\n\u0026lt;h2\u0026gt;Calculation\u0026lt;/h2\u0026gt;\n\u0026lt;p\u0026gt;Keep in mind (from above meaning) that; We just need \u0026lt;strong\u0026gt;worst-case time\u0026lt;/strong\u0026gt; and/or \u0026lt;strong\u0026gt;maximum repeat count\u0026lt;/strong\u0026gt; affected by \u0026lt;strong\u0026gt;N\u0026lt;/strong\u0026gt; (size of input),\u0026lt;br\u0026gt;\nThen take another look at (accepted answer\u0026apos;s) example:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt; (i = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;; i \u0026amp;lt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;*n; i += \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;) {  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// line 123\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt; (j=n; j \u0026amp;gt; i; j--) {     \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// line 124\u0026lt;/span\u0026gt;\n        foo();                  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// line 125\u0026lt;/span\u0026gt;\n    }\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;ol\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;Begin with this search-pattern:\u0026lt;/p\u0026gt;\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;Find first line that \u0026lt;strong\u0026gt;N\u0026lt;/strong\u0026gt; caused repeat behavior,\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Or caused increase of logic executed,\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;But constant or not, ignore anything before that line.\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;Seems line hundred-twenty-three is what we are searching ;-)\u0026lt;/p\u0026gt;\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;On first sight, line seems to have \u0026lt;code\u0026gt;2*n\u0026lt;/code\u0026gt; max-looping.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;But looking again, we see \u0026lt;code\u0026gt;i += 2\u0026lt;/code\u0026gt; (and that half is skipped).\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;So, max repeat is simply \u0026lt;strong\u0026gt;n\u0026lt;/strong\u0026gt;, write it down, like \u0026lt;code\u0026gt;f(n) = O( n \u0026lt;/code\u0026gt; but don\u0026apos;t close parenthesis yet.\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;Repeat search till method\u0026apos;s end, and find next line matching our search-pattern, here that\u0026apos;s line 124\u0026lt;/p\u0026gt;\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;Which is tricky, because strange condition, and reverse looping.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;But after remembering that we just need to consider maximum repeat count (or worst-case time taken).\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;It\u0026apos;s as easy as saying \u0026quot;Reverse-Loop \u0026lt;code\u0026gt;j\u0026lt;/code\u0026gt; starts with \u0026lt;code\u0026gt;j=n\u0026lt;/code\u0026gt;, am I right? yes, \u0026lt;strong\u0026gt;n\u0026lt;/strong\u0026gt; seems to be maximum possible repeat count\u0026quot;, so:\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;Add \u0026lt;code\u0026gt;n\u0026lt;/code\u0026gt; to previous write down\u0026apos;s end,\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;but like \u0026quot;\u0026lt;code\u0026gt;( n \u0026lt;/code\u0026gt;\u0026quot;  instead of \u0026quot;\u0026lt;code\u0026gt;+ n\u0026lt;/code\u0026gt;\u0026quot; (as this is inside previous loop),\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;and close parenthesis only if we find something outside of previous loop.\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;/ol\u0026gt;\n\u0026lt;p\u0026gt;Search Done! why? because line 125 (or any other line after) does not match our search-pattern.\u0026lt;br\u0026gt;\nWe can now close any parenthesis (left-open in our write down), resulting in below:\u0026lt;/p\u0026gt;\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;f(n) = O( n( n ) )\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;Try to further shorten \u0026quot;\u0026lt;code\u0026gt;n( n )\u0026lt;/code\u0026gt;\u0026quot; part, like:\u0026lt;/p\u0026gt;\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;strong\u0026gt;n( n ) = n * n\u0026lt;/strong\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;strong\u0026gt;= n\u0026lt;sup\u0026gt;2\u0026lt;/sup\u0026gt;\u0026lt;/strong\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Finally, just wrap it with Big Oh notation, like \u0026lt;strong\u0026gt;O(n\u0026lt;sup\u0026gt;2\u0026lt;/sup\u0026gt;)\u0026lt;/strong\u0026gt; or O(n^2) without formatting.\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n    ","\n\u0026lt;p\u0026gt;I don\u0026apos;t know how to programmatically solve this, but the first thing people do is that we sample the algorithm for certain patterns in the number of operations done, say 4n^2 + 2n + 1 we have 2 rules:\u0026lt;/p\u0026gt;\n\n\u0026lt;ol\u0026gt;\n\u0026lt;li\u0026gt;If we have a sum of terms, the term with the largest growth rate is kept, with other terms omitted.\n\u0026lt;br\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;If we have a product of several factors constant factors are omitted.\u0026lt;/li\u0026gt;\n\u0026lt;/ol\u0026gt;\n\n\u0026lt;p\u0026gt; If we simplify f(x), where f(x) is the formula for number of operations done, (4n^2 + 2n + 1 explained above), we obtain the big-O value [O(n^2) in this case]. But this would have to account for Lagrange interpolation in the program, which may be hard to implement. And what if the real big-O value was O(2^n), and we might have something like O(x^n), so this algorithm probably wouldn\u0026apos;t be programmable. But if someone proves me wrong, give me the code . . . .\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;For code A, the outer loop will execute for \u0026lt;code\u0026gt;n+1\u0026lt;/code\u0026gt; times, the \u0026apos;1\u0026apos; time means the process which checks the whether i still meets the requirement. And inner loop runs \u0026lt;code\u0026gt;n\u0026lt;/code\u0026gt; times, \u0026lt;code\u0026gt;n-2\u0026lt;/code\u0026gt; times.... Thus,\u0026lt;code\u0026gt;0+2+..+(n-2)+n= (0+n)(n+1)/2= O(n²)\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;For code B, though inner loop wouldn\u0026apos;t step in and execute the foo(), the inner loop will be executed for n times depend on outer loop execution time, which is O(n)\u0026lt;/p\u0026gt;\n    "],"id":398,"title":"Big O, how do you calculate/approximate it?","content":"\n                \n\u0026lt;p\u0026gt;Most people with a degree in CS will certainly know what \u0026lt;a href=\u0026quot;http://www.nist.gov/dads/HTML/bigOnotation.html\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;Big O stands for\u0026lt;/a\u0026gt;.\nIt helps us to measure how well an algorithm scales. \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;But I\u0026apos;m curious, how do \u0026lt;em\u0026gt;you\u0026lt;/em\u0026gt; calculate or approximate the complexity of your algorithms?\u0026lt;/p\u0026gt;\n    ","slug":"big-o-how-do-you-calculateapproximate-it-1657387856392","postType":"QUESTION","createdAt":"2022-07-09T17:30:56.000Z","updatedAt":"2022-07-09T17:30:56.000Z","tags":[],"relatedQuestions":[]},"randomQuestions":[{"title":"PHP code is not being executed, but the code shows in the browser source code","slug":"php-code-is-not-being-executed-but-the-code-shows-in-the-browser-source-code-1657384553581"},{"title":"Using global variables in a function","slug":"using-global-variables-in-a-function-1657384796002"},{"title":"How to serve static files in Flask","slug":"how-to-serve-static-files-in-flask-1657387862496"},{"title":"How do I execute a program or call a system command?","slug":"how-do-i-execute-a-program-or-call-a-system-command-1657385465629"},{"title":"Convert one date format into another in PHP","slug":"convert-one-date-format-into-another-in-php-1657384566234"},{"title":"Iterating over dictionaries using 'for' loops","slug":"iterating-over-dictionaries-using-'for'-loops-1657388334481"},{"title":"Selecting and manipulating CSS pseudo-elements such as ::before and ::after using javascript (or jQuery)","slug":"selecting-and-manipulating-css-pseudo-elements-such-as-::before-and-::after-using-javascript-(or-jquery)-1657387406132"},{"title":"Android permission doesn't work even if I have declared it","slug":"android-permission-doesn't-work-even-if-i-have-declared-it-1657387726990"},{"title":"Why JSF calls getters multiple times","slug":"why-jsf-calls-getters-multiple-times-1657388244489"},{"title":"Get the values from the \"GET\" parameters (JavaScript) [duplicate]","slug":"get-the-values-from-the-\"get\"-parameters-(javascript)-duplicate-1657387656693"},{"title":"Why are floating point numbers inaccurate?","slug":"why-are-floating-point-numbers-inaccurate-1657387346111"},{"title":"Performance optimization strategies of last resort [closed]","slug":"performance-optimization-strategies-of-last-resort-closed-1657388420614"},{"title":"How do I split a list into equally-sized chunks?","slug":"how-do-i-split-a-list-into-equally-sized-chunks-1657384580399"},{"title":"How should I use servlets and Ajax?","slug":"how-should-i-use-servlets-and-ajax-1657385492684"},{"title":"Why are these constructs using pre and post-increment undefined behavior?","slug":"why-are-these-constructs-using-pre-and-post-increment-undefined-behavior-1657384520109"},{"title":"How do I write a correct micro-benchmark in Java?","slug":"how-do-i-write-a-correct-micro-benchmark-in-java-1657384488725"},{"title":"How do I modify the URL without reloading the page?","slug":"how-do-i-modify-the-url-without-reloading-the-page-1657387509731"},{"title":"Why use getters and setters/accessors?","slug":"why-use-getters-and-settersaccessors-1657387343971"},{"title":"What is the difference between a definition and a declaration?","slug":"what-is-the-difference-between-a-definition-and-a-declaration-1657387851618"},{"title":"How do I vertically center text with CSS? [duplicate]","slug":"how-do-i-vertically-center-text-with-css-duplicate-1657387645821"}]},"__N_SSG":true},"page":"/questions/[slug]","query":{"slug":"big-o-how-do-you-calculateapproximate-it-1657387856392"},"buildId":"xZs8haGjOP63QuDE0kxeX","isFallback":false,"gsp":true,"locale":"en","locales":["en"],"defaultLocale":"en","scriptLoader":[]}</script></body></html>