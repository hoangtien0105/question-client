{"pageProps":{"data":{"answer":["\n&lt;p&gt;The iteration order for objects follows &lt;a href=&quot;https://stackoverflow.com/a/38218582/292500&quot;&gt;a certain set of rules&lt;/a&gt; since ES2015, but &lt;strong&gt;it does not (always) follow the insertion order&lt;/strong&gt;. Simply put, the iteration order is a combination of the insertion order for strings keys, and ascending order for number-like keys:&lt;/p&gt;\n&lt;pre class=&quot;lang-js s-code-block&quot;&gt;&lt;code class=&quot;hljs language-javascript&quot;&gt;&lt;span class=&quot;hljs-comment&quot;&gt;// key order: 1, foo, bar&lt;/span&gt;\n&lt;span class=&quot;hljs-keyword&quot;&gt;const&lt;/span&gt; obj = { &lt;span class=&quot;hljs-string&quot;&gt;&quot;foo&quot;&lt;/span&gt;: &lt;span class=&quot;hljs-string&quot;&gt;&quot;foo&quot;&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&quot;1&quot;&lt;/span&gt;: &lt;span class=&quot;hljs-string&quot;&gt;&quot;1&quot;&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&quot;bar&quot;&lt;/span&gt;: &lt;span class=&quot;hljs-string&quot;&gt;&quot;bar&quot;&lt;/span&gt; }\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;Using an array or a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map&quot; rel=&quot;noreferrer&quot;&gt;&lt;code&gt;Map&lt;/code&gt; object&lt;/a&gt; can be a better way to achieve this. &lt;code&gt;Map&lt;/code&gt; shares some similarities with &lt;code&gt;Object&lt;/code&gt; and &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map#Objects_and_maps_compared&quot; rel=&quot;noreferrer&quot;&gt;guarantees the keys to be iterated in order of insertion&lt;/a&gt;, without exception:&lt;/p&gt;\n&lt;blockquote&gt;\n&lt;p&gt;The keys in Map are ordered while keys added to object are not. Thus, when iterating over it, a Map object returns keys in order of insertion. (Note that in the ECMAScript 2015 spec objects do preserve creation order for string and Symbol keys, so traversal of an object with ie only string keys would yield keys in order of insertion)&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;p&gt;As a note, properties order in objects werent guaranteed at all before ES2015. Definition of an Object from &lt;a href=&quot;http://www.ecma-international.org/publications/files/ECMA-ST-ARCH/ECMA-262,%203rd%20edition,%20December%201999.pdf&quot; rel=&quot;noreferrer&quot;&gt;ECMAScript Third Edition (pdf)&lt;/a&gt;:&lt;/p&gt;\n&lt;blockquote&gt;\n&lt;h3&gt;4.3.3 Object&lt;/h3&gt;\n&lt;p&gt;An object is a member of the\ntype Object. &lt;strong&gt;It is an unordered collection of properties&lt;/strong&gt; each of which\ncontains a primitive value, object, or\nfunction. A function stored in a\nproperty of an object is called a\nmethod.&lt;/p&gt;\n&lt;/blockquote&gt;\n    ","\n&lt;p&gt;&lt;strong&gt;YES (but not always insertion order).&lt;/strong&gt;&lt;/p&gt;\n&lt;p&gt;Most Browsers iterate object properties as:&lt;/p&gt;\n&lt;ol&gt;\n&lt;li&gt;Integer keys in ascending order (and strings like &quot;1&quot; that parse as ints)&lt;/li&gt;\n&lt;li&gt;String keys, in insertion order (ES2015 guarantees this and all browsers comply)&lt;/li&gt;\n&lt;li&gt;Symbol names, in insertion order (ES2015 guarantees this and all browsers comply)&lt;/li&gt;\n&lt;/ol&gt;\n&lt;p&gt;Some older browsers combine categories #1 and #2, iterating all keys in insertion order. If your keys might parse as integers, it&apos;s best not to rely on any specific iteration order.&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;Current Language Spec (since ES2015)&lt;/strong&gt; insertion order is preserved, except in the case of keys that parse as integers (eg &quot;7&quot; or &quot;99&quot;), where behavior varies between browsers. For example, Chrome/V8 does not respect insertion order when the keys are parse as numeric.&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;Old Language Spec (before ES2015)&lt;/strong&gt;: Iteration order was technically undefined, but all major browsers complied with the ES2015 behavior.&lt;/p&gt;\n&lt;p&gt;Note that the ES2015 behavior was a good example of the language spec being driven by existing behavior, and not the other way round. To get a deeper sense of that backwards-compatibility mindset, see &lt;a href=&quot;http://code.google.com/p/v8/issues/detail?id=164&quot; rel=&quot;noreferrer&quot;&gt;http://code.google.com/p/v8/issues/detail?id=164&lt;/a&gt;, a Chrome bug that covers in detail the design decisions behind Chrome&apos;s iteration order behavior.\nPer one of the (rather opinionated) comments on that bug report:&lt;/p&gt;\n&lt;blockquote&gt;\n&lt;p&gt;Standards always follow implementations, that&apos;s where XHR came from, and Google does the same thing by implementing Gears and then embracing equivalent HTML5 functionality.  The right fix is to have ECMA formally incorporate the de-facto standard behavior into the next rev of the spec.&lt;/p&gt;\n&lt;/blockquote&gt;\n    ","\n&lt;p&gt;Property order in normal Objects is a complex subject in JavaScript.&lt;/p&gt;\n&lt;p&gt;While in ES5 explicitly no order has been specified, ES2015 defined an order in certain cases, and successive changes to the specification since have increasingly defined the order (even, as of ES2020, the &lt;code&gt;for-in&lt;/code&gt; loop&apos;s order). Given is the following object:&lt;/p&gt;\n&lt;pre class=&quot;lang-js s-code-block&quot;&gt;&lt;code class=&quot;hljs language-javascript&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;const&lt;/span&gt; o = &lt;span class=&quot;hljs-title class_&quot;&gt;Object&lt;/span&gt;.&lt;span class=&quot;hljs-title function_&quot;&gt;create&lt;/span&gt;(&lt;span class=&quot;hljs-literal&quot;&gt;null&lt;/span&gt;, {\n  &lt;span class=&quot;hljs-attr&quot;&gt;m&lt;/span&gt;: {&lt;span class=&quot;hljs-attr&quot;&gt;value&lt;/span&gt;: &lt;span class=&quot;hljs-keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;&lt;/span&gt;) {}, &lt;span class=&quot;hljs-attr&quot;&gt;enumerable&lt;/span&gt;: &lt;span class=&quot;hljs-literal&quot;&gt;true&lt;/span&gt;},\n  &lt;span class=&quot;hljs-string&quot;&gt;&quot;2&quot;&lt;/span&gt;: {&lt;span class=&quot;hljs-attr&quot;&gt;value&lt;/span&gt;: &lt;span class=&quot;hljs-string&quot;&gt;&quot;2&quot;&lt;/span&gt;, &lt;span class=&quot;hljs-attr&quot;&gt;enumerable&lt;/span&gt;: &lt;span class=&quot;hljs-literal&quot;&gt;true&lt;/span&gt;},\n  &lt;span class=&quot;hljs-string&quot;&gt;&quot;b&quot;&lt;/span&gt;: {&lt;span class=&quot;hljs-attr&quot;&gt;value&lt;/span&gt;: &lt;span class=&quot;hljs-string&quot;&gt;&quot;b&quot;&lt;/span&gt;, &lt;span class=&quot;hljs-attr&quot;&gt;enumerable&lt;/span&gt;: &lt;span class=&quot;hljs-literal&quot;&gt;true&lt;/span&gt;},\n  &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;: {&lt;span class=&quot;hljs-attr&quot;&gt;value&lt;/span&gt;: &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;hljs-attr&quot;&gt;enumerable&lt;/span&gt;: &lt;span class=&quot;hljs-literal&quot;&gt;true&lt;/span&gt;},\n  [&lt;span class=&quot;hljs-title class_&quot;&gt;Symbol&lt;/span&gt;()]: {&lt;span class=&quot;hljs-attr&quot;&gt;value&lt;/span&gt;: &lt;span class=&quot;hljs-string&quot;&gt;&quot;sym&quot;&lt;/span&gt;, &lt;span class=&quot;hljs-attr&quot;&gt;enumerable&lt;/span&gt;: &lt;span class=&quot;hljs-literal&quot;&gt;true&lt;/span&gt;},\n  &lt;span class=&quot;hljs-string&quot;&gt;&quot;1&quot;&lt;/span&gt;: {&lt;span class=&quot;hljs-attr&quot;&gt;value&lt;/span&gt;: &lt;span class=&quot;hljs-string&quot;&gt;&quot;1&quot;&lt;/span&gt;, &lt;span class=&quot;hljs-attr&quot;&gt;enumerable&lt;/span&gt;: &lt;span class=&quot;hljs-literal&quot;&gt;true&lt;/span&gt;},\n  &lt;span class=&quot;hljs-string&quot;&gt;&quot;a&quot;&lt;/span&gt;: {&lt;span class=&quot;hljs-attr&quot;&gt;value&lt;/span&gt;: &lt;span class=&quot;hljs-string&quot;&gt;&quot;a&quot;&lt;/span&gt;, &lt;span class=&quot;hljs-attr&quot;&gt;enumerable&lt;/span&gt;: &lt;span class=&quot;hljs-literal&quot;&gt;true&lt;/span&gt;},\n});\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;This results in the following order (in certain cases):&lt;/p&gt;\n&lt;pre class=&quot;lang-js s-code-block&quot;&gt;&lt;code class=&quot;hljs language-javascript&quot;&gt;&lt;span class=&quot;hljs-title class_&quot;&gt;Object&lt;/span&gt; {\n  &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;: &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;,\n  &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;: &lt;span class=&quot;hljs-string&quot;&gt;&quot;1&quot;&lt;/span&gt;,\n  &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;: &lt;span class=&quot;hljs-string&quot;&gt;&quot;2&quot;&lt;/span&gt;,\n  &lt;span class=&quot;hljs-attr&quot;&gt;b&lt;/span&gt;: &lt;span class=&quot;hljs-string&quot;&gt;&quot;b&quot;&lt;/span&gt;,\n  &lt;span class=&quot;hljs-attr&quot;&gt;a&lt;/span&gt;: &lt;span class=&quot;hljs-string&quot;&gt;&quot;a&quot;&lt;/span&gt;,\n  &lt;span class=&quot;hljs-attr&quot;&gt;m&lt;/span&gt;: &lt;span class=&quot;hljs-keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;&lt;/span&gt;) {},\n  &lt;span class=&quot;hljs-title class_&quot;&gt;Symbol&lt;/span&gt;(): &lt;span class=&quot;hljs-string&quot;&gt;&quot;sym&quot;&lt;/span&gt;\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;The order for &quot;own&quot; (non-inherited) properties is:&lt;/p&gt;\n&lt;ol&gt;\n&lt;li&gt;Integer-like keys in ascending order&lt;/li&gt;\n&lt;li&gt;String keys in insertion order&lt;/li&gt;\n&lt;li&gt;Symbols in insertion order&lt;/li&gt;\n&lt;/ol&gt;\n&lt;p&gt;Thus, there are three segments, which may alter the insertion order (as happened in the example). And integer-like keys don&apos;t stick to the insertion order at all.&lt;/p&gt;\n&lt;p&gt;In ES2015, only certain methods followed the order:&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;Object.assign&lt;/li&gt;\n&lt;li&gt;Object.defineProperties&lt;/li&gt;\n&lt;li&gt;Object.getOwnPropertyNames&lt;/li&gt;\n&lt;li&gt;Object.getOwnPropertySymbols&lt;/li&gt;\n&lt;li&gt;Reflect.ownKeys&lt;/li&gt;\n&lt;li&gt;JSON.parse&lt;/li&gt;\n&lt;li&gt;JSON.stringify&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;As of ES2020, all others do (some in specs between ES2015 and ES2020, others in ES2020), which includes:&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;Object.keys, Object.entries, Object.values, ...&lt;/li&gt;\n&lt;li&gt;for..in&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;The most difficult to nail down was &lt;code&gt;for-in&lt;/code&gt; because, uniquely, it includes inherited properties. That &lt;a href=&quot;https://github.com/tc39/proposal-for-in-order&quot; rel=&quot;noreferrer&quot;&gt;was done&lt;/a&gt; (in all but edge cases) in ES2020. The following list from the linked (now completed) proposal provides the edge cases where the order is not specified:&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;Neither the object being iterated nor anything in its prototype chain is a proxy, typed array, module namespace object, or host exotic object.&lt;/li&gt;\n&lt;li&gt;Neither the object nor anything in its prototype chain has its prototype change during iteration.&lt;/li&gt;\n&lt;li&gt;Neither the object nor anything in its prototype chain has a property deleted during iteration.&lt;/li&gt;\n&lt;li&gt;Nothing in the object&apos;s prototype chain has a property added during iteration.&lt;/li&gt;\n&lt;li&gt;No property of the object or anything in its prototype chain has its enumerability change during iteration.&lt;/li&gt;\n&lt;li&gt;No non-enumerable property shadows an enumerable one.&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;Conclusion: Even in ES2015 you shouldn&apos;t rely on the property order of normal objects in JavaScript. It is prone to errors. If you need ordered named pairs, use &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map&quot; rel=&quot;noreferrer&quot;&gt;&lt;code&gt;Map&lt;/code&gt;&lt;/a&gt; instead, which purely uses insertion order. If you just need order, use an array or &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set&quot; rel=&quot;noreferrer&quot;&gt;&lt;code&gt;Set&lt;/code&gt;&lt;/a&gt; (which also uses purely insertion order).&lt;/p&gt;\n    ","\n&lt;p&gt;At the time of writing, most browsers did return properties in the same order as they were inserted, but it was explicitly not guaranteed behaviour so shouldn&apos;t have been relied upon.&lt;/p&gt;\n\n&lt;p&gt;The &lt;a href=&quot;http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-262.pdf&quot; rel=&quot;noreferrer&quot;&gt;ECMAScript specification&lt;/a&gt; used to say:&lt;/p&gt;\n\n&lt;blockquote&gt;\n  &lt;p&gt;The mechanics and order of enumerating the properties ... is not specified.&lt;/p&gt;\n&lt;/blockquote&gt;\n\n&lt;p&gt;However in ES2015 and later non-integer keys will be returned in insertion order.&lt;/p&gt;\n    ","\n&lt;p&gt;This whole answer is in the context of spec compliance, not what any engine does at a particular moment or historically.&lt;/p&gt;\n\n&lt;h1&gt;Generally, no&lt;/h1&gt;\n\n&lt;p&gt;The actual question is very vague.&lt;/p&gt;\n\n&lt;blockquote&gt;\n  &lt;p&gt;will the properties be in the same order that I added them&lt;/p&gt;\n&lt;/blockquote&gt;\n\n&lt;p&gt;&lt;em&gt;In what context?&lt;/em&gt;&lt;/p&gt;\n\n&lt;p&gt;The answer is: it depends on a number of factors. In general, &lt;em&gt;no&lt;/em&gt;.&lt;/p&gt;\n\n&lt;h1&gt;Sometimes, yes&lt;/h1&gt;\n\n&lt;p&gt;Here is where you can count on property key order for plain &lt;code&gt;Objects&lt;/code&gt;:&lt;/p&gt;\n\n&lt;ul&gt;\n&lt;li&gt;ES2015 compliant engine&lt;/li&gt;\n&lt;li&gt;Own properties&lt;/li&gt;\n&lt;li&gt;&lt;code&gt;Object.getOwnPropertyNames()&lt;/code&gt;, &lt;code&gt;Reflect.ownKeys()&lt;/code&gt;, &lt;code&gt;Object.getOwnPropertySymbols(O)&lt;/code&gt;&lt;/li&gt;\n&lt;/ul&gt;\n\n&lt;p&gt;In all cases these methods include non-enumerable property keys and order keys as specified by &lt;code&gt;[[OwnPropertyKeys]]&lt;/code&gt; (see below). They differ in the type of key values they include (&lt;code&gt;String&lt;/code&gt; and / or &lt;code&gt;Symbol&lt;/code&gt;). In this context &lt;code&gt;String&lt;/code&gt; includes integer values.&lt;/p&gt;\n\n&lt;h2&gt;&lt;a href=&quot;http://www.ecma-international.org/ecma-262/6.0/#sec-object.getownpropertynames&quot; rel=&quot;noreferrer&quot;&gt;&lt;code&gt;Object.getOwnPropertyNames(O)&lt;/code&gt;&lt;/a&gt;&lt;/h2&gt;\n\n&lt;p&gt;Returns &lt;code&gt;O&lt;/code&gt;&apos;s own &lt;code&gt;String&lt;/code&gt;-keyed properties (&lt;em&gt;property names&lt;/em&gt;).&lt;/p&gt;\n\n&lt;h2&gt;&lt;a href=&quot;http://www.ecma-international.org/ecma-262/6.0/#sec-reflect.ownkeys&quot; rel=&quot;noreferrer&quot;&gt;&lt;code&gt;Reflect.ownKeys(O)&lt;/code&gt;&lt;/a&gt;&lt;/h2&gt;\n\n&lt;p&gt;Returns &lt;code&gt;O&lt;/code&gt;&apos;s own &lt;code&gt;String&lt;/code&gt;- and &lt;code&gt;Symbol&lt;/code&gt;-keyed properties.&lt;/p&gt;\n\n&lt;h2&gt;&lt;a href=&quot;http://www.ecma-international.org/ecma-262/6.0/#sec-object.getownpropertysymbols&quot; rel=&quot;noreferrer&quot;&gt;&lt;code&gt;Object.getOwnPropertySymbols(O)&lt;/code&gt;&lt;/a&gt;&lt;/h2&gt;\n\n&lt;p&gt;Returns &lt;code&gt;O&lt;/code&gt;&apos;s own &lt;code&gt;Symbol&lt;/code&gt;-keyed properties.&lt;/p&gt;\n\n&lt;h2&gt;&lt;a href=&quot;http://www.ecma-international.org/ecma-262/6.0/#sec-ordinary-object-internal-methods-and-internal-slots-ownpropertykeys&quot; rel=&quot;noreferrer&quot;&gt;&lt;code&gt;[[OwnPropertyKeys]]&lt;/code&gt;&lt;/a&gt;&lt;/h2&gt;\n\n&lt;p&gt;The order is essentially: integer-like &lt;code&gt;Strings&lt;/code&gt; in ascending order, non-integer-like &lt;code&gt;Strings&lt;/code&gt; in creation order, Symbols in creation order. Depending which function invokes this, some of these types may not be included.&lt;/p&gt;\n\n&lt;p&gt;The specific language is that keys are returned in the following order:&lt;/p&gt;\n\n&lt;blockquote&gt;\n  &lt;ol start=&quot;2&quot;&gt;\n  &lt;li&gt;&lt;p&gt;... each own property key &lt;code&gt;P&lt;/code&gt; of &lt;code&gt;O&lt;/code&gt; [the object being iterated] that is an integer index, in ascending numeric index order&lt;/p&gt;&lt;/li&gt;\n  &lt;li&gt;&lt;p&gt;... each own property key &lt;code&gt;P&lt;/code&gt; of &lt;code&gt;O&lt;/code&gt; that is a String but is not an integer index, in property creation order&lt;/p&gt;&lt;/li&gt;\n  &lt;li&gt;&lt;p&gt;... each own property key &lt;code&gt;P&lt;/code&gt; of &lt;code&gt;O&lt;/code&gt; that is a Symbol, in property creation order&lt;/p&gt;&lt;/li&gt;\n  &lt;/ol&gt;\n&lt;/blockquote&gt;\n\n&lt;h1&gt;&lt;code&gt;Map&lt;/code&gt;&lt;/h1&gt;\n\n&lt;p&gt;If you&apos;re interested in ordered maps you should consider using the &lt;code&gt;Map&lt;/code&gt; type introduced in ES2015 instead of plain &lt;code&gt;Objects&lt;/code&gt;.&lt;/p&gt;\n    ","\n&lt;p&gt;As of ES2015, property order is guaranteed for certain methods that iterate over properties. &lt;a href=&quot;https://stackoverflow.com/a/30919039/&quot;&gt;but not others&lt;/a&gt;. Unfortunately, the methods which are not guaranteed to have an order are generally the most often used:&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;code&gt;Object.keys&lt;/code&gt;, &lt;code&gt;Object.values&lt;/code&gt;, &lt;code&gt;Object.entries&lt;/code&gt;&lt;/li&gt;\n&lt;li&gt;&lt;code&gt;for..in&lt;/code&gt; loops&lt;/li&gt;\n&lt;li&gt;&lt;code&gt;JSON.stringify&lt;/code&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;&lt;strong&gt;But, as of ES2020, property order for these previously untrustworthy methods &lt;em&gt;will&lt;/em&gt; be guaranteed by the specification&lt;/strong&gt; to be iterated over in the same deterministic manner as the others, due to to the &lt;a href=&quot;https://github.com/tc39/proposals/blob/master/finished-proposals.md&quot; rel=&quot;noreferrer&quot;&gt;finished&lt;/a&gt; proposal: &lt;a href=&quot;https://github.com/tc39/proposal-for-in-order&quot; rel=&quot;noreferrer&quot;&gt;for-in mechanics&lt;/a&gt;.&lt;/p&gt;\n&lt;p&gt;Just like with the methods which have a guaranteed iteration order (like &lt;code&gt;Reflect.ownKeys&lt;/code&gt; and &lt;code&gt;Object.getOwnPropertyNames&lt;/code&gt;), the previously-unspecified methods will also iterate in the following order:&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;Numeric array keys, in ascending numeric order&lt;/li&gt;\n&lt;li&gt;All other non-Symbol keys, in insertion order&lt;/li&gt;\n&lt;li&gt;Symbol keys, in insertion order&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;This is what pretty much every implementation does already (and has done for many years), but the new proposal has made it official.&lt;/p&gt;\n&lt;p&gt;Although the current specification leaves for..in iteration order &quot;&lt;a href=&quot;https://tc39.github.io/ecma262/#sec-enumerate-object-properties&quot; rel=&quot;noreferrer&quot;&gt;almost totally unspecified&lt;/a&gt;, real engines tend to be more consistent:&quot;&lt;/p&gt;\n&lt;blockquote&gt;\n&lt;p&gt;The lack of specificity in ECMA-262 does not reflect reality. In discussion going back years, implementors have observed that there are some constraints on the behavior of for-in which anyone who wants to run code on the web needs to follow.&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;p&gt;Because every implementation already iterates over properties predictably, it can be put into the specification without breaking backwards compatibility.&lt;/p&gt;\n&lt;hr&gt;\n&lt;p&gt;There are a few weird cases which implementations currently do &lt;em&gt;not&lt;/em&gt; agree on, and in such cases, the resulting order will continue be unspecified. For property order &lt;a href=&quot;https://github.com/tc39/proposal-for-in-order#a-conservative-underapproximation-of-interop-semantics&quot; rel=&quot;noreferrer&quot;&gt;to be guaranteed&lt;/a&gt;:&lt;/p&gt;\n&lt;blockquote&gt;\n&lt;p&gt;Neither the object being iterated nor anything in its prototype chain is a proxy, typed array, module namespace object, or host exotic object.&lt;/p&gt;\n&lt;p&gt;Neither the object nor anything in its prototype chain has its prototype change during iteration.&lt;/p&gt;\n&lt;p&gt;Neither the object nor anything in its prototype chain has a property deleted during iteration.&lt;/p&gt;\n&lt;p&gt;Nothing in the object&apos;s prototype chain has a property added during iteration.&lt;/p&gt;\n&lt;p&gt;No property of the object or anything in its prototype chain has its enumerability change during iteration.&lt;/p&gt;\n&lt;p&gt;No non-enumerable property shadows an enumerable one.&lt;/p&gt;\n&lt;/blockquote&gt;\n    ","\n&lt;p&gt;In modern browsers you can use the &lt;code&gt;Map&lt;/code&gt; data structure instead of a object. &lt;/p&gt;\n\n&lt;p&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map&quot; rel=&quot;noreferrer&quot;&gt;Developer mozilla &amp;gt; Map&lt;/a&gt; &lt;/p&gt;\n\n&lt;blockquote&gt;\n  &lt;p&gt;A Map object can iterate its elements in insertion order...&lt;/p&gt;\n&lt;/blockquote&gt;\n    ","\n&lt;h2&gt;In ES2015, it does, but not to what you might think&lt;/h2&gt;\n\n&lt;p&gt;The order of keys in an object wasn&apos;t guaranteed until ES2015. It was implementation-defined.&lt;/p&gt;\n\n&lt;p&gt;However, in ES2015 in &lt;em&gt;was&lt;/em&gt; specified. Like many things in JavaScript, this was done for compatibility purposes and generally reflected an existing unofficial standard among most JS engines (with you-know-who being an exception).&lt;/p&gt;\n\n&lt;p&gt;The order is defined in the spec, under the abstract operation &lt;a href=&quot;https://www.ecma-international.org/ecma-262/9.0/index.html#sec-ordinaryownpropertykeys&quot; rel=&quot;noreferrer&quot;&gt;OrdinaryOwnPropertyKeys&lt;/a&gt;, which underpins all methods of iterating over an object&apos;s own keys. Paraphrased, the order is as follows:&lt;/p&gt;\n\n&lt;ol&gt;\n&lt;li&gt;&lt;p&gt;All &lt;em&gt;integer index&lt;/em&gt; keys (stuff like &lt;code&gt;&quot;1123&quot;&lt;/code&gt;, &lt;code&gt;&quot;55&quot;&lt;/code&gt;, etc) in ascending numeric order.&lt;/p&gt;&lt;/li&gt;\n&lt;li&gt;&lt;p&gt;All string keys which are not integer indices, in order of creation (oldest-first).&lt;/p&gt;&lt;/li&gt;\n&lt;li&gt;&lt;p&gt;All symbol keys, in order of creation (oldest-first).&lt;/p&gt;&lt;/li&gt;\n&lt;/ol&gt;\n\n&lt;p&gt;It&apos;s silly to say that the order is unreliable - it is reliable, it&apos;s just probably not what you want, and modern browsers implement this order correctly.&lt;/p&gt;\n\n&lt;p&gt;Some exceptions include methods of enumerating inherited keys, such as the &lt;code&gt;for .. in&lt;/code&gt; loop. The &lt;code&gt;for .. in&lt;/code&gt; loop doesn&apos;t guarantee order according to the specification. &lt;/p&gt;\n    ","\n&lt;p&gt;As others have stated, you have no guarantee as to the order when you iterate over the properties of an object. If you need an ordered list of multiple fields I suggested creating an array of objects.&lt;/p&gt;\n\n&lt;pre class=&quot;lang-js s-code-block&quot;&gt;&lt;code class=&quot;hljs language-javascript&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; myarr = [{&lt;span class=&quot;hljs-attr&quot;&gt;somfield1&lt;/span&gt;: &lt;span class=&quot;hljs-string&quot;&gt;&apos;x&apos;&lt;/span&gt;, &lt;span class=&quot;hljs-attr&quot;&gt;somefield2&lt;/span&gt;: &lt;span class=&quot;hljs-string&quot;&gt;&apos;y&apos;&lt;/span&gt;},\n{&lt;span class=&quot;hljs-attr&quot;&gt;somfield1&lt;/span&gt;: &lt;span class=&quot;hljs-string&quot;&gt;&apos;a&apos;&lt;/span&gt;, &lt;span class=&quot;hljs-attr&quot;&gt;somefield2&lt;/span&gt;: &lt;span class=&quot;hljs-string&quot;&gt;&apos;b&apos;&lt;/span&gt;},\n{&lt;span class=&quot;hljs-attr&quot;&gt;somfield1&lt;/span&gt;: &lt;span class=&quot;hljs-string&quot;&gt;&apos;i&apos;&lt;/span&gt;, &lt;span class=&quot;hljs-attr&quot;&gt;somefield2&lt;/span&gt;: &lt;span class=&quot;hljs-string&quot;&gt;&apos;j&apos;&lt;/span&gt;}];\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;This way you can use a regular for loop and have the insert order. You could then use the Array sort method to sort this into a new array if needed.&lt;/p&gt;\n    ","\n&lt;p&gt;Just found this out the hard way.&lt;/p&gt;\n\n&lt;p&gt;Using React with Redux, the state container of which&apos;s keys I want to traverse in order to generate children is refreshed everytime the store is changed (as per Redux&apos;s immutability concepts).&lt;/p&gt;\n\n&lt;p&gt;Thus, in order to take &lt;code&gt;Object.keys(valueFromStore)&lt;/code&gt; I used &lt;code&gt;Object.keys(valueFromStore).sort()&lt;/code&gt;, so that I at least now have an alphabetical order for the keys.&lt;/p&gt;\n    ","\n&lt;p&gt;Major Difference between Object and MAP with Example :&lt;/p&gt;\n&lt;p&gt;it&apos;s Order of iteration in loop, In Map it follows the order as it was set while creation whereas in OBJECT does not.&lt;/p&gt;\n&lt;p&gt;SEE:\n&lt;strong&gt;OBJECT&lt;/strong&gt;&lt;/p&gt;\n&lt;pre class=&quot;lang-js s-code-block&quot;&gt;&lt;code class=&quot;hljs language-javascript&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;const&lt;/span&gt; obj = {};\nobj.&lt;span class=&quot;hljs-property&quot;&gt;prop1&lt;/span&gt; = &lt;span class=&quot;hljs-string&quot;&gt;&quot;Foo&quot;&lt;/span&gt;;\nobj.&lt;span class=&quot;hljs-property&quot;&gt;prop2&lt;/span&gt; = &lt;span class=&quot;hljs-string&quot;&gt;&quot;Bar&quot;&lt;/span&gt;;\nobj[&lt;span class=&quot;hljs-string&quot;&gt;&apos;1&apos;&lt;/span&gt;] = &lt;span class=&quot;hljs-string&quot;&gt;&quot;day&quot;&lt;/span&gt;;\n&lt;span class=&quot;hljs-variable language_&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;hljs-title function_&quot;&gt;log&lt;/span&gt;(obj)\n\n**&lt;span class=&quot;hljs-attr&quot;&gt;OUTPUT&lt;/span&gt;: {&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;: &lt;span class=&quot;hljs-string&quot;&gt;&quot;day&quot;&lt;/span&gt;, &lt;span class=&quot;hljs-attr&quot;&gt;prop1&lt;/span&gt;: &lt;span class=&quot;hljs-string&quot;&gt;&quot;Foo&quot;&lt;/span&gt;, &lt;span class=&quot;hljs-attr&quot;&gt;prop2&lt;/span&gt;: &lt;span class=&quot;hljs-string&quot;&gt;&quot;Bar&quot;&lt;/span&gt;}**\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;&lt;strong&gt;MAP&lt;/strong&gt;&lt;/p&gt;\n&lt;pre class=&quot;lang-js s-code-block&quot;&gt;&lt;code class=&quot;hljs language-javascript&quot;&gt;    &lt;span class=&quot;hljs-keyword&quot;&gt;const&lt;/span&gt; myMap = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;hljs-title class_&quot;&gt;Map&lt;/span&gt;()\n    &lt;span class=&quot;hljs-comment&quot;&gt;// setting the values&lt;/span&gt;\n    myMap.&lt;span class=&quot;hljs-title function_&quot;&gt;set&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;foo&quot;&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&quot;value associated with &apos;a string&apos;&quot;&lt;/span&gt;)\n    myMap.&lt;span class=&quot;hljs-title function_&quot;&gt;set&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;Bar&quot;&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&apos;value associated with keyObj&apos;&lt;/span&gt;)\n    myMap.&lt;span class=&quot;hljs-title function_&quot;&gt;set&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;1&quot;&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&apos;value associated with keyFunc&apos;&lt;/span&gt;)\n\n&lt;span class=&quot;hljs-attr&quot;&gt;OUTPUT&lt;/span&gt;:\n**&lt;span class=&quot;hljs-number&quot;&gt;1.&lt;/span&gt;    &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;: &lt;span class=&quot;hljs-title class_&quot;&gt;Array&lt;/span&gt;[&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;]\n&lt;span class=&quot;hljs-number&quot;&gt;1.&lt;/span&gt;   &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;: &lt;span class=&quot;hljs-string&quot;&gt;&quot;foo&quot;&lt;/span&gt;\n&lt;span class=&quot;hljs-number&quot;&gt;2.&lt;/span&gt;   &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;: &lt;span class=&quot;hljs-string&quot;&gt;&quot;value associated with &apos;a string&apos;&quot;&lt;/span&gt;\n&lt;span class=&quot;hljs-number&quot;&gt;2.&lt;/span&gt;  &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;: &lt;span class=&quot;hljs-title class_&quot;&gt;Array&lt;/span&gt;[&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;]\n&lt;span class=&quot;hljs-number&quot;&gt;1.&lt;/span&gt;   &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;: &lt;span class=&quot;hljs-string&quot;&gt;&quot;Bar&quot;&lt;/span&gt;\n&lt;span class=&quot;hljs-number&quot;&gt;2.&lt;/span&gt;   &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;: &lt;span class=&quot;hljs-string&quot;&gt;&quot;value associated with keyObj&quot;&lt;/span&gt;\n&lt;span class=&quot;hljs-number&quot;&gt;3.&lt;/span&gt;  &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;: &lt;span class=&quot;hljs-title class_&quot;&gt;Array&lt;/span&gt;[&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;]\n&lt;span class=&quot;hljs-number&quot;&gt;1.&lt;/span&gt;   &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;: &lt;span class=&quot;hljs-string&quot;&gt;&quot;1&quot;&lt;/span&gt;\n&lt;span class=&quot;hljs-number&quot;&gt;2.&lt;/span&gt;   &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;: &lt;span class=&quot;hljs-string&quot;&gt;&quot;value associated with keyFunc&quot;&lt;/span&gt;**\n&lt;/code&gt;&lt;/pre&gt;\n    ","\n&lt;p&gt;For a 100% fail-safe solution you could use nested objects and do something like this:&lt;/p&gt;\n&lt;pre class=&quot;lang-js s-code-block&quot;&gt;&lt;code class=&quot;hljs language-javascript&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;const&lt;/span&gt; obj = {};\nobj.&lt;span class=&quot;hljs-property&quot;&gt;prop1&lt;/span&gt; = {&lt;span class=&quot;hljs-attr&quot;&gt;content&lt;/span&gt;: &lt;span class=&quot;hljs-string&quot;&gt;&quot;Foo&quot;&lt;/span&gt;, &lt;span class=&quot;hljs-attr&quot;&gt;index&lt;/span&gt;: &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;};\nobj.&lt;span class=&quot;hljs-property&quot;&gt;prop2&lt;/span&gt; = {&lt;span class=&quot;hljs-attr&quot;&gt;content&lt;/span&gt;: &lt;span class=&quot;hljs-string&quot;&gt;&quot;Bar&quot;&lt;/span&gt;, &lt;span class=&quot;hljs-attr&quot;&gt;index&lt;/span&gt;: &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;};\n\n&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;hljs-keyword&quot;&gt;let&lt;/span&gt; i = &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;; i &amp;lt; &lt;span class=&quot;hljs-title class_&quot;&gt;Object&lt;/span&gt;.&lt;span class=&quot;hljs-title function_&quot;&gt;keys&lt;/span&gt;(obj).&lt;span class=&quot;hljs-property&quot;&gt;length&lt;/span&gt;; i++)\n&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;hljs-keyword&quot;&gt;const&lt;/span&gt; prop &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; obj) {\n    &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (obj[prop].&lt;span class=&quot;hljs-property&quot;&gt;index&lt;/span&gt; == i) {\n        &lt;span class=&quot;hljs-variable language_&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;hljs-title function_&quot;&gt;log&lt;/span&gt;(obj[prop].&lt;span class=&quot;hljs-property&quot;&gt;content&lt;/span&gt;);\n        &lt;span class=&quot;hljs-keyword&quot;&gt;break&lt;/span&gt;;\n    }\n}\n&lt;/code&gt;&lt;/pre&gt;\n    ","\n&lt;p&gt;From the &lt;a href=&quot;http://www.ietf.org/rfc/rfc4627.txt&quot; rel=&quot;nofollow&quot;&gt;JSON standard&lt;/a&gt;:&lt;/p&gt;\n\n&lt;blockquote&gt;\n  &lt;p&gt;An object is an &lt;strong&gt;unordered&lt;/strong&gt; collection of zero or more name/value pairs, where a name is a string and a value is a string, number, boolean, null, object, or array.&lt;/p&gt;\n&lt;/blockquote&gt;\n\n&lt;p&gt;(emphasis mine).&lt;/p&gt;\n\n&lt;p&gt;So, no you can&apos;t guarantee the order.&lt;/p&gt;\n    "],"id":161,"title":"Does JavaScript guarantee object property order?","content":"\n                \n&lt;p&gt;If I create an object like this:&lt;/p&gt;\n\n&lt;pre class=&quot;lang-js s-code-block&quot;&gt;&lt;code class=&quot;hljs language-javascript&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; obj = {};\nobj.&lt;span class=&quot;hljs-property&quot;&gt;prop1&lt;/span&gt; = &lt;span class=&quot;hljs-string&quot;&gt;&quot;Foo&quot;&lt;/span&gt;;\nobj.&lt;span class=&quot;hljs-property&quot;&gt;prop2&lt;/span&gt; = &lt;span class=&quot;hljs-string&quot;&gt;&quot;Bar&quot;&lt;/span&gt;;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Will the resulting object &lt;em&gt;always&lt;/em&gt; look like this?&lt;/p&gt;\n\n&lt;pre class=&quot;lang-js s-code-block&quot;&gt;&lt;code class=&quot;hljs language-javascript&quot;&gt;{ prop1 : &lt;span class=&quot;hljs-string&quot;&gt;&quot;Foo&quot;&lt;/span&gt;, prop2 : &lt;span class=&quot;hljs-string&quot;&gt;&quot;Bar&quot;&lt;/span&gt; }\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;That is, will the properties be in the same order that I added them?&lt;/p&gt;\n    ","slug":"does-javascript-guarantee-object-property-order-1657384822587","postType":"QUESTION","createdAt":"2022-07-09T16:40:22.000Z","updatedAt":"2022-07-09T16:40:22.000Z","tags":[],"relatedQuestions":[]},"randomQuestions":[{"title":"How to center an element horizontally and vertically","slug":"how-to-center-an-element-horizontally-and-vertically-1657388132330"},{"title":"Understanding slicing","slug":"understanding-slicing-1657384397680"},{"title":"Importing installed package from script raises \"AttributeError: module has no attribute\" or \"ImportError: cannot import name\"","slug":"importing-installed-package-from-script-raises-\"attributeerror:-module-has-no-attribute\"-or-\"importerror:-cannot-import-name\"-1657387790607"},{"title":"How to filter object array based on attributes?","slug":"how-to-filter-object-array-based-on-attributes-1657388211247"},{"title":"What should main() return in C and C++?","slug":"what-should-main()-return-in-c-and-c++-1657384745630"},{"title":"How to deal with floating point number precision in JavaScript?","slug":"how-to-deal-with-floating-point-number-precision-in-javascript-1657387293762"},{"title":"Should I avoid the use of set(Preferred|Maximum|Minimum)Size methods in Java Swing?","slug":"should-i-avoid-the-use-of-set(preferredormaximumorminimum)size-methods-in-java-swing-1657384628399"},{"title":"Numbering rows within groups in a data frame","slug":"numbering-rows-within-groups-in-a-data-frame-1657388556436"},{"title":"How do I give text or an image a transparent background using CSS?","slug":"how-do-i-give-text-or-an-image-a-transparent-background-using-css-1657388188508"},{"title":"Make container shrink-to-fit child elements as they wrap","slug":"make-container-shrink-to-fit-child-elements-as-they-wrap-1657388134549"},{"title":"How to use ThreeTenABP in Android Project","slug":"how-to-use-threetenabp-in-android-project-1657384345704"},{"title":"What does a \"Cannot find symbol\" or \"Cannot resolve symbol\" error mean?","slug":"what-does-a-\"cannot-find-symbol\"-or-\"cannot-resolve-symbol\"-error-mean-1657384492160"},{"title":"When does SQLiteOpenHelper onCreate() / onUpgrade() run?","slug":"when-does-sqliteopenhelper-oncreate()-onupgrade()-run-1657384883864"},{"title":"How to manage startActivityForResult on Android","slug":"how-to-manage-startactivityforresult-on-android-1657387967393"},{"title":"Why is \"using namespace std;\" considered bad practice?","slug":"why-is-\"using-namespace-std\"-considered-bad-practice-1657384296377"},{"title":"What is move semantics?","slug":"what-is-move-semantics-1657387702625"},{"title":"When to use virtual destructors?","slug":"when-to-use-virtual-destructors-1657388152135"},{"title":"What is ViewModel in MVC?","slug":"what-is-viewmodel-in-mvc-1657387451244"},{"title":"How can I get useful error messages in PHP?","slug":"how-can-i-get-useful-error-messages-in-php-1657384609065"},{"title":"Dynamically select data frame columns using $ and a character value","slug":"dynamically-select-data-frame-columns-using-dollar-and-a-character-value-1657387836662"}]},"__N_SSG":true}