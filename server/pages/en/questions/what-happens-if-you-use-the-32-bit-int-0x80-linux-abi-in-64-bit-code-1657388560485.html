<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><meta name="twitter:card" content="summary_large_image"/><meta name="twitter:site" content="@solutionschecker.com"/><meta name="twitter:creator" content="@solutionschecker.com"/><meta property="og:url" content="https://solutionschecker.com"/><meta property="og:type" content="website"/><meta property="og:image" content="https://solutionschecker.com/solutions-checker-banner.png"/><meta property="og:image:alt" content="Find solution for coding, HTML, CSS, JAVASCRIPT, MYSQL, PHP, PYTHON,... quickly. - solutionschecker.com"/><script type="application/ld+json">{"@context":"https://schema.org","@type":"Organization","logo":"/logo.svg","url":"https://solutionschecker.com"}</script><title>What happens if you use the 32-bit int 0x80 Linux ABI in 64-bit code? | Solutions Checker</title><meta name="robots" content="index,follow"/><meta name="description" content="int 0x80 on Linux always invokes the 32-bit ABI, regardless of what mode it&#x27;s called from:  args in ebx, ecx, ... and syscall numbers from /usr/include/asm/unistd_32.h.   (Or crashes on 64-bit kernels compiled without CONFIG_IA32_EMULATION).

64-bit code should use syscall, with call numbers from /usr/include/asm/unistd_64.h, and args in rdi, rsi, etc.  See What are the calling conventions for UNIX &amp; Linux system calls on i386 and x86-64.  If your question was marked a duplicate of this, see that link for details on how you should make system calls in 32 or 64-bit code.  If you want to understand what exactly happened, keep reading.

(For an example of 32-bit vs. 64-bit sys_write, see Using interrupt 0x80 on 64-bit Linux)



syscall system calls are faster than int 0x80 system calls, so use native 64-bit syscall unless you&#x27;re writing polyglot machine code that runs the same when executed as 32 or 64 bit.  (sysenter always returns in 32-bit mode, so it&#x27;s not useful from 64-bit userspace, although it is a valid x86-64 instruction.)

Related: The Definitive Guide to Linux System Calls (on x86) for how to make int 0x80 or sysenter 32-bit system calls, or syscall 64-bit system calls, or calling the vDSO for &quot;virtual&quot; system calls like gettimeofday.  Plus background on what system calls are all about.



Using int 0x80 makes it possible to write something that will assemble in 32 or 64-bit mode, so it&#x27;s handy for an exit_group() at the end of a microbenchmark or something.

Current PDFs of the official i386 and x86-64 System V psABI documents that standardize function and syscall calling conventions are linked from https://github.com/hjl-tools/x86-psABI/wiki/X86-psABI.

See the x86 tag wiki for beginner guides, x86 manuals, official documentation, and performance optimization guides / resources.



But since people keep posting questions with code that uses int 0x80 in 64-bit code, or accidentally building 64-bit binaries from source written for 32-bit, I wonder what exactly does happen on current Linux?

Does int 0x80 save/restore all the 64-bit registers?  Does it truncate any registers to 32-bit?  What happens if you pass pointer args that have non-zero upper halves?

Does it work if you pass it 32-bit pointers?
    "/><meta property="og:title" content="What happens if you use the 32-bit int 0x80 Linux ABI in 64-bit code? | Solutions Checker"/><meta property="og:description" content="int 0x80 on Linux always invokes the 32-bit ABI, regardless of what mode it&#x27;s called from:  args in ebx, ecx, ... and syscall numbers from /usr/include/asm/unistd_32.h.   (Or crashes on 64-bit kernels compiled without CONFIG_IA32_EMULATION).

64-bit code should use syscall, with call numbers from /usr/include/asm/unistd_64.h, and args in rdi, rsi, etc.  See What are the calling conventions for UNIX &amp; Linux system calls on i386 and x86-64.  If your question was marked a duplicate of this, see that link for details on how you should make system calls in 32 or 64-bit code.  If you want to understand what exactly happened, keep reading.

(For an example of 32-bit vs. 64-bit sys_write, see Using interrupt 0x80 on 64-bit Linux)



syscall system calls are faster than int 0x80 system calls, so use native 64-bit syscall unless you&#x27;re writing polyglot machine code that runs the same when executed as 32 or 64 bit.  (sysenter always returns in 32-bit mode, so it&#x27;s not useful from 64-bit userspace, although it is a valid x86-64 instruction.)

Related: The Definitive Guide to Linux System Calls (on x86) for how to make int 0x80 or sysenter 32-bit system calls, or syscall 64-bit system calls, or calling the vDSO for &quot;virtual&quot; system calls like gettimeofday.  Plus background on what system calls are all about.



Using int 0x80 makes it possible to write something that will assemble in 32 or 64-bit mode, so it&#x27;s handy for an exit_group() at the end of a microbenchmark or something.

Current PDFs of the official i386 and x86-64 System V psABI documents that standardize function and syscall calling conventions are linked from https://github.com/hjl-tools/x86-psABI/wiki/X86-psABI.

See the x86 tag wiki for beginner guides, x86 manuals, official documentation, and performance optimization guides / resources.



But since people keep posting questions with code that uses int 0x80 in 64-bit code, or accidentally building 64-bit binaries from source written for 32-bit, I wonder what exactly does happen on current Linux?

Does int 0x80 save/restore all the 64-bit registers?  Does it truncate any registers to 32-bit?  What happens if you pass pointer args that have non-zero upper halves?

Does it work if you pass it 32-bit pointers?
    "/><script type="application/ld+json">{"@context":"https://schema.org","@type":"QAPage","mainEntity":{"name":"What happens if you use the 32-bit int 0x80 Linux ABI in 64-bit code?","text":"int 0x80 on Linux always invokes the 32-bit ABI, regardless of what mode it&apos;s called from:  args in ebx, ecx, ... and syscall numbers from /usr/include/asm/unistd_32.h.   (Or crashes on 64-bit kernels compiled without CONFIG_IA32_EMULATION).\n\n64-bit code should use syscall, with call numbers from /usr/include/asm/unistd_64.h, and args in rdi, rsi, etc.  See What are the calling conventions for UNIX &amp; Linux system calls on i386 and x86-64.  If your question was marked a duplicate of this, see that link for details on how you should make system calls in 32 or 64-bit code.  If you want to understand what exactly happened, keep reading.\n\n(For an example of 32-bit vs. 64-bit sys_write, see Using interrupt 0x80 on 64-bit Linux)\n\n\n\nsyscall system calls are faster than int 0x80 system calls, so use native 64-bit syscall unless you&apos;re writing polyglot machine code that runs the same when executed as 32 or 64 bit.  (sysenter always returns in 32-bit mode, so it&apos;s not useful from 64-bit userspace, although it is a valid x86-64 instruction.)\n\nRelated: The Definitive Guide to Linux System Calls (on x86) for how to make int 0x80 or sysenter 32-bit system calls, or syscall 64-bit system calls, or calling the vDSO for &quot;virtual&quot; system calls like gettimeofday.  Plus background on what system calls are all about.\n\n\n\nUsing int 0x80 makes it possible to write something that will assemble in 32 or 64-bit mode, so it&apos;s handy for an exit_group() at the end of a microbenchmark or something.\n\nCurrent PDFs of the official i386 and x86-64 System V psABI documents that standardize function and syscall calling conventions are linked from https://github.com/hjl-tools/x86-psABI/wiki/X86-psABI.\n\nSee the x86 tag wiki for beginner guides, x86 manuals, official documentation, and performance optimization guides / resources.\n\n\n\nBut since people keep posting questions with code that uses int 0x80 in 64-bit code, or accidentally building 64-bit binaries from source written for 32-bit, I wonder what exactly does happen on current Linux?\n\nDoes int 0x80 save/restore all the 64-bit registers?  Does it truncate any registers to 32-bit?  What happens if you pass pointer args that have non-zero upper halves?\n\nDoes it work if you pass it 32-bit pointers?\n    ","answerCount":1,"upVoteCount":500,"suggestedAnswer":[{"text":"TL:DR: int 0x80 works when used correctly, as long as any pointers fit in 32 bits (stack pointers don&apos;t fit).  But beware that strace decodes it wrong unless you have a very recent strace + kernel.\nint 0x80 zeros r8-r11 for reasons, and preserves everything else.  Use it exactly like you would in 32-bit code, with the 32-bit call numbers.  (Or better, don&apos;t use it!)\nNot all systems even support int 0x80:  The Windows Subsystem for Linux version 1 (WSL1) is strictly 64-bit only: int 0x80 doesn&apos;t work at all.  It&apos;s also possible to build Linux kernels without IA-32 emulation either.  (No support for 32-bit executables, no support for 32-bit system calls).  See this re: making sure your WSL is actually WSL2 (which uses an actual Linux kernel in a VM.)\n\nThe details: what&apos;s saved/restored, which parts of which regs the kernel uses\nint 0x80 uses eax (not the full rax) as the system-call number, dispatching to the same table of function-pointers that 32-bit user-space int 0x80 uses.  (These pointers are to sys_whatever implementations or wrappers for the native 64-bit implementation inside the kernel.  System calls are really function calls across the user/kernel boundary.)\nOnly the low 32 bits of arg registers are passed.  The upper halves of rbx-rbp are preserved, but ignored by int 0x80 system calls.  Note that passing a bad pointer to a system call doesn&apos;t result in SIGSEGV; instead the system call returns -EFAULT.  If you don&apos;t check error return values (with a debugger or tracing tool), it will appear to silently fail.\nAll registers (except eax of course) are saved/restored (including RFLAGS, and the upper 32 of integer regs), except that r8-r11 are zeroed.  r12-r15 are call-preserved in the x86-64 SysV ABI&apos;s function calling convention, so the registers that get zeroed by int 0x80 in 64-bit are the call-clobbered subset of the &quot;new&quot; registers that AMD64 added.\nThis behaviour has been preserved over some internal changes to how register-saving was implemented inside the kernel, and comments in the kernel mention that it&apos;s usable from 64-bit, so this ABI is probably stable.  (I.e. you can count on r8-r11 being zeroed, and everything else being preserved.)\nThe return value is sign-extended to fill 64-bit rax.  (Linux declares 32-bit sys_ functions as returning signed long.)  This means that pointer return values (like from void *mmap()) need to be zero-extended before use in 64-bit addressing modes\nUnlike sysenter, it preserves the original value of cs, so it returns to user-space in the same mode that it was called in.  (Using sysenter results in the kernel setting cs to $__USER32_CS, which selects a descriptor for a 32-bit code segment.)\n\nOlder strace decodes int 0x80 incorrectly for 64-bit processes.  It decodes as if the process had used syscall instead of int 0x80.  This can be very confusing.  e.g. strace prints write(0, NULL, 12 &lt;unfinished ... exit status 1&gt; for eax=1 / int $0x80, which is actually _exit(ebx), not write(rdi, rsi, rdx).\nI don&apos;t know the exact version where the PTRACE_GET_SYSCALL_INFO feature was added, but Linux kernel 5.5 / strace 5.5 handle it.  It misleadingly says the process &quot;runs in 32-bit mode&quot; but does decode correctly.  (Example).\n\nint 0x80 works as long as all arguments (including pointers) fit in the low 32 of a register.  This is the case for static code and data in the default code model (&quot;small&quot;) in the x86-64 SysV ABI.  (Section 3.5.1\n: all symbols are known to be located in the virtual addresses in the range 0x00000000 to 0x7effffff, so you can do stuff like mov edi, hello (AT&amp;T mov $hello, %edi) to get a pointer into a register with a 5 byte instruction).\nBut this is not the case for position-independent executables, which many Linux distros now configure gcc to make by default (and they enable ASLR for executables).  For example, I compiled a hello.c on Arch Linux, and set a breakpoint at the start of main.  The string constant passed to puts was at 0x555555554724, so a 32-bit ABI write system call would not work.  (GDB disables ASLR by default, so you always see the same address from run to run, if you run from within GDB.)\nLinux puts the stack near the &quot;gap&quot; between the upper and lower ranges of canonical addresses, i.e. with the top of the stack at 2^48-1.  (Or somewhere random, with ASLR enabled).  So rsp on entry to _start in a typical statically-linked executable is something like 0x7fffffffe550, depending on size of env vars and args.  Truncating this pointer to esp does not point to any valid memory, so system calls with pointer inputs will typically return -EFAULT if you try to pass a truncated stack pointer.  (And your program will crash if you truncate rsp to esp and then do anything with the stack, e.g. if you built 32-bit asm source as a 64-bit executable.)\n\nHow it works in the kernel:\nIn the Linux source code, arch/x86/entry/entry_64_compat.S defines\nENTRY(entry_INT80_compat).  Both 32 and 64-bit processes use the same entry point when they execute int 0x80.\nentry_64.S is defines native entry points for a 64-bit kernel, which includes interrupt / fault handlers and syscall native system calls from long mode (aka 64-bit mode) processes.\nentry_64_compat.S defines system-call entry-points from compat mode into a 64-bit kernel, plus the special case of int 0x80 in a 64-bit process.   (sysenter in a 64-bit process may go to that entry point as well, but it pushes $__USER32_CS, so it will always return in 32-bit mode.)  There&apos;s a 32-bit version of the syscall instruction, supported on AMD CPUs, and Linux supports it too for fast 32-bit system calls from 32-bit processes.\nI guess a possible use-case for int 0x80 in 64-bit mode is if you wanted to use a custom code-segment descriptor that you installed with modify_ldt.  int 0x80 pushes segment registers itself for use with iret, and Linux always returns from int 0x80 system calls via iret.  The 64-bit syscall entry point sets pt_regs-&gt;cs and -&gt;ss to constants, __USER_CS and __USER_DS.  (It&apos;s normal that SS and DS use the same segment descriptors.  Permission differences are done with paging, not segmentation.)\nentry_32.S defines entry points into a 32-bit kernel, and is not involved at all.\n\nThe int 0x80 entry point in Linux 4.12&apos;s entry_64_compat.S:\n/*\n * 32-bit legacy system call entry.\n *\n * 32-bit x86 Linux system calls traditionally used the INT $0x80\n * instruction.  INT $0x80 lands here.\n *\n * This entry point can be used by 32-bit and 64-bit programs to perform\n * 32-bit system calls.  Instances of INT $0x80 can be found inline in\n * various programs and libraries.  It is also used by the vDSO&apos;s\n * __kernel_vsyscall fallback for hardware that doesn&apos;t support a faster\n * entry method.  Restarted 32-bit system calls also fall back to INT\n * $0x80 regardless of what instruction was originally used to do the\n * system call.\n *\n * This is considered a slow path.  It is not used by most libc\n * implementations on modern hardware except during process startup.\n ...\n */\n ENTRY(entry_INT80_compat)\n ...  (see the github URL for the full source)\n\n\nThe code zero-extends eax into rax, then pushes all the registers onto the kernel stack to form a struct pt_regs.  This is where it will restore from when the system call returns.  It&apos;s in a standard layout for saved user-space registers (for any entry point), so ptrace from other process (like gdb or strace) will read and/or write that memory if they use ptrace while this process is inside a system call.  (ptrace modification of registers is one thing that makes return paths complicated for the other entry points.  See comments.)\nBut it pushes $0 instead of r8/r9/r10/r11.   (sysenter and AMD syscall32 entry points store zeros for r8-r15.)\nI think this zeroing of r8-r11 is to match historical behaviour.  Before the Set up full pt_regs for all compat syscalls commit, the entry point only saved the C call-clobbered registers.  It dispatched directly from asm with call  *ia32_sys_call_table(, %rax, 8), and those functions follow the calling convention, so they preserve rbx, rbp, rsp, and r12-r15.  Zeroing r8-r11 instead of leaving them undefined was to avoid info leaks from a 64-bit kernel to 32-bit user-space (which could far jmp to a 64-bit code segment to read anything the kernel left there).\nThe current implementation (Linux 4.12) dispatches 32-bit-ABI system calls from C, reloading the saved ebx, ecx, etc. from pt_regs.  (64-bit native system calls dispatch directly from asm, with only a mov %r10, %rcx needed to account for the small difference in calling convention between functions and syscall.  Unfortunately it can&apos;t always use sysret, because CPU bugs make it unsafe with non-canonical addresses.  It does try to, so the fast-path is pretty damn fast, although syscall itself still takes tens of cycles.)\nAnyway, in current Linux, 32-bit syscalls (including int 0x80 from 64-bit) eventually end up indo_syscall_32_irqs_on(struct pt_regs *regs).  It dispatches to a function pointer ia32_sys_call_table, with 6 zero-extended args.  This maybe avoids needing a wrapper around the 64-bit native syscall function in more cases to preserve that behaviour, so more of the ia32 table entries can be the native system call implementation directly.\n\nLinux 4.12 arch/x86/entry/common.c\nif (likely(nr &lt; IA32_NR_syscalls)) {\n  /*\n   * It&apos;s possible that a 32-bit syscall implementation\n   * takes a 64-bit parameter but nonetheless assumes that\n   * the high bits are zero.  Make sure we zero-extend all\n   * of the args.\n   */\n  regs-&gt;ax = ia32_sys_call_table[nr](\n      (unsigned int)regs-&gt;bx, (unsigned int)regs-&gt;cx,\n      (unsigned int)regs-&gt;dx, (unsigned int)regs-&gt;si,\n      (unsigned int)regs-&gt;di, (unsigned int)regs-&gt;bp);\n}\n\nsyscall_return_slowpath(regs);\n\n\nIn older versions of Linux that dispatch 32-bit system calls from asm (like 64-bit still did until 4.151), the int80 entry point itself puts args in the right registers with mov and xchg instructions, using 32-bit registers.  It even uses mov %edx,%edx to zero-extend EDX into RDX (because arg3 happen to use the same register in both conventions).  code here.  This code is duplicated in the sysenter and syscall32 entry points.\nFootnote 1: Linux 4.15 (I think) introduced Spectre / Meltdown mitigations, and a major revamp of the entry points that made them them a trampoline for the meltdown case.  It also sanitized the incoming registers to avoid user-space values other than actual args being in registers during the call (when some Spectre gadget might run), by storing them, zeroing everything, then calling to a C wrapper that reloads just the right widths of args from the struct saved on entry.\nI&apos;m planning to leave this answer describing the much simpler mechanism because the conceptually useful part here is that the kernel side of a syscall involves using EAX or RAX as an index into a table of function pointers, with other incoming register values copied going to the places where the calling convention wants args to go.  i.e. syscall is just a way to make a call into the kernel, to its dispatch code.\n\nSimple example / test program:\nI wrote a simple Hello World (in NASM syntax) which sets all registers to have non-zero upper halves, then makes two write() system calls with int 0x80, one with a pointer to a string in .rodata (succeeds), the second with a pointer to the stack (fails with -EFAULT).\nThen it uses the native 64-bit syscall ABI to write() the chars from the stack (64-bit pointer), and again to exit.\nSo all of these examples are using the ABIs correctly, except for the 2nd int 0x80 which tries to pass a 64-bit pointer and has it truncated.\nIf you built it as a position-independent executable, the first one would fail too.  (You&apos;d have to use a RIP-relative lea instead of mov to get the address of hello: into a register.)\nI used gdb, but use whatever debugger you prefer.  Use one that highlights changed registers since the last single-step.  gdbgui works well for debugging asm source, but is not great for disassembly.  Still, it does have a register pane that works well for integer regs at least, and it worked great on this example.\nSee the inline ;;; comments describing how register are changed by system calls\nglobal _start\n_start:\n    mov  rax, 0x123456789abcdef\n    mov  rbx, rax\n    mov  rcx, rax\n    mov  rdx, rax\n    mov  rsi, rax\n    mov  rdi, rax\n    mov  rbp, rax\n    mov  r8, rax\n    mov  r9, rax\n    mov  r10, rax\n    mov  r11, rax\n    mov  r12, rax\n    mov  r13, rax\n    mov  r14, rax\n    mov  r15, rax\n\n    ;; 32-bit ABI\n    mov  rax, 0xffffffff00000004          ; high garbage + __NR_write (unistd_32.h)\n    mov  rbx, 0xffffffff00000001          ; high garbage + fd=1\n    mov  rcx, 0xffffffff00000000 + .hello\n    mov  rdx, 0xffffffff00000000 + .hellolen\n    ;std\nafter_setup:       ; set a breakpoint here\n    int  0x80                   ; write(1, hello, hellolen);   32-bit ABI\n    ;; succeeds, writing to stdout\n;;; changes to registers:   r8-r11 = 0.  rax=14 = return value\n\n    ; ebx still = 1 = STDOUT_FILENO\n    push &apos;bye&apos; + (0xa&lt;&lt;(3*8))\n    mov  rcx, rsp               ; rcx = 64-bit pointer that won&apos;t work if truncated\n    mov  edx, 4\n    mov  eax, 4                 ; __NR_write (unistd_32.h)\n    int  0x80                   ; write(ebx=1, ecx=truncated pointer,  edx=4);  32-bit\n    ;; fails, nothing printed\n;;; changes to registers: rax=-14 = -EFAULT  (from /usr/include/asm-generic/errno-base.h)\n\n    mov  r10, rax               ; save return value as exit status\n    mov  r8, r15\n    mov  r9, r15\n    mov  r11, r15               ; make these regs non-zero again\n\n    ;; 64-bit ABI\n    mov  eax, 1                 ; __NR_write (unistd_64.h)\n    mov  edi, 1\n    mov  rsi, rsp\n    mov  edx, 4\n    syscall                     ; write(edi=1, rsi=&apos;bye\\n&apos; on the stack,  rdx=4);  64-bit\n    ;; succeeds: writes to stdout and returns 4 in rax\n;;; changes to registers: rax=4 = length return value\n;;; rcx = 0x400112 = RIP.   r11 = 0x302 = eflags with an extra bit set.\n;;; (This is not a coincidence, it&apos;s how sysret works.  But don&apos;t depend on it, since iret could leave something else)\n\n    mov  edi, r10d\n    ;xor  edi,edi\n    mov  eax, 60                ; __NR_exit (unistd_64.h)\n    syscall                     ; _exit(edi = first int 0x80 result);  64-bit\n    ;; succeeds, exit status = low byte of first int 0x80 result = 14\n\nsection .rodata\n_start.hello:    db &quot;Hello World!&quot;, 0xa, 0\n_start.hellolen  equ   $ - _start.hello\n\nBuild it into a 64-bit static binary with\nyasm -felf64 -Worphan-labels -gdwarf2 abi32-from-64.asm\nld -o abi32-from-64 abi32-from-64.o\n\nRun gdb ./abi32-from-64.  In gdb, run set disassembly-flavor intel and layout reg if you don&apos;t have that in your ~/.gdbinit already.  (GAS .intel_syntax is like MASM, not NASM, but they&apos;re close enough that it&apos;s easy to read if you like NASM syntax.)\n(gdb)  set disassembly-flavor intel\n(gdb)  layout reg\n(gdb)  b  after_setup\n(gdb)  r\n(gdb)  si                     # step instruction\n    press return to repeat the last command, keep stepping\n\nPress control-L when gdb&apos;s TUI mode gets messed up.  This happens easily, even when programs don&apos;t print to stdout themselves.\n    ","url":"/questions/[slug]#solution1","@type":"Answer","upvoteCount":0}],"@type":"Question"}}</script><meta name="next-head-count" content="16"/><link rel="preload" href="/_next/static/css/08bcc42a26fe5c92.css" as="style"/><link rel="stylesheet" href="/_next/static/css/08bcc42a26fe5c92.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-0d1b80a048d4787e.js"></script><script src="/_next/static/chunks/webpack-42cdea76c8170223.js" defer=""></script><script src="/_next/static/chunks/framework-4556c45dd113b893.js" defer=""></script><script src="/_next/static/chunks/main-ccfab947c79712f4.js" defer=""></script><script src="/_next/static/chunks/pages/_app-08d1a634dea6705e.js" defer=""></script><script src="/_next/static/chunks/29107295-fbcfe2172188e46f.js" defer=""></script><script src="/_next/static/chunks/150-b06815e21c943e0d.js" defer=""></script><script src="/_next/static/chunks/490-7f0418bb4354ac73.js" defer=""></script><script src="/_next/static/chunks/108-87de33c23337ff53.js" defer=""></script><script src="/_next/static/chunks/pages/questions/%5Bslug%5D-79a1437acf654019.js" defer=""></script><script src="/_next/static/6ctJfCympFH_chh5mjicD/_buildManifest.js" defer=""></script><script src="/_next/static/6ctJfCympFH_chh5mjicD/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="wrapper"><header><nav class="bg-white border-gray-200 px-4 lg:px-6 py-2.5 dark:bg-gray-800"><div class="flex flex-wrap justify-between items-center mx-auto max-w-screen-xl"><a class="flex items-center" href="/"><img src="/logo-second.png" class="mr-3 h-6 sm:h-9" alt="Solution Checker Logo"/><h4 class="self-center text-xl font-semibold whitespace-nowrap dark:text-white">Solution Checker</h4></a><div class="flex items-center lg:order-2"><button data-collapse-toggle="mobile-menu-2" type="button" class="inline-flex items-center p-2 ml-1 text-sm text-gray-500 rounded-lg lg:hidden hover:bg-gray-100 focus:outline-none focus:ring-2 focus:ring-gray-200 dark:text-gray-400 dark:hover:bg-gray-700 dark:focus:ring-gray-600" aria-controls="mobile-menu-2" aria-expanded="false"><span class="sr-only">Open main menu</span><svg class="w-6 h-6" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M3 5a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM3 10a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM3 15a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1z" clip-rule="evenodd"></path></svg><svg class="hidden w-6 h-6" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z" clip-rule="evenodd"></path></svg></button></div><div class="hidden justify-between items-center w-full lg:flex lg:w-auto lg:order-1" id="mobile-menu-2"><ul class="flex flex-col mt-4 font-medium lg:flex-row lg:space-x-8 lg:mt-0"><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" aria-current="page" href="/">Home</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/questions?tab=news">Questions</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/post?tab=news">Post</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/questions/what-happens-if-you-use-the-32-bit-int-0x80-linux-abi-in-64-bit-code-1657388560485#">Coding</a></li></ul></div></div></nav></header><div class="main-content"><div class="question my-5"><div class="flex question-header items-center m-auto justify-center"><div class="rounded-xl w-full border p-5 shadow-md bg-white"><div class="flex w-full items-center justify-between border-b pb-3"><div class="flex items-center space-x-3"><div class="text-lg font-bold text-slate-700"><a href="/questions/what-happens-if-you-use-the-32-bit-int-0x80-linux-abi-in-64-bit-code-1657388560485"><h1>What happens if you use the 32-bit int 0x80 Linux ABI in 64-bit code?</h1></a></div></div><div class="flex flex-wrap h-auto justify-end items-center space-x-8"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold" href="/questions/tag/x86-64">x86-64</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold" href="/questions/tag/system-calls">system-calls</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold" href="/questions/tag/abi">abi</a></div></div><div class="question-content mt-5">
                
<p><code>int 0x80</code> on Linux always invokes the 32-bit ABI, regardless of what mode it's called from:  args in <code>ebx</code>, <code>ecx</code>, ... and syscall numbers from <code>/usr/include/asm/unistd_32.h</code>.   (Or crashes on 64-bit kernels compiled without <code>CONFIG_IA32_EMULATION</code>).</p>

<p><strong>64-bit code should use <code>syscall</code></strong>, with call numbers from <code>/usr/include/asm/unistd_64.h</code>, and args in <code>rdi</code>, <code>rsi</code>, etc.  See <a href="https://stackoverflow.com/questions/2535989/what-are-the-calling-conventions-for-unix-linux-system-calls-on-x86-64">What are the calling conventions for UNIX &amp; Linux system calls on i386 and x86-64</a>.  If your question was marked a duplicate of this, <strong>see that link for details on how you <em>should</em> make system calls in 32 or 64-bit code.</strong>  If you want to understand what exactly happened, keep reading.</p>

<p>(For an example of 32-bit vs. 64-bit <code>sys_write</code>, see <a href="https://stackoverflow.com/questions/22503944/using-interrupt-0x80-on-64-bit-linux">Using interrupt 0x80 on 64-bit Linux</a>)</p>

<hr>

<p><code>syscall</code> system calls are faster than <code>int 0x80</code> system calls, so use native 64-bit <code>syscall</code> unless you're writing polyglot machine code that runs the same when executed as 32 or 64 bit.  (<code>sysenter</code> always returns in 32-bit mode, so it's not useful from 64-bit userspace, although it is a valid x86-64 instruction.)</p>

<p>Related: <a href="https://blog.packagecloud.io/eng/2016/04/05/the-definitive-guide-to-linux-system-calls/" rel="noreferrer"><strong>The Definitive Guide to Linux System Calls</strong> (on x86)</a> for how to make <code>int 0x80</code> or <code>sysenter</code> 32-bit system calls, or <code>syscall</code> 64-bit system calls, or calling the vDSO for "virtual" system calls like <code>gettimeofday</code>.  Plus background on what system calls are all about.</p>

<hr>

<p>Using <code>int 0x80</code> makes it possible to write something that will assemble in 32 or 64-bit mode, so it's handy for an <code>exit_group()</code> at the end of a microbenchmark or something.</p>

<p>Current PDFs of the official i386 and x86-64 System V psABI documents that standardize function and syscall calling conventions are linked from <a href="https://github.com/hjl-tools/x86-psABI/wiki/X86-psABI" rel="noreferrer">https://github.com/hjl-tools/x86-psABI/wiki/X86-psABI</a>.</p>

<p>See the <a href="/questions/tagged/x86" class="post-tag" title="show questions tagged 'x86'" rel="tag">x86</a> tag <a href="https://stackoverflow.com/tags/x86/info">wiki</a> for beginner guides, x86 manuals, official documentation, and performance optimization guides / resources.</p>

<hr>

<p>But since people keep posting questions with code that uses <a href="https://stackoverflow.com/questions/14033028/sys-read-syscall-vs-int-0x80-in-gnu-assembler"><code>int 0x80</code> in 64-bit code</a>, or accidentally <a href="https://stackoverflow.com/questions/36861903/assembling-32-bit-binaries-on-a-64-bit-system-gnu-toolchain">building 64-bit binaries</a> from source written for 32-bit, I wonder <strong>what <em>exactly</em> does happen on current Linux?</strong></p>

<p><strong>Does <code>int 0x80</code> save/restore all the 64-bit registers?  Does it truncate any registers to 32-bit?  What happens if you pass pointer args that have non-zero upper halves?</strong></p>

<p><strong>Does it work if you pass it 32-bit pointers?</strong></p>
    </div></div></div><div class="solution-section"><nav class="flex pagination-solution flex-col justify-end"><ul class="inline-flex -space-x-px overflow-auto"><li class="pagination-solution-item"><span data-id="#solution1" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">1</span></li></ul></nav><div id="solution1" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 1</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/x86-64">x86-64</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/system-calls">system-calls</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/abi">abi</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p><strong>TL:DR</strong>: <code>int 0x80</code> works when used correctly, as long as any pointers fit in 32 bits (<strong>stack pointers don't fit</strong>).  But beware that <strong><code>strace</code> decodes it wrong</strong> unless you have a very recent strace + kernel.</p>
<p><code>int 0x80</code> zeros r8-r11 <a href="https://stackoverflow.com/questions/38505049/using-r8-register-as-a-loop-counter-results-in-endless-loop-why/38520761#38520761">for reasons</a>, and preserves everything else.  Use it exactly like you would in 32-bit code, with the 32-bit call numbers.  (Or better, don't use it!)</p>
<p>Not all systems even support <code>int 0x80</code>:  The Windows Subsystem for Linux version 1 (WSL1) is strictly 64-bit only: <a href="https://stackoverflow.com/questions/47736104/assembly-compiled-executable-on-bash-on-ubuntu-on-windows-doesnt-produce-output"><code>int 0x80</code> doesn't work at all</a>.  It's also possible to build Linux kernels <a href="https://wiki.gentoo.org/wiki/AMD64/FAQ#What_kernel_should_I_use.3F" rel="noreferrer">without IA-32 emulation</a> either.  (No support for 32-bit executables, no support for 32-bit system calls).  See <a href="https://stackoverflow.com/questions/61300194/does-wsl-2-really-support-32-bit-program">this</a> re: making sure your WSL is actually WSL2 (which uses an actual Linux kernel in a VM.)</p>
<hr>
<h3>The details: what's saved/restored, which parts of which regs the kernel uses</h3>
<p><code>int 0x80</code> uses <code>eax</code> (not the full <code>rax</code>) as the system-call number, dispatching to the same table of function-pointers that 32-bit user-space <code>int 0x80</code> uses.  (These pointers are to <code>sys_whatever</code> implementations or wrappers for the native 64-bit implementation inside the kernel.  System calls are really function calls across the user/kernel boundary.)</p>
<p>Only the low 32 bits of arg registers are passed.  <strong>The upper halves of <code>rbx</code>-<code>rbp</code> are preserved, but ignored by <code>int 0x80</code> system calls.</strong>  Note that passing a bad pointer to a system call doesn't result in SIGSEGV; instead the system call returns <code>-EFAULT</code>.  If you don't check error return values (with a debugger or tracing tool), it will appear to silently fail.</p>
<p>All registers (except eax of course) are saved/restored (including RFLAGS, and the upper 32 of integer regs), except that <strong>r8-r11 are zeroed</strong>.  <code>r12-r15</code> are call-preserved in the x86-64 SysV ABI's function calling convention, so the registers that get zeroed by <code>int 0x80</code> in 64-bit are the call-clobbered subset of the "new" registers that AMD64 added.</p>
<p>This behaviour has been preserved over some internal changes to how register-saving was implemented inside the kernel, and comments in the kernel mention that it's usable from 64-bit, so this ABI is probably stable.  (I.e. you can count on r8-r11 being zeroed, and everything else being preserved.)</p>
<p>The return value is sign-extended to fill 64-bit <code>rax</code>.  <a href="https://github.com/torvalds/linux/blob/89c9fea3c8034cdb2fd745f551cde0b507fd6893/arch/x86/entry/syscall_32.c#L9" rel="noreferrer">(Linux declares 32-bit sys_ functions as returning signed <code>long</code></a>.)  This means that pointer return values (like from <code>void *mmap()</code>) need to be zero-extended before use in 64-bit addressing modes</p>
<p>Unlike <code>sysenter</code>, it preserves the original value of <code>cs</code>, so it returns to user-space in the same mode that it was called in.  (Using <code>sysenter</code> results in the kernel setting <code>cs</code> to <code>$__USER32_CS</code>, which selects a descriptor for a 32-bit code segment.)</p>
<hr>
<p><strong>Older <code>strace</code> decodes <code>int 0x80</code> incorrectly</strong> for 64-bit processes.  It decodes as if the process had used <code>syscall</code> instead of <code>int 0x80</code>.  <a href="https://stackoverflow.com/questions/2500362/running-32-bit-assembly-code-on-a-64-bit-linux-64-bit-processor-explain-the/46020177#46020177">This</a> can be <a href="https://stackoverflow.com/a/8106176/224132">very confusing</a>.  e.g. <code>strace</code> prints <code>write(0, NULL, 12 &lt;unfinished ... exit status 1&gt;</code> for <code>eax=1</code> / <code>int $0x80</code>, which is actually <code>_exit(ebx)</code>, not <code>write(rdi, rsi, rdx)</code>.</p>
<p>I don't know the exact version where the <code>PTRACE_GET_SYSCALL_INFO</code> feature was added, but Linux kernel 5.5 / strace 5.5 handle it.  It misleadingly says the process "runs in 32-bit mode" but does decode correctly.  (<a href="https://stackoverflow.com/questions/53456266/can-ptrace-tell-if-an-x86-system-call-used-the-64-bit-or-32-bit-abi">Example</a>).</p>
<hr>
<p><strong><code>int 0x80</code> works as long as all arguments (including pointers) fit in the low 32 of a register</strong>.  This is the case for static code and data in the default code model ("small") <a href="https://github.com/hjl-tools/x86-psABI/wiki/X86-psABI" rel="noreferrer">in the x86-64 SysV ABI</a>.  (Section 3.5.1
: <em>all symbols are known to be located in the virtual addresses in the range <code>0x00000000</code> to <code>0x7effffff</code></em>, so you can do stuff like <code>mov edi, hello</code> (AT&amp;T <code>mov $hello, %edi</code>) to get a pointer into a register with a 5 byte instruction).</p>
<p>But <strong>this is <em>not</em> the case for <a href="https://en.wikipedia.org/wiki/Position-independent_code#Position-independent_executables" rel="noreferrer">position-independent executables</a>, which many Linux distros now configure <code>gcc</code> to make by default</strong> (and they <a href="https://en.wikipedia.org/wiki/Address_space_layout_randomization" rel="noreferrer">enable ASLR</a> for executables).  For example, I compiled a <code>hello.c</code> on Arch Linux, and set a breakpoint at the start of main.  The string constant passed to <code>puts</code> was at <code>0x555555554724</code>, so a 32-bit ABI <code>write</code> system call would not work.  (GDB disables ASLR by default, so you always see the same address from run to run, if you run from within GDB.)</p>
<p>Linux puts the stack near <a href="https://stackoverflow.com/questions/38977755/address-canonical-form-and-pointer-arithmetic/38983032#38983032">the "gap" between the upper and lower ranges of canonical addresses</a>, i.e. with the top of the stack at 2^48-1.  (Or somewhere random, with ASLR enabled).  So <code>rsp</code> on entry to <code>_start</code> in a typical statically-linked executable is something like <code>0x7fffffffe550</code>, depending on size of env vars and args.  Truncating this pointer to <code>esp</code> does not point to any valid memory, so system calls with pointer inputs will typically return <code>-EFAULT</code> if you try to pass a truncated stack pointer.  (And your program will crash if you truncate <code>rsp</code> to <code>esp</code> and then do anything with the stack, e.g. if you built 32-bit asm source as a 64-bit executable.)</p>
<hr>
<h3>How it works in the kernel:</h3>
<p>In the Linux source code, <code>arch/x86/entry/entry_64_compat.S</code> defines
<code>ENTRY(entry_INT80_compat)</code>.  Both 32 and 64-bit processes use the same entry point when they execute <code>int 0x80</code>.</p>
<p><code>entry_64.S</code> is defines native entry points for a 64-bit kernel, which includes interrupt / fault handlers and <code>syscall</code> native system calls from <a href="http://wiki.osdev.org/X86-64#Long_Mode" rel="noreferrer">long mode (aka 64-bit mode)</a> processes.</p>
<p><code>entry_64_compat.S</code> defines system-call entry-points from compat mode into a 64-bit kernel, plus the special case of <code>int 0x80</code> in a 64-bit process.   (<code>sysenter</code> in a 64-bit process may go to that entry point as well, but it pushes <code>$__USER32_CS</code>, so it will always return in 32-bit mode.)  There's a 32-bit version of the <code>syscall</code> instruction, supported on AMD CPUs, and Linux supports it too for fast 32-bit system calls from 32-bit processes.</p>
<p>I guess a <strong>possible use-case</strong> for <code>int 0x80</code> in 64-bit mode is if you wanted to use <a href="https://stackoverflow.com/a/13355668/224132">a <strong>custom code-segment descriptor</strong></a> that you installed with <code>modify_ldt</code>.  <code>int 0x80</code> pushes segment registers itself for use with <a href="http://felixcloutier.com/x86/IRET:IRETD.html" rel="noreferrer"><code>iret</code></a>, and Linux always returns from <code>int 0x80</code> system calls via <code>iret</code>.  The 64-bit <code>syscall</code> entry point sets <code>pt_regs-&gt;cs</code> and <code>-&gt;ss</code> to constants, <code>__USER_CS</code> and <code>__USER_DS</code>.  (It's normal that SS and DS use the same segment descriptors.  Permission differences are done with paging, not segmentation.)</p>
<p><code>entry_32.S</code> defines entry points into a 32-bit kernel, and is not involved at all.</p>
<blockquote>
<p>The <code>int 0x80</code> entry point in <a href="https://github.com/torvalds/linux/blob/e7d0c41ecc2e372a81741a30894f556afec24315/arch/x86/entry/entry_64_compat.S#L267" rel="noreferrer">Linux 4.12's <code>entry_64_compat.S</code></a>:</p>
<pre><code>/*
 * 32-bit legacy system call entry.
 *
 * 32-bit x86 Linux system calls traditionally used the INT $0x80
 * instruction.  INT $0x80 lands here.
 *
 * This entry point can be used by 32-bit and 64-bit programs to perform
 * 32-bit system calls.  Instances of INT $0x80 can be found inline in
 * various programs and libraries.  It is also used by the vDSO's
 * __kernel_vsyscall fallback for hardware that doesn't support a faster
 * entry method.  Restarted 32-bit system calls also fall back to INT
 * $0x80 regardless of what instruction was originally used to do the
 * system call.
 *
 * This is considered a slow path.  It is not used by most libc
 * implementations on modern hardware except during process startup.
 ...
 */
 ENTRY(entry_INT80_compat)
 ...  (see the github URL for the full source)
</code></pre>
</blockquote>
<p>The code zero-extends eax into rax, then pushes all the registers onto the kernel stack to form a <a href="https://github.com/torvalds/linux/blob/80cee03bf1d626db0278271b505d7f5febb37bba/arch/x86/include/asm/ptrace.h#L53" rel="noreferrer"><code>struct pt_regs</code></a>.  This is where it will restore from when the system call returns.  It's in a standard layout for saved user-space registers (for any entry point), so <code>ptrace</code> from other process (like gdb or <code>strace</code>) will read and/or write that memory if they use <code>ptrace</code> while this process is inside a system call.  (<code>ptrace</code> modification of registers is one thing that makes return paths complicated for the other entry points.  See comments.)</p>
<p>But it pushes <code>$0</code> instead of r8/r9/r10/r11.   (<code>sysenter</code> and AMD <code>syscall32</code> entry points store zeros for r8-r15.)</p>
<p>I think this zeroing of r8-r11 is to match historical behaviour.  Before the <a href="https://github.com/torvalds/linux/commit/8169aff611956ed360e3313e8c718f530f58f6cb" rel="noreferrer">Set up full pt_regs for all compat syscalls</a> commit, the entry point only saved the C call-clobbered registers.  It dispatched directly from asm with <code>call  *ia32_sys_call_table(, %rax, 8)</code>, and those functions follow the calling convention, so they preserve <code>rbx</code>, <code>rbp</code>, <code>rsp</code>, and <code>r12-r15</code>.  Zeroing <code>r8-r11</code> instead of leaving them undefined was <a href="https://stackoverflow.com/questions/38505049/using-r8-register-as-a-loop-counter-results-in-endless-loop-why/38520761#38520761">to avoid info leaks</a> from a 64-bit kernel to 32-bit user-space (which could far jmp to a 64-bit code segment to read anything the kernel left there).</p>
<p>The current implementation (Linux 4.12) dispatches 32-bit-ABI system calls from C, reloading the saved <code>ebx</code>, <code>ecx</code>, etc. from <code>pt_regs</code>.  (64-bit native system calls dispatch directly from asm, <a href="https://github.com/torvalds/linux/blob/e7d0c41ecc2e372a81741a30894f556afec24315/arch/x86/entry/entry_64.S#L195" rel="noreferrer">with only a <code>mov %r10, %rcx</code></a> needed to account for the small difference in calling convention between functions and <code>syscall</code>.  Unfortunately it can't always use <code>sysret</code>, because CPU bugs make it unsafe with non-canonical addresses.  It does try to, so the fast-path is pretty damn fast, although <code>syscall</code> itself still takes tens of cycles.)</p>
<p>Anyway, in current Linux, 32-bit syscalls (including <code>int 0x80</code> from 64-bit) eventually end up in<a href="https://github.com/torvalds/linux/blob/89c9fea3c8034cdb2fd745f551cde0b507fd6893/arch/x86/entry/common.c#L319" rel="noreferrer"><code>do_syscall_32_irqs_on(struct pt_regs *regs)</code></a>.  It dispatches to a function pointer <code>ia32_sys_call_table</code>, with 6 zero-extended args.  This maybe avoids needing a wrapper around the 64-bit native syscall function in more cases to preserve that behaviour, so more of the <code>ia32</code> table entries can be the native system call implementation directly.</p>
<blockquote>
<p><a href="https://github.com/torvalds/linux/blob/89c9fea3c8034cdb2fd745f551cde0b507fd6893/arch/x86/entry/common.c#L319" rel="noreferrer">Linux 4.12 <code>arch/x86/entry/common.c</code></a></p>
<pre><code>if (likely(nr &lt; IA32_NR_syscalls)) {
  /*
   * It's possible that a 32-bit syscall implementation
   * takes a 64-bit parameter but nonetheless assumes that
   * the high bits are zero.  Make sure we zero-extend all
   * of the args.
   */
  regs-&gt;ax = ia32_sys_call_table[nr](
      (unsigned int)regs-&gt;bx, (unsigned int)regs-&gt;cx,
      (unsigned int)regs-&gt;dx, (unsigned int)regs-&gt;si,
      (unsigned int)regs-&gt;di, (unsigned int)regs-&gt;bp);
}

syscall_return_slowpath(regs);
</code></pre>
</blockquote>
<p>In older versions of Linux that dispatch 32-bit system calls from asm (like 64-bit still did until 4.15<sup>1</sup>), the int80 entry point itself puts args in the right registers with <code>mov</code> and <code>xchg</code> instructions, using 32-bit registers.  It even uses <code>mov %edx,%edx</code> to zero-extend EDX into RDX (because arg3 happen to use the same register in both conventions).  <a href="https://github.com/torvalds/linux/blob/b611acf4736b5b00c89dcc238f640337832abcb4/arch/x86/entry/entry_64_compat.S#L552" rel="noreferrer">code here</a>.  This code is duplicated in the <code>sysenter</code> and <code>syscall32</code> entry points.</p>
<p>Footnote 1: Linux 4.15 (I think) introduced Spectre / Meltdown mitigations, and a major revamp of the entry points that made them them a trampoline for the meltdown case.  It also sanitized the incoming registers to avoid user-space values other than actual args being in registers during the call (when some Spectre gadget might run), by storing them, zeroing everything, then calling to a C wrapper that reloads just the right widths of args from the struct saved on entry.</p>
<p>I'm planning to leave this answer describing the much simpler mechanism because the conceptually useful part here is that the kernel side of a syscall involves using EAX or RAX as an index into a table of function pointers, with other incoming register values copied going to the places where the calling convention wants args to go.  i.e. <code>syscall</code> is just a way to make a call into the kernel, to its dispatch code.</p>
<hr>
<h3>Simple example / test program:</h3>
<p>I wrote a simple Hello World (in NASM syntax) which sets all registers to have non-zero upper halves, then makes two <code>write()</code> system calls with <code>int 0x80</code>, one with a pointer to a string in <code>.rodata</code> (succeeds), the second with a pointer to the stack (fails with <code>-EFAULT</code>).</p>
<p>Then it uses the native 64-bit <code>syscall</code> ABI to <code>write()</code> the chars from the stack (64-bit pointer), and again to exit.</p>
<p>So all of these examples are using the ABIs correctly, except for the 2nd <code>int 0x80</code> which tries to pass a 64-bit pointer and has it truncated.</p>
<p>If you built it as a position-independent executable, the first one would fail too.  (You'd have to use a RIP-relative <code>lea</code> instead of <code>mov</code> to get the address of <code>hello:</code> into a register.)</p>
<p>I used gdb, but use whatever debugger you prefer.  Use one that highlights changed registers since the last single-step.  <a href="https://github.com/cs01/gdbgui" rel="noreferrer"><code>gdbgui</code></a> works well for debugging asm source, but is not great for disassembly.  Still, it does have a register pane that works well for integer regs at least, and it worked great on this example.</p>
<p><strong>See the inline <code>;;;</code> comments describing how register are changed by system calls</strong></p>
<pre><code>global _start
_start:
    mov  rax, 0x123456789abcdef
    mov  rbx, rax
    mov  rcx, rax
    mov  rdx, rax
    mov  rsi, rax
    mov  rdi, rax
    mov  rbp, rax
    mov  r8, rax
    mov  r9, rax
    mov  r10, rax
    mov  r11, rax
    mov  r12, rax
    mov  r13, rax
    mov  r14, rax
    mov  r15, rax

    ;; 32-bit ABI
    mov  rax, 0xffffffff00000004          ; high garbage + __NR_write (unistd_32.h)
    mov  rbx, 0xffffffff00000001          ; high garbage + fd=1
    mov  rcx, 0xffffffff00000000 + .hello
    mov  rdx, 0xffffffff00000000 + .hellolen
    ;std
after_setup:       ; set a breakpoint here
    int  0x80                   ; write(1, hello, hellolen);   32-bit ABI
    ;; succeeds, writing to stdout
;;; changes to registers:   r8-r11 = 0.  rax=14 = return value

    ; ebx still = 1 = STDOUT_FILENO
    push 'bye' + (0xa&lt;&lt;(3*8))
    mov  rcx, rsp               ; rcx = 64-bit pointer that won't work if truncated
    mov  edx, 4
    mov  eax, 4                 ; __NR_write (unistd_32.h)
    int  0x80                   ; write(ebx=1, ecx=truncated pointer,  edx=4);  32-bit
    ;; fails, nothing printed
;;; changes to registers: rax=-14 = -EFAULT  (from /usr/include/asm-generic/errno-base.h)

    mov  r10, rax               ; save return value as exit status
    mov  r8, r15
    mov  r9, r15
    mov  r11, r15               ; make these regs non-zero again

    ;; 64-bit ABI
    mov  eax, 1                 ; __NR_write (unistd_64.h)
    mov  edi, 1
    mov  rsi, rsp
    mov  edx, 4
    syscall                     ; write(edi=1, rsi='bye\n' on the stack,  rdx=4);  64-bit
    ;; succeeds: writes to stdout and returns 4 in rax
;;; changes to registers: rax=4 = length return value
;;; rcx = 0x400112 = RIP.   r11 = 0x302 = eflags with an extra bit set.
;;; (This is not a coincidence, it's how sysret works.  But don't depend on it, since iret could leave something else)

    mov  edi, r10d
    ;xor  edi,edi
    mov  eax, 60                ; __NR_exit (unistd_64.h)
    syscall                     ; _exit(edi = first int 0x80 result);  64-bit
    ;; succeeds, exit status = low byte of first int 0x80 result = 14

section .rodata
_start.hello:    db "Hello World!", 0xa, 0
_start.hellolen  equ   $ - _start.hello
</code></pre>
<p><a href="https://stackoverflow.com/questions/36861903/assembling-32-bit-binaries-on-a-64-bit-system-gnu-toolchain">Build it</a> into a 64-bit static binary with</p>
<pre><code>yasm -felf64 -Worphan-labels -gdwarf2 abi32-from-64.asm
ld -o abi32-from-64 abi32-from-64.o
</code></pre>
<p>Run <code>gdb ./abi32-from-64</code>.  In <code>gdb</code>, run <code>set disassembly-flavor intel</code> and <code>layout reg</code> if you don't have that in your <code>~/.gdbinit</code> already.  (GAS <code>.intel_syntax</code> is like MASM, not NASM, but they're close enough that it's easy to read if you like NASM syntax.)</p>
<pre><code>(gdb)  set disassembly-flavor intel
(gdb)  layout reg
(gdb)  b  after_setup
(gdb)  r
(gdb)  si                     # step instruction
    press return to repeat the last command, keep stepping
</code></pre>
<p>Press control-L when gdb's TUI mode gets messed up.  This happens easily, even when programs don't print to stdout themselves.</p>
    </div></div></div></div></div></div><div class="widget"><a href="/questions/using-asyncawait-with-a-foreach-loop-1657384512667">Using async/await with a forEach loop</a><a href="/questions/are-&#x27;arrow-functions&#x27;-and-&#x27;functions&#x27;-equivalent-interchangeable-1657384527873">Are &#x27;Arrow Functions&#x27; and &#x27;Functions&#x27; equivalent / interchangeable?</a><a href="/questions/how-do-i-make-a-flat-list-out-of-a-list-of-lists-1657384500439">How do I make a flat list out of a list of lists?</a><a href="/questions/what-does-it-mean-to-%22program-to-an-interface%22-1657384671665">What does it mean to &quot;program to an interface&quot;?</a><a href="/questions/mysql-pivot-row-into-dynamic-number-of-columns-1657387981930">MySQL pivot row into dynamic number of columns</a><a href="/questions/how-to-remove-%22noise%22-from-gccclang-assembly-output-1657387612391">How to remove &quot;noise&quot; from GCC/clang assembly output?</a><a href="/questions/servlet-returns-%22http-status-404-the-requested-resource-(servlet)-is-not-available%22-1657384850661">Servlet returns &quot;HTTP Status 404 The requested resource (/servlet) is not available&quot;</a><a href="/questions/why-do-i-need-to-override-the-equals-and-hashcode-methods-in-java-1657388359877">Why do I need to override the equals and hashCode methods in Java?</a><a href="/questions/how-do-i-attach-events-to-dynamic-html-elements-with-jquery-duplicate-1657387992964">How do I attach events to dynamic HTML elements with jQuery? [duplicate]</a><a href="/questions/what-is-an-efficient-way-to-implement-a-singleton-pattern-in-java-closed-1657387970474">What is an efficient way to implement a singleton pattern in Java? [closed]</a><a href="/questions/what-do-&#x27;lazy&#x27;-and-&#x27;greedy&#x27;-mean-in-the-context-of-regular-expressions-1657388200552">What do &#x27;lazy&#x27; and &#x27;greedy&#x27; mean in the context of regular expressions?</a><a href="/questions/selecting-and-manipulating-css-pseudo-elements-such-as-::before-and-::after-using-javascript-(or-jquery)-1657387406132">Selecting and manipulating CSS pseudo-elements such as ::before and ::after using javascript (or jQuery)</a><a href="/questions/what-is-move-semantics-1657387702625">What is move semantics?</a><a href="/questions/how-do-i-detect-a-click-outside-an-element-1657387505351">How do I detect a click outside an element?</a><a href="/questions/why-don&#x27;t-flex-items-shrink-past-content-size-1657384687282">Why don&#x27;t flex items shrink past content size?</a><a href="/questions/how-to-filter-pandas-dataframe-using-&#x27;in&#x27;-and-&#x27;not-in&#x27;-like-in-sql-1657387371355">How to filter Pandas dataframe using &#x27;in&#x27; and &#x27;not in&#x27; like in SQL</a><a href="/questions/what-does-if-__name__-%22__main__%22:-do-1657384825815">What does if __name__ == &quot;__main__&quot;: do?</a><a href="/questions/default-constructor-with-empty-brackets-1657388246967">Default constructor with empty brackets</a><a href="/questions/dynamic-tabs-with-user-click-chosen-components-1657388465232">Dynamic tabs with user-click chosen components</a><a href="/questions/how-do-i-use-extern-to-share-variables-between-source-files-1657387453605">How do I use extern to share variables between source files?</a></div></div><span class="cursor-pointer text-lg p-2" style="position:fixed;bottom:20px;left:20px;background:#000;z-index:2000;color:white">Go go top</span></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"data":{"answer":["\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;TL:DR\u0026lt;/strong\u0026gt;: \u0026lt;code\u0026gt;int 0x80\u0026lt;/code\u0026gt; works when used correctly, as long as any pointers fit in 32 bits (\u0026lt;strong\u0026gt;stack pointers don\u0026apos;t fit\u0026lt;/strong\u0026gt;).  But beware that \u0026lt;strong\u0026gt;\u0026lt;code\u0026gt;strace\u0026lt;/code\u0026gt; decodes it wrong\u0026lt;/strong\u0026gt; unless you have a very recent strace + kernel.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;code\u0026gt;int 0x80\u0026lt;/code\u0026gt; zeros r8-r11 \u0026lt;a href=\u0026quot;https://stackoverflow.com/questions/38505049/using-r8-register-as-a-loop-counter-results-in-endless-loop-why/38520761#38520761\u0026quot;\u0026gt;for reasons\u0026lt;/a\u0026gt;, and preserves everything else.  Use it exactly like you would in 32-bit code, with the 32-bit call numbers.  (Or better, don\u0026apos;t use it!)\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Not all systems even support \u0026lt;code\u0026gt;int 0x80\u0026lt;/code\u0026gt;:  The Windows Subsystem for Linux version 1 (WSL1) is strictly 64-bit only: \u0026lt;a href=\u0026quot;https://stackoverflow.com/questions/47736104/assembly-compiled-executable-on-bash-on-ubuntu-on-windows-doesnt-produce-output\u0026quot;\u0026gt;\u0026lt;code\u0026gt;int 0x80\u0026lt;/code\u0026gt; doesn\u0026apos;t work at all\u0026lt;/a\u0026gt;.  It\u0026apos;s also possible to build Linux kernels \u0026lt;a href=\u0026quot;https://wiki.gentoo.org/wiki/AMD64/FAQ#What_kernel_should_I_use.3F\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;without IA-32 emulation\u0026lt;/a\u0026gt; either.  (No support for 32-bit executables, no support for 32-bit system calls).  See \u0026lt;a href=\u0026quot;https://stackoverflow.com/questions/61300194/does-wsl-2-really-support-32-bit-program\u0026quot;\u0026gt;this\u0026lt;/a\u0026gt; re: making sure your WSL is actually WSL2 (which uses an actual Linux kernel in a VM.)\u0026lt;/p\u0026gt;\n\u0026lt;hr\u0026gt;\n\u0026lt;h3\u0026gt;The details: what\u0026apos;s saved/restored, which parts of which regs the kernel uses\u0026lt;/h3\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;code\u0026gt;int 0x80\u0026lt;/code\u0026gt; uses \u0026lt;code\u0026gt;eax\u0026lt;/code\u0026gt; (not the full \u0026lt;code\u0026gt;rax\u0026lt;/code\u0026gt;) as the system-call number, dispatching to the same table of function-pointers that 32-bit user-space \u0026lt;code\u0026gt;int 0x80\u0026lt;/code\u0026gt; uses.  (These pointers are to \u0026lt;code\u0026gt;sys_whatever\u0026lt;/code\u0026gt; implementations or wrappers for the native 64-bit implementation inside the kernel.  System calls are really function calls across the user/kernel boundary.)\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Only the low 32 bits of arg registers are passed.  \u0026lt;strong\u0026gt;The upper halves of \u0026lt;code\u0026gt;rbx\u0026lt;/code\u0026gt;-\u0026lt;code\u0026gt;rbp\u0026lt;/code\u0026gt; are preserved, but ignored by \u0026lt;code\u0026gt;int 0x80\u0026lt;/code\u0026gt; system calls.\u0026lt;/strong\u0026gt;  Note that passing a bad pointer to a system call doesn\u0026apos;t result in SIGSEGV; instead the system call returns \u0026lt;code\u0026gt;-EFAULT\u0026lt;/code\u0026gt;.  If you don\u0026apos;t check error return values (with a debugger or tracing tool), it will appear to silently fail.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;All registers (except eax of course) are saved/restored (including RFLAGS, and the upper 32 of integer regs), except that \u0026lt;strong\u0026gt;r8-r11 are zeroed\u0026lt;/strong\u0026gt;.  \u0026lt;code\u0026gt;r12-r15\u0026lt;/code\u0026gt; are call-preserved in the x86-64 SysV ABI\u0026apos;s function calling convention, so the registers that get zeroed by \u0026lt;code\u0026gt;int 0x80\u0026lt;/code\u0026gt; in 64-bit are the call-clobbered subset of the \u0026quot;new\u0026quot; registers that AMD64 added.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;This behaviour has been preserved over some internal changes to how register-saving was implemented inside the kernel, and comments in the kernel mention that it\u0026apos;s usable from 64-bit, so this ABI is probably stable.  (I.e. you can count on r8-r11 being zeroed, and everything else being preserved.)\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;The return value is sign-extended to fill 64-bit \u0026lt;code\u0026gt;rax\u0026lt;/code\u0026gt;.  \u0026lt;a href=\u0026quot;https://github.com/torvalds/linux/blob/89c9fea3c8034cdb2fd745f551cde0b507fd6893/arch/x86/entry/syscall_32.c#L9\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;(Linux declares 32-bit sys_ functions as returning signed \u0026lt;code\u0026gt;long\u0026lt;/code\u0026gt;\u0026lt;/a\u0026gt;.)  This means that pointer return values (like from \u0026lt;code\u0026gt;void *mmap()\u0026lt;/code\u0026gt;) need to be zero-extended before use in 64-bit addressing modes\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Unlike \u0026lt;code\u0026gt;sysenter\u0026lt;/code\u0026gt;, it preserves the original value of \u0026lt;code\u0026gt;cs\u0026lt;/code\u0026gt;, so it returns to user-space in the same mode that it was called in.  (Using \u0026lt;code\u0026gt;sysenter\u0026lt;/code\u0026gt; results in the kernel setting \u0026lt;code\u0026gt;cs\u0026lt;/code\u0026gt; to \u0026lt;code\u0026gt;$__USER32_CS\u0026lt;/code\u0026gt;, which selects a descriptor for a 32-bit code segment.)\u0026lt;/p\u0026gt;\n\u0026lt;hr\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Older \u0026lt;code\u0026gt;strace\u0026lt;/code\u0026gt; decodes \u0026lt;code\u0026gt;int 0x80\u0026lt;/code\u0026gt; incorrectly\u0026lt;/strong\u0026gt; for 64-bit processes.  It decodes as if the process had used \u0026lt;code\u0026gt;syscall\u0026lt;/code\u0026gt; instead of \u0026lt;code\u0026gt;int 0x80\u0026lt;/code\u0026gt;.  \u0026lt;a href=\u0026quot;https://stackoverflow.com/questions/2500362/running-32-bit-assembly-code-on-a-64-bit-linux-64-bit-processor-explain-the/46020177#46020177\u0026quot;\u0026gt;This\u0026lt;/a\u0026gt; can be \u0026lt;a href=\u0026quot;https://stackoverflow.com/a/8106176/224132\u0026quot;\u0026gt;very confusing\u0026lt;/a\u0026gt;.  e.g. \u0026lt;code\u0026gt;strace\u0026lt;/code\u0026gt; prints \u0026lt;code\u0026gt;write(0, NULL, 12 \u0026amp;lt;unfinished ... exit status 1\u0026amp;gt;\u0026lt;/code\u0026gt; for \u0026lt;code\u0026gt;eax=1\u0026lt;/code\u0026gt; / \u0026lt;code\u0026gt;int $0x80\u0026lt;/code\u0026gt;, which is actually \u0026lt;code\u0026gt;_exit(ebx)\u0026lt;/code\u0026gt;, not \u0026lt;code\u0026gt;write(rdi, rsi, rdx)\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;I don\u0026apos;t know the exact version where the \u0026lt;code\u0026gt;PTRACE_GET_SYSCALL_INFO\u0026lt;/code\u0026gt; feature was added, but Linux kernel 5.5 / strace 5.5 handle it.  It misleadingly says the process \u0026quot;runs in 32-bit mode\u0026quot; but does decode correctly.  (\u0026lt;a href=\u0026quot;https://stackoverflow.com/questions/53456266/can-ptrace-tell-if-an-x86-system-call-used-the-64-bit-or-32-bit-abi\u0026quot;\u0026gt;Example\u0026lt;/a\u0026gt;).\u0026lt;/p\u0026gt;\n\u0026lt;hr\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;\u0026lt;code\u0026gt;int 0x80\u0026lt;/code\u0026gt; works as long as all arguments (including pointers) fit in the low 32 of a register\u0026lt;/strong\u0026gt;.  This is the case for static code and data in the default code model (\u0026quot;small\u0026quot;) \u0026lt;a href=\u0026quot;https://github.com/hjl-tools/x86-psABI/wiki/X86-psABI\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;in the x86-64 SysV ABI\u0026lt;/a\u0026gt;.  (Section 3.5.1\n: \u0026lt;em\u0026gt;all symbols are known to be located in the virtual addresses in the range \u0026lt;code\u0026gt;0x00000000\u0026lt;/code\u0026gt; to \u0026lt;code\u0026gt;0x7effffff\u0026lt;/code\u0026gt;\u0026lt;/em\u0026gt;, so you can do stuff like \u0026lt;code\u0026gt;mov edi, hello\u0026lt;/code\u0026gt; (AT\u0026amp;amp;T \u0026lt;code\u0026gt;mov $hello, %edi\u0026lt;/code\u0026gt;) to get a pointer into a register with a 5 byte instruction).\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;But \u0026lt;strong\u0026gt;this is \u0026lt;em\u0026gt;not\u0026lt;/em\u0026gt; the case for \u0026lt;a href=\u0026quot;https://en.wikipedia.org/wiki/Position-independent_code#Position-independent_executables\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;position-independent executables\u0026lt;/a\u0026gt;, which many Linux distros now configure \u0026lt;code\u0026gt;gcc\u0026lt;/code\u0026gt; to make by default\u0026lt;/strong\u0026gt; (and they \u0026lt;a href=\u0026quot;https://en.wikipedia.org/wiki/Address_space_layout_randomization\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;enable ASLR\u0026lt;/a\u0026gt; for executables).  For example, I compiled a \u0026lt;code\u0026gt;hello.c\u0026lt;/code\u0026gt; on Arch Linux, and set a breakpoint at the start of main.  The string constant passed to \u0026lt;code\u0026gt;puts\u0026lt;/code\u0026gt; was at \u0026lt;code\u0026gt;0x555555554724\u0026lt;/code\u0026gt;, so a 32-bit ABI \u0026lt;code\u0026gt;write\u0026lt;/code\u0026gt; system call would not work.  (GDB disables ASLR by default, so you always see the same address from run to run, if you run from within GDB.)\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Linux puts the stack near \u0026lt;a href=\u0026quot;https://stackoverflow.com/questions/38977755/address-canonical-form-and-pointer-arithmetic/38983032#38983032\u0026quot;\u0026gt;the \u0026quot;gap\u0026quot; between the upper and lower ranges of canonical addresses\u0026lt;/a\u0026gt;, i.e. with the top of the stack at 2^48-1.  (Or somewhere random, with ASLR enabled).  So \u0026lt;code\u0026gt;rsp\u0026lt;/code\u0026gt; on entry to \u0026lt;code\u0026gt;_start\u0026lt;/code\u0026gt; in a typical statically-linked executable is something like \u0026lt;code\u0026gt;0x7fffffffe550\u0026lt;/code\u0026gt;, depending on size of env vars and args.  Truncating this pointer to \u0026lt;code\u0026gt;esp\u0026lt;/code\u0026gt; does not point to any valid memory, so system calls with pointer inputs will typically return \u0026lt;code\u0026gt;-EFAULT\u0026lt;/code\u0026gt; if you try to pass a truncated stack pointer.  (And your program will crash if you truncate \u0026lt;code\u0026gt;rsp\u0026lt;/code\u0026gt; to \u0026lt;code\u0026gt;esp\u0026lt;/code\u0026gt; and then do anything with the stack, e.g. if you built 32-bit asm source as a 64-bit executable.)\u0026lt;/p\u0026gt;\n\u0026lt;hr\u0026gt;\n\u0026lt;h3\u0026gt;How it works in the kernel:\u0026lt;/h3\u0026gt;\n\u0026lt;p\u0026gt;In the Linux source code, \u0026lt;code\u0026gt;arch/x86/entry/entry_64_compat.S\u0026lt;/code\u0026gt; defines\n\u0026lt;code\u0026gt;ENTRY(entry_INT80_compat)\u0026lt;/code\u0026gt;.  Both 32 and 64-bit processes use the same entry point when they execute \u0026lt;code\u0026gt;int 0x80\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;code\u0026gt;entry_64.S\u0026lt;/code\u0026gt; is defines native entry points for a 64-bit kernel, which includes interrupt / fault handlers and \u0026lt;code\u0026gt;syscall\u0026lt;/code\u0026gt; native system calls from \u0026lt;a href=\u0026quot;http://wiki.osdev.org/X86-64#Long_Mode\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;long mode (aka 64-bit mode)\u0026lt;/a\u0026gt; processes.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;code\u0026gt;entry_64_compat.S\u0026lt;/code\u0026gt; defines system-call entry-points from compat mode into a 64-bit kernel, plus the special case of \u0026lt;code\u0026gt;int 0x80\u0026lt;/code\u0026gt; in a 64-bit process.   (\u0026lt;code\u0026gt;sysenter\u0026lt;/code\u0026gt; in a 64-bit process may go to that entry point as well, but it pushes \u0026lt;code\u0026gt;$__USER32_CS\u0026lt;/code\u0026gt;, so it will always return in 32-bit mode.)  There\u0026apos;s a 32-bit version of the \u0026lt;code\u0026gt;syscall\u0026lt;/code\u0026gt; instruction, supported on AMD CPUs, and Linux supports it too for fast 32-bit system calls from 32-bit processes.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;I guess a \u0026lt;strong\u0026gt;possible use-case\u0026lt;/strong\u0026gt; for \u0026lt;code\u0026gt;int 0x80\u0026lt;/code\u0026gt; in 64-bit mode is if you wanted to use \u0026lt;a href=\u0026quot;https://stackoverflow.com/a/13355668/224132\u0026quot;\u0026gt;a \u0026lt;strong\u0026gt;custom code-segment descriptor\u0026lt;/strong\u0026gt;\u0026lt;/a\u0026gt; that you installed with \u0026lt;code\u0026gt;modify_ldt\u0026lt;/code\u0026gt;.  \u0026lt;code\u0026gt;int 0x80\u0026lt;/code\u0026gt; pushes segment registers itself for use with \u0026lt;a href=\u0026quot;http://felixcloutier.com/x86/IRET:IRETD.html\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;\u0026lt;code\u0026gt;iret\u0026lt;/code\u0026gt;\u0026lt;/a\u0026gt;, and Linux always returns from \u0026lt;code\u0026gt;int 0x80\u0026lt;/code\u0026gt; system calls via \u0026lt;code\u0026gt;iret\u0026lt;/code\u0026gt;.  The 64-bit \u0026lt;code\u0026gt;syscall\u0026lt;/code\u0026gt; entry point sets \u0026lt;code\u0026gt;pt_regs-\u0026amp;gt;cs\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;-\u0026amp;gt;ss\u0026lt;/code\u0026gt; to constants, \u0026lt;code\u0026gt;__USER_CS\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;__USER_DS\u0026lt;/code\u0026gt;.  (It\u0026apos;s normal that SS and DS use the same segment descriptors.  Permission differences are done with paging, not segmentation.)\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;code\u0026gt;entry_32.S\u0026lt;/code\u0026gt; defines entry points into a 32-bit kernel, and is not involved at all.\u0026lt;/p\u0026gt;\n\u0026lt;blockquote\u0026gt;\n\u0026lt;p\u0026gt;The \u0026lt;code\u0026gt;int 0x80\u0026lt;/code\u0026gt; entry point in \u0026lt;a href=\u0026quot;https://github.com/torvalds/linux/blob/e7d0c41ecc2e372a81741a30894f556afec24315/arch/x86/entry/entry_64_compat.S#L267\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;Linux 4.12\u0026apos;s \u0026lt;code\u0026gt;entry_64_compat.S\u0026lt;/code\u0026gt;\u0026lt;/a\u0026gt;:\u0026lt;/p\u0026gt;\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;/*\n * 32-bit legacy system call entry.\n *\n * 32-bit x86 Linux system calls traditionally used the INT $0x80\n * instruction.  INT $0x80 lands here.\n *\n * This entry point can be used by 32-bit and 64-bit programs to perform\n * 32-bit system calls.  Instances of INT $0x80 can be found inline in\n * various programs and libraries.  It is also used by the vDSO\u0026apos;s\n * __kernel_vsyscall fallback for hardware that doesn\u0026apos;t support a faster\n * entry method.  Restarted 32-bit system calls also fall back to INT\n * $0x80 regardless of what instruction was originally used to do the\n * system call.\n *\n * This is considered a slow path.  It is not used by most libc\n * implementations on modern hardware except during process startup.\n ...\n */\n ENTRY(entry_INT80_compat)\n ...  (see the github URL for the full source)\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\u0026lt;p\u0026gt;The code zero-extends eax into rax, then pushes all the registers onto the kernel stack to form a \u0026lt;a href=\u0026quot;https://github.com/torvalds/linux/blob/80cee03bf1d626db0278271b505d7f5febb37bba/arch/x86/include/asm/ptrace.h#L53\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;\u0026lt;code\u0026gt;struct pt_regs\u0026lt;/code\u0026gt;\u0026lt;/a\u0026gt;.  This is where it will restore from when the system call returns.  It\u0026apos;s in a standard layout for saved user-space registers (for any entry point), so \u0026lt;code\u0026gt;ptrace\u0026lt;/code\u0026gt; from other process (like gdb or \u0026lt;code\u0026gt;strace\u0026lt;/code\u0026gt;) will read and/or write that memory if they use \u0026lt;code\u0026gt;ptrace\u0026lt;/code\u0026gt; while this process is inside a system call.  (\u0026lt;code\u0026gt;ptrace\u0026lt;/code\u0026gt; modification of registers is one thing that makes return paths complicated for the other entry points.  See comments.)\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;But it pushes \u0026lt;code\u0026gt;$0\u0026lt;/code\u0026gt; instead of r8/r9/r10/r11.   (\u0026lt;code\u0026gt;sysenter\u0026lt;/code\u0026gt; and AMD \u0026lt;code\u0026gt;syscall32\u0026lt;/code\u0026gt; entry points store zeros for r8-r15.)\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;I think this zeroing of r8-r11 is to match historical behaviour.  Before the \u0026lt;a href=\u0026quot;https://github.com/torvalds/linux/commit/8169aff611956ed360e3313e8c718f530f58f6cb\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;Set up full pt_regs for all compat syscalls\u0026lt;/a\u0026gt; commit, the entry point only saved the C call-clobbered registers.  It dispatched directly from asm with \u0026lt;code\u0026gt;call  *ia32_sys_call_table(, %rax, 8)\u0026lt;/code\u0026gt;, and those functions follow the calling convention, so they preserve \u0026lt;code\u0026gt;rbx\u0026lt;/code\u0026gt;, \u0026lt;code\u0026gt;rbp\u0026lt;/code\u0026gt;, \u0026lt;code\u0026gt;rsp\u0026lt;/code\u0026gt;, and \u0026lt;code\u0026gt;r12-r15\u0026lt;/code\u0026gt;.  Zeroing \u0026lt;code\u0026gt;r8-r11\u0026lt;/code\u0026gt; instead of leaving them undefined was \u0026lt;a href=\u0026quot;https://stackoverflow.com/questions/38505049/using-r8-register-as-a-loop-counter-results-in-endless-loop-why/38520761#38520761\u0026quot;\u0026gt;to avoid info leaks\u0026lt;/a\u0026gt; from a 64-bit kernel to 32-bit user-space (which could far jmp to a 64-bit code segment to read anything the kernel left there).\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;The current implementation (Linux 4.12) dispatches 32-bit-ABI system calls from C, reloading the saved \u0026lt;code\u0026gt;ebx\u0026lt;/code\u0026gt;, \u0026lt;code\u0026gt;ecx\u0026lt;/code\u0026gt;, etc. from \u0026lt;code\u0026gt;pt_regs\u0026lt;/code\u0026gt;.  (64-bit native system calls dispatch directly from asm, \u0026lt;a href=\u0026quot;https://github.com/torvalds/linux/blob/e7d0c41ecc2e372a81741a30894f556afec24315/arch/x86/entry/entry_64.S#L195\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;with only a \u0026lt;code\u0026gt;mov %r10, %rcx\u0026lt;/code\u0026gt;\u0026lt;/a\u0026gt; needed to account for the small difference in calling convention between functions and \u0026lt;code\u0026gt;syscall\u0026lt;/code\u0026gt;.  Unfortunately it can\u0026apos;t always use \u0026lt;code\u0026gt;sysret\u0026lt;/code\u0026gt;, because CPU bugs make it unsafe with non-canonical addresses.  It does try to, so the fast-path is pretty damn fast, although \u0026lt;code\u0026gt;syscall\u0026lt;/code\u0026gt; itself still takes tens of cycles.)\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Anyway, in current Linux, 32-bit syscalls (including \u0026lt;code\u0026gt;int 0x80\u0026lt;/code\u0026gt; from 64-bit) eventually end up in\u0026lt;a href=\u0026quot;https://github.com/torvalds/linux/blob/89c9fea3c8034cdb2fd745f551cde0b507fd6893/arch/x86/entry/common.c#L319\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;\u0026lt;code\u0026gt;do_syscall_32_irqs_on(struct pt_regs *regs)\u0026lt;/code\u0026gt;\u0026lt;/a\u0026gt;.  It dispatches to a function pointer \u0026lt;code\u0026gt;ia32_sys_call_table\u0026lt;/code\u0026gt;, with 6 zero-extended args.  This maybe avoids needing a wrapper around the 64-bit native syscall function in more cases to preserve that behaviour, so more of the \u0026lt;code\u0026gt;ia32\u0026lt;/code\u0026gt; table entries can be the native system call implementation directly.\u0026lt;/p\u0026gt;\n\u0026lt;blockquote\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;a href=\u0026quot;https://github.com/torvalds/linux/blob/89c9fea3c8034cdb2fd745f551cde0b507fd6893/arch/x86/entry/common.c#L319\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;Linux 4.12 \u0026lt;code\u0026gt;arch/x86/entry/common.c\u0026lt;/code\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;if (likely(nr \u0026amp;lt; IA32_NR_syscalls)) {\n  /*\n   * It\u0026apos;s possible that a 32-bit syscall implementation\n   * takes a 64-bit parameter but nonetheless assumes that\n   * the high bits are zero.  Make sure we zero-extend all\n   * of the args.\n   */\n  regs-\u0026amp;gt;ax = ia32_sys_call_table[nr](\n      (unsigned int)regs-\u0026amp;gt;bx, (unsigned int)regs-\u0026amp;gt;cx,\n      (unsigned int)regs-\u0026amp;gt;dx, (unsigned int)regs-\u0026amp;gt;si,\n      (unsigned int)regs-\u0026amp;gt;di, (unsigned int)regs-\u0026amp;gt;bp);\n}\n\nsyscall_return_slowpath(regs);\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\u0026lt;p\u0026gt;In older versions of Linux that dispatch 32-bit system calls from asm (like 64-bit still did until 4.15\u0026lt;sup\u0026gt;1\u0026lt;/sup\u0026gt;), the int80 entry point itself puts args in the right registers with \u0026lt;code\u0026gt;mov\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;xchg\u0026lt;/code\u0026gt; instructions, using 32-bit registers.  It even uses \u0026lt;code\u0026gt;mov %edx,%edx\u0026lt;/code\u0026gt; to zero-extend EDX into RDX (because arg3 happen to use the same register in both conventions).  \u0026lt;a href=\u0026quot;https://github.com/torvalds/linux/blob/b611acf4736b5b00c89dcc238f640337832abcb4/arch/x86/entry/entry_64_compat.S#L552\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;code here\u0026lt;/a\u0026gt;.  This code is duplicated in the \u0026lt;code\u0026gt;sysenter\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;syscall32\u0026lt;/code\u0026gt; entry points.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Footnote 1: Linux 4.15 (I think) introduced Spectre / Meltdown mitigations, and a major revamp of the entry points that made them them a trampoline for the meltdown case.  It also sanitized the incoming registers to avoid user-space values other than actual args being in registers during the call (when some Spectre gadget might run), by storing them, zeroing everything, then calling to a C wrapper that reloads just the right widths of args from the struct saved on entry.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;I\u0026apos;m planning to leave this answer describing the much simpler mechanism because the conceptually useful part here is that the kernel side of a syscall involves using EAX or RAX as an index into a table of function pointers, with other incoming register values copied going to the places where the calling convention wants args to go.  i.e. \u0026lt;code\u0026gt;syscall\u0026lt;/code\u0026gt; is just a way to make a call into the kernel, to its dispatch code.\u0026lt;/p\u0026gt;\n\u0026lt;hr\u0026gt;\n\u0026lt;h3\u0026gt;Simple example / test program:\u0026lt;/h3\u0026gt;\n\u0026lt;p\u0026gt;I wrote a simple Hello World (in NASM syntax) which sets all registers to have non-zero upper halves, then makes two \u0026lt;code\u0026gt;write()\u0026lt;/code\u0026gt; system calls with \u0026lt;code\u0026gt;int 0x80\u0026lt;/code\u0026gt;, one with a pointer to a string in \u0026lt;code\u0026gt;.rodata\u0026lt;/code\u0026gt; (succeeds), the second with a pointer to the stack (fails with \u0026lt;code\u0026gt;-EFAULT\u0026lt;/code\u0026gt;).\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Then it uses the native 64-bit \u0026lt;code\u0026gt;syscall\u0026lt;/code\u0026gt; ABI to \u0026lt;code\u0026gt;write()\u0026lt;/code\u0026gt; the chars from the stack (64-bit pointer), and again to exit.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;So all of these examples are using the ABIs correctly, except for the 2nd \u0026lt;code\u0026gt;int 0x80\u0026lt;/code\u0026gt; which tries to pass a 64-bit pointer and has it truncated.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;If you built it as a position-independent executable, the first one would fail too.  (You\u0026apos;d have to use a RIP-relative \u0026lt;code\u0026gt;lea\u0026lt;/code\u0026gt; instead of \u0026lt;code\u0026gt;mov\u0026lt;/code\u0026gt; to get the address of \u0026lt;code\u0026gt;hello:\u0026lt;/code\u0026gt; into a register.)\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;I used gdb, but use whatever debugger you prefer.  Use one that highlights changed registers since the last single-step.  \u0026lt;a href=\u0026quot;https://github.com/cs01/gdbgui\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;\u0026lt;code\u0026gt;gdbgui\u0026lt;/code\u0026gt;\u0026lt;/a\u0026gt; works well for debugging asm source, but is not great for disassembly.  Still, it does have a register pane that works well for integer regs at least, and it worked great on this example.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;See the inline \u0026lt;code\u0026gt;;;;\u0026lt;/code\u0026gt; comments describing how register are changed by system calls\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;global _start\n_start:\n    mov  rax, 0x123456789abcdef\n    mov  rbx, rax\n    mov  rcx, rax\n    mov  rdx, rax\n    mov  rsi, rax\n    mov  rdi, rax\n    mov  rbp, rax\n    mov  r8, rax\n    mov  r9, rax\n    mov  r10, rax\n    mov  r11, rax\n    mov  r12, rax\n    mov  r13, rax\n    mov  r14, rax\n    mov  r15, rax\n\n    ;; 32-bit ABI\n    mov  rax, 0xffffffff00000004          ; high garbage + __NR_write (unistd_32.h)\n    mov  rbx, 0xffffffff00000001          ; high garbage + fd=1\n    mov  rcx, 0xffffffff00000000 + .hello\n    mov  rdx, 0xffffffff00000000 + .hellolen\n    ;std\nafter_setup:       ; set a breakpoint here\n    int  0x80                   ; write(1, hello, hellolen);   32-bit ABI\n    ;; succeeds, writing to stdout\n;;; changes to registers:   r8-r11 = 0.  rax=14 = return value\n\n    ; ebx still = 1 = STDOUT_FILENO\n    push \u0026apos;bye\u0026apos; + (0xa\u0026amp;lt;\u0026amp;lt;(3*8))\n    mov  rcx, rsp               ; rcx = 64-bit pointer that won\u0026apos;t work if truncated\n    mov  edx, 4\n    mov  eax, 4                 ; __NR_write (unistd_32.h)\n    int  0x80                   ; write(ebx=1, ecx=truncated pointer,  edx=4);  32-bit\n    ;; fails, nothing printed\n;;; changes to registers: rax=-14 = -EFAULT  (from /usr/include/asm-generic/errno-base.h)\n\n    mov  r10, rax               ; save return value as exit status\n    mov  r8, r15\n    mov  r9, r15\n    mov  r11, r15               ; make these regs non-zero again\n\n    ;; 64-bit ABI\n    mov  eax, 1                 ; __NR_write (unistd_64.h)\n    mov  edi, 1\n    mov  rsi, rsp\n    mov  edx, 4\n    syscall                     ; write(edi=1, rsi=\u0026apos;bye\\n\u0026apos; on the stack,  rdx=4);  64-bit\n    ;; succeeds: writes to stdout and returns 4 in rax\n;;; changes to registers: rax=4 = length return value\n;;; rcx = 0x400112 = RIP.   r11 = 0x302 = eflags with an extra bit set.\n;;; (This is not a coincidence, it\u0026apos;s how sysret works.  But don\u0026apos;t depend on it, since iret could leave something else)\n\n    mov  edi, r10d\n    ;xor  edi,edi\n    mov  eax, 60                ; __NR_exit (unistd_64.h)\n    syscall                     ; _exit(edi = first int 0x80 result);  64-bit\n    ;; succeeds, exit status = low byte of first int 0x80 result = 14\n\nsection .rodata\n_start.hello:    db \u0026quot;Hello World!\u0026quot;, 0xa, 0\n_start.hellolen  equ   $ - _start.hello\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;a href=\u0026quot;https://stackoverflow.com/questions/36861903/assembling-32-bit-binaries-on-a-64-bit-system-gnu-toolchain\u0026quot;\u0026gt;Build it\u0026lt;/a\u0026gt; into a 64-bit static binary with\u0026lt;/p\u0026gt;\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;yasm -felf64 -Worphan-labels -gdwarf2 abi32-from-64.asm\nld -o abi32-from-64 abi32-from-64.o\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;Run \u0026lt;code\u0026gt;gdb ./abi32-from-64\u0026lt;/code\u0026gt;.  In \u0026lt;code\u0026gt;gdb\u0026lt;/code\u0026gt;, run \u0026lt;code\u0026gt;set disassembly-flavor intel\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;layout reg\u0026lt;/code\u0026gt; if you don\u0026apos;t have that in your \u0026lt;code\u0026gt;~/.gdbinit\u0026lt;/code\u0026gt; already.  (GAS \u0026lt;code\u0026gt;.intel_syntax\u0026lt;/code\u0026gt; is like MASM, not NASM, but they\u0026apos;re close enough that it\u0026apos;s easy to read if you like NASM syntax.)\u0026lt;/p\u0026gt;\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;(gdb)  set disassembly-flavor intel\n(gdb)  layout reg\n(gdb)  b  after_setup\n(gdb)  r\n(gdb)  si                     # step instruction\n    press return to repeat the last command, keep stepping\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;Press control-L when gdb\u0026apos;s TUI mode gets messed up.  This happens easily, even when programs don\u0026apos;t print to stdout themselves.\u0026lt;/p\u0026gt;\n    "],"id":608,"title":"What happens if you use the 32-bit int 0x80 Linux ABI in 64-bit code?","content":"\n                \n\u0026lt;p\u0026gt;\u0026lt;code\u0026gt;int 0x80\u0026lt;/code\u0026gt; on Linux always invokes the 32-bit ABI, regardless of what mode it\u0026apos;s called from:  args in \u0026lt;code\u0026gt;ebx\u0026lt;/code\u0026gt;, \u0026lt;code\u0026gt;ecx\u0026lt;/code\u0026gt;, ... and syscall numbers from \u0026lt;code\u0026gt;/usr/include/asm/unistd_32.h\u0026lt;/code\u0026gt;.   (Or crashes on 64-bit kernels compiled without \u0026lt;code\u0026gt;CONFIG_IA32_EMULATION\u0026lt;/code\u0026gt;).\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;64-bit code should use \u0026lt;code\u0026gt;syscall\u0026lt;/code\u0026gt;\u0026lt;/strong\u0026gt;, with call numbers from \u0026lt;code\u0026gt;/usr/include/asm/unistd_64.h\u0026lt;/code\u0026gt;, and args in \u0026lt;code\u0026gt;rdi\u0026lt;/code\u0026gt;, \u0026lt;code\u0026gt;rsi\u0026lt;/code\u0026gt;, etc.  See \u0026lt;a href=\u0026quot;https://stackoverflow.com/questions/2535989/what-are-the-calling-conventions-for-unix-linux-system-calls-on-x86-64\u0026quot;\u0026gt;What are the calling conventions for UNIX \u0026amp;amp; Linux system calls on i386 and x86-64\u0026lt;/a\u0026gt;.  If your question was marked a duplicate of this, \u0026lt;strong\u0026gt;see that link for details on how you \u0026lt;em\u0026gt;should\u0026lt;/em\u0026gt; make system calls in 32 or 64-bit code.\u0026lt;/strong\u0026gt;  If you want to understand what exactly happened, keep reading.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;(For an example of 32-bit vs. 64-bit \u0026lt;code\u0026gt;sys_write\u0026lt;/code\u0026gt;, see \u0026lt;a href=\u0026quot;https://stackoverflow.com/questions/22503944/using-interrupt-0x80-on-64-bit-linux\u0026quot;\u0026gt;Using interrupt 0x80 on 64-bit Linux\u0026lt;/a\u0026gt;)\u0026lt;/p\u0026gt;\n\n\u0026lt;hr\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;code\u0026gt;syscall\u0026lt;/code\u0026gt; system calls are faster than \u0026lt;code\u0026gt;int 0x80\u0026lt;/code\u0026gt; system calls, so use native 64-bit \u0026lt;code\u0026gt;syscall\u0026lt;/code\u0026gt; unless you\u0026apos;re writing polyglot machine code that runs the same when executed as 32 or 64 bit.  (\u0026lt;code\u0026gt;sysenter\u0026lt;/code\u0026gt; always returns in 32-bit mode, so it\u0026apos;s not useful from 64-bit userspace, although it is a valid x86-64 instruction.)\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Related: \u0026lt;a href=\u0026quot;https://blog.packagecloud.io/eng/2016/04/05/the-definitive-guide-to-linux-system-calls/\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;\u0026lt;strong\u0026gt;The Definitive Guide to Linux System Calls\u0026lt;/strong\u0026gt; (on x86)\u0026lt;/a\u0026gt; for how to make \u0026lt;code\u0026gt;int 0x80\u0026lt;/code\u0026gt; or \u0026lt;code\u0026gt;sysenter\u0026lt;/code\u0026gt; 32-bit system calls, or \u0026lt;code\u0026gt;syscall\u0026lt;/code\u0026gt; 64-bit system calls, or calling the vDSO for \u0026quot;virtual\u0026quot; system calls like \u0026lt;code\u0026gt;gettimeofday\u0026lt;/code\u0026gt;.  Plus background on what system calls are all about.\u0026lt;/p\u0026gt;\n\n\u0026lt;hr\u0026gt;\n\n\u0026lt;p\u0026gt;Using \u0026lt;code\u0026gt;int 0x80\u0026lt;/code\u0026gt; makes it possible to write something that will assemble in 32 or 64-bit mode, so it\u0026apos;s handy for an \u0026lt;code\u0026gt;exit_group()\u0026lt;/code\u0026gt; at the end of a microbenchmark or something.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Current PDFs of the official i386 and x86-64 System V psABI documents that standardize function and syscall calling conventions are linked from \u0026lt;a href=\u0026quot;https://github.com/hjl-tools/x86-psABI/wiki/X86-psABI\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;https://github.com/hjl-tools/x86-psABI/wiki/X86-psABI\u0026lt;/a\u0026gt;.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;See the \u0026lt;a href=\u0026quot;/questions/tagged/x86\u0026quot; class=\u0026quot;post-tag\u0026quot; title=\u0026quot;show questions tagged \u0026apos;x86\u0026apos;\u0026quot; rel=\u0026quot;tag\u0026quot;\u0026gt;x86\u0026lt;/a\u0026gt; tag \u0026lt;a href=\u0026quot;https://stackoverflow.com/tags/x86/info\u0026quot;\u0026gt;wiki\u0026lt;/a\u0026gt; for beginner guides, x86 manuals, official documentation, and performance optimization guides / resources.\u0026lt;/p\u0026gt;\n\n\u0026lt;hr\u0026gt;\n\n\u0026lt;p\u0026gt;But since people keep posting questions with code that uses \u0026lt;a href=\u0026quot;https://stackoverflow.com/questions/14033028/sys-read-syscall-vs-int-0x80-in-gnu-assembler\u0026quot;\u0026gt;\u0026lt;code\u0026gt;int 0x80\u0026lt;/code\u0026gt; in 64-bit code\u0026lt;/a\u0026gt;, or accidentally \u0026lt;a href=\u0026quot;https://stackoverflow.com/questions/36861903/assembling-32-bit-binaries-on-a-64-bit-system-gnu-toolchain\u0026quot;\u0026gt;building 64-bit binaries\u0026lt;/a\u0026gt; from source written for 32-bit, I wonder \u0026lt;strong\u0026gt;what \u0026lt;em\u0026gt;exactly\u0026lt;/em\u0026gt; does happen on current Linux?\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Does \u0026lt;code\u0026gt;int 0x80\u0026lt;/code\u0026gt; save/restore all the 64-bit registers?  Does it truncate any registers to 32-bit?  What happens if you pass pointer args that have non-zero upper halves?\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Does it work if you pass it 32-bit pointers?\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n    ","slug":"what-happens-if-you-use-the-32-bit-int-0x80-linux-abi-in-64-bit-code-1657388560485","postType":"QUESTION","createdAt":"2022-07-09T17:42:40.000Z","updatedAt":"2022-07-09T17:42:40.000Z","tags":[{"id":2877,"name":"x86-64","slug":"x86-64","createdAt":"2022-07-09T17:42:40.000Z","updatedAt":"2022-07-09T17:42:40.000Z","Questions_Tags":{"questionId":608,"tagId":2877}},{"id":2878,"name":"system-calls","slug":"system-calls","createdAt":"2022-07-09T17:42:40.000Z","updatedAt":"2022-07-09T17:42:40.000Z","Questions_Tags":{"questionId":608,"tagId":2878}},{"id":2879,"name":"abi","slug":"abi","createdAt":"2022-07-09T17:42:40.000Z","updatedAt":"2022-07-09T17:42:40.000Z","Questions_Tags":{"questionId":608,"tagId":2879}}],"relatedQuestions":[{"title":"What happens if you use the 32-bit int 0x80 Linux ABI in 64-bit code?","slug":"what-happens-if-you-use-the-32-bit-int-0x80-linux-abi-in-64-bit-code-1657388560485","tags":[{"name":"x86-64","Questions_Tags":{"questionId":608,"tagId":2877}},{"name":"system-calls","Questions_Tags":{"questionId":608,"tagId":2878}},{"name":"abi","Questions_Tags":{"questionId":608,"tagId":2879}}]}]},"randomQuestions":[{"title":"Using async/await with a forEach loop","slug":"using-asyncawait-with-a-foreach-loop-1657384512667"},{"title":"Are 'Arrow Functions' and 'Functions' equivalent / interchangeable?","slug":"are-'arrow-functions'-and-'functions'-equivalent-interchangeable-1657384527873"},{"title":"How do I make a flat list out of a list of lists?","slug":"how-do-i-make-a-flat-list-out-of-a-list-of-lists-1657384500439"},{"title":"What does it mean to \"program to an interface\"?","slug":"what-does-it-mean-to-\"program-to-an-interface\"-1657384671665"},{"title":"MySQL pivot row into dynamic number of columns","slug":"mysql-pivot-row-into-dynamic-number-of-columns-1657387981930"},{"title":"How to remove \"noise\" from GCC/clang assembly output?","slug":"how-to-remove-\"noise\"-from-gccclang-assembly-output-1657387612391"},{"title":"Servlet returns \"HTTP Status 404 The requested resource (/servlet) is not available\"","slug":"servlet-returns-\"http-status-404-the-requested-resource-(servlet)-is-not-available\"-1657384850661"},{"title":"Why do I need to override the equals and hashCode methods in Java?","slug":"why-do-i-need-to-override-the-equals-and-hashcode-methods-in-java-1657388359877"},{"title":"How do I attach events to dynamic HTML elements with jQuery? [duplicate]","slug":"how-do-i-attach-events-to-dynamic-html-elements-with-jquery-duplicate-1657387992964"},{"title":"What is an efficient way to implement a singleton pattern in Java? [closed]","slug":"what-is-an-efficient-way-to-implement-a-singleton-pattern-in-java-closed-1657387970474"},{"title":"What do 'lazy' and 'greedy' mean in the context of regular expressions?","slug":"what-do-'lazy'-and-'greedy'-mean-in-the-context-of-regular-expressions-1657388200552"},{"title":"Selecting and manipulating CSS pseudo-elements such as ::before and ::after using javascript (or jQuery)","slug":"selecting-and-manipulating-css-pseudo-elements-such-as-::before-and-::after-using-javascript-(or-jquery)-1657387406132"},{"title":"What is move semantics?","slug":"what-is-move-semantics-1657387702625"},{"title":"How do I detect a click outside an element?","slug":"how-do-i-detect-a-click-outside-an-element-1657387505351"},{"title":"Why don't flex items shrink past content size?","slug":"why-don't-flex-items-shrink-past-content-size-1657384687282"},{"title":"How to filter Pandas dataframe using 'in' and 'not in' like in SQL","slug":"how-to-filter-pandas-dataframe-using-'in'-and-'not-in'-like-in-sql-1657387371355"},{"title":"What does if __name__ == \"__main__\": do?","slug":"what-does-if-__name__-\"__main__\":-do-1657384825815"},{"title":"Default constructor with empty brackets","slug":"default-constructor-with-empty-brackets-1657388246967"},{"title":"Dynamic tabs with user-click chosen components","slug":"dynamic-tabs-with-user-click-chosen-components-1657388465232"},{"title":"How do I use extern to share variables between source files?","slug":"how-do-i-use-extern-to-share-variables-between-source-files-1657387453605"}]},"__N_SSG":true},"page":"/questions/[slug]","query":{"slug":"what-happens-if-you-use-the-32-bit-int-0x80-linux-abi-in-64-bit-code-1657388560485"},"buildId":"6ctJfCympFH_chh5mjicD","isFallback":false,"gsp":true,"locale":"en","locales":["en"],"defaultLocale":"en","scriptLoader":[]}</script></body></html>