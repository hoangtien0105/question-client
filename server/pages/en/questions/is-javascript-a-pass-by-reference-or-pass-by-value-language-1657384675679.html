<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><meta name="twitter:card" content="summary_large_image"/><meta name="twitter:site" content="@solutionschecker.com"/><meta name="twitter:creator" content="@solutionschecker.com"/><meta property="og:url" content="https://solutionschecker.com"/><meta property="og:type" content="website"/><meta property="og:image" content="https://solutionschecker.com/solutions-checker-banner.png"/><meta property="og:image:alt" content="Find the solution to any question. We focus on finding the fastest possible solution for users. Main topics like coding, learning. - solutionschecker.com"/><link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png"/><link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png"/><link rel="manifest" href="/site.webmanifest"/><script type="application/ld+json">{"@context":"https://schema.org","@type":"Organization","logo":"/logo.svg","url":"https://solutionschecker.com"}</script><link name="keywords" content="solutions checker, solution checker, how to, solution for, check for solution, resolve question, what is, what solution for, find solution"/><script type="application/ld+json">{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"item":{"@id":"https://solutionschecker.com","name":"Home"}},{"@type":"ListItem","position":2,"item":{"@id":"https://solutionschecker.com/questions","name":"Questions"}},{"@type":"ListItem","position":3,"item":{"@id":"https://solutionschecker.com/questions/is-javascript-a-pass-by-reference-or-pass-by-value-language-1657384675679","name":"Questions"}}]}</script><title>Is JavaScript a pass-by-reference or pass-by-value language? | Solution Checker</title><meta name="robots" content="index,follow"/><meta name="description" content="The primitive types (number, string, etc.) are passed by value, but objects are unknown, because they can be both passed-by-value (in case we consider that a variable holding an object is in fact a reference to the object) and passed-by-reference (when we consider that the variable to the object holds the object itself).

Although it doesn&#x27;t really matter at the end, I want to know what is the correct way to present the arguments passing conventions. Is there an excerpt from JavaScript specification, which defines what should be the semantics regarding this?
    "/><meta property="og:title" content="Is JavaScript a pass-by-reference or pass-by-value language? | Solution Checker"/><meta property="og:description" content="The primitive types (number, string, etc.) are passed by value, but objects are unknown, because they can be both passed-by-value (in case we consider that a variable holding an object is in fact a reference to the object) and passed-by-reference (when we consider that the variable to the object holds the object itself).

Although it doesn&#x27;t really matter at the end, I want to know what is the correct way to present the arguments passing conventions. Is there an excerpt from JavaScript specification, which defines what should be the semantics regarding this?
    "/><script type="application/ld+json">{"@context":"https://schema.org","@type":"QAPage","mainEntity":{"name":"Is JavaScript a pass-by-reference or pass-by-value language?","text":"The primitive types (number, string, etc.) are passed by value, but objects are unknown, because they can be both passed-by-value (in case we consider that a variable holding an object is in fact a reference to the object) and passed-by-reference (when we consider that the variable to the object holds the object itself).\n\nAlthough it doesn&apos;t really matter at the end, I want to know what is the correct way to present the arguments passing conventions. Is there an excerpt from JavaScript specification, which defines what should be the semantics regarding this?\n    ","answerCount":30,"upVoteCount":500,"suggestedAnswer":[{"text":"It&apos;s interesting in JavaScript. Consider this example:\n\n\nfunction changeStuff(a, b, c)\n{\n  a = a * 10;\n  b.item = &quot;changed&quot;;\n  c = {item: &quot;changed&quot;};\n}\n\nvar num = 10;\nvar obj1 = {item: &quot;unchanged&quot;};\nvar obj2 = {item: &quot;unchanged&quot;};\n\nchangeStuff(num, obj1, obj2);\n\nconsole.log(num);\nconsole.log(obj1.item);\nconsole.log(obj2.item);\n Run code snippetHide resultsExpand snippet\n\n\nThis produces the output:\n10\nchanged\nunchanged\n\n\nIf obj1 was not a reference at all, then changing obj1.item would have no effect on the obj1 outside of the function.\nIf the argument was a proper reference, then everything would have changed. num would be 100, and obj2.item would read &quot;changed&quot;. Instead, num stays 10 and obj2.item remains &quot;unchanged&quot;.\n\nInstead, the situation is that the item passed in is passed by value. But the item that is passed by value is itself a reference.\nTechnically, this is called call-by-sharing.\nIn practical terms, this means that if you change the parameter itself (as with num and obj2), that won&apos;t affect the item that was fed into the parameter. But if you change the internals of the parameter, that will propagate back up (as with obj1).\n    ","url":"/questions/[slug]#solution1","@type":"Answer","upvoteCount":0},{"text":"It&apos;s always pass by value, but for objects the value of the variable is a reference.  Because of this, when you pass an object and change its members, those changes persist outside of the function.  This makes it look like pass by reference.  But if you actually change the value of the object variable you will see that the change does not persist, proving it&apos;s really pass by value.\n\nExample:\n\n\n\nfunction changeObject(x) {\n  x = { member: &quot;bar&quot; };\n  console.log(&quot;in changeObject: &quot; + x.member);\n}\n\nfunction changeMember(x) {\n  x.member = &quot;bar&quot;;\n  console.log(&quot;in changeMember: &quot; + x.member);\n}\n\nvar x = { member: &quot;foo&quot; };\n\nconsole.log(&quot;before changeObject: &quot; + x.member);\nchangeObject(x);\nconsole.log(&quot;after changeObject: &quot; + x.member); /* change did not persist */\n\nconsole.log(&quot;before changeMember: &quot; + x.member);\nchangeMember(x);\nconsole.log(&quot;after changeMember: &quot; + x.member); /* change persists */\n Run code snippetHide resultsExpand snippet\n\n\n\nOutput:\n\nbefore changeObject: foo\nin changeObject: bar\nafter changeObject: foo\n\nbefore changeMember: foo\nin changeMember: bar\nafter changeMember: bar\n\n    ","url":"/questions/[slug]#solution2","@type":"Answer","upvoteCount":0},{"text":"The variable doesn&apos;t &quot;hold&quot; the object; it holds a reference. You can assign that reference to another variable, and now both reference the same object. It&apos;s always pass by value (even when that value is a reference...).\n\nThere&apos;s no way to alter the value held by a variable passed as a parameter, which would be possible if JavaScript supported passing by reference.\n    ","url":"/questions/[slug]#solution3","@type":"Answer","upvoteCount":0},{"text":"My two cents... This is the way I understand it. (Feel free to correct me if I&apos;m wrong)\nIt&apos;s time to throw out everything you know about pass by value / reference.\nBecause in JavaScript, it doesn&apos;t matter whether it&apos;s passed by value or by reference or whatever.\nWhat matters is mutation vs assignment of the parameters passed into a function.\nOK, let me do my best to explain what I mean. Let&apos;s say you have a few objects.\nvar object1 = {};\nvar object2 = {};\n\nWhat we have done is &quot;assignment&quot;... We&apos;ve assigned 2 separate empty objects to the variables &quot;object1&quot; and &quot;object2&quot;.\nNow, let&apos;s say that we like object1 better... So, we &quot;assign&quot; a new variable.\nvar favoriteObject = object1;\n\nNext, for whatever reason, we decide that we like object 2 better. So, we do a little re-assignment.\nfavoriteObject = object2;\n\nNothing happened to object1 or to object2. We haven&apos;t changed any data at all. All we did was re-assign what our favorite object is. It is important to know that object2 and favoriteObject are both assigned to the same object. We can change that object via either of those variables.\nobject2.name = &apos;Fred&apos;;\nconsole.log(favoriteObject.name) // Logs Fred\nfavoriteObject.name = &apos;Joe&apos;;\nconsole.log(object2.name); // Logs Joe\n\nOK, now let&apos;s look at primitives like strings for example\nvar string1 = &apos;Hello world&apos;;\nvar string2 = &apos;Goodbye world&apos;;\n\nAgain, we pick a favorite.\nvar favoriteString = string1;\n\nBoth our favoriteString and string1 variables are assigned to &apos;Hello world&apos;. Now, what if we want to change our favoriteString??? What will happen???\nfavoriteString = &apos;Hello everyone&apos;;\nconsole.log(favoriteString); // Logs &apos;Hello everyone&apos;\nconsole.log(string1); // Logs &apos;Hello world&apos;\n\nUh oh.... What has happened. We couldn&apos;t change string1 by changing favoriteString... Why?? Because we didn&apos;t change our string object. All we did was &quot;RE ASSIGN&quot; the favoriteString variable to a new string. This essentially disconnected it from string1. In the previous example, when we renamed our object, we didn&apos;t assign anything. (Well, not to the variable itself, ... we did, however, assign the name property to a new string.) Instead, we mutated the object which keeps the connections between the 2 variables and the underlying objects. (Even if we had wanted to modify or mutate the string object itself, we couldn&apos;t have, because strings are actually immutable in JavaScript.)\nNow, on to functions and passing parameters.... When you call a function, and pass a parameter, what you are essentially doing is an &quot;assignment&quot; to a new variable, and it works exactly the same as if you assigned using the equal (=) sign.\nTake these examples.\nvar myString = &apos;hello&apos;;\n\n// Assign to a new variable (just like when you pass to a function)\nvar param1 = myString;\nparam1 = &apos;world&apos;; // Re assignment\n\nconsole.log(myString); // Logs &apos;hello&apos;\nconsole.log(param1);   // Logs &apos;world&apos;\n\nNow, the same thing, but with a function\nfunction myFunc(param1) {\n    param1 = &apos;world&apos;;\n\n    console.log(param1);   // Logs &apos;world&apos;\n}\n\nvar myString = &apos;hello&apos;;\n// Calls myFunc and assigns param1 to myString just like param1 = myString\nmyFunc(myString);\n\nconsole.log(myString); // logs &apos;hello&apos;\n\nOK, now lets give a few examples using objects instead... first, without the function.\nvar myObject = {\n    firstName: &apos;Joe&apos;,\n    lastName: &apos;Smith&apos;\n};\n\n// Assign to a new variable (just like when you pass to a function)\nvar otherObj = myObject;\n\n// Let&apos;s mutate our object\notherObj.firstName = &apos;Sue&apos;; // I guess Joe decided to be a girl\n\nconsole.log(myObject.firstName); // Logs &apos;Sue&apos;\nconsole.log(otherObj.firstName); // Logs &apos;Sue&apos;\n\n// Now, let&apos;s reassign the variable\notherObj = {\n    firstName: &apos;Jack&apos;,\n    lastName: &apos;Frost&apos;\n};\n\n// Now, otherObj and myObject are assigned to 2 very different objects\n// And mutating one object has no influence on the other\nconsole.log(myObject.firstName); // Logs &apos;Sue&apos;\nconsole.log(otherObj.firstName); // Logs &apos;Jack&apos;;\n\nNow, the same thing, but with a function call\nfunction myFunc(otherObj) {\n\n    // Let&apos;s mutate our object\n    otherObj.firstName = &apos;Sue&apos;;\n    console.log(otherObj.firstName); // Logs &apos;Sue&apos;\n\n    // Now let&apos;s re-assign\n    otherObj = {\n        firstName: &apos;Jack&apos;,\n        lastName: &apos;Frost&apos;\n    };\n    console.log(otherObj.firstName); // Logs &apos;Jack&apos;\n\n    // Again, otherObj and myObject are assigned to 2 very different objects\n    // And mutating one object doesn&apos;t magically mutate the other\n}\n\nvar myObject = {\n    firstName: &apos;Joe&apos;,\n    lastName: &apos;Smith&apos;\n};\n\n// Calls myFunc and assigns otherObj to myObject just like otherObj = myObject\nmyFunc(myObject);\n\nconsole.log(myObject.firstName); // Logs &apos;Sue&apos;, just like before\n\nOK, if you read through this entire post, perhaps you now have a better understanding of how function calls work in JavaScript. It doesn&apos;t matter whether something is passed by reference or by value... What matters is assignment vs mutation.\nEvery time you pass a variable to a function, you are &quot;Assigning&quot; to whatever the name of the parameter variable is, just like if you used the equal (=) sign.\nAlways remember that the equals sign (=) means assignment.\nAlways remember that passing a parameter to a function in JavaScript also means assignment.\nThey are the same and the 2 variables are connected in exactly the same way (which is to say they aren&apos;t, unless you count that they are assigned to the same object).\nThe only time that &quot;modifying a variable&quot; affects a different variable is when the underlying object is mutated (in which case you haven&apos;t modified the variable, but the object itself.\nThere is no point in making a distinction between objects and primitives, because it works the same exact way as if you didn&apos;t have a function and just used the equal sign to assign to a new variable.\nThe only gotcha is when the name of the variable you pass into the function is the same as the name of the function parameter. When this happens, you have to treat the parameter inside the function as if it was a whole new variable private to the function (because it is)\nfunction myFunc(myString) {\n    // myString is private and does not affect the outer variable\n    myString = &apos;hello&apos;;\n}\n\nvar myString = &apos;test&apos;;\nmyString = myString; // Does nothing, myString is still &apos;test&apos;;\n\nmyFunc(myString);\nconsole.log(myString); // Logs &apos;test&apos;\n\n    ","url":"/questions/[slug]#solution4","@type":"Answer","upvoteCount":0},{"text":"These phrases/concepts were originally defined long before JS was created and they don&apos;t accurately describe the semantics for javascript. I think trying to apply them to JS causes more confusion than not.\nSo don&apos;t get hung up on &quot;pass by reference/value&quot;.\nConsider the following:\n\nVariables are pointers to values.\nReassigning a variable merely points that pointer at a new value.\nReassigning a variable will never affect other variables that were pointing at that same object because each variable has its own pointer.\n\nSo if I had to give it a name I&apos;d say &quot;pass-by-pointer&quot; -- we don&apos;t deal with pointers in JS but the underlying engine does.\n\n// code\nvar obj = {\n    name: &apos;Fred&apos;,\n    num: 1\n};\n\n// illustration\n               &apos;Fred&apos;\n              /\n             /\n(obj) ---- {}\n             \\\n              \\\n               1\n\n\n// code\nobj.name = &apos;George&apos;;\n\n\n// illustration\n                 &apos;Fred&apos;\n\n\n(obj) ---- {} ----- &apos;George&apos;\n             \\\n              \\\n               1\n\n\n// code\nobj = {};\n\n// illustration\n                 &apos;Fred&apos;\n\n\n(obj)      {} ----- &apos;George&apos;\n  |          \\\n  |           \\\n { }            1\n\n\n// code\nvar obj = {\n    text: &apos;Hello world!&apos;\n};\n\n/* function parameters get their own pointer to \n * the arguments that are passed in, just like any other variable */\nsomeFunc(obj);\n\n\n// illustration\n(caller scope)        (someFunc scope)\n           \\             /\n            \\           /\n             \\         /\n              \\       /\n               \\     /\n                 { }\n                  |\n                  |\n                  |\n            &apos;Hello world&apos;\n\nSome final comments:\n\nThe phrases &quot;pass by value/reference&quot; are only used to describe the behavior of a language, not necessarily the actual underlying implementation. As a result of this abstraction, critical details that are essential for a decent explanation are lost, which inevitably leads to the current situation where a single term doesn&apos;t adequately describe the actual behavior without additional info.\nIt&apos;s tempting to think that primitives are enforced by special rules while objects are not, but primitives are simply the end of the pointer chain.\nAs a final example, consider why a common attempt to clear an array doesn&apos;t work as expected.\n\n\n\nvar a = [1, 2];\nvar b = a;\n\na = [];\nconsole.log(b); // [1,2]\n// doesn&apos;t work because `b` is still pointing at the original array\n Run code snippetHide resultsExpand snippet\n\n\n    ","url":"/questions/[slug]#solution5","@type":"Answer","upvoteCount":0},{"text":"An object outside a function is passed into a function by giving a reference to the outside object.\n\nWhen you use that reference to manipulate its object, the object outside is thus affected. However, if inside the function you decided to point the reference to something else, you did not affect the object outside at all, because all you did was re-direct the reference to something else. \n    ","url":"/questions/[slug]#solution6","@type":"Answer","upvoteCount":0},{"text":"Think of it like this: It&apos;s always pass by value. However, the value of an object is not the object itself, but a reference to that object. \n\nHere is an example, passing a number (a primitive type)\n\nfunction changePrimitive(val) {\n    // At this point there are two &apos;10&apos;s in memory.\n    // Changing one won&apos;t affect the other\n    val = val * 10;\n}\nvar x = 10;\nchangePrimitive(x);\n// x === 10\n\n\nRepeating this with an object yields different results:\n\nfunction changeObject(obj) {\n    // At this point there are two references (x and obj) in memory,\n    // but these both point to the same object.\n    // changing the object will change the underlying object that\n    // x and obj both hold a reference to.\n    obj.val = obj.val * 10;\n}\nvar x = { val: 10 };\nchangeObject(x);\n// x === { val: 100 }\n\n\nOne more example:\n\nfunction changeObject(obj) {\n    // Again there are two references (x and obj) in memory,\n    // these both point to the same object.\n    // now we create a completely new object and assign it.\n    // obj&apos;s reference now points to the new object.\n    // x&apos;s reference doesn&apos;t change.\n    obj = { val: 100 };\n}\nvar x = { val: 10 };\nchangeObject(x);\n// x === { val: 10}\n\n    ","url":"/questions/[slug]#solution7","@type":"Answer","upvoteCount":0},{"text":"A very detailed explanation about copying, passing and comparing by value and by reference is in this chapter of the &quot;JavaScript: The Definitive Guide&quot; book.\n\nBefore we leave the topic of\nmanipulating objects and arrays by\nreference, we need to clear up a point\nof nomenclature.\nThe phrase &quot;pass by\nreference&quot; can have several meanings.\nTo some readers, the phrase refers to\na function invocation technique that\nallows a function to assign new values\nto its arguments and to have those\nmodified values visible outside the\nfunction. This is not the way the term\nis used in this book.\nHere, we mean\nsimply that a reference to an object\nor array -- not the object itself --\nis passed to a function. A function\ncan use the reference to modify\nproperties of the object or elements\nof the array. But if the function\noverwrites the reference with a\nreference to a new object or array,\nthat modification is not visible\noutside of the function.\nReaders\nfamiliar with the other meaning of\nthis term may prefer to say that\nobjects and arrays are passed by\nvalue, but the value that is passed is\nactually a reference rather than the\nobject itself.\n\n    ","url":"/questions/[slug]#solution8","@type":"Answer","upvoteCount":0},{"text":"JavaScript is always pass-by-value; everything is of value type.\nObjects are values, and member functions of objects are values themselves (remember that functions are first-class objects in JavaScript). Also, regarding the concept that everything in JavaScript is an object; this is wrong. Strings, symbols, numbers, booleans, nulls, and undefineds are primitives.\nOn occasion they can leverage some member functions and properties inherited from their base prototypes, but this is only for convenience. It does not mean that they are objects themselves. Try the following for reference:\n\n\nx = &quot;test&quot;;\nconsole.log(x.foo);\nx.foo = 12;\nconsole.log(x.foo);\n Run code snippetHide resultsExpand snippet\n\n\nIn both console.log you will find the value to be undefined.\n    ","url":"/questions/[slug]#solution9","@type":"Answer","upvoteCount":0},{"text":"In JavaScript, the type of the value solely controls whether that value will be assigned by value-copy or by reference-copy. \n\nPrimitive values are always assigned/passed by value-copy: \n\n\nnull\nundefined\nstring\nnumber\nboolean\nsymbol in ES6\n\n\nCompound values are always assigned/passed by reference-copy\n\n\nobjects \narrays\nfunction\n\n\nFor example\n\nvar a = 2;\nvar b = a; // `b` is always a copy of the value in `a`\nb++;\na; // 2\nb; // 3\n\nvar c = [1,2,3];\nvar d = c; // `d` is a reference to the shared `[1,2,3]` value\nd.push( 4 );\nc; // [1,2,3,4]\nd; // [1,2,3,4]\n\n\nIn the above snippet, because 2 is a scalar primitive, a holds one initial copy of that value, and b is assigned another copy of the value. When changing b, you are in no way changing the value in a.\n\nBut both c and d are separate references to the same shared value [1,2,3], which is a compound value. It&apos;s important to note that neither c nor d more &quot;owns&quot; the [1,2,3] value -- both are just equal peer references to the value. So, when using either reference to modify (.push(4)) the actual shared array value itself, it&apos;s affecting just the one shared value, and both references will reference the newly modified value [1,2,3,4].\n\nvar a = [1,2,3];\nvar b = a;\na; // [1,2,3]\nb; // [1,2,3]\n\n// later\nb = [4,5,6];\na; // [1,2,3]\nb; // [4,5,6]\n\n\nWhen we make the assignment b = [4,5,6], we are doing absolutely nothing to affect where a is still referencing ([1,2,3]). To do that, b would have to be a pointer to a rather than a reference to the array -- but no such capability exists in JS!\n\nfunction foo(x) {\n    x.push( 4 );\n    x; // [1,2,3,4]\n\n    // later\n    x = [4,5,6];\n    x.push( 7 );\n    x; // [4,5,6,7]\n}\n\nvar a = [1,2,3];\n\nfoo( a );\n\na; // [1,2,3,4]  not  [4,5,6,7]\n\n\nWhen we pass in the argument a, it assigns a copy of the a reference to x. x and a are separate references pointing at the same [1,2,3] value. Now, inside the function, we can use that reference to mutate the value itself (push(4)). But when we make the assignment x = [4,5,6], this is in no way affecting where the initial reference a is pointing -- still points at the (now modified) [1,2,3,4] value.\n\nTo effectively pass a compound value (like an array) by value-copy, you need to manually make a copy of it, so that the reference passed doesn&apos;t still point to the original. For example:\n\nfoo( a.slice() );\n\n\nCompound value (object, array, etc) that can be passed by reference-copy\n\nfunction foo(wrapper) {\n    wrapper.a = 42;\n}\n\nvar obj = {\n    a: 2\n};\n\nfoo( obj );\n\nobj.a; // 42\n\n\nHere, obj acts as a wrapper for the scalar primitive property a. When passed to foo(..), a copy of the obj reference is passed in and set to the wrapperparameter. We now can use the wrapper reference to access the shared object, and update its property. After the function finishes, obj.a will see the updated value 42.\n\nSource\n    ","url":"/questions/[slug]#solution10","@type":"Answer","upvoteCount":0},{"text":"well, it&apos;s about &apos;performance&apos; and &apos;speed&apos; and in the simple word &apos;memory management&apos; in a programming language.\nin javascript we can put values in two layer: type1-objects and type2-all other types of value such as string &amp; boolean &amp; etc\nif you imagine memory as below squares which in every one of them just one type2-value can be saved:\n\nevery type2-value (green) is a single square while a type1-value (blue) is a group of them:\n\nthe point is that if you want to indicate a type2-value, the address is plain but if you want to do the same thing for type1-value that&apos;s not easy at all! :\n\nand in a more complicated story:\n\nso here references can rescue us:\n\n\nwhile the green arrow here is a typical variable, the purple one is an object variable, so because the green arrow(typical variable) has just one task (and that is indicating a typical value) we don&apos;t need to separate it&apos;s value from it so we move the green arrow with the value of that wherever it goes and in all assignments, functions and so on ...\nbut we cant do the same thing with the purple arrow, we may want to move &apos;john&apos; cell here or many other things..., so the purple arrow will stick to its place and just typical arrows that were assigned to it will move ...\na very confusing situation is where you can&apos;t realize how your referenced variable changes, let&apos;s take a look at a very good example:\nlet arr = [1, 2, 3, 4, 5]; //arr is an object now and a purple arrow is indicating it\nlet obj2 = arr; // now, obj2 is another purple arrow that is indicating the value of arr obj\nlet obj3 = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;];\nobj2.push(6); // first pic below - making a new hand for the blue circle to point the 6\n//obj2 = [1, 2, 3, 4, 5, 6]\n//arr = [1, 2, 3, 4, 5, 6]\n//we changed the blue circle object value (type1-value) and due to arr and obj2 are indicating that so both of them changed\nobj2 = obj3; //next pic below - changing the direction of obj2 array from blue circle to orange circle so obj2 is no more [1,2,3,4,5,6] and it&apos;s no more about changing anything in it but we completely changed its direction and now obj2 is pointing to obj3\n//obj2 = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;];\n//obj3 = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;];\n\n\n\n    ","url":"/questions/[slug]#solution11","@type":"Answer","upvoteCount":0},{"text":"This is little more explanation for pass by value and pass by reference (JavaScript). In this concept, they are talking about passing the variable by reference and passing the variable by reference.\n\nPass by value (primitive type)\n\nvar a = 3;\nvar b = a;\n\nconsole.log(a); // a = 3\nconsole.log(b); // b = 3\n\na=4;\nconsole.log(a); // a = 4\nconsole.log(b); // b = 3\n\n\n\napplies to all primitive type in JavaScript (string, number, Boolean, undefined, and null).\na is allocated a memory (say 0x001) and b creates a copy of the value in memory (say 0x002).\nSo changing the value of a variable doesn&apos;t affect the other, as they both reside in two different locations.\n\n\n\n\nPass by reference (objects)\n\nvar c = { &quot;name&quot; : &quot;john&quot; };\nvar d = c;\n\nconsole.log(c); // { &quot;name&quot; : &quot;john&quot; }\nconsole.log(d); // { &quot;name&quot; : &quot;john&quot; }\n\nc.name = &quot;doe&quot;;\n\nconsole.log(c); // { &quot;name&quot; : &quot;doe&quot; }\nconsole.log(d); // { &quot;name&quot; : &quot;doe&quot; }\n\n\n\nThe JavaScript engine assigns the object to the variable c, and it points to some memory, say (0x012).\nWhen d=c, in this step d points to the same location (0x012).\nChanging the value of any changes value for both the variable.\nFunctions are objects\n\n\n\n\nSpecial case, pass by reference (objects)\n\nc = {&quot;name&quot; : &quot;jane&quot;};\nconsole.log(c); // { &quot;name&quot; : &quot;jane&quot; }\nconsole.log(d); // { &quot;name&quot; : &quot;doe&quot; }\n\n\n\nThe equal(=) operator sets up new memory space or address\n\n    ","url":"/questions/[slug]#solution12","@type":"Answer","upvoteCount":0},{"text":"Semantics!! Setting concrete definitions will necessarily make some answers and comments incompatible since they are not describing the same thing even when using the same words and phrases, but it is critical to get past the confusion (especially for new programmers).\n\nFirst of all, there are multiple levels of abstraction that not everyone seems to grasp.  Newer programmers who have learned on 4th or 5th generation languages may have difficulty wrapping their mind around concepts familiar to assembly or C programmers not phased by pointers to pointers to pointers.  Pass-by-reference does not simply mean the ability to change a referenced object using a function parameter variable.\n\nVariable: Combined concept of a symbol which references a value at a particular location in memory.  This term is usually too loaded to be used alone in discussing details.\n\nSymbol:  Text string used to refer to variable (i.e. variable&apos;s name).\n\nValue:  Particular bits stored in memory and referenced using variable&apos;s symbol.\n\nMemory location:  Where a variable&apos;s value is stored.  (The location itself is represented by a number separate from the value stored at the location.)\n\nFunction parameter:  Variable declared in a function definition, used for referencing variables passed to the function.\n\nFunction argument: Variable outside the function which is passed to the function by the caller.\n\nObject variable:  Variable whose basic underlying value is not the &quot;object&quot; itself, rather its value is a pointer (memory location value) to another location in memory where the object&apos;s actual data is stored.  In most higher-generation languages, the &quot;pointer&quot; aspect is effectively hidden by automatic de-referencing in various contexts.\n\nPrimitive variable: Variable whose value IS the actual value.  Even this concept can be complicated by auto-boxing and object-like contexts of various languages, but the general ideas is that the variable&apos;s value IS the actual value represented by the variable&apos;s symbol rather than a pointer to another memory location.\n\nFunction arguments and parameters are not the same thing.  Also, a variable&apos;s value is not the variable&apos;s object (as already pointed out by various people, but apparently ignored).  These distinctions are critical to proper understanding.\n\nPass-by-value or Call-by-sharing (for objects):  The function argument&apos;s value is COPIED to another memory location which is referenced by the function&apos;s parameter symbol (regardless of whether it&apos;s on the stack or heap).  In other words, the function parameter received a copy of the passed argument&apos;s value... AND (critical) the argument&apos;s value IS NEVER UPDATED / ALTERED / CHANGED by the calling function.  Remember, an object variable&apos;s value is NOT the object itself, rather it is the pointer to the object, so passing an object variable by value copies the pointer to the function parameter variable.  The function parameter&apos;s value points to the exact same object in memory.  The object data itself can be altered directly via the function parameter, BUT the function argument&apos;s value IS NEVER UPDATED, so it will continue to point to the same object throughout and even after the function call (even if its object&apos;s data was altered or if the function parameter is assigned a different object altogether).  It is incorrect to conclude that the function argument was passed by reference just because the referenced object is updatable via the function parameter variable.\n\nCall / Pass-by-reference:  The function argument&apos;s value can/will be updated directly by the corresponding function parameter.  If it helps, the function parameter becomes an effective &quot;alias&quot; for the argument--they effectively refer to the same value at the same memory location.  If a function argument is an object variable, the ability to change the object&apos;s data is no different than the pass-by-value case since the function parameter will still point to the same object as the argument.  But in the object variable case, if the function parameter is set to a completely different object, then the argument will likewise also point to the different object--this does not happen in the pass-by-value case.\n\nJavaScript does not pass by reference.  If you read closely, you will realize that all contrary opinions misunderstand what is meant by pass-by-value and they falsely conclude that the ability to update an object&apos;s data via the function parameter is synonymous to &quot;pass-by-value&quot;.\n\nObject clone/copy: A new object is created and the original object&apos;s data is copied.  This can be a deep copy or shallow copy, but the point is that a new object is created.  Creating a copy of an object is a separate concept from pass-by-value.  Some languages distinguish between class object and structs (or the like), and may have different behavior for passing variables of the different types.  But JavaScript does not do anything like this automatically when passing object variables.  But the absence of automatic object cloning does not translate to pass-by-reference.\n    ","url":"/questions/[slug]#solution13","@type":"Answer","upvoteCount":0},{"text":"\n  sharing what I know of references in JavaScript\n\n\nIn JavaScript, when assigning an object to a variable, the value assigned to the variable is a reference to the object:\n\n\n\nvar a = {\n  a: 1,\n  b: 2,\n  c: 3\n};\nvar b = a;\n\n// b.c is referencing to a.c value\nconsole.log(b.c) // Output: 3\n// Changing value of b.c\nb.c = 4\n// Also changes the value of a.c\nconsole.log(a.c) // Output: 4\n Run code snippetHide resultsExpand snippet\n\n\n    ","url":"/questions/[slug]#solution14","@type":"Answer","upvoteCount":0},{"text":"JavaScript passes primitive types by value and object types by reference\n\n\n  Now, people like to bicker endlessly about whether &quot;pass by reference&quot;\n  is the correct way to describe what Java et al. actually do. The point\n  is this:\n  \n  \n  Passing an object does not copy the object.\n  An object passed to a function can have its members modified by the function.\n  A primitive value passed to a function cannot be modified by the function. A copy is made.\n  \n  \n  In my book that&apos;s called passing by reference.\n\n\n Brian Bi - Which programming languages are pass by reference?\n\n\n\nUpdate\n\nHere is a rebuttal to this:\n\nThere is no &quot;pass by reference&quot; available in JavaScript.\n    ","url":"/questions/[slug]#solution15","@type":"Answer","upvoteCount":0},{"text":"Observation: If there isn&apos;t any way for an observer to examine the underlying memory of the engine, there is no way to determine whether an immutable value gets copied or a reference gets passed.\nJavaScript is more or less agnostic to the underlying memory model. There is no such thing as a reference². JavaScript has values. Two variables can hold the same value (or more accurate: two environment records can bind the same value). The only type of values that can be mutated are objects through their abstract [[Get]] and [[Set]] operations.\nIf you forget about computers and memory, this is all you need to describe JavaScript&apos;s behaviour, and it allows you to understand the specification.\n let a = { prop: 1 };\n let b = a; // a and b hold the same value\n a.prop = &quot;test&quot;; // The object gets mutated, can be observed through both a and b\n b = { prop: 2 }; // b holds now a different value\n\nNow you might ask yourself how two variables can hold the same value on a computer. You might then look into the source code of a JavaScript engine and you&apos;ll most likely find something which a programmer of the language the engine was written in would call a reference.\nSo in fact you can say that JavaScript is &quot;pass by value&quot;, whereas the value can be shared, and you can say that JavaScript is &quot;pass by reference&quot;, which might be a useful logical abstraction for programmers from low level languages, or you might call the behaviour &quot;call by sharing&quot;.\nAs there is no such thing as a reference in JavaScript, all of these are neither wrong nor on point. Therefore I don&apos;t think the answer is particularly useful to search for.\n² The term Reference in the specification is not a reference in the traditional sense. It is a container for an object and the name of a property, and it is an intermediate value (e.g., a.b evaluates to Reference { value = a, name = &quot;b&quot; }). The term reference also sometimes appears in the specification in unrelated sections.\n    ","url":"/questions/[slug]#solution16","@type":"Answer","upvoteCount":0},{"text":"Everything is passed by value.\nBasic types are passed by value (i.e. a new copy of the actual variable value is passed to the function).\nComplex types (objects) are passed as &quot;pointer to the object&quot;. So the actual stuff you are passing is a pointer which is passed by value (it&apos;s an address, a numerical value like any other). Obviously if you try to modify a property of the object inside the function, the modification will be reflected even outside of such function. That&apos;s because you are accessing the property via the pointer which points to the unique copy of the property.\nThe confusion here has arises over &quot;passing a pointer by value&quot; and &quot;passing an object by reference&quot;.\n    ","url":"/questions/[slug]#solution17","@type":"Answer","upvoteCount":0},{"text":"My simple way to understand this...\n\n\nWhen calling a function, you are passing the content (reference or\nvalue) of the argument variables, not the the variables themselves.\n\nvar var1 = 13;\nvar var2 = { prop: 2 };\n\n//13 and var2&apos;s content (reference) are being passed here\nfoo(var1, var2); \n\nInside the function, parameter variables, inVar1 and inVar2, receive the contents being passed.\n\nfunction foo(inVar1, inVar2){\n    //changing contents of inVar1 and inVar2 won&apos;t affect variables outside\n    inVar1 = 20;\n    inVar2 = { prop: 7 };\n}\n\nSince inVar2 received the reference of { prop: 2 }, you can change the value of the object&apos;s property.\n\nfunction foo(inVar1, inVar2){\n    inVar2.prop = 7; \n}\n\n\n    ","url":"/questions/[slug]#solution18","@type":"Answer","upvoteCount":0},{"text":"The MDN docs explain it clearly, without being too verbose:  \n\n\n  The parameters of a function call are the function&apos;s arguments.\n  Arguments are passed to functions by value. If the function changes\n  the value of an argument, this change is not reflected globally or in\n  the calling function. However, object references are values, too, and\n  they are special: if the function changes the referred object&apos;s\n  properties, that change is visible outside the function, (...)\n\n\nSource: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions#Description\n    ","url":"/questions/[slug]#solution19","@type":"Answer","upvoteCount":0},{"text":"Passing arguments to a function in JavaScript is analogous to passing\nparameters by pointer value in C:\n\n/*\nThe following C program demonstrates how arguments\nto JavaScript functions are passed in a way analogous\nto pass-by-pointer-value in C. The original JavaScript\ntest case by @Shog9 follows with the translation of\nthe code into C. This should make things clear to\nthose transitioning from C to JavaScript.\n\nfunction changeStuff(num, obj1, obj2)\n{\n    num = num * 10;\n    obj1.item = &quot;changed&quot;;\n    obj2 = {item: &quot;changed&quot;};\n}\n\nvar num = 10;\nvar obj1 = {item: &quot;unchanged&quot;};\nvar obj2 = {item: &quot;unchanged&quot;};\nchangeStuff(num, obj1, obj2);\nconsole.log(num);\nconsole.log(obj1.item);    \nconsole.log(obj2.item);\n\nThis produces the output:\n\n10\nchanged\nunchanged\n*/\n\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\nstruct obj {\n    char *item;\n};\n\nvoid changeStuff(int *num, struct obj *obj1, struct obj *obj2)\n{\n    // make pointer point to a new memory location\n    // holding the new integer value\n    int *old_num = num;\n    num = malloc(sizeof(int));\n    *num = *old_num * 10;\n    // make property of structure pointed to by pointer\n    // point to the new value\n    obj1-&gt;item = &quot;changed&quot;;\n    // make pointer point to a new memory location\n    // holding the new structure value\n    obj2 = malloc(sizeof(struct obj));\n    obj2-&gt;item = &quot;changed&quot;;\n    free(num); // end of scope\n    free(obj2); // end of scope\n}\n\nint num = 10;\nstruct obj obj1 = { &quot;unchanged&quot; };\nstruct obj obj2 = { &quot;unchanged&quot; };\n\nint main()\n{\n    // pass pointers by value: the pointers\n    // will be copied into the argument list\n    // of the called function and the copied\n    // pointers will point to the same values\n    // as the original pointers\n    changeStuff(&amp;num, &amp;obj1, &amp;obj2);\n    printf(&quot;%d\\n&quot;, num);\n    puts(obj1.item);\n    puts(obj2.item);\n    return 0;\n}\n\n    ","url":"/questions/[slug]#solution20","@type":"Answer","upvoteCount":0},{"text":"For programming language lawyers, I&apos;ve went through the following sections of ECMAScript 5.1 (which is easier to read than the latest edition), and go as far as asking it on the ECMAScript mailing list.\nTL;DR: Everythings&apos;re passed by value, but properties of Objects are references, and the definition of Object is creepily lacking in the standard.\nConstruction of Argument Lists\nSection 11.2.4 &quot;Argument Lists&quot; says the following on producing a argument list consisting of only 1 argument:\n\nThe production ArgumentList : AssignmentExpression is evaluated as follows:\n\nLet ref be the result of evaluating AssignmentExpression.\nLet arg be GetValue(ref).\nReturn a List whose sole item is arg.\n\n\nThe section also enumerate cases where argument list has 0 or &gt;1 arguments.\nThus, everything&apos;s are passed by reference.\nAccess of Object Properties\nSection 11.2.1 &quot;Property Accessors&quot;\n\nThe production MemberExpression : MemberExpression [ Expression ] is evaluated as follows:\n\nLet baseReference be the result of evaluating MemberExpression.\nLet baseValue be GetValue(baseReference).\nLet propertyNameReference be the result of evaluating Expression.\nLet propertyNameValue be GetValue(propertyNameReference).\nCall CheckObjectCoercible(baseValue).\nLet propertyNameString be ToString(propertyNameValue).\nIf the syntactic production that is being evaluated is contained in strict mode code, let strict be true, else let\nstrict be false.\nReturn a value of type Reference whose base value is baseValue and whose referenced name is\npropertyNameString, and whose strict mode flag is strict.\n\n\nThus, properties of Objects are always available as reference.\nOn Reference\nIt is described in section 8.7 &quot;The Reference Specification Type&quot;, that references are not real types in the language - they&apos;re only used to describe the behavior of the delete, the typeof, and the assignment operators.\nDefinition of &quot;Object&quot;\nIt is defined in 5.1 edition that &quot;An Object is a collection of properties&quot;. Therefore, we can infer, that the value of the object is the collection, but as to what is the value of the collection is poorly defined in the spec, and requires a bit of effort to understand.\n    ","url":"/questions/[slug]#solution21","@type":"Answer","upvoteCount":0},{"text":"The most succinct explanation I found was in the AirBNB style guide:\n\n\nPrimitives: When you access a primitive type you work directly on its\nvalue\n\n\nstring\nnumber\nboolean\nnull\nundefined\n\n\n\nE.g.:\n\nvar foo = 1,\n    bar = foo;\n\nbar = 9;\n\nconsole.log(foo, bar); // =&gt; 1, 9\n\n\n\nComplex: When you access a complex type you work on a reference to its value\n\n\nobject\narray\nfunction\n\n\n\nE.g.:\n\nvar foo = [1, 2],\n    bar = foo;\n\nbar[0] = 9;\n\nconsole.log(foo[0], bar[0]); // =&gt; 9, 9\n\n\nI.e. effectively primitive types are passed by value, and complex types are passed by reference.\n    ","url":"/questions/[slug]#solution22","@type":"Answer","upvoteCount":0},{"text":"I&apos;ve read through these answers multiple times, but didn&apos;t REALLY get it until I learned about the technical definition of &quot;Call by sharing&quot; as termed by Barbara Liskov\n\n\n  The semantics of call by sharing differ from call by reference in that assignments to function arguments within the function aren&apos;t visible to the caller (unlike by reference semantics)[citation needed], so e.g. if a variable was passed, it is not possible to simulate an assignment on that variable in the caller&apos;s scope. However, since the function has access to the same object as the caller (no copy is made), mutations to those objects, if the objects are mutable, within the function are visible to the caller, which may appear to differ from call by value semantics. Mutations of a mutable object within the function are visible to the caller because the object is not copied or cloned  it is shared.\n\n\nThat is, parameter references are alterable if you go and access the parameter value itself. On the other hand, assignment to a parameter will disappear after evaluation, and is non-accessible to the function caller.\n    ","url":"/questions/[slug]#solution23","@type":"Answer","upvoteCount":0},{"text":"In a low-level language, if you want to pass a variable by reference, you have to use a specific syntax in the creation of the function:\nint myAge = 14;\nincreaseAgeByRef(myAge);\nfunction increaseAgeByRef(int &amp;age) {\n  *age = *age + 1;\n}\n\nThe &amp;age is a reference to myAge, but if you want the value you have to convert the reference, using *age.\nJavaScript is a high level language that does this conversion for you.\nSo, although objects are passed by reference, the language converts the reference parameter to the value. You don&apos;t need to use &amp;, on the function definition, to pass it by reference, neither *, on the function body, to convert the reference to the value, JavaScript does it for you.\nThat&apos;s why when you try to change an object inside a function, by replacing it&apos;s value (i.e. age = {value:5}), the change doesn&apos;t persist, but if you change it&apos;s properties (i.e. age.value = 5), it does.\nLearn more\n    ","url":"/questions/[slug]#solution24","@type":"Answer","upvoteCount":0},{"text":"If you want (normal) function parameter behavior like in other languages (passing copy of a value)\nthen just clone the object before passing into a function:\nfunction run()\n{\n    var test = [];\n    test.push(1);\n\n    console.log(&apos;before: &apos;+test); // 1\n\n    changeVariable(_.clone(test)); // (Note: I am using lodash _.clone() function)\n \n    console.log(&apos;after: &apos;+test); // 1 \n}\n\n\nfunction changeVariable(test2) {\n  var test1 = test2;\n  test1.push(2); \n  console.log(&apos;inside func:&apos;, test1);  // inside func: [1,2]\n}   \n\n\nrun();    \n\n    ","url":"/questions/[slug]#solution25","@type":"Answer","upvoteCount":0},{"text":"I have found the extend method of the Underscore.js library very useful when I want to pass in an object as a parameter which may either be modified or replaced entirely.\n\nfunction replaceOrModify(aObj) {\n  if (modify) {\n\n    aObj.setNewValue(&apos;foo&apos;);\n\n  } else {\n\n   var newObj = new MyObject();\n   // _.extend(destination, *sources) \n   _.extend(newObj, aObj);\n  }\n}\n\n    ","url":"/questions/[slug]#solution26","@type":"Answer","upvoteCount":0},{"text":"I would say it is pass-by-copy -\n\nConsider arguments and variable objects are objects created during the execution context created in the beginning of function invocation - and your actual value/reference passed into the function just get stored in this arguments + variable objects.\n\nSimply speaking, for primitive types, the values get copied in the beginning of function call, for object type, the reference get copied.\n    ","url":"/questions/[slug]#solution27","@type":"Answer","upvoteCount":0},{"text":"\nprimitive type variable like string,number are always pass as  pass\nby value.\nArray and Object is passed as  pass by reference or  pass by value based on these two condition.\n\n\nif you are changing value of that Object or array with new Object or Array then it is pass by Value.\n\nobject1 = {item: &quot;car&quot;};\n  array1=[1,2,3];\n\n\nhere you are assigning new object or array to old one.you are not changing the value of property \nof old object.so it is pass by value.\n\n\nif you are changing a property value of an object or array then it is pass by Reference.\n\nobject1.key1= &quot;car&quot;;\n  array1[0]=9;\n\n\nhere you are changing a property value of old object.you are not assigning new object or array to old one.so it is pass by reference.\n\n\nCode\n\n    function passVar(object1, object2, number1) {\n\n        object1.key1= &quot;laptop&quot;;\n        object2 = {\n            key2: &quot;computer&quot;\n        };\n        number1 = number1 + 1;\n    }\n\n    var object1 = {\n        key1: &quot;car&quot;\n    };\n    var object2 = {\n        key2: &quot;bike&quot;\n    };\n    var number1 = 10;\n\n    passVar(object1, object2, number1);\n    console.log(object1.key1);\n    console.log(object2.key2);\n    console.log(number1);\n\nOutput: -\n    laptop\n    bike\n    10\n\n    ","url":"/questions/[slug]#solution28","@type":"Answer","upvoteCount":0},{"text":"An easy way to determine whether something is &quot;pass by reference&quot; is whether you can write a &quot;swap&quot; function. For example, in C, you can do:\n\nvoid swap(int *i, int *j)\n{\n    int t;\n    t = *i;\n    *i = *j;\n    *j = t;\n}\n\n\nIf you can&apos;t do the equivalent of that in JavaScript, it is not &quot;pass by reference&quot;.\n    ","url":"/questions/[slug]#solution29","@type":"Answer","upvoteCount":0},{"text":"\nPrimitives (number, Boolean, etc.) are passed by value.\n\n\nStrings are immutable, so it doesn&apos;t really matter for them.\n\nObjects are passed by reference (the reference is passed by value).\n\n    ","url":"/questions/[slug]#solution30","@type":"Answer","upvoteCount":0}],"@type":"Question"}}</script><meta name="next-head-count" content="22"/><link rel="preload" href="/_next/static/css/c116652e2d6f4ad0.css" as="style"/><link rel="stylesheet" href="/_next/static/css/c116652e2d6f4ad0.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-0d1b80a048d4787e.js"></script><script src="/_next/static/chunks/webpack-42cdea76c8170223.js" defer=""></script><script src="/_next/static/chunks/framework-4556c45dd113b893.js" defer=""></script><script src="/_next/static/chunks/main-ccfab947c79712f4.js" defer=""></script><script src="/_next/static/chunks/pages/_app-260362324a06d105.js" defer=""></script><script src="/_next/static/chunks/294-106ef8570fa99deb.js" defer=""></script><script src="/_next/static/chunks/490-7f0418bb4354ac73.js" defer=""></script><script src="/_next/static/chunks/pages/questions/%5Bslug%5D-50e201fdaa1e0fd1.js" defer=""></script><script src="/_next/static/5tS3Jli5j89_wXapXajXn/_buildManifest.js" defer=""></script><script src="/_next/static/5tS3Jli5j89_wXapXajXn/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="wrapper"><header><nav class="bg-white border-gray-200 px-4 lg:px-6 py-2.5 dark:bg-gray-800"><div class="flex flex-wrap justify-between items-center mx-auto max-w-screen-xl"><a class="flex items-center" href="/"><img src="/logo-second.png" class="mr-3 h-6 sm:h-9" alt="Solution Checker Logo"/><h1 class="self-center text-xl font-semibold whitespace-nowrap dark:text-white">Solution Checker</h1></a><div class="flex items-center lg:order-2"><button data-collapse-toggle="mobile-menu-2" type="button" class="inline-flex items-center p-2 ml-1 text-sm text-gray-500 rounded-lg lg:hidden hover:bg-gray-100 focus:outline-none focus:ring-2 focus:ring-gray-200 dark:text-gray-400 dark:hover:bg-gray-700 dark:focus:ring-gray-600" aria-controls="mobile-menu-2" aria-expanded="false"><span class="sr-only">Open main menu</span><svg class="w-6 h-6" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M3 5a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM3 10a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM3 15a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1z" clip-rule="evenodd"></path></svg><svg class="hidden w-6 h-6" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z" clip-rule="evenodd"></path></svg></button></div><div class="hidden justify-between items-center w-full lg:flex lg:w-auto lg:order-1" id="mobile-menu-2"><ul class="flex flex-col mt-4 font-medium lg:flex-row lg:space-x-8 lg:mt-0"><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" aria-current="page" href="/">Home</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/questions?tab=news">Questions</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/post?tab=news">Post</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/questions/is-javascript-a-pass-by-reference-or-pass-by-value-language-1657384675679#">Coding</a></li></ul></div></div></nav></header><div class="main-content"><div class="question my-5"><div class="flex question-header items-center m-auto justify-center"><div class="rounded-xl w-full border p-5 shadow-md bg-white"><div class="flex w-full items-center justify-between border-b pb-3"><div class="flex items-center space-x-3"><div class="text-lg font-bold text-slate-700"><a href="/questions/is-javascript-a-pass-by-reference-or-pass-by-value-language-1657384675679"><h1>Is JavaScript a pass-by-reference or pass-by-value language?</h1></a></div></div><div class="flex flex-wrap h-auto justify-end items-center space-x-8"></div></div><div class="question-content mt-5">
                
<p>The primitive types (number, string, etc.) are passed by value, but objects are unknown, because they can be both passed-by-value (in case we consider that a variable holding an object is in fact a reference to the object) and passed-by-reference (when we consider that the variable to the object holds the object itself).</p>

<p>Although it doesn't really matter at the end, I want to know what is the correct way to present the arguments passing conventions. Is there an excerpt from JavaScript specification, which defines what should be the semantics regarding this?</p>
    </div></div></div><div class="solution-section"><nav class="flex pagination-solution flex-col justify-end"><h1 class="text-lg font-semibold mb-5">Navigate to solutions: </h1><ul class="inline-flex -space-x-px overflow-auto"><li class="pagination-solution-item"><span data-id="#solution1" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">1</span></li><li class="pagination-solution-item"><span data-id="#solution2" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">2</span></li><li class="pagination-solution-item"><span data-id="#solution3" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">3</span></li><li class="pagination-solution-item"><span data-id="#solution4" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">4</span></li><li class="pagination-solution-item"><span data-id="#solution5" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">5</span></li><li class="pagination-solution-item"><span data-id="#solution6" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">6</span></li><li class="pagination-solution-item"><span data-id="#solution7" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">7</span></li><li class="pagination-solution-item"><span data-id="#solution8" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">8</span></li><li class="pagination-solution-item"><span data-id="#solution9" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">9</span></li><li class="pagination-solution-item"><span data-id="#solution10" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">10</span></li><li class="pagination-solution-item"><span data-id="#solution11" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">11</span></li><li class="pagination-solution-item"><span data-id="#solution12" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">12</span></li><li class="pagination-solution-item"><span data-id="#solution13" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">13</span></li><li class="pagination-solution-item"><span data-id="#solution14" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">14</span></li><li class="pagination-solution-item"><span data-id="#solution15" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">15</span></li><li class="pagination-solution-item"><span data-id="#solution16" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">16</span></li><li class="pagination-solution-item"><span data-id="#solution17" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">17</span></li><li class="pagination-solution-item"><span data-id="#solution18" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">18</span></li><li class="pagination-solution-item"><span data-id="#solution19" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">19</span></li><li class="pagination-solution-item"><span data-id="#solution20" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">20</span></li><li class="pagination-solution-item"><span data-id="#solution21" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">21</span></li><li class="pagination-solution-item"><span data-id="#solution22" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">22</span></li><li class="pagination-solution-item"><span data-id="#solution23" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">23</span></li><li class="pagination-solution-item"><span data-id="#solution24" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">24</span></li><li class="pagination-solution-item"><span data-id="#solution25" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">25</span></li><li class="pagination-solution-item"><span data-id="#solution26" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">26</span></li><li class="pagination-solution-item"><span data-id="#solution27" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">27</span></li><li class="pagination-solution-item"><span data-id="#solution28" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">28</span></li><li class="pagination-solution-item"><span data-id="#solution29" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">29</span></li><li class="pagination-solution-item"><span data-id="#solution30" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">30</span></li></ul></nav><div id="solution1" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 1</h1><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>It's interesting in JavaScript. Consider this example:</p>
<p></p><div class="snippet" data-lang="js" data-hide="false" data-console="true" data-babel="false">
<div class="snippet-code">
<pre class="snippet-code-js lang-js s-code-block"><code class="hljs language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">changeStuff</span>(<span class="hljs-params">a, b, c</span>)
{
  a = a * <span class="hljs-number">10</span>;
  b.<span class="hljs-property">item</span> = <span class="hljs-string">"changed"</span>;
  c = {<span class="hljs-attr">item</span>: <span class="hljs-string">"changed"</span>};
}

<span class="hljs-keyword">var</span> num = <span class="hljs-number">10</span>;
<span class="hljs-keyword">var</span> obj1 = {<span class="hljs-attr">item</span>: <span class="hljs-string">"unchanged"</span>};
<span class="hljs-keyword">var</span> obj2 = {<span class="hljs-attr">item</span>: <span class="hljs-string">"unchanged"</span>};

<span class="hljs-title function_">changeStuff</span>(num, obj1, obj2);

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(num);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj1.<span class="hljs-property">item</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj2.<span class="hljs-property">item</span>);</code></pre>
<div class="snippet-result"><div class="snippet-ctas"><button type="button" class="s-btn s-btn__primary"><span class="icon-play-white _hover"></span><span> Run code snippet</span></button><input class="copySnippet s-btn s-btn__filled" type="button" value="Copy snippet to answer" style="display: none;"><button type="button" class="s-btn hideResults" style="display: none;">Hide results</button><div class="popout-code"><a class="snippet-expand-link">Expand snippet</a></div></div><div class="snippet-result-code" style="display: none;"><iframe name="sif1" sandbox="allow-forms allow-modals allow-scripts" class="snippet-box-edit snippet-box-result" frameborder="0"></iframe></div></div></div>
</div>
<p></p>
<p>This produces the output:</p>
<pre class="lang-none s-code-block"><code>10
changed
unchanged
</code></pre>
<ul>
<li>If <code>obj1</code> was not a reference at all, then changing <code>obj1.item</code> would have no effect on the <code>obj1</code> outside of the function.</li>
<li>If the argument was a proper reference, then everything would have changed. <code>num</code> would be <code>100</code>, and <code>obj2.item</code> would read <code>"changed"</code>. Instead, <code>num</code> stays <code>10</code> and <code>obj2.item</code> remains <code>"unchanged</code>".</li>
</ul>
<p>Instead, the situation is that the item passed in is passed by value. But the item that is passed by value is <em>itself</em> a reference.
Technically, this is called <a href="http://en.wikipedia.org/wiki/Evaluation_strategy#Call_by_sharing" rel="noreferrer">call-by-sharing</a>.</p>
<p>In practical terms, this means that if you change the parameter itself (as with <code>num</code> and <code>obj2</code>), that won't affect the item that was fed into the parameter. But if you change the <em>internals</em> of the parameter, that will propagate back up (as with <code>obj1</code>).</p>
    </div></div></div></div><div id="solution2" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 2</h1><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>It's always pass by value, but for objects the value of the variable is a reference.  Because of this, when you pass an object and change its <em>members</em>, those changes persist outside of the function.  This makes it <em>look</em> like pass by reference.  But if you actually change the value of the object variable you will see that the change does not persist, proving it's really pass by value.</p>

<p>Example:</p>

<p></p><div class="snippet" data-lang="js" data-hide="false" data-console="true" data-babel="false">
<div class="snippet-code">
<pre class="snippet-code-js lang-js s-code-block"><code class="hljs language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">changeObject</span>(<span class="hljs-params">x</span>) {
  x = { <span class="hljs-attr">member</span>: <span class="hljs-string">"bar"</span> };
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"in changeObject: "</span> + x.<span class="hljs-property">member</span>);
}

<span class="hljs-keyword">function</span> <span class="hljs-title function_">changeMember</span>(<span class="hljs-params">x</span>) {
  x.<span class="hljs-property">member</span> = <span class="hljs-string">"bar"</span>;
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"in changeMember: "</span> + x.<span class="hljs-property">member</span>);
}

<span class="hljs-keyword">var</span> x = { <span class="hljs-attr">member</span>: <span class="hljs-string">"foo"</span> };

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"before changeObject: "</span> + x.<span class="hljs-property">member</span>);
<span class="hljs-title function_">changeObject</span>(x);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"after changeObject: "</span> + x.<span class="hljs-property">member</span>); <span class="hljs-comment">/* change did not persist */</span>

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"before changeMember: "</span> + x.<span class="hljs-property">member</span>);
<span class="hljs-title function_">changeMember</span>(x);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"after changeMember: "</span> + x.<span class="hljs-property">member</span>); <span class="hljs-comment">/* change persists */</span></code></pre>
<div class="snippet-result"><div class="snippet-ctas"><button type="button" class="s-btn s-btn__primary"><span class="icon-play-white _hover"></span><span> Run code snippet</span></button><input class="copySnippet s-btn s-btn__filled" type="button" value="Copy snippet to answer" style="display: none;"><button type="button" class="s-btn hideResults" style="display: none;">Hide results</button><div class="popout-code"><a class="snippet-expand-link">Expand snippet</a></div></div><div class="snippet-result-code" style="display: none;"><iframe name="sif2" sandbox="allow-forms allow-modals allow-scripts" class="snippet-box-edit snippet-box-result" frameborder="0"></iframe></div></div></div>
</div>
<p></p>

<p>Output:</p>

<pre class="lang-js s-code-block"><code class="hljs language-javascript">before <span class="hljs-attr">changeObject</span>: foo
<span class="hljs-keyword">in</span> <span class="hljs-attr">changeObject</span>: bar
after <span class="hljs-attr">changeObject</span>: foo

before <span class="hljs-attr">changeMember</span>: foo
<span class="hljs-keyword">in</span> <span class="hljs-attr">changeMember</span>: bar
after <span class="hljs-attr">changeMember</span>: bar
</code></pre>
    </div></div></div></div><div id="solution3" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 3</h1><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>The variable doesn't "hold" the object; it holds a reference. You can assign that reference to another variable, and now both reference the same object. It's always pass by value (even when that value is a reference...).</p>

<p>There's no way to alter the value held by a variable passed as a parameter, which would be possible if JavaScript supported passing by reference.</p>
    </div></div></div></div><div id="solution4" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 4</h1><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>My two cents... This is the way I understand it. (Feel free to correct me if I'm wrong)</p>
<p>It's time to throw out everything you know about pass by value / reference.</p>
<p><strong>Because in JavaScript, it doesn't matter whether it's passed by value or by reference or whatever.
What matters is mutation vs assignment of the parameters passed into a function.</strong></p>
<p>OK, let me do my best to explain what I mean. Let's say you have a few objects.</p>
<pre class="lang-js s-code-block"><code class="hljs language-javascript"><span class="hljs-keyword">var</span> object1 = {};
<span class="hljs-keyword">var</span> object2 = {};
</code></pre>
<p>What we have done is "assignment"... We've assigned 2 separate empty objects to the variables "object1" and "object2".</p>
<p>Now, let's say that we like object1 better... So, we "assign" a new variable.</p>
<pre class="lang-js s-code-block"><code class="hljs language-javascript"><span class="hljs-keyword">var</span> favoriteObject = object1;
</code></pre>
<p>Next, for whatever reason, we decide that we like object 2 better. So, we do a little re-assignment.</p>
<pre class="lang-js s-code-block"><code class="hljs language-javascript">favoriteObject = object2;
</code></pre>
<p>Nothing happened to object1 or to object2. We haven't changed any data at all. All we did was re-assign what our favorite object is. It is important to know that object2 and favoriteObject are both assigned to the same object. We can change that object via either of those variables.</p>
<pre class="lang-js s-code-block"><code class="hljs language-javascript">object2.<span class="hljs-property">name</span> = <span class="hljs-string">'Fred'</span>;
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(favoriteObject.<span class="hljs-property">name</span>) <span class="hljs-comment">// Logs Fred</span>
favoriteObject.<span class="hljs-property">name</span> = <span class="hljs-string">'Joe'</span>;
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(object2.<span class="hljs-property">name</span>); <span class="hljs-comment">// Logs Joe</span>
</code></pre>
<p>OK, now let's look at primitives like strings for example</p>
<pre class="lang-js s-code-block"><code class="hljs language-javascript"><span class="hljs-keyword">var</span> string1 = <span class="hljs-string">'Hello world'</span>;
<span class="hljs-keyword">var</span> string2 = <span class="hljs-string">'Goodbye world'</span>;
</code></pre>
<p>Again, we pick a favorite.</p>
<pre class="lang-js s-code-block"><code class="hljs language-javascript"><span class="hljs-keyword">var</span> favoriteString = string1;
</code></pre>
<p>Both our favoriteString and string1 variables are assigned to 'Hello world'. Now, what if we want to change our favoriteString??? What will happen???</p>
<pre class="lang-js s-code-block"><code class="hljs language-javascript">favoriteString = <span class="hljs-string">'Hello everyone'</span>;
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(favoriteString); <span class="hljs-comment">// Logs 'Hello everyone'</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(string1); <span class="hljs-comment">// Logs 'Hello world'</span>
</code></pre>
<p>Uh oh.... What has happened. We couldn't change string1 by changing favoriteString... Why?? Because we didn't <em>change</em> our string <em>object</em>. All we did was "RE ASSIGN" the favoriteString <em>variable</em> to a new string. This essentially disconnected it from string1. In the previous example, when we renamed our object, we didn't assign anything. (Well, not to the <em>variable itself</em>, ... we did, however, assign the name property to a new string.) Instead, we mutated the object which keeps the connections between the 2 variables and the underlying objects. (Even if we had wanted to modify or <em>mutate</em> the string object <em>itself</em>, we couldn't have, because strings are actually immutable in JavaScript.)</p>
<p>Now, on to functions and passing parameters.... When you call a function, and pass a parameter, what you are essentially doing is an "assignment" to a new variable, and it works exactly the same as if you assigned using the equal (=) sign.</p>
<p>Take these examples.</p>
<pre class="lang-js s-code-block"><code class="hljs language-javascript"><span class="hljs-keyword">var</span> myString = <span class="hljs-string">'hello'</span>;

<span class="hljs-comment">// Assign to a new variable (just like when you pass to a function)</span>
<span class="hljs-keyword">var</span> param1 = myString;
param1 = <span class="hljs-string">'world'</span>; <span class="hljs-comment">// Re assignment</span>

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(myString); <span class="hljs-comment">// Logs 'hello'</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(param1);   <span class="hljs-comment">// Logs 'world'</span>
</code></pre>
<p>Now, the same thing, but with a function</p>
<pre class="lang-js s-code-block"><code class="hljs language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">myFunc</span>(<span class="hljs-params">param1</span>) {
    param1 = <span class="hljs-string">'world'</span>;

    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(param1);   <span class="hljs-comment">// Logs 'world'</span>
}

<span class="hljs-keyword">var</span> myString = <span class="hljs-string">'hello'</span>;
<span class="hljs-comment">// Calls myFunc and assigns param1 to myString just like param1 = myString</span>
<span class="hljs-title function_">myFunc</span>(myString);

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(myString); <span class="hljs-comment">// logs 'hello'</span>
</code></pre>
<p>OK, now lets give a few examples using objects instead... first, without the function.</p>
<pre class="lang-js s-code-block"><code class="hljs language-javascript"><span class="hljs-keyword">var</span> myObject = {
    <span class="hljs-attr">firstName</span>: <span class="hljs-string">'Joe'</span>,
    <span class="hljs-attr">lastName</span>: <span class="hljs-string">'Smith'</span>
};

<span class="hljs-comment">// Assign to a new variable (just like when you pass to a function)</span>
<span class="hljs-keyword">var</span> otherObj = myObject;

<span class="hljs-comment">// Let's mutate our object</span>
otherObj.<span class="hljs-property">firstName</span> = <span class="hljs-string">'Sue'</span>; <span class="hljs-comment">// I guess Joe decided to be a girl</span>

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(myObject.<span class="hljs-property">firstName</span>); <span class="hljs-comment">// Logs 'Sue'</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(otherObj.<span class="hljs-property">firstName</span>); <span class="hljs-comment">// Logs 'Sue'</span>

<span class="hljs-comment">// Now, let's reassign the variable</span>
otherObj = {
    <span class="hljs-attr">firstName</span>: <span class="hljs-string">'Jack'</span>,
    <span class="hljs-attr">lastName</span>: <span class="hljs-string">'Frost'</span>
};

<span class="hljs-comment">// Now, otherObj and myObject are assigned to 2 very different objects</span>
<span class="hljs-comment">// And mutating one object has no influence on the other</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(myObject.<span class="hljs-property">firstName</span>); <span class="hljs-comment">// Logs 'Sue'</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(otherObj.<span class="hljs-property">firstName</span>); <span class="hljs-comment">// Logs 'Jack';</span>
</code></pre>
<p>Now, the same thing, but with a function call</p>
<pre class="lang-js s-code-block"><code class="hljs language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">myFunc</span>(<span class="hljs-params">otherObj</span>) {

    <span class="hljs-comment">// Let's mutate our object</span>
    otherObj.<span class="hljs-property">firstName</span> = <span class="hljs-string">'Sue'</span>;
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(otherObj.<span class="hljs-property">firstName</span>); <span class="hljs-comment">// Logs 'Sue'</span>

    <span class="hljs-comment">// Now let's re-assign</span>
    otherObj = {
        <span class="hljs-attr">firstName</span>: <span class="hljs-string">'Jack'</span>,
        <span class="hljs-attr">lastName</span>: <span class="hljs-string">'Frost'</span>
    };
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(otherObj.<span class="hljs-property">firstName</span>); <span class="hljs-comment">// Logs 'Jack'</span>

    <span class="hljs-comment">// Again, otherObj and myObject are assigned to 2 very different objects</span>
    <span class="hljs-comment">// And mutating one object doesn't magically mutate the other</span>
}

<span class="hljs-keyword">var</span> myObject = {
    <span class="hljs-attr">firstName</span>: <span class="hljs-string">'Joe'</span>,
    <span class="hljs-attr">lastName</span>: <span class="hljs-string">'Smith'</span>
};

<span class="hljs-comment">// Calls myFunc and assigns otherObj to myObject just like otherObj = myObject</span>
<span class="hljs-title function_">myFunc</span>(myObject);

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(myObject.<span class="hljs-property">firstName</span>); <span class="hljs-comment">// Logs 'Sue', just like before</span>
</code></pre>
<p>OK, if you read through this entire post, perhaps you now have a better understanding of how function calls work in JavaScript. It doesn't matter whether something is passed by reference or by value... What matters is assignment vs mutation.</p>
<p>Every time you pass a variable to a function, you are "Assigning" to whatever the name of the parameter variable is, just like if you used the equal (=) sign.</p>
<p>Always remember that the equals sign (=) means assignment.
Always remember that passing a parameter to a function <em>in JavaScript</em> also means assignment.
They are the same and the 2 variables are connected in exactly the same way (which is to say they aren't, unless you count that they are assigned to the same object).</p>
<p>The only time that "modifying a variable" affects a different variable is when the underlying object is mutated (in which case you haven't modified the variable, but the object itself.</p>
<p>There is no point in making a distinction between objects and primitives, because it works the same exact way as if you didn't have a function and just used the equal sign to assign to a new variable.</p>
<p>The only gotcha is when the name of the variable you pass into the function is the same as the name of the function parameter. When this happens, you have to treat the parameter inside the function as if it was a whole new variable private to the function (because it is)</p>
<pre class="lang-js s-code-block"><code class="hljs language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">myFunc</span>(<span class="hljs-params">myString</span>) {
    <span class="hljs-comment">// myString is private and does not affect the outer variable</span>
    myString = <span class="hljs-string">'hello'</span>;
}

<span class="hljs-keyword">var</span> myString = <span class="hljs-string">'test'</span>;
myString = myString; <span class="hljs-comment">// Does nothing, myString is still 'test';</span>

<span class="hljs-title function_">myFunc</span>(myString);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(myString); <span class="hljs-comment">// Logs 'test'</span>
</code></pre>
    </div></div></div></div><div id="solution5" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 5</h1><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">

<p>These phrases/concepts were originally defined long before JS was created and they don't accurately describe the semantics for javascript. I think trying to apply them to JS causes more confusion than not.</p>
<p>So don't get hung up on "pass by reference/value".</p>
<p>Consider the following:</p>
<ol>
<li>Variables are <em>pointers</em> to values.</li>
<li>Reassigning a variable merely points that pointer at a new value.</li>
<li>Reassigning a variable will never affect other variables that were pointing at that same object because each variable has its own pointer.</li>
</ol>
<p>So if I had to give it a name I'd say <strong>"pass-by-pointer"</strong> -- we don't deal with pointers in JS but the underlying engine does.</p>
<br>
<pre class="lang-js s-code-block"><code class="hljs language-javascript"><span class="hljs-comment">// code</span>
<span class="hljs-keyword">var</span> obj = {
    <span class="hljs-attr">name</span>: <span class="hljs-string">'Fred'</span>,
    <span class="hljs-attr">num</span>: <span class="hljs-number">1</span>
};

<span class="hljs-comment">// illustration</span>
               <span class="hljs-string">'Fred'</span>
              /
             /
(obj) ---- {}
             \
              \
               <span class="hljs-number">1</span>
</code></pre>
<br>
<pre class="lang-js s-code-block"><code class="hljs language-javascript"><span class="hljs-comment">// code</span>
obj.<span class="hljs-property">name</span> = <span class="hljs-string">'George'</span>;


<span class="hljs-comment">// illustration</span>
                 <span class="hljs-string">'Fred'</span>


(obj) ---- {} ----- <span class="hljs-string">'George'</span>
             \
              \
               <span class="hljs-number">1</span>
</code></pre>
<br>
<pre class="lang-js s-code-block"><code class="hljs language-javascript"><span class="hljs-comment">// code</span>
obj = {};

<span class="hljs-comment">// illustration</span>
                 <span class="hljs-string">'Fred'</span>


(obj)      {} ----- <span class="hljs-string">'George'</span>
  |          \
  |           \
 { }            <span class="hljs-number">1</span>
</code></pre>
<br>
<pre class="lang-js s-code-block"><code class="hljs language-javascript"><span class="hljs-comment">// code</span>
<span class="hljs-keyword">var</span> obj = {
    <span class="hljs-attr">text</span>: <span class="hljs-string">'Hello world!'</span>
};

<span class="hljs-comment">/* function parameters get their own pointer to 
 * the arguments that are passed in, just like any other variable */</span>
<span class="hljs-title function_">someFunc</span>(obj);


<span class="hljs-comment">// illustration</span>
(caller scope)        (someFunc scope)
           \             /
            \           /
             \         /
              \       /
               \     /
                 { }
                  |
                  |
                  |
            <span class="hljs-string">'Hello world'</span>
</code></pre>
<p>Some final comments:</p>
<ul>
<li>The phrases "pass by value/reference" are only used to describe the <em>behavior</em> of a language, not necessarily the actual underlying implementation. As a result of this abstraction, critical details that are essential for a decent explanation are lost, which inevitably leads to the current situation where a single term doesn't adequately describe the actual behavior without additional info.</li>
<li>It's tempting to think that <em>primitives</em> are enforced by special rules while <em>objects</em> are not, but primitives are simply the end of the pointer chain.</li>
<li>As a final example, consider why a common attempt to clear an array doesn't work as expected.</li>
</ul>
<p></p><div class="snippet" data-lang="js" data-hide="false" data-console="true" data-babel="false">
<div class="snippet-code">
<pre class="snippet-code-js lang-js s-code-block"><code class="hljs language-javascript"><span class="hljs-keyword">var</span> a = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>];
<span class="hljs-keyword">var</span> b = a;

a = [];
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(b); <span class="hljs-comment">// [1,2]</span>
<span class="hljs-comment">// doesn't work because `b` is still pointing at the original array</span></code></pre>
<div class="snippet-result"><div class="snippet-ctas"><button type="button" class="s-btn s-btn__primary"><span class="icon-play-white _hover"></span><span> Run code snippet</span></button><input class="copySnippet s-btn s-btn__filled" type="button" value="Copy snippet to answer" style="display: none;"><button type="button" class="s-btn hideResults" style="display: none;">Hide results</button><div class="popout-code"><a class="snippet-expand-link">Expand snippet</a></div></div><div class="snippet-result-code" style="display: none;"><iframe name="sif3" sandbox="allow-forms allow-modals allow-scripts" class="snippet-box-edit snippet-box-result" frameborder="0"></iframe></div></div></div>
</div>
<p></p>
    </div></div></div></div><div id="solution6" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 6</h1><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>An object outside a function is passed into a function by giving a reference to the outside object.</p>

<p>When you use that reference to manipulate its object, the object outside is thus affected. However, if inside the function you decided to point the reference to something else, you did not affect the object outside at all, because all you did was re-direct the reference to something else. </p>
    </div></div></div></div><div id="solution7" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 7</h1><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Think of it like this: It's always pass by value. However, the value of an object is not the object itself, but a reference to that object. </p>

<p>Here is an example, passing a number (a primitive type)</p>

<pre class="lang-js s-code-block"><code class="hljs language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">changePrimitive</span>(<span class="hljs-params">val</span>) {
    <span class="hljs-comment">// At this point there are two '10's in memory.</span>
    <span class="hljs-comment">// Changing one won't affect the other</span>
    val = val * <span class="hljs-number">10</span>;
}
<span class="hljs-keyword">var</span> x = <span class="hljs-number">10</span>;
<span class="hljs-title function_">changePrimitive</span>(x);
<span class="hljs-comment">// x === 10</span>
</code></pre>

<p>Repeating this with an object yields different results:</p>

<pre class="lang-js s-code-block"><code class="hljs language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">changeObject</span>(<span class="hljs-params">obj</span>) {
    <span class="hljs-comment">// At this point there are two references (x and obj) in memory,</span>
    <span class="hljs-comment">// but these both point to the same object.</span>
    <span class="hljs-comment">// changing the object will change the underlying object that</span>
    <span class="hljs-comment">// x and obj both hold a reference to.</span>
    obj.<span class="hljs-property">val</span> = obj.<span class="hljs-property">val</span> * <span class="hljs-number">10</span>;
}
<span class="hljs-keyword">var</span> x = { <span class="hljs-attr">val</span>: <span class="hljs-number">10</span> };
<span class="hljs-title function_">changeObject</span>(x);
<span class="hljs-comment">// x === { val: 100 }</span>
</code></pre>

<p>One more example:</p>

<pre class="lang-js s-code-block"><code class="hljs language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">changeObject</span>(<span class="hljs-params">obj</span>) {
    <span class="hljs-comment">// Again there are two references (x and obj) in memory,</span>
    <span class="hljs-comment">// these both point to the same object.</span>
    <span class="hljs-comment">// now we create a completely new object and assign it.</span>
    <span class="hljs-comment">// obj's reference now points to the new object.</span>
    <span class="hljs-comment">// x's reference doesn't change.</span>
    obj = { <span class="hljs-attr">val</span>: <span class="hljs-number">100</span> };
}
<span class="hljs-keyword">var</span> x = { <span class="hljs-attr">val</span>: <span class="hljs-number">10</span> };
<span class="hljs-title function_">changeObject</span>(x);
<span class="hljs-comment">// x === { val: 10}</span>
</code></pre>
    </div></div></div></div><div id="solution8" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 8</h1><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>A very detailed explanation about copying, passing and comparing by value and by reference is in <a href="http://docstore.mik.ua/orelly/webprog/jscript/ch11_02.htm" rel="noreferrer">this chapter</a> of the <em>"JavaScript: The Definitive Guide"</em> book.</p>
<blockquote>
<p>Before we leave the topic of
manipulating objects and arrays by
reference, we need to clear up a point
of nomenclature.</p>
<p>The phrase "pass by
reference" can have several meanings.
To some readers, the phrase refers to
a function invocation technique that
allows a function to assign new values
to its arguments and to have those
modified values visible outside the
function. This is not the way the term
is used in this book.</p>
<p>Here, we mean
simply that a reference to an object
or array -- not the object itself --
is passed to a function. A function
can use the reference to modify
properties of the object or elements
of the array. But if the function
overwrites the reference with a
reference to a new object or array,
that modification is not visible
outside of the function.</p>
<p>Readers
familiar with the other meaning of
this term may prefer to say that
objects and arrays are passed by
value, but the value that is passed is
actually a reference rather than the
object itself.</p>
</blockquote>
    </div></div></div></div><div id="solution9" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 9</h1><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>JavaScript is always <em>pass-by-value</em>; everything is of value type.</p>
<p>Objects are values, and member functions of objects are values themselves (remember that functions are first-class objects in JavaScript). Also, regarding the concept that everything in JavaScript is an <em>object</em>; this is wrong. Strings, symbols, numbers, booleans, nulls, and undefineds are <em>primitives</em>.</p>
<p>On occasion they can leverage some member functions and properties inherited from their base prototypes, but this is only for convenience. It does not mean that they are objects themselves. Try the following for reference:</p>
<p></p><div class="snippet" data-lang="js" data-hide="false" data-console="true" data-babel="false">
<div class="snippet-code">
<pre class="snippet-code-js lang-js s-code-block"><code class="hljs language-javascript">x = <span class="hljs-string">"test"</span>;
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(x.<span class="hljs-property">foo</span>);
x.<span class="hljs-property">foo</span> = <span class="hljs-number">12</span>;
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(x.<span class="hljs-property">foo</span>);</code></pre>
<div class="snippet-result"><div class="snippet-ctas"><button type="button" class="s-btn s-btn__primary"><span class="icon-play-white _hover"></span><span> Run code snippet</span></button><input class="copySnippet s-btn s-btn__filled" type="button" value="Copy snippet to answer" style="display: none;"><button type="button" class="s-btn hideResults" style="display: none;">Hide results</button><div class="popout-code"><a class="snippet-expand-link">Expand snippet</a></div></div><div class="snippet-result-code" style="display: none;"><iframe name="sif4" sandbox="allow-forms allow-modals allow-scripts" class="snippet-box-edit snippet-box-result" frameborder="0"></iframe></div></div></div>
</div>
<p></p>
<p>In both <code>console.log</code> you will find the value to be <code>undefined</code>.</p>
    </div></div></div></div><div id="solution10" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 10</h1><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>In JavaScript, the type of the value <em>solely</em> controls whether that value will be assigned by <strong>value-copy</strong> or by <strong>reference-copy</strong>. </p>

<p><em>Primitive values are always assigned/passed by value-copy</em>: </p>

<ul>
<li><code>null</code></li>
<li><code>undefined</code></li>
<li>string</li>
<li>number</li>
<li>boolean</li>
<li>symbol in <code>ES6</code></li>
</ul>

<p><em>Compound values are always assigned/passed by reference-copy</em></p>

<ul>
<li>objects </li>
<li>arrays</li>
<li>function</li>
</ul>

<p>For example</p>

<pre class="lang-js s-code-block"><code class="hljs language-javascript"><span class="hljs-keyword">var</span> a = <span class="hljs-number">2</span>;
<span class="hljs-keyword">var</span> b = a; <span class="hljs-comment">// `b` is always a copy of the value in `a`</span>
b++;
a; <span class="hljs-comment">// 2</span>
b; <span class="hljs-comment">// 3</span>

<span class="hljs-keyword">var</span> c = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>];
<span class="hljs-keyword">var</span> d = c; <span class="hljs-comment">// `d` is a reference to the shared `[1,2,3]` value</span>
d.<span class="hljs-title function_">push</span>( <span class="hljs-number">4</span> );
c; <span class="hljs-comment">// [1,2,3,4]</span>
d; <span class="hljs-comment">// [1,2,3,4]</span>
</code></pre>

<p>In the above snippet, because <code>2</code> is a scalar primitive, <code>a</code> holds one initial copy of that value, and <code>b</code> is assigned another copy of the value. When changing <code>b</code>, you are in no way changing the value in <code>a</code>.</p>

<p>But both <code>c</code> and <code>d</code> are separate references to the same shared value <code>[1,2,3]</code>, which is a compound value. It's important to note that neither <code>c</code> nor <code>d</code> more "owns" the <code>[1,2,3]</code> value -- both are just equal peer references to the value. So, when using either reference to modify (<code>.push(4)</code>) the actual shared <code>array</code> value itself, it's affecting just the one shared value, and both references will reference the newly modified value <code>[1,2,3,4]</code>.</p>

<pre class="lang-js s-code-block"><code class="hljs language-javascript"><span class="hljs-keyword">var</span> a = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>];
<span class="hljs-keyword">var</span> b = a;
a; <span class="hljs-comment">// [1,2,3]</span>
b; <span class="hljs-comment">// [1,2,3]</span>

<span class="hljs-comment">// later</span>
b = [<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>];
a; <span class="hljs-comment">// [1,2,3]</span>
b; <span class="hljs-comment">// [4,5,6]</span>
</code></pre>

<p>When we make the assignment <code>b = [4,5,6]</code>, we are doing absolutely nothing to affect where <code>a</code> is still referencing (<code>[1,2,3]</code>). To do that, <code>b</code> would have to be a pointer to <code>a</code> rather than a reference to the <code>array</code> -- but no such capability exists in JS!</p>

<pre class="lang-js s-code-block"><code class="hljs language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">x</span>) {
    x.<span class="hljs-title function_">push</span>( <span class="hljs-number">4</span> );
    x; <span class="hljs-comment">// [1,2,3,4]</span>

    <span class="hljs-comment">// later</span>
    x = [<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>];
    x.<span class="hljs-title function_">push</span>( <span class="hljs-number">7</span> );
    x; <span class="hljs-comment">// [4,5,6,7]</span>
}

<span class="hljs-keyword">var</span> a = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>];

<span class="hljs-title function_">foo</span>( a );

a; <span class="hljs-comment">// [1,2,3,4]  not  [4,5,6,7]</span>
</code></pre>

<p>When we pass in the argument <code>a</code>, it assigns a copy of the <code>a</code> reference to <code>x</code>. <code>x</code> and <code>a</code> are separate references pointing at the same <code>[1,2,3]</code> value. Now, inside the function, we can use that reference to mutate the value itself (<code>push(4)</code>). But when we make the assignment <code>x = [4,5,6]</code>, this is in no way affecting where the initial reference <code>a</code> is pointing -- still points at the (now modified) <code>[1,2,3,4]</code> value.</p>

<p>To effectively pass a compound value (like an <code>array</code>) by value-copy, you need to manually make a copy of it, so that the reference passed doesn't still point to the original. For example:</p>

<pre class="lang-js s-code-block"><code class="hljs language-javascript"><span class="hljs-title function_">foo</span>( a.<span class="hljs-title function_">slice</span>() );
</code></pre>

<p>Compound value (object, array, etc) that can be passed by reference-copy</p>

<pre class="lang-js s-code-block"><code class="hljs language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">wrapper</span>) {
    wrapper.<span class="hljs-property">a</span> = <span class="hljs-number">42</span>;
}

<span class="hljs-keyword">var</span> obj = {
    <span class="hljs-attr">a</span>: <span class="hljs-number">2</span>
};

<span class="hljs-title function_">foo</span>( obj );

obj.<span class="hljs-property">a</span>; <span class="hljs-comment">// 42</span>
</code></pre>

<p>Here, <code>obj</code> acts as a wrapper for the scalar primitive property <code>a</code>. When passed to <code>foo(..)</code>, a copy of the <code>obj</code> reference is passed in and set to the <code>wrapper</code>parameter. We now can use the <code>wrapper</code> reference to access the shared object, and update its property. After the function finishes, <code>obj.a</code> will see the updated value <code>42</code>.</p>

<p><a href="https://github.com/getify/You-Dont-Know-JS/blob/master/types%20%26%20grammar/ch2.md">Source</a></p>
    </div></div></div></div><div id="solution11" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 11</h1><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>well, it's about 'performance' and 'speed' and in the simple word 'memory management' in a programming language.</p>
<p>in javascript we can put values in two layer: <strong>type1</strong>-<code>objects</code> and <strong>type2</strong>-all other types of value such as <code>string</code> &amp; <code>boolean</code> &amp; etc</p>
<p>if you imagine memory as below squares which in every one of them just one type2-value can be saved:</p>
<p><a href="https://i.stack.imgur.com/wFWOsm.png" rel="nofollow noreferrer"><img src="https://i.stack.imgur.com/wFWOsm.png" alt="enter image description here"></a></p>
<p>every type2-value (green) is a <strong>single square</strong> while a type1-value (blue) is a <strong>group of them</strong>:</p>
<p><a href="https://i.stack.imgur.com/vwu2vm.png" rel="nofollow noreferrer"><img src="https://i.stack.imgur.com/vwu2vm.png" alt="enter image description here"></a></p>
<p>the point is that if you want to indicate a type2-value, the address is plain but if you want to do the same thing for type1-value that's not easy at all! :</p>
<p><a href="https://i.stack.imgur.com/ZISOHm.png" rel="nofollow noreferrer"><img src="https://i.stack.imgur.com/ZISOHm.png" alt="enter image description here"></a></p>
<p>and in a more complicated story:</p>
<p><a href="https://i.stack.imgur.com/GIEvCm.png" rel="nofollow noreferrer"><img src="https://i.stack.imgur.com/GIEvCm.png" alt="enter image description here"></a></p>
<p>so here <strong>references</strong> can rescue us:
<br>
<a href="https://i.stack.imgur.com/orhtHm.png" rel="nofollow noreferrer"><img src="https://i.stack.imgur.com/orhtHm.png" alt="enter image description here"></a></p>
<p>while the green arrow here is a typical variable, the purple one is an object variable, so <strong>because the green arrow(typical variable) has just one task</strong> (and that is indicating a typical value) we don't need to separate it's value from it so we move the green arrow with the value of that wherever it goes and in all assignments, functions and so on ...</p>
<p>but we cant do the same thing with the purple arrow, we may want to move 'john' cell here or many other things..., so the purple arrow will stick to its place and just typical arrows that were assigned to it will move ...</p>
<p>a very confusing situation is where you can't realize how your referenced variable changes, let's take a look at a very good example:</p>
<pre class="lang-js s-code-block"><code class="hljs language-javascript"><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]; <span class="hljs-comment">//arr is an object now and a purple arrow is indicating it</span>
<span class="hljs-keyword">let</span> obj2 = arr; <span class="hljs-comment">// now, obj2 is another purple arrow that is indicating the value of arr obj</span>
<span class="hljs-keyword">let</span> obj3 = [<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'c'</span>];
obj2.<span class="hljs-title function_">push</span>(<span class="hljs-number">6</span>); <span class="hljs-comment">// first pic below - making a new hand for the blue circle to point the 6</span>
<span class="hljs-comment">//obj2 = [1, 2, 3, 4, 5, 6]</span>
<span class="hljs-comment">//arr = [1, 2, 3, 4, 5, 6]</span>
<span class="hljs-comment">//we changed the blue circle object value (type1-value) and due to arr and obj2 are indicating that so both of them changed</span>
obj2 = obj3; <span class="hljs-comment">//next pic below - changing the direction of obj2 array from blue circle to orange circle so obj2 is no more [1,2,3,4,5,6] and it's no more about changing anything in it but we completely changed its direction and now obj2 is pointing to obj3</span>
<span class="hljs-comment">//obj2 = ['a', 'b', 'c'];</span>
<span class="hljs-comment">//obj3 = ['a', 'b', 'c'];</span>
</code></pre>
<p><a href="https://i.stack.imgur.com/fELHnm.png" rel="nofollow noreferrer"><img src="https://i.stack.imgur.com/fELHnm.png" alt="enter image description here"></a>
<a href="https://i.stack.imgur.com/y9kukm.png" rel="nofollow noreferrer"><img src="https://i.stack.imgur.com/y9kukm.png" alt="enter image description here"></a></p>
    </div></div></div></div><div id="solution12" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 12</h1><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>This is little more explanation for pass by value and pass by reference (JavaScript). In this concept, they are talking about passing the variable by reference and passing the variable by reference.</p>

<p><strong>Pass by value (primitive type)</strong></p>

<pre class="lang-js s-code-block"><code class="hljs language-javascript"><span class="hljs-keyword">var</span> a = <span class="hljs-number">3</span>;
<span class="hljs-keyword">var</span> b = a;

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a); <span class="hljs-comment">// a = 3</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(b); <span class="hljs-comment">// b = 3</span>

a=<span class="hljs-number">4</span>;
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a); <span class="hljs-comment">// a = 4</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(b); <span class="hljs-comment">// b = 3</span>
</code></pre>

<ul>
<li>applies to all primitive type in JavaScript (string, number, Boolean, undefined, and null).</li>
<li>a is allocated a memory (say 0x001) and b creates a copy of the value in memory (say 0x002).</li>
<li>So changing the value of a variable doesn't affect the other, as they both reside in two different locations.</li>
</ul>

<hr>

<p><strong>Pass by reference (objects)</strong></p>

<pre class="lang-js s-code-block"><code class="hljs language-javascript"><span class="hljs-keyword">var</span> c = { <span class="hljs-string">"name"</span> : <span class="hljs-string">"john"</span> };
<span class="hljs-keyword">var</span> d = c;

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(c); <span class="hljs-comment">// { "name" : "john" }</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(d); <span class="hljs-comment">// { "name" : "john" }</span>

c.<span class="hljs-property">name</span> = <span class="hljs-string">"doe"</span>;

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(c); <span class="hljs-comment">// { "name" : "doe" }</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(d); <span class="hljs-comment">// { "name" : "doe" }</span>
</code></pre>

<ul>
<li>The JavaScript engine assigns the object to the variable <code>c</code>, and it points to some memory, say (0x012).</li>
<li>When d=c, in this step <code>d</code> points to the same location (0x012).</li>
<li>Changing the value of any changes value for both the variable.</li>
<li>Functions are objects</li>
</ul>

<hr>

<p><strong>Special case, pass by reference (objects)</strong></p>

<pre class="lang-js s-code-block"><code class="hljs language-javascript">c = {<span class="hljs-string">"name"</span> : <span class="hljs-string">"jane"</span>};
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(c); <span class="hljs-comment">// { "name" : "jane" }</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(d); <span class="hljs-comment">// { "name" : "doe" }</span>
</code></pre>

<ul>
<li>The equal(=) operator sets up new memory space or address</li>
</ul>
    </div></div></div></div><div id="solution13" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 13</h1><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Semantics!! Setting concrete definitions will necessarily make some answers and comments incompatible since they are not describing the same thing even when using the same words and phrases, but it is critical to get past the confusion (especially for new programmers).</p>

<p>First of all, there are multiple levels of abstraction that not everyone seems to grasp.  Newer programmers who have learned on 4th or 5th generation languages may have difficulty wrapping their mind around concepts familiar to assembly or C programmers not phased by pointers to pointers to pointers.  Pass-by-reference does not simply mean the ability to change a referenced object using a function parameter variable.</p>

<p><strong>Variable</strong>: Combined concept of a symbol which references a value at a particular location in memory.  This term is usually too loaded to be used alone in discussing details.</p>

<p><strong>Symbol</strong>:  Text string used to refer to variable (i.e. variable's name).</p>

<p><strong>Value</strong>:  Particular bits stored in memory and referenced using variable's symbol.</p>

<p><strong>Memory location</strong>:  Where a variable's value is stored.  (The location itself is represented by a number separate from the value stored at the location.)</p>

<p><strong>Function parameter</strong>:  Variable declared in a function definition, used for referencing variables passed to the function.</p>

<p><strong>Function argument</strong>: Variable outside the function which is passed to the function by the caller.</p>

<p><strong>Object variable</strong>:  Variable whose basic underlying value is not the "object" itself, rather its value is a pointer (memory location value) to another location in memory where the object's actual data is stored.  In most higher-generation languages, the "pointer" aspect is effectively hidden by automatic de-referencing in various contexts.</p>

<p><strong>Primitive variable</strong>: Variable whose value IS the actual value.  Even this concept can be complicated by auto-boxing and object-like contexts of various languages, but the general ideas is that the variable's value IS the actual value represented by the variable's symbol rather than a pointer to another memory location.</p>

<p><em>Function arguments and parameters are not the same thing.  Also, a variable's value is not the variable's object (as already pointed out by various people, but apparently ignored).  These distinctions are critical to proper understanding.</em></p>

<p><strong>Pass-by-value or Call-by-sharing (for objects)</strong>:  The function argument's value is COPIED to another memory location which is referenced by the function's parameter symbol (regardless of whether it's on the stack or heap).  In other words, the function parameter received a copy of the passed argument's value... AND (critical) the argument's value IS NEVER UPDATED / ALTERED / CHANGED by the calling function.  Remember, an object variable's value is NOT the object itself, rather it is the pointer to the object, so passing an object variable by value copies the pointer to the function parameter variable.  The function parameter's value points to the exact same object in memory.  The object data itself can be altered directly via the function parameter, BUT the function argument's value IS NEVER UPDATED, so it will continue to point to the <em>same</em> object throughout and even after the function call (even if its object's data was altered or if the function parameter is assigned a different object altogether).  It is incorrect to conclude that the function argument was passed by reference just because the referenced object is updatable via the function parameter variable.</p>

<p><strong>Call / Pass-by-reference</strong>:  The function argument's value can/will be updated directly by the corresponding function parameter.  If it helps, the function parameter becomes an effective "alias" for the argument--they effectively refer to the same value at the same memory location.  If a function argument is an object variable, the ability to change the object's data is no different than the pass-by-value case since the function parameter will still point to the same object as the argument.  But in the object variable case, if the function parameter is set to a completely different object, then the argument will likewise also point to the different object--this does not happen in the pass-by-value case.</p>

<p>JavaScript does not pass by reference.  If you read closely, you will realize that all contrary opinions misunderstand what is meant by pass-by-value and they falsely conclude that the ability to update an object's data via the function parameter is synonymous to "pass-by-value".</p>

<p><strong>Object clone/copy</strong>: A new object is created and the original object's data is copied.  This can be a deep copy or shallow copy, but the point is that a new object is created.  Creating a copy of an object is a separate concept from pass-by-value.  Some languages distinguish between class object and structs (or the like), and may have different behavior for passing variables of the different types.  But JavaScript does not do anything like this automatically when passing object variables.  But the absence of automatic object cloning does not translate to pass-by-reference.</p>
    </div></div></div></div><div id="solution14" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 14</h1><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<blockquote>
  <p>sharing what I know of references in JavaScript</p>
</blockquote>

<p>In JavaScript, when assigning an object to a variable, the value assigned to the variable is a reference to the object:</p>

<p></p><div class="snippet" data-lang="js" data-hide="false" data-console="true" data-babel="false">
<div class="snippet-code">
<pre class="snippet-code-js lang-js s-code-block"><code class="hljs language-javascript"><span class="hljs-keyword">var</span> a = {
  <span class="hljs-attr">a</span>: <span class="hljs-number">1</span>,
  <span class="hljs-attr">b</span>: <span class="hljs-number">2</span>,
  <span class="hljs-attr">c</span>: <span class="hljs-number">3</span>
};
<span class="hljs-keyword">var</span> b = a;

<span class="hljs-comment">// b.c is referencing to a.c value</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(b.<span class="hljs-property">c</span>) <span class="hljs-comment">// Output: 3</span>
<span class="hljs-comment">// Changing value of b.c</span>
b.<span class="hljs-property">c</span> = <span class="hljs-number">4</span>
<span class="hljs-comment">// Also changes the value of a.c</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a.<span class="hljs-property">c</span>) <span class="hljs-comment">// Output: 4</span></code></pre>
<div class="snippet-result"><div class="snippet-ctas"><button type="button" class="s-btn s-btn__primary"><span class="icon-play-white _hover"></span><span> Run code snippet</span></button><input class="copySnippet s-btn s-btn__filled" type="button" value="Copy snippet to answer" style="display: none;"><button type="button" class="s-btn hideResults" style="display: none;">Hide results</button><div class="popout-code"><a class="snippet-expand-link">Expand snippet</a></div></div><div class="snippet-result-code" style="display: none;"><iframe name="sif5" sandbox="allow-forms allow-modals allow-scripts" class="snippet-box-edit snippet-box-result" frameborder="0"></iframe></div></div></div>
</div>
<p></p>
    </div></div></div></div><div id="solution15" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 15</h1><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<h2>JavaScript passes primitive types by value and object types by reference</h2>

<blockquote>
  <p>Now, people like to bicker endlessly about whether "pass by reference"
  is the correct way to describe what Java et al. actually do. The point
  is this:</p>
  
  <ol>
  <li>Passing an object does not copy the object.</li>
  <li>An object passed to a function can have its members modified by the function.</li>
  <li>A primitive value passed to a function cannot be modified by the function. A copy is made.</li>
  </ol>
  
  <p>In my book that's called passing by reference.</p>
</blockquote>

<p> <a href="https://www.quora.com/profile/Brian-Bi" rel="nofollow noreferrer">Brian Bi</a> - <a href="https://www.quora.com/Which-programming-languages-are-pass-by-reference#" rel="nofollow noreferrer">Which programming languages are pass by reference?</a></p>

<hr>

<h1>Update</h1>

<p>Here is a rebuttal to this:</p>

<p><a href="https://stackoverflow.com/a/7744623/5535245">There is no "pass by reference" available in JavaScript.</a></p>
    </div></div></div></div><div id="solution16" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 16</h1><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p><em>Observation: If there isn't any way for an observer to examine the underlying memory of the engine, there is no way to determine whether an immutable value gets copied or a reference gets passed.</em></p>
<p>JavaScript is more or less agnostic to the underlying memory model. There is no such thing as a <em>reference</em>². JavaScript has <em>values</em>. Two variables can hold the same <em>value</em> (or more accurate: two <em>environment records</em> can <em>bind</em> the same value). The only type of values that can be mutated are objects through their abstract [[Get]] and [[Set]] operations.
If you forget about computers and memory, this is all you need to describe JavaScript's behaviour, and it allows you to understand the specification.</p>
<pre class="lang-js s-code-block"><code class="hljs language-javascript"> <span class="hljs-keyword">let</span> a = { <span class="hljs-attr">prop</span>: <span class="hljs-number">1</span> };
 <span class="hljs-keyword">let</span> b = a; <span class="hljs-comment">// a and b hold the same value</span>
 a.<span class="hljs-property">prop</span> = <span class="hljs-string">"test"</span>; <span class="hljs-comment">// The object gets mutated, can be observed through both a and b</span>
 b = { <span class="hljs-attr">prop</span>: <span class="hljs-number">2</span> }; <span class="hljs-comment">// b holds now a different value</span>
</code></pre>
<p>Now you might ask yourself how two variables can hold the same value on a computer. You might then look into the source code of a JavaScript engine and you'll most likely find something which a programmer of the language the engine was written in would call a reference.</p>
<p>So in fact you can say that JavaScript is "pass by value", whereas the value can be shared, and you can say that JavaScript is "pass by reference", which might be a useful logical abstraction for programmers from low level languages, or you might call the behaviour "call by sharing".</p>
<p>As there is no such thing as a reference in JavaScript, all of these are neither wrong nor on point. Therefore I don't think the answer is particularly useful to search for.</p>
<p>² The term <em>Reference</em> in the specification is not a reference in the traditional sense. It is a container for an object and the name of a property, and it is an intermediate value (e.g., <code>a.b</code> evaluates to <code>Reference { value = a, name = "b" }</code>). The term <em>reference</em> also sometimes appears in the specification in unrelated sections.</p>
    </div></div></div></div><div id="solution17" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 17</h1><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Everything is passed by value.</p>
<p>Basic types are passed by value (i.e. a new copy of the actual variable value is passed to the function).</p>
<p>Complex types (objects) are passed as "pointer to the object". So the actual stuff you are passing is a pointer which is passed by value (it's an address, a numerical value like any other). Obviously if you try to modify a property of the object inside the function, the modification will be reflected even outside of such function. That's because you are accessing the property via the pointer which points to the unique copy of the property.</p>
<p>The confusion here has arises over "passing a pointer by value" and "passing an object by reference".</p>
    </div></div></div></div><div id="solution18" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 18</h1><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>My simple way to understand this...</p>

<ul>
<li><p>When calling a function, you are passing the content (reference or
value) of the argument variables, not the the variables themselves.</p>

<pre class="lang-js s-code-block"><code class="hljs language-javascript"><span class="hljs-keyword">var</span> var1 = <span class="hljs-number">13</span>;
<span class="hljs-keyword">var</span> var2 = { <span class="hljs-attr">prop</span>: <span class="hljs-number">2</span> };

<span class="hljs-comment">//13 and var2's content (reference) are being passed here</span>
<span class="hljs-title function_">foo</span>(var1, var2); 
</code></pre></li>
<li><p>Inside the function, parameter variables, <code>inVar1</code> and <code>inVar2</code>, receive the contents being passed.</p>

<pre class="lang-js s-code-block"><code class="hljs language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">inVar1, inVar2</span>){
    <span class="hljs-comment">//changing contents of inVar1 and inVar2 won't affect variables outside</span>
    inVar1 = <span class="hljs-number">20</span>;
    inVar2 = { <span class="hljs-attr">prop</span>: <span class="hljs-number">7</span> };
}
</code></pre></li>
<li><p>Since <code>inVar2</code> received the reference of <code>{ prop: 2 }</code>, you can change the value of the object's property.</p>

<pre class="lang-js s-code-block"><code class="hljs language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">inVar1, inVar2</span>){
    inVar2.<span class="hljs-property">prop</span> = <span class="hljs-number">7</span>; 
}
</code></pre></li>
</ul>
    </div></div></div></div><div id="solution19" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 19</h1><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>The MDN docs explain it clearly, without being too verbose:  </p>

<blockquote>
  <p>The parameters of a function call are the function's <em>arguments</em>.
  Arguments are passed to functions <em>by value</em>. If the function changes
  the value of an argument, this change is not reflected globally or in
  the calling function. However, object references are values, too, and
  they are special: if the function changes the referred object's
  properties, that change is visible outside the function, (...)</p>
</blockquote>

<p>Source: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions#Description" rel="nofollow noreferrer">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions#Description</a></p>
    </div></div></div></div><div id="solution20" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 20</h1><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Passing arguments to a function in JavaScript is analogous to passing
parameters by pointer value in C:</p>

<pre class="lang-js s-code-block"><code class="hljs language-javascript"><span class="hljs-comment">/*
The following C program demonstrates how arguments
to JavaScript functions are passed in a way analogous
to pass-by-pointer-value in C. The original JavaScript
test case by @Shog9 follows with the translation of
the code into C. This should make things clear to
those transitioning from C to JavaScript.

function changeStuff(num, obj1, obj2)
{
    num = num * 10;
    obj1.item = "changed";
    obj2 = {item: "changed"};
}

var num = 10;
var obj1 = {item: "unchanged"};
var obj2 = {item: "unchanged"};
changeStuff(num, obj1, obj2);
console.log(num);
console.log(obj1.item);    
console.log(obj2.item);

This produces the output:

10
changed
unchanged
*/</span>

#include &lt;stdio.<span class="hljs-property">h</span>&gt;
#include &lt;stdlib.<span class="hljs-property">h</span>&gt;

struct obj {
    char *item;
};

<span class="hljs-keyword">void</span> <span class="hljs-title function_">changeStuff</span>(<span class="hljs-params">int *num, struct obj *obj1, struct obj *obj2</span>)
{
    <span class="hljs-comment">// make pointer point to a new memory location</span>
    <span class="hljs-comment">// holding the new integer value</span>
    int *old_num = num;
    num = <span class="hljs-title function_">malloc</span>(<span class="hljs-title function_">sizeof</span>(int));
    *num = *old_num * <span class="hljs-number">10</span>;
    <span class="hljs-comment">// make property of structure pointed to by pointer</span>
    <span class="hljs-comment">// point to the new value</span>
    obj1-&gt;item = <span class="hljs-string">"changed"</span>;
    <span class="hljs-comment">// make pointer point to a new memory location</span>
    <span class="hljs-comment">// holding the new structure value</span>
    obj2 = <span class="hljs-title function_">malloc</span>(<span class="hljs-title function_">sizeof</span>(struct obj));
    obj2-&gt;item = <span class="hljs-string">"changed"</span>;
    <span class="hljs-title function_">free</span>(num); <span class="hljs-comment">// end of scope</span>
    <span class="hljs-title function_">free</span>(obj2); <span class="hljs-comment">// end of scope</span>
}

int num = <span class="hljs-number">10</span>;
struct obj obj1 = { <span class="hljs-string">"unchanged"</span> };
struct obj obj2 = { <span class="hljs-string">"unchanged"</span> };

int <span class="hljs-title function_">main</span>(<span class="hljs-params"></span>)
{
    <span class="hljs-comment">// pass pointers by value: the pointers</span>
    <span class="hljs-comment">// will be copied into the argument list</span>
    <span class="hljs-comment">// of the called function and the copied</span>
    <span class="hljs-comment">// pointers will point to the same values</span>
    <span class="hljs-comment">// as the original pointers</span>
    <span class="hljs-title function_">changeStuff</span>(&amp;num, &amp;obj1, &amp;obj2);
    <span class="hljs-title function_">printf</span>(<span class="hljs-string">"%d\n"</span>, num);
    <span class="hljs-title function_">puts</span>(obj1.<span class="hljs-property">item</span>);
    <span class="hljs-title function_">puts</span>(obj2.<span class="hljs-property">item</span>);
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>
    </div></div></div></div><div id="solution21" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 21</h1><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>For programming language lawyers, I've went through the following sections of ECMAScript 5.1 (which is easier to read than the latest edition), and go as far as <a href="https://esdiscuss.org/topic/are-the-values-of-objects-the-references-to-them" rel="nofollow noreferrer">asking</a> it on the ECMAScript mailing list.</p>
<p><b>TL;DR</b>: Everythings're passed by value, but properties of Objects are references, and the definition of Object is creepily lacking in the standard.</p>
<h1>Construction of Argument Lists</h1>
<p>Section 11.2.4 "Argument Lists" says the following on producing a argument list consisting of only 1 argument:</p>
<blockquote>
<p>The production ArgumentList : AssignmentExpression is evaluated as follows:</p>
<ol>
<li>Let ref be the result of evaluating AssignmentExpression.</li>
<li>Let arg be GetValue(ref).</li>
<li>Return a List whose sole item is arg.</li>
</ol>
</blockquote>
<p>The section also enumerate cases where argument list has 0 or &gt;1 arguments.</p>
<p>Thus, everything's are passed by reference.</p>
<h1>Access of Object Properties</h1>
<p>Section 11.2.1 "Property Accessors"</p>
<blockquote>
<p>The production MemberExpression : MemberExpression [ Expression ] is evaluated as follows:</p>
<ol>
<li>Let baseReference be the result of evaluating MemberExpression.</li>
<li>Let baseValue be GetValue(baseReference).</li>
<li>Let propertyNameReference be the result of evaluating Expression.</li>
<li>Let propertyNameValue be GetValue(propertyNameReference).</li>
<li>Call CheckObjectCoercible(baseValue).</li>
<li>Let propertyNameString be ToString(propertyNameValue).</li>
<li>If the syntactic production that is being evaluated is contained in strict mode code, let strict be true, else let
strict be false.</li>
<li><b>Return a value of type Reference</b> whose base value is baseValue and whose referenced name is
propertyNameString, and whose strict mode flag is strict.</li>
</ol>
</blockquote>
<p>Thus, properties of Objects are always available as reference.</p>
<h1>On Reference</h1>
<p>It is described in section 8.7 "The Reference Specification Type", that references are not real types in the language - they're only used to describe the behavior of the delete, the typeof, and the assignment operators.</p>
<h1>Definition of "Object"</h1>
<p>It is defined in 5.1 edition that "An Object is a collection of properties". Therefore, we can infer, that the value of the object is the collection, but as to what is the value of the collection is poorly defined in the spec, and requires a bit of <a href="https://stackoverflow.com/questions/45388408/where-is-the-mutability-of-objects-defined-in-ecmascript/45407589#45407589">effort</a> to understand.</p>
    </div></div></div></div><div id="solution22" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 22</h1><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>The most succinct explanation I found was in the <a href="https://github.com/airbnb/javascript#types" rel="nofollow">AirBNB style guide</a>:</p>

<ul>
<li><p><strong>Primitives</strong>: When you access a primitive type you work directly on its
value</p>

<ul>
<li>string</li>
<li>number</li>
<li>boolean</li>
<li>null</li>
<li>undefined</li>
</ul></li>
</ul>

<p>E.g.:</p>

<pre class="lang-js s-code-block"><code class="hljs language-javascript"><span class="hljs-keyword">var</span> foo = <span class="hljs-number">1</span>,
    bar = foo;

bar = <span class="hljs-number">9</span>;

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(foo, bar); <span class="hljs-comment">// =&gt; 1, 9</span>
</code></pre>

<ul>
<li><p><strong>Complex</strong>: When you access a complex type you work on a reference to its value</p>

<ul>
<li>object</li>
<li>array</li>
<li>function</li>
</ul></li>
</ul>

<p>E.g.:</p>

<pre class="lang-js s-code-block"><code class="hljs language-javascript"><span class="hljs-keyword">var</span> foo = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>],
    bar = foo;

bar[<span class="hljs-number">0</span>] = <span class="hljs-number">9</span>;

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(foo[<span class="hljs-number">0</span>], bar[<span class="hljs-number">0</span>]); <span class="hljs-comment">// =&gt; 9, 9</span>
</code></pre>

<p>I.e. effectively primitive types are passed by value, and complex types are passed by reference.</p>
    </div></div></div></div><div id="solution23" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 23</h1><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>I've read through these answers multiple times, but didn't REALLY get it until I learned about the technical definition of <a href="https://en.wikipedia.org/wiki/Evaluation_strategy#Call_by_sharing" rel="nofollow">"Call by sharing"</a> as termed by Barbara Liskov</p>

<blockquote>
  <p>The semantics of call by sharing differ from call by reference in that assignments to function arguments within the function aren't visible to the caller (unlike by reference semantics)[citation needed], so e.g. if a variable was passed, it is not possible to simulate an assignment on that variable in the caller's scope. However, since the function has access to the same object as the caller (no copy is made), mutations to those objects, if the objects are mutable, within the function are visible to the caller, which may appear to differ from call by value semantics. Mutations of a mutable object within the function are visible to the caller because the object is not copied or cloned  it is shared.</p>
</blockquote>

<p>That is, parameter references are alterable if you go and access the parameter value itself. On the other hand, assignment to a parameter will disappear after evaluation, and is non-accessible to the function caller.</p>
    </div></div></div></div><div id="solution24" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 24</h1><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>In a low-level language, if you want to pass a variable by reference, you have to use a specific syntax in the creation of the function:</p>
<pre class="lang-js s-code-block"><code class="hljs language-javascript">int myAge = <span class="hljs-number">14</span>;
<span class="hljs-title function_">increaseAgeByRef</span>(myAge);
<span class="hljs-keyword">function</span> <span class="hljs-title function_">increaseAgeByRef</span>(<span class="hljs-params">int &amp;age</span>) {
  *age = *age + <span class="hljs-number">1</span>;
}
</code></pre>
<p>The <code>&amp;age</code> is a reference to <code>myAge</code>, but if you want the value you have to convert the reference, using <code>*age</code>.</p>
<p>JavaScript is a high level language that does this conversion for you.</p>
<p>So, although objects are passed by reference, the language converts the reference parameter to the value. You don't need to use <code>&amp;</code>, on the function definition, to pass it by reference, neither <code>*</code>, on the function body, to convert the reference to the value, JavaScript does it for you.</p>
<p>That's why when you try to change an object inside a function, by replacing it's value (i.e. <code>age = {value:5}</code>), the change doesn't persist, but if you change it's properties (i.e. <code>age.value = 5</code>), it does.</p>
<p><a href="https://blog.penjee.com/passing-by-value-vs-by-reference-java-graphical/" rel="nofollow noreferrer">Learn more</a></p>
    </div></div></div></div><div id="solution25" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 25</h1><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>If you want (normal) function parameter behavior like in other languages (passing copy of a value)
then just clone the object before passing into a function:</p>
<pre class="lang-js s-code-block"><code class="hljs language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">run</span>(<span class="hljs-params"></span>)
{
    <span class="hljs-keyword">var</span> test = [];
    test.<span class="hljs-title function_">push</span>(<span class="hljs-number">1</span>);

    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'before: '</span>+test); <span class="hljs-comment">// 1</span>

    <span class="hljs-title function_">changeVariable</span>(_.<span class="hljs-title function_">clone</span>(test)); <span class="hljs-comment">// (Note: I am using lodash _.clone() function)</span>
 
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'after: '</span>+test); <span class="hljs-comment">// 1 </span>
}


<span class="hljs-keyword">function</span> <span class="hljs-title function_">changeVariable</span>(<span class="hljs-params">test2</span>) {
  <span class="hljs-keyword">var</span> test1 = test2;
  test1.<span class="hljs-title function_">push</span>(<span class="hljs-number">2</span>); 
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'inside func:'</span>, test1);  <span class="hljs-comment">// inside func: [1,2]</span>
}   


<span class="hljs-title function_">run</span>();    
</code></pre>
    </div></div></div></div><div id="solution26" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 26</h1><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>I have found the <a href="http://documentcloud.github.com/underscore/#extend" rel="nofollow">extend method</a> of the <a href="http://documentcloud.github.com/underscore" rel="nofollow">Underscore.js library</a> very useful when I want to pass in an object as a parameter which may either be modified or replaced entirely.</p>

<pre class="lang-js s-code-block"><code class="hljs language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">replaceOrModify</span>(<span class="hljs-params">aObj</span>) {
  <span class="hljs-keyword">if</span> (modify) {

    aObj.<span class="hljs-title function_">setNewValue</span>(<span class="hljs-string">'foo'</span>);

  } <span class="hljs-keyword">else</span> {

   <span class="hljs-keyword">var</span> newObj = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyObject</span>();
   <span class="hljs-comment">// _.extend(destination, *sources) </span>
   _.<span class="hljs-title function_">extend</span>(newObj, aObj);
  }
}
</code></pre>
    </div></div></div></div><div id="solution27" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 27</h1><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>I would say it is pass-by-copy -</p>

<p>Consider arguments and variable objects are objects created during the execution context created in the beginning of function invocation - and your actual value/reference passed into the function just get stored in this arguments + variable objects.</p>

<p>Simply speaking, for primitive types, the values get copied in the beginning of function call, for object type, the reference get copied.</p>
    </div></div></div></div><div id="solution28" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 28</h1><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<ol>
<li>primitive type variable like string,number are always pass as  pass
by value.</li>
<li><p>Array and Object is passed as  pass by reference or  pass by value based on these two condition.</p>

<ul>
<li><p>if you are changing value of that Object or array with new Object or Array then it is pass by Value.</p>

<p><code>object1 = {item: "car"};
  array1=[1,2,3];</code></p></li>
</ul>

<p>here you are assigning new object or array to old one.you are not changing the value of property 
of old object.so it is pass by value.</p>

<ul>
<li><p>if you are changing a property value of an object or array then it is pass by Reference.</p>

<p><code>object1.key1= "car";
  array1[0]=9;</code></p></li>
</ul>

<p>here you are changing a property value of old object.you are not assigning new object or array to old one.so it is pass by reference.</p></li>
</ol>

<p><strong>Code</strong></p>

<pre class="lang-js s-code-block"><code class="hljs language-javascript">    <span class="hljs-keyword">function</span> <span class="hljs-title function_">passVar</span>(<span class="hljs-params">object1, object2, number1</span>) {

        object1.<span class="hljs-property">key1</span>= <span class="hljs-string">"laptop"</span>;
        object2 = {
            <span class="hljs-attr">key2</span>: <span class="hljs-string">"computer"</span>
        };
        number1 = number1 + <span class="hljs-number">1</span>;
    }

    <span class="hljs-keyword">var</span> object1 = {
        <span class="hljs-attr">key1</span>: <span class="hljs-string">"car"</span>
    };
    <span class="hljs-keyword">var</span> object2 = {
        <span class="hljs-attr">key2</span>: <span class="hljs-string">"bike"</span>
    };
    <span class="hljs-keyword">var</span> number1 = <span class="hljs-number">10</span>;

    <span class="hljs-title function_">passVar</span>(object1, object2, number1);
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(object1.<span class="hljs-property">key1</span>);
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(object2.<span class="hljs-property">key2</span>);
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(number1);

<span class="hljs-title class_">Output</span>: -
    laptop
    bike
    <span class="hljs-number">10</span>
</code></pre>
    </div></div></div></div><div id="solution29" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 29</h1><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>An easy way to determine whether something is "pass by reference" is whether you can write a "swap" function. For example, in C, you can do:</p>

<pre class="lang-js s-code-block"><code class="hljs language-javascript"><span class="hljs-keyword">void</span> <span class="hljs-title function_">swap</span>(<span class="hljs-params">int *i, int *j</span>)
{
    int t;
    t = *i;
    *i = *j;
    *j = t;
}
</code></pre>

<p>If you can't do the equivalent of that in JavaScript, it is not "pass by reference".</p>
    </div></div></div></div><div id="solution30" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 30</h1><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<ol>
<li>Primitives (number, Boolean, etc.) are passed by value.

<ul>
<li>Strings are immutable, so it doesn't really matter for them.</li>
</ul></li>
<li>Objects are passed by reference (the reference is passed by value).</li>
</ol>
    </div></div></div></div></div></div><div class="widget"><a href="/questions/how-do-you-access-the-matched-groups-in-a-javascript-regular-expression-1657388233817">How do you access the matched groups in a JavaScript regular expression?</a><a href="/questions/how-to-use-java.util.scanner-to-correctly-read-user-input-from-system.in-and-act-on-it-1657388546306">How to use java.util.Scanner to correctly read user input from System.in and act on it?</a><a href="/questions/reference:-what-is-variable-scope-which-variables-are-accessible-from-where-and-what-are-%22undefined-variable%22-errors-1657384644697">Reference: What is variable scope, which variables are accessible from where and what are &quot;undefined variable&quot; errors?</a><a href="/questions/why-does-my-javascript-code-receive-a-%22no-&#x27;access-control-allow-origin&#x27;-header-is-present-on-the-requested-resource%22-error-while-postman-does-not-1657384636363">Why does my JavaScript code receive a &quot;No &#x27;Access-Control-Allow-Origin&#x27; header is present on the requested resource&quot; error, while Postman does not?</a><a href="/questions/how-to-extract-and-access-data-from-json-with-php-1657384483259">How to extract and access data from JSON with PHP?</a><a href="/questions/what-is-a-clearfix-1657387337825">What is a clearfix?</a><a href="/questions/disable-same-origin-policy-in-chrome-1657387743804">Disable same origin policy in Chrome</a><a href="/questions/web-scraping-javascript-page-with-python-1657388240875">Web-scraping JavaScript page with Python</a><a href="/questions/swing-gui-listeners-without-awt-1657387522426">Swing GUI listeners without AWT</a><a href="/questions/is-there-any-way-to-kill-a-thread-1657387859831">Is there any way to kill a Thread?</a><a href="/questions/why-do-we-always-prefer-using-parameters-in-sql-statements-1657388031476">Why do we always prefer using parameters in SQL statements?</a><a href="/questions/tkinter:-attributeerror:-nonetype-object-has-no-attribute-lessattribute-namegreater-1657385472410">Tkinter: AttributeError: NoneType object has no attribute &lt;attribute name&gt;</a><a href="/questions/how-can-i-access-and-process-nested-objects-arrays-or-json-1657384332823">How can I access and process nested objects, arrays, or JSON?</a><a href="/questions/how-does-access-control-allow-origin-header-work-1657384881723">How does Access-Control-Allow-Origin header work?</a><a href="/questions/how-do-i-give-text-or-an-image-a-transparent-background-using-css-1657388188508">How do I give text or an image a transparent background using CSS?</a><a href="/questions/addeventlistener-vs-onclick-1657388191429">addEventListener vs onclick</a><a href="/questions/simulating-group_concat-mysql-function-in-microsoft-sql-server-2005-1657384832169">Simulating group_concat MySQL function in Microsoft SQL Server 2005?</a><a href="/questions/what-special-characters-must-be-escaped-in-regular-expressions-1657387465381">What special characters must be escaped in regular expressions?</a><a href="/questions/what-is-object-slicing-1657384506425">What is object slicing?</a><a href="/questions/selenium-%22selenium.common.exceptions.nosuchelementexception%22-when-using-chrome-1657388136699">Selenium &quot;selenium.common.exceptions.NoSuchElementException&quot; when using Chrome</a></div></div><span class="cursor-pointer text-lg p-2" style="position:fixed;bottom:20px;left:20px;background:#000;z-index:2000;color:white">Go go top</span></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"data":{"answer":["\n\u0026lt;p\u0026gt;It\u0026apos;s interesting in JavaScript. Consider this example:\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;/p\u0026gt;\u0026lt;div class=\u0026quot;snippet\u0026quot; data-lang=\u0026quot;js\u0026quot; data-hide=\u0026quot;false\u0026quot; data-console=\u0026quot;true\u0026quot; data-babel=\u0026quot;false\u0026quot;\u0026gt;\n\u0026lt;div class=\u0026quot;snippet-code\u0026quot;\u0026gt;\n\u0026lt;pre class=\u0026quot;snippet-code-js lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;changeStuff\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;a, b, c\u0026lt;/span\u0026gt;)\n{\n  a = a * \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;10\u0026lt;/span\u0026gt;;\n  b.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;item\u0026lt;/span\u0026gt; = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;changed\u0026quot;\u0026lt;/span\u0026gt;;\n  c = {\u0026lt;span class=\u0026quot;hljs-attr\u0026quot;\u0026gt;item\u0026lt;/span\u0026gt;: \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;changed\u0026quot;\u0026lt;/span\u0026gt;};\n}\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; num = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;10\u0026lt;/span\u0026gt;;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; obj1 = {\u0026lt;span class=\u0026quot;hljs-attr\u0026quot;\u0026gt;item\u0026lt;/span\u0026gt;: \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;unchanged\u0026quot;\u0026lt;/span\u0026gt;};\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; obj2 = {\u0026lt;span class=\u0026quot;hljs-attr\u0026quot;\u0026gt;item\u0026lt;/span\u0026gt;: \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;unchanged\u0026quot;\u0026lt;/span\u0026gt;};\n\n\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;changeStuff\u0026lt;/span\u0026gt;(num, obj1, obj2);\n\n\u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;console\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;log\u0026lt;/span\u0026gt;(num);\n\u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;console\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;log\u0026lt;/span\u0026gt;(obj1.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;item\u0026lt;/span\u0026gt;);\n\u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;console\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;log\u0026lt;/span\u0026gt;(obj2.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;item\u0026lt;/span\u0026gt;);\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;div class=\u0026quot;snippet-result\u0026quot;\u0026gt;\u0026lt;div class=\u0026quot;snippet-ctas\u0026quot;\u0026gt;\u0026lt;button type=\u0026quot;button\u0026quot; class=\u0026quot;s-btn s-btn__primary\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;icon-play-white _hover\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;\u0026lt;span\u0026gt; Run code snippet\u0026lt;/span\u0026gt;\u0026lt;/button\u0026gt;\u0026lt;input class=\u0026quot;copySnippet s-btn s-btn__filled\u0026quot; type=\u0026quot;button\u0026quot; value=\u0026quot;Copy snippet to answer\u0026quot; style=\u0026quot;display: none;\u0026quot;\u0026gt;\u0026lt;button type=\u0026quot;button\u0026quot; class=\u0026quot;s-btn hideResults\u0026quot; style=\u0026quot;display: none;\u0026quot;\u0026gt;Hide results\u0026lt;/button\u0026gt;\u0026lt;div class=\u0026quot;popout-code\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;snippet-expand-link\u0026quot;\u0026gt;Expand snippet\u0026lt;/a\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;div class=\u0026quot;snippet-result-code\u0026quot; style=\u0026quot;display: none;\u0026quot;\u0026gt;\u0026lt;iframe name=\u0026quot;sif1\u0026quot; sandbox=\u0026quot;allow-forms allow-modals allow-scripts\u0026quot; class=\u0026quot;snippet-box-edit snippet-box-result\u0026quot; frameborder=\u0026quot;0\u0026quot;\u0026gt;\u0026lt;/iframe\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;/div\u0026gt;\n\u0026lt;/div\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;This produces the output:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-none s-code-block\u0026quot;\u0026gt;\u0026lt;code\u0026gt;10\nchanged\nunchanged\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;If \u0026lt;code\u0026gt;obj1\u0026lt;/code\u0026gt; was not a reference at all, then changing \u0026lt;code\u0026gt;obj1.item\u0026lt;/code\u0026gt; would have no effect on the \u0026lt;code\u0026gt;obj1\u0026lt;/code\u0026gt; outside of the function.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;If the argument was a proper reference, then everything would have changed. \u0026lt;code\u0026gt;num\u0026lt;/code\u0026gt; would be \u0026lt;code\u0026gt;100\u0026lt;/code\u0026gt;, and \u0026lt;code\u0026gt;obj2.item\u0026lt;/code\u0026gt; would read \u0026lt;code\u0026gt;\u0026quot;changed\u0026quot;\u0026lt;/code\u0026gt;. Instead, \u0026lt;code\u0026gt;num\u0026lt;/code\u0026gt; stays \u0026lt;code\u0026gt;10\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;obj2.item\u0026lt;/code\u0026gt; remains \u0026lt;code\u0026gt;\u0026quot;unchanged\u0026lt;/code\u0026gt;\u0026quot;.\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;p\u0026gt;Instead, the situation is that the item passed in is passed by value. But the item that is passed by value is \u0026lt;em\u0026gt;itself\u0026lt;/em\u0026gt; a reference.\nTechnically, this is called \u0026lt;a href=\u0026quot;http://en.wikipedia.org/wiki/Evaluation_strategy#Call_by_sharing\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;call-by-sharing\u0026lt;/a\u0026gt;.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;In practical terms, this means that if you change the parameter itself (as with \u0026lt;code\u0026gt;num\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;obj2\u0026lt;/code\u0026gt;), that won\u0026apos;t affect the item that was fed into the parameter. But if you change the \u0026lt;em\u0026gt;internals\u0026lt;/em\u0026gt; of the parameter, that will propagate back up (as with \u0026lt;code\u0026gt;obj1\u0026lt;/code\u0026gt;).\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;It\u0026apos;s always pass by value, but for objects the value of the variable is a reference.  Because of this, when you pass an object and change its \u0026lt;em\u0026gt;members\u0026lt;/em\u0026gt;, those changes persist outside of the function.  This makes it \u0026lt;em\u0026gt;look\u0026lt;/em\u0026gt; like pass by reference.  But if you actually change the value of the object variable you will see that the change does not persist, proving it\u0026apos;s really pass by value.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Example:\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;/p\u0026gt;\u0026lt;div class=\u0026quot;snippet\u0026quot; data-lang=\u0026quot;js\u0026quot; data-hide=\u0026quot;false\u0026quot; data-console=\u0026quot;true\u0026quot; data-babel=\u0026quot;false\u0026quot;\u0026gt;\n\u0026lt;div class=\u0026quot;snippet-code\u0026quot;\u0026gt;\n\u0026lt;pre class=\u0026quot;snippet-code-js lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;changeObject\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;x\u0026lt;/span\u0026gt;) {\n  x = { \u0026lt;span class=\u0026quot;hljs-attr\u0026quot;\u0026gt;member\u0026lt;/span\u0026gt;: \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;bar\u0026quot;\u0026lt;/span\u0026gt; };\n  \u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;console\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;log\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;in changeObject: \u0026quot;\u0026lt;/span\u0026gt; + x.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;member\u0026lt;/span\u0026gt;);\n}\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;changeMember\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;x\u0026lt;/span\u0026gt;) {\n  x.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;member\u0026lt;/span\u0026gt; = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;bar\u0026quot;\u0026lt;/span\u0026gt;;\n  \u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;console\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;log\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;in changeMember: \u0026quot;\u0026lt;/span\u0026gt; + x.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;member\u0026lt;/span\u0026gt;);\n}\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; x = { \u0026lt;span class=\u0026quot;hljs-attr\u0026quot;\u0026gt;member\u0026lt;/span\u0026gt;: \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;foo\u0026quot;\u0026lt;/span\u0026gt; };\n\n\u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;console\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;log\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;before changeObject: \u0026quot;\u0026lt;/span\u0026gt; + x.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;member\u0026lt;/span\u0026gt;);\n\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;changeObject\u0026lt;/span\u0026gt;(x);\n\u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;console\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;log\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;after changeObject: \u0026quot;\u0026lt;/span\u0026gt; + x.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;member\u0026lt;/span\u0026gt;); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;/* change did not persist */\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;console\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;log\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;before changeMember: \u0026quot;\u0026lt;/span\u0026gt; + x.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;member\u0026lt;/span\u0026gt;);\n\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;changeMember\u0026lt;/span\u0026gt;(x);\n\u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;console\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;log\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;after changeMember: \u0026quot;\u0026lt;/span\u0026gt; + x.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;member\u0026lt;/span\u0026gt;); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;/* change persists */\u0026lt;/span\u0026gt;\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;div class=\u0026quot;snippet-result\u0026quot;\u0026gt;\u0026lt;div class=\u0026quot;snippet-ctas\u0026quot;\u0026gt;\u0026lt;button type=\u0026quot;button\u0026quot; class=\u0026quot;s-btn s-btn__primary\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;icon-play-white _hover\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;\u0026lt;span\u0026gt; Run code snippet\u0026lt;/span\u0026gt;\u0026lt;/button\u0026gt;\u0026lt;input class=\u0026quot;copySnippet s-btn s-btn__filled\u0026quot; type=\u0026quot;button\u0026quot; value=\u0026quot;Copy snippet to answer\u0026quot; style=\u0026quot;display: none;\u0026quot;\u0026gt;\u0026lt;button type=\u0026quot;button\u0026quot; class=\u0026quot;s-btn hideResults\u0026quot; style=\u0026quot;display: none;\u0026quot;\u0026gt;Hide results\u0026lt;/button\u0026gt;\u0026lt;div class=\u0026quot;popout-code\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;snippet-expand-link\u0026quot;\u0026gt;Expand snippet\u0026lt;/a\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;div class=\u0026quot;snippet-result-code\u0026quot; style=\u0026quot;display: none;\u0026quot;\u0026gt;\u0026lt;iframe name=\u0026quot;sif2\u0026quot; sandbox=\u0026quot;allow-forms allow-modals allow-scripts\u0026quot; class=\u0026quot;snippet-box-edit snippet-box-result\u0026quot; frameborder=\u0026quot;0\u0026quot;\u0026gt;\u0026lt;/iframe\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;/div\u0026gt;\n\u0026lt;/div\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Output:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;before \u0026lt;span class=\u0026quot;hljs-attr\u0026quot;\u0026gt;changeObject\u0026lt;/span\u0026gt;: foo\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;in\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-attr\u0026quot;\u0026gt;changeObject\u0026lt;/span\u0026gt;: bar\nafter \u0026lt;span class=\u0026quot;hljs-attr\u0026quot;\u0026gt;changeObject\u0026lt;/span\u0026gt;: foo\n\nbefore \u0026lt;span class=\u0026quot;hljs-attr\u0026quot;\u0026gt;changeMember\u0026lt;/span\u0026gt;: foo\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;in\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-attr\u0026quot;\u0026gt;changeMember\u0026lt;/span\u0026gt;: bar\nafter \u0026lt;span class=\u0026quot;hljs-attr\u0026quot;\u0026gt;changeMember\u0026lt;/span\u0026gt;: bar\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;The variable doesn\u0026apos;t \u0026quot;hold\u0026quot; the object; it holds a reference. You can assign that reference to another variable, and now both reference the same object. It\u0026apos;s always pass by value (even when that value is a reference...).\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;There\u0026apos;s no way to alter the value held by a variable passed as a parameter, which would be possible if JavaScript supported passing by reference.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;My two cents... This is the way I understand it. (Feel free to correct me if I\u0026apos;m wrong)\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;It\u0026apos;s time to throw out everything you know about pass by value / reference.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Because in JavaScript, it doesn\u0026apos;t matter whether it\u0026apos;s passed by value or by reference or whatever.\nWhat matters is mutation vs assignment of the parameters passed into a function.\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;OK, let me do my best to explain what I mean. Let\u0026apos;s say you have a few objects.\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; object1 = {};\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; object2 = {};\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;What we have done is \u0026quot;assignment\u0026quot;... We\u0026apos;ve assigned 2 separate empty objects to the variables \u0026quot;object1\u0026quot; and \u0026quot;object2\u0026quot;.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Now, let\u0026apos;s say that we like object1 better... So, we \u0026quot;assign\u0026quot; a new variable.\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; favoriteObject = object1;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;Next, for whatever reason, we decide that we like object 2 better. So, we do a little re-assignment.\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;favoriteObject = object2;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;Nothing happened to object1 or to object2. We haven\u0026apos;t changed any data at all. All we did was re-assign what our favorite object is. It is important to know that object2 and favoriteObject are both assigned to the same object. We can change that object via either of those variables.\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;object2.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;name\u0026lt;/span\u0026gt; = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;Fred\u0026apos;\u0026lt;/span\u0026gt;;\n\u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;console\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;log\u0026lt;/span\u0026gt;(favoriteObject.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;name\u0026lt;/span\u0026gt;) \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Logs Fred\u0026lt;/span\u0026gt;\nfavoriteObject.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;name\u0026lt;/span\u0026gt; = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;Joe\u0026apos;\u0026lt;/span\u0026gt;;\n\u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;console\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;log\u0026lt;/span\u0026gt;(object2.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;name\u0026lt;/span\u0026gt;); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Logs Joe\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;OK, now let\u0026apos;s look at primitives like strings for example\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; string1 = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;Hello world\u0026apos;\u0026lt;/span\u0026gt;;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; string2 = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;Goodbye world\u0026apos;\u0026lt;/span\u0026gt;;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;Again, we pick a favorite.\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; favoriteString = string1;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;Both our favoriteString and string1 variables are assigned to \u0026apos;Hello world\u0026apos;. Now, what if we want to change our favoriteString??? What will happen???\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;favoriteString = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;Hello everyone\u0026apos;\u0026lt;/span\u0026gt;;\n\u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;console\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;log\u0026lt;/span\u0026gt;(favoriteString); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Logs \u0026apos;Hello everyone\u0026apos;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;console\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;log\u0026lt;/span\u0026gt;(string1); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Logs \u0026apos;Hello world\u0026apos;\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;Uh oh.... What has happened. We couldn\u0026apos;t change string1 by changing favoriteString... Why?? Because we didn\u0026apos;t \u0026lt;em\u0026gt;change\u0026lt;/em\u0026gt; our string \u0026lt;em\u0026gt;object\u0026lt;/em\u0026gt;. All we did was \u0026quot;RE ASSIGN\u0026quot; the favoriteString \u0026lt;em\u0026gt;variable\u0026lt;/em\u0026gt; to a new string. This essentially disconnected it from string1. In the previous example, when we renamed our object, we didn\u0026apos;t assign anything. (Well, not to the \u0026lt;em\u0026gt;variable itself\u0026lt;/em\u0026gt;, ... we did, however, assign the name property to a new string.) Instead, we mutated the object which keeps the connections between the 2 variables and the underlying objects. (Even if we had wanted to modify or \u0026lt;em\u0026gt;mutate\u0026lt;/em\u0026gt; the string object \u0026lt;em\u0026gt;itself\u0026lt;/em\u0026gt;, we couldn\u0026apos;t have, because strings are actually immutable in JavaScript.)\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Now, on to functions and passing parameters.... When you call a function, and pass a parameter, what you are essentially doing is an \u0026quot;assignment\u0026quot; to a new variable, and it works exactly the same as if you assigned using the equal (=) sign.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Take these examples.\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; myString = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;hello\u0026apos;\u0026lt;/span\u0026gt;;\n\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Assign to a new variable (just like when you pass to a function)\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; param1 = myString;\nparam1 = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;world\u0026apos;\u0026lt;/span\u0026gt;; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Re assignment\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;console\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;log\u0026lt;/span\u0026gt;(myString); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Logs \u0026apos;hello\u0026apos;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;console\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;log\u0026lt;/span\u0026gt;(param1);   \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Logs \u0026apos;world\u0026apos;\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;Now, the same thing, but with a function\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;myFunc\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;param1\u0026lt;/span\u0026gt;) {\n    param1 = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;world\u0026apos;\u0026lt;/span\u0026gt;;\n\n    \u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;console\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;log\u0026lt;/span\u0026gt;(param1);   \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Logs \u0026apos;world\u0026apos;\u0026lt;/span\u0026gt;\n}\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; myString = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;hello\u0026apos;\u0026lt;/span\u0026gt;;\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Calls myFunc and assigns param1 to myString just like param1 = myString\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;myFunc\u0026lt;/span\u0026gt;(myString);\n\n\u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;console\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;log\u0026lt;/span\u0026gt;(myString); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// logs \u0026apos;hello\u0026apos;\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;OK, now lets give a few examples using objects instead... first, without the function.\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; myObject = {\n    \u0026lt;span class=\u0026quot;hljs-attr\u0026quot;\u0026gt;firstName\u0026lt;/span\u0026gt;: \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;Joe\u0026apos;\u0026lt;/span\u0026gt;,\n    \u0026lt;span class=\u0026quot;hljs-attr\u0026quot;\u0026gt;lastName\u0026lt;/span\u0026gt;: \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;Smith\u0026apos;\u0026lt;/span\u0026gt;\n};\n\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Assign to a new variable (just like when you pass to a function)\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; otherObj = myObject;\n\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Let\u0026apos;s mutate our object\u0026lt;/span\u0026gt;\notherObj.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;firstName\u0026lt;/span\u0026gt; = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;Sue\u0026apos;\u0026lt;/span\u0026gt;; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// I guess Joe decided to be a girl\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;console\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;log\u0026lt;/span\u0026gt;(myObject.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;firstName\u0026lt;/span\u0026gt;); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Logs \u0026apos;Sue\u0026apos;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;console\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;log\u0026lt;/span\u0026gt;(otherObj.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;firstName\u0026lt;/span\u0026gt;); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Logs \u0026apos;Sue\u0026apos;\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Now, let\u0026apos;s reassign the variable\u0026lt;/span\u0026gt;\notherObj = {\n    \u0026lt;span class=\u0026quot;hljs-attr\u0026quot;\u0026gt;firstName\u0026lt;/span\u0026gt;: \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;Jack\u0026apos;\u0026lt;/span\u0026gt;,\n    \u0026lt;span class=\u0026quot;hljs-attr\u0026quot;\u0026gt;lastName\u0026lt;/span\u0026gt;: \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;Frost\u0026apos;\u0026lt;/span\u0026gt;\n};\n\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Now, otherObj and myObject are assigned to 2 very different objects\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// And mutating one object has no influence on the other\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;console\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;log\u0026lt;/span\u0026gt;(myObject.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;firstName\u0026lt;/span\u0026gt;); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Logs \u0026apos;Sue\u0026apos;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;console\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;log\u0026lt;/span\u0026gt;(otherObj.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;firstName\u0026lt;/span\u0026gt;); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Logs \u0026apos;Jack\u0026apos;;\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;Now, the same thing, but with a function call\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;myFunc\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;otherObj\u0026lt;/span\u0026gt;) {\n\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Let\u0026apos;s mutate our object\u0026lt;/span\u0026gt;\n    otherObj.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;firstName\u0026lt;/span\u0026gt; = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;Sue\u0026apos;\u0026lt;/span\u0026gt;;\n    \u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;console\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;log\u0026lt;/span\u0026gt;(otherObj.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;firstName\u0026lt;/span\u0026gt;); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Logs \u0026apos;Sue\u0026apos;\u0026lt;/span\u0026gt;\n\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Now let\u0026apos;s re-assign\u0026lt;/span\u0026gt;\n    otherObj = {\n        \u0026lt;span class=\u0026quot;hljs-attr\u0026quot;\u0026gt;firstName\u0026lt;/span\u0026gt;: \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;Jack\u0026apos;\u0026lt;/span\u0026gt;,\n        \u0026lt;span class=\u0026quot;hljs-attr\u0026quot;\u0026gt;lastName\u0026lt;/span\u0026gt;: \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;Frost\u0026apos;\u0026lt;/span\u0026gt;\n    };\n    \u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;console\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;log\u0026lt;/span\u0026gt;(otherObj.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;firstName\u0026lt;/span\u0026gt;); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Logs \u0026apos;Jack\u0026apos;\u0026lt;/span\u0026gt;\n\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Again, otherObj and myObject are assigned to 2 very different objects\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// And mutating one object doesn\u0026apos;t magically mutate the other\u0026lt;/span\u0026gt;\n}\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; myObject = {\n    \u0026lt;span class=\u0026quot;hljs-attr\u0026quot;\u0026gt;firstName\u0026lt;/span\u0026gt;: \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;Joe\u0026apos;\u0026lt;/span\u0026gt;,\n    \u0026lt;span class=\u0026quot;hljs-attr\u0026quot;\u0026gt;lastName\u0026lt;/span\u0026gt;: \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;Smith\u0026apos;\u0026lt;/span\u0026gt;\n};\n\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Calls myFunc and assigns otherObj to myObject just like otherObj = myObject\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;myFunc\u0026lt;/span\u0026gt;(myObject);\n\n\u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;console\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;log\u0026lt;/span\u0026gt;(myObject.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;firstName\u0026lt;/span\u0026gt;); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Logs \u0026apos;Sue\u0026apos;, just like before\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;OK, if you read through this entire post, perhaps you now have a better understanding of how function calls work in JavaScript. It doesn\u0026apos;t matter whether something is passed by reference or by value... What matters is assignment vs mutation.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Every time you pass a variable to a function, you are \u0026quot;Assigning\u0026quot; to whatever the name of the parameter variable is, just like if you used the equal (=) sign.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Always remember that the equals sign (=) means assignment.\nAlways remember that passing a parameter to a function \u0026lt;em\u0026gt;in JavaScript\u0026lt;/em\u0026gt; also means assignment.\nThey are the same and the 2 variables are connected in exactly the same way (which is to say they aren\u0026apos;t, unless you count that they are assigned to the same object).\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;The only time that \u0026quot;modifying a variable\u0026quot; affects a different variable is when the underlying object is mutated (in which case you haven\u0026apos;t modified the variable, but the object itself.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;There is no point in making a distinction between objects and primitives, because it works the same exact way as if you didn\u0026apos;t have a function and just used the equal sign to assign to a new variable.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;The only gotcha is when the name of the variable you pass into the function is the same as the name of the function parameter. When this happens, you have to treat the parameter inside the function as if it was a whole new variable private to the function (because it is)\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;myFunc\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;myString\u0026lt;/span\u0026gt;) {\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// myString is private and does not affect the outer variable\u0026lt;/span\u0026gt;\n    myString = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;hello\u0026apos;\u0026lt;/span\u0026gt;;\n}\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; myString = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;test\u0026apos;\u0026lt;/span\u0026gt;;\nmyString = myString; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Does nothing, myString is still \u0026apos;test\u0026apos;;\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;myFunc\u0026lt;/span\u0026gt;(myString);\n\u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;console\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;log\u0026lt;/span\u0026gt;(myString); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Logs \u0026apos;test\u0026apos;\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\n\u0026lt;p\u0026gt;These phrases/concepts were originally defined long before JS was created and they don\u0026apos;t accurately describe the semantics for javascript. I think trying to apply them to JS causes more confusion than not.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;So don\u0026apos;t get hung up on \u0026quot;pass by reference/value\u0026quot;.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Consider the following:\u0026lt;/p\u0026gt;\n\u0026lt;ol\u0026gt;\n\u0026lt;li\u0026gt;Variables are \u0026lt;em\u0026gt;pointers\u0026lt;/em\u0026gt; to values.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Reassigning a variable merely points that pointer at a new value.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Reassigning a variable will never affect other variables that were pointing at that same object because each variable has its own pointer.\u0026lt;/li\u0026gt;\n\u0026lt;/ol\u0026gt;\n\u0026lt;p\u0026gt;So if I had to give it a name I\u0026apos;d say \u0026lt;strong\u0026gt;\u0026quot;pass-by-pointer\u0026quot;\u0026lt;/strong\u0026gt; -- we don\u0026apos;t deal with pointers in JS but the underlying engine does.\u0026lt;/p\u0026gt;\n\u0026lt;br\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// code\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; obj = {\n    \u0026lt;span class=\u0026quot;hljs-attr\u0026quot;\u0026gt;name\u0026lt;/span\u0026gt;: \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;Fred\u0026apos;\u0026lt;/span\u0026gt;,\n    \u0026lt;span class=\u0026quot;hljs-attr\u0026quot;\u0026gt;num\u0026lt;/span\u0026gt;: \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;\n};\n\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// illustration\u0026lt;/span\u0026gt;\n               \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;Fred\u0026apos;\u0026lt;/span\u0026gt;\n              /\n             /\n(obj) ---- {}\n             \\\n              \\\n               \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;br\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// code\u0026lt;/span\u0026gt;\nobj.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;name\u0026lt;/span\u0026gt; = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;George\u0026apos;\u0026lt;/span\u0026gt;;\n\n\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// illustration\u0026lt;/span\u0026gt;\n                 \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;Fred\u0026apos;\u0026lt;/span\u0026gt;\n\n\n(obj) ---- {} ----- \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;George\u0026apos;\u0026lt;/span\u0026gt;\n             \\\n              \\\n               \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;br\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// code\u0026lt;/span\u0026gt;\nobj = {};\n\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// illustration\u0026lt;/span\u0026gt;\n                 \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;Fred\u0026apos;\u0026lt;/span\u0026gt;\n\n\n(obj)      {} ----- \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;George\u0026apos;\u0026lt;/span\u0026gt;\n  |          \\\n  |           \\\n { }            \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;br\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// code\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; obj = {\n    \u0026lt;span class=\u0026quot;hljs-attr\u0026quot;\u0026gt;text\u0026lt;/span\u0026gt;: \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;Hello world!\u0026apos;\u0026lt;/span\u0026gt;\n};\n\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;/* function parameters get their own pointer to \n * the arguments that are passed in, just like any other variable */\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;someFunc\u0026lt;/span\u0026gt;(obj);\n\n\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// illustration\u0026lt;/span\u0026gt;\n(caller scope)        (someFunc scope)\n           \\             /\n            \\           /\n             \\         /\n              \\       /\n               \\     /\n                 { }\n                  |\n                  |\n                  |\n            \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;Hello world\u0026apos;\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;Some final comments:\u0026lt;/p\u0026gt;\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;The phrases \u0026quot;pass by value/reference\u0026quot; are only used to describe the \u0026lt;em\u0026gt;behavior\u0026lt;/em\u0026gt; of a language, not necessarily the actual underlying implementation. As a result of this abstraction, critical details that are essential for a decent explanation are lost, which inevitably leads to the current situation where a single term doesn\u0026apos;t adequately describe the actual behavior without additional info.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;It\u0026apos;s tempting to think that \u0026lt;em\u0026gt;primitives\u0026lt;/em\u0026gt; are enforced by special rules while \u0026lt;em\u0026gt;objects\u0026lt;/em\u0026gt; are not, but primitives are simply the end of the pointer chain.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;As a final example, consider why a common attempt to clear an array doesn\u0026apos;t work as expected.\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;/p\u0026gt;\u0026lt;div class=\u0026quot;snippet\u0026quot; data-lang=\u0026quot;js\u0026quot; data-hide=\u0026quot;false\u0026quot; data-console=\u0026quot;true\u0026quot; data-babel=\u0026quot;false\u0026quot;\u0026gt;\n\u0026lt;div class=\u0026quot;snippet-code\u0026quot;\u0026gt;\n\u0026lt;pre class=\u0026quot;snippet-code-js lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; a = [\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;];\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; b = a;\n\na = [];\n\u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;console\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;log\u0026lt;/span\u0026gt;(b); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// [1,2]\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// doesn\u0026apos;t work because `b` is still pointing at the original array\u0026lt;/span\u0026gt;\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;div class=\u0026quot;snippet-result\u0026quot;\u0026gt;\u0026lt;div class=\u0026quot;snippet-ctas\u0026quot;\u0026gt;\u0026lt;button type=\u0026quot;button\u0026quot; class=\u0026quot;s-btn s-btn__primary\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;icon-play-white _hover\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;\u0026lt;span\u0026gt; Run code snippet\u0026lt;/span\u0026gt;\u0026lt;/button\u0026gt;\u0026lt;input class=\u0026quot;copySnippet s-btn s-btn__filled\u0026quot; type=\u0026quot;button\u0026quot; value=\u0026quot;Copy snippet to answer\u0026quot; style=\u0026quot;display: none;\u0026quot;\u0026gt;\u0026lt;button type=\u0026quot;button\u0026quot; class=\u0026quot;s-btn hideResults\u0026quot; style=\u0026quot;display: none;\u0026quot;\u0026gt;Hide results\u0026lt;/button\u0026gt;\u0026lt;div class=\u0026quot;popout-code\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;snippet-expand-link\u0026quot;\u0026gt;Expand snippet\u0026lt;/a\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;div class=\u0026quot;snippet-result-code\u0026quot; style=\u0026quot;display: none;\u0026quot;\u0026gt;\u0026lt;iframe name=\u0026quot;sif3\u0026quot; sandbox=\u0026quot;allow-forms allow-modals allow-scripts\u0026quot; class=\u0026quot;snippet-box-edit snippet-box-result\u0026quot; frameborder=\u0026quot;0\u0026quot;\u0026gt;\u0026lt;/iframe\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;/div\u0026gt;\n\u0026lt;/div\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;An object outside a function is passed into a function by giving a reference to the outside object.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;When you use that reference to manipulate its object, the object outside is thus affected. However, if inside the function you decided to point the reference to something else, you did not affect the object outside at all, because all you did was re-direct the reference to something else. \u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Think of it like this: It\u0026apos;s always pass by value. However, the value of an object is not the object itself, but a reference to that object. \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Here is an example, passing a number (a primitive type)\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;changePrimitive\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;val\u0026lt;/span\u0026gt;) {\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// At this point there are two \u0026apos;10\u0026apos;s in memory.\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Changing one won\u0026apos;t affect the other\u0026lt;/span\u0026gt;\n    val = val * \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;10\u0026lt;/span\u0026gt;;\n}\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; x = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;10\u0026lt;/span\u0026gt;;\n\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;changePrimitive\u0026lt;/span\u0026gt;(x);\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// x === 10\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Repeating this with an object yields different results:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;changeObject\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;obj\u0026lt;/span\u0026gt;) {\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// At this point there are two references (x and obj) in memory,\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// but these both point to the same object.\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// changing the object will change the underlying object that\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// x and obj both hold a reference to.\u0026lt;/span\u0026gt;\n    obj.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;val\u0026lt;/span\u0026gt; = obj.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;val\u0026lt;/span\u0026gt; * \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;10\u0026lt;/span\u0026gt;;\n}\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; x = { \u0026lt;span class=\u0026quot;hljs-attr\u0026quot;\u0026gt;val\u0026lt;/span\u0026gt;: \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;10\u0026lt;/span\u0026gt; };\n\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;changeObject\u0026lt;/span\u0026gt;(x);\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// x === { val: 100 }\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;One more example:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;changeObject\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;obj\u0026lt;/span\u0026gt;) {\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Again there are two references (x and obj) in memory,\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// these both point to the same object.\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// now we create a completely new object and assign it.\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// obj\u0026apos;s reference now points to the new object.\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// x\u0026apos;s reference doesn\u0026apos;t change.\u0026lt;/span\u0026gt;\n    obj = { \u0026lt;span class=\u0026quot;hljs-attr\u0026quot;\u0026gt;val\u0026lt;/span\u0026gt;: \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;100\u0026lt;/span\u0026gt; };\n}\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; x = { \u0026lt;span class=\u0026quot;hljs-attr\u0026quot;\u0026gt;val\u0026lt;/span\u0026gt;: \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;10\u0026lt;/span\u0026gt; };\n\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;changeObject\u0026lt;/span\u0026gt;(x);\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// x === { val: 10}\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;A very detailed explanation about copying, passing and comparing by value and by reference is in \u0026lt;a href=\u0026quot;http://docstore.mik.ua/orelly/webprog/jscript/ch11_02.htm\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;this chapter\u0026lt;/a\u0026gt; of the \u0026lt;em\u0026gt;\u0026quot;JavaScript: The Definitive Guide\u0026quot;\u0026lt;/em\u0026gt; book.\u0026lt;/p\u0026gt;\n\u0026lt;blockquote\u0026gt;\n\u0026lt;p\u0026gt;Before we leave the topic of\nmanipulating objects and arrays by\nreference, we need to clear up a point\nof nomenclature.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;The phrase \u0026quot;pass by\nreference\u0026quot; can have several meanings.\nTo some readers, the phrase refers to\na function invocation technique that\nallows a function to assign new values\nto its arguments and to have those\nmodified values visible outside the\nfunction. This is not the way the term\nis used in this book.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Here, we mean\nsimply that a reference to an object\nor array -- not the object itself --\nis passed to a function. A function\ncan use the reference to modify\nproperties of the object or elements\nof the array. But if the function\noverwrites the reference with a\nreference to a new object or array,\nthat modification is not visible\noutside of the function.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Readers\nfamiliar with the other meaning of\nthis term may prefer to say that\nobjects and arrays are passed by\nvalue, but the value that is passed is\nactually a reference rather than the\nobject itself.\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n    ","\n\u0026lt;p\u0026gt;JavaScript is always \u0026lt;em\u0026gt;pass-by-value\u0026lt;/em\u0026gt;; everything is of value type.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Objects are values, and member functions of objects are values themselves (remember that functions are first-class objects in JavaScript). Also, regarding the concept that everything in JavaScript is an \u0026lt;em\u0026gt;object\u0026lt;/em\u0026gt;; this is wrong. Strings, symbols, numbers, booleans, nulls, and undefineds are \u0026lt;em\u0026gt;primitives\u0026lt;/em\u0026gt;.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;On occasion they can leverage some member functions and properties inherited from their base prototypes, but this is only for convenience. It does not mean that they are objects themselves. Try the following for reference:\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;/p\u0026gt;\u0026lt;div class=\u0026quot;snippet\u0026quot; data-lang=\u0026quot;js\u0026quot; data-hide=\u0026quot;false\u0026quot; data-console=\u0026quot;true\u0026quot; data-babel=\u0026quot;false\u0026quot;\u0026gt;\n\u0026lt;div class=\u0026quot;snippet-code\u0026quot;\u0026gt;\n\u0026lt;pre class=\u0026quot;snippet-code-js lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;x = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;test\u0026quot;\u0026lt;/span\u0026gt;;\n\u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;console\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;log\u0026lt;/span\u0026gt;(x.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;foo\u0026lt;/span\u0026gt;);\nx.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;foo\u0026lt;/span\u0026gt; = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;12\u0026lt;/span\u0026gt;;\n\u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;console\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;log\u0026lt;/span\u0026gt;(x.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;foo\u0026lt;/span\u0026gt;);\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;div class=\u0026quot;snippet-result\u0026quot;\u0026gt;\u0026lt;div class=\u0026quot;snippet-ctas\u0026quot;\u0026gt;\u0026lt;button type=\u0026quot;button\u0026quot; class=\u0026quot;s-btn s-btn__primary\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;icon-play-white _hover\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;\u0026lt;span\u0026gt; Run code snippet\u0026lt;/span\u0026gt;\u0026lt;/button\u0026gt;\u0026lt;input class=\u0026quot;copySnippet s-btn s-btn__filled\u0026quot; type=\u0026quot;button\u0026quot; value=\u0026quot;Copy snippet to answer\u0026quot; style=\u0026quot;display: none;\u0026quot;\u0026gt;\u0026lt;button type=\u0026quot;button\u0026quot; class=\u0026quot;s-btn hideResults\u0026quot; style=\u0026quot;display: none;\u0026quot;\u0026gt;Hide results\u0026lt;/button\u0026gt;\u0026lt;div class=\u0026quot;popout-code\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;snippet-expand-link\u0026quot;\u0026gt;Expand snippet\u0026lt;/a\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;div class=\u0026quot;snippet-result-code\u0026quot; style=\u0026quot;display: none;\u0026quot;\u0026gt;\u0026lt;iframe name=\u0026quot;sif4\u0026quot; sandbox=\u0026quot;allow-forms allow-modals allow-scripts\u0026quot; class=\u0026quot;snippet-box-edit snippet-box-result\u0026quot; frameborder=\u0026quot;0\u0026quot;\u0026gt;\u0026lt;/iframe\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;/div\u0026gt;\n\u0026lt;/div\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;In both \u0026lt;code\u0026gt;console.log\u0026lt;/code\u0026gt; you will find the value to be \u0026lt;code\u0026gt;undefined\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;In JavaScript, the type of the value \u0026lt;em\u0026gt;solely\u0026lt;/em\u0026gt; controls whether that value will be assigned by \u0026lt;strong\u0026gt;value-copy\u0026lt;/strong\u0026gt; or by \u0026lt;strong\u0026gt;reference-copy\u0026lt;/strong\u0026gt;. \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;em\u0026gt;Primitive values are always assigned/passed by value-copy\u0026lt;/em\u0026gt;: \u0026lt;/p\u0026gt;\n\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;code\u0026gt;null\u0026lt;/code\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;code\u0026gt;undefined\u0026lt;/code\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;string\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;number\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;boolean\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;symbol in \u0026lt;code\u0026gt;ES6\u0026lt;/code\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;em\u0026gt;Compound values are always assigned/passed by reference-copy\u0026lt;/em\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;objects \u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;arrays\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;function\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\n\u0026lt;p\u0026gt;For example\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; a = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; b = a; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// `b` is always a copy of the value in `a`\u0026lt;/span\u0026gt;\nb++;\na; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// 2\u0026lt;/span\u0026gt;\nb; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// 3\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; c = [\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;,\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;,\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3\u0026lt;/span\u0026gt;];\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; d = c; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// `d` is a reference to the shared `[1,2,3]` value\u0026lt;/span\u0026gt;\nd.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;push\u0026lt;/span\u0026gt;( \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;4\u0026lt;/span\u0026gt; );\nc; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// [1,2,3,4]\u0026lt;/span\u0026gt;\nd; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// [1,2,3,4]\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;In the above snippet, because \u0026lt;code\u0026gt;2\u0026lt;/code\u0026gt; is a scalar primitive, \u0026lt;code\u0026gt;a\u0026lt;/code\u0026gt; holds one initial copy of that value, and \u0026lt;code\u0026gt;b\u0026lt;/code\u0026gt; is assigned another copy of the value. When changing \u0026lt;code\u0026gt;b\u0026lt;/code\u0026gt;, you are in no way changing the value in \u0026lt;code\u0026gt;a\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;But both \u0026lt;code\u0026gt;c\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;d\u0026lt;/code\u0026gt; are separate references to the same shared value \u0026lt;code\u0026gt;[1,2,3]\u0026lt;/code\u0026gt;, which is a compound value. It\u0026apos;s important to note that neither \u0026lt;code\u0026gt;c\u0026lt;/code\u0026gt; nor \u0026lt;code\u0026gt;d\u0026lt;/code\u0026gt; more \u0026quot;owns\u0026quot; the \u0026lt;code\u0026gt;[1,2,3]\u0026lt;/code\u0026gt; value -- both are just equal peer references to the value. So, when using either reference to modify (\u0026lt;code\u0026gt;.push(4)\u0026lt;/code\u0026gt;) the actual shared \u0026lt;code\u0026gt;array\u0026lt;/code\u0026gt; value itself, it\u0026apos;s affecting just the one shared value, and both references will reference the newly modified value \u0026lt;code\u0026gt;[1,2,3,4]\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; a = [\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;,\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;,\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3\u0026lt;/span\u0026gt;];\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; b = a;\na; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// [1,2,3]\u0026lt;/span\u0026gt;\nb; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// [1,2,3]\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// later\u0026lt;/span\u0026gt;\nb = [\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;4\u0026lt;/span\u0026gt;,\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;5\u0026lt;/span\u0026gt;,\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;6\u0026lt;/span\u0026gt;];\na; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// [1,2,3]\u0026lt;/span\u0026gt;\nb; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// [4,5,6]\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;When we make the assignment \u0026lt;code\u0026gt;b = [4,5,6]\u0026lt;/code\u0026gt;, we are doing absolutely nothing to affect where \u0026lt;code\u0026gt;a\u0026lt;/code\u0026gt; is still referencing (\u0026lt;code\u0026gt;[1,2,3]\u0026lt;/code\u0026gt;). To do that, \u0026lt;code\u0026gt;b\u0026lt;/code\u0026gt; would have to be a pointer to \u0026lt;code\u0026gt;a\u0026lt;/code\u0026gt; rather than a reference to the \u0026lt;code\u0026gt;array\u0026lt;/code\u0026gt; -- but no such capability exists in JS!\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;foo\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;x\u0026lt;/span\u0026gt;) {\n    x.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;push\u0026lt;/span\u0026gt;( \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;4\u0026lt;/span\u0026gt; );\n    x; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// [1,2,3,4]\u0026lt;/span\u0026gt;\n\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// later\u0026lt;/span\u0026gt;\n    x = [\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;4\u0026lt;/span\u0026gt;,\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;5\u0026lt;/span\u0026gt;,\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;6\u0026lt;/span\u0026gt;];\n    x.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;push\u0026lt;/span\u0026gt;( \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;7\u0026lt;/span\u0026gt; );\n    x; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// [4,5,6,7]\u0026lt;/span\u0026gt;\n}\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; a = [\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;,\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;,\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3\u0026lt;/span\u0026gt;];\n\n\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;foo\u0026lt;/span\u0026gt;( a );\n\na; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// [1,2,3,4]  not  [4,5,6,7]\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;When we pass in the argument \u0026lt;code\u0026gt;a\u0026lt;/code\u0026gt;, it assigns a copy of the \u0026lt;code\u0026gt;a\u0026lt;/code\u0026gt; reference to \u0026lt;code\u0026gt;x\u0026lt;/code\u0026gt;. \u0026lt;code\u0026gt;x\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;a\u0026lt;/code\u0026gt; are separate references pointing at the same \u0026lt;code\u0026gt;[1,2,3]\u0026lt;/code\u0026gt; value. Now, inside the function, we can use that reference to mutate the value itself (\u0026lt;code\u0026gt;push(4)\u0026lt;/code\u0026gt;). But when we make the assignment \u0026lt;code\u0026gt;x = [4,5,6]\u0026lt;/code\u0026gt;, this is in no way affecting where the initial reference \u0026lt;code\u0026gt;a\u0026lt;/code\u0026gt; is pointing -- still points at the (now modified) \u0026lt;code\u0026gt;[1,2,3,4]\u0026lt;/code\u0026gt; value.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;To effectively pass a compound value (like an \u0026lt;code\u0026gt;array\u0026lt;/code\u0026gt;) by value-copy, you need to manually make a copy of it, so that the reference passed doesn\u0026apos;t still point to the original. For example:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;foo\u0026lt;/span\u0026gt;( a.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;slice\u0026lt;/span\u0026gt;() );\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Compound value (object, array, etc) that can be passed by reference-copy\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;foo\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;wrapper\u0026lt;/span\u0026gt;) {\n    wrapper.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;a\u0026lt;/span\u0026gt; = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;42\u0026lt;/span\u0026gt;;\n}\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; obj = {\n    \u0026lt;span class=\u0026quot;hljs-attr\u0026quot;\u0026gt;a\u0026lt;/span\u0026gt;: \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;\n};\n\n\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;foo\u0026lt;/span\u0026gt;( obj );\n\nobj.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;a\u0026lt;/span\u0026gt;; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// 42\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Here, \u0026lt;code\u0026gt;obj\u0026lt;/code\u0026gt; acts as a wrapper for the scalar primitive property \u0026lt;code\u0026gt;a\u0026lt;/code\u0026gt;. When passed to \u0026lt;code\u0026gt;foo(..)\u0026lt;/code\u0026gt;, a copy of the \u0026lt;code\u0026gt;obj\u0026lt;/code\u0026gt; reference is passed in and set to the \u0026lt;code\u0026gt;wrapper\u0026lt;/code\u0026gt;parameter. We now can use the \u0026lt;code\u0026gt;wrapper\u0026lt;/code\u0026gt; reference to access the shared object, and update its property. After the function finishes, \u0026lt;code\u0026gt;obj.a\u0026lt;/code\u0026gt; will see the updated value \u0026lt;code\u0026gt;42\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;a href=\u0026quot;https://github.com/getify/You-Dont-Know-JS/blob/master/types%20%26%20grammar/ch2.md\u0026quot;\u0026gt;Source\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;well, it\u0026apos;s about \u0026apos;performance\u0026apos; and \u0026apos;speed\u0026apos; and in the simple word \u0026apos;memory management\u0026apos; in a programming language.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;in javascript we can put values in two layer: \u0026lt;strong\u0026gt;type1\u0026lt;/strong\u0026gt;-\u0026lt;code\u0026gt;objects\u0026lt;/code\u0026gt; and \u0026lt;strong\u0026gt;type2\u0026lt;/strong\u0026gt;-all other types of value such as \u0026lt;code\u0026gt;string\u0026lt;/code\u0026gt; \u0026amp;amp; \u0026lt;code\u0026gt;boolean\u0026lt;/code\u0026gt; \u0026amp;amp; etc\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;if you imagine memory as below squares which in every one of them just one type2-value can be saved:\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;a href=\u0026quot;https://i.stack.imgur.com/wFWOsm.png\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;\u0026lt;img src=\u0026quot;https://i.stack.imgur.com/wFWOsm.png\u0026quot; alt=\u0026quot;enter image description here\u0026quot;\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;every type2-value (green) is a \u0026lt;strong\u0026gt;single square\u0026lt;/strong\u0026gt; while a type1-value (blue) is a \u0026lt;strong\u0026gt;group of them\u0026lt;/strong\u0026gt;:\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;a href=\u0026quot;https://i.stack.imgur.com/vwu2vm.png\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;\u0026lt;img src=\u0026quot;https://i.stack.imgur.com/vwu2vm.png\u0026quot; alt=\u0026quot;enter image description here\u0026quot;\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;the point is that if you want to indicate a type2-value, the address is plain but if you want to do the same thing for type1-value that\u0026apos;s not easy at all! :\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;a href=\u0026quot;https://i.stack.imgur.com/ZISOHm.png\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;\u0026lt;img src=\u0026quot;https://i.stack.imgur.com/ZISOHm.png\u0026quot; alt=\u0026quot;enter image description here\u0026quot;\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;and in a more complicated story:\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;a href=\u0026quot;https://i.stack.imgur.com/GIEvCm.png\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;\u0026lt;img src=\u0026quot;https://i.stack.imgur.com/GIEvCm.png\u0026quot; alt=\u0026quot;enter image description here\u0026quot;\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;so here \u0026lt;strong\u0026gt;references\u0026lt;/strong\u0026gt; can rescue us:\n\u0026lt;br\u0026gt;\n\u0026lt;a href=\u0026quot;https://i.stack.imgur.com/orhtHm.png\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;\u0026lt;img src=\u0026quot;https://i.stack.imgur.com/orhtHm.png\u0026quot; alt=\u0026quot;enter image description here\u0026quot;\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;while the green arrow here is a typical variable, the purple one is an object variable, so \u0026lt;strong\u0026gt;because the green arrow(typical variable) has just one task\u0026lt;/strong\u0026gt; (and that is indicating a typical value) we don\u0026apos;t need to separate it\u0026apos;s value from it so we move the green arrow with the value of that wherever it goes and in all assignments, functions and so on ...\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;but we cant do the same thing with the purple arrow, we may want to move \u0026apos;john\u0026apos; cell here or many other things..., so the purple arrow will stick to its place and just typical arrows that were assigned to it will move ...\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;a very confusing situation is where you can\u0026apos;t realize how your referenced variable changes, let\u0026apos;s take a look at a very good example:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;let\u0026lt;/span\u0026gt; arr = [\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;4\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;5\u0026lt;/span\u0026gt;]; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//arr is an object now and a purple arrow is indicating it\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;let\u0026lt;/span\u0026gt; obj2 = arr; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// now, obj2 is another purple arrow that is indicating the value of arr obj\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;let\u0026lt;/span\u0026gt; obj3 = [\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;a\u0026apos;\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;b\u0026apos;\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;c\u0026apos;\u0026lt;/span\u0026gt;];\nobj2.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;push\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;6\u0026lt;/span\u0026gt;); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// first pic below - making a new hand for the blue circle to point the 6\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//obj2 = [1, 2, 3, 4, 5, 6]\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//arr = [1, 2, 3, 4, 5, 6]\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//we changed the blue circle object value (type1-value) and due to arr and obj2 are indicating that so both of them changed\u0026lt;/span\u0026gt;\nobj2 = obj3; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//next pic below - changing the direction of obj2 array from blue circle to orange circle so obj2 is no more [1,2,3,4,5,6] and it\u0026apos;s no more about changing anything in it but we completely changed its direction and now obj2 is pointing to obj3\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//obj2 = [\u0026apos;a\u0026apos;, \u0026apos;b\u0026apos;, \u0026apos;c\u0026apos;];\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//obj3 = [\u0026apos;a\u0026apos;, \u0026apos;b\u0026apos;, \u0026apos;c\u0026apos;];\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;a href=\u0026quot;https://i.stack.imgur.com/fELHnm.png\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;\u0026lt;img src=\u0026quot;https://i.stack.imgur.com/fELHnm.png\u0026quot; alt=\u0026quot;enter image description here\u0026quot;\u0026gt;\u0026lt;/a\u0026gt;\n\u0026lt;a href=\u0026quot;https://i.stack.imgur.com/y9kukm.png\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;\u0026lt;img src=\u0026quot;https://i.stack.imgur.com/y9kukm.png\u0026quot; alt=\u0026quot;enter image description here\u0026quot;\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;This is little more explanation for pass by value and pass by reference (JavaScript). In this concept, they are talking about passing the variable by reference and passing the variable by reference.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Pass by value (primitive type)\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; a = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3\u0026lt;/span\u0026gt;;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; b = a;\n\n\u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;console\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;log\u0026lt;/span\u0026gt;(a); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// a = 3\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;console\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;log\u0026lt;/span\u0026gt;(b); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// b = 3\u0026lt;/span\u0026gt;\n\na=\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;4\u0026lt;/span\u0026gt;;\n\u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;console\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;log\u0026lt;/span\u0026gt;(a); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// a = 4\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;console\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;log\u0026lt;/span\u0026gt;(b); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// b = 3\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;applies to all primitive type in JavaScript (string, number, Boolean, undefined, and null).\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;a is allocated a memory (say 0x001) and b creates a copy of the value in memory (say 0x002).\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;So changing the value of a variable doesn\u0026apos;t affect the other, as they both reside in two different locations.\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\n\u0026lt;hr\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Pass by reference (objects)\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; c = { \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;name\u0026quot;\u0026lt;/span\u0026gt; : \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;john\u0026quot;\u0026lt;/span\u0026gt; };\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; d = c;\n\n\u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;console\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;log\u0026lt;/span\u0026gt;(c); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// { \u0026quot;name\u0026quot; : \u0026quot;john\u0026quot; }\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;console\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;log\u0026lt;/span\u0026gt;(d); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// { \u0026quot;name\u0026quot; : \u0026quot;john\u0026quot; }\u0026lt;/span\u0026gt;\n\nc.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;name\u0026lt;/span\u0026gt; = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;doe\u0026quot;\u0026lt;/span\u0026gt;;\n\n\u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;console\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;log\u0026lt;/span\u0026gt;(c); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// { \u0026quot;name\u0026quot; : \u0026quot;doe\u0026quot; }\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;console\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;log\u0026lt;/span\u0026gt;(d); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// { \u0026quot;name\u0026quot; : \u0026quot;doe\u0026quot; }\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;The JavaScript engine assigns the object to the variable \u0026lt;code\u0026gt;c\u0026lt;/code\u0026gt;, and it points to some memory, say (0x012).\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;When d=c, in this step \u0026lt;code\u0026gt;d\u0026lt;/code\u0026gt; points to the same location (0x012).\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Changing the value of any changes value for both the variable.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Functions are objects\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\n\u0026lt;hr\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Special case, pass by reference (objects)\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;c = {\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;name\u0026quot;\u0026lt;/span\u0026gt; : \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;jane\u0026quot;\u0026lt;/span\u0026gt;};\n\u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;console\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;log\u0026lt;/span\u0026gt;(c); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// { \u0026quot;name\u0026quot; : \u0026quot;jane\u0026quot; }\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;console\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;log\u0026lt;/span\u0026gt;(d); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// { \u0026quot;name\u0026quot; : \u0026quot;doe\u0026quot; }\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;The equal(=) operator sets up new memory space or address\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Semantics!! Setting concrete definitions will necessarily make some answers and comments incompatible since they are not describing the same thing even when using the same words and phrases, but it is critical to get past the confusion (especially for new programmers).\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;First of all, there are multiple levels of abstraction that not everyone seems to grasp.  Newer programmers who have learned on 4th or 5th generation languages may have difficulty wrapping their mind around concepts familiar to assembly or C programmers not phased by pointers to pointers to pointers.  Pass-by-reference does not simply mean the ability to change a referenced object using a function parameter variable.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Variable\u0026lt;/strong\u0026gt;: Combined concept of a symbol which references a value at a particular location in memory.  This term is usually too loaded to be used alone in discussing details.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Symbol\u0026lt;/strong\u0026gt;:  Text string used to refer to variable (i.e. variable\u0026apos;s name).\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Value\u0026lt;/strong\u0026gt;:  Particular bits stored in memory and referenced using variable\u0026apos;s symbol.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Memory location\u0026lt;/strong\u0026gt;:  Where a variable\u0026apos;s value is stored.  (The location itself is represented by a number separate from the value stored at the location.)\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Function parameter\u0026lt;/strong\u0026gt;:  Variable declared in a function definition, used for referencing variables passed to the function.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Function argument\u0026lt;/strong\u0026gt;: Variable outside the function which is passed to the function by the caller.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Object variable\u0026lt;/strong\u0026gt;:  Variable whose basic underlying value is not the \u0026quot;object\u0026quot; itself, rather its value is a pointer (memory location value) to another location in memory where the object\u0026apos;s actual data is stored.  In most higher-generation languages, the \u0026quot;pointer\u0026quot; aspect is effectively hidden by automatic de-referencing in various contexts.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Primitive variable\u0026lt;/strong\u0026gt;: Variable whose value IS the actual value.  Even this concept can be complicated by auto-boxing and object-like contexts of various languages, but the general ideas is that the variable\u0026apos;s value IS the actual value represented by the variable\u0026apos;s symbol rather than a pointer to another memory location.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;em\u0026gt;Function arguments and parameters are not the same thing.  Also, a variable\u0026apos;s value is not the variable\u0026apos;s object (as already pointed out by various people, but apparently ignored).  These distinctions are critical to proper understanding.\u0026lt;/em\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Pass-by-value or Call-by-sharing (for objects)\u0026lt;/strong\u0026gt;:  The function argument\u0026apos;s value is COPIED to another memory location which is referenced by the function\u0026apos;s parameter symbol (regardless of whether it\u0026apos;s on the stack or heap).  In other words, the function parameter received a copy of the passed argument\u0026apos;s value... AND (critical) the argument\u0026apos;s value IS NEVER UPDATED / ALTERED / CHANGED by the calling function.  Remember, an object variable\u0026apos;s value is NOT the object itself, rather it is the pointer to the object, so passing an object variable by value copies the pointer to the function parameter variable.  The function parameter\u0026apos;s value points to the exact same object in memory.  The object data itself can be altered directly via the function parameter, BUT the function argument\u0026apos;s value IS NEVER UPDATED, so it will continue to point to the \u0026lt;em\u0026gt;same\u0026lt;/em\u0026gt; object throughout and even after the function call (even if its object\u0026apos;s data was altered or if the function parameter is assigned a different object altogether).  It is incorrect to conclude that the function argument was passed by reference just because the referenced object is updatable via the function parameter variable.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Call / Pass-by-reference\u0026lt;/strong\u0026gt;:  The function argument\u0026apos;s value can/will be updated directly by the corresponding function parameter.  If it helps, the function parameter becomes an effective \u0026quot;alias\u0026quot; for the argument--they effectively refer to the same value at the same memory location.  If a function argument is an object variable, the ability to change the object\u0026apos;s data is no different than the pass-by-value case since the function parameter will still point to the same object as the argument.  But in the object variable case, if the function parameter is set to a completely different object, then the argument will likewise also point to the different object--this does not happen in the pass-by-value case.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;JavaScript does not pass by reference.  If you read closely, you will realize that all contrary opinions misunderstand what is meant by pass-by-value and they falsely conclude that the ability to update an object\u0026apos;s data via the function parameter is synonymous to \u0026quot;pass-by-value\u0026quot;.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Object clone/copy\u0026lt;/strong\u0026gt;: A new object is created and the original object\u0026apos;s data is copied.  This can be a deep copy or shallow copy, but the point is that a new object is created.  Creating a copy of an object is a separate concept from pass-by-value.  Some languages distinguish between class object and structs (or the like), and may have different behavior for passing variables of the different types.  But JavaScript does not do anything like this automatically when passing object variables.  But the absence of automatic object cloning does not translate to pass-by-reference.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;sharing what I know of references in JavaScript\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;p\u0026gt;In JavaScript, when assigning an object to a variable, the value assigned to the variable is a reference to the object:\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;/p\u0026gt;\u0026lt;div class=\u0026quot;snippet\u0026quot; data-lang=\u0026quot;js\u0026quot; data-hide=\u0026quot;false\u0026quot; data-console=\u0026quot;true\u0026quot; data-babel=\u0026quot;false\u0026quot;\u0026gt;\n\u0026lt;div class=\u0026quot;snippet-code\u0026quot;\u0026gt;\n\u0026lt;pre class=\u0026quot;snippet-code-js lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; a = {\n  \u0026lt;span class=\u0026quot;hljs-attr\u0026quot;\u0026gt;a\u0026lt;/span\u0026gt;: \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;,\n  \u0026lt;span class=\u0026quot;hljs-attr\u0026quot;\u0026gt;b\u0026lt;/span\u0026gt;: \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;,\n  \u0026lt;span class=\u0026quot;hljs-attr\u0026quot;\u0026gt;c\u0026lt;/span\u0026gt;: \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3\u0026lt;/span\u0026gt;\n};\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; b = a;\n\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// b.c is referencing to a.c value\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;console\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;log\u0026lt;/span\u0026gt;(b.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;c\u0026lt;/span\u0026gt;) \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Output: 3\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Changing value of b.c\u0026lt;/span\u0026gt;\nb.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;c\u0026lt;/span\u0026gt; = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;4\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Also changes the value of a.c\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;console\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;log\u0026lt;/span\u0026gt;(a.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;c\u0026lt;/span\u0026gt;) \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Output: 4\u0026lt;/span\u0026gt;\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;div class=\u0026quot;snippet-result\u0026quot;\u0026gt;\u0026lt;div class=\u0026quot;snippet-ctas\u0026quot;\u0026gt;\u0026lt;button type=\u0026quot;button\u0026quot; class=\u0026quot;s-btn s-btn__primary\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;icon-play-white _hover\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;\u0026lt;span\u0026gt; Run code snippet\u0026lt;/span\u0026gt;\u0026lt;/button\u0026gt;\u0026lt;input class=\u0026quot;copySnippet s-btn s-btn__filled\u0026quot; type=\u0026quot;button\u0026quot; value=\u0026quot;Copy snippet to answer\u0026quot; style=\u0026quot;display: none;\u0026quot;\u0026gt;\u0026lt;button type=\u0026quot;button\u0026quot; class=\u0026quot;s-btn hideResults\u0026quot; style=\u0026quot;display: none;\u0026quot;\u0026gt;Hide results\u0026lt;/button\u0026gt;\u0026lt;div class=\u0026quot;popout-code\u0026quot;\u0026gt;\u0026lt;a class=\u0026quot;snippet-expand-link\u0026quot;\u0026gt;Expand snippet\u0026lt;/a\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;div class=\u0026quot;snippet-result-code\u0026quot; style=\u0026quot;display: none;\u0026quot;\u0026gt;\u0026lt;iframe name=\u0026quot;sif5\u0026quot; sandbox=\u0026quot;allow-forms allow-modals allow-scripts\u0026quot; class=\u0026quot;snippet-box-edit snippet-box-result\u0026quot; frameborder=\u0026quot;0\u0026quot;\u0026gt;\u0026lt;/iframe\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;/div\u0026gt;\n\u0026lt;/div\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;h2\u0026gt;JavaScript passes primitive types by value and object types by reference\u0026lt;/h2\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;Now, people like to bicker endlessly about whether \u0026quot;pass by reference\u0026quot;\n  is the correct way to describe what Java et al. actually do. The point\n  is this:\u0026lt;/p\u0026gt;\n  \n  \u0026lt;ol\u0026gt;\n  \u0026lt;li\u0026gt;Passing an object does not copy the object.\u0026lt;/li\u0026gt;\n  \u0026lt;li\u0026gt;An object passed to a function can have its members modified by the function.\u0026lt;/li\u0026gt;\n  \u0026lt;li\u0026gt;A primitive value passed to a function cannot be modified by the function. A copy is made.\u0026lt;/li\u0026gt;\n  \u0026lt;/ol\u0026gt;\n  \n  \u0026lt;p\u0026gt;In my book that\u0026apos;s called passing by reference.\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;p\u0026gt; \u0026lt;a href=\u0026quot;https://www.quora.com/profile/Brian-Bi\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;Brian Bi\u0026lt;/a\u0026gt; - \u0026lt;a href=\u0026quot;https://www.quora.com/Which-programming-languages-are-pass-by-reference#\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;Which programming languages are pass by reference?\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;hr\u0026gt;\n\n\u0026lt;h1\u0026gt;Update\u0026lt;/h1\u0026gt;\n\n\u0026lt;p\u0026gt;Here is a rebuttal to this:\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;a href=\u0026quot;https://stackoverflow.com/a/7744623/5535245\u0026quot;\u0026gt;There is no \u0026quot;pass by reference\u0026quot; available in JavaScript.\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;\u0026lt;em\u0026gt;Observation: If there isn\u0026apos;t any way for an observer to examine the underlying memory of the engine, there is no way to determine whether an immutable value gets copied or a reference gets passed.\u0026lt;/em\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;JavaScript is more or less agnostic to the underlying memory model. There is no such thing as a \u0026lt;em\u0026gt;reference\u0026lt;/em\u0026gt;². JavaScript has \u0026lt;em\u0026gt;values\u0026lt;/em\u0026gt;. Two variables can hold the same \u0026lt;em\u0026gt;value\u0026lt;/em\u0026gt; (or more accurate: two \u0026lt;em\u0026gt;environment records\u0026lt;/em\u0026gt; can \u0026lt;em\u0026gt;bind\u0026lt;/em\u0026gt; the same value). The only type of values that can be mutated are objects through their abstract [[Get]] and [[Set]] operations.\nIf you forget about computers and memory, this is all you need to describe JavaScript\u0026apos;s behaviour, and it allows you to understand the specification.\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;let\u0026lt;/span\u0026gt; a = { \u0026lt;span class=\u0026quot;hljs-attr\u0026quot;\u0026gt;prop\u0026lt;/span\u0026gt;: \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt; };\n \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;let\u0026lt;/span\u0026gt; b = a; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// a and b hold the same value\u0026lt;/span\u0026gt;\n a.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;prop\u0026lt;/span\u0026gt; = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;test\u0026quot;\u0026lt;/span\u0026gt;; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// The object gets mutated, can be observed through both a and b\u0026lt;/span\u0026gt;\n b = { \u0026lt;span class=\u0026quot;hljs-attr\u0026quot;\u0026gt;prop\u0026lt;/span\u0026gt;: \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt; }; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// b holds now a different value\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;Now you might ask yourself how two variables can hold the same value on a computer. You might then look into the source code of a JavaScript engine and you\u0026apos;ll most likely find something which a programmer of the language the engine was written in would call a reference.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;So in fact you can say that JavaScript is \u0026quot;pass by value\u0026quot;, whereas the value can be shared, and you can say that JavaScript is \u0026quot;pass by reference\u0026quot;, which might be a useful logical abstraction for programmers from low level languages, or you might call the behaviour \u0026quot;call by sharing\u0026quot;.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;As there is no such thing as a reference in JavaScript, all of these are neither wrong nor on point. Therefore I don\u0026apos;t think the answer is particularly useful to search for.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;² The term \u0026lt;em\u0026gt;Reference\u0026lt;/em\u0026gt; in the specification is not a reference in the traditional sense. It is a container for an object and the name of a property, and it is an intermediate value (e.g., \u0026lt;code\u0026gt;a.b\u0026lt;/code\u0026gt; evaluates to \u0026lt;code\u0026gt;Reference { value = a, name = \u0026quot;b\u0026quot; }\u0026lt;/code\u0026gt;). The term \u0026lt;em\u0026gt;reference\u0026lt;/em\u0026gt; also sometimes appears in the specification in unrelated sections.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Everything is passed by value.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Basic types are passed by value (i.e. a new copy of the actual variable value is passed to the function).\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Complex types (objects) are passed as \u0026quot;pointer to the object\u0026quot;. So the actual stuff you are passing is a pointer which is passed by value (it\u0026apos;s an address, a numerical value like any other). Obviously if you try to modify a property of the object inside the function, the modification will be reflected even outside of such function. That\u0026apos;s because you are accessing the property via the pointer which points to the unique copy of the property.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;The confusion here has arises over \u0026quot;passing a pointer by value\u0026quot; and \u0026quot;passing an object by reference\u0026quot;.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;My simple way to understand this...\u0026lt;/p\u0026gt;\n\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;When calling a function, you are passing the content (reference or\nvalue) of the argument variables, not the the variables themselves.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; var1 = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;13\u0026lt;/span\u0026gt;;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; var2 = { \u0026lt;span class=\u0026quot;hljs-attr\u0026quot;\u0026gt;prop\u0026lt;/span\u0026gt;: \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt; };\n\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//13 and var2\u0026apos;s content (reference) are being passed here\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;foo\u0026lt;/span\u0026gt;(var1, var2); \n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;Inside the function, parameter variables, \u0026lt;code\u0026gt;inVar1\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;inVar2\u0026lt;/code\u0026gt;, receive the contents being passed.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;foo\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;inVar1, inVar2\u0026lt;/span\u0026gt;){\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//changing contents of inVar1 and inVar2 won\u0026apos;t affect variables outside\u0026lt;/span\u0026gt;\n    inVar1 = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;20\u0026lt;/span\u0026gt;;\n    inVar2 = { \u0026lt;span class=\u0026quot;hljs-attr\u0026quot;\u0026gt;prop\u0026lt;/span\u0026gt;: \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;7\u0026lt;/span\u0026gt; };\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;Since \u0026lt;code\u0026gt;inVar2\u0026lt;/code\u0026gt; received the reference of \u0026lt;code\u0026gt;{ prop: 2 }\u0026lt;/code\u0026gt;, you can change the value of the object\u0026apos;s property.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;foo\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;inVar1, inVar2\u0026lt;/span\u0026gt;){\n    inVar2.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;prop\u0026lt;/span\u0026gt; = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;7\u0026lt;/span\u0026gt;; \n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n    ","\n\u0026lt;p\u0026gt;The MDN docs explain it clearly, without being too verbose:  \u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;The parameters of a function call are the function\u0026apos;s \u0026lt;em\u0026gt;arguments\u0026lt;/em\u0026gt;.\n  Arguments are passed to functions \u0026lt;em\u0026gt;by value\u0026lt;/em\u0026gt;. If the function changes\n  the value of an argument, this change is not reflected globally or in\n  the calling function. However, object references are values, too, and\n  they are special: if the function changes the referred object\u0026apos;s\n  properties, that change is visible outside the function, (...)\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;p\u0026gt;Source: \u0026lt;a href=\u0026quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions#Description\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions#Description\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Passing arguments to a function in JavaScript is analogous to passing\nparameters by pointer value in C:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;/*\nThe following C program demonstrates how arguments\nto JavaScript functions are passed in a way analogous\nto pass-by-pointer-value in C. The original JavaScript\ntest case by @Shog9 follows with the translation of\nthe code into C. This should make things clear to\nthose transitioning from C to JavaScript.\n\nfunction changeStuff(num, obj1, obj2)\n{\n    num = num * 10;\n    obj1.item = \u0026quot;changed\u0026quot;;\n    obj2 = {item: \u0026quot;changed\u0026quot;};\n}\n\nvar num = 10;\nvar obj1 = {item: \u0026quot;unchanged\u0026quot;};\nvar obj2 = {item: \u0026quot;unchanged\u0026quot;};\nchangeStuff(num, obj1, obj2);\nconsole.log(num);\nconsole.log(obj1.item);    \nconsole.log(obj2.item);\n\nThis produces the output:\n\n10\nchanged\nunchanged\n*/\u0026lt;/span\u0026gt;\n\n#include \u0026amp;lt;stdio.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;h\u0026lt;/span\u0026gt;\u0026amp;gt;\n#include \u0026amp;lt;stdlib.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;h\u0026lt;/span\u0026gt;\u0026amp;gt;\n\nstruct obj {\n    char *item;\n};\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;changeStuff\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;int *num, struct obj *obj1, struct obj *obj2\u0026lt;/span\u0026gt;)\n{\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// make pointer point to a new memory location\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// holding the new integer value\u0026lt;/span\u0026gt;\n    int *old_num = num;\n    num = \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;malloc\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;sizeof\u0026lt;/span\u0026gt;(int));\n    *num = *old_num * \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;10\u0026lt;/span\u0026gt;;\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// make property of structure pointed to by pointer\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// point to the new value\u0026lt;/span\u0026gt;\n    obj1-\u0026amp;gt;item = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;changed\u0026quot;\u0026lt;/span\u0026gt;;\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// make pointer point to a new memory location\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// holding the new structure value\u0026lt;/span\u0026gt;\n    obj2 = \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;malloc\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;sizeof\u0026lt;/span\u0026gt;(struct obj));\n    obj2-\u0026amp;gt;item = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;changed\u0026quot;\u0026lt;/span\u0026gt;;\n    \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;free\u0026lt;/span\u0026gt;(num); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// end of scope\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;free\u0026lt;/span\u0026gt;(obj2); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// end of scope\u0026lt;/span\u0026gt;\n}\n\nint num = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;10\u0026lt;/span\u0026gt;;\nstruct obj obj1 = { \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;unchanged\u0026quot;\u0026lt;/span\u0026gt; };\nstruct obj obj2 = { \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;unchanged\u0026quot;\u0026lt;/span\u0026gt; };\n\nint \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;main\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;)\n{\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// pass pointers by value: the pointers\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// will be copied into the argument list\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// of the called function and the copied\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// pointers will point to the same values\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// as the original pointers\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;changeStuff\u0026lt;/span\u0026gt;(\u0026amp;amp;num, \u0026amp;amp;obj1, \u0026amp;amp;obj2);\n    \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;printf\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;%d\\n\u0026quot;\u0026lt;/span\u0026gt;, num);\n    \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;puts\u0026lt;/span\u0026gt;(obj1.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;item\u0026lt;/span\u0026gt;);\n    \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;puts\u0026lt;/span\u0026gt;(obj2.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;item\u0026lt;/span\u0026gt;);\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;For programming language lawyers, I\u0026apos;ve went through the following sections of ECMAScript 5.1 (which is easier to read than the latest edition), and go as far as \u0026lt;a href=\u0026quot;https://esdiscuss.org/topic/are-the-values-of-objects-the-references-to-them\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;asking\u0026lt;/a\u0026gt; it on the ECMAScript mailing list.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;b\u0026gt;TL;DR\u0026lt;/b\u0026gt;: Everythings\u0026apos;re passed by value, but properties of Objects are references, and the definition of Object is creepily lacking in the standard.\u0026lt;/p\u0026gt;\n\u0026lt;h1\u0026gt;Construction of Argument Lists\u0026lt;/h1\u0026gt;\n\u0026lt;p\u0026gt;Section 11.2.4 \u0026quot;Argument Lists\u0026quot; says the following on producing a argument list consisting of only 1 argument:\u0026lt;/p\u0026gt;\n\u0026lt;blockquote\u0026gt;\n\u0026lt;p\u0026gt;The production ArgumentList : AssignmentExpression is evaluated as follows:\u0026lt;/p\u0026gt;\n\u0026lt;ol\u0026gt;\n\u0026lt;li\u0026gt;Let ref be the result of evaluating AssignmentExpression.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Let arg be GetValue(ref).\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Return a List whose sole item is arg.\u0026lt;/li\u0026gt;\n\u0026lt;/ol\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\u0026lt;p\u0026gt;The section also enumerate cases where argument list has 0 or \u0026amp;gt;1 arguments.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Thus, everything\u0026apos;s are passed by reference.\u0026lt;/p\u0026gt;\n\u0026lt;h1\u0026gt;Access of Object Properties\u0026lt;/h1\u0026gt;\n\u0026lt;p\u0026gt;Section 11.2.1 \u0026quot;Property Accessors\u0026quot;\u0026lt;/p\u0026gt;\n\u0026lt;blockquote\u0026gt;\n\u0026lt;p\u0026gt;The production MemberExpression : MemberExpression [ Expression ] is evaluated as follows:\u0026lt;/p\u0026gt;\n\u0026lt;ol\u0026gt;\n\u0026lt;li\u0026gt;Let baseReference be the result of evaluating MemberExpression.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Let baseValue be GetValue(baseReference).\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Let propertyNameReference be the result of evaluating Expression.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Let propertyNameValue be GetValue(propertyNameReference).\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Call CheckObjectCoercible(baseValue).\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Let propertyNameString be ToString(propertyNameValue).\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;If the syntactic production that is being evaluated is contained in strict mode code, let strict be true, else let\nstrict be false.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;b\u0026gt;Return a value of type Reference\u0026lt;/b\u0026gt; whose base value is baseValue and whose referenced name is\npropertyNameString, and whose strict mode flag is strict.\u0026lt;/li\u0026gt;\n\u0026lt;/ol\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\u0026lt;p\u0026gt;Thus, properties of Objects are always available as reference.\u0026lt;/p\u0026gt;\n\u0026lt;h1\u0026gt;On Reference\u0026lt;/h1\u0026gt;\n\u0026lt;p\u0026gt;It is described in section 8.7 \u0026quot;The Reference Specification Type\u0026quot;, that references are not real types in the language - they\u0026apos;re only used to describe the behavior of the delete, the typeof, and the assignment operators.\u0026lt;/p\u0026gt;\n\u0026lt;h1\u0026gt;Definition of \u0026quot;Object\u0026quot;\u0026lt;/h1\u0026gt;\n\u0026lt;p\u0026gt;It is defined in 5.1 edition that \u0026quot;An Object is a collection of properties\u0026quot;. Therefore, we can infer, that the value of the object is the collection, but as to what is the value of the collection is poorly defined in the spec, and requires a bit of \u0026lt;a href=\u0026quot;https://stackoverflow.com/questions/45388408/where-is-the-mutability-of-objects-defined-in-ecmascript/45407589#45407589\u0026quot;\u0026gt;effort\u0026lt;/a\u0026gt; to understand.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;The most succinct explanation I found was in the \u0026lt;a href=\u0026quot;https://github.com/airbnb/javascript#types\u0026quot; rel=\u0026quot;nofollow\u0026quot;\u0026gt;AirBNB style guide\u0026lt;/a\u0026gt;:\u0026lt;/p\u0026gt;\n\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Primitives\u0026lt;/strong\u0026gt;: When you access a primitive type you work directly on its\nvalue\u0026lt;/p\u0026gt;\n\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;string\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;number\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;boolean\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;null\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;undefined\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\n\u0026lt;p\u0026gt;E.g.:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; foo = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;,\n    bar = foo;\n\nbar = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;9\u0026lt;/span\u0026gt;;\n\n\u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;console\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;log\u0026lt;/span\u0026gt;(foo, bar); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// =\u0026amp;gt; 1, 9\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Complex\u0026lt;/strong\u0026gt;: When you access a complex type you work on a reference to its value\u0026lt;/p\u0026gt;\n\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;object\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;array\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;function\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\n\u0026lt;p\u0026gt;E.g.:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; foo = [\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;],\n    bar = foo;\n\nbar[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;] = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;9\u0026lt;/span\u0026gt;;\n\n\u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;console\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;log\u0026lt;/span\u0026gt;(foo[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;], bar[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;]); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// =\u0026amp;gt; 9, 9\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;I.e. effectively primitive types are passed by value, and complex types are passed by reference.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;I\u0026apos;ve read through these answers multiple times, but didn\u0026apos;t REALLY get it until I learned about the technical definition of \u0026lt;a href=\u0026quot;https://en.wikipedia.org/wiki/Evaluation_strategy#Call_by_sharing\u0026quot; rel=\u0026quot;nofollow\u0026quot;\u0026gt;\u0026quot;Call by sharing\u0026quot;\u0026lt;/a\u0026gt; as termed by Barbara Liskov\u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;The semantics of call by sharing differ from call by reference in that assignments to function arguments within the function aren\u0026apos;t visible to the caller (unlike by reference semantics)[citation needed], so e.g. if a variable was passed, it is not possible to simulate an assignment on that variable in the caller\u0026apos;s scope. However, since the function has access to the same object as the caller (no copy is made), mutations to those objects, if the objects are mutable, within the function are visible to the caller, which may appear to differ from call by value semantics. Mutations of a mutable object within the function are visible to the caller because the object is not copied or cloned  it is shared.\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;p\u0026gt;That is, parameter references are alterable if you go and access the parameter value itself. On the other hand, assignment to a parameter will disappear after evaluation, and is non-accessible to the function caller.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;In a low-level language, if you want to pass a variable by reference, you have to use a specific syntax in the creation of the function:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;int myAge = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;14\u0026lt;/span\u0026gt;;\n\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;increaseAgeByRef\u0026lt;/span\u0026gt;(myAge);\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;increaseAgeByRef\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;int \u0026amp;amp;age\u0026lt;/span\u0026gt;) {\n  *age = *age + \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;The \u0026lt;code\u0026gt;\u0026amp;amp;age\u0026lt;/code\u0026gt; is a reference to \u0026lt;code\u0026gt;myAge\u0026lt;/code\u0026gt;, but if you want the value you have to convert the reference, using \u0026lt;code\u0026gt;*age\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;JavaScript is a high level language that does this conversion for you.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;So, although objects are passed by reference, the language converts the reference parameter to the value. You don\u0026apos;t need to use \u0026lt;code\u0026gt;\u0026amp;amp;\u0026lt;/code\u0026gt;, on the function definition, to pass it by reference, neither \u0026lt;code\u0026gt;*\u0026lt;/code\u0026gt;, on the function body, to convert the reference to the value, JavaScript does it for you.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;That\u0026apos;s why when you try to change an object inside a function, by replacing it\u0026apos;s value (i.e. \u0026lt;code\u0026gt;age = {value:5}\u0026lt;/code\u0026gt;), the change doesn\u0026apos;t persist, but if you change it\u0026apos;s properties (i.e. \u0026lt;code\u0026gt;age.value = 5\u0026lt;/code\u0026gt;), it does.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;a href=\u0026quot;https://blog.penjee.com/passing-by-value-vs-by-reference-java-graphical/\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;Learn more\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;If you want (normal) function parameter behavior like in other languages (passing copy of a value)\nthen just clone the object before passing into a function:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;run\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;)\n{\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; test = [];\n    test.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;push\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;);\n\n    \u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;console\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;log\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;before: \u0026apos;\u0026lt;/span\u0026gt;+test); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// 1\u0026lt;/span\u0026gt;\n\n    \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;changeVariable\u0026lt;/span\u0026gt;(_.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;clone\u0026lt;/span\u0026gt;(test)); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// (Note: I am using lodash _.clone() function)\u0026lt;/span\u0026gt;\n \n    \u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;console\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;log\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;after: \u0026apos;\u0026lt;/span\u0026gt;+test); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// 1 \u0026lt;/span\u0026gt;\n}\n\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;changeVariable\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;test2\u0026lt;/span\u0026gt;) {\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; test1 = test2;\n  test1.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;push\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;); \n  \u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;console\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;log\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;inside func:\u0026apos;\u0026lt;/span\u0026gt;, test1);  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// inside func: [1,2]\u0026lt;/span\u0026gt;\n}   \n\n\n\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;run\u0026lt;/span\u0026gt;();    \n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;I have found the \u0026lt;a href=\u0026quot;http://documentcloud.github.com/underscore/#extend\u0026quot; rel=\u0026quot;nofollow\u0026quot;\u0026gt;extend method\u0026lt;/a\u0026gt; of the \u0026lt;a href=\u0026quot;http://documentcloud.github.com/underscore\u0026quot; rel=\u0026quot;nofollow\u0026quot;\u0026gt;Underscore.js library\u0026lt;/a\u0026gt; very useful when I want to pass in an object as a parameter which may either be modified or replaced entirely.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;replaceOrModify\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;aObj\u0026lt;/span\u0026gt;) {\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (modify) {\n\n    aObj.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;setNewValue\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026apos;foo\u0026apos;\u0026lt;/span\u0026gt;);\n\n  } \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;else\u0026lt;/span\u0026gt; {\n\n   \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; newObj = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;MyObject\u0026lt;/span\u0026gt;();\n   \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// _.extend(destination, *sources) \u0026lt;/span\u0026gt;\n   _.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;extend\u0026lt;/span\u0026gt;(newObj, aObj);\n  }\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;I would say it is pass-by-copy -\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Consider arguments and variable objects are objects created during the execution context created in the beginning of function invocation - and your actual value/reference passed into the function just get stored in this arguments + variable objects.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Simply speaking, for primitive types, the values get copied in the beginning of function call, for object type, the reference get copied.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;ol\u0026gt;\n\u0026lt;li\u0026gt;primitive type variable like string,number are always pass as  pass\nby value.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;Array and Object is passed as  pass by reference or  pass by value based on these two condition.\u0026lt;/p\u0026gt;\n\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;if you are changing value of that Object or array with new Object or Array then it is pass by Value.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;code\u0026gt;object1 = {item: \u0026quot;car\u0026quot;};\n  array1=[1,2,3];\u0026lt;/code\u0026gt;\u0026lt;/p\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\n\u0026lt;p\u0026gt;here you are assigning new object or array to old one.you are not changing the value of property \nof old object.so it is pass by value.\u0026lt;/p\u0026gt;\n\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;if you are changing a property value of an object or array then it is pass by Reference.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;code\u0026gt;object1.key1= \u0026quot;car\u0026quot;;\n  array1[0]=9;\u0026lt;/code\u0026gt;\u0026lt;/p\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\n\u0026lt;p\u0026gt;here you are changing a property value of old object.you are not assigning new object or array to old one.so it is pass by reference.\u0026lt;/p\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;/ol\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Code\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;function\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;passVar\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;object1, object2, number1\u0026lt;/span\u0026gt;) {\n\n        object1.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;key1\u0026lt;/span\u0026gt;= \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;laptop\u0026quot;\u0026lt;/span\u0026gt;;\n        object2 = {\n            \u0026lt;span class=\u0026quot;hljs-attr\u0026quot;\u0026gt;key2\u0026lt;/span\u0026gt;: \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;computer\u0026quot;\u0026lt;/span\u0026gt;\n        };\n        number1 = number1 + \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;;\n    }\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; object1 = {\n        \u0026lt;span class=\u0026quot;hljs-attr\u0026quot;\u0026gt;key1\u0026lt;/span\u0026gt;: \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;car\u0026quot;\u0026lt;/span\u0026gt;\n    };\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; object2 = {\n        \u0026lt;span class=\u0026quot;hljs-attr\u0026quot;\u0026gt;key2\u0026lt;/span\u0026gt;: \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;bike\u0026quot;\u0026lt;/span\u0026gt;\n    };\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; number1 = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;10\u0026lt;/span\u0026gt;;\n\n    \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;passVar\u0026lt;/span\u0026gt;(object1, object2, number1);\n    \u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;console\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;log\u0026lt;/span\u0026gt;(object1.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;key1\u0026lt;/span\u0026gt;);\n    \u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;console\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;log\u0026lt;/span\u0026gt;(object2.\u0026lt;span class=\u0026quot;hljs-property\u0026quot;\u0026gt;key2\u0026lt;/span\u0026gt;);\n    \u0026lt;span class=\u0026quot;hljs-variable language_\u0026quot;\u0026gt;console\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;log\u0026lt;/span\u0026gt;(number1);\n\n\u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Output\u0026lt;/span\u0026gt;: -\n    laptop\n    bike\n    \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;10\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;An easy way to determine whether something is \u0026quot;pass by reference\u0026quot; is whether you can write a \u0026quot;swap\u0026quot; function. For example, in C, you can do:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-js s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-javascript\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;swap\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;int *i, int *j\u0026lt;/span\u0026gt;)\n{\n    int t;\n    t = *i;\n    *i = *j;\n    *j = t;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;If you can\u0026apos;t do the equivalent of that in JavaScript, it is not \u0026quot;pass by reference\u0026quot;.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;ol\u0026gt;\n\u0026lt;li\u0026gt;Primitives (number, Boolean, etc.) are passed by value.\n\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;Strings are immutable, so it doesn\u0026apos;t really matter for them.\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Objects are passed by reference (the reference is passed by value).\u0026lt;/li\u0026gt;\n\u0026lt;/ol\u0026gt;\n    "],"id":119,"title":"Is JavaScript a pass-by-reference or pass-by-value language?","content":"\n                \n\u0026lt;p\u0026gt;The primitive types (number, string, etc.) are passed by value, but objects are unknown, because they can be both passed-by-value (in case we consider that a variable holding an object is in fact a reference to the object) and passed-by-reference (when we consider that the variable to the object holds the object itself).\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Although it doesn\u0026apos;t really matter at the end, I want to know what is the correct way to present the arguments passing conventions. Is there an excerpt from JavaScript specification, which defines what should be the semantics regarding this?\u0026lt;/p\u0026gt;\n    ","slug":"is-javascript-a-pass-by-reference-or-pass-by-value-language-1657384675679","postType":"QUESTION","createdAt":"2022-07-09T16:37:55.000Z","updatedAt":"2022-07-09T16:37:55.000Z","tags":[],"relatedQuestions":[]},"randomQuestions":[{"title":"How do you access the matched groups in a JavaScript regular expression?","slug":"how-do-you-access-the-matched-groups-in-a-javascript-regular-expression-1657388233817"},{"title":"How to use java.util.Scanner to correctly read user input from System.in and act on it?","slug":"how-to-use-java.util.scanner-to-correctly-read-user-input-from-system.in-and-act-on-it-1657388546306"},{"title":"Reference: What is variable scope, which variables are accessible from where and what are \"undefined variable\" errors?","slug":"reference:-what-is-variable-scope-which-variables-are-accessible-from-where-and-what-are-\"undefined-variable\"-errors-1657384644697"},{"title":"Why does my JavaScript code receive a \"No 'Access-Control-Allow-Origin' header is present on the requested resource\" error, while Postman does not?","slug":"why-does-my-javascript-code-receive-a-\"no-'access-control-allow-origin'-header-is-present-on-the-requested-resource\"-error-while-postman-does-not-1657384636363"},{"title":"How to extract and access data from JSON with PHP?","slug":"how-to-extract-and-access-data-from-json-with-php-1657384483259"},{"title":"What is a clearfix?","slug":"what-is-a-clearfix-1657387337825"},{"title":"Disable same origin policy in Chrome","slug":"disable-same-origin-policy-in-chrome-1657387743804"},{"title":"Web-scraping JavaScript page with Python","slug":"web-scraping-javascript-page-with-python-1657388240875"},{"title":"Swing GUI listeners without AWT","slug":"swing-gui-listeners-without-awt-1657387522426"},{"title":"Is there any way to kill a Thread?","slug":"is-there-any-way-to-kill-a-thread-1657387859831"},{"title":"Why do we always prefer using parameters in SQL statements?","slug":"why-do-we-always-prefer-using-parameters-in-sql-statements-1657388031476"},{"title":"Tkinter: AttributeError: NoneType object has no attribute \u003cattribute name\u003e","slug":"tkinter:-attributeerror:-nonetype-object-has-no-attribute-lessattribute-namegreater-1657385472410"},{"title":"How can I access and process nested objects, arrays, or JSON?","slug":"how-can-i-access-and-process-nested-objects-arrays-or-json-1657384332823"},{"title":"How does Access-Control-Allow-Origin header work?","slug":"how-does-access-control-allow-origin-header-work-1657384881723"},{"title":"How do I give text or an image a transparent background using CSS?","slug":"how-do-i-give-text-or-an-image-a-transparent-background-using-css-1657388188508"},{"title":"addEventListener vs onclick","slug":"addeventlistener-vs-onclick-1657388191429"},{"title":"Simulating group_concat MySQL function in Microsoft SQL Server 2005?","slug":"simulating-group_concat-mysql-function-in-microsoft-sql-server-2005-1657384832169"},{"title":"What special characters must be escaped in regular expressions?","slug":"what-special-characters-must-be-escaped-in-regular-expressions-1657387465381"},{"title":"What is object slicing?","slug":"what-is-object-slicing-1657384506425"},{"title":"Selenium \"selenium.common.exceptions.NoSuchElementException\" when using Chrome","slug":"selenium-\"selenium.common.exceptions.nosuchelementexception\"-when-using-chrome-1657388136699"}]},"__N_SSG":true},"page":"/questions/[slug]","query":{"slug":"is-javascript-a-pass-by-reference-or-pass-by-value-language-1657384675679"},"buildId":"5tS3Jli5j89_wXapXajXn","isFallback":false,"gsp":true,"locale":"en","locales":["en"],"defaultLocale":"en","scriptLoader":[]}</script></body></html>