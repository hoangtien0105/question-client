<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><meta name="twitter:card" content="summary_large_image"/><meta name="twitter:site" content="@solutionschecker.com"/><meta name="twitter:creator" content="@solutionschecker.com"/><meta property="og:url" content="https://solutionschecker.com"/><meta property="og:type" content="website"/><meta property="og:image" content="https://solutionschecker.com/solutions-checker-banner.png"/><meta property="og:image:alt" content="Find solution for coding, HTML, CSS, JAVASCRIPT, MYSQL, PHP, PYTHON,... quickly. - solutionschecker.com"/><script type="application/ld+json">{"@context":"https://schema.org","@type":"Organization","logo":"/logo.svg","url":"https://solutionschecker.com"}</script><script type="application/ld+json">{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"item":{"@id":"https://solutionschecker.com","name":"Home"}},{"@type":"ListItem","position":2,"item":{"@id":"https://solutionschecker.com/questions","name":"Questions"}},{"@type":"ListItem","position":3,"item":{"@id":"https://solutionschecker.com/questions/performance-optimization-strategies-of-last-resort-closed-1657388420614","name":"Questions"}}]}</script><title>Performance optimization strategies of last resort [closed] | Solutions Checker</title><meta name="robots" content="index,follow"/><meta name="description" content="
            
        
            
                
                    
                        Closed. This question needs to be more focused. It is not currently accepting answers.
                        
                    
                
            
        
            
        
            
                
                        
                            
                        
                    Want to improve this question? Update the question so it focuses on one problem only by editing this post.
                
                    
                        Closed 8 years ago.
                    
                

                
            
        
            
                    
                        Improve this question
                    
            


    

There are plenty of performance questions on this site already, but it occurs to me that almost all are very problem-specific and fairly narrow. And almost all repeat the advice to avoid premature optimization.

Let&#x27;s assume:


the code already is working correctly
the algorithms chosen are already optimal for the circumstances of the problem
the code has been measured, and the offending routines have been isolated
all attempts to optimize will also be measured to ensure they do not make matters worse


What I am looking for here is strategies and tricks to squeeze out up to the last few percent in a critical algorithm when there is nothing else left to do but whatever it takes.

Ideally, try to make answers language agnostic, and indicate any down-sides to the suggested strategies where applicable.

I&#x27;ll add a reply with my own initial suggestions, and look forward to whatever else the Stack Overflow community can think of.
    "/><meta property="og:title" content="Performance optimization strategies of last resort [closed] | Solutions Checker"/><meta property="og:description" content="
            
        
            
                
                    
                        Closed. This question needs to be more focused. It is not currently accepting answers.
                        
                    
                
            
        
            
        
            
                
                        
                            
                        
                    Want to improve this question? Update the question so it focuses on one problem only by editing this post.
                
                    
                        Closed 8 years ago.
                    
                

                
            
        
            
                    
                        Improve this question
                    
            


    

There are plenty of performance questions on this site already, but it occurs to me that almost all are very problem-specific and fairly narrow. And almost all repeat the advice to avoid premature optimization.

Let&#x27;s assume:


the code already is working correctly
the algorithms chosen are already optimal for the circumstances of the problem
the code has been measured, and the offending routines have been isolated
all attempts to optimize will also be measured to ensure they do not make matters worse


What I am looking for here is strategies and tricks to squeeze out up to the last few percent in a critical algorithm when there is nothing else left to do but whatever it takes.

Ideally, try to make answers language agnostic, and indicate any down-sides to the suggested strategies where applicable.

I&#x27;ll add a reply with my own initial suggestions, and look forward to whatever else the Stack Overflow community can think of.
    "/><script type="application/ld+json">{"@context":"https://schema.org","@type":"QAPage","mainEntity":{"name":"Performance optimization strategies of last resort [closed]","text":"\n            \n        \n            \n                \n                    \n                        Closed. This question needs to be more focused. It is not currently accepting answers.\n                        \n                    \n                \n            \n        \n            \n        \n            \n                \n                        \n                            \n                        \n                    Want to improve this question? Update the question so it focuses on one problem only by editing this post.\n                \n                    \n                        Closed 8 years ago.\n                    \n                \n\n                \n            \n        \n            \n                    \n                        Improve this question\n                    \n            \n\n\n    \n\nThere are plenty of performance questions on this site already, but it occurs to me that almost all are very problem-specific and fairly narrow. And almost all repeat the advice to avoid premature optimization.\n\nLet&apos;s assume:\n\n\nthe code already is working correctly\nthe algorithms chosen are already optimal for the circumstances of the problem\nthe code has been measured, and the offending routines have been isolated\nall attempts to optimize will also be measured to ensure they do not make matters worse\n\n\nWhat I am looking for here is strategies and tricks to squeeze out up to the last few percent in a critical algorithm when there is nothing else left to do but whatever it takes.\n\nIdeally, try to make answers language agnostic, and indicate any down-sides to the suggested strategies where applicable.\n\nI&apos;ll add a reply with my own initial suggestions, and look forward to whatever else the Stack Overflow community can think of.\n    ","answerCount":30,"upVoteCount":500,"suggestedAnswer":[{"text":"OK, you&apos;re defining the problem to where it would seem there is not much room for improvement. That is fairly rare, in my experience. I tried to explain this in a Dr. Dobbs article in November 1993, by starting from a conventionally well-designed non-trivial program with no obvious waste and taking it through a series of optimizations until its wall-clock time was reduced from 48 seconds to 1.1 seconds, and the source code size was reduced by a factor of 4. My diagnostic tool was this. The sequence of changes was this:\n\n\nThe first problem found was use of list clusters (now called &quot;iterators&quot; and &quot;container classes&quot;) accounting for over half the time. Those were replaced with fairly simple code, bringing the time down to 20 seconds.\nNow the largest time-taker is more list-building. As a percentage, it was not so big before, but now it is because the bigger problem was removed. I find a way to speed it up, and the time drops to 17 seconds.\nNow it is harder to find obvious culprits, but there are a few smaller ones that I can do something about, and the time drops to 13 sec.\n\n\nNow I seem to have hit a wall. The samples are telling me exactly what it is doing, but I can&apos;t seem to find anything that I can improve. Then I reflect on the basic design of the program, on its transaction-driven structure, and ask if all the list-searching that it is doing is actually mandated by the requirements of the problem.\n\nThen I hit upon a re-design, where the program code is actually generated (via preprocessor macros) from a smaller set of source, and in which the program is not constantly figuring out things that the programmer knows are fairly predictable. In other words, don&apos;t &quot;interpret&quot; the sequence of things to do, &quot;compile&quot; it.\n\n\nThat redesign is done, shrinking the source code by a factor of 4, and the time is reduced to 10 seconds.\n\n\nNow, because it&apos;s getting so quick, it&apos;s hard to sample, so I give it 10 times as much work to do, but the following times are based on the original workload.\n\n\nMore diagnosis reveals that it is spending time in queue-management. In-lining these reduces the time to 7 seconds.\nNow a big time-taker is the diagnostic printing I had been doing. Flush that - 4 seconds.\nNow the biggest time-takers are calls to malloc and free. Recycle objects - 2.6 seconds.\nContinuing to sample, I still find operations that are not strictly necessary - 1.1 seconds.\n\n\nTotal speedup factor: 43.6\n\nNow no two programs are alike, but in non-toy software I&apos;ve always seen a progression like this. First you get the easy stuff, and then the more difficult, until you get to a point of diminishing returns. Then the insight you gain may well lead to a redesign, starting a new round of speedups, until you again hit diminishing returns. Now this is the point at which it might make sense to wonder whether ++i or i++ or for(;;) or while(1) are faster: the kinds of questions I see so often on StackÂ Overflow.\n\nP.S. It may be wondered why I didn&apos;t use a profiler. The answer is that almost every one of these &quot;problems&quot; was a function call site, which stack samples pinpoint. Profilers, even today, are just barely coming around to the idea that statements and call instructions are more important to locate, and easier to fix, than whole functions.\n\nI actually built a profiler to do this, but for a real down-and-dirty intimacy with what the code is doing, there&apos;s no substitute for getting your fingers right in it. It is not an issue that the number of samples is small, because none of the problems being found are so tiny that they are easily missed.\n\nADDED: jerryjvl requested some examples. Here is the first problem. It consists of a small number of separate lines of code, together taking over half the time:\n\n /* IF ALL TASKS DONE, SEND ITC_ACKOP, AND DELETE OP */\nif (ptop-&gt;current_task &gt;= ILST_LENGTH(ptop-&gt;tasklist){\n. . .\n/* FOR EACH OPERATION REQUEST */\nfor ( ptop = ILST_FIRST(oplist); ptop != NULL; ptop = ILST_NEXT(oplist, ptop)){\n. . .\n/* GET CURRENT TASK */\nptask = ILST_NTH(ptop-&gt;tasklist, ptop-&gt;current_task)\n\n\nThese were using the list cluster ILST (similar to a list class). They are implemented in the usual way, with &quot;information hiding&quot; meaning that the users of the class were not supposed to have to care how they were implemented. When these lines were written (out of roughly 800 lines of code) thought was not given to the idea that these could be a &quot;bottleneck&quot; (I hate that word). They are simply the recommended way to do things. It is easy to say in hindsight that these should have been avoided, but in my experience all performance problems are like that. In general, it is good to try to avoid creating performance problems. It is even better to find and fix the ones that are created, even though they &quot;should have been avoided&quot; (in hindsight). I hope that gives a bit of the flavor.\n\nHere is the second problem, in two separate lines:\n\n /* ADD TASK TO TASK LIST */\nILST_APPEND(ptop-&gt;tasklist, ptask)\n. . .\n/* ADD TRANSACTION TO TRANSACTION QUEUE */\nILST_APPEND(trnque, ptrn)\n\n\nThese are building lists by appending items to their ends. (The fix was to collect the items in arrays, and build the lists all at once.) The interesting thing is that these statements only cost (i.e. were on the call stack) 3/48 of the original time, so they were not in fact a big problem at the beginning. However, after removing the first problem, they cost 3/20 of the time and so were now a &quot;bigger fish&quot;. In general, that&apos;s how it goes.\n\nI might add that this project was distilled from a real project I helped on. In that project, the performance problems were far more dramatic (as were the speedups), such as calling a database-access routine within an inner loop to see if a task was finished.\n\nREFERENCE ADDED:\nThe source code, both original and redesigned, can be found in www.ddj.com, for 1993, in file 9311.zip, files slug.asc and slug.zip.\n\nEDIT 2011/11/26:\nThere is now a SourceForge project containing source code in Visual C++ and a blow-by-blow description of how it was tuned. It only goes through the first half of the scenario described above, and it doesn&apos;t follow exactly the same sequence, but still gets a 2-3 order of magnitude speedup.\n    ","url":"/questions/[slug]#solution1","@type":"Answer","upvoteCount":0},{"text":"Suggestions:\n\n\nPre-compute rather than re-calculate: any loops or repeated calls that contain calculations that have a relatively limited range of inputs, consider making a lookup (array or dictionary) that contains the result of that calculation for all values in the valid range of inputs. Then use a simple lookup inside the algorithm instead.\nDown-sides: if few of the pre-computed values are actually used this may make matters worse, also the lookup may take significant memory.\nDon&apos;t use library methods: most libraries need to be written to operate correctly under a broad range of scenarios, and perform null checks on parameters, etc. By re-implementing a method you may be able to strip out a lot of logic that does not apply in the exact circumstance you are using it.\nDown-sides: writing additional code means more surface area for bugs.\nDo use library methods: to contradict myself, language libraries get written by people that are a lot smarter than you or me; odds are they did it better and faster. Do not implement it yourself unless you can actually make it faster (i.e.: always measure!)\nCheat: in some cases although an exact calculation may exist for your problem, you may not need &apos;exact&apos;, sometimes an approximation may be &apos;good enough&apos; and a lot faster in the deal. Ask yourself, does it really matter if the answer is out by 1%? 5%? even 10%?\nDown-sides: Well... the answer won&apos;t be exact.\n\n    ","url":"/questions/[slug]#solution2","@type":"Answer","upvoteCount":0},{"text":"When you can&apos;t improve the performance any more - see if you can improve the perceived performance instead.\n\nYou may not be able to make your fooCalc algorithm faster, but often there are ways to make your application seem more responsive to the user. \n\nA few examples:\n\n\nanticipating what the user is going\nto request and start working on that\nbefore then\ndisplaying results as\nthey come in, instead of all at once\nat the end\nAccurate progress meter\n\n\nThese won&apos;t make your program faster, but it might make your users happier with the speed you have.\n    ","url":"/questions/[slug]#solution3","@type":"Answer","upvoteCount":0},{"text":"I spend most of my life in just this place. The broad strokes are to run your profiler and get it to record:\n\n\nCache misses. Data cache is the #1 source of stalls in most programs. Improve cache hit rate by reorganizing offending data structures to have better locality; pack structures and numerical types down to eliminate wasted bytes (and therefore wasted cache fetches); prefetch data wherever possible to reduce stalls.\nLoad-hit-stores. Compiler assumptions about pointer aliasing, and cases where data is moved between disconnected register sets via memory, can cause a certain pathological behavior that causes the entire CPU pipeline to clear on a load op. Find places where floats, vectors, and ints are being cast to one another and eliminate them. Use __restrict liberally to promise the compiler about aliasing.\nMicrocoded operations. Most processors have some operations that cannot be pipelined, but instead run a tiny subroutine stored in ROM. Examples on the PowerPC are integer multiply, divide, and shift-by-variable-amount. The problem is that the entire pipeline stops dead while this operation is executing. Try to eliminate use of these operations or at least break them down into their constituent pipelined ops so you can get the benefit of superscalar dispatch on whatever the rest of your program is doing.\nBranch mispredicts. These too empty the pipeline. Find cases where the CPU is spending a lot of time refilling the pipe after a branch, and use branch hinting if available to get it to predict correctly more often. Or better yet, replace branches with conditional-moves wherever possible, especially after floating point operations because their pipe is usually deeper and reading the condition flags after fcmp can cause a stall.\nSequential floating-point ops. Make these SIMD.\n\n\nAnd one more thing I like to do:\n\n\nSet your compiler to output assembly listings and look at what it emits for the hotspot functions in your code. All those clever optimizations that &quot;a good compiler should be able to do for you automatically&quot;? Chances are your actual compiler doesn&apos;t do them. I&apos;ve seen GCC emit truly WTF code.\n\n    ","url":"/questions/[slug]#solution4","@type":"Answer","upvoteCount":0},{"text":"Throw more hardware at it!\n    ","url":"/questions/[slug]#solution5","@type":"Answer","upvoteCount":0},{"text":"More suggestions:\n\n\nAvoid I/O: Any I/O (disk, network, ports, etc.) is\nalways going to be far slower than any code that is\nperforming calculations, so get rid of any I/O that you do\nnot strictly need.\nMove I/O up-front: Load up all the data you are going\nto need for a calculation up-front, so that you do not\nhave repeated I/O waits within the core of a critical\nalgorithm (and maybe as a result repeated disk seeks, when\nloading all the data in one hit may avoid seeking).\nDelay I/O: Do not write out your results until the\ncalculation is over, store them in a data structure and\nthen dump that out in one go at the end when the hard work\nis done.\nThreaded I/O: For those daring enough, combine &apos;I/O\nup-front&apos; or &apos;Delay I/O&apos; with the actual calculation by\nmoving the loading into a parallel thread, so that while\nyou are loading more data you can work on a calculation on\nthe data you already have, or while you calculate the next\nbatch of data you can simultaneously write out the results\nfrom the last batch.\n\n    ","url":"/questions/[slug]#solution6","@type":"Answer","upvoteCount":0},{"text":"Since many of the performance problems involve database issues, I&apos;ll give you some specific things to look at when tuning queries and stored procedures.\n\nAvoid cursors in most databases. Avoid looping as well. Most of the time, data access should be set-based, not record by record processing. This includes not reusing a single record stored procedure when you want to insert 1,000,000 records at once.\n\nNever use select *, only return the fields you actually need. This is especially true if there are any joins as the join fields will be repeated and thus cause unnecesary load on both the server and the network.\n\nAvoid the use of correlated subqueries. Use joins (including joins to derived tables where possible) (I know this is true for Microsoft SQL Server, but test the advice when using a differnt backend).\n\nIndex, index, index. And get those stats updated if applicable to your database.\n\nMake the query sargable. Meaning avoid things which make it impossible to use the indexes such as using a wildcard in the first character of a like clause or a function in the join or as the left part of a where statement.\n\nUse correct data types. It is faster to do date math on a date field than to have to try to convert a string datatype to a date datatype, then do the calculation.\n\nNever put a loop of any kind into a trigger!\n\nMost databases have a way to check how the query execution will be done. In Microsoft SQL Server this is called an execution plan. Check those first to see where problem areas lie.\n\nConsider how often the query runs as well as how long it takes to run when determining what needs to be optimized. Sometimes you can gain more perfomance from a slight tweak to a query that runs millions of times a day than you can from wiping time off a long_running query that only runs once a month.\n\nUse some sort of profiler tool to find out what is really being sent to and from the database. I can remember one time in the past where we couldn&apos;t figure out why the page was so slow to load when the stored procedure was fast and found out through profiling that the webpage was asking for the query many many times instead of once. \n\nThe profiler will also help you to find who are blocking who. Some queries that execute quickly while running alone may become really slow due to locks from other queries.\n    ","url":"/questions/[slug]#solution7","@type":"Answer","upvoteCount":0},{"text":"The single most important limiting factor today is the limited memory bandwitdh. Multicores are just making this worse, as the bandwidth is shared betwen cores. Also, the limited chip area devoted to implementing caches is also divided among the cores and threads, worsening this problem even more. Finally, the inter-chip signalling needed to keep the different caches coherent also increase with an increased number of cores. This also adds a penalty.\n\nThese are the effects that you need to manage. Sometimes through micro managing your code, but sometimes through careful consideration and refactoring.\n\nA lot of comments already mention cache friendly code. There are at least two distinct flavors of this:\n\n\nAvoid memory fetch latencies.\nLower memory bus pressure (bandwidth).\n\n\nThe first problem specifically has to do with making your data access patterns more regular, allowing the hardware prefetcher to work efficiently. Avoid dynamic memory allocation which spreads your data objects around in memory. Use linear containers instead of linked lists, hashes and trees.\n\nThe second problem has to do with improving data reuse. Alter your algorithms to work on subsets of your data that do fit in available cache, and reuse that data as much as possible while it is still in the cache.\n\nPacking data tighter and making sure you use all data in cache lines in the hot loops, will help avoid these other effects, and allow fitting more useful data in the cache.\n    ","url":"/questions/[slug]#solution8","@type":"Answer","upvoteCount":0},{"text":"\nWhat hardware are you running on? Can you use platform-specific optimizations (like vectorization)?\nCan you get a better compiler? E.g. switch from GCC to Intel?\nCan you make your algorithm run in parallel?\nCan you reduce cache misses by reorganizing data?\nCan you disable asserts?\nMicro-optimize for your compiler and platform. In the style of, &quot;at an if/else, put the most common statement first&quot;\n\n    ","url":"/questions/[slug]#solution9","@type":"Answer","upvoteCount":0},{"text":"Although I like Mike Dunlavey&apos;s answer, in fact it is a great answer indeed with supporting example, I think it could be expressed very simply thus:\n\nFind out what takes the largest amounts of time first, and understand why.\n\nIt is the identification process of the time hogs that helps you understand where you must refine your algorithm. This is the only all-encompassing language agnostic answer I can find to a problem that&apos;s already supposed to be fully optimised. Also presuming you want to be architecture independent in your quest for speed.\n\nSo while the algorithm may be optimised, the implementation of it may not be. The identification allows you to know which part is which: algorithm or implementation. So whichever hogs the time the most is your prime candidate for review. But since you say you want to squeeze the last few % out, you might want to also examine the lesser parts, the parts that you have not examined that closely at first.\n\nLastly a bit of trial and error with performance figures on different ways to implement the same solution, or potentially different algorithms, can bring insights that help identify time wasters and time savers.\n\nHPH,\nasoudmove.\n    ","url":"/questions/[slug]#solution10","@type":"Answer","upvoteCount":0},{"text":"You should probably consider the &quot;Google perspective&quot;, i.e. determine how your application can become largely parallelized and concurrent, which will inevitably also mean at some point to look into distributing your application across different machines and networks, so that it can ideally scale almost linearly with the hardware that you throw at it.\n\nOn the other hand, the Google folks are also known for throwing lots of manpower and resources at solving some of the issues in projects, tools and infrastructure they are using, such as for example whole program optimization for gcc by having a dedicated team of engineers hacking gcc internals in order to prepare it for Google-typical use case scenarios.\n\nSimilarly, profiling an application no longer means to simply profile the program code, but also all its surrounding systems and infrastructure (think networks, switches, server, RAID arrays) in order to identify redundancies and optimization potential from a system&apos;s point of view.\n    ","url":"/questions/[slug]#solution11","@type":"Answer","upvoteCount":0},{"text":"\nInline routines (eliminate call/return and parameter pushing)\nTry eliminating tests/switches with table look ups (if they&apos;re faster)\nUnroll loops (Duff&apos;s device) to the point where they just fit in the CPU cache\nLocalize memory access so as not to blow your cache\nLocalize related calculations if the optimizer isn&apos;t already doing that\nEliminate loop invariants if the optimizer isn&apos;t already doing that\n\n    ","url":"/questions/[slug]#solution12","@type":"Answer","upvoteCount":0},{"text":"\nWhen you get to the point that you&apos;re using efficient algorithms its a question of what you need more speed or memory. Use caching to &quot;pay&quot; in memory for more speed or use calculations to reduce the memory footprint.\nIf possible (and more cost effective) throw hardware at the problem - faster CPU, more memory or HD could solve the problem faster then trying to code it.\nUse parallelization if possible - run part of the code on multiple threads.\nUse the right tool for the job. some programing languages create more efficient code, using managed code (i.e. Java/.NET) speed up development but native programing languages creates faster running code. \nMicro optimize. Only were applicable you can use optimized assembly to speed small pieces of code, using SSE/vector optimizations in the right places can greatly increase performance.\n\n    ","url":"/questions/[slug]#solution13","@type":"Answer","upvoteCount":0},{"text":"Divide and conquer\n\nIf the dataset being processed is too large, loop over chunks of it. If you&apos;ve done your code right, implementation should be easy. If you have a monolithic program, now you know better.\n    ","url":"/questions/[slug]#solution14","@type":"Answer","upvoteCount":0},{"text":"First of all, as mentioned in several prior answers, learn what bites your performance - is it memory or processor or network or database or something else. Depending on that...\n\n\n...if it&apos;s memory - find one of the books written long time ago by Knuth, one of &quot;The Art of Computer Programming&quot; series. Most likely it&apos;s one about sorting and search - if my memory is wrong then you&apos;ll have to find out in which he talks about how to deal with slow tape data storage. Mentally transform his memory/tape pair into your pair of cache/main memory (or in pair of L1/L2 cache) respectively. Study all the tricks he describes - if you don&apos;s find something that solves your problem, then hire professional computer scientist to conduct a professional research. If your memory issue is by chance with FFT (cache misses at bit-reversed indexes when doing radix-2 butterflies) then don&apos;t hire a scientist - instead, manually optimize passes one-by-one until you&apos;re either win or get to dead end. You mentioned squeeze out up to the last few percent right? If it&apos;s few indeed you&apos;ll most likely win.\n...if it&apos;s processor - switch to assembly language. Study processor specification - what takes ticks, VLIW, SIMD. Function calls are most likely replaceable tick-eaters. Learn loop transformations - pipeline, unroll. Multiplies and divisions might be replaceable / interpolated with bit shifts (multiplies by small integers might be replaceable with additions). Try tricks with shorter data - if you&apos;re lucky one instruction with 64 bits might turn out replaceable with two on 32 or even 4 on 16 or 8 on 8 bits go figure. Try also longer data - eg your float calculations might turn out slower than double ones at particular processor. If you have trigonometric stuff, fight it with pre-calculated tables; also keep in mind that sine of small value might be replaced with that value if loss of precision is within allowed limits.\n...if it&apos;s network - think of compressing data you pass over it. Replace XML transfer with binary. Study protocols. Try UDP instead of TCP if you can somehow handle data loss.\n...if it&apos;s database, well, go to any database forum and ask for advice. In-memory data-grid, optimizing query plan etc etc etc.\n\n\nHTH :)\n    ","url":"/questions/[slug]#solution15","@type":"Answer","upvoteCount":0},{"text":"Caching! A cheap way (in programmer effort) to make almost anything faster is to add a caching abstraction layer to any data movement area of your program. Be it I/O or just passing/creation of objects or structures. Often it&apos;s easy to add caches to factory classes and reader/writers.\n\nSometimes the cache will not gain you much, but it&apos;s an easy method to just add caching all over and then disable it where it doesn&apos;t help. I&apos;ve often found this to gain huge performance without having to micro-analyse the code.\n    ","url":"/questions/[slug]#solution16","@type":"Answer","upvoteCount":0},{"text":"I think this has already been said in a different way.  But when you&apos;re dealing with a processor intensive algorithm, you should simplify everything inside the most inner loop at the expense of everything else.  \n\nThat may seem obvious to some, but it&apos;s something I try to focus on regardless of the language I&apos;m working with.  If you&apos;re dealing with nested loops, for example, and you find an opportunity to take some code down a level, you can in some cases drastically speed up your code.  As another example, there are the little things to think about like working with integers instead of floating point variables whenever you can, and using multiplication instead of division whenever you can.  Again, these are things that should be considered for your most inner loop.  \n\nSometimes you may find benefit of performing your math operations on an integer inside the inner loop, and then scaling it down to a floating point variable you can work with afterwards.  That&apos;s an example of sacrificing speed in one section to improve the speed in another, but in some cases the pay off can be well worth it.\n    ","url":"/questions/[slug]#solution17","@type":"Answer","upvoteCount":0},{"text":"I&apos;ve spent some time working on optimising client/server business systems operating over low-bandwidth and long-latency networks (e.g. satellite, remote, offshore), and been able to achieve some dramatic performance improvements with a fairly repeatable process.\n\n\nMeasure: Start by understanding the network&apos;s underlying capacity and topology. Talking to the relevant networking people in the business, and make use of basic tools such as ping and traceroute to establish (at a minimum) the network latency from each client location, during typical operational periods. Next, take accurate time measurements of specific end user functions that display the problematic symptoms. Record all of these measurements, along with their locations, dates and times. Consider building end-user &quot;network performance testing&quot; functionality into your client application, allowing your power users to participate in the process of improvement; empowering them like this can have a huge psychological impact when you&apos;re dealing with users frustrated by a poorly performing system.\nAnalyze: Using any and all logging methods available to establish exactly what data is being transmitted and received during the execution of the affected operations. Ideally, your application can capture data transmitted and received by both the client and the server. If these include timestamps as well, even better. If sufficient logging isn&apos;t available (e.g. closed system, or inability to deploy modifications into a production environment), use a network sniffer and make sure you really understand what&apos;s going on at the network level.\nCache: Look for cases where static or infrequently changed data is being transmitted repetitively and consider an appropriate caching strategy. Typical examples include &quot;pick list&quot; values or other &quot;reference entities&quot;, which can be surprisingly large in some business applications. In many cases, users can accept that they must restart or refresh the application to update infrequently updated data, especially if it can shave significant time from the display of commonly used user interface elements. Make sure you understand the real behaviour of the caching elements already deployed - many common caching methods (e.g. HTTP ETag) still require a network round-trip to ensure consistency, and where network latency is expensive, you may be able to avoid it altogether with a different caching approach.\nParallelise: Look for sequential transactions that don&apos;t logically need to be issued strictly sequentially, and rework the system to issue them in parallel. I dealt with one case where an end-to-end request had an inherent network delay of ~2s, which was not a problem for a single transaction, but when 6 sequential 2s round trips were required before the user regained control of the client application, it became a huge source of frustration. Discovering that these transactions were in fact independent allowed them to be executed in parallel, reducing the end-user delay to very close to the cost of a single round trip.\nCombine: Where sequential requests must be executed sequentially, look for opportunities to combine them into a single more comprehensive request. Typical examples include creation of new entities, followed by requests to relate those entities to other existing entities.\nCompress: Look for opportunities to leverage compression of the payload, either by replacing a textual form with a binary one, or using actual compression technology. Many modern (i.e. within a decade) technology stacks support this almost transparently, so make sure it&apos;s configured. I have often been surprised by the significant impact of compression where it seemed clear that the problem was fundamentally latency rather than bandwidth,  discovering after the fact that it allowed the transaction to fit within a single packet or otherwise avoid packet loss and therefore have an outsize impact on performance.\nRepeat: Go back to the beginning and re-measure your operations (at the same locations and times) with the improvements in place, record and report your results. As with all optimisation, some problems may have been solved exposing others that now dominate.\n\n\nIn the steps above, I focus on the application related optimisation process, but of course you must ensure the underlying network itself is configured in the most efficient manner to support your application too. Engage the networking specialists in the business and determine if they&apos;re able to apply capacity improvements, QoS, network compression, or other techniques to address the problem. Usually, they will not understand your application&apos;s needs, so it&apos;s important that you&apos;re equipped (after the Analyse step) to discuss it with them, and also to make the business case for any costs you&apos;re going to be asking them to incur. I&apos;ve encountered cases where erroneous network configuration caused the applications data to be transmitted over a slow satellite link rather than an overland link, simply because it was using a TCP port that was not &quot;well known&quot; by the networking specialists; obviously rectifying a problem like this can have a dramatic impact on performance, with no software code or configuration changes necessary at all.\n    ","url":"/questions/[slug]#solution18","@type":"Answer","upvoteCount":0},{"text":"Very difficult to give a generic answer to this question. It really depends on your problem domain and technical implementation. A general technique that is fairly language neutral: Identify code hotspots that cannot be eliminated, and hand-optimize assembler code. \n    ","url":"/questions/[slug]#solution19","@type":"Answer","upvoteCount":0},{"text":"Last few % is a very CPU and application dependent thing....\n\n\ncache architectures differ, some chips have on-chip RAM\nyou can map directly, ARM&apos;s (sometimes) have a vector\nunit, SH4&apos;s a useful matrix opcode. Is there a GPU -\nmaybe a shader is the way to go. TMS320&apos;s are very\nsensitive to branches within loops (so separate loops and\nmove conditions outside if possible).\n\n\nThe list goes on.... But these sorts of things really are\nthe last resort...\n\nBuild for x86, and run Valgrind/Cachegrind against the code\nfor proper performance profiling. Or Texas Instruments&apos;\nCCStudio has a sweet profiler. Then you&apos;ll really know where\nto focus...\n    ","url":"/questions/[slug]#solution20","@type":"Answer","upvoteCount":0},{"text":"Not nearly as in depth or complex as previous answers, but here goes:\n(these are more beginner/intermediate level)\n\n\nobvious: dry\nrun loops backwards so you&apos;re always comparing to 0 rather than a variable\nuse bitwise operators whenever you can\nbreak repetitive code into modules/functions\ncache objects\nlocal variables have slight performance advantage\nlimit string manipulation as much as possible \n\n    ","url":"/questions/[slug]#solution21","@type":"Answer","upvoteCount":0},{"text":"Did you know that a CAT6 cable is capable of 10x better shielding off external inteferences than a default Cat5e UTP cable?\nFor any non-offline projects, while having best software and best hardware, if your throughoutput is weak, then that thin line is going to squeeze data and give you delays, albeit in milliseconds...\nAlso the maximum throughput is higher on CAT6 cables because there is a higher chance that you will actually receive a cable whose strands exist of cupper cores, instead of CCA, Cupper Cladded Aluminium, which is often fount in all your standard CAT5e cables.\nI if you are facing lost packets, packet drops, then an increase in throughput reliability for 24/7 operation can make the difference that you may be looking for.\nFor those who seek the ultimate in home/office connection reliability, (and are willing to say NO to this years fastfood restaurants, at the end of the year you can there you can) gift yourself the pinnacle of LAN connectivity in the form of  CAT7 cable from a reputable brand.\n    ","url":"/questions/[slug]#solution22","@type":"Answer","upvoteCount":0},{"text":"Impossible to say. It depends on what the code looks like. If we can assume that the code already exists, then we can simply look at it and figure out from that, how to optimize it.\n\nBetter cache locality, loop unrolling, Try to eliminate long dependency chains, to get better instruction-level parallelism. Prefer conditional moves over branches when possible. Exploit SIMD instructions when possible.\n\nUnderstand what your code is doing, and understand the hardware it&apos;s running on. Then it becomes fairly simple to determine what you need to do to improve performance of your code. That&apos;s really the only truly general piece of advice I can think of.\n\nWell, that, and &quot;Show the code on SO and ask for optimization advice for that specific piece of code&quot;.\n    ","url":"/questions/[slug]#solution23","@type":"Answer","upvoteCount":0},{"text":"If better hardware is an option then definitely go for that. Otherwise\n\n\nCheck you are using the best compiler and linker options.\nIf hotspot routine in different library to frequent caller, consider moving or cloning it to the callers module. Eliminates some of the call overhead and may improve cache hits (cf how AIX links strcpy() statically into separately linked shared objects). This could of course decrease cache hits also, which is why one measure.\nSee if there is any possibility of using a specialized version of the hotspot routine. Downside is more than one version to maintain.\nLook at the assembler. If you think it could be better, consider why the compiler did not figure this out, and how you could help the compiler.\nConsider: are you really using the best algorithm? Is it the best algorithm for your input size?\n\n    ","url":"/questions/[slug]#solution24","@type":"Answer","upvoteCount":0},{"text":"The google way is one option &quot;Cache it.. Whenever possible don&apos;t touch the disk&quot;\n    ","url":"/questions/[slug]#solution25","@type":"Answer","upvoteCount":0},{"text":"Here are some quick and dirty optimization techniques I use.  I consider this to be a &apos;first pass&apos; optimization.\n\nLearn where the time is spent Find out exactly what is taking the time.  Is it file  IO?  Is it CPU time?  Is it the network?  Is it the Database?  It&apos;s useless to optimize for IO if that&apos;s not the bottleneck.\n\nKnow Your Environment  Knowing where to optimize typically depends on the development environment.  In VB6, for example, passing by reference is slower than passing by value, but in C and C++, by reference is vastly faster.  In C, it is reasonable to try something and do something different if a return code indicates a failure, while in Dot Net, catching exceptions are much slower than checking for a valid condition before attempting.  \n\nIndexes Build indexes on frequently queried database fields.  You can almost always trade space for speed.\n\nAvoid lookups  Inside of the loop to be optimized, I avoid having to do any lookups.  Find the offset and/or index outside of the loop and reuse the data inside.\n\nMinimize IO try to design in a manner that reduces the number of times you have to read or write especially over a networked connection\n\nReduce Abstractions The more layers of abstraction the code has to work through, the slower it is.  Inside the critical loop, reduce abstractions (e.g. reveal lower-level methods that avoid extra code)\n\nSpawn Threads for projects with a user interface, spawning a new thread to preform slower tasks makes the application feel more responsive, although isn&apos;t.\n\nPre-process You can generally trade space for speed.  If there are calculations or other intense operations, see if you can precompute some of the information before you&apos;re in the critical loop.\n    ","url":"/questions/[slug]#solution26","@type":"Answer","upvoteCount":0},{"text":"If you have a lot of highly parallel floating point math-especially single-precision-try offloading it to a graphics processor (if one is present) using OpenCL or (for NVidia chips) CUDA. GPUs have immense floating point computing power in their shaders, which is much greater than that of a CPU.\n    ","url":"/questions/[slug]#solution27","@type":"Answer","upvoteCount":0},{"text":"Adding this answer since I didnt see it included in all the others.\n\nMinimize implicit conversion between types and sign:\n\nThis applies to C/C++ at least, Even if you already think you&apos;re free of conversions - sometimes its good to test adding compiler warnings around functions that require performance, especially watch-out for conversions within loops.\n\nGCC spesific: You can test this by adding some verbose pragmas around your code,\n\n#ifdef __GNUC__\n#  pragma GCC diagnostic push\n#  pragma GCC diagnostic error &quot;-Wsign-conversion&quot;\n#  pragma GCC diagnostic error &quot;-Wdouble-promotion&quot;\n#  pragma GCC diagnostic error &quot;-Wsign-compare&quot;\n#  pragma GCC diagnostic error &quot;-Wconversion&quot;\n#endif\n\n/* your code */\n\n#ifdef __GNUC__\n#  pragma GCC diagnostic pop\n#endif\n\n\nI&apos;ve seen cases where you can get a few percent speedup by reducing conversions raised by warnings like this.\n\nIn some cases I have a header with strict warnings that I keep included to prevent accidental conversions, however this is a trade-off since you may end up adding a lot of casts to quiet intentional conversions which may just make the code more cluttered for minimal gains.\n    ","url":"/questions/[slug]#solution28","@type":"Answer","upvoteCount":0},{"text":"Sometimes changing the layout of your data can help. In C, you might switch from an array or structures to a structure of arrays, or vice versa.\n    ","url":"/questions/[slug]#solution29","@type":"Answer","upvoteCount":0},{"text":"Tweak the OS and framework.\n\nIt may sound an overkill but think about it like this: Operating Systems and Frameworks are designed to do many things. Your application only does very specific things. If you could get the OS do to exactly what your application needs and have your application understand how the the framework (php,.net,java) works, you could get much better out of your hardware.\n\nFacebook, for example, changed some kernel level thingys in Linux, changed how memcached works (for example they wrote a memcached proxy, and used udp instead of tcp).\n\nAnother example for this is Window2008. Win2K8 has a version were you can install just the basic OS needed to run X applicaions (e.g. Web-Apps, Server Apps). This reduces much of the overhead that the OS have on running processes and gives you better performance.\n\nOf course, you should always throw in more hardware as the first step...\n    ","url":"/questions/[slug]#solution30","@type":"Answer","upvoteCount":0}],"@type":"Question"}}</script><meta name="next-head-count" content="17"/><link rel="preload" href="/_next/static/css/08bcc42a26fe5c92.css" as="style"/><link rel="stylesheet" href="/_next/static/css/08bcc42a26fe5c92.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-0d1b80a048d4787e.js"></script><script src="/_next/static/chunks/webpack-42cdea76c8170223.js" defer=""></script><script src="/_next/static/chunks/framework-4556c45dd113b893.js" defer=""></script><script src="/_next/static/chunks/main-ccfab947c79712f4.js" defer=""></script><script src="/_next/static/chunks/pages/_app-7e79b78ef884195a.js" defer=""></script><script src="/_next/static/chunks/294-106ef8570fa99deb.js" defer=""></script><script src="/_next/static/chunks/490-7f0418bb4354ac73.js" defer=""></script><script src="/_next/static/chunks/pages/questions/%5Bslug%5D-c1a73f3e758d48b9.js" defer=""></script><script src="/_next/static/XDXakEY6gSPdgAODPxtjg/_buildManifest.js" defer=""></script><script src="/_next/static/XDXakEY6gSPdgAODPxtjg/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="wrapper"><header><nav class="bg-white border-gray-200 px-4 lg:px-6 py-2.5 dark:bg-gray-800"><div class="flex flex-wrap justify-between items-center mx-auto max-w-screen-xl"><a class="flex items-center" href="/"><img src="/logo-second.png" class="mr-3 h-6 sm:h-9" alt="Solution Checker Logo"/><h4 class="self-center text-xl font-semibold whitespace-nowrap dark:text-white">Solution Checker</h4></a><div class="flex items-center lg:order-2"><button data-collapse-toggle="mobile-menu-2" type="button" class="inline-flex items-center p-2 ml-1 text-sm text-gray-500 rounded-lg lg:hidden hover:bg-gray-100 focus:outline-none focus:ring-2 focus:ring-gray-200 dark:text-gray-400 dark:hover:bg-gray-700 dark:focus:ring-gray-600" aria-controls="mobile-menu-2" aria-expanded="false"><span class="sr-only">Open main menu</span><svg class="w-6 h-6" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M3 5a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM3 10a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM3 15a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1z" clip-rule="evenodd"></path></svg><svg class="hidden w-6 h-6" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z" clip-rule="evenodd"></path></svg></button></div><div class="hidden justify-between items-center w-full lg:flex lg:w-auto lg:order-1" id="mobile-menu-2"><ul class="flex flex-col mt-4 font-medium lg:flex-row lg:space-x-8 lg:mt-0"><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" aria-current="page" href="/">Home</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/questions?tab=news">Questions</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/post?tab=news">Post</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/questions/performance-optimization-strategies-of-last-resort-closed-1657388420614#">Coding</a></li></ul></div></div></nav></header><div class="main-content"><div class="question my-5"><div class="flex question-header items-center m-auto justify-center"><div class="rounded-xl w-full border p-5 shadow-md bg-white"><div class="flex w-full items-center justify-between border-b pb-3"><div class="flex items-center space-x-3"><div class="text-lg font-bold text-slate-700"><a href="/questions/performance-optimization-strategies-of-last-resort-closed-1657388420614"><h1>Performance optimization strategies of last resort [closed]</h1></a></div></div><div class="flex flex-wrap h-auto justify-end items-center space-x-8"></div></div><div class="question-content mt-5">
                    <div>
            <aside class="s-notice s-notice__info post-notice js-post-notice mb16" role="status">
        <div class="d-flex fd-column fw-nowrap">
            <div class="d-flex fw-nowrap">
                <div class="flex--item wmn0 fl1 lh-lg">
                    <div class="flex--item fl1 lh-lg">
                        <b>Closed</b>. This question needs to be more <a href="/help/closed-questions">focused</a>. It is not currently accepting answers.
                        
                    </div>
                </div>
            </div>
        </div>
            <hr class="my12 outline-none baw0 bb bc-powder-400">
        <div class="fw-nowrap fc-black-600">
            <div class="d-flex fd-column lh-md">
                <div class="mb0 d-flex">
                        <div class="flex--item mr8">
                            <svg aria-hidden="true" class="svg-icon iconLightbulb" width="18" height="18" viewBox="0 0 18 18"><path d="M15 6.38A6.48 6.48 0 0 0 7.78.04h-.02A6.49 6.49 0 0 0 2.05 5.6a6.31 6.31 0 0 0 2.39 5.75c.49.39.76.93.76 1.5v.24c0 1.07.89 1.9 1.92 1.9h2.75c1.04 0 1.92-.83 1.92-1.9v-.2c0-.6.26-1.15.7-1.48A6.32 6.32 0 0 0 15 6.37ZM4.03 5.85A4.49 4.49 0 0 1 8 2.02a4.48 4.48 0 0 1 5 4.36 4.3 4.3 0 0 1-1.72 3.44c-.98.74-1.5 1.9-1.5 3.08v.1H7.2v-.14c0-1.23-.6-2.34-1.53-3.07a4.32 4.32 0 0 1-1.64-3.94ZM10 18a1 1 0 0 0 0-2H7a1 1 0 1 0 0 2h3Z"></path></svg>
                        </div>
                    <p><b>Want to improve this question?</b> Update the question so it focuses on one problem only by <a href="/posts/926266/edit">editing this post</a>.</p>
                </div>
                    <div class="mb0 mt6 d-flex">
                        <p class="ml24 pl2">Closed <span title="2013-11-15 22:32:33Z" class="relativetime">8 years ago</span>.</p>
                    </div>
                <div class="ml24 pl2">

                </div>
            </div>
        </div>
            <div class="mt24 d-flex gsx gs8">
                    <a class="s-btn s-btn__outlined flex--item js-post-notice-edit-post" href="/posts/926266/edit">
                        Improve this question
                    </a>
            </div>
</aside>

    </div>

<p>There are plenty of performance questions on this site already, but it occurs to me that almost all are very problem-specific and fairly narrow. And almost all repeat the advice to avoid premature optimization.</p>

<p>Let's assume:</p>

<ul>
<li>the code already is working correctly</li>
<li>the algorithms chosen are already optimal for the circumstances of the problem</li>
<li>the code has been measured, and the offending routines have been isolated</li>
<li>all attempts to optimize will also be measured to ensure they do not make matters worse</li>
</ul>

<p>What I am looking for here is strategies and tricks to squeeze out up to the last few percent in a critical algorithm when there is nothing else left to do but whatever it takes.</p>

<p>Ideally, try to make answers language agnostic, and indicate any down-sides to the suggested strategies where applicable.</p>

<p>I'll add a reply with my own initial suggestions, and look forward to whatever else the Stack Overflow community can think of.</p>
    </div></div></div><div class="solution-section"><nav class="flex pagination-solution flex-col justify-end"><ul class="inline-flex -space-x-px overflow-auto"><li class="pagination-solution-item"><span data-id="#solution1" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">1</span></li><li class="pagination-solution-item"><span data-id="#solution2" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">2</span></li><li class="pagination-solution-item"><span data-id="#solution3" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">3</span></li><li class="pagination-solution-item"><span data-id="#solution4" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">4</span></li><li class="pagination-solution-item"><span data-id="#solution5" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">5</span></li><li class="pagination-solution-item"><span data-id="#solution6" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">6</span></li><li class="pagination-solution-item"><span data-id="#solution7" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">7</span></li><li class="pagination-solution-item"><span data-id="#solution8" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">8</span></li><li class="pagination-solution-item"><span data-id="#solution9" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">9</span></li><li class="pagination-solution-item"><span data-id="#solution10" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">10</span></li><li class="pagination-solution-item"><span data-id="#solution11" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">11</span></li><li class="pagination-solution-item"><span data-id="#solution12" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">12</span></li><li class="pagination-solution-item"><span data-id="#solution13" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">13</span></li><li class="pagination-solution-item"><span data-id="#solution14" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">14</span></li><li class="pagination-solution-item"><span data-id="#solution15" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">15</span></li><li class="pagination-solution-item"><span data-id="#solution16" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">16</span></li><li class="pagination-solution-item"><span data-id="#solution17" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">17</span></li><li class="pagination-solution-item"><span data-id="#solution18" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">18</span></li><li class="pagination-solution-item"><span data-id="#solution19" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">19</span></li><li class="pagination-solution-item"><span data-id="#solution20" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">20</span></li><li class="pagination-solution-item"><span data-id="#solution21" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">21</span></li><li class="pagination-solution-item"><span data-id="#solution22" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">22</span></li><li class="pagination-solution-item"><span data-id="#solution23" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">23</span></li><li class="pagination-solution-item"><span data-id="#solution24" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">24</span></li><li class="pagination-solution-item"><span data-id="#solution25" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">25</span></li><li class="pagination-solution-item"><span data-id="#solution26" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">26</span></li><li class="pagination-solution-item"><span data-id="#solution27" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">27</span></li><li class="pagination-solution-item"><span data-id="#solution28" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">28</span></li><li class="pagination-solution-item"><span data-id="#solution29" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">29</span></li><li class="pagination-solution-item"><span data-id="#solution30" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">30</span></li></ul></nav><div id="solution1" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 1</h4><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>OK, you're defining the problem to where it would seem there is not much room for improvement. That is fairly rare, in my experience. I tried to explain this in a Dr. Dobbs article in November 1993, by starting from a conventionally well-designed non-trivial program with no obvious waste and taking it through a series of optimizations until its wall-clock time was reduced from 48 seconds to 1.1 seconds, and the source code size was reduced by a factor of 4. My diagnostic tool <a href="https://stackoverflow.com/questions/375913/what-can-i-use-to-profile-c-code-in-linux/378024#378024">was this</a>. The sequence of changes was this:</p>

<ul>
<li><p>The first problem found was use of list clusters (now called "iterators" and "container classes") accounting for over half the time. Those were replaced with fairly simple code, bringing the time down to 20 seconds.</p></li>
<li><p>Now the largest time-taker is more list-building. As a percentage, it was not so big before, but now it is because the bigger problem was removed. I find a way to speed it up, and the time drops to 17 seconds.</p></li>
<li><p>Now it is harder to find obvious culprits, but there are a few smaller ones that I can do something about, and the time drops to 13 sec.</p></li>
</ul>

<p>Now I seem to have hit a wall. The samples are telling me exactly what it is doing, but I can't seem to find anything that I can improve. Then I reflect on the basic design of the program, on its transaction-driven structure, and ask if all the list-searching that it is doing is actually mandated by the requirements of the problem.</p>

<p>Then I hit upon a re-design, where the program code is actually generated (via preprocessor macros) from a smaller set of source, and in which the program is not constantly figuring out things that the programmer knows are fairly predictable. In other words, don't "interpret" the sequence of things to do, "compile" it.</p>

<ul>
<li>That redesign is done, shrinking the source code by a factor of 4, and the time is reduced to 10 seconds.</li>
</ul>

<p>Now, because it's getting so quick, it's hard to sample, so I give it 10 times as much work to do, but the following times are based on the original workload.</p>

<ul>
<li><p>More diagnosis reveals that it is spending time in queue-management. In-lining these reduces the time to 7 seconds.</p></li>
<li><p>Now a big time-taker is the diagnostic printing I had been doing. Flush that - 4 seconds.</p></li>
<li><p>Now the biggest time-takers are calls to <em>malloc</em> and <em>free</em>. Recycle objects - 2.6 seconds.</p></li>
<li><p>Continuing to sample, I still find operations that are not strictly necessary - 1.1 seconds.</p></li>
</ul>

<p>Total speedup factor: 43.6</p>

<p>Now no two programs are alike, but in non-toy software I've always seen a progression like this. First you get the easy stuff, and then the more difficult, until you get to a point of diminishing returns. Then the insight you gain may well lead to a redesign, starting a new round of speedups, until you again hit diminishing returns. Now this is the point at which it might make sense to wonder whether <code>++i</code> or <code>i++</code> or <code>for(;;)</code> or <code>while(1)</code> are faster: the kinds of questions I see so often on Stack&nbsp;Overflow.</p>

<p>P.S. It may be wondered why I didn't use a profiler. The answer is that almost every one of these "problems" was a function call site, which stack samples pinpoint. Profilers, even today, are just barely coming around to the idea that statements and call instructions are more important to locate, and easier to fix, than whole functions.</p>

<p>I actually built a profiler to do this, but for a real down-and-dirty intimacy with what the code is doing, there's no substitute for getting your fingers right in it. It is not an issue that the number of samples is small, because none of the problems being found are so tiny that they are easily missed.</p>

<p>ADDED: jerryjvl requested some examples. Here is the first problem. It consists of a small number of separate lines of code, together taking over half the time:</p>

<pre><code> /* IF ALL TASKS DONE, SEND ITC_ACKOP, AND DELETE OP */
if (ptop-&gt;current_task &gt;= ILST_LENGTH(ptop-&gt;tasklist){
. . .
/* FOR EACH OPERATION REQUEST */
for ( ptop = ILST_FIRST(oplist); ptop != NULL; ptop = ILST_NEXT(oplist, ptop)){
. . .
/* GET CURRENT TASK */
ptask = ILST_NTH(ptop-&gt;tasklist, ptop-&gt;current_task)
</code></pre>

<p>These were using the list cluster ILST (similar to a list class). They are implemented in the usual way, with "information hiding" meaning that the users of the class were not supposed to have to care how they were implemented. When these lines were written (out of roughly 800 lines of code) thought was not given to the idea that these could be a "bottleneck" (I hate that word). They are simply the recommended way to do things. It is easy to say <em>in hindsight</em> that these should have been avoided, but in my experience <em>all</em> performance problems are like that. In general, it is good to try to avoid creating performance problems. It is even better to find and fix the ones that are created, even though they "should have been avoided" (in hindsight). I hope that gives a bit of the flavor.</p>

<p>Here is the second problem, in two separate lines:</p>

<pre><code> /* ADD TASK TO TASK LIST */
ILST_APPEND(ptop-&gt;tasklist, ptask)
. . .
/* ADD TRANSACTION TO TRANSACTION QUEUE */
ILST_APPEND(trnque, ptrn)
</code></pre>

<p>These are building lists by appending items to their ends. (The fix was to collect the items in arrays, and build the lists all at once.) The interesting thing is that these statements only cost (i.e. were on the call stack) 3/48 of the original time, so they were not in fact a big problem <em>at the beginning</em>. However, after removing the first problem, they cost 3/20 of the time and so were now a "bigger fish". In general, that's how it goes.</p>

<p>I might add that this project was distilled from a real project I helped on. In that project, the performance problems were far more dramatic (as were the speedups), such as calling a database-access routine within an inner loop to see if a task was finished.</p>

<p>REFERENCE ADDED:
The source code, both original and redesigned, can be found in <a href="http://www.drdobbs.com/parallel/performance-tuning-slugging-it-out/184409106" rel="noreferrer">www.ddj.com</a>, for 1993, in file 9311.zip, files slug.asc and slug.zip.</p>

<p>EDIT 2011/11/26:
There is now a <a href="https://sourceforge.net/projects/randompausedemo/" rel="noreferrer">SourceForge project</a> containing source code in Visual C++ and a blow-by-blow description of how it was tuned. It only goes through the first half of the scenario described above, and it doesn't follow exactly the same sequence, but still gets a 2-3 order of magnitude speedup.</p>
    </div></div></div></div><div id="solution2" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 2</h4><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Suggestions:</p>

<ul>
<li><strong>Pre-compute rather than re-calculate</strong>: any loops or repeated calls that contain calculations that have a relatively limited range of inputs, consider making a lookup (array or dictionary) that contains the result of that calculation for all values in the valid range of inputs. Then use a simple lookup inside the algorithm instead.<br>
<em>Down-sides</em>: if few of the pre-computed values are actually used this may make matters worse, also the lookup may take significant memory.</li>
<li><strong>Don't use library methods</strong>: most libraries need to be written to operate correctly under a broad range of scenarios, and perform null checks on parameters, etc. By re-implementing a method you may be able to strip out a lot of logic that does not apply in the exact circumstance you are using it.<br>
<em>Down-sides</em>: writing additional code means more surface area for bugs.</li>
<li><strong>Do use library methods</strong>: to contradict myself, language libraries get written by people that are a lot smarter than you or me; odds are they did it better and faster. Do not implement it yourself unless you can actually make it faster (i.e.: always measure!)</li>
<li><strong>Cheat</strong>: in some cases although an exact calculation may exist for your problem, you may not need 'exact', sometimes an approximation may be 'good enough' and a lot faster in the deal. Ask yourself, does it really matter if the answer is out by 1%? 5%? even 10%?<br>
<em>Down-sides</em>: Well... the answer won't be exact.</li>
</ul>
    </div></div></div></div><div id="solution3" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 3</h4><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>When you can't improve the performance any more - see if you can improve the <strong>perceived</strong> performance instead.</p>

<p>You may not be able to make your fooCalc algorithm faster, but often there are ways to make your application seem more responsive to the user. </p>

<p>A few examples:</p>

<ul>
<li>anticipating what the user is going
to request and start working on that
before then</li>
<li>displaying results as
they come in, instead of all at once
at the end</li>
<li><em>Accurate</em> progress meter</li>
</ul>

<p>These won't make your program faster, but it might make your users happier with the speed you have.</p>
    </div></div></div></div><div id="solution4" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 4</h4><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>I spend most of my life in just this place. The broad strokes are to run your profiler and get it to record:</p>

<ul>
<li><strong>Cache misses</strong>. Data cache is the #1 source of stalls in most programs. Improve cache hit rate by reorganizing offending data structures to have better locality; pack structures and numerical types down to eliminate wasted bytes (and therefore wasted cache fetches); prefetch data wherever possible to reduce stalls.</li>
<li><strong>Load-hit-stores</strong>. Compiler assumptions about pointer aliasing, and cases where data is moved between disconnected register sets via memory, can cause a certain pathological behavior that causes the entire CPU pipeline to clear on a load op. Find places where floats, vectors, and ints are being cast to one another and eliminate them. Use <code>__restrict</code> liberally to promise the compiler about aliasing.</li>
<li><strong>Microcoded operations</strong>. Most processors have some operations that cannot be pipelined, but instead run a tiny subroutine stored in ROM. Examples on the PowerPC are integer multiply, divide, and shift-by-variable-amount. The problem is that the entire pipeline stops dead while this operation is executing. Try to eliminate use of these operations or at least break them down into their constituent pipelined ops so you can get the benefit of superscalar dispatch on whatever the rest of your program is doing.</li>
<li><strong>Branch mispredicts</strong>. These too empty the pipeline. Find cases where the CPU is spending a lot of time refilling the pipe after a branch, and use branch hinting if available to get it to predict correctly more often. Or better yet, replace branches with conditional-moves wherever possible, <em>especially</em> after floating point operations because their pipe is usually deeper and reading the condition flags after fcmp can cause a stall.</li>
<li><strong>Sequential floating-point ops</strong>. Make these SIMD.</li>
</ul>

<p>And one more thing I like to do:</p>

<ul>
<li><strong>Set your compiler to output assembly listings</strong> and look at what it emits for the hotspot functions in your code. All those clever optimizations that "a good compiler should be able to do for you automatically"? Chances are your actual compiler doesn't do them. I've seen GCC emit truly WTF code.</li>
</ul>
    </div></div></div></div><div id="solution5" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 5</h4><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Throw more hardware at it!</p>
    </div></div></div></div><div id="solution6" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 6</h4><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>More suggestions:</p>

<ul>
<li><p><strong>Avoid I/O</strong>: Any I/O (disk, network, ports, etc.) is
always going to be far slower than any code that is
performing calculations, so get rid of any I/O that you do
not strictly need.</p></li>
<li><p><strong>Move I/O up-front</strong>: Load up all the data you are going
to need for a calculation up-front, so that you do not
have repeated I/O waits within the core of a critical
algorithm (and maybe as a result repeated disk seeks, when
loading all the data in one hit may avoid seeking).</p></li>
<li><p><strong>Delay I/O</strong>: Do not write out your results until the
calculation is over, store them in a data structure and
then dump that out in one go at the end when the hard work
is done.</p></li>
<li><p><strong>Threaded I/O</strong>: For those daring enough, combine 'I/O
up-front' or 'Delay I/O' with the actual calculation by
moving the loading into a parallel thread, so that while
you are loading more data you can work on a calculation on
the data you already have, or while you calculate the next
batch of data you can simultaneously write out the results
from the last batch.</p></li>
</ul>
    </div></div></div></div><div id="solution7" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 7</h4><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Since many of the performance problems involve database issues, I'll give you some specific things to look at when tuning queries and stored procedures.</p>

<p>Avoid cursors in most databases. Avoid looping as well. Most of the time, data access should be set-based, not record by record processing. This includes not reusing a single record stored procedure when you want to insert 1,000,000 records at once.</p>

<p>Never use select *, only return the fields you actually need. This is especially true if there are any joins as the join fields will be repeated and thus cause unnecesary load on both the server and the network.</p>

<p>Avoid the use of correlated subqueries. Use joins (including joins to derived tables where possible) (I know this is true for Microsoft SQL Server, but test the advice when using a differnt backend).</p>

<p>Index, index, index. And get those stats updated if applicable to your database.</p>

<p>Make the query <a href="http://en.wikipedia.org/wiki/Sargable" rel="noreferrer">sargable</a>. Meaning avoid things which make it impossible to use the indexes such as using a wildcard in the first character of a like clause or a function in the join or as the left part of a where statement.</p>

<p>Use correct data types. It is faster to do date math on a date field than to have to try to convert a string datatype to a date datatype, then do the calculation.</p>

<p>Never put a loop of any kind into a trigger!</p>

<p>Most databases have a way to check how the query execution will be done. In Microsoft SQL Server this is called an execution plan. Check those first to see where problem areas lie.</p>

<p>Consider how often the query runs as well as how long it takes to run when determining what needs to be optimized. Sometimes you can gain more perfomance from a slight tweak to a query that runs millions of times a day than you can from wiping time off a long_running query that only runs once a month.</p>

<p>Use some sort of profiler tool to find out what is really being sent to and from the database. I can remember one time in the past where we couldn't figure out why the page was so slow to load when the stored procedure was fast and found out through profiling that the webpage was asking for the query many many times instead of once. </p>

<p>The profiler will also help you to find who are blocking who. Some queries that execute quickly while running alone may become really slow due to locks from other queries.</p>
    </div></div></div></div><div id="solution8" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 8</h4><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>The single most important limiting factor today is the <strong>limited memory bandwitdh</strong>. Multicores are just making this worse, as the bandwidth is shared betwen cores. Also, the limited chip area devoted to implementing caches is also divided among the cores and threads, worsening this problem even more. Finally, the inter-chip signalling needed to keep the different caches coherent also increase with an increased number of cores. This also adds a penalty.</p>

<p>These are the effects that you need to manage. Sometimes through micro managing your code, but sometimes through careful consideration and refactoring.</p>

<p>A lot of comments already mention cache friendly code. There are at least two distinct flavors of this:</p>

<ul>
<li>Avoid memory fetch latencies.</li>
<li>Lower memory bus pressure (bandwidth).</li>
</ul>

<p>The first problem specifically has to do with making your data access patterns more regular, allowing the hardware prefetcher to work efficiently. Avoid dynamic memory allocation which spreads your data objects around in memory. Use linear containers instead of linked lists, hashes and trees.</p>

<p>The second problem has to do with improving data reuse. Alter your algorithms to work on subsets of your data that do fit in available cache, and reuse that data as much as possible while it is still in the cache.</p>

<p>Packing data tighter and making sure you use all data in cache lines in the hot loops, will help avoid these other effects, and allow fitting more <em>useful</em> data in the cache.</p>
    </div></div></div></div><div id="solution9" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 9</h4><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<ul>
<li>What hardware are you running on? Can you use platform-specific optimizations (like vectorization)?</li>
<li>Can you get a better compiler? E.g. switch from GCC to Intel?</li>
<li>Can you make your algorithm run in parallel?</li>
<li>Can you reduce cache misses by reorganizing data?</li>
<li>Can you disable asserts?</li>
<li>Micro-optimize for your compiler and platform. In the style of, "at an if/else, put the most common statement first"</li>
</ul>
    </div></div></div></div><div id="solution10" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 10</h4><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Although I like Mike Dunlavey's answer, in fact it is a great answer indeed with supporting example, I think it could be expressed very simply thus:</p>

<p><strong>Find out what takes the largest amounts of time first, and understand why.</strong></p>

<p>It is the identification process of the time hogs that helps you understand where you must refine your algorithm. This is the only all-encompassing language agnostic answer I can find to a problem that's already supposed to be fully optimised. Also presuming you want to be architecture independent in your quest for speed.</p>

<p>So while the algorithm may be optimised, the implementation of it may not be. The identification allows you to know which part is which: algorithm or implementation. So whichever hogs the time the most is your prime candidate for review. But since you say you want to squeeze the last few % out, you might want to also examine the lesser parts, the parts that you have not examined that closely at first.</p>

<p>Lastly a bit of trial and error with performance figures on different ways to implement the same solution, or potentially different algorithms, can bring insights that help identify time wasters and time savers.</p>

<p>HPH,
asoudmove.</p>
    </div></div></div></div><div id="solution11" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 11</h4><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>You should probably consider the "Google perspective", i.e. determine how your application can become largely parallelized and concurrent, which will inevitably also mean at some point to look into distributing your application across different machines and networks, so that it can ideally scale almost linearly with the hardware that you throw at it.</p>

<p>On the other hand, the Google folks are also known for throwing lots of manpower and resources at solving some of the issues in projects, tools and infrastructure they are using, such as for example <a href="http://gcc.gnu.org/wiki/LinkTimeOptimization" rel="noreferrer">whole program optimization for gcc</a> by having a dedicated team of engineers hacking gcc internals in order to prepare it for Google-typical use case scenarios.</p>

<p>Similarly, profiling an application no longer means to simply profile the program code, but also all its surrounding systems and infrastructure (think networks, switches, server, RAID arrays) in order to identify redundancies and optimization potential from a system's point of view.</p>
    </div></div></div></div><div id="solution12" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 12</h4><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<ul>
<li>Inline routines (eliminate call/return and parameter pushing)</li>
<li>Try eliminating tests/switches with table look ups (if they're faster)</li>
<li>Unroll loops (Duff's device) to the point where they just fit in the CPU cache</li>
<li>Localize memory access so as not to blow your cache</li>
<li>Localize related calculations if the optimizer isn't already doing that</li>
<li>Eliminate loop invariants if the optimizer isn't already doing that</li>
</ul>
    </div></div></div></div><div id="solution13" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 13</h4><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<ul>
<li>When you get to the point that you're using efficient algorithms its a question of what you need more <strong>speed or memory</strong>. Use caching to "pay" in memory for more speed or use calculations to reduce the memory footprint.</li>
<li>If possible (and more cost effective) <strong>throw hardware at the problem</strong> - faster CPU, more memory or HD could solve the problem faster then trying to code it.</li>
<li><strong>Use parallelization</strong> if possible - run part of the code on multiple threads.</li>
<li><strong>Use the right tool for the job</strong>. some programing languages create more efficient code, using managed code (i.e. Java/.NET) speed up development but native programing languages creates faster running code. </li>
<li><strong>Micro optimize</strong>. Only were applicable you can use optimized assembly to speed small pieces of code, using SSE/vector optimizations in the right places can greatly increase performance.</li>
</ul>
    </div></div></div></div><div id="solution14" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 14</h4><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p><strong>Divide and conquer</strong></p>

<p>If the dataset being processed is too large, loop over chunks of it. If you've done your code right, implementation should be easy. If you have a monolithic program, now you know better.</p>
    </div></div></div></div><div id="solution15" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 15</h4><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>First of all, as mentioned in several prior answers, learn what bites your performance - is it memory or processor or network or database or something else. Depending on that...</p>

<ul>
<li><p>...if it's memory - find one of the books written long time ago by Knuth, one of "The Art of Computer Programming" series. Most likely it's one about sorting and search - if my memory is wrong then you'll have to find out in which he talks about how to deal with slow tape data storage. Mentally transform his <em>memory/tape</em> pair into your pair of cache/main memory (or in pair of L1/L2 cache) respectively. Study all the tricks he describes - if you don's find something that solves your problem, then hire professional computer scientist to conduct a professional research. If your memory issue is by chance with FFT (cache misses at bit-reversed indexes when doing radix-2 butterflies) then don't hire a scientist - instead, manually optimize passes one-by-one until you're either win or get to dead end. You mentioned <em>squeeze out up to the last few percent</em> right? If it's <em>few</em> indeed you'll most likely win.</p></li>
<li><p>...if it's processor - switch to assembly language. Study processor specification - <em>what takes ticks</em>, VLIW, SIMD. Function calls are most likely replaceable tick-eaters. Learn loop transformations - pipeline, unroll. Multiplies and divisions might be replaceable / interpolated with bit shifts (multiplies by small integers might be replaceable with additions). Try tricks with shorter data - if you're lucky one instruction with 64 bits might turn out replaceable with two on 32 or even 4 on 16 or 8 on 8 bits go figure. Try also <em>longer</em> data - eg your float calculations might turn out slower than double ones at particular processor. If you have trigonometric stuff, fight it with pre-calculated tables; also keep in mind that sine of small value might be replaced with that value if loss of precision is within allowed limits.</p></li>
<li><p>...if it's network - think of compressing data you pass over it. Replace XML transfer with binary. Study protocols. Try UDP instead of TCP if you can somehow handle data loss.</p></li>
<li><p>...if it's database, well, go to any database forum and ask for advice. In-memory data-grid, optimizing query plan etc etc etc.</p></li>
</ul>

<p>HTH :)</p>
    </div></div></div></div><div id="solution16" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 16</h4><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p><strong>Caching!</strong> A cheap way (in programmer effort) to make almost anything faster is to add a caching abstraction layer to any data movement area of your program. Be it I/O or just passing/creation of objects or structures. Often it's easy to add caches to factory classes and reader/writers.</p>

<p>Sometimes the cache will not gain you much, but it's an easy method to just add caching all over and then disable it where it doesn't help. I've often found this to gain huge performance without having to micro-analyse the code.</p>
    </div></div></div></div><div id="solution17" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 17</h4><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>I think this has already been said in a different way.  But when you're dealing with a processor intensive algorithm, you should simplify everything inside the most inner loop at the expense of everything else.  </p>

<p>That may seem obvious to some, but it's something I try to focus on regardless of the language I'm working with.  If you're dealing with nested loops, for example, and you find an opportunity to take some code down a level, you can in some cases drastically speed up your code.  As another example, there are the little things to think about like working with integers instead of floating point variables whenever you can, and using multiplication instead of division whenever you can.  Again, these are things that should be considered for your most inner loop.  </p>

<p>Sometimes you may find benefit of performing your math operations on an integer inside the inner loop, and then scaling it down to a floating point variable you can work with afterwards.  That's an example of sacrificing speed in one section to improve the speed in another, but in some cases the pay off can be well worth it.</p>
    </div></div></div></div><div id="solution18" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 18</h4><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>I've spent some time working on optimising client/server business systems operating over low-bandwidth and long-latency networks (e.g. satellite, remote, offshore), and been able to achieve some dramatic performance improvements with a fairly repeatable process.</p>

<ul>
<li><p><strong>Measure</strong>: Start by understanding the network's underlying capacity and topology. Talking to the relevant networking people in the business, and make use of basic tools such as ping and traceroute to establish (at a minimum) the network latency from each client location, during typical operational periods. Next, take accurate time measurements of specific end user functions that display the problematic symptoms. Record all of these measurements, along with their locations, dates and times. Consider building end-user "network performance testing" functionality into your client application, allowing your power users to participate in the process of improvement; empowering them like this can have a <em>huge</em> psychological impact when you're dealing with users frustrated by a poorly performing system.</p></li>
<li><p><strong>Analyze</strong>: Using any and all logging methods available to establish exactly what data is being transmitted and received during the execution of the affected operations. Ideally, your application can capture data transmitted and received by both the client and the server. If these include timestamps as well, even better. If sufficient logging isn't available (e.g. closed system, or inability to deploy modifications into a production environment), use a network sniffer and make sure you really understand what's going on at the network level.</p></li>
<li><p><strong>Cache</strong>: Look for cases where static or infrequently changed data is being transmitted repetitively and consider an appropriate caching strategy. Typical examples include "pick list" values or other "reference entities", which can be surprisingly large in some business applications. In many cases, users can accept that they must restart or refresh the application to update infrequently updated data, especially if it can shave significant time from the display of commonly used user interface elements. Make sure you understand the real behaviour of the caching elements already deployed - many common caching methods (e.g. HTTP ETag) still require a network round-trip to ensure consistency, and where network latency is expensive, you may be able to avoid it altogether with a different caching approach.</p></li>
<li><p><strong>Parallelise</strong>: Look for sequential transactions that don't logically need to be issued strictly sequentially, and rework the system to issue them in parallel. I dealt with one case where an end-to-end request had an inherent network delay of ~2s, which was not a problem for a single transaction, but when 6 sequential 2s round trips were required before the user regained control of the client application, it became a huge source of frustration. Discovering that these transactions were in fact independent allowed them to be executed in parallel, reducing the end-user delay to very close to the cost of a single round trip.</p></li>
<li><p><strong>Combine</strong>: Where sequential requests <em>must</em> be executed sequentially, look for opportunities to combine them into a single more comprehensive request. Typical examples include creation of new entities, followed by requests to relate those entities to other existing entities.</p></li>
<li><p><strong>Compress</strong>: Look for opportunities to leverage compression of the payload, either by replacing a textual form with a binary one, or using actual compression technology. Many modern (i.e. within a decade) technology stacks support this almost transparently, so make sure it's configured. I have often been surprised by the significant impact of compression where it seemed clear that the problem was fundamentally latency rather than bandwidth,  discovering after the fact that it allowed the transaction to fit within a single packet or otherwise avoid packet loss and therefore have an outsize impact on performance.</p></li>
<li><p><strong>Repeat</strong>: Go back to the beginning and re-measure your operations (at the same locations and times) with the improvements in place, record and report your results. As with all optimisation, some problems may have been solved exposing others that now dominate.</p></li>
</ul>

<p>In the steps above, I focus on the application related optimisation process, but of course you must ensure the underlying network itself is configured in the most efficient manner to support your application too. Engage the networking specialists in the business and determine if they're able to apply capacity improvements, QoS, network compression, or other techniques to address the problem. Usually, they will not understand your application's needs, so it's important that you're equipped (after the Analyse step) to discuss it with them, and also to make the business case for any costs you're going to be asking them to incur. I've encountered cases where erroneous network configuration caused the applications data to be transmitted over a slow satellite link rather than an overland link, simply because it was using a TCP port that was not "well known" by the networking specialists; obviously rectifying a problem like this can have a dramatic impact on performance, with no software code or configuration changes necessary at all.</p>
    </div></div></div></div><div id="solution19" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 19</h4><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Very difficult to give a generic answer to this question. It really depends on your problem domain and technical implementation. A general technique that is fairly language neutral: Identify code hotspots that cannot be eliminated, and hand-optimize assembler code. </p>
    </div></div></div></div><div id="solution20" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 20</h4><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Last few % is a very CPU and application dependent thing....</p>

<ul>
<li>cache architectures differ, some chips have on-chip RAM
you can map directly, ARM's (sometimes) have a vector
unit, SH4's a useful matrix opcode. Is there a <a href="http://en.wikipedia.org/wiki/Graphics_processing_unit" rel="noreferrer">GPU</a> -
maybe a shader is the way to go. <a href="http://en.wikipedia.org/wiki/Texas_Instruments_TMS320" rel="noreferrer">TMS320</a>'s are very
sensitive to branches within loops (so separate loops and
move conditions outside if possible).</li>
</ul>

<p>The list goes on.... But these sorts of things really are
the last resort...</p>

<p>Build for x86, and run <a href="http://en.wikipedia.org/wiki/Valgrind" rel="noreferrer">Valgrind</a>/Cachegrind against the code
for proper performance profiling. Or Texas Instruments'
<a href="http://en.wikipedia.org/wiki/Code_Composer_Studio" rel="noreferrer">CCStudio</a> has a sweet profiler. Then you'll really know where
to focus...</p>
    </div></div></div></div><div id="solution21" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 21</h4><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Not nearly as in depth or complex as previous answers, but here goes:
(these are more beginner/intermediate level)</p>

<ul>
<li>obvious: dry</li>
<li>run loops backwards so you're always comparing to 0 rather than a variable</li>
<li>use bitwise operators whenever you can</li>
<li>break repetitive code into modules/functions</li>
<li>cache objects</li>
<li>local variables have slight performance advantage</li>
<li>limit string manipulation as much as possible </li>
</ul>
    </div></div></div></div><div id="solution22" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 22</h4><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p><code>Did you know that a CAT6 cable is capable of 10x better shielding off external inteferences than a default Cat5e UTP cable?</code></p>
<p>For any non-offline projects, while having best software and best hardware, if your throughoutput is weak, then that thin line is going to squeeze data and give you delays, albeit in milliseconds...</p>
<p>Also the maximum throughput is higher on CAT6 cables because there is a higher chance that you will actually receive a cable whose strands exist of cupper cores, instead of CCA, Cupper Cladded Aluminium, which is often fount in all your standard CAT5e cables.</p>
<p>I if you are facing lost packets, packet drops, then an increase in throughput reliability for 24/7 operation can make the difference that you may be looking for.</p>
<p>For those who seek the ultimate in home/office connection reliability, (<em>and are willing to say NO to this years fastfood restaurants, at the end of the year you can there you can</em>) gift yourself <code>the pinnacle of LAN connectivity in the form of  CAT7 cable</code> from a reputable brand.</p>
    </div></div></div></div><div id="solution23" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 23</h4><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Impossible to say. It depends on what the code looks like. If we can assume that the code already exists, then we can simply look at it and figure out from that, how to optimize it.</p>

<p>Better cache locality, loop unrolling, Try to eliminate long dependency chains, to get better instruction-level parallelism. Prefer conditional moves over branches when possible. Exploit SIMD instructions when possible.</p>

<p>Understand what your code is doing, and understand the hardware it's running on. Then it becomes fairly simple to determine what you need to do to improve performance of your code. That's really the only truly general piece of advice I can think of.</p>

<p>Well, that, and "Show the code on SO and ask for optimization advice for that specific piece of code".</p>
    </div></div></div></div><div id="solution24" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 24</h4><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>If better hardware is an option then definitely go for that. Otherwise</p>

<ul>
<li>Check you are using the best compiler and linker options.</li>
<li>If hotspot routine in different library to frequent caller, consider moving or cloning it to the callers module. Eliminates some of the call overhead and may improve cache hits (cf how AIX links strcpy() statically into separately linked shared objects). This could of course decrease cache hits also, which is why one measure.</li>
<li>See if there is any possibility of using a specialized version of the hotspot routine. Downside is more than one version to maintain.</li>
<li>Look at the assembler. If you think it could be better, consider why the compiler did not figure this out, and how you could help the compiler.</li>
<li>Consider: are you really using the best algorithm? Is it the best algorithm for your input size?</li>
</ul>
    </div></div></div></div><div id="solution25" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 25</h4><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>The google way is one option "Cache it.. Whenever possible don't touch the disk"</p>
    </div></div></div></div><div id="solution26" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 26</h4><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Here are some quick and dirty optimization techniques I use.  I consider this to be a 'first pass' optimization.</p>

<p><strong>Learn where the time is spent</strong> Find out exactly what is taking the time.  Is it file  IO?  Is it CPU time?  Is it the network?  Is it the Database?  It's useless to optimize for IO if that's not the bottleneck.</p>

<p><strong>Know Your Environment</strong>  Knowing where to optimize typically depends on the development environment.  In VB6, for example, passing by reference is slower than passing by value, but in C and C++, by reference is vastly faster.  In C, it is reasonable to try something and do something different if a return code indicates a failure, while in Dot Net, catching exceptions are much slower than checking for a valid condition before attempting.  </p>

<p><strong>Indexes</strong> Build indexes on frequently queried database fields.  You can almost always trade space for speed.</p>

<p><strong>Avoid lookups</strong>  Inside of the loop to be optimized, I avoid having to do any lookups.  Find the offset and/or index outside of the loop and reuse the data inside.</p>

<p><strong>Minimize IO</strong> try to design in a manner that reduces the number of times you have to read or write especially over a networked connection</p>

<p><strong>Reduce Abstractions</strong> The more layers of abstraction the code has to work through, the slower it is.  Inside the critical loop, reduce abstractions (e.g. reveal lower-level methods that avoid extra code)</p>

<p><strong>Spawn Threads</strong> for projects with a user interface, spawning a new thread to preform slower tasks makes the application <em>feel</em> more responsive, although isn't.</p>

<p><strong>Pre-process</strong> You can generally trade space for speed.  If there are calculations or other intense operations, see if you can precompute some of the information before you're in the critical loop.</p>
    </div></div></div></div><div id="solution27" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 27</h4><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>If you have a lot of highly parallel floating point math-especially single-precision-try offloading it to a graphics processor (if one is present) using OpenCL or (for NVidia chips) CUDA. GPUs have immense floating point computing power in their shaders, which is much greater than that of a CPU.</p>
    </div></div></div></div><div id="solution28" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 28</h4><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Adding this answer since I didnt see it included in all the others.</p>

<h3>Minimize implicit conversion between types and sign:</h3>

<p>This applies to C/C++ at least, Even if you already <em>think</em> you're free of conversions - sometimes its good to test adding compiler warnings around functions that require performance, especially watch-out for conversions within loops.</p>

<p>GCC spesific: You can test this by adding some verbose pragmas around your code,</p>

<pre><code>#ifdef __GNUC__
#  pragma GCC diagnostic push
#  pragma GCC diagnostic error "-Wsign-conversion"
#  pragma GCC diagnostic error "-Wdouble-promotion"
#  pragma GCC diagnostic error "-Wsign-compare"
#  pragma GCC diagnostic error "-Wconversion"
#endif

/* your code */

#ifdef __GNUC__
#  pragma GCC diagnostic pop
#endif
</code></pre>

<p>I've seen cases where you can get a few percent speedup by reducing conversions raised by warnings like this.</p>

<p>In some cases I have a header with strict warnings that I keep included to prevent accidental conversions, however this is a trade-off since you may end up adding a lot of casts to quiet intentional conversions which may just make the code more cluttered for minimal gains.</p>
    </div></div></div></div><div id="solution29" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 29</h4><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Sometimes changing the layout of your data can help. In C, you might switch from an array or structures to a structure of arrays, or vice versa.</p>
    </div></div></div></div><div id="solution30" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 30</h4><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p><strong>Tweak the OS and framework.</strong></p>

<p>It may sound an overkill but think about it like this: Operating Systems and Frameworks are designed to do many things. Your application only does very specific things. If you could get the OS do to exactly what your application needs and have your application understand how the the framework (php,.net,java) works, you could get much better out of your hardware.</p>

<p>Facebook, for example, changed some <a href="http://www.facebook.com/video/video.php?v=631826881803" rel="nofollow noreferrer">kernel level thingys</a> in Linux, changed how memcached works (for example they wrote a memcached proxy, and <a href="http://www.facebook.com/note.php?note_id=39391378919" rel="nofollow noreferrer">used udp instead of tcp</a>).</p>

<p>Another example for this is Window2008. Win2K8 has a version were you can install just the basic OS needed to run X applicaions (e.g. Web-Apps, Server Apps). This reduces much of the overhead that the OS have on running processes and gives you better performance.</p>

<p>Of course, you should always throw in more hardware as the first step...</p>
    </div></div></div></div></div></div><div class="widget"><a href="/questions/web-scraping-javascript-page-with-python-1657388240875">Web-scraping JavaScript page with Python</a><a href="/questions/determine-whether-two-date-ranges-overlap-1657387924335">Determine Whether Two Date Ranges Overlap</a><a href="/questions/what-is-the-difference-between-a-definition-and-a-declaration-1657387851618">What is the difference between a definition and a declaration?</a><a href="/questions/how-do-i-make-git-forget-about-a-file-that-was-tracked-but-is-now-in-.gitignore-1657387328843">How do I make Git forget about a file that was tracked, but is now in .gitignore?</a><a href="/questions/how-do-i-split-a-list-into-equally-sized-chunks-1657384580399">How do I split a list into equally-sized chunks?</a><a href="/questions/sort-(order)-data-frame-rows-by-multiple-columns-1657388355671">Sort (order) data frame rows by multiple columns</a><a href="/questions/how-do-you-use-a-variable-in-a-regular-expression-1657387939007">How do you use a variable in a regular expression?</a><a href="/questions/input()-error-nameerror:-name-&#x27;...&#x27;-is-not-defined-1657388497243">input() error - NameError: name &#x27;...&#x27; is not defined</a><a href="/questions/does-python-have-a-ternary-conditional-operator-1657387555448">Does Python have a ternary conditional operator?</a><a href="/questions/the-definitive-c++-book-guide-and-list-1657384247395">The Definitive C++ Book Guide and List</a><a href="/questions/how-do-i-merge-two-dictionaries-in-a-single-expression-1657387593160">How do I merge two dictionaries in a single expression?</a><a href="/questions/how-do-i-sort-a-dictionary-by-value-1657385485049">How do I sort a dictionary by value?</a><a href="/questions/how-to-create-a-generic-array-in-java-1657387532298">How to create a generic array in Java?</a><a href="/questions/how-do-i-select-rows-from-a-dataframe-based-on-column-values-1657384901065">How do I select rows from a DataFrame based on column values?</a><a href="/questions/what-does-if-__name__-%22__main__%22:-do-1657384825815">What does if __name__ == &quot;__main__&quot;: do?</a><a href="/questions/event.preventdefault()-vs.-return-false-1657387458377">event.preventDefault() vs. return false</a><a href="/questions/is-there-a-unique-android-device-id-1657388089268">Is there a unique Android device ID?</a><a href="/questions/variables-are-not-behaving-as-expected-1657384865672">Variables are not behaving as expected</a><a href="/questions/the-viewdata-item-that-has-the-key-&#x27;xxx&#x27;-is-of-type-&#x27;system.int32&#x27;-but-must-be-of-type-&#x27;ienumerablelessselectlistitemgreater&#x27;-1657388454191">The ViewData item that has the key &#x27;XXX&#x27; is of type &#x27;System.Int32&#x27; but must be of type &#x27;IEnumerable&lt;SelectListItem&gt;&#x27;</a><a href="/questions/what-is-the-difference-between-public-protected-package-private-and-private-in-java-1657387376262">What is the difference between public, protected, package-private and private in Java?</a></div></div><span class="cursor-pointer text-lg p-2" style="position:fixed;bottom:20px;left:20px;background:#000;z-index:2000;color:white">Go go top</span></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"data":{"answer":["\n\u0026lt;p\u0026gt;OK, you\u0026apos;re defining the problem to where it would seem there is not much room for improvement. That is fairly rare, in my experience. I tried to explain this in a Dr. Dobbs article in November 1993, by starting from a conventionally well-designed non-trivial program with no obvious waste and taking it through a series of optimizations until its wall-clock time was reduced from 48 seconds to 1.1 seconds, and the source code size was reduced by a factor of 4. My diagnostic tool \u0026lt;a href=\u0026quot;https://stackoverflow.com/questions/375913/what-can-i-use-to-profile-c-code-in-linux/378024#378024\u0026quot;\u0026gt;was this\u0026lt;/a\u0026gt;. The sequence of changes was this:\u0026lt;/p\u0026gt;\n\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;The first problem found was use of list clusters (now called \u0026quot;iterators\u0026quot; and \u0026quot;container classes\u0026quot;) accounting for over half the time. Those were replaced with fairly simple code, bringing the time down to 20 seconds.\u0026lt;/p\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;Now the largest time-taker is more list-building. As a percentage, it was not so big before, but now it is because the bigger problem was removed. I find a way to speed it up, and the time drops to 17 seconds.\u0026lt;/p\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;Now it is harder to find obvious culprits, but there are a few smaller ones that I can do something about, and the time drops to 13 sec.\u0026lt;/p\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\n\u0026lt;p\u0026gt;Now I seem to have hit a wall. The samples are telling me exactly what it is doing, but I can\u0026apos;t seem to find anything that I can improve. Then I reflect on the basic design of the program, on its transaction-driven structure, and ask if all the list-searching that it is doing is actually mandated by the requirements of the problem.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Then I hit upon a re-design, where the program code is actually generated (via preprocessor macros) from a smaller set of source, and in which the program is not constantly figuring out things that the programmer knows are fairly predictable. In other words, don\u0026apos;t \u0026quot;interpret\u0026quot; the sequence of things to do, \u0026quot;compile\u0026quot; it.\u0026lt;/p\u0026gt;\n\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;That redesign is done, shrinking the source code by a factor of 4, and the time is reduced to 10 seconds.\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\n\u0026lt;p\u0026gt;Now, because it\u0026apos;s getting so quick, it\u0026apos;s hard to sample, so I give it 10 times as much work to do, but the following times are based on the original workload.\u0026lt;/p\u0026gt;\n\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;More diagnosis reveals that it is spending time in queue-management. In-lining these reduces the time to 7 seconds.\u0026lt;/p\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;Now a big time-taker is the diagnostic printing I had been doing. Flush that - 4 seconds.\u0026lt;/p\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;Now the biggest time-takers are calls to \u0026lt;em\u0026gt;malloc\u0026lt;/em\u0026gt; and \u0026lt;em\u0026gt;free\u0026lt;/em\u0026gt;. Recycle objects - 2.6 seconds.\u0026lt;/p\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;Continuing to sample, I still find operations that are not strictly necessary - 1.1 seconds.\u0026lt;/p\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\n\u0026lt;p\u0026gt;Total speedup factor: 43.6\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Now no two programs are alike, but in non-toy software I\u0026apos;ve always seen a progression like this. First you get the easy stuff, and then the more difficult, until you get to a point of diminishing returns. Then the insight you gain may well lead to a redesign, starting a new round of speedups, until you again hit diminishing returns. Now this is the point at which it might make sense to wonder whether \u0026lt;code\u0026gt;++i\u0026lt;/code\u0026gt; or \u0026lt;code\u0026gt;i++\u0026lt;/code\u0026gt; or \u0026lt;code\u0026gt;for(;;)\u0026lt;/code\u0026gt; or \u0026lt;code\u0026gt;while(1)\u0026lt;/code\u0026gt; are faster: the kinds of questions I see so often on Stack\u0026amp;nbsp;Overflow.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;P.S. It may be wondered why I didn\u0026apos;t use a profiler. The answer is that almost every one of these \u0026quot;problems\u0026quot; was a function call site, which stack samples pinpoint. Profilers, even today, are just barely coming around to the idea that statements and call instructions are more important to locate, and easier to fix, than whole functions.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;I actually built a profiler to do this, but for a real down-and-dirty intimacy with what the code is doing, there\u0026apos;s no substitute for getting your fingers right in it. It is not an issue that the number of samples is small, because none of the problems being found are so tiny that they are easily missed.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;ADDED: jerryjvl requested some examples. Here is the first problem. It consists of a small number of separate lines of code, together taking over half the time:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt; /* IF ALL TASKS DONE, SEND ITC_ACKOP, AND DELETE OP */\nif (ptop-\u0026amp;gt;current_task \u0026amp;gt;= ILST_LENGTH(ptop-\u0026amp;gt;tasklist){\n. . .\n/* FOR EACH OPERATION REQUEST */\nfor ( ptop = ILST_FIRST(oplist); ptop != NULL; ptop = ILST_NEXT(oplist, ptop)){\n. . .\n/* GET CURRENT TASK */\nptask = ILST_NTH(ptop-\u0026amp;gt;tasklist, ptop-\u0026amp;gt;current_task)\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;These were using the list cluster ILST (similar to a list class). They are implemented in the usual way, with \u0026quot;information hiding\u0026quot; meaning that the users of the class were not supposed to have to care how they were implemented. When these lines were written (out of roughly 800 lines of code) thought was not given to the idea that these could be a \u0026quot;bottleneck\u0026quot; (I hate that word). They are simply the recommended way to do things. It is easy to say \u0026lt;em\u0026gt;in hindsight\u0026lt;/em\u0026gt; that these should have been avoided, but in my experience \u0026lt;em\u0026gt;all\u0026lt;/em\u0026gt; performance problems are like that. In general, it is good to try to avoid creating performance problems. It is even better to find and fix the ones that are created, even though they \u0026quot;should have been avoided\u0026quot; (in hindsight). I hope that gives a bit of the flavor.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Here is the second problem, in two separate lines:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt; /* ADD TASK TO TASK LIST */\nILST_APPEND(ptop-\u0026amp;gt;tasklist, ptask)\n. . .\n/* ADD TRANSACTION TO TRANSACTION QUEUE */\nILST_APPEND(trnque, ptrn)\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;These are building lists by appending items to their ends. (The fix was to collect the items in arrays, and build the lists all at once.) The interesting thing is that these statements only cost (i.e. were on the call stack) 3/48 of the original time, so they were not in fact a big problem \u0026lt;em\u0026gt;at the beginning\u0026lt;/em\u0026gt;. However, after removing the first problem, they cost 3/20 of the time and so were now a \u0026quot;bigger fish\u0026quot;. In general, that\u0026apos;s how it goes.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;I might add that this project was distilled from a real project I helped on. In that project, the performance problems were far more dramatic (as were the speedups), such as calling a database-access routine within an inner loop to see if a task was finished.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;REFERENCE ADDED:\nThe source code, both original and redesigned, can be found in \u0026lt;a href=\u0026quot;http://www.drdobbs.com/parallel/performance-tuning-slugging-it-out/184409106\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;www.ddj.com\u0026lt;/a\u0026gt;, for 1993, in file 9311.zip, files slug.asc and slug.zip.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;EDIT 2011/11/26:\nThere is now a \u0026lt;a href=\u0026quot;https://sourceforge.net/projects/randompausedemo/\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;SourceForge project\u0026lt;/a\u0026gt; containing source code in Visual C++ and a blow-by-blow description of how it was tuned. It only goes through the first half of the scenario described above, and it doesn\u0026apos;t follow exactly the same sequence, but still gets a 2-3 order of magnitude speedup.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Suggestions:\u0026lt;/p\u0026gt;\n\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;strong\u0026gt;Pre-compute rather than re-calculate\u0026lt;/strong\u0026gt;: any loops or repeated calls that contain calculations that have a relatively limited range of inputs, consider making a lookup (array or dictionary) that contains the result of that calculation for all values in the valid range of inputs. Then use a simple lookup inside the algorithm instead.\u0026lt;br\u0026gt;\n\u0026lt;em\u0026gt;Down-sides\u0026lt;/em\u0026gt;: if few of the pre-computed values are actually used this may make matters worse, also the lookup may take significant memory.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;strong\u0026gt;Don\u0026apos;t use library methods\u0026lt;/strong\u0026gt;: most libraries need to be written to operate correctly under a broad range of scenarios, and perform null checks on parameters, etc. By re-implementing a method you may be able to strip out a lot of logic that does not apply in the exact circumstance you are using it.\u0026lt;br\u0026gt;\n\u0026lt;em\u0026gt;Down-sides\u0026lt;/em\u0026gt;: writing additional code means more surface area for bugs.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;strong\u0026gt;Do use library methods\u0026lt;/strong\u0026gt;: to contradict myself, language libraries get written by people that are a lot smarter than you or me; odds are they did it better and faster. Do not implement it yourself unless you can actually make it faster (i.e.: always measure!)\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;strong\u0026gt;Cheat\u0026lt;/strong\u0026gt;: in some cases although an exact calculation may exist for your problem, you may not need \u0026apos;exact\u0026apos;, sometimes an approximation may be \u0026apos;good enough\u0026apos; and a lot faster in the deal. Ask yourself, does it really matter if the answer is out by 1%? 5%? even 10%?\u0026lt;br\u0026gt;\n\u0026lt;em\u0026gt;Down-sides\u0026lt;/em\u0026gt;: Well... the answer won\u0026apos;t be exact.\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n    ","\n\u0026lt;p\u0026gt;When you can\u0026apos;t improve the performance any more - see if you can improve the \u0026lt;strong\u0026gt;perceived\u0026lt;/strong\u0026gt; performance instead.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;You may not be able to make your fooCalc algorithm faster, but often there are ways to make your application seem more responsive to the user. \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;A few examples:\u0026lt;/p\u0026gt;\n\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;anticipating what the user is going\nto request and start working on that\nbefore then\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;displaying results as\nthey come in, instead of all at once\nat the end\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;em\u0026gt;Accurate\u0026lt;/em\u0026gt; progress meter\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\n\u0026lt;p\u0026gt;These won\u0026apos;t make your program faster, but it might make your users happier with the speed you have.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;I spend most of my life in just this place. The broad strokes are to run your profiler and get it to record:\u0026lt;/p\u0026gt;\n\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;strong\u0026gt;Cache misses\u0026lt;/strong\u0026gt;. Data cache is the #1 source of stalls in most programs. Improve cache hit rate by reorganizing offending data structures to have better locality; pack structures and numerical types down to eliminate wasted bytes (and therefore wasted cache fetches); prefetch data wherever possible to reduce stalls.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;strong\u0026gt;Load-hit-stores\u0026lt;/strong\u0026gt;. Compiler assumptions about pointer aliasing, and cases where data is moved between disconnected register sets via memory, can cause a certain pathological behavior that causes the entire CPU pipeline to clear on a load op. Find places where floats, vectors, and ints are being cast to one another and eliminate them. Use \u0026lt;code\u0026gt;__restrict\u0026lt;/code\u0026gt; liberally to promise the compiler about aliasing.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;strong\u0026gt;Microcoded operations\u0026lt;/strong\u0026gt;. Most processors have some operations that cannot be pipelined, but instead run a tiny subroutine stored in ROM. Examples on the PowerPC are integer multiply, divide, and shift-by-variable-amount. The problem is that the entire pipeline stops dead while this operation is executing. Try to eliminate use of these operations or at least break them down into their constituent pipelined ops so you can get the benefit of superscalar dispatch on whatever the rest of your program is doing.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;strong\u0026gt;Branch mispredicts\u0026lt;/strong\u0026gt;. These too empty the pipeline. Find cases where the CPU is spending a lot of time refilling the pipe after a branch, and use branch hinting if available to get it to predict correctly more often. Or better yet, replace branches with conditional-moves wherever possible, \u0026lt;em\u0026gt;especially\u0026lt;/em\u0026gt; after floating point operations because their pipe is usually deeper and reading the condition flags after fcmp can cause a stall.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;strong\u0026gt;Sequential floating-point ops\u0026lt;/strong\u0026gt;. Make these SIMD.\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\n\u0026lt;p\u0026gt;And one more thing I like to do:\u0026lt;/p\u0026gt;\n\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;strong\u0026gt;Set your compiler to output assembly listings\u0026lt;/strong\u0026gt; and look at what it emits for the hotspot functions in your code. All those clever optimizations that \u0026quot;a good compiler should be able to do for you automatically\u0026quot;? Chances are your actual compiler doesn\u0026apos;t do them. I\u0026apos;ve seen GCC emit truly WTF code.\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Throw more hardware at it!\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;More suggestions:\u0026lt;/p\u0026gt;\n\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Avoid I/O\u0026lt;/strong\u0026gt;: Any I/O (disk, network, ports, etc.) is\nalways going to be far slower than any code that is\nperforming calculations, so get rid of any I/O that you do\nnot strictly need.\u0026lt;/p\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Move I/O up-front\u0026lt;/strong\u0026gt;: Load up all the data you are going\nto need for a calculation up-front, so that you do not\nhave repeated I/O waits within the core of a critical\nalgorithm (and maybe as a result repeated disk seeks, when\nloading all the data in one hit may avoid seeking).\u0026lt;/p\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Delay I/O\u0026lt;/strong\u0026gt;: Do not write out your results until the\ncalculation is over, store them in a data structure and\nthen dump that out in one go at the end when the hard work\nis done.\u0026lt;/p\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Threaded I/O\u0026lt;/strong\u0026gt;: For those daring enough, combine \u0026apos;I/O\nup-front\u0026apos; or \u0026apos;Delay I/O\u0026apos; with the actual calculation by\nmoving the loading into a parallel thread, so that while\nyou are loading more data you can work on a calculation on\nthe data you already have, or while you calculate the next\nbatch of data you can simultaneously write out the results\nfrom the last batch.\u0026lt;/p\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Since many of the performance problems involve database issues, I\u0026apos;ll give you some specific things to look at when tuning queries and stored procedures.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Avoid cursors in most databases. Avoid looping as well. Most of the time, data access should be set-based, not record by record processing. This includes not reusing a single record stored procedure when you want to insert 1,000,000 records at once.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Never use select *, only return the fields you actually need. This is especially true if there are any joins as the join fields will be repeated and thus cause unnecesary load on both the server and the network.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Avoid the use of correlated subqueries. Use joins (including joins to derived tables where possible) (I know this is true for Microsoft SQL Server, but test the advice when using a differnt backend).\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Index, index, index. And get those stats updated if applicable to your database.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Make the query \u0026lt;a href=\u0026quot;http://en.wikipedia.org/wiki/Sargable\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;sargable\u0026lt;/a\u0026gt;. Meaning avoid things which make it impossible to use the indexes such as using a wildcard in the first character of a like clause or a function in the join or as the left part of a where statement.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Use correct data types. It is faster to do date math on a date field than to have to try to convert a string datatype to a date datatype, then do the calculation.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Never put a loop of any kind into a trigger!\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Most databases have a way to check how the query execution will be done. In Microsoft SQL Server this is called an execution plan. Check those first to see where problem areas lie.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Consider how often the query runs as well as how long it takes to run when determining what needs to be optimized. Sometimes you can gain more perfomance from a slight tweak to a query that runs millions of times a day than you can from wiping time off a long_running query that only runs once a month.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Use some sort of profiler tool to find out what is really being sent to and from the database. I can remember one time in the past where we couldn\u0026apos;t figure out why the page was so slow to load when the stored procedure was fast and found out through profiling that the webpage was asking for the query many many times instead of once. \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;The profiler will also help you to find who are blocking who. Some queries that execute quickly while running alone may become really slow due to locks from other queries.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;The single most important limiting factor today is the \u0026lt;strong\u0026gt;limited memory bandwitdh\u0026lt;/strong\u0026gt;. Multicores are just making this worse, as the bandwidth is shared betwen cores. Also, the limited chip area devoted to implementing caches is also divided among the cores and threads, worsening this problem even more. Finally, the inter-chip signalling needed to keep the different caches coherent also increase with an increased number of cores. This also adds a penalty.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;These are the effects that you need to manage. Sometimes through micro managing your code, but sometimes through careful consideration and refactoring.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;A lot of comments already mention cache friendly code. There are at least two distinct flavors of this:\u0026lt;/p\u0026gt;\n\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;Avoid memory fetch latencies.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Lower memory bus pressure (bandwidth).\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\n\u0026lt;p\u0026gt;The first problem specifically has to do with making your data access patterns more regular, allowing the hardware prefetcher to work efficiently. Avoid dynamic memory allocation which spreads your data objects around in memory. Use linear containers instead of linked lists, hashes and trees.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;The second problem has to do with improving data reuse. Alter your algorithms to work on subsets of your data that do fit in available cache, and reuse that data as much as possible while it is still in the cache.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Packing data tighter and making sure you use all data in cache lines in the hot loops, will help avoid these other effects, and allow fitting more \u0026lt;em\u0026gt;useful\u0026lt;/em\u0026gt; data in the cache.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;What hardware are you running on? Can you use platform-specific optimizations (like vectorization)?\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Can you get a better compiler? E.g. switch from GCC to Intel?\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Can you make your algorithm run in parallel?\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Can you reduce cache misses by reorganizing data?\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Can you disable asserts?\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Micro-optimize for your compiler and platform. In the style of, \u0026quot;at an if/else, put the most common statement first\u0026quot;\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Although I like Mike Dunlavey\u0026apos;s answer, in fact it is a great answer indeed with supporting example, I think it could be expressed very simply thus:\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Find out what takes the largest amounts of time first, and understand why.\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;It is the identification process of the time hogs that helps you understand where you must refine your algorithm. This is the only all-encompassing language agnostic answer I can find to a problem that\u0026apos;s already supposed to be fully optimised. Also presuming you want to be architecture independent in your quest for speed.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;So while the algorithm may be optimised, the implementation of it may not be. The identification allows you to know which part is which: algorithm or implementation. So whichever hogs the time the most is your prime candidate for review. But since you say you want to squeeze the last few % out, you might want to also examine the lesser parts, the parts that you have not examined that closely at first.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Lastly a bit of trial and error with performance figures on different ways to implement the same solution, or potentially different algorithms, can bring insights that help identify time wasters and time savers.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;HPH,\nasoudmove.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;You should probably consider the \u0026quot;Google perspective\u0026quot;, i.e. determine how your application can become largely parallelized and concurrent, which will inevitably also mean at some point to look into distributing your application across different machines and networks, so that it can ideally scale almost linearly with the hardware that you throw at it.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;On the other hand, the Google folks are also known for throwing lots of manpower and resources at solving some of the issues in projects, tools and infrastructure they are using, such as for example \u0026lt;a href=\u0026quot;http://gcc.gnu.org/wiki/LinkTimeOptimization\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;whole program optimization for gcc\u0026lt;/a\u0026gt; by having a dedicated team of engineers hacking gcc internals in order to prepare it for Google-typical use case scenarios.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Similarly, profiling an application no longer means to simply profile the program code, but also all its surrounding systems and infrastructure (think networks, switches, server, RAID arrays) in order to identify redundancies and optimization potential from a system\u0026apos;s point of view.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;Inline routines (eliminate call/return and parameter pushing)\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Try eliminating tests/switches with table look ups (if they\u0026apos;re faster)\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Unroll loops (Duff\u0026apos;s device) to the point where they just fit in the CPU cache\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Localize memory access so as not to blow your cache\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Localize related calculations if the optimizer isn\u0026apos;t already doing that\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Eliminate loop invariants if the optimizer isn\u0026apos;t already doing that\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n    ","\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;When you get to the point that you\u0026apos;re using efficient algorithms its a question of what you need more \u0026lt;strong\u0026gt;speed or memory\u0026lt;/strong\u0026gt;. Use caching to \u0026quot;pay\u0026quot; in memory for more speed or use calculations to reduce the memory footprint.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;If possible (and more cost effective) \u0026lt;strong\u0026gt;throw hardware at the problem\u0026lt;/strong\u0026gt; - faster CPU, more memory or HD could solve the problem faster then trying to code it.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;strong\u0026gt;Use parallelization\u0026lt;/strong\u0026gt; if possible - run part of the code on multiple threads.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;strong\u0026gt;Use the right tool for the job\u0026lt;/strong\u0026gt;. some programing languages create more efficient code, using managed code (i.e. Java/.NET) speed up development but native programing languages creates faster running code. \u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;strong\u0026gt;Micro optimize\u0026lt;/strong\u0026gt;. Only were applicable you can use optimized assembly to speed small pieces of code, using SSE/vector optimizations in the right places can greatly increase performance.\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n    ","\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Divide and conquer\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;If the dataset being processed is too large, loop over chunks of it. If you\u0026apos;ve done your code right, implementation should be easy. If you have a monolithic program, now you know better.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;First of all, as mentioned in several prior answers, learn what bites your performance - is it memory or processor or network or database or something else. Depending on that...\u0026lt;/p\u0026gt;\n\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;...if it\u0026apos;s memory - find one of the books written long time ago by Knuth, one of \u0026quot;The Art of Computer Programming\u0026quot; series. Most likely it\u0026apos;s one about sorting and search - if my memory is wrong then you\u0026apos;ll have to find out in which he talks about how to deal with slow tape data storage. Mentally transform his \u0026lt;em\u0026gt;memory/tape\u0026lt;/em\u0026gt; pair into your pair of cache/main memory (or in pair of L1/L2 cache) respectively. Study all the tricks he describes - if you don\u0026apos;s find something that solves your problem, then hire professional computer scientist to conduct a professional research. If your memory issue is by chance with FFT (cache misses at bit-reversed indexes when doing radix-2 butterflies) then don\u0026apos;t hire a scientist - instead, manually optimize passes one-by-one until you\u0026apos;re either win or get to dead end. You mentioned \u0026lt;em\u0026gt;squeeze out up to the last few percent\u0026lt;/em\u0026gt; right? If it\u0026apos;s \u0026lt;em\u0026gt;few\u0026lt;/em\u0026gt; indeed you\u0026apos;ll most likely win.\u0026lt;/p\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;...if it\u0026apos;s processor - switch to assembly language. Study processor specification - \u0026lt;em\u0026gt;what takes ticks\u0026lt;/em\u0026gt;, VLIW, SIMD. Function calls are most likely replaceable tick-eaters. Learn loop transformations - pipeline, unroll. Multiplies and divisions might be replaceable / interpolated with bit shifts (multiplies by small integers might be replaceable with additions). Try tricks with shorter data - if you\u0026apos;re lucky one instruction with 64 bits might turn out replaceable with two on 32 or even 4 on 16 or 8 on 8 bits go figure. Try also \u0026lt;em\u0026gt;longer\u0026lt;/em\u0026gt; data - eg your float calculations might turn out slower than double ones at particular processor. If you have trigonometric stuff, fight it with pre-calculated tables; also keep in mind that sine of small value might be replaced with that value if loss of precision is within allowed limits.\u0026lt;/p\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;...if it\u0026apos;s network - think of compressing data you pass over it. Replace XML transfer with binary. Study protocols. Try UDP instead of TCP if you can somehow handle data loss.\u0026lt;/p\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;...if it\u0026apos;s database, well, go to any database forum and ask for advice. In-memory data-grid, optimizing query plan etc etc etc.\u0026lt;/p\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\n\u0026lt;p\u0026gt;HTH :)\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Caching!\u0026lt;/strong\u0026gt; A cheap way (in programmer effort) to make almost anything faster is to add a caching abstraction layer to any data movement area of your program. Be it I/O or just passing/creation of objects or structures. Often it\u0026apos;s easy to add caches to factory classes and reader/writers.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Sometimes the cache will not gain you much, but it\u0026apos;s an easy method to just add caching all over and then disable it where it doesn\u0026apos;t help. I\u0026apos;ve often found this to gain huge performance without having to micro-analyse the code.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;I think this has already been said in a different way.  But when you\u0026apos;re dealing with a processor intensive algorithm, you should simplify everything inside the most inner loop at the expense of everything else.  \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;That may seem obvious to some, but it\u0026apos;s something I try to focus on regardless of the language I\u0026apos;m working with.  If you\u0026apos;re dealing with nested loops, for example, and you find an opportunity to take some code down a level, you can in some cases drastically speed up your code.  As another example, there are the little things to think about like working with integers instead of floating point variables whenever you can, and using multiplication instead of division whenever you can.  Again, these are things that should be considered for your most inner loop.  \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Sometimes you may find benefit of performing your math operations on an integer inside the inner loop, and then scaling it down to a floating point variable you can work with afterwards.  That\u0026apos;s an example of sacrificing speed in one section to improve the speed in another, but in some cases the pay off can be well worth it.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;I\u0026apos;ve spent some time working on optimising client/server business systems operating over low-bandwidth and long-latency networks (e.g. satellite, remote, offshore), and been able to achieve some dramatic performance improvements with a fairly repeatable process.\u0026lt;/p\u0026gt;\n\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Measure\u0026lt;/strong\u0026gt;: Start by understanding the network\u0026apos;s underlying capacity and topology. Talking to the relevant networking people in the business, and make use of basic tools such as ping and traceroute to establish (at a minimum) the network latency from each client location, during typical operational periods. Next, take accurate time measurements of specific end user functions that display the problematic symptoms. Record all of these measurements, along with their locations, dates and times. Consider building end-user \u0026quot;network performance testing\u0026quot; functionality into your client application, allowing your power users to participate in the process of improvement; empowering them like this can have a \u0026lt;em\u0026gt;huge\u0026lt;/em\u0026gt; psychological impact when you\u0026apos;re dealing with users frustrated by a poorly performing system.\u0026lt;/p\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Analyze\u0026lt;/strong\u0026gt;: Using any and all logging methods available to establish exactly what data is being transmitted and received during the execution of the affected operations. Ideally, your application can capture data transmitted and received by both the client and the server. If these include timestamps as well, even better. If sufficient logging isn\u0026apos;t available (e.g. closed system, or inability to deploy modifications into a production environment), use a network sniffer and make sure you really understand what\u0026apos;s going on at the network level.\u0026lt;/p\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Cache\u0026lt;/strong\u0026gt;: Look for cases where static or infrequently changed data is being transmitted repetitively and consider an appropriate caching strategy. Typical examples include \u0026quot;pick list\u0026quot; values or other \u0026quot;reference entities\u0026quot;, which can be surprisingly large in some business applications. In many cases, users can accept that they must restart or refresh the application to update infrequently updated data, especially if it can shave significant time from the display of commonly used user interface elements. Make sure you understand the real behaviour of the caching elements already deployed - many common caching methods (e.g. HTTP ETag) still require a network round-trip to ensure consistency, and where network latency is expensive, you may be able to avoid it altogether with a different caching approach.\u0026lt;/p\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Parallelise\u0026lt;/strong\u0026gt;: Look for sequential transactions that don\u0026apos;t logically need to be issued strictly sequentially, and rework the system to issue them in parallel. I dealt with one case where an end-to-end request had an inherent network delay of ~2s, which was not a problem for a single transaction, but when 6 sequential 2s round trips were required before the user regained control of the client application, it became a huge source of frustration. Discovering that these transactions were in fact independent allowed them to be executed in parallel, reducing the end-user delay to very close to the cost of a single round trip.\u0026lt;/p\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Combine\u0026lt;/strong\u0026gt;: Where sequential requests \u0026lt;em\u0026gt;must\u0026lt;/em\u0026gt; be executed sequentially, look for opportunities to combine them into a single more comprehensive request. Typical examples include creation of new entities, followed by requests to relate those entities to other existing entities.\u0026lt;/p\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Compress\u0026lt;/strong\u0026gt;: Look for opportunities to leverage compression of the payload, either by replacing a textual form with a binary one, or using actual compression technology. Many modern (i.e. within a decade) technology stacks support this almost transparently, so make sure it\u0026apos;s configured. I have often been surprised by the significant impact of compression where it seemed clear that the problem was fundamentally latency rather than bandwidth,  discovering after the fact that it allowed the transaction to fit within a single packet or otherwise avoid packet loss and therefore have an outsize impact on performance.\u0026lt;/p\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Repeat\u0026lt;/strong\u0026gt;: Go back to the beginning and re-measure your operations (at the same locations and times) with the improvements in place, record and report your results. As with all optimisation, some problems may have been solved exposing others that now dominate.\u0026lt;/p\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\n\u0026lt;p\u0026gt;In the steps above, I focus on the application related optimisation process, but of course you must ensure the underlying network itself is configured in the most efficient manner to support your application too. Engage the networking specialists in the business and determine if they\u0026apos;re able to apply capacity improvements, QoS, network compression, or other techniques to address the problem. Usually, they will not understand your application\u0026apos;s needs, so it\u0026apos;s important that you\u0026apos;re equipped (after the Analyse step) to discuss it with them, and also to make the business case for any costs you\u0026apos;re going to be asking them to incur. I\u0026apos;ve encountered cases where erroneous network configuration caused the applications data to be transmitted over a slow satellite link rather than an overland link, simply because it was using a TCP port that was not \u0026quot;well known\u0026quot; by the networking specialists; obviously rectifying a problem like this can have a dramatic impact on performance, with no software code or configuration changes necessary at all.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Very difficult to give a generic answer to this question. It really depends on your problem domain and technical implementation. A general technique that is fairly language neutral: Identify code hotspots that cannot be eliminated, and hand-optimize assembler code. \u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Last few % is a very CPU and application dependent thing....\u0026lt;/p\u0026gt;\n\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;cache architectures differ, some chips have on-chip RAM\nyou can map directly, ARM\u0026apos;s (sometimes) have a vector\nunit, SH4\u0026apos;s a useful matrix opcode. Is there a \u0026lt;a href=\u0026quot;http://en.wikipedia.org/wiki/Graphics_processing_unit\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;GPU\u0026lt;/a\u0026gt; -\nmaybe a shader is the way to go. \u0026lt;a href=\u0026quot;http://en.wikipedia.org/wiki/Texas_Instruments_TMS320\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;TMS320\u0026lt;/a\u0026gt;\u0026apos;s are very\nsensitive to branches within loops (so separate loops and\nmove conditions outside if possible).\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\n\u0026lt;p\u0026gt;The list goes on.... But these sorts of things really are\nthe last resort...\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Build for x86, and run \u0026lt;a href=\u0026quot;http://en.wikipedia.org/wiki/Valgrind\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;Valgrind\u0026lt;/a\u0026gt;/Cachegrind against the code\nfor proper performance profiling. Or Texas Instruments\u0026apos;\n\u0026lt;a href=\u0026quot;http://en.wikipedia.org/wiki/Code_Composer_Studio\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;CCStudio\u0026lt;/a\u0026gt; has a sweet profiler. Then you\u0026apos;ll really know where\nto focus...\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Not nearly as in depth or complex as previous answers, but here goes:\n(these are more beginner/intermediate level)\u0026lt;/p\u0026gt;\n\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;obvious: dry\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;run loops backwards so you\u0026apos;re always comparing to 0 rather than a variable\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;use bitwise operators whenever you can\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;break repetitive code into modules/functions\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;cache objects\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;local variables have slight performance advantage\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;limit string manipulation as much as possible \u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n    ","\n\u0026lt;p\u0026gt;\u0026lt;code\u0026gt;Did you know that a CAT6 cable is capable of 10x better shielding off external inteferences than a default Cat5e UTP cable?\u0026lt;/code\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;For any non-offline projects, while having best software and best hardware, if your throughoutput is weak, then that thin line is going to squeeze data and give you delays, albeit in milliseconds...\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Also the maximum throughput is higher on CAT6 cables because there is a higher chance that you will actually receive a cable whose strands exist of cupper cores, instead of CCA, Cupper Cladded Aluminium, which is often fount in all your standard CAT5e cables.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;I if you are facing lost packets, packet drops, then an increase in throughput reliability for 24/7 operation can make the difference that you may be looking for.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;For those who seek the ultimate in home/office connection reliability, (\u0026lt;em\u0026gt;and are willing to say NO to this years fastfood restaurants, at the end of the year you can there you can\u0026lt;/em\u0026gt;) gift yourself \u0026lt;code\u0026gt;the pinnacle of LAN connectivity in the form of  CAT7 cable\u0026lt;/code\u0026gt; from a reputable brand.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Impossible to say. It depends on what the code looks like. If we can assume that the code already exists, then we can simply look at it and figure out from that, how to optimize it.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Better cache locality, loop unrolling, Try to eliminate long dependency chains, to get better instruction-level parallelism. Prefer conditional moves over branches when possible. Exploit SIMD instructions when possible.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Understand what your code is doing, and understand the hardware it\u0026apos;s running on. Then it becomes fairly simple to determine what you need to do to improve performance of your code. That\u0026apos;s really the only truly general piece of advice I can think of.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Well, that, and \u0026quot;Show the code on SO and ask for optimization advice for that specific piece of code\u0026quot;.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;If better hardware is an option then definitely go for that. Otherwise\u0026lt;/p\u0026gt;\n\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;Check you are using the best compiler and linker options.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;If hotspot routine in different library to frequent caller, consider moving or cloning it to the callers module. Eliminates some of the call overhead and may improve cache hits (cf how AIX links strcpy() statically into separately linked shared objects). This could of course decrease cache hits also, which is why one measure.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;See if there is any possibility of using a specialized version of the hotspot routine. Downside is more than one version to maintain.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Look at the assembler. If you think it could be better, consider why the compiler did not figure this out, and how you could help the compiler.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Consider: are you really using the best algorithm? Is it the best algorithm for your input size?\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n    ","\n\u0026lt;p\u0026gt;The google way is one option \u0026quot;Cache it.. Whenever possible don\u0026apos;t touch the disk\u0026quot;\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Here are some quick and dirty optimization techniques I use.  I consider this to be a \u0026apos;first pass\u0026apos; optimization.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Learn where the time is spent\u0026lt;/strong\u0026gt; Find out exactly what is taking the time.  Is it file  IO?  Is it CPU time?  Is it the network?  Is it the Database?  It\u0026apos;s useless to optimize for IO if that\u0026apos;s not the bottleneck.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Know Your Environment\u0026lt;/strong\u0026gt;  Knowing where to optimize typically depends on the development environment.  In VB6, for example, passing by reference is slower than passing by value, but in C and C++, by reference is vastly faster.  In C, it is reasonable to try something and do something different if a return code indicates a failure, while in Dot Net, catching exceptions are much slower than checking for a valid condition before attempting.  \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Indexes\u0026lt;/strong\u0026gt; Build indexes on frequently queried database fields.  You can almost always trade space for speed.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Avoid lookups\u0026lt;/strong\u0026gt;  Inside of the loop to be optimized, I avoid having to do any lookups.  Find the offset and/or index outside of the loop and reuse the data inside.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Minimize IO\u0026lt;/strong\u0026gt; try to design in a manner that reduces the number of times you have to read or write especially over a networked connection\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Reduce Abstractions\u0026lt;/strong\u0026gt; The more layers of abstraction the code has to work through, the slower it is.  Inside the critical loop, reduce abstractions (e.g. reveal lower-level methods that avoid extra code)\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Spawn Threads\u0026lt;/strong\u0026gt; for projects with a user interface, spawning a new thread to preform slower tasks makes the application \u0026lt;em\u0026gt;feel\u0026lt;/em\u0026gt; more responsive, although isn\u0026apos;t.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Pre-process\u0026lt;/strong\u0026gt; You can generally trade space for speed.  If there are calculations or other intense operations, see if you can precompute some of the information before you\u0026apos;re in the critical loop.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;If you have a lot of highly parallel floating point math-especially single-precision-try offloading it to a graphics processor (if one is present) using OpenCL or (for NVidia chips) CUDA. GPUs have immense floating point computing power in their shaders, which is much greater than that of a CPU.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Adding this answer since I didnt see it included in all the others.\u0026lt;/p\u0026gt;\n\n\u0026lt;h3\u0026gt;Minimize implicit conversion between types and sign:\u0026lt;/h3\u0026gt;\n\n\u0026lt;p\u0026gt;This applies to C/C++ at least, Even if you already \u0026lt;em\u0026gt;think\u0026lt;/em\u0026gt; you\u0026apos;re free of conversions - sometimes its good to test adding compiler warnings around functions that require performance, especially watch-out for conversions within loops.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;GCC spesific: You can test this by adding some verbose pragmas around your code,\u0026lt;/p\u0026gt;\n\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;#ifdef __GNUC__\n#  pragma GCC diagnostic push\n#  pragma GCC diagnostic error \u0026quot;-Wsign-conversion\u0026quot;\n#  pragma GCC diagnostic error \u0026quot;-Wdouble-promotion\u0026quot;\n#  pragma GCC diagnostic error \u0026quot;-Wsign-compare\u0026quot;\n#  pragma GCC diagnostic error \u0026quot;-Wconversion\u0026quot;\n#endif\n\n/* your code */\n\n#ifdef __GNUC__\n#  pragma GCC diagnostic pop\n#endif\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;I\u0026apos;ve seen cases where you can get a few percent speedup by reducing conversions raised by warnings like this.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;In some cases I have a header with strict warnings that I keep included to prevent accidental conversions, however this is a trade-off since you may end up adding a lot of casts to quiet intentional conversions which may just make the code more cluttered for minimal gains.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Sometimes changing the layout of your data can help. In C, you might switch from an array or structures to a structure of arrays, or vice versa.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Tweak the OS and framework.\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;It may sound an overkill but think about it like this: Operating Systems and Frameworks are designed to do many things. Your application only does very specific things. If you could get the OS do to exactly what your application needs and have your application understand how the the framework (php,.net,java) works, you could get much better out of your hardware.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Facebook, for example, changed some \u0026lt;a href=\u0026quot;http://www.facebook.com/video/video.php?v=631826881803\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;kernel level thingys\u0026lt;/a\u0026gt; in Linux, changed how memcached works (for example they wrote a memcached proxy, and \u0026lt;a href=\u0026quot;http://www.facebook.com/note.php?note_id=39391378919\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;used udp instead of tcp\u0026lt;/a\u0026gt;).\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Another example for this is Window2008. Win2K8 has a version were you can install just the basic OS needed to run X applicaions (e.g. Web-Apps, Server Apps). This reduces much of the overhead that the OS have on running processes and gives you better performance.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Of course, you should always throw in more hardware as the first step...\u0026lt;/p\u0026gt;\n    "],"id":560,"title":"Performance optimization strategies of last resort [closed]","content":"\n                    \u0026lt;div\u0026gt;\n            \u0026lt;aside class=\u0026quot;s-notice s-notice__info post-notice js-post-notice mb16\u0026quot; role=\u0026quot;status\u0026quot;\u0026gt;\n        \u0026lt;div class=\u0026quot;d-flex fd-column fw-nowrap\u0026quot;\u0026gt;\n            \u0026lt;div class=\u0026quot;d-flex fw-nowrap\u0026quot;\u0026gt;\n                \u0026lt;div class=\u0026quot;flex--item wmn0 fl1 lh-lg\u0026quot;\u0026gt;\n                    \u0026lt;div class=\u0026quot;flex--item fl1 lh-lg\u0026quot;\u0026gt;\n                        \u0026lt;b\u0026gt;Closed\u0026lt;/b\u0026gt;. This question needs to be more \u0026lt;a href=\u0026quot;/help/closed-questions\u0026quot;\u0026gt;focused\u0026lt;/a\u0026gt;. It is not currently accepting answers.\n                        \n                    \u0026lt;/div\u0026gt;\n                \u0026lt;/div\u0026gt;\n            \u0026lt;/div\u0026gt;\n        \u0026lt;/div\u0026gt;\n            \u0026lt;hr class=\u0026quot;my12 outline-none baw0 bb bc-powder-400\u0026quot;\u0026gt;\n        \u0026lt;div class=\u0026quot;fw-nowrap fc-black-600\u0026quot;\u0026gt;\n            \u0026lt;div class=\u0026quot;d-flex fd-column lh-md\u0026quot;\u0026gt;\n                \u0026lt;div class=\u0026quot;mb0 d-flex\u0026quot;\u0026gt;\n                        \u0026lt;div class=\u0026quot;flex--item mr8\u0026quot;\u0026gt;\n                            \u0026lt;svg aria-hidden=\u0026quot;true\u0026quot; class=\u0026quot;svg-icon iconLightbulb\u0026quot; width=\u0026quot;18\u0026quot; height=\u0026quot;18\u0026quot; viewBox=\u0026quot;0 0 18 18\u0026quot;\u0026gt;\u0026lt;path d=\u0026quot;M15 6.38A6.48 6.48 0 0 0 7.78.04h-.02A6.49 6.49 0 0 0 2.05 5.6a6.31 6.31 0 0 0 2.39 5.75c.49.39.76.93.76 1.5v.24c0 1.07.89 1.9 1.92 1.9h2.75c1.04 0 1.92-.83 1.92-1.9v-.2c0-.6.26-1.15.7-1.48A6.32 6.32 0 0 0 15 6.37ZM4.03 5.85A4.49 4.49 0 0 1 8 2.02a4.48 4.48 0 0 1 5 4.36 4.3 4.3 0 0 1-1.72 3.44c-.98.74-1.5 1.9-1.5 3.08v.1H7.2v-.14c0-1.23-.6-2.34-1.53-3.07a4.32 4.32 0 0 1-1.64-3.94ZM10 18a1 1 0 0 0 0-2H7a1 1 0 1 0 0 2h3Z\u0026quot;\u0026gt;\u0026lt;/path\u0026gt;\u0026lt;/svg\u0026gt;\n                        \u0026lt;/div\u0026gt;\n                    \u0026lt;p\u0026gt;\u0026lt;b\u0026gt;Want to improve this question?\u0026lt;/b\u0026gt; Update the question so it focuses on one problem only by \u0026lt;a href=\u0026quot;/posts/926266/edit\u0026quot;\u0026gt;editing this post\u0026lt;/a\u0026gt;.\u0026lt;/p\u0026gt;\n                \u0026lt;/div\u0026gt;\n                    \u0026lt;div class=\u0026quot;mb0 mt6 d-flex\u0026quot;\u0026gt;\n                        \u0026lt;p class=\u0026quot;ml24 pl2\u0026quot;\u0026gt;Closed \u0026lt;span title=\u0026quot;2013-11-15 22:32:33Z\u0026quot; class=\u0026quot;relativetime\u0026quot;\u0026gt;8 years ago\u0026lt;/span\u0026gt;.\u0026lt;/p\u0026gt;\n                    \u0026lt;/div\u0026gt;\n                \u0026lt;div class=\u0026quot;ml24 pl2\u0026quot;\u0026gt;\n\n                \u0026lt;/div\u0026gt;\n            \u0026lt;/div\u0026gt;\n        \u0026lt;/div\u0026gt;\n            \u0026lt;div class=\u0026quot;mt24 d-flex gsx gs8\u0026quot;\u0026gt;\n                    \u0026lt;a class=\u0026quot;s-btn s-btn__outlined flex--item js-post-notice-edit-post\u0026quot; href=\u0026quot;/posts/926266/edit\u0026quot;\u0026gt;\n                        Improve this question\n                    \u0026lt;/a\u0026gt;\n            \u0026lt;/div\u0026gt;\n\u0026lt;/aside\u0026gt;\n\n    \u0026lt;/div\u0026gt;\n\n\u0026lt;p\u0026gt;There are plenty of performance questions on this site already, but it occurs to me that almost all are very problem-specific and fairly narrow. And almost all repeat the advice to avoid premature optimization.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Let\u0026apos;s assume:\u0026lt;/p\u0026gt;\n\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;the code already is working correctly\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;the algorithms chosen are already optimal for the circumstances of the problem\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;the code has been measured, and the offending routines have been isolated\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;all attempts to optimize will also be measured to ensure they do not make matters worse\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\n\u0026lt;p\u0026gt;What I am looking for here is strategies and tricks to squeeze out up to the last few percent in a critical algorithm when there is nothing else left to do but whatever it takes.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Ideally, try to make answers language agnostic, and indicate any down-sides to the suggested strategies where applicable.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;I\u0026apos;ll add a reply with my own initial suggestions, and look forward to whatever else the Stack Overflow community can think of.\u0026lt;/p\u0026gt;\n    ","slug":"performance-optimization-strategies-of-last-resort-closed-1657388420614","postType":"QUESTION","createdAt":"2022-07-09T17:40:20.000Z","updatedAt":"2022-07-09T17:40:20.000Z","tags":[],"relatedQuestions":[]},"randomQuestions":[{"title":"Web-scraping JavaScript page with Python","slug":"web-scraping-javascript-page-with-python-1657388240875"},{"title":"Determine Whether Two Date Ranges Overlap","slug":"determine-whether-two-date-ranges-overlap-1657387924335"},{"title":"What is the difference between a definition and a declaration?","slug":"what-is-the-difference-between-a-definition-and-a-declaration-1657387851618"},{"title":"How do I make Git forget about a file that was tracked, but is now in .gitignore?","slug":"how-do-i-make-git-forget-about-a-file-that-was-tracked-but-is-now-in-.gitignore-1657387328843"},{"title":"How do I split a list into equally-sized chunks?","slug":"how-do-i-split-a-list-into-equally-sized-chunks-1657384580399"},{"title":"Sort (order) data frame rows by multiple columns","slug":"sort-(order)-data-frame-rows-by-multiple-columns-1657388355671"},{"title":"How do you use a variable in a regular expression?","slug":"how-do-you-use-a-variable-in-a-regular-expression-1657387939007"},{"title":"input() error - NameError: name '...' is not defined","slug":"input()-error-nameerror:-name-'...'-is-not-defined-1657388497243"},{"title":"Does Python have a ternary conditional operator?","slug":"does-python-have-a-ternary-conditional-operator-1657387555448"},{"title":"The Definitive C++ Book Guide and List","slug":"the-definitive-c++-book-guide-and-list-1657384247395"},{"title":"How do I merge two dictionaries in a single expression?","slug":"how-do-i-merge-two-dictionaries-in-a-single-expression-1657387593160"},{"title":"How do I sort a dictionary by value?","slug":"how-do-i-sort-a-dictionary-by-value-1657385485049"},{"title":"How to create a generic array in Java?","slug":"how-to-create-a-generic-array-in-java-1657387532298"},{"title":"How do I select rows from a DataFrame based on column values?","slug":"how-do-i-select-rows-from-a-dataframe-based-on-column-values-1657384901065"},{"title":"What does if __name__ == \"__main__\": do?","slug":"what-does-if-__name__-\"__main__\":-do-1657384825815"},{"title":"event.preventDefault() vs. return false","slug":"event.preventdefault()-vs.-return-false-1657387458377"},{"title":"Is there a unique Android device ID?","slug":"is-there-a-unique-android-device-id-1657388089268"},{"title":"Variables are not behaving as expected","slug":"variables-are-not-behaving-as-expected-1657384865672"},{"title":"The ViewData item that has the key 'XXX' is of type 'System.Int32' but must be of type 'IEnumerable\u003cSelectListItem\u003e'","slug":"the-viewdata-item-that-has-the-key-'xxx'-is-of-type-'system.int32'-but-must-be-of-type-'ienumerablelessselectlistitemgreater'-1657388454191"},{"title":"What is the difference between public, protected, package-private and private in Java?","slug":"what-is-the-difference-between-public-protected-package-private-and-private-in-java-1657387376262"}]},"__N_SSG":true},"page":"/questions/[slug]","query":{"slug":"performance-optimization-strategies-of-last-resort-closed-1657388420614"},"buildId":"XDXakEY6gSPdgAODPxtjg","isFallback":false,"gsp":true,"locale":"en","locales":["en"],"defaultLocale":"en","scriptLoader":[]}</script></body></html>