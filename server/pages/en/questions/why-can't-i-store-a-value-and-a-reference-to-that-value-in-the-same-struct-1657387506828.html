<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><meta name="twitter:card" content="summary_large_image"/><meta name="twitter:site" content="@solutionschecker.com"/><meta name="twitter:creator" content="@solutionschecker.com"/><meta property="og:url" content="https://solutionschecker.com"/><meta property="og:type" content="website"/><meta property="og:image" content="https://solutionschecker.com/solutions-checker-banner.png"/><meta property="og:image:alt" content="Find the solution to any question. We focus on finding the fastest possible solution for users. Main topics like coding, learning. - solutionschecker.com"/><link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png"/><link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png"/><link rel="manifest" href="/site.webmanifest"/><script type="application/ld+json">{"@context":"https://schema.org","@type":"Organization","logo":"/logo.svg","url":"https://solutionschecker.com"}</script><link name="keywords" content="rust,lifetime,borrow-checker,solutions checker, solution checker, how to, solution for, check for solution, resolve question, what is, what solution for, find solution"/><script type="application/ld+json">{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"item":{"@id":"https://solutionschecker.com","name":"Home"}},{"@type":"ListItem","position":2,"item":{"@id":"https://solutionschecker.com/questions","name":"Questions"}},{"@type":"ListItem","position":3,"item":{"@id":"https://solutionschecker.com/questions/why-can&apos;t-i-store-a-value-and-a-reference-to-that-value-in-the-same-struct-1657387506828","name":"Questions"}}]}</script><title>Why can&#x27;t I store a value and a reference to that value in the same struct? | Solution Checker</title><meta name="robots" content="index,follow"/><meta name="description" content="I have a value and I want to store that value and a reference to
something inside that value in my own type:

struct Thing {
    count: u32,
}

struct Combined&lt;&#x27;a&gt;(Thing, &amp;&#x27;a u32);

fn make_combined&lt;&#x27;a&gt;() -&gt; Combined&lt;&#x27;a&gt; {
    let thing = Thing { count: 42 };

    Combined(thing, &amp;thing.count)
}


Sometimes, I have a value and I want to store that value and a reference to
that value in the same structure:

struct Combined&lt;&#x27;a&gt;(Thing, &amp;&#x27;a Thing);

fn make_combined&lt;&#x27;a&gt;() -&gt; Combined&lt;&#x27;a&gt; {
    let thing = Thing::new();

    Combined(thing, &amp;thing)
}


Sometimes, I&#x27;m not even taking a reference of the value and I get the
same error:

struct Combined&lt;&#x27;a&gt;(Parent, Child&lt;&#x27;a&gt;);

fn make_combined&lt;&#x27;a&gt;() -&gt; Combined&lt;&#x27;a&gt; {
    let parent = Parent::new();
    let child = parent.child();

    Combined(parent, child)
}


In each of these cases, I get an error that one of the values &quot;does
not live long enough&quot;. What does this error mean?
    "/><meta property="og:title" content="Why can&#x27;t I store a value and a reference to that value in the same struct? | Solution Checker"/><meta property="og:description" content="I have a value and I want to store that value and a reference to
something inside that value in my own type:

struct Thing {
    count: u32,
}

struct Combined&lt;&#x27;a&gt;(Thing, &amp;&#x27;a u32);

fn make_combined&lt;&#x27;a&gt;() -&gt; Combined&lt;&#x27;a&gt; {
    let thing = Thing { count: 42 };

    Combined(thing, &amp;thing.count)
}


Sometimes, I have a value and I want to store that value and a reference to
that value in the same structure:

struct Combined&lt;&#x27;a&gt;(Thing, &amp;&#x27;a Thing);

fn make_combined&lt;&#x27;a&gt;() -&gt; Combined&lt;&#x27;a&gt; {
    let thing = Thing::new();

    Combined(thing, &amp;thing)
}


Sometimes, I&#x27;m not even taking a reference of the value and I get the
same error:

struct Combined&lt;&#x27;a&gt;(Parent, Child&lt;&#x27;a&gt;);

fn make_combined&lt;&#x27;a&gt;() -&gt; Combined&lt;&#x27;a&gt; {
    let parent = Parent::new();
    let child = parent.child();

    Combined(parent, child)
}


In each of these cases, I get an error that one of the values &quot;does
not live long enough&quot;. What does this error mean?
    "/><script type="application/ld+json">{"@context":"https://schema.org","@type":"QAPage","mainEntity":{"name":"Why can&apos;t I store a value and a reference to that value in the same struct?","text":"I have a value and I want to store that value and a reference to\nsomething inside that value in my own type:\n\nstruct Thing {\n    count: u32,\n}\n\nstruct Combined&lt;&apos;a&gt;(Thing, &amp;&apos;a u32);\n\nfn make_combined&lt;&apos;a&gt;() -&gt; Combined&lt;&apos;a&gt; {\n    let thing = Thing { count: 42 };\n\n    Combined(thing, &amp;thing.count)\n}\n\n\nSometimes, I have a value and I want to store that value and a reference to\nthat value in the same structure:\n\nstruct Combined&lt;&apos;a&gt;(Thing, &amp;&apos;a Thing);\n\nfn make_combined&lt;&apos;a&gt;() -&gt; Combined&lt;&apos;a&gt; {\n    let thing = Thing::new();\n\n    Combined(thing, &amp;thing)\n}\n\n\nSometimes, I&apos;m not even taking a reference of the value and I get the\nsame error:\n\nstruct Combined&lt;&apos;a&gt;(Parent, Child&lt;&apos;a&gt;);\n\nfn make_combined&lt;&apos;a&gt;() -&gt; Combined&lt;&apos;a&gt; {\n    let parent = Parent::new();\n    let child = parent.child();\n\n    Combined(parent, child)\n}\n\n\nIn each of these cases, I get an error that one of the values &quot;does\nnot live long enough&quot;. What does this error mean?\n    ","answerCount":3,"upVoteCount":500,"suggestedAnswer":[{"text":"Let&apos;s look at a simple implementation of this:\nstruct Parent {\n    count: u32,\n}\n\nstruct Child&lt;&apos;a&gt; {\n    parent: &amp;&apos;a Parent,\n}\n\nstruct Combined&lt;&apos;a&gt; {\n    parent: Parent,\n    child: Child&lt;&apos;a&gt;,\n}\n\nimpl&lt;&apos;a&gt; Combined&lt;&apos;a&gt; {\n    fn new() -&gt; Self {\n        let parent = Parent { count: 42 };\n        let child = Child { parent: &amp;parent };\n\n        Combined { parent, child }\n    }\n}\n\nfn main() {}\n\nThis will fail with the error:\nerror[E0515]: cannot return value referencing local variable `parent`\n  --&gt; src/main.rs:19:9\n   |\n17 |         let child = Child { parent: &amp;parent };\n   |                                     ------- `parent` is borrowed here\n18 | \n19 |         Combined { parent, child }\n   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^ returns a value referencing data owned by the current function\n\nerror[E0505]: cannot move out of `parent` because it is borrowed\n  --&gt; src/main.rs:19:20\n   |\n14 | impl&lt;&apos;a&gt; Combined&lt;&apos;a&gt; {\n   |      -- lifetime `&apos;a` defined here\n...\n17 |         let child = Child { parent: &amp;parent };\n   |                                     ------- borrow of `parent` occurs here\n18 | \n19 |         Combined { parent, child }\n   |         -----------^^^^^^---------\n   |         |          |\n   |         |          move out of `parent` occurs here\n   |         returning this value requires that `parent` is borrowed for `&apos;a`\n\nTo completely understand this error, you have to think about how the\nvalues are represented in memory and what happens when you move\nthose values. Let&apos;s annotate Combined::new with some hypothetical\nmemory addresses that show where values are located:\nlet parent = Parent { count: 42 };\n// `parent` lives at address 0x1000 and takes up 4 bytes\n// The value of `parent` is 42 \nlet child = Child { parent: &amp;parent };\n// `child` lives at address 0x1010 and takes up 4 bytes\n// The value of `child` is 0x1000\n         \nCombined { parent, child }\n// The return value lives at address 0x2000 and takes up 8 bytes\n// `parent` is moved to 0x2000\n// `child` is ... ?\n\nWhat should happen to child? If the value was just moved like parent\nwas, then it would refer to memory that no longer is guaranteed to\nhave a valid value in it. Any other piece of code is allowed to store\nvalues at memory address 0x1000. Accessing that memory assuming it was\nan integer could lead to crashes and/or security bugs, and is one of\nthe main categories of errors that Rust prevents.\nThis is exactly the problem that lifetimes prevent. A lifetime is a\nbit of metadata that allows you and the compiler to know how long a\nvalue will be valid at its current memory location. That&apos;s an\nimportant distinction, as it&apos;s a common mistake Rust newcomers make.\nRust lifetimes are not the time period between when an object is\ncreated and when it is destroyed!\nAs an analogy, think of it this way: During a person&apos;s life, they will\nreside in many different locations, each with a distinct address. A\nRust lifetime is concerned with the address you currently reside at,\nnot about whenever you will die in the future (although dying also\nchanges your address). Every time you move it&apos;s relevant because your\naddress is no longer valid.\nIt&apos;s also important to note that lifetimes do not change your code; your\ncode controls the lifetimes, your lifetimes don&apos;t control the code. The\npithy saying is &quot;lifetimes are descriptive, not prescriptive&quot;.\nLet&apos;s annotate Combined::new with some line numbers which we will use\nto highlight lifetimes:\n{                                          // 0\n    let parent = Parent { count: 42 };     // 1\n    let child = Child { parent: &amp;parent }; // 2\n                                           // 3\n    Combined { parent, child }             // 4\n}                                          // 5\n\nThe concrete lifetime of parent is from 1 to 4, inclusive (which I&apos;ll\nrepresent as [1,4]). The concrete lifetime of child is [2,4], and\nthe concrete lifetime of the return value is [4,5]. It&apos;s\npossible to have concrete lifetimes that start at zero - that would\nrepresent the lifetime of a parameter to a function or something that\nexisted outside of the block.\nNote that the lifetime of child itself is [2,4], but that it refers\nto a value with a lifetime of [1,4]. This is fine as long as the\nreferring value becomes invalid before the referred-to value does. The\nproblem occurs when we try to return child from the block. This would\n&quot;over-extend&quot; the lifetime beyond its natural length.\nThis new knowledge should explain the first two examples. The third\none requires looking at the implementation of Parent::child. Chances\nare, it will look something like this:\nimpl Parent {\n    fn child(&amp;self) -&gt; Child { /* ... */ }\n}\n\nThis uses lifetime elision to avoid writing explicit generic\nlifetime parameters. It is equivalent to:\nimpl Parent {\n    fn child&lt;&apos;a&gt;(&amp;&apos;a self) -&gt; Child&lt;&apos;a&gt; { /* ... */ }\n}\n\nIn both cases, the method says that a Child structure will be\nreturned that has been parameterized with the concrete lifetime of\nself. Said another way, the Child instance contains a reference\nto the Parent that created it, and thus cannot live longer than that\nParent instance.\nThis also lets us recognize that something is really wrong with our\ncreation function:\nfn make_combined&lt;&apos;a&gt;() -&gt; Combined&lt;&apos;a&gt; { /* ... */ }\n\nAlthough you are more likely to see this written in a different form:\nimpl&lt;&apos;a&gt; Combined&lt;&apos;a&gt; {\n    fn new() -&gt; Combined&lt;&apos;a&gt; { /* ... */ }\n}\n\nIn both cases, there is no lifetime parameter being provided via an\nargument. This means that the lifetime that Combined will be\nparameterized with isn&apos;t constrained by anything - it can be whatever\nthe caller wants it to be. This is nonsensical, because the caller\ncould specify the &apos;static lifetime and there&apos;s no way to meet that\ncondition.\nHow do I fix it?\nThe easiest and most recommended solution is to not attempt to put\nthese items in the same structure together. By doing this, your\nstructure nesting will mimic the lifetimes of your code. Place types\nthat own data into a structure together and then provide methods that\nallow you to get references or objects containing references as needed.\nThere is a special case where the lifetime tracking is overzealous:\nwhen you have something placed on the heap. This occurs when you use a\nBox&lt;T&gt;, for example. In this case, the structure that is moved\ncontains a pointer into the heap. The pointed-at value will remain\nstable, but the address of the pointer itself will move. In practice,\nthis doesn&apos;t matter, as you always follow the pointer.\nSome crates provide ways of representing this case, but they\nrequire that the base address never move. This rules out mutating\nvectors, which may cause a reallocation and a move of the\nheap-allocated values.\n\nrental (no longer maintained or suppported)\nowning_ref\nouroboros\n\nExamples of problems solved with Rental:\n\nIs there an owned version of String::chars?\nReturning a RWLockReadGuard independently from a method\nHow can I return an iterator over a locked struct member in Rust?\nHow to return a reference to a sub-value of a value that is under a mutex?\nHow do I store a result using Serde Zero-copy deserialization of a Futures-enabled Hyper Chunk?\nHow to store a reference without having to deal with lifetimes?\n\nIn other cases, you may wish to move to some type of reference-counting, such as by using Rc or Arc.\nMore information\n\nAfter moving parent into the struct, why is the compiler not able to get a new reference to parent and assign it to child in the struct?\n\nWhile it is theoretically possible to do this, doing so would introduce a large amount of complexity and overhead. Every time that the object is moved, the compiler would need to insert code to &quot;fix up&quot; the reference. This would mean that copying a struct is no longer a very cheap operation that just moves some bits around. It could even mean that code like this is expensive, depending on how good a hypothetical optimizer would be:\nlet a = Object::new();\nlet b = a;\nlet c = b;\n\nInstead of forcing this to happen for every move, the programmer gets to choose when this will happen by creating methods that will take the appropriate references only when you call them.\nA type with a reference to itself\nThere&apos;s one specific case where you can create a type with a reference to itself. You need to use something like Option to make it in two steps though:\n#[derive(Debug)]\nstruct WhatAboutThis&lt;&apos;a&gt; {\n    name: String,\n    nickname: Option&lt;&amp;&apos;a str&gt;,\n}\n\nfn main() {\n    let mut tricky = WhatAboutThis {\n        name: &quot;Annabelle&quot;.to_string(),\n        nickname: None,\n    };\n    tricky.nickname = Some(&amp;tricky.name[..4]);\n\n    println!(&quot;{:?}&quot;, tricky);\n}\n\nThis does work, in some sense, but the created value is highly restricted - it can never be moved. Notably, this means it cannot be returned from a function or passed by-value to anything. A constructor function shows the same problem with the lifetimes as above:\nfn creator&lt;&apos;a&gt;() -&gt; WhatAboutThis&lt;&apos;a&gt; { /* ... */ }\n\nIf you try to do this same code with a method, you&apos;ll need the alluring but ultimately useless &amp;&apos;a self. When that&apos;s involved, this code is even more restricted and you will get borrow-checker errors after the first method call:\n#[derive(Debug)]\nstruct WhatAboutThis&lt;&apos;a&gt; {\n    name: String,\n    nickname: Option&lt;&amp;&apos;a str&gt;,\n}\n\nimpl&lt;&apos;a&gt; WhatAboutThis&lt;&apos;a&gt; {\n    fn tie_the_knot(&amp;&apos;a mut self) {\n       self.nickname = Some(&amp;self.name[..4]); \n    }\n}\n\nfn main() {\n    let mut tricky = WhatAboutThis {\n        name: &quot;Annabelle&quot;.to_string(),\n        nickname: None,\n    };\n    tricky.tie_the_knot();\n\n    // cannot borrow `tricky` as immutable because it is also borrowed as mutable\n    // println!(&quot;{:?}&quot;, tricky);\n}\n\nSee also:\n\nCannot borrow as mutable more than once at a time in one code - but can in another very similar\n\nWhat about Pin?\nPin, stabilized in Rust 1.33, has this in the module documentation:\n\nA prime example of such a scenario would be building self-referential structs, since moving an object with pointers to itself will invalidate them, which could cause undefined behavior.\n\nIt&apos;s important to note that &quot;self-referential&quot; doesn&apos;t necessarily mean using a reference. Indeed, the example of a self-referential struct specifically says (emphasis mine):\n\nWe cannot inform the compiler about that with a normal reference,\nsince this pattern cannot be described with the usual borrowing rules.\nInstead we use a raw pointer, though one which is known to not be null,\nsince we know it&apos;s pointing at the string.\n\nThe ability to use a raw pointer for this behavior has existed since Rust 1.0. Indeed, owning-ref and rental use raw pointers under the hood.\nThe only thing that Pin adds to the table is a common way to state that a given value is guaranteed to not move.\nSee also:\n\nHow to use the Pin struct with self-referential structures?\n\n    ","url":"/questions/[slug]#solution1","@type":"Answer","upvoteCount":0},{"text":"A slightly different issue which causes very similar compiler messages is object lifetime dependency, rather than storing an explicit reference. An example of that is the ssh2 library. When developing something bigger than a test project, it is tempting to try to put the Session and Channel obtained from that session alongside each other into a struct, hiding the implementation details from the user. However, note that the Channel definition has the &apos;sess lifetime in its type annotation, while Session doesn&apos;t.\n\nThis causes similar compiler errors related to lifetimes.\n\nOne way to solve it in a very simple way is to declare the Session outside in the caller, and then for annotate the reference within the struct with a lifetime, similar to the answer in this Rust User&apos;s Forum post talking about the same issue while encapsulating SFTP. This will not look elegant and may not always apply - because now you have two entities to deal with, rather than one that you wanted!\n\nTurns out the rental crate or the owning_ref crate from the other answer are the solutions for this issue too. Let&apos;s consider the owning_ref, which has the special object for this exact purpose:\nOwningHandle. To avoid the underlying object moving, we allocate it on the heap using a Box, which gives us the following possible solution:\n\nuse ssh2::{Channel, Error, Session};\nuse std::net::TcpStream;\n\nuse owning_ref::OwningHandle;\n\nstruct DeviceSSHConnection {\n    tcp: TcpStream,\n    channel: OwningHandle&lt;Box&lt;Session&gt;, Box&lt;Channel&lt;&apos;static&gt;&gt;&gt;,\n}\n\nimpl DeviceSSHConnection {\n    fn new(targ: &amp;str, c_user: &amp;str, c_pass: &amp;str) -&gt; Self {\n        use std::net::TcpStream;\n        let mut session = Session::new().unwrap();\n        let mut tcp = TcpStream::connect(targ).unwrap();\n\n        session.handshake(&amp;tcp).unwrap();\n        session.set_timeout(5000);\n        session.userauth_password(c_user, c_pass).unwrap();\n\n        let mut sess = Box::new(session);\n        let mut oref = OwningHandle::new_with_fn(\n            sess,\n            unsafe { |x| Box::new((*x).channel_session().unwrap()) },\n        );\n\n        oref.shell().unwrap();\n        let ret = DeviceSSHConnection {\n            tcp: tcp,\n            channel: oref,\n        };\n        ret\n    }\n}\n\n\nThe result of this code is that we can not use the Session anymore, but it is stored alongside with the Channel which we will be using. Because the OwningHandle object dereferences to Box, which dereferences to Channel, when storing it in a struct, we name it as such. NOTE: This is just my understanding. I have a suspicion this may not be correct, since it appears to be quite close to discussion of OwningHandle unsafety. \n\nOne curious detail here is that the Session logically has a similar relationship with TcpStream as Channel has to Session, yet its ownership is not taken and there are no type annotations around doing so. Instead, it is up to the user to take care of this, as the documentation of handshake method says:\n\n\n  This session does not take ownership of the socket provided, it is\n  recommended to ensure that the socket persists the lifetime of this\n  session to ensure that communication is correctly performed.\n  \n  It is also highly recommended that the stream provided is not used\n  concurrently elsewhere for the duration of this session as it may\n  interfere with the protocol.\n\n\nSo with the TcpStream usage, is completely up to the programmer to ensure the correctness of the code. With the OwningHandle, the attention to where the &quot;dangerous magic&quot; happens is drawn using the unsafe {} block.\n\nA further and a more high-level discussion of this issue is in this Rust User&apos;s Forum thread - which includes a different example and its solution using the rental crate, which does not contain unsafe blocks.\n    ","url":"/questions/[slug]#solution2","@type":"Answer","upvoteCount":0},{"text":"I&apos;ve found the Arc (read-only) or Arc&lt;Mutex&gt; (read-write with locking) patterns to be sometimes quite useful tradeoff between performance and code complexity (mostly caused by lifetime-annotation).\nArc:\nuse std::sync::Arc;\n\nstruct Parent {\n    child: Arc&lt;Child&gt;,\n}\nstruct Child {\n    value: u32,\n}\nstruct Combined(Parent, Arc&lt;Child&gt;);\n\nfn main() {\n    let parent = Parent { child: Arc::new(Child { value: 42 }) };\n    let child = parent.child.clone();\n    let combined = Combined(parent, child.clone());\n\n    assert_eq!(combined.0.child.value, 42);\n    assert_eq!(child.value, 42);\n    // combined.0.child.value = 50; // fails, Arc is not DerefMut\n}\n\nArc + Mutex:\nuse std::sync::{Arc, Mutex};\n\nstruct Child {\n    value: u32,\n}\nstruct Parent {\n    child: Arc&lt;Mutex&lt;Child&gt;&gt;,\n}\nstruct Combined(Parent, Arc&lt;Mutex&lt;Child&gt;&gt;);\n\nfn main() {\n    let parent = Parent { child: Arc::new(Mutex::new(Child {value: 42 }))};\n    let child = parent.child.clone();\n    let combined = Combined(parent, child.clone());\n\n    assert_eq!(combined.0.child.lock().unwrap().value, 42);\n    assert_eq!(child.lock().unwrap().value, 42);\n    child.lock().unwrap().value = 50;\n    assert_eq!(combined.0.child.lock().unwrap().value, 50);\n}\n\nSee also RwLock (When or why should I use a Mutex over an RwLock?)\n    ","url":"/questions/[slug]#solution3","@type":"Answer","upvoteCount":0}],"@type":"Question"}}</script><meta name="next-head-count" content="22"/><link rel="preload" href="/_next/static/css/4f7b2847abfe82c6.css" as="style"/><link rel="stylesheet" href="/_next/static/css/4f7b2847abfe82c6.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-0d1b80a048d4787e.js"></script><script src="/_next/static/chunks/webpack-42cdea76c8170223.js" defer=""></script><script src="/_next/static/chunks/framework-4556c45dd113b893.js" defer=""></script><script src="/_next/static/chunks/main-ccfab947c79712f4.js" defer=""></script><script src="/_next/static/chunks/pages/_app-c0d2dcb5e85faf18.js" defer=""></script><script src="/_next/static/chunks/294-106ef8570fa99deb.js" defer=""></script><script src="/_next/static/chunks/490-7f0418bb4354ac73.js" defer=""></script><script src="/_next/static/chunks/pages/questions/%5Bslug%5D-50e201fdaa1e0fd1.js" defer=""></script><script src="/_next/static/eGqQHYKGZKE-nXShFn8wX/_buildManifest.js" defer=""></script><script src="/_next/static/eGqQHYKGZKE-nXShFn8wX/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="wrapper"><header><nav class="bg-white border-gray-200 px-4 lg:px-6 py-2.5 dark:bg-gray-800"><div class="flex flex-wrap justify-between items-center mx-auto max-w-screen-xl"><a class="flex items-center" href="/"><img src="/logo-second.png" class="mr-3 h-6 sm:h-9" alt="Solution Checker Logo"/><h1 class="self-center text-xl font-semibold whitespace-nowrap dark:text-white">Solution Checker</h1></a><div class="flex items-center lg:order-2"><button data-collapse-toggle="mobile-menu-2" type="button" class="inline-flex items-center p-2 ml-1 text-sm text-gray-500 rounded-lg lg:hidden hover:bg-gray-100 focus:outline-none focus:ring-2 focus:ring-gray-200 dark:text-gray-400 dark:hover:bg-gray-700 dark:focus:ring-gray-600" aria-controls="mobile-menu-2" aria-expanded="false"><span class="sr-only">Open main menu</span><svg class="w-6 h-6" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M3 5a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM3 10a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM3 15a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1z" clip-rule="evenodd"></path></svg><svg class="hidden w-6 h-6" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z" clip-rule="evenodd"></path></svg></button></div><div class="hidden justify-between items-center w-full lg:flex lg:w-auto lg:order-1" id="mobile-menu-2"><ul class="flex flex-col mt-4 font-medium lg:flex-row lg:space-x-8 lg:mt-0"><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" aria-current="page" href="/">Home</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/questions?tab=news">Questions</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/post?tab=news">Post</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/questions/why-can&#x27;t-i-store-a-value-and-a-reference-to-that-value-in-the-same-struct-1657387506828#">Coding</a></li></ul></div></div></nav></header><div class="main-content"><div class="question my-5"><div class="flex question-header items-center m-auto justify-center"><div class="rounded-xl w-full border p-5 shadow-md bg-white"><div class="flex w-full items-center justify-between border-b pb-3"><div class="flex items-center space-x-3"><div class="text-lg font-bold text-slate-700"><a href="/questions/why-can&#x27;t-i-store-a-value-and-a-reference-to-that-value-in-the-same-struct-1657387506828"><h1>Why can&#x27;t I store a value and a reference to that value in the same struct?</h1></a></div></div><div class="flex flex-wrap h-auto justify-end items-center space-x-8"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold" href="/questions/tag/rust">rust</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold" href="/questions/tag/lifetime">lifetime</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold" href="/questions/tag/borrow-checker">borrow-checker</a></div></div><div class="question-content mt-5">
                
<p>I have a value and I want to store that value and a reference to
something inside that value in my own type:</p>

<pre class="lang-rust s-code-block"><code class="hljs language-rust"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Thing</span> {
    count: <span class="hljs-type">u32</span>,
}

<span class="hljs-keyword">struct</span> <span class="hljs-title class_">Combined</span>&lt;<span class="hljs-symbol">'a</span>&gt;(Thing, &amp;<span class="hljs-symbol">'a</span> <span class="hljs-type">u32</span>);

<span class="hljs-keyword">fn</span> <span class="hljs-title function_">make_combined</span>&lt;<span class="hljs-symbol">'a</span>&gt;() <span class="hljs-punctuation">-&gt;</span> Combined&lt;<span class="hljs-symbol">'a</span>&gt; {
    <span class="hljs-keyword">let</span> <span class="hljs-variable">thing</span> = Thing { count: <span class="hljs-number">42</span> };

    <span class="hljs-title function_ invoke__">Combined</span>(thing, &amp;thing.count)
}
</code></pre>

<p>Sometimes, I have a value and I want to store that value and a reference to
that value in the same structure:</p>

<pre class="lang-rust s-code-block"><code class="hljs language-rust"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Combined</span>&lt;<span class="hljs-symbol">'a</span>&gt;(Thing, &amp;<span class="hljs-symbol">'a</span> Thing);

<span class="hljs-keyword">fn</span> <span class="hljs-title function_">make_combined</span>&lt;<span class="hljs-symbol">'a</span>&gt;() <span class="hljs-punctuation">-&gt;</span> Combined&lt;<span class="hljs-symbol">'a</span>&gt; {
    <span class="hljs-keyword">let</span> <span class="hljs-variable">thing</span> = Thing::<span class="hljs-title function_ invoke__">new</span>();

    <span class="hljs-title function_ invoke__">Combined</span>(thing, &amp;thing)
}
</code></pre>

<p>Sometimes, I'm not even taking a reference of the value and I get the
same error:</p>

<pre class="lang-rust s-code-block"><code class="hljs language-rust"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Combined</span>&lt;<span class="hljs-symbol">'a</span>&gt;(Parent, Child&lt;<span class="hljs-symbol">'a</span>&gt;);

<span class="hljs-keyword">fn</span> <span class="hljs-title function_">make_combined</span>&lt;<span class="hljs-symbol">'a</span>&gt;() <span class="hljs-punctuation">-&gt;</span> Combined&lt;<span class="hljs-symbol">'a</span>&gt; {
    <span class="hljs-keyword">let</span> <span class="hljs-variable">parent</span> = Parent::<span class="hljs-title function_ invoke__">new</span>();
    <span class="hljs-keyword">let</span> <span class="hljs-variable">child</span> = parent.<span class="hljs-title function_ invoke__">child</span>();

    <span class="hljs-title function_ invoke__">Combined</span>(parent, child)
}
</code></pre>

<p>In each of these cases, I get an error that one of the values "does
not live long enough". What does this error mean?</p>
    </div></div></div><div class="solution-section"><nav class="flex pagination-solution flex-col justify-end"><h1 class="text-lg font-semibold mb-5">Navigate to solutions: </h1><ul class="inline-flex -space-x-px overflow-auto"><li class="pagination-solution-item"><span data-id="#solution1" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">1</span></li><li class="pagination-solution-item"><span data-id="#solution2" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">2</span></li><li class="pagination-solution-item"><span data-id="#solution3" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">3</span></li></ul></nav><div id="solution1" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 1</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/rust">rust</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/lifetime">lifetime</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/borrow-checker">borrow-checker</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Let's look at <a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=c1432ed38048684c7eb306540c182cd0" rel="noreferrer">a simple implementation of this</a>:</p>
<pre class="lang-rust s-code-block"><code class="hljs language-rust"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Parent</span> {
    count: <span class="hljs-type">u32</span>,
}

<span class="hljs-keyword">struct</span> <span class="hljs-title class_">Child</span>&lt;<span class="hljs-symbol">'a</span>&gt; {
    parent: &amp;<span class="hljs-symbol">'a</span> Parent,
}

<span class="hljs-keyword">struct</span> <span class="hljs-title class_">Combined</span>&lt;<span class="hljs-symbol">'a</span>&gt; {
    parent: Parent,
    child: Child&lt;<span class="hljs-symbol">'a</span>&gt;,
}

<span class="hljs-keyword">impl</span>&lt;<span class="hljs-symbol">'a</span>&gt; Combined&lt;<span class="hljs-symbol">'a</span>&gt; {
    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">new</span>() <span class="hljs-punctuation">-&gt;</span> <span class="hljs-keyword">Self</span> {
        <span class="hljs-keyword">let</span> <span class="hljs-variable">parent</span> = Parent { count: <span class="hljs-number">42</span> };
        <span class="hljs-keyword">let</span> <span class="hljs-variable">child</span> = Child { parent: &amp;parent };

        Combined { parent, child }
    }
}

<span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() {}
</code></pre>
<p>This will fail with the error:</p>
<pre class="lang-none s-code-block"><code>error[E0515]: cannot return value referencing local variable `parent`
  --&gt; src/main.rs:19:9
   |
17 |         let child = Child { parent: &amp;parent };
   |                                     ------- `parent` is borrowed here
18 | 
19 |         Combined { parent, child }
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^ returns a value referencing data owned by the current function

error[E0505]: cannot move out of `parent` because it is borrowed
  --&gt; src/main.rs:19:20
   |
14 | impl&lt;'a&gt; Combined&lt;'a&gt; {
   |      -- lifetime `'a` defined here
...
17 |         let child = Child { parent: &amp;parent };
   |                                     ------- borrow of `parent` occurs here
18 | 
19 |         Combined { parent, child }
   |         -----------^^^^^^---------
   |         |          |
   |         |          move out of `parent` occurs here
   |         returning this value requires that `parent` is borrowed for `'a`
</code></pre>
<p>To completely understand this error, you have to think about how the
values are represented in memory and what happens when you <em>move</em>
those values. Let's annotate <code>Combined::new</code> with some hypothetical
memory addresses that show where values are located:</p>
<pre class="lang-rust s-code-block"><code class="hljs language-rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">parent</span> = Parent { count: <span class="hljs-number">42</span> };
<span class="hljs-comment">// `parent` lives at address 0x1000 and takes up 4 bytes</span>
<span class="hljs-comment">// The value of `parent` is 42 </span>
<span class="hljs-keyword">let</span> <span class="hljs-variable">child</span> = Child { parent: &amp;parent };
<span class="hljs-comment">// `child` lives at address 0x1010 and takes up 4 bytes</span>
<span class="hljs-comment">// The value of `child` is 0x1000</span>
         
Combined { parent, child }
<span class="hljs-comment">// The return value lives at address 0x2000 and takes up 8 bytes</span>
<span class="hljs-comment">// `parent` is moved to 0x2000</span>
<span class="hljs-comment">// `child` is ... ?</span>
</code></pre>
<p>What should happen to <code>child</code>? If the value was just moved like <code>parent</code>
was, then it would refer to memory that no longer is guaranteed to
have a valid value in it. Any other piece of code is allowed to store
values at memory address 0x1000. Accessing that memory assuming it was
an integer could lead to crashes and/or security bugs, and is one of
the main categories of errors that Rust prevents.</p>
<p>This is exactly the problem that <em>lifetimes</em> prevent. A lifetime is a
bit of metadata that allows you and the compiler to know how long a
value will be valid at its <strong>current memory location</strong>. That's an
important distinction, as it's a common mistake Rust newcomers make.
Rust lifetimes are <em>not</em> the time period between when an object is
created and when it is destroyed!</p>
<p>As an analogy, think of it this way: During a person's life, they will
reside in many different locations, each with a distinct address. A
Rust lifetime is concerned with the address you <em>currently reside at</em>,
not about whenever you will die in the future (although dying also
changes your address). Every time you move it's relevant because your
address is no longer valid.</p>
<p>It's also important to note that lifetimes <em>do not</em> change your code; your
code controls the lifetimes, your lifetimes don't control the code. The
pithy saying is "lifetimes are descriptive, not prescriptive".</p>
<p>Let's annotate <code>Combined::new</code> with some line numbers which we will use
to highlight lifetimes:</p>
<pre class="lang-rust s-code-block"><code class="hljs language-rust">{                                          <span class="hljs-comment">// 0</span>
    <span class="hljs-keyword">let</span> <span class="hljs-variable">parent</span> = Parent { count: <span class="hljs-number">42</span> };     <span class="hljs-comment">// 1</span>
    <span class="hljs-keyword">let</span> <span class="hljs-variable">child</span> = Child { parent: &amp;parent }; <span class="hljs-comment">// 2</span>
                                           <span class="hljs-comment">// 3</span>
    Combined { parent, child }             <span class="hljs-comment">// 4</span>
}                                          <span class="hljs-comment">// 5</span>
</code></pre>
<p>The <em>concrete lifetime</em> of <code>parent</code> is from 1 to 4, inclusive (which I'll
represent as <code>[1,4]</code>). The concrete lifetime of <code>child</code> is <code>[2,4]</code>, and
the concrete lifetime of the return value is <code>[4,5]</code>. It's
possible to have concrete lifetimes that start at zero - that would
represent the lifetime of a parameter to a function or something that
existed outside of the block.</p>
<p>Note that the lifetime of <code>child</code> itself is <code>[2,4]</code>, but that it <strong>refers
to</strong> a value with a lifetime of <code>[1,4]</code>. This is fine as long as the
referring value becomes invalid before the referred-to value does. The
problem occurs when we try to return <code>child</code> from the block. This would
"over-extend" the lifetime beyond its natural length.</p>
<p>This new knowledge should explain the first two examples. The third
one requires looking at the implementation of <code>Parent::child</code>. Chances
are, it will look something like this:</p>
<pre class="lang-rust s-code-block"><code class="hljs language-rust"><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Parent</span> {
    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">child</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> Child { <span class="hljs-comment">/* ... */</span> }
}
</code></pre>
<p>This uses <em>lifetime elision</em> to avoid writing explicit <em>generic
lifetime parameters</em>. It is equivalent to:</p>
<pre class="lang-rust s-code-block"><code class="hljs language-rust"><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Parent</span> {
    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">child</span>&lt;<span class="hljs-symbol">'a</span>&gt;(&amp;<span class="hljs-symbol">'a</span> <span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> Child&lt;<span class="hljs-symbol">'a</span>&gt; { <span class="hljs-comment">/* ... */</span> }
}
</code></pre>
<p>In both cases, the method says that a <code>Child</code> structure will be
returned that has been parameterized with the concrete lifetime of
<code>self</code>. Said another way, the <code>Child</code> instance contains a reference
to the <code>Parent</code> that created it, and thus cannot live longer than that
<code>Parent</code> instance.</p>
<p>This also lets us recognize that something is really wrong with our
creation function:</p>
<pre class="lang-rust s-code-block"><code class="hljs language-rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">make_combined</span>&lt;<span class="hljs-symbol">'a</span>&gt;() <span class="hljs-punctuation">-&gt;</span> Combined&lt;<span class="hljs-symbol">'a</span>&gt; { <span class="hljs-comment">/* ... */</span> }
</code></pre>
<p>Although you are more likely to see this written in a different form:</p>
<pre class="lang-rust s-code-block"><code class="hljs language-rust"><span class="hljs-keyword">impl</span>&lt;<span class="hljs-symbol">'a</span>&gt; Combined&lt;<span class="hljs-symbol">'a</span>&gt; {
    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">new</span>() <span class="hljs-punctuation">-&gt;</span> Combined&lt;<span class="hljs-symbol">'a</span>&gt; { <span class="hljs-comment">/* ... */</span> }
}
</code></pre>
<p>In both cases, there is no lifetime parameter being provided via an
argument. This means that the lifetime that <code>Combined</code> will be
parameterized with isn't constrained by anything - it can be whatever
the caller wants it to be. This is nonsensical, because the caller
could specify the <code>'static</code> lifetime and there's no way to meet that
condition.</p>
<h3>How do I fix it?</h3>
<p>The easiest and most recommended solution is to not attempt to put
these items in the same structure together. By doing this, your
structure nesting will mimic the lifetimes of your code. Place types
that own data into a structure together and then provide methods that
allow you to get references or objects containing references as needed.</p>
<p>There is a special case where the lifetime tracking is overzealous:
when you have something placed on the heap. This occurs when you use a
<code>Box&lt;T&gt;</code>, for example. In this case, the structure that is moved
contains a pointer into the heap. The pointed-at value will remain
stable, but the address of the pointer itself will move. In practice,
this doesn't matter, as you always follow the pointer.</p>
<p>Some crates provide ways of representing this case, but they
require that the base address <em>never move</em>. This rules out mutating
vectors, which may cause a reallocation and a move of the
heap-allocated values.</p>
<ul>
<li><a href="https://crates.io/crates/rental" rel="noreferrer">rental</a> (no longer maintained or suppported)</li>
<li><a href="https://crates.io/crates/owning_ref" rel="noreferrer">owning_ref</a></li>
<li><a href="https://crates.io/crates/ouroboros" rel="noreferrer">ouroboros</a></li>
</ul>
<p>Examples of problems solved with Rental:</p>
<ul>
<li><a href="https://stackoverflow.com/q/47193584/155423">Is there an owned version of String::chars?</a></li>
<li><a href="https://stackoverflow.com/q/50496879/155423">Returning a RWLockReadGuard independently from a method</a></li>
<li><a href="https://stackoverflow.com/q/51664098/155423">How can I return an iterator over a locked struct member in Rust?</a></li>
<li><a href="https://stackoverflow.com/q/40095383/155423">How to return a reference to a sub-value of a value that is under a mutex?</a></li>
<li><a href="https://stackoverflow.com/q/43702185/155423">How do I store a result using Serde Zero-copy deserialization of a Futures-enabled Hyper Chunk?</a></li>
<li><a href="https://stackoverflow.com/q/49300618/155423">How to store a reference without having to deal with lifetimes?</a></li>
</ul>
<p>In other cases, you may wish to move to some type of reference-counting, such as by using <a href="https://doc.rust-lang.org/std/rc/struct.Rc.html" rel="noreferrer"><code>Rc</code></a> or <a href="https://doc.rust-lang.org/std/sync/struct.Arc.html" rel="noreferrer"><code>Arc</code></a>.</p>
<h3>More information</h3>
<blockquote>
<p>After moving <code>parent</code> into the struct, why is the compiler not able to get a new reference to <code>parent</code> and assign it to <code>child</code> in the struct?</p>
</blockquote>
<p>While it is theoretically possible to do this, doing so would introduce a large amount of complexity and overhead. Every time that the object is moved, the compiler would need to insert code to "fix up" the reference. This would mean that copying a struct is no longer a very cheap operation that just moves some bits around. It could even mean that code like this is expensive, depending on how good a hypothetical optimizer would be:</p>
<pre class="lang-rust s-code-block"><code class="hljs language-rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">a</span> = Object::<span class="hljs-title function_ invoke__">new</span>();
<span class="hljs-keyword">let</span> <span class="hljs-variable">b</span> = a;
<span class="hljs-keyword">let</span> <span class="hljs-variable">c</span> = b;
</code></pre>
<p>Instead of forcing this to happen for <em>every</em> move, the programmer gets to <em>choose</em> when this will happen by creating methods that will take the appropriate references only when you call them.</p>
<h3>A type with a reference to itself</h3>
<p>There's one specific case where you <em>can</em> create a type with a reference to itself. You need to use something like <code>Option</code> to make it in two steps though:</p>
<pre class="lang-rust s-code-block"><code class="hljs language-rust"><span class="hljs-meta">#[derive(Debug)]</span>
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">WhatAboutThis</span>&lt;<span class="hljs-symbol">'a</span>&gt; {
    name: <span class="hljs-type">String</span>,
    nickname: <span class="hljs-type">Option</span>&lt;&amp;<span class="hljs-symbol">'a</span> <span class="hljs-type">str</span>&gt;,
}

<span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() {
    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">tricky</span> = WhatAboutThis {
        name: <span class="hljs-string">"Annabelle"</span>.<span class="hljs-title function_ invoke__">to_string</span>(),
        nickname: <span class="hljs-literal">None</span>,
    };
    tricky.nickname = <span class="hljs-title function_ invoke__">Some</span>(&amp;tricky.name[..<span class="hljs-number">4</span>]);

    <span class="hljs-built_in">println!</span>(<span class="hljs-string">"{:?}"</span>, tricky);
}
</code></pre>
<p>This does work, in some sense, but the created value is highly restricted - it can <em>never</em> be moved. Notably, this means it cannot be returned from a function or passed by-value to anything. A constructor function shows the same problem with the lifetimes as above:</p>
<pre class="lang-rust s-code-block"><code class="hljs language-rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">creator</span>&lt;<span class="hljs-symbol">'a</span>&gt;() <span class="hljs-punctuation">-&gt;</span> WhatAboutThis&lt;<span class="hljs-symbol">'a</span>&gt; { <span class="hljs-comment">/* ... */</span> }
</code></pre>
<p>If you try to do this same code with a method, you'll need the alluring but ultimately useless <code>&amp;'a self</code>. When that's involved, this code is even more restricted and you will get borrow-checker errors after the first method call:</p>
<pre class="lang-rust s-code-block"><code class="hljs language-rust"><span class="hljs-meta">#[derive(Debug)]</span>
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">WhatAboutThis</span>&lt;<span class="hljs-symbol">'a</span>&gt; {
    name: <span class="hljs-type">String</span>,
    nickname: <span class="hljs-type">Option</span>&lt;&amp;<span class="hljs-symbol">'a</span> <span class="hljs-type">str</span>&gt;,
}

<span class="hljs-keyword">impl</span>&lt;<span class="hljs-symbol">'a</span>&gt; WhatAboutThis&lt;<span class="hljs-symbol">'a</span>&gt; {
    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">tie_the_knot</span>(&amp;<span class="hljs-symbol">'a</span> <span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) {
       <span class="hljs-keyword">self</span>.nickname = <span class="hljs-title function_ invoke__">Some</span>(&amp;<span class="hljs-keyword">self</span>.name[..<span class="hljs-number">4</span>]); 
    }
}

<span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() {
    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">tricky</span> = WhatAboutThis {
        name: <span class="hljs-string">"Annabelle"</span>.<span class="hljs-title function_ invoke__">to_string</span>(),
        nickname: <span class="hljs-literal">None</span>,
    };
    tricky.<span class="hljs-title function_ invoke__">tie_the_knot</span>();

    <span class="hljs-comment">// cannot borrow `tricky` as immutable because it is also borrowed as mutable</span>
    <span class="hljs-comment">// println!("{:?}", tricky);</span>
}
</code></pre>
<p>See also:</p>
<ul>
<li><a href="https://stackoverflow.com/q/31067031/155423">Cannot borrow as mutable more than once at a time in one code - but can in another very similar</a></li>
</ul>
<h3>What about <code>Pin</code>?</h3>
<p><a href="https://doc.rust-lang.org/std/pin/struct.Pin.html" rel="noreferrer"><code>Pin</code></a>, stabilized in Rust 1.33, has this <a href="https://doc.rust-lang.org/std/pin/index.html" rel="noreferrer">in the module documentation</a>:</p>
<blockquote>
<p>A prime example of such a scenario would be building self-referential structs, since moving an object with pointers to itself will invalidate them, which could cause undefined behavior.</p>
</blockquote>
<p>It's important to note that "self-referential" doesn't necessarily mean using <em>a reference</em>. Indeed, the <a href="https://doc.rust-lang.org/std/pin/index.html#example-self-referential-struct" rel="noreferrer">example of a self-referential struct</a> specifically says (emphasis mine):</p>
<blockquote>
<p>We cannot inform the compiler about that with a normal reference,
since this pattern cannot be described with the usual borrowing rules.
Instead <strong>we use a raw pointer</strong>, though one which is known to not be null,
since we know it's pointing at the string.</p>
</blockquote>
<p>The ability to use a raw pointer for this behavior has existed since Rust 1.0. Indeed, owning-ref and rental use raw pointers under the hood.</p>
<p>The only thing that <code>Pin</code> adds to the table is a common way to state that a given value is guaranteed to not move.</p>
<p>See also:</p>
<ul>
<li><a href="https://stackoverflow.com/q/49860149/155423">How to use the Pin struct with self-referential structures?</a></li>
</ul>
    </div></div></div></div><div id="solution2" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 2</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/rust">rust</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/lifetime">lifetime</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/borrow-checker">borrow-checker</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>A slightly different issue which causes very similar compiler messages is object lifetime dependency, rather than storing an explicit reference. An example of that is the <a href="http://alexcrichton.com/ssh2-rs/ssh2/" rel="noreferrer">ssh2</a> library. When developing something bigger than a test project, it is tempting to try to put the <code>Session</code> and <code>Channel</code> obtained from that session alongside each other into a struct, hiding the implementation details from the user. However, note that the <a href="http://alexcrichton.com/ssh2-rs/ssh2/struct.Channel.html" rel="noreferrer"><code>Channel</code></a> definition has the <code>'sess</code> lifetime in its type annotation, while <a href="http://alexcrichton.com/ssh2-rs/ssh2/struct.Session.html" rel="noreferrer"><code>Session</code></a> doesn't.</p>

<p>This causes similar compiler errors related to lifetimes.</p>

<p>One way to solve it in a very simple way is to declare the <code>Session</code> outside in the caller, and then for annotate the reference within the struct with a lifetime, similar to the answer in <a href="https://users.rust-lang.org/t/solved-first-issue-with-lifetimes/13243/16" rel="noreferrer">this Rust User's Forum post</a> talking about the same issue while encapsulating SFTP. This will not look elegant and may not always apply - because now you have two entities to deal with, rather than one that you wanted!</p>

<p>Turns out the <a href="https://crates.io/crates/rental" rel="noreferrer">rental crate</a> or the <a href="https://crates.io/crates/owning_ref" rel="noreferrer">owning_ref crate</a> from the other answer are the solutions for this issue too. Let's consider the owning_ref, which has the special object for this exact purpose:
<a href="http://kimundi.github.io/owning-ref-rs/owning_ref/struct.OwningHandle.html" rel="noreferrer"><code>OwningHandle</code></a>. To avoid the underlying object moving, we allocate it on the heap using a <code>Box</code>, which gives us the following possible solution:</p>

<pre class="lang-rust s-code-block"><code class="hljs language-rust"><span class="hljs-keyword">use</span> ssh2::{Channel, Error, Session};
<span class="hljs-keyword">use</span> std::net::TcpStream;

<span class="hljs-keyword">use</span> owning_ref::OwningHandle;

<span class="hljs-keyword">struct</span> <span class="hljs-title class_">DeviceSSHConnection</span> {
    tcp: TcpStream,
    channel: OwningHandle&lt;<span class="hljs-type">Box</span>&lt;Session&gt;, <span class="hljs-type">Box</span>&lt;Channel&lt;<span class="hljs-symbol">'static</span>&gt;&gt;&gt;,
}

<span class="hljs-keyword">impl</span> <span class="hljs-title class_">DeviceSSHConnection</span> {
    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">new</span>(targ: &amp;<span class="hljs-type">str</span>, c_user: &amp;<span class="hljs-type">str</span>, c_pass: &amp;<span class="hljs-type">str</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-keyword">Self</span> {
        <span class="hljs-keyword">use</span> std::net::TcpStream;
        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">session</span> = Session::<span class="hljs-title function_ invoke__">new</span>().<span class="hljs-title function_ invoke__">unwrap</span>();
        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">tcp</span> = TcpStream::<span class="hljs-title function_ invoke__">connect</span>(targ).<span class="hljs-title function_ invoke__">unwrap</span>();

        session.<span class="hljs-title function_ invoke__">handshake</span>(&amp;tcp).<span class="hljs-title function_ invoke__">unwrap</span>();
        session.<span class="hljs-title function_ invoke__">set_timeout</span>(<span class="hljs-number">5000</span>);
        session.<span class="hljs-title function_ invoke__">userauth_password</span>(c_user, c_pass).<span class="hljs-title function_ invoke__">unwrap</span>();

        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">sess</span> = Box::<span class="hljs-title function_ invoke__">new</span>(session);
        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">oref</span> = OwningHandle::<span class="hljs-title function_ invoke__">new_with_fn</span>(
            sess,
            <span class="hljs-keyword">unsafe</span> { |x| Box::<span class="hljs-title function_ invoke__">new</span>((*x).<span class="hljs-title function_ invoke__">channel_session</span>().<span class="hljs-title function_ invoke__">unwrap</span>()) },
        );

        oref.<span class="hljs-title function_ invoke__">shell</span>().<span class="hljs-title function_ invoke__">unwrap</span>();
        <span class="hljs-keyword">let</span> <span class="hljs-variable">ret</span> = DeviceSSHConnection {
            tcp: tcp,
            channel: oref,
        };
        ret
    }
}
</code></pre>

<p>The result of this code is that we can not use the <code>Session</code> anymore, but it is stored alongside with the <code>Channel</code> which we will be using. Because the <code>OwningHandle</code> object dereferences to <code>Box</code>, which dereferences to <code>Channel</code>, when storing it in a struct, we name it as such. <strong>NOTE:</strong> This is just my understanding. I have a suspicion this may not be correct, since it appears to be quite close to <a href="https://github.com/Kimundi/owning-ref-rs/issues/27" rel="noreferrer">discussion of <code>OwningHandle</code> unsafety</a>. </p>

<p>One curious detail here is that the <code>Session</code> logically has a similar relationship with <code>TcpStream</code> as <code>Channel</code> has to <code>Session</code>, yet its ownership is not taken and there are no type annotations around doing so. Instead, it is up to the user to take care of this, as the documentation of <a href="http://alexcrichton.com/ssh2-rs/ssh2/struct.Session.html#method.handshake" rel="noreferrer">handshake</a> method says:</p>

<blockquote>
  <p>This session does not take ownership of the socket provided, it is
  recommended to ensure that the socket persists the lifetime of this
  session to ensure that communication is correctly performed.</p>
  
  <p>It is also highly recommended that the stream provided is not used
  concurrently elsewhere for the duration of this session as it may
  interfere with the protocol.</p>
</blockquote>

<p>So with the <code>TcpStream</code> usage, is completely up to the programmer to ensure the correctness of the code. With the <code>OwningHandle</code>, the attention to where the "dangerous magic" happens is drawn using the <code>unsafe {}</code> block.</p>

<p>A further and a more high-level discussion of this issue is in this <a href="https://users.rust-lang.org/t/how-to-write-software-without-self-referential-structs/13819/11" rel="noreferrer">Rust User's Forum thread</a> - which includes a different example and its solution using the rental crate, which does not contain unsafe blocks.</p>
    </div></div></div></div><div id="solution3" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 3</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/rust">rust</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/lifetime">lifetime</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/borrow-checker">borrow-checker</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>I've found the <code>Arc</code> (read-only) or <code>Arc&lt;Mutex&gt;</code> (read-write with locking) patterns to be sometimes quite useful tradeoff between performance and code complexity (mostly caused by lifetime-annotation).</p>
<p>Arc:</p>
<pre class="lang-rust s-code-block"><code class="hljs language-rust"><span class="hljs-keyword">use</span> std::sync::Arc;

<span class="hljs-keyword">struct</span> <span class="hljs-title class_">Parent</span> {
    child: Arc&lt;Child&gt;,
}
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">Child</span> {
    value: <span class="hljs-type">u32</span>,
}
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">Combined</span>(Parent, Arc&lt;Child&gt;);

<span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() {
    <span class="hljs-keyword">let</span> <span class="hljs-variable">parent</span> = Parent { child: Arc::<span class="hljs-title function_ invoke__">new</span>(Child { value: <span class="hljs-number">42</span> }) };
    <span class="hljs-keyword">let</span> <span class="hljs-variable">child</span> = parent.child.<span class="hljs-title function_ invoke__">clone</span>();
    <span class="hljs-keyword">let</span> <span class="hljs-variable">combined</span> = <span class="hljs-title function_ invoke__">Combined</span>(parent, child.<span class="hljs-title function_ invoke__">clone</span>());

    <span class="hljs-built_in">assert_eq!</span>(combined.<span class="hljs-number">0</span>.child.value, <span class="hljs-number">42</span>);
    <span class="hljs-built_in">assert_eq!</span>(child.value, <span class="hljs-number">42</span>);
    <span class="hljs-comment">// combined.0.child.value = 50; // fails, Arc is not DerefMut</span>
}
</code></pre>
<p>Arc + Mutex:</p>
<pre class="lang-rust s-code-block"><code class="hljs language-rust"><span class="hljs-keyword">use</span> std::sync::{Arc, Mutex};

<span class="hljs-keyword">struct</span> <span class="hljs-title class_">Child</span> {
    value: <span class="hljs-type">u32</span>,
}
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">Parent</span> {
    child: Arc&lt;Mutex&lt;Child&gt;&gt;,
}
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">Combined</span>(Parent, Arc&lt;Mutex&lt;Child&gt;&gt;);

<span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() {
    <span class="hljs-keyword">let</span> <span class="hljs-variable">parent</span> = Parent { child: Arc::<span class="hljs-title function_ invoke__">new</span>(Mutex::<span class="hljs-title function_ invoke__">new</span>(Child {value: <span class="hljs-number">42</span> }))};
    <span class="hljs-keyword">let</span> <span class="hljs-variable">child</span> = parent.child.<span class="hljs-title function_ invoke__">clone</span>();
    <span class="hljs-keyword">let</span> <span class="hljs-variable">combined</span> = <span class="hljs-title function_ invoke__">Combined</span>(parent, child.<span class="hljs-title function_ invoke__">clone</span>());

    <span class="hljs-built_in">assert_eq!</span>(combined.<span class="hljs-number">0</span>.child.<span class="hljs-title function_ invoke__">lock</span>().<span class="hljs-title function_ invoke__">unwrap</span>().value, <span class="hljs-number">42</span>);
    <span class="hljs-built_in">assert_eq!</span>(child.<span class="hljs-title function_ invoke__">lock</span>().<span class="hljs-title function_ invoke__">unwrap</span>().value, <span class="hljs-number">42</span>);
    child.<span class="hljs-title function_ invoke__">lock</span>().<span class="hljs-title function_ invoke__">unwrap</span>().value = <span class="hljs-number">50</span>;
    <span class="hljs-built_in">assert_eq!</span>(combined.<span class="hljs-number">0</span>.child.<span class="hljs-title function_ invoke__">lock</span>().<span class="hljs-title function_ invoke__">unwrap</span>().value, <span class="hljs-number">50</span>);
}
</code></pre>
<p>See also <code>RwLock</code> (<a href="https://stackoverflow.com/questions/50704279/when-or-why-should-i-use-a-mutex-over-an-rwlock">When or why should I use a Mutex over an RwLock?</a>)</p>
    </div></div></div></div></div></div><div class="widget"><a href="/questions/android-permission-doesn&#x27;t-work-even-if-i-have-declared-it-1657387726990">Android permission doesn&#x27;t work even if I have declared it</a><a href="/questions/how-can-i-prevent-sql-injection-in-php-1657384220094">How can I prevent SQL injection in PHP?</a><a href="/questions/ways-to-circumvent-the-same-origin-policy-1657384763316">Ways to circumvent the same-origin policy</a><a href="/questions/how-do-i-clone-a-list-so-that-it-doesn&#x27;t-change-unexpectedly-after-assignment-1657384423195">How do I clone a list so that it doesn&#x27;t change unexpectedly after assignment?</a><a href="/questions/why-should-there-be-spaces-around-&#x27;&#x27;-and-&#x27;&#x27;-in-bash-1657387984122">Why should there be spaces around &#x27;[&#x27; and &#x27;]&#x27; in Bash?</a><a href="/questions/what-is-the-difference-between-single-quoted-and-double-quoted-strings-in-php-1657384624345">What is the difference between single-quoted and double-quoted strings in PHP?</a><a href="/questions/how-to-removedelete-a-large-file-from-commit-history-in-the-git-repository-1657387589093">How to remove/delete a large file from commit history in the Git repository?</a><a href="/questions/read-file-line-by-line-using-ifstream-in-c++-1657388236966">Read file line by line using ifstream in C++</a><a href="/questions/remove-duplicate-values-from-js-array-duplicate-1657387801931">Remove duplicate values from JS array [duplicate]</a><a href="/questions/servlet-returns-%22http-status-404-the-requested-resource-(servlet)-is-not-available%22-1657384850661">Servlet returns &quot;HTTP Status 404 The requested resource (/servlet) is not available&quot;</a><a href="/questions/how-to-find-the-&#x27;sizeof&#x27;-(a-pointer-pointing-to-an-array)-1657387354284">How to find the &#x27;sizeof&#x27; (a pointer pointing to an array)?</a><a href="/questions/is-it-safe-to-expose-firebase-apikey-to-the-public-1657388268111">Is it safe to expose Firebase apiKey to the public?</a><a href="/questions/what-is-__init__.py-for-1657388415243">What is __init__.py for?</a><a href="/questions/what-is-the-copy-and-swap-idiom-1657384840329">What is the copy-and-swap idiom?</a><a href="/questions/convert-columns-into-rows-with-pandas-1657388374964">Convert columns into rows with Pandas</a><a href="/questions/how-can-i-deserialize-json-with-c-1657388102941">How can I deserialize JSON with C#?</a><a href="/questions/how-to-reshape-data-from-long-to-wide-format-1657384486421">How to reshape data from long to wide format</a><a href="/questions/maintain-the-aspect-ratio-of-a-div-with-css-1657387513615">Maintain the aspect ratio of a div with CSS</a><a href="/questions/creating-multiline-strings-in-javascript-1657388025414">Creating multiline strings in JavaScript</a><a href="/questions/how-to-use-java.net.urlconnection-to-fire-and-handle-http-requests-1657387245934">How to use java.net.URLConnection to fire and handle HTTP requests</a></div></div><span class="cursor-pointer text-lg p-2" style="position:fixed;bottom:20px;left:20px;background:#000;z-index:2000;color:white">Go go top</span></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"data":{"answer":["\n\u0026lt;p\u0026gt;Let\u0026apos;s look at \u0026lt;a href=\u0026quot;https://play.rust-lang.org/?version=stable\u0026amp;amp;mode=debug\u0026amp;amp;edition=2018\u0026amp;amp;gist=c1432ed38048684c7eb306540c182cd0\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;a simple implementation of this\u0026lt;/a\u0026gt;:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-rust s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-rust\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Parent\u0026lt;/span\u0026gt; {\n    count: \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;u32\u0026lt;/span\u0026gt;,\n}\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Child\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-symbol\u0026quot;\u0026gt;\u0026apos;a\u0026lt;/span\u0026gt;\u0026amp;gt; {\n    parent: \u0026amp;amp;\u0026lt;span class=\u0026quot;hljs-symbol\u0026quot;\u0026gt;\u0026apos;a\u0026lt;/span\u0026gt; Parent,\n}\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Combined\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-symbol\u0026quot;\u0026gt;\u0026apos;a\u0026lt;/span\u0026gt;\u0026amp;gt; {\n    parent: Parent,\n    child: Child\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-symbol\u0026quot;\u0026gt;\u0026apos;a\u0026lt;/span\u0026gt;\u0026amp;gt;,\n}\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;impl\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-symbol\u0026quot;\u0026gt;\u0026apos;a\u0026lt;/span\u0026gt;\u0026amp;gt; Combined\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-symbol\u0026quot;\u0026gt;\u0026apos;a\u0026lt;/span\u0026gt;\u0026amp;gt; {\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;fn\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt;() \u0026lt;span class=\u0026quot;hljs-punctuation\u0026quot;\u0026gt;-\u0026amp;gt;\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;Self\u0026lt;/span\u0026gt; {\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;let\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;parent\u0026lt;/span\u0026gt; = Parent { count: \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;42\u0026lt;/span\u0026gt; };\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;let\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;child\u0026lt;/span\u0026gt; = Child { parent: \u0026amp;amp;parent };\n\n        Combined { parent, child }\n    }\n}\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;fn\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;main\u0026lt;/span\u0026gt;() {}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;This will fail with the error:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-none s-code-block\u0026quot;\u0026gt;\u0026lt;code\u0026gt;error[E0515]: cannot return value referencing local variable `parent`\n  --\u0026amp;gt; src/main.rs:19:9\n   |\n17 |         let child = Child { parent: \u0026amp;amp;parent };\n   |                                     ------- `parent` is borrowed here\n18 | \n19 |         Combined { parent, child }\n   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^ returns a value referencing data owned by the current function\n\nerror[E0505]: cannot move out of `parent` because it is borrowed\n  --\u0026amp;gt; src/main.rs:19:20\n   |\n14 | impl\u0026amp;lt;\u0026apos;a\u0026amp;gt; Combined\u0026amp;lt;\u0026apos;a\u0026amp;gt; {\n   |      -- lifetime `\u0026apos;a` defined here\n...\n17 |         let child = Child { parent: \u0026amp;amp;parent };\n   |                                     ------- borrow of `parent` occurs here\n18 | \n19 |         Combined { parent, child }\n   |         -----------^^^^^^---------\n   |         |          |\n   |         |          move out of `parent` occurs here\n   |         returning this value requires that `parent` is borrowed for `\u0026apos;a`\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;To completely understand this error, you have to think about how the\nvalues are represented in memory and what happens when you \u0026lt;em\u0026gt;move\u0026lt;/em\u0026gt;\nthose values. Let\u0026apos;s annotate \u0026lt;code\u0026gt;Combined::new\u0026lt;/code\u0026gt; with some hypothetical\nmemory addresses that show where values are located:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-rust s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-rust\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;let\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;parent\u0026lt;/span\u0026gt; = Parent { count: \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;42\u0026lt;/span\u0026gt; };\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// `parent` lives at address 0x1000 and takes up 4 bytes\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// The value of `parent` is 42 \u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;let\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;child\u0026lt;/span\u0026gt; = Child { parent: \u0026amp;amp;parent };\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// `child` lives at address 0x1010 and takes up 4 bytes\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// The value of `child` is 0x1000\u0026lt;/span\u0026gt;\n         \nCombined { parent, child }\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// The return value lives at address 0x2000 and takes up 8 bytes\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// `parent` is moved to 0x2000\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// `child` is ... ?\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;What should happen to \u0026lt;code\u0026gt;child\u0026lt;/code\u0026gt;? If the value was just moved like \u0026lt;code\u0026gt;parent\u0026lt;/code\u0026gt;\nwas, then it would refer to memory that no longer is guaranteed to\nhave a valid value in it. Any other piece of code is allowed to store\nvalues at memory address 0x1000. Accessing that memory assuming it was\nan integer could lead to crashes and/or security bugs, and is one of\nthe main categories of errors that Rust prevents.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;This is exactly the problem that \u0026lt;em\u0026gt;lifetimes\u0026lt;/em\u0026gt; prevent. A lifetime is a\nbit of metadata that allows you and the compiler to know how long a\nvalue will be valid at its \u0026lt;strong\u0026gt;current memory location\u0026lt;/strong\u0026gt;. That\u0026apos;s an\nimportant distinction, as it\u0026apos;s a common mistake Rust newcomers make.\nRust lifetimes are \u0026lt;em\u0026gt;not\u0026lt;/em\u0026gt; the time period between when an object is\ncreated and when it is destroyed!\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;As an analogy, think of it this way: During a person\u0026apos;s life, they will\nreside in many different locations, each with a distinct address. A\nRust lifetime is concerned with the address you \u0026lt;em\u0026gt;currently reside at\u0026lt;/em\u0026gt;,\nnot about whenever you will die in the future (although dying also\nchanges your address). Every time you move it\u0026apos;s relevant because your\naddress is no longer valid.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;It\u0026apos;s also important to note that lifetimes \u0026lt;em\u0026gt;do not\u0026lt;/em\u0026gt; change your code; your\ncode controls the lifetimes, your lifetimes don\u0026apos;t control the code. The\npithy saying is \u0026quot;lifetimes are descriptive, not prescriptive\u0026quot;.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Let\u0026apos;s annotate \u0026lt;code\u0026gt;Combined::new\u0026lt;/code\u0026gt; with some line numbers which we will use\nto highlight lifetimes:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-rust s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-rust\u0026quot;\u0026gt;{                                          \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// 0\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;let\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;parent\u0026lt;/span\u0026gt; = Parent { count: \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;42\u0026lt;/span\u0026gt; };     \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// 1\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;let\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;child\u0026lt;/span\u0026gt; = Child { parent: \u0026amp;amp;parent }; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// 2\u0026lt;/span\u0026gt;\n                                           \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// 3\u0026lt;/span\u0026gt;\n    Combined { parent, child }             \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// 4\u0026lt;/span\u0026gt;\n}                                          \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// 5\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;The \u0026lt;em\u0026gt;concrete lifetime\u0026lt;/em\u0026gt; of \u0026lt;code\u0026gt;parent\u0026lt;/code\u0026gt; is from 1 to 4, inclusive (which I\u0026apos;ll\nrepresent as \u0026lt;code\u0026gt;[1,4]\u0026lt;/code\u0026gt;). The concrete lifetime of \u0026lt;code\u0026gt;child\u0026lt;/code\u0026gt; is \u0026lt;code\u0026gt;[2,4]\u0026lt;/code\u0026gt;, and\nthe concrete lifetime of the return value is \u0026lt;code\u0026gt;[4,5]\u0026lt;/code\u0026gt;. It\u0026apos;s\npossible to have concrete lifetimes that start at zero - that would\nrepresent the lifetime of a parameter to a function or something that\nexisted outside of the block.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Note that the lifetime of \u0026lt;code\u0026gt;child\u0026lt;/code\u0026gt; itself is \u0026lt;code\u0026gt;[2,4]\u0026lt;/code\u0026gt;, but that it \u0026lt;strong\u0026gt;refers\nto\u0026lt;/strong\u0026gt; a value with a lifetime of \u0026lt;code\u0026gt;[1,4]\u0026lt;/code\u0026gt;. This is fine as long as the\nreferring value becomes invalid before the referred-to value does. The\nproblem occurs when we try to return \u0026lt;code\u0026gt;child\u0026lt;/code\u0026gt; from the block. This would\n\u0026quot;over-extend\u0026quot; the lifetime beyond its natural length.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;This new knowledge should explain the first two examples. The third\none requires looking at the implementation of \u0026lt;code\u0026gt;Parent::child\u0026lt;/code\u0026gt;. Chances\nare, it will look something like this:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-rust s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-rust\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;impl\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Parent\u0026lt;/span\u0026gt; {\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;fn\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;child\u0026lt;/span\u0026gt;(\u0026amp;amp;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;self\u0026lt;/span\u0026gt;) \u0026lt;span class=\u0026quot;hljs-punctuation\u0026quot;\u0026gt;-\u0026amp;gt;\u0026lt;/span\u0026gt; Child { \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;/* ... */\u0026lt;/span\u0026gt; }\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;This uses \u0026lt;em\u0026gt;lifetime elision\u0026lt;/em\u0026gt; to avoid writing explicit \u0026lt;em\u0026gt;generic\nlifetime parameters\u0026lt;/em\u0026gt;. It is equivalent to:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-rust s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-rust\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;impl\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Parent\u0026lt;/span\u0026gt; {\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;fn\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;child\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-symbol\u0026quot;\u0026gt;\u0026apos;a\u0026lt;/span\u0026gt;\u0026amp;gt;(\u0026amp;amp;\u0026lt;span class=\u0026quot;hljs-symbol\u0026quot;\u0026gt;\u0026apos;a\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;self\u0026lt;/span\u0026gt;) \u0026lt;span class=\u0026quot;hljs-punctuation\u0026quot;\u0026gt;-\u0026amp;gt;\u0026lt;/span\u0026gt; Child\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-symbol\u0026quot;\u0026gt;\u0026apos;a\u0026lt;/span\u0026gt;\u0026amp;gt; { \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;/* ... */\u0026lt;/span\u0026gt; }\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;In both cases, the method says that a \u0026lt;code\u0026gt;Child\u0026lt;/code\u0026gt; structure will be\nreturned that has been parameterized with the concrete lifetime of\n\u0026lt;code\u0026gt;self\u0026lt;/code\u0026gt;. Said another way, the \u0026lt;code\u0026gt;Child\u0026lt;/code\u0026gt; instance contains a reference\nto the \u0026lt;code\u0026gt;Parent\u0026lt;/code\u0026gt; that created it, and thus cannot live longer than that\n\u0026lt;code\u0026gt;Parent\u0026lt;/code\u0026gt; instance.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;This also lets us recognize that something is really wrong with our\ncreation function:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-rust s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-rust\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;fn\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;make_combined\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-symbol\u0026quot;\u0026gt;\u0026apos;a\u0026lt;/span\u0026gt;\u0026amp;gt;() \u0026lt;span class=\u0026quot;hljs-punctuation\u0026quot;\u0026gt;-\u0026amp;gt;\u0026lt;/span\u0026gt; Combined\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-symbol\u0026quot;\u0026gt;\u0026apos;a\u0026lt;/span\u0026gt;\u0026amp;gt; { \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;/* ... */\u0026lt;/span\u0026gt; }\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;Although you are more likely to see this written in a different form:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-rust s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-rust\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;impl\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-symbol\u0026quot;\u0026gt;\u0026apos;a\u0026lt;/span\u0026gt;\u0026amp;gt; Combined\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-symbol\u0026quot;\u0026gt;\u0026apos;a\u0026lt;/span\u0026gt;\u0026amp;gt; {\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;fn\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt;() \u0026lt;span class=\u0026quot;hljs-punctuation\u0026quot;\u0026gt;-\u0026amp;gt;\u0026lt;/span\u0026gt; Combined\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-symbol\u0026quot;\u0026gt;\u0026apos;a\u0026lt;/span\u0026gt;\u0026amp;gt; { \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;/* ... */\u0026lt;/span\u0026gt; }\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;In both cases, there is no lifetime parameter being provided via an\nargument. This means that the lifetime that \u0026lt;code\u0026gt;Combined\u0026lt;/code\u0026gt; will be\nparameterized with isn\u0026apos;t constrained by anything - it can be whatever\nthe caller wants it to be. This is nonsensical, because the caller\ncould specify the \u0026lt;code\u0026gt;\u0026apos;static\u0026lt;/code\u0026gt; lifetime and there\u0026apos;s no way to meet that\ncondition.\u0026lt;/p\u0026gt;\n\u0026lt;h3\u0026gt;How do I fix it?\u0026lt;/h3\u0026gt;\n\u0026lt;p\u0026gt;The easiest and most recommended solution is to not attempt to put\nthese items in the same structure together. By doing this, your\nstructure nesting will mimic the lifetimes of your code. Place types\nthat own data into a structure together and then provide methods that\nallow you to get references or objects containing references as needed.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;There is a special case where the lifetime tracking is overzealous:\nwhen you have something placed on the heap. This occurs when you use a\n\u0026lt;code\u0026gt;Box\u0026amp;lt;T\u0026amp;gt;\u0026lt;/code\u0026gt;, for example. In this case, the structure that is moved\ncontains a pointer into the heap. The pointed-at value will remain\nstable, but the address of the pointer itself will move. In practice,\nthis doesn\u0026apos;t matter, as you always follow the pointer.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Some crates provide ways of representing this case, but they\nrequire that the base address \u0026lt;em\u0026gt;never move\u0026lt;/em\u0026gt;. This rules out mutating\nvectors, which may cause a reallocation and a move of the\nheap-allocated values.\u0026lt;/p\u0026gt;\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;a href=\u0026quot;https://crates.io/crates/rental\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;rental\u0026lt;/a\u0026gt; (no longer maintained or suppported)\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;a href=\u0026quot;https://crates.io/crates/owning_ref\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;owning_ref\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;a href=\u0026quot;https://crates.io/crates/ouroboros\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;ouroboros\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;p\u0026gt;Examples of problems solved with Rental:\u0026lt;/p\u0026gt;\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;a href=\u0026quot;https://stackoverflow.com/q/47193584/155423\u0026quot;\u0026gt;Is there an owned version of String::chars?\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;a href=\u0026quot;https://stackoverflow.com/q/50496879/155423\u0026quot;\u0026gt;Returning a RWLockReadGuard independently from a method\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;a href=\u0026quot;https://stackoverflow.com/q/51664098/155423\u0026quot;\u0026gt;How can I return an iterator over a locked struct member in Rust?\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;a href=\u0026quot;https://stackoverflow.com/q/40095383/155423\u0026quot;\u0026gt;How to return a reference to a sub-value of a value that is under a mutex?\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;a href=\u0026quot;https://stackoverflow.com/q/43702185/155423\u0026quot;\u0026gt;How do I store a result using Serde Zero-copy deserialization of a Futures-enabled Hyper Chunk?\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;a href=\u0026quot;https://stackoverflow.com/q/49300618/155423\u0026quot;\u0026gt;How to store a reference without having to deal with lifetimes?\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;p\u0026gt;In other cases, you may wish to move to some type of reference-counting, such as by using \u0026lt;a href=\u0026quot;https://doc.rust-lang.org/std/rc/struct.Rc.html\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;\u0026lt;code\u0026gt;Rc\u0026lt;/code\u0026gt;\u0026lt;/a\u0026gt; or \u0026lt;a href=\u0026quot;https://doc.rust-lang.org/std/sync/struct.Arc.html\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;\u0026lt;code\u0026gt;Arc\u0026lt;/code\u0026gt;\u0026lt;/a\u0026gt;.\u0026lt;/p\u0026gt;\n\u0026lt;h3\u0026gt;More information\u0026lt;/h3\u0026gt;\n\u0026lt;blockquote\u0026gt;\n\u0026lt;p\u0026gt;After moving \u0026lt;code\u0026gt;parent\u0026lt;/code\u0026gt; into the struct, why is the compiler not able to get a new reference to \u0026lt;code\u0026gt;parent\u0026lt;/code\u0026gt; and assign it to \u0026lt;code\u0026gt;child\u0026lt;/code\u0026gt; in the struct?\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\u0026lt;p\u0026gt;While it is theoretically possible to do this, doing so would introduce a large amount of complexity and overhead. Every time that the object is moved, the compiler would need to insert code to \u0026quot;fix up\u0026quot; the reference. This would mean that copying a struct is no longer a very cheap operation that just moves some bits around. It could even mean that code like this is expensive, depending on how good a hypothetical optimizer would be:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-rust s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-rust\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;let\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;a\u0026lt;/span\u0026gt; = Object::\u0026lt;span class=\u0026quot;hljs-title function_ invoke__\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt;();\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;let\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;b\u0026lt;/span\u0026gt; = a;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;let\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;c\u0026lt;/span\u0026gt; = b;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;Instead of forcing this to happen for \u0026lt;em\u0026gt;every\u0026lt;/em\u0026gt; move, the programmer gets to \u0026lt;em\u0026gt;choose\u0026lt;/em\u0026gt; when this will happen by creating methods that will take the appropriate references only when you call them.\u0026lt;/p\u0026gt;\n\u0026lt;h3\u0026gt;A type with a reference to itself\u0026lt;/h3\u0026gt;\n\u0026lt;p\u0026gt;There\u0026apos;s one specific case where you \u0026lt;em\u0026gt;can\u0026lt;/em\u0026gt; create a type with a reference to itself. You need to use something like \u0026lt;code\u0026gt;Option\u0026lt;/code\u0026gt; to make it in two steps though:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-rust s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-rust\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#[derive(Debug)]\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;WhatAboutThis\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-symbol\u0026quot;\u0026gt;\u0026apos;a\u0026lt;/span\u0026gt;\u0026amp;gt; {\n    name: \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;String\u0026lt;/span\u0026gt;,\n    nickname: \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;Option\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026amp;amp;\u0026lt;span class=\u0026quot;hljs-symbol\u0026quot;\u0026gt;\u0026apos;a\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;str\u0026lt;/span\u0026gt;\u0026amp;gt;,\n}\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;fn\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;main\u0026lt;/span\u0026gt;() {\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;let\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;mut \u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;tricky\u0026lt;/span\u0026gt; = WhatAboutThis {\n        name: \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Annabelle\u0026quot;\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-title function_ invoke__\u0026quot;\u0026gt;to_string\u0026lt;/span\u0026gt;(),\n        nickname: \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;None\u0026lt;/span\u0026gt;,\n    };\n    tricky.nickname = \u0026lt;span class=\u0026quot;hljs-title function_ invoke__\u0026quot;\u0026gt;Some\u0026lt;/span\u0026gt;(\u0026amp;amp;tricky.name[..\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;4\u0026lt;/span\u0026gt;]);\n\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;println!\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;{:?}\u0026quot;\u0026lt;/span\u0026gt;, tricky);\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;This does work, in some sense, but the created value is highly restricted - it can \u0026lt;em\u0026gt;never\u0026lt;/em\u0026gt; be moved. Notably, this means it cannot be returned from a function or passed by-value to anything. A constructor function shows the same problem with the lifetimes as above:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-rust s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-rust\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;fn\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;creator\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-symbol\u0026quot;\u0026gt;\u0026apos;a\u0026lt;/span\u0026gt;\u0026amp;gt;() \u0026lt;span class=\u0026quot;hljs-punctuation\u0026quot;\u0026gt;-\u0026amp;gt;\u0026lt;/span\u0026gt; WhatAboutThis\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-symbol\u0026quot;\u0026gt;\u0026apos;a\u0026lt;/span\u0026gt;\u0026amp;gt; { \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;/* ... */\u0026lt;/span\u0026gt; }\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;If you try to do this same code with a method, you\u0026apos;ll need the alluring but ultimately useless \u0026lt;code\u0026gt;\u0026amp;amp;\u0026apos;a self\u0026lt;/code\u0026gt;. When that\u0026apos;s involved, this code is even more restricted and you will get borrow-checker errors after the first method call:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-rust s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-rust\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#[derive(Debug)]\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;WhatAboutThis\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-symbol\u0026quot;\u0026gt;\u0026apos;a\u0026lt;/span\u0026gt;\u0026amp;gt; {\n    name: \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;String\u0026lt;/span\u0026gt;,\n    nickname: \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;Option\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026amp;amp;\u0026lt;span class=\u0026quot;hljs-symbol\u0026quot;\u0026gt;\u0026apos;a\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;str\u0026lt;/span\u0026gt;\u0026amp;gt;,\n}\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;impl\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-symbol\u0026quot;\u0026gt;\u0026apos;a\u0026lt;/span\u0026gt;\u0026amp;gt; WhatAboutThis\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-symbol\u0026quot;\u0026gt;\u0026apos;a\u0026lt;/span\u0026gt;\u0026amp;gt; {\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;fn\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;tie_the_knot\u0026lt;/span\u0026gt;(\u0026amp;amp;\u0026lt;span class=\u0026quot;hljs-symbol\u0026quot;\u0026gt;\u0026apos;a\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;mut\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;self\u0026lt;/span\u0026gt;) {\n       \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;self\u0026lt;/span\u0026gt;.nickname = \u0026lt;span class=\u0026quot;hljs-title function_ invoke__\u0026quot;\u0026gt;Some\u0026lt;/span\u0026gt;(\u0026amp;amp;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;self\u0026lt;/span\u0026gt;.name[..\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;4\u0026lt;/span\u0026gt;]); \n    }\n}\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;fn\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;main\u0026lt;/span\u0026gt;() {\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;let\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;mut \u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;tricky\u0026lt;/span\u0026gt; = WhatAboutThis {\n        name: \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Annabelle\u0026quot;\u0026lt;/span\u0026gt;.\u0026lt;span class=\u0026quot;hljs-title function_ invoke__\u0026quot;\u0026gt;to_string\u0026lt;/span\u0026gt;(),\n        nickname: \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;None\u0026lt;/span\u0026gt;,\n    };\n    tricky.\u0026lt;span class=\u0026quot;hljs-title function_ invoke__\u0026quot;\u0026gt;tie_the_knot\u0026lt;/span\u0026gt;();\n\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// cannot borrow `tricky` as immutable because it is also borrowed as mutable\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// println!(\u0026quot;{:?}\u0026quot;, tricky);\u0026lt;/span\u0026gt;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;See also:\u0026lt;/p\u0026gt;\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;a href=\u0026quot;https://stackoverflow.com/q/31067031/155423\u0026quot;\u0026gt;Cannot borrow as mutable more than once at a time in one code - but can in another very similar\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;h3\u0026gt;What about \u0026lt;code\u0026gt;Pin\u0026lt;/code\u0026gt;?\u0026lt;/h3\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;a href=\u0026quot;https://doc.rust-lang.org/std/pin/struct.Pin.html\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;\u0026lt;code\u0026gt;Pin\u0026lt;/code\u0026gt;\u0026lt;/a\u0026gt;, stabilized in Rust 1.33, has this \u0026lt;a href=\u0026quot;https://doc.rust-lang.org/std/pin/index.html\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;in the module documentation\u0026lt;/a\u0026gt;:\u0026lt;/p\u0026gt;\n\u0026lt;blockquote\u0026gt;\n\u0026lt;p\u0026gt;A prime example of such a scenario would be building self-referential structs, since moving an object with pointers to itself will invalidate them, which could cause undefined behavior.\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\u0026lt;p\u0026gt;It\u0026apos;s important to note that \u0026quot;self-referential\u0026quot; doesn\u0026apos;t necessarily mean using \u0026lt;em\u0026gt;a reference\u0026lt;/em\u0026gt;. Indeed, the \u0026lt;a href=\u0026quot;https://doc.rust-lang.org/std/pin/index.html#example-self-referential-struct\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;example of a self-referential struct\u0026lt;/a\u0026gt; specifically says (emphasis mine):\u0026lt;/p\u0026gt;\n\u0026lt;blockquote\u0026gt;\n\u0026lt;p\u0026gt;We cannot inform the compiler about that with a normal reference,\nsince this pattern cannot be described with the usual borrowing rules.\nInstead \u0026lt;strong\u0026gt;we use a raw pointer\u0026lt;/strong\u0026gt;, though one which is known to not be null,\nsince we know it\u0026apos;s pointing at the string.\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\u0026lt;p\u0026gt;The ability to use a raw pointer for this behavior has existed since Rust 1.0. Indeed, owning-ref and rental use raw pointers under the hood.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;The only thing that \u0026lt;code\u0026gt;Pin\u0026lt;/code\u0026gt; adds to the table is a common way to state that a given value is guaranteed to not move.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;See also:\u0026lt;/p\u0026gt;\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;a href=\u0026quot;https://stackoverflow.com/q/49860149/155423\u0026quot;\u0026gt;How to use the Pin struct with self-referential structures?\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n    ","\n\u0026lt;p\u0026gt;A slightly different issue which causes very similar compiler messages is object lifetime dependency, rather than storing an explicit reference. An example of that is the \u0026lt;a href=\u0026quot;http://alexcrichton.com/ssh2-rs/ssh2/\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;ssh2\u0026lt;/a\u0026gt; library. When developing something bigger than a test project, it is tempting to try to put the \u0026lt;code\u0026gt;Session\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;Channel\u0026lt;/code\u0026gt; obtained from that session alongside each other into a struct, hiding the implementation details from the user. However, note that the \u0026lt;a href=\u0026quot;http://alexcrichton.com/ssh2-rs/ssh2/struct.Channel.html\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;\u0026lt;code\u0026gt;Channel\u0026lt;/code\u0026gt;\u0026lt;/a\u0026gt; definition has the \u0026lt;code\u0026gt;\u0026apos;sess\u0026lt;/code\u0026gt; lifetime in its type annotation, while \u0026lt;a href=\u0026quot;http://alexcrichton.com/ssh2-rs/ssh2/struct.Session.html\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;\u0026lt;code\u0026gt;Session\u0026lt;/code\u0026gt;\u0026lt;/a\u0026gt; doesn\u0026apos;t.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;This causes similar compiler errors related to lifetimes.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;One way to solve it in a very simple way is to declare the \u0026lt;code\u0026gt;Session\u0026lt;/code\u0026gt; outside in the caller, and then for annotate the reference within the struct with a lifetime, similar to the answer in \u0026lt;a href=\u0026quot;https://users.rust-lang.org/t/solved-first-issue-with-lifetimes/13243/16\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;this Rust User\u0026apos;s Forum post\u0026lt;/a\u0026gt; talking about the same issue while encapsulating SFTP. This will not look elegant and may not always apply - because now you have two entities to deal with, rather than one that you wanted!\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Turns out the \u0026lt;a href=\u0026quot;https://crates.io/crates/rental\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;rental crate\u0026lt;/a\u0026gt; or the \u0026lt;a href=\u0026quot;https://crates.io/crates/owning_ref\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;owning_ref crate\u0026lt;/a\u0026gt; from the other answer are the solutions for this issue too. Let\u0026apos;s consider the owning_ref, which has the special object for this exact purpose:\n\u0026lt;a href=\u0026quot;http://kimundi.github.io/owning-ref-rs/owning_ref/struct.OwningHandle.html\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;\u0026lt;code\u0026gt;OwningHandle\u0026lt;/code\u0026gt;\u0026lt;/a\u0026gt;. To avoid the underlying object moving, we allocate it on the heap using a \u0026lt;code\u0026gt;Box\u0026lt;/code\u0026gt;, which gives us the following possible solution:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-rust s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-rust\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;use\u0026lt;/span\u0026gt; ssh2::{Channel, Error, Session};\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;use\u0026lt;/span\u0026gt; std::net::TcpStream;\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;use\u0026lt;/span\u0026gt; owning_ref::OwningHandle;\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;DeviceSSHConnection\u0026lt;/span\u0026gt; {\n    tcp: TcpStream,\n    channel: OwningHandle\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;Box\u0026lt;/span\u0026gt;\u0026amp;lt;Session\u0026amp;gt;, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;Box\u0026lt;/span\u0026gt;\u0026amp;lt;Channel\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-symbol\u0026quot;\u0026gt;\u0026apos;static\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026amp;gt;,\n}\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;impl\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;DeviceSSHConnection\u0026lt;/span\u0026gt; {\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;fn\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt;(targ: \u0026amp;amp;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;str\u0026lt;/span\u0026gt;, c_user: \u0026amp;amp;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;str\u0026lt;/span\u0026gt;, c_pass: \u0026amp;amp;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;str\u0026lt;/span\u0026gt;) \u0026lt;span class=\u0026quot;hljs-punctuation\u0026quot;\u0026gt;-\u0026amp;gt;\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;Self\u0026lt;/span\u0026gt; {\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;use\u0026lt;/span\u0026gt; std::net::TcpStream;\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;let\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;mut \u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;session\u0026lt;/span\u0026gt; = Session::\u0026lt;span class=\u0026quot;hljs-title function_ invoke__\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt;().\u0026lt;span class=\u0026quot;hljs-title function_ invoke__\u0026quot;\u0026gt;unwrap\u0026lt;/span\u0026gt;();\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;let\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;mut \u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;tcp\u0026lt;/span\u0026gt; = TcpStream::\u0026lt;span class=\u0026quot;hljs-title function_ invoke__\u0026quot;\u0026gt;connect\u0026lt;/span\u0026gt;(targ).\u0026lt;span class=\u0026quot;hljs-title function_ invoke__\u0026quot;\u0026gt;unwrap\u0026lt;/span\u0026gt;();\n\n        session.\u0026lt;span class=\u0026quot;hljs-title function_ invoke__\u0026quot;\u0026gt;handshake\u0026lt;/span\u0026gt;(\u0026amp;amp;tcp).\u0026lt;span class=\u0026quot;hljs-title function_ invoke__\u0026quot;\u0026gt;unwrap\u0026lt;/span\u0026gt;();\n        session.\u0026lt;span class=\u0026quot;hljs-title function_ invoke__\u0026quot;\u0026gt;set_timeout\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;5000\u0026lt;/span\u0026gt;);\n        session.\u0026lt;span class=\u0026quot;hljs-title function_ invoke__\u0026quot;\u0026gt;userauth_password\u0026lt;/span\u0026gt;(c_user, c_pass).\u0026lt;span class=\u0026quot;hljs-title function_ invoke__\u0026quot;\u0026gt;unwrap\u0026lt;/span\u0026gt;();\n\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;let\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;mut \u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;sess\u0026lt;/span\u0026gt; = Box::\u0026lt;span class=\u0026quot;hljs-title function_ invoke__\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt;(session);\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;let\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;mut \u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;oref\u0026lt;/span\u0026gt; = OwningHandle::\u0026lt;span class=\u0026quot;hljs-title function_ invoke__\u0026quot;\u0026gt;new_with_fn\u0026lt;/span\u0026gt;(\n            sess,\n            \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;unsafe\u0026lt;/span\u0026gt; { |x| Box::\u0026lt;span class=\u0026quot;hljs-title function_ invoke__\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt;((*x).\u0026lt;span class=\u0026quot;hljs-title function_ invoke__\u0026quot;\u0026gt;channel_session\u0026lt;/span\u0026gt;().\u0026lt;span class=\u0026quot;hljs-title function_ invoke__\u0026quot;\u0026gt;unwrap\u0026lt;/span\u0026gt;()) },\n        );\n\n        oref.\u0026lt;span class=\u0026quot;hljs-title function_ invoke__\u0026quot;\u0026gt;shell\u0026lt;/span\u0026gt;().\u0026lt;span class=\u0026quot;hljs-title function_ invoke__\u0026quot;\u0026gt;unwrap\u0026lt;/span\u0026gt;();\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;let\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;ret\u0026lt;/span\u0026gt; = DeviceSSHConnection {\n            tcp: tcp,\n            channel: oref,\n        };\n        ret\n    }\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;The result of this code is that we can not use the \u0026lt;code\u0026gt;Session\u0026lt;/code\u0026gt; anymore, but it is stored alongside with the \u0026lt;code\u0026gt;Channel\u0026lt;/code\u0026gt; which we will be using. Because the \u0026lt;code\u0026gt;OwningHandle\u0026lt;/code\u0026gt; object dereferences to \u0026lt;code\u0026gt;Box\u0026lt;/code\u0026gt;, which dereferences to \u0026lt;code\u0026gt;Channel\u0026lt;/code\u0026gt;, when storing it in a struct, we name it as such. \u0026lt;strong\u0026gt;NOTE:\u0026lt;/strong\u0026gt; This is just my understanding. I have a suspicion this may not be correct, since it appears to be quite close to \u0026lt;a href=\u0026quot;https://github.com/Kimundi/owning-ref-rs/issues/27\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;discussion of \u0026lt;code\u0026gt;OwningHandle\u0026lt;/code\u0026gt; unsafety\u0026lt;/a\u0026gt;. \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;One curious detail here is that the \u0026lt;code\u0026gt;Session\u0026lt;/code\u0026gt; logically has a similar relationship with \u0026lt;code\u0026gt;TcpStream\u0026lt;/code\u0026gt; as \u0026lt;code\u0026gt;Channel\u0026lt;/code\u0026gt; has to \u0026lt;code\u0026gt;Session\u0026lt;/code\u0026gt;, yet its ownership is not taken and there are no type annotations around doing so. Instead, it is up to the user to take care of this, as the documentation of \u0026lt;a href=\u0026quot;http://alexcrichton.com/ssh2-rs/ssh2/struct.Session.html#method.handshake\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;handshake\u0026lt;/a\u0026gt; method says:\u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;This session does not take ownership of the socket provided, it is\n  recommended to ensure that the socket persists the lifetime of this\n  session to ensure that communication is correctly performed.\u0026lt;/p\u0026gt;\n  \n  \u0026lt;p\u0026gt;It is also highly recommended that the stream provided is not used\n  concurrently elsewhere for the duration of this session as it may\n  interfere with the protocol.\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;p\u0026gt;So with the \u0026lt;code\u0026gt;TcpStream\u0026lt;/code\u0026gt; usage, is completely up to the programmer to ensure the correctness of the code. With the \u0026lt;code\u0026gt;OwningHandle\u0026lt;/code\u0026gt;, the attention to where the \u0026quot;dangerous magic\u0026quot; happens is drawn using the \u0026lt;code\u0026gt;unsafe {}\u0026lt;/code\u0026gt; block.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;A further and a more high-level discussion of this issue is in this \u0026lt;a href=\u0026quot;https://users.rust-lang.org/t/how-to-write-software-without-self-referential-structs/13819/11\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;Rust User\u0026apos;s Forum thread\u0026lt;/a\u0026gt; - which includes a different example and its solution using the rental crate, which does not contain unsafe blocks.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;I\u0026apos;ve found the \u0026lt;code\u0026gt;Arc\u0026lt;/code\u0026gt; (read-only) or \u0026lt;code\u0026gt;Arc\u0026amp;lt;Mutex\u0026amp;gt;\u0026lt;/code\u0026gt; (read-write with locking) patterns to be sometimes quite useful tradeoff between performance and code complexity (mostly caused by lifetime-annotation).\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Arc:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-rust s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-rust\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;use\u0026lt;/span\u0026gt; std::sync::Arc;\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Parent\u0026lt;/span\u0026gt; {\n    child: Arc\u0026amp;lt;Child\u0026amp;gt;,\n}\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Child\u0026lt;/span\u0026gt; {\n    value: \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;u32\u0026lt;/span\u0026gt;,\n}\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Combined\u0026lt;/span\u0026gt;(Parent, Arc\u0026amp;lt;Child\u0026amp;gt;);\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;fn\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;main\u0026lt;/span\u0026gt;() {\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;let\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;parent\u0026lt;/span\u0026gt; = Parent { child: Arc::\u0026lt;span class=\u0026quot;hljs-title function_ invoke__\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt;(Child { value: \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;42\u0026lt;/span\u0026gt; }) };\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;let\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;child\u0026lt;/span\u0026gt; = parent.child.\u0026lt;span class=\u0026quot;hljs-title function_ invoke__\u0026quot;\u0026gt;clone\u0026lt;/span\u0026gt;();\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;let\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;combined\u0026lt;/span\u0026gt; = \u0026lt;span class=\u0026quot;hljs-title function_ invoke__\u0026quot;\u0026gt;Combined\u0026lt;/span\u0026gt;(parent, child.\u0026lt;span class=\u0026quot;hljs-title function_ invoke__\u0026quot;\u0026gt;clone\u0026lt;/span\u0026gt;());\n\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;assert_eq!\u0026lt;/span\u0026gt;(combined.\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;.child.value, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;42\u0026lt;/span\u0026gt;);\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;assert_eq!\u0026lt;/span\u0026gt;(child.value, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;42\u0026lt;/span\u0026gt;);\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// combined.0.child.value = 50; // fails, Arc is not DerefMut\u0026lt;/span\u0026gt;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;Arc + Mutex:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-rust s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-rust\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;use\u0026lt;/span\u0026gt; std::sync::{Arc, Mutex};\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Child\u0026lt;/span\u0026gt; {\n    value: \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;u32\u0026lt;/span\u0026gt;,\n}\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Parent\u0026lt;/span\u0026gt; {\n    child: Arc\u0026amp;lt;Mutex\u0026amp;lt;Child\u0026amp;gt;\u0026amp;gt;,\n}\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Combined\u0026lt;/span\u0026gt;(Parent, Arc\u0026amp;lt;Mutex\u0026amp;lt;Child\u0026amp;gt;\u0026amp;gt;);\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;fn\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;main\u0026lt;/span\u0026gt;() {\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;let\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;parent\u0026lt;/span\u0026gt; = Parent { child: Arc::\u0026lt;span class=\u0026quot;hljs-title function_ invoke__\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt;(Mutex::\u0026lt;span class=\u0026quot;hljs-title function_ invoke__\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt;(Child {value: \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;42\u0026lt;/span\u0026gt; }))};\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;let\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;child\u0026lt;/span\u0026gt; = parent.child.\u0026lt;span class=\u0026quot;hljs-title function_ invoke__\u0026quot;\u0026gt;clone\u0026lt;/span\u0026gt;();\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;let\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;combined\u0026lt;/span\u0026gt; = \u0026lt;span class=\u0026quot;hljs-title function_ invoke__\u0026quot;\u0026gt;Combined\u0026lt;/span\u0026gt;(parent, child.\u0026lt;span class=\u0026quot;hljs-title function_ invoke__\u0026quot;\u0026gt;clone\u0026lt;/span\u0026gt;());\n\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;assert_eq!\u0026lt;/span\u0026gt;(combined.\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;.child.\u0026lt;span class=\u0026quot;hljs-title function_ invoke__\u0026quot;\u0026gt;lock\u0026lt;/span\u0026gt;().\u0026lt;span class=\u0026quot;hljs-title function_ invoke__\u0026quot;\u0026gt;unwrap\u0026lt;/span\u0026gt;().value, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;42\u0026lt;/span\u0026gt;);\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;assert_eq!\u0026lt;/span\u0026gt;(child.\u0026lt;span class=\u0026quot;hljs-title function_ invoke__\u0026quot;\u0026gt;lock\u0026lt;/span\u0026gt;().\u0026lt;span class=\u0026quot;hljs-title function_ invoke__\u0026quot;\u0026gt;unwrap\u0026lt;/span\u0026gt;().value, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;42\u0026lt;/span\u0026gt;);\n    child.\u0026lt;span class=\u0026quot;hljs-title function_ invoke__\u0026quot;\u0026gt;lock\u0026lt;/span\u0026gt;().\u0026lt;span class=\u0026quot;hljs-title function_ invoke__\u0026quot;\u0026gt;unwrap\u0026lt;/span\u0026gt;().value = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;50\u0026lt;/span\u0026gt;;\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;assert_eq!\u0026lt;/span\u0026gt;(combined.\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;.child.\u0026lt;span class=\u0026quot;hljs-title function_ invoke__\u0026quot;\u0026gt;lock\u0026lt;/span\u0026gt;().\u0026lt;span class=\u0026quot;hljs-title function_ invoke__\u0026quot;\u0026gt;unwrap\u0026lt;/span\u0026gt;().value, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;50\u0026lt;/span\u0026gt;);\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;See also \u0026lt;code\u0026gt;RwLock\u0026lt;/code\u0026gt; (\u0026lt;a href=\u0026quot;https://stackoverflow.com/questions/50704279/when-or-why-should-i-use-a-mutex-over-an-rwlock\u0026quot;\u0026gt;When or why should I use a Mutex over an RwLock?\u0026lt;/a\u0026gt;)\u0026lt;/p\u0026gt;\n    "],"id":285,"title":"Why can't I store a value and a reference to that value in the same struct?","content":"\n                \n\u0026lt;p\u0026gt;I have a value and I want to store that value and a reference to\nsomething inside that value in my own type:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-rust s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-rust\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Thing\u0026lt;/span\u0026gt; {\n    count: \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;u32\u0026lt;/span\u0026gt;,\n}\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Combined\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-symbol\u0026quot;\u0026gt;\u0026apos;a\u0026lt;/span\u0026gt;\u0026amp;gt;(Thing, \u0026amp;amp;\u0026lt;span class=\u0026quot;hljs-symbol\u0026quot;\u0026gt;\u0026apos;a\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;u32\u0026lt;/span\u0026gt;);\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;fn\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;make_combined\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-symbol\u0026quot;\u0026gt;\u0026apos;a\u0026lt;/span\u0026gt;\u0026amp;gt;() \u0026lt;span class=\u0026quot;hljs-punctuation\u0026quot;\u0026gt;-\u0026amp;gt;\u0026lt;/span\u0026gt; Combined\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-symbol\u0026quot;\u0026gt;\u0026apos;a\u0026lt;/span\u0026gt;\u0026amp;gt; {\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;let\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;thing\u0026lt;/span\u0026gt; = Thing { count: \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;42\u0026lt;/span\u0026gt; };\n\n    \u0026lt;span class=\u0026quot;hljs-title function_ invoke__\u0026quot;\u0026gt;Combined\u0026lt;/span\u0026gt;(thing, \u0026amp;amp;thing.count)\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Sometimes, I have a value and I want to store that value and a reference to\nthat value in the same structure:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-rust s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-rust\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Combined\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-symbol\u0026quot;\u0026gt;\u0026apos;a\u0026lt;/span\u0026gt;\u0026amp;gt;(Thing, \u0026amp;amp;\u0026lt;span class=\u0026quot;hljs-symbol\u0026quot;\u0026gt;\u0026apos;a\u0026lt;/span\u0026gt; Thing);\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;fn\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;make_combined\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-symbol\u0026quot;\u0026gt;\u0026apos;a\u0026lt;/span\u0026gt;\u0026amp;gt;() \u0026lt;span class=\u0026quot;hljs-punctuation\u0026quot;\u0026gt;-\u0026amp;gt;\u0026lt;/span\u0026gt; Combined\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-symbol\u0026quot;\u0026gt;\u0026apos;a\u0026lt;/span\u0026gt;\u0026amp;gt; {\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;let\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;thing\u0026lt;/span\u0026gt; = Thing::\u0026lt;span class=\u0026quot;hljs-title function_ invoke__\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt;();\n\n    \u0026lt;span class=\u0026quot;hljs-title function_ invoke__\u0026quot;\u0026gt;Combined\u0026lt;/span\u0026gt;(thing, \u0026amp;amp;thing)\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Sometimes, I\u0026apos;m not even taking a reference of the value and I get the\nsame error:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-rust s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-rust\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Combined\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-symbol\u0026quot;\u0026gt;\u0026apos;a\u0026lt;/span\u0026gt;\u0026amp;gt;(Parent, Child\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-symbol\u0026quot;\u0026gt;\u0026apos;a\u0026lt;/span\u0026gt;\u0026amp;gt;);\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;fn\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;make_combined\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-symbol\u0026quot;\u0026gt;\u0026apos;a\u0026lt;/span\u0026gt;\u0026amp;gt;() \u0026lt;span class=\u0026quot;hljs-punctuation\u0026quot;\u0026gt;-\u0026amp;gt;\u0026lt;/span\u0026gt; Combined\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-symbol\u0026quot;\u0026gt;\u0026apos;a\u0026lt;/span\u0026gt;\u0026amp;gt; {\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;let\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;parent\u0026lt;/span\u0026gt; = Parent::\u0026lt;span class=\u0026quot;hljs-title function_ invoke__\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt;();\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;let\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-variable\u0026quot;\u0026gt;child\u0026lt;/span\u0026gt; = parent.\u0026lt;span class=\u0026quot;hljs-title function_ invoke__\u0026quot;\u0026gt;child\u0026lt;/span\u0026gt;();\n\n    \u0026lt;span class=\u0026quot;hljs-title function_ invoke__\u0026quot;\u0026gt;Combined\u0026lt;/span\u0026gt;(parent, child)\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;In each of these cases, I get an error that one of the values \u0026quot;does\nnot live long enough\u0026quot;. What does this error mean?\u0026lt;/p\u0026gt;\n    ","slug":"why-can't-i-store-a-value-and-a-reference-to-that-value-in-the-same-struct-1657387506828","postType":"QUESTION","createdAt":"2022-07-09T17:25:06.000Z","updatedAt":"2022-07-09T17:25:06.000Z","tags":[{"id":1740,"name":"rust","slug":"rust","createdAt":"2022-07-09T17:25:06.000Z","updatedAt":"2022-07-09T17:25:06.000Z","Questions_Tags":{"questionId":285,"tagId":1740}},{"id":1742,"name":"lifetime","slug":"lifetime","createdAt":"2022-07-09T17:25:06.000Z","updatedAt":"2022-07-09T17:25:06.000Z","Questions_Tags":{"questionId":285,"tagId":1742}},{"id":1743,"name":"borrow-checker","slug":"borrow-checker","createdAt":"2022-07-09T17:25:06.000Z","updatedAt":"2022-07-09T17:25:06.000Z","Questions_Tags":{"questionId":285,"tagId":1743}}],"relatedQuestions":[{"title":"Why can't I store a value and a reference to that value in the same struct?","slug":"why-can't-i-store-a-value-and-a-reference-to-that-value-in-the-same-struct-1657387506828","tags":[{"name":"rust","Questions_Tags":{"questionId":285,"tagId":1740}},{"name":"lifetime","Questions_Tags":{"questionId":285,"tagId":1742}},{"name":"borrow-checker","Questions_Tags":{"questionId":285,"tagId":1743}}]}]},"randomQuestions":[{"title":"Android permission doesn't work even if I have declared it","slug":"android-permission-doesn't-work-even-if-i-have-declared-it-1657387726990"},{"title":"How can I prevent SQL injection in PHP?","slug":"how-can-i-prevent-sql-injection-in-php-1657384220094"},{"title":"Ways to circumvent the same-origin policy","slug":"ways-to-circumvent-the-same-origin-policy-1657384763316"},{"title":"How do I clone a list so that it doesn't change unexpectedly after assignment?","slug":"how-do-i-clone-a-list-so-that-it-doesn't-change-unexpectedly-after-assignment-1657384423195"},{"title":"Why should there be spaces around '[' and ']' in Bash?","slug":"why-should-there-be-spaces-around-''-and-''-in-bash-1657387984122"},{"title":"What is the difference between single-quoted and double-quoted strings in PHP?","slug":"what-is-the-difference-between-single-quoted-and-double-quoted-strings-in-php-1657384624345"},{"title":"How to remove/delete a large file from commit history in the Git repository?","slug":"how-to-removedelete-a-large-file-from-commit-history-in-the-git-repository-1657387589093"},{"title":"Read file line by line using ifstream in C++","slug":"read-file-line-by-line-using-ifstream-in-c++-1657388236966"},{"title":"Remove duplicate values from JS array [duplicate]","slug":"remove-duplicate-values-from-js-array-duplicate-1657387801931"},{"title":"Servlet returns \"HTTP Status 404 The requested resource (/servlet) is not available\"","slug":"servlet-returns-\"http-status-404-the-requested-resource-(servlet)-is-not-available\"-1657384850661"},{"title":"How to find the 'sizeof' (a pointer pointing to an array)?","slug":"how-to-find-the-'sizeof'-(a-pointer-pointing-to-an-array)-1657387354284"},{"title":"Is it safe to expose Firebase apiKey to the public?","slug":"is-it-safe-to-expose-firebase-apikey-to-the-public-1657388268111"},{"title":"What is __init__.py for?","slug":"what-is-__init__.py-for-1657388415243"},{"title":"What is the copy-and-swap idiom?","slug":"what-is-the-copy-and-swap-idiom-1657384840329"},{"title":"Convert columns into rows with Pandas","slug":"convert-columns-into-rows-with-pandas-1657388374964"},{"title":"How can I deserialize JSON with C#?","slug":"how-can-i-deserialize-json-with-c-1657388102941"},{"title":"How to reshape data from long to wide format","slug":"how-to-reshape-data-from-long-to-wide-format-1657384486421"},{"title":"Maintain the aspect ratio of a div with CSS","slug":"maintain-the-aspect-ratio-of-a-div-with-css-1657387513615"},{"title":"Creating multiline strings in JavaScript","slug":"creating-multiline-strings-in-javascript-1657388025414"},{"title":"How to use java.net.URLConnection to fire and handle HTTP requests","slug":"how-to-use-java.net.urlconnection-to-fire-and-handle-http-requests-1657387245934"}]},"__N_SSG":true},"page":"/questions/[slug]","query":{"slug":"why-can't-i-store-a-value-and-a-reference-to-that-value-in-the-same-struct-1657387506828"},"buildId":"eGqQHYKGZKE-nXShFn8wX","isFallback":false,"gsp":true,"locale":"en","locales":["en"],"defaultLocale":"en","scriptLoader":[]}</script></body></html>