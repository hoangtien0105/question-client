<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><meta name="twitter:card" content="summary_large_image"/><meta name="twitter:site" content="@solutionschecker.com"/><meta name="twitter:creator" content="@solutionschecker.com"/><meta property="og:url" content="https://solutionschecker.com"/><meta property="og:type" content="website"/><meta property="og:image" content="https://solutionschecker.com/solutions-checker-banner.png"/><meta property="og:image:alt" content="Find the solution to any question. We focus on finding the fastest possible solution for users. Main topics like coding, learning. - solutionschecker.com"/><link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png"/><link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png"/><link rel="manifest" href="/site.webmanifest"/><script type="application/ld+json">{"@context":"https://schema.org","@type":"Organization","logo":"/logo.svg","url":"https://solutionschecker.com"}</script><link name="keywords" content="while-loop,eof,file,feof,solutions checker, solution checker, how to, solution for, check for solution, resolve question, what is, what solution for, find solution"/><script type="application/ld+json">{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"item":{"@id":"https://solutionschecker.com","name":"Home"}},{"@type":"ListItem","position":2,"item":{"@id":"https://solutionschecker.com/questions","name":"Questions"}},{"@type":"ListItem","position":3,"item":{"@id":"https://solutionschecker.com/questions/why-is-&quot;while(-!feof(file)-)&quot;-always-wrong-1657384367349","name":"Questions"}}]}</script><title>Why is “while( !feof(file) )” always wrong? | Solution Checker</title><meta name="robots" content="index,follow"/><meta name="description" content="What is wrong with using feof() to control a read loop?  For example:
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int
main(int argc, char **argv)
{
    char *path = &quot;stdin&quot;;
    FILE *fp = argc &gt; 1 ? fopen(path=argv[1], &quot;r&quot;) : stdin;

    if( fp == NULL ){
        perror(path);
        return EXIT_FAILURE;
    }

    while( !feof(fp) ){  /* THIS IS WRONG */
        /* Read and process data from file… */
    }
    if( fclose(fp) != 0 ){
        perror(path);
        return EXIT_FAILURE;
    }
    return EXIT_SUCCESS;
}

What is wrong with this loop?
    "/><meta property="og:title" content="Why is “while( !feof(file) )” always wrong? | Solution Checker"/><meta property="og:description" content="What is wrong with using feof() to control a read loop?  For example:
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int
main(int argc, char **argv)
{
    char *path = &quot;stdin&quot;;
    FILE *fp = argc &gt; 1 ? fopen(path=argv[1], &quot;r&quot;) : stdin;

    if( fp == NULL ){
        perror(path);
        return EXIT_FAILURE;
    }

    while( !feof(fp) ){  /* THIS IS WRONG */
        /* Read and process data from file… */
    }
    if( fclose(fp) != 0 ){
        perror(path);
        return EXIT_FAILURE;
    }
    return EXIT_SUCCESS;
}

What is wrong with this loop?
    "/><script type="application/ld+json">{"@context":"https://schema.org","@type":"QAPage","mainEntity":{"name":"Why is “while( !feof(file) )” always wrong?","text":"What is wrong with using feof() to control a read loop?  For example:\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\nint\nmain(int argc, char **argv)\n{\n    char *path = &quot;stdin&quot;;\n    FILE *fp = argc &gt; 1 ? fopen(path=argv[1], &quot;r&quot;) : stdin;\n\n    if( fp == NULL ){\n        perror(path);\n        return EXIT_FAILURE;\n    }\n\n    while( !feof(fp) ){  /* THIS IS WRONG */\n        /* Read and process data from file… */\n    }\n    if( fclose(fp) != 0 ){\n        perror(path);\n        return EXIT_FAILURE;\n    }\n    return EXIT_SUCCESS;\n}\n\nWhat is wrong with this loop?\n    ","answerCount":5,"upVoteCount":500,"suggestedAnswer":[{"text":"TL;DR\nwhile(!feof) is wrong because it tests for something that is irrelevant and fails to test for something that you need to know. The result is that you are erroneously executing code that assumes that it is accessing data that was read successfully, when in fact this never happened.\nI&apos;d like to provide an abstract, high-level perspective. So continue reading if you&apos;re interested in what while(!feof) actually does.\nConcurrency and simultaneity\nI/O operations interact with the environment. The environment is not part of your program, and not under your control. The environment truly exists &quot;concurrently&quot; with your program. As with all things concurrent, questions about the &quot;current state&quot; don&apos;t make sense: There is no concept of &quot;simultaneity&quot; across concurrent events. Many properties of state simply don&apos;t exist concurrently.\nLet me make this more precise: Suppose you want to ask, &quot;do you have more data&quot;. You could ask this of a concurrent container, or of your I/O system. But the answer is generally unactionable, and thus meaningless. So what if the container says &quot;yes&quot;  by the time you try reading, it may no longer have data. Similarly, if the answer is &quot;no&quot;, by the time you try reading, data may have arrived. The conclusion is that there simply is no property like &quot;I have data&quot;, since you cannot act meaningfully in response to any possible answer. (The situation is slightly better with buffered input, where you might conceivably get a &quot;yes, I have data&quot; that constitutes some kind of guarantee, but you would still have to be able to deal with the opposite case. And with output the situation is certainly just as bad as I described: you never know if that disk or that network buffer is full.)\nSo we conclude that it is impossible, and in fact unreasonable, to ask an I/O system whether it will be able to perform an I/O operation. The only possible way we can interact with it (just as with a concurrent container) is to attempt the operation and check whether it succeeded or failed. At that moment where you interact with the environment, then and only then can you know whether the interaction was actually possible, and at that point you must commit to performing the interaction. (This is a &quot;synchronisation point&quot;, if you will.)\nEOF\nNow we get to EOF. EOF is the response you get from an attempted I/O operation. It means that you were trying to read or write something, but when doing so you failed to read or write any data, and instead the end of the input or output was encountered. This is true for essentially all the I/O APIs, whether it be the C standard library, C++ iostreams, or other libraries. As long as the I/O operations succeed, you simply cannot know whether further, future operations will succeed. You must always first try the operation and then respond to success or failure.\nExamples\nIn each of the examples, note carefully that we first attempt the I/O operation and then consume the result if it is valid. Note further that we always must use the result of the I/O operation, though the result takes different shapes and forms in each example.\n\nC stdio, read from a file:\n  for (;;) {\n      size_t n = fread(buf, 1, bufsize, infile);\n      consume(buf, n);\n      if (n == 0) { break; }\n  }\n\nThe result we must use is n, the number of elements that were read (which may be as little as zero).\n\nC stdio, scanf:\n  for (int a, b, c; scanf(&quot;%d %d %d&quot;, &amp;a, &amp;b, &amp;c) == 3; ) {\n      consume(a, b, c);\n  }\n\nThe result we must use is the return value of scanf, the number of elements converted.\n\nC++, iostreams formatted extraction:\n  for (int n; std::cin &gt;&gt; n; ) {\n      consume(n);\n  }\n\nThe result we must use is std::cin itself, which can be evaluated in a boolean context and tells us whether the stream is still in the good() state.\n\nC++, iostreams getline:\n  for (std::string line; std::getline(std::cin, line); ) {\n      consume(line);\n  }\n\nThe result we must use is again std::cin, just as before.\n\nPOSIX, write(2) to flush a buffer:\n  char const * p = buf;\n  ssize_t n = bufsize;\n  for (ssize_t k = bufsize; (k = write(fd, p, n)) &gt; 0; p += k, n -= k) {}\n  if (n != 0) { /* error, failed to write complete buffer */ }\n\nThe result we use here is k, the number of bytes written. The point here is that we can only know how many bytes were written after the write operation.\n\nPOSIX getline()\n  char *buffer = NULL;\n  size_t bufsiz = 0;\n  ssize_t nbytes;\n  while ((nbytes = getline(&amp;buffer, &amp;bufsiz, fp)) != -1)\n  {\n      /* Use nbytes of data in buffer */\n  }\n  free(buffer);\n\nThe result we must use is nbytes, the number of bytes up to and including the newline (or EOF if the file did not end with a newline).\nNote that the function explicitly returns -1 (and not EOF!) when an error occurs or it reaches EOF.\n\n\nYou may notice that we very rarely spell out the actual word &quot;EOF&quot;. We usually detect the error condition in some other way that is more immediately interesting to us (e.g. failure to perform as much I/O as we had desired). In every example there is some API feature that could tell us explicitly that the EOF state has been encountered, but this is in fact not a terribly useful piece of information. It is much more of a detail than we often care about. What matters is whether the I/O succeeded, more-so than how it failed.\n\nA final example that actually queries the EOF state: Suppose you have a string and want to test that it represents an integer in its entirety, with no extra bits at the end except whitespace. Using C++ iostreams, it goes like this:\n  std::string input = &quot;   123   &quot;;   // example\n\n  std::istringstream iss(input);\n  int value;\n  if (iss &gt;&gt; value &gt;&gt; std::ws &amp;&amp; iss.get() == EOF) {\n      consume(value);\n  } else {\n      // error, &quot;input&quot; is not parsable as an integer\n  }\n\n\n\nWe use two results here. The first is iss, the stream object itself, to check that the formatted extraction to value succeeded. But then, after also consuming whitespace, we perform another I/O/ operation, iss.get(), and expect it to fail as EOF, which is the case if the entire string has already been consumed by the formatted extraction.\nIn the C standard library you can achieve something similar with the strto*l functions by checking that the end pointer has reached the end of the input string.\n    ","url":"/questions/[slug]#solution1","@type":"Answer","upvoteCount":0},{"text":"It&apos;s wrong because (in the absence of a read error) it enters the loop one more time than the author expects.  If there is a read error, the loop never terminates.\nConsider the following code:\n/* WARNING: demonstration of bad coding technique!! */\n\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\nFILE *Fopen(const char *path, const char *mode);\n\nint main(int argc, char **argv)\n{\n    FILE *in;\n    unsigned count;\n\n    in = argc &gt; 1 ? Fopen(argv[1], &quot;r&quot;) : stdin;\n    count = 0;\n\n    /* WARNING: this is a bug */\n    while( !feof(in) ) {  /* This is WRONG! */\n        fgetc(in);\n        count++;\n    }\n    printf(&quot;Number of characters read: %u\\n&quot;, count);\n    return EXIT_SUCCESS;\n}\n\nFILE * Fopen(const char *path, const char *mode)\n{\n    FILE *f = fopen(path, mode);\n    if( f == NULL ) {\n        perror(path);\n        exit(EXIT_FAILURE);\n    }\n    return f;\n}\n\nThis program will consistently print one greater than the number of characters in the input stream (assuming no read errors).  Consider the case where the input stream is empty:\n$ ./a.out &lt; /dev/null\nNumber of characters read: 1\n\nIn this case, feof() is called before any data has been read, so it returns false.  The loop is entered, fgetc() is called (and returns EOF), and count is incremented.  Then feof() is called and returns true, causing the loop to abort.\nThis happens in all such cases.  feof() does not return true until after a read on the stream encounters the end of file.  The purpose of feof() is NOT to check if the next read will reach the end of file.  The purpose of feof() is to determine the status of a previous read function\nand distinguish between an error condition and the end of the data stream.  If fread() returns 0, you must use feof/ferror to decide whether an error occurred or if all of the data was consumed.  Similarly if fgetc returns EOF.  feof() is only useful after fread has returned zero or fgetc has returned EOF.  Before that happens, feof() will always return 0.\nIt is always necessary to check the return value of a read (either an fread(), or an fscanf(), or an fgetc()) before calling feof().\nEven worse, consider the case where a read error occurs.  In that case, fgetc() returns EOF, feof() returns false, and the loop never terminates.  In all cases where while(!feof(p)) is used, there must be at least a check inside the loop for ferror(), or at the very least the while condition should be replaced with while(!feof(p) &amp;&amp; !ferror(p)) or there is a very real possibility of an infinite loop, probably spewing all sorts of garbage as invalid data is being processed.\nSo, in summary, although I cannot state with certainty that there is never a situation in which it may be semantically correct to write &quot;while(!feof(f))&quot; (although there must be another check inside the loop with a break to avoid a infinite loop on a read error), it is the case that it is almost certainly always wrong.  And even if a case ever arose where it would be correct, it is so idiomatically wrong that it would not be the right way to write the code.  Anyone seeing that code should immediately hesitate and say, &quot;that&apos;s a bug&quot;.  And possibly slap the author (unless the author is your boss in which case discretion is advised.)\n    ","url":"/questions/[slug]#solution2","@type":"Answer","upvoteCount":0},{"text":"No it&apos;s not always wrong. If your loop condition is &quot;while we haven&apos;t tried to read past end of file&quot; then you use while (!feof(f)). This is however not a common loop condition - usually you want to test for something else (such as &quot;can I read more&quot;). while (!feof(f)) isn&apos;t wrong, it&apos;s just used wrong.\n    ","url":"/questions/[slug]#solution3","@type":"Answer","upvoteCount":0},{"text":"feof() indicates if one has tried to read past the end of file. That means it has little predictive effect: if it is true, you are sure that the next input operation will fail (you aren&apos;t sure the previous one failed BTW), but if it is false, you aren&apos;t sure the next input operation will succeed.  More over, input operations may fail for other reasons than the end of file (a format error for formatted input, a pure IO failure -- disk failure, network timeout -- for all input kinds), so even if you could be predictive about the end of file (and anybody who has tried to implement Ada one, which is predictive, will tell you it can complex if you need to skip spaces, and that it has undesirable effects on interactive devices -- sometimes forcing the input of the next line before starting the handling of the previous one), you would have to be able to handle a failure.\n\nSo the correct idiom in C is to loop with the IO operation success as loop condition, and then test the cause of the failure.  For instance:\n\nwhile (fgets(line, sizeof(line), file)) {\n    /* note that fgets don&apos;t strip the terminating \\n, checking its\n       presence allow to handle lines longer that sizeof(line), not showed here */\n    ...\n}\nif (ferror(file)) {\n   /* IO failure */\n} else if (feof(file)) {\n   /* format error (not possible with fgets, but would be with fscanf) or end of file */\n} else {\n   /* format error (not possible with fgets, but would be with fscanf) */\n}\n\n    ","url":"/questions/[slug]#solution4","@type":"Answer","upvoteCount":0},{"text":"feof() is not very intuitive. In my very humble opinion, the FILE&apos;s end-of-file state should be set to true if any read operation results in the end of file being reached. Instead, you have to manually check if the end of file has been reached after each read operation. For example, something like this will work if reading from a text file using fgetc():\n\n#include &lt;stdio.h&gt;\n\nint main(int argc, char *argv[])\n{\n  FILE *in = fopen(&quot;testfile.txt&quot;, &quot;r&quot;);\n\n  while(1) {\n    char c = fgetc(in);\n    if (feof(in)) break;\n    printf(&quot;%c&quot;, c);\n  }\n\n  fclose(in);\n  return 0;\n}\n\n\nIt would be great if something like this would work instead:\n\n#include &lt;stdio.h&gt;\n\nint main(int argc, char *argv[])\n{\n  FILE *in = fopen(&quot;testfile.txt&quot;, &quot;r&quot;);\n\n  while(!feof(in)) {\n    printf(&quot;%c&quot;, fgetc(in));\n  }\n\n  fclose(in);\n  return 0;\n}\n\n    ","url":"/questions/[slug]#solution5","@type":"Answer","upvoteCount":0}],"@type":"Question"}}</script><meta name="next-head-count" content="22"/><link rel="preload" href="/_next/static/css/c116652e2d6f4ad0.css" as="style"/><link rel="stylesheet" href="/_next/static/css/c116652e2d6f4ad0.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-0d1b80a048d4787e.js"></script><script src="/_next/static/chunks/webpack-42cdea76c8170223.js" defer=""></script><script src="/_next/static/chunks/framework-4556c45dd113b893.js" defer=""></script><script src="/_next/static/chunks/main-ccfab947c79712f4.js" defer=""></script><script src="/_next/static/chunks/pages/_app-43d1c35cd6eb9b8f.js" defer=""></script><script src="/_next/static/chunks/294-106ef8570fa99deb.js" defer=""></script><script src="/_next/static/chunks/490-7f0418bb4354ac73.js" defer=""></script><script src="/_next/static/chunks/pages/questions/%5Bslug%5D-50e201fdaa1e0fd1.js" defer=""></script><script src="/_next/static/00bsHgHZki2FteshOatnd/_buildManifest.js" defer=""></script><script src="/_next/static/00bsHgHZki2FteshOatnd/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="wrapper"><header><nav class="bg-white border-gray-200 px-4 lg:px-6 py-2.5 dark:bg-gray-800"><div class="flex flex-wrap justify-between items-center mx-auto max-w-screen-xl"><a class="flex items-center" href="/"><img src="/logo-second.png" class="mr-3 h-6 sm:h-9" alt="Solution Checker Logo"/><h1 class="self-center text-xl font-semibold whitespace-nowrap dark:text-white">Solution Checker</h1></a><div class="flex items-center lg:order-2"><button data-collapse-toggle="mobile-menu-2" type="button" class="inline-flex items-center p-2 ml-1 text-sm text-gray-500 rounded-lg lg:hidden hover:bg-gray-100 focus:outline-none focus:ring-2 focus:ring-gray-200 dark:text-gray-400 dark:hover:bg-gray-700 dark:focus:ring-gray-600" aria-controls="mobile-menu-2" aria-expanded="false"><span class="sr-only">Open main menu</span><svg class="w-6 h-6" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M3 5a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM3 10a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM3 15a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1z" clip-rule="evenodd"></path></svg><svg class="hidden w-6 h-6" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z" clip-rule="evenodd"></path></svg></button></div><div class="hidden justify-between items-center w-full lg:flex lg:w-auto lg:order-1" id="mobile-menu-2"><ul class="flex flex-col mt-4 font-medium lg:flex-row lg:space-x-8 lg:mt-0"><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" aria-current="page" href="/">Home</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/questions?tab=news">Questions</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/post?tab=news">Post</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/questions/why-is-%22while(-!feof(file)-)%22-always-wrong-1657384367349#">Coding</a></li></ul></div></div></nav></header><div class="main-content"><div class="question my-5"><div class="flex question-header items-center m-auto justify-center"><div class="rounded-xl w-full border p-5 shadow-md bg-white"><div class="flex w-full items-center justify-between border-b pb-3"><div class="flex items-center space-x-3"><div class="text-lg font-bold text-slate-700"><a href="/questions/why-is-%22while(-!feof(file)-)%22-always-wrong-1657384367349"><h1>Why is “while( !feof(file) )” always wrong?</h1></a></div></div><div class="flex flex-wrap h-auto justify-end items-center space-x-8"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold" href="/questions/tag/while-loop">while-loop</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold" href="/questions/tag/eof">eof</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold" href="/questions/tag/file">file</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold" href="/questions/tag/feof">feof</a></div></div><div class="question-content mt-5">
                
<p>What is wrong with using <code>feof()</code> to control a read loop?  For example:</p>
<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span>

<span class="hljs-type">int</span>
<span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv)</span>
{
    <span class="hljs-type">char</span> *path = <span class="hljs-string">"stdin"</span>;
    FILE *fp = argc &gt; <span class="hljs-number">1</span> ? fopen(path=argv[<span class="hljs-number">1</span>], <span class="hljs-string">"r"</span>) : <span class="hljs-built_in">stdin</span>;

    <span class="hljs-keyword">if</span>( fp == <span class="hljs-literal">NULL</span> ){
        perror(path);
        <span class="hljs-keyword">return</span> EXIT_FAILURE;
    }

    <span class="hljs-keyword">while</span>( !feof(fp) ){  <span class="hljs-comment">/* THIS IS WRONG */</span>
        <span class="hljs-comment">/* Read and process data from file… */</span>
    }
    <span class="hljs-keyword">if</span>( fclose(fp) != <span class="hljs-number">0</span> ){
        perror(path);
        <span class="hljs-keyword">return</span> EXIT_FAILURE;
    }
    <span class="hljs-keyword">return</span> EXIT_SUCCESS;
}
</code></pre>
<p>What is wrong with this loop?</p>
    </div></div></div><div class="solution-section"><nav class="flex pagination-solution flex-col justify-end"><h1 class="text-lg font-semibold mb-5">Navigate to solutions: </h1><ul class="inline-flex -space-x-px overflow-auto"><li class="pagination-solution-item"><span data-id="#solution1" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">1</span></li><li class="pagination-solution-item"><span data-id="#solution2" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">2</span></li><li class="pagination-solution-item"><span data-id="#solution3" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">3</span></li><li class="pagination-solution-item"><span data-id="#solution4" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">4</span></li><li class="pagination-solution-item"><span data-id="#solution5" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">5</span></li></ul></nav><div id="solution1" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 1</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/while-loop">while-loop</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/eof">eof</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/file">file</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/feof">feof</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<h3>TL;DR</h3>
<p><code>while(!feof)</code> is wrong because it tests for something that is irrelevant and fails to test for something that you need to know. The result is that you are erroneously executing code that assumes that it is accessing data that was read successfully, when in fact this never happened.</p>
<p>I'd like to provide an abstract, high-level perspective. So continue reading if you're interested in what <code>while(!feof)</code> actually does.</p>
<h3>Concurrency and simultaneity</h3>
<p>I/O operations interact with the environment. The environment is not part of your program, and not under your control. The environment truly exists "concurrently" with your program. As with all things concurrent, questions about the "current state" don't make sense: There is no concept of "simultaneity" across concurrent events. Many properties of state simply don't <em>exist</em> concurrently.</p>
<p>Let me make this more precise: Suppose you want to ask, "do you have more data". You could ask this of a concurrent container, or of your I/O system. But the answer is generally unactionable, and thus meaningless. So what if the container says "yes"  by the time you try reading, it may no longer have data. Similarly, if the answer is "no", by the time you try reading, data may have arrived. The conclusion is that there simply <em>is</em> no property like "I have data", since you cannot act meaningfully in response to any possible answer. (The situation is slightly better with buffered input, where you might conceivably get a "yes, I have data" that constitutes some kind of guarantee, but you would still have to be able to deal with the opposite case. And with output the situation is certainly just as bad as I described: you never know if that disk or that network buffer is full.)</p>
<p>So we conclude that it is impossible, and in fact un<em>reasonable</em>, to ask an I/O system whether it <em>will be</em> able to perform an I/O operation. The only possible way we can interact with it (just as with a concurrent container) is to <em>attempt</em> the operation and check whether it succeeded or failed. At that moment where you interact with the environment, then and only then can you know whether the interaction was actually possible, and at that point you must commit to performing the interaction. (This is a "synchronisation point", if you will.)</p>
<h3>EOF</h3>
<p>Now we get to EOF. EOF is the <em>response</em> you get from an <em>attempted</em> I/O operation. It means that you were trying to read or write something, but when doing so you failed to read or write any data, and instead the end of the input or output was encountered. This is true for essentially all the I/O APIs, whether it be the C standard library, C++ iostreams, or other libraries. As long as the I/O operations succeed, you simply <em>cannot know</em> whether further, future operations will succeed. You <em>must</em> always first try the operation and then respond to success or failure.</p>
<h3>Examples</h3>
<p>In each of the examples, note carefully that we <em>first</em> attempt the I/O operation and <em>then</em> consume the result if it is valid. Note further that we <em>always</em> must use the result of the I/O operation, though the result takes different shapes and forms in each example.</p>
<ul>
<li><p>C stdio, read from a file:</p>
<pre class="lang-c s-code-block"><code class="hljs language-c">  <span class="hljs-keyword">for</span> (;;) {
      <span class="hljs-type">size_t</span> n = fread(buf, <span class="hljs-number">1</span>, bufsize, infile);
      consume(buf, n);
      <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>) { <span class="hljs-keyword">break</span>; }
  }
</code></pre>
<p>The result we must use is <code>n</code>, the number of elements that were read (which may be as little as zero).</p>
</li>
<li><p>C stdio, <code>scanf</code>:</p>
<pre class="lang-c s-code-block"><code class="hljs language-c">  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> a, b, c; <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d %d %d"</span>, &amp;a, &amp;b, &amp;c) == <span class="hljs-number">3</span>; ) {
      consume(a, b, c);
  }
</code></pre>
<p>The result we must use is the return value of <code>scanf</code>, the number of elements converted.</p>
</li>
<li><p>C++, iostreams formatted extraction:</p>
<pre class="lang-c s-code-block"><code class="hljs language-c">  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> n; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cin</span> &gt;&gt; n; ) {
      consume(n);
  }
</code></pre>
<p>The result we must use is <code>std::cin</code> itself, which can be evaluated in a boolean context and tells us whether the stream is still in the <code>good()</code> state.</p>
</li>
<li><p>C++, iostreams getline:</p>
<pre class="lang-c s-code-block"><code class="hljs language-c">  <span class="hljs-keyword">for</span> (<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> line; <span class="hljs-built_in">std</span>::getline(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">cin</span>, line); ) {
      consume(line);
  }
</code></pre>
<p>The result we must use is again <code>std::cin</code>, just as before.</p>
</li>
<li><p>POSIX, <code>write(2)</code> to flush a buffer:</p>
<pre class="lang-c s-code-block"><code class="hljs language-c">  <span class="hljs-type">char</span> <span class="hljs-type">const</span> * p = buf;
  <span class="hljs-type">ssize_t</span> n = bufsize;
  <span class="hljs-keyword">for</span> (<span class="hljs-type">ssize_t</span> k = bufsize; (k = write(fd, p, n)) &gt; <span class="hljs-number">0</span>; p += k, n -= k) {}
  <span class="hljs-keyword">if</span> (n != <span class="hljs-number">0</span>) { <span class="hljs-comment">/* error, failed to write complete buffer */</span> }
</code></pre>
<p>The result we use here is <code>k</code>, the number of bytes written. The point here is that we can only know how many bytes were written <em>after</em> the write operation.</p>
</li>
<li><p>POSIX <a href="http://pubs.opengroup.org/onlinepubs/9699919799/functions/getline.html" rel="noreferrer"><code>getline()</code></a></p>
<pre class="lang-c s-code-block"><code class="hljs language-c">  <span class="hljs-type">char</span> *buffer = <span class="hljs-literal">NULL</span>;
  <span class="hljs-type">size_t</span> bufsiz = <span class="hljs-number">0</span>;
  <span class="hljs-type">ssize_t</span> nbytes;
  <span class="hljs-keyword">while</span> ((nbytes = getline(&amp;buffer, &amp;bufsiz, fp)) != <span class="hljs-number">-1</span>)
  {
      <span class="hljs-comment">/* Use nbytes of data in buffer */</span>
  }
  <span class="hljs-built_in">free</span>(buffer);
</code></pre>
<p>The result we must use is <code>nbytes</code>, the number of bytes up to and including the newline (or EOF if the file did not end with a newline).</p>
<p>Note that the function explicitly returns <code>-1</code> (and not EOF!) when an error occurs or it reaches EOF.</p>
</li>
</ul>
<p>You may notice that we very rarely spell out the actual word "EOF". We usually detect the error condition in some other way that is more immediately interesting to us (e.g. failure to perform as much I/O as we had desired). In every example there is some API feature that could tell us explicitly that the EOF state has been encountered, but this is in fact not a terribly useful piece of information. It is much more of a detail than we often care about. What matters is whether the I/O succeeded, more-so than how it failed.</p>
<ul>
<li><p>A final example that actually queries the EOF state: Suppose you have a string and want to test that it represents an integer in its entirety, with no extra bits at the end except whitespace. Using C++ iostreams, it goes like this:</p>
<pre class="lang-c s-code-block"><code class="hljs language-c">  <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> input = <span class="hljs-string">"   123   "</span>;   <span class="hljs-comment">// example</span>

  <span class="hljs-built_in">std</span>::<span class="hljs-built_in">istringstream</span> <span class="hljs-title function_">iss</span><span class="hljs-params">(input)</span>;
  <span class="hljs-type">int</span> value;
  <span class="hljs-keyword">if</span> (iss &gt;&gt; value &gt;&gt; <span class="hljs-built_in">std</span>::ws &amp;&amp; iss.get() == EOF) {
      consume(value);
  } <span class="hljs-keyword">else</span> {
      <span class="hljs-comment">// error, "input" is not parsable as an integer</span>
  }
</code></pre>
</li>
</ul>
<p>We use two results here. The first is <code>iss</code>, the stream object itself, to check that the formatted extraction to <code>value</code> succeeded. But then, after also consuming whitespace, we perform another I/O/ operation, <code>iss.get()</code>, and expect it to fail as EOF, which is the case if the entire string has already been consumed by the formatted extraction.</p>
<p>In the C standard library you can achieve something similar with the <code>strto*l</code> functions by checking that the end pointer has reached the end of the input string.</p>
    </div></div></div></div><div id="solution2" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 2</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/while-loop">while-loop</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/eof">eof</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/file">file</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/feof">feof</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>It's wrong because (in the absence of a read error) it enters the loop one more time than the author expects.  If there is a read error, the loop never terminates.</p>
<p>Consider the following code:</p>
<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-comment">/* WARNING: demonstration of bad coding technique!! */</span>

<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span>

FILE *<span class="hljs-title function_">Fopen</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *path, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *mode)</span>;

<span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv)</span>
{
    FILE *in;
    <span class="hljs-type">unsigned</span> count;

    in = argc &gt; <span class="hljs-number">1</span> ? Fopen(argv[<span class="hljs-number">1</span>], <span class="hljs-string">"r"</span>) : <span class="hljs-built_in">stdin</span>;
    count = <span class="hljs-number">0</span>;

    <span class="hljs-comment">/* WARNING: this is a bug */</span>
    <span class="hljs-keyword">while</span>( !feof(in) ) {  <span class="hljs-comment">/* This is WRONG! */</span>
        fgetc(in);
        count++;
    }
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Number of characters read: %u\n"</span>, count);
    <span class="hljs-keyword">return</span> EXIT_SUCCESS;
}

FILE * <span class="hljs-title function_">Fopen</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *path, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *mode)</span>
{
    FILE *f = fopen(path, mode);
    <span class="hljs-keyword">if</span>( f == <span class="hljs-literal">NULL</span> ) {
        perror(path);
        <span class="hljs-built_in">exit</span>(EXIT_FAILURE);
    }
    <span class="hljs-keyword">return</span> f;
}
</code></pre>
<p>This program will consistently print one greater than the number of characters in the input stream (assuming no read errors).  Consider the case where the input stream is empty:</p>
<pre class="lang-c s-code-block"><code class="hljs language-c">$ ./a.out &lt; /dev/null
Number of characters read: <span class="hljs-number">1</span>
</code></pre>
<p>In this case, <code>feof()</code> is called before any data has been read, so it returns false.  The loop is entered, <code>fgetc()</code> is called (and returns <code>EOF</code>), and count is incremented.  Then <code>feof()</code> is called and returns true, causing the loop to abort.</p>
<p>This happens in all such cases.  <code>feof()</code> does not return true until <strong>after</strong> a read on the stream encounters the end of file.  The purpose of <code>feof()</code> is NOT to check if the next read will reach the end of file.  The purpose of <code>feof()</code> is to determine the status of a previous read function
and distinguish between an error condition and the end of the data stream.  If <code>fread()</code> returns 0, you must use <code>feof</code>/<code>ferror</code> to decide whether an error occurred or if all of the data was consumed.  Similarly if <code>fgetc</code> returns <code>EOF</code>.  <code>feof()</code> is only useful <strong>after</strong> fread has returned zero or <code>fgetc</code> has returned <code>EOF</code>.  Before that happens, <code>feof()</code> will always return 0.</p>
<p>It is always necessary to check the return value of a read (either an <code>fread()</code>, or an <code>fscanf()</code>, or an <code>fgetc()</code>) before calling <code>feof()</code>.</p>
<p>Even worse, consider the case where a read error occurs.  In that case, <code>fgetc()</code> returns <code>EOF</code>, <code>feof()</code> returns false, and the loop never terminates.  In all cases where <code>while(!feof(p))</code> is used, there must be at least a check inside the loop for <code>ferror()</code>, or at the very least the while condition should be replaced with <code>while(!feof(p) &amp;&amp; !ferror(p))</code> or there is a very real possibility of an infinite loop, probably spewing all sorts of garbage as invalid data is being processed.</p>
<p>So, in summary, although I cannot state with certainty that there is never a situation in which it may be semantically correct to write "<code>while(!feof(f))</code>" (although there <strong>must</strong> be another check inside the loop with a break to avoid a infinite loop on a read error), it is the case that it is almost certainly always wrong.  And even if a case ever arose where it would be correct, it is so idiomatically wrong that it would not be the right way to write the code.  Anyone seeing that code should immediately hesitate and say, "that's a bug".  And possibly slap the author (unless the author is your boss in which case discretion is advised.)</p>
    </div></div></div></div><div id="solution3" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 3</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/while-loop">while-loop</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/eof">eof</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/file">file</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/feof">feof</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>No it's not always wrong. If your loop condition is "while we haven't tried to read past end of file" then you use <code>while (!feof(f))</code>. This is however not a common loop condition - usually you want to test for something else (such as "can I read more"). <code>while (!feof(f))</code> isn't wrong, it's just <em>used</em> wrong.</p>
    </div></div></div></div><div id="solution4" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 4</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/while-loop">while-loop</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/eof">eof</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/file">file</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/feof">feof</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p><code>feof()</code> indicates if one has tried to read past the end of file. That means it has little predictive effect: if it is true, you are sure that the next input operation will fail (you aren't sure the previous one failed BTW), but if it is false, you aren't sure the next input operation will succeed.  More over, input operations may fail for other reasons than the end of file (a format error for formatted input, a pure IO failure -- disk failure, network timeout -- for all input kinds), so even if you could be predictive about the end of file (and anybody who has tried to implement Ada one, which is predictive, will tell you it can complex if you need to skip spaces, and that it has undesirable effects on interactive devices -- sometimes forcing the input of the next line before starting the handling of the previous one), you would have to be able to handle a failure.</p>

<p>So the correct idiom in C is to loop with the IO operation success as loop condition, and then test the cause of the failure.  For instance:</p>

<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-keyword">while</span> (fgets(line, <span class="hljs-keyword">sizeof</span>(line), file)) {
    <span class="hljs-comment">/* note that fgets don't strip the terminating \n, checking its
       presence allow to handle lines longer that sizeof(line), not showed here */</span>
    ...
}
<span class="hljs-keyword">if</span> (ferror(file)) {
   <span class="hljs-comment">/* IO failure */</span>
} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (feof(file)) {
   <span class="hljs-comment">/* format error (not possible with fgets, but would be with fscanf) or end of file */</span>
} <span class="hljs-keyword">else</span> {
   <span class="hljs-comment">/* format error (not possible with fgets, but would be with fscanf) */</span>
}
</code></pre>
    </div></div></div></div><div id="solution5" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h1 class="text-4xl font-semibold mb-5">Solution 5</h1><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/while-loop">while-loop</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/eof">eof</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/file">file</a><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/feof">feof</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p><code>feof()</code> is not very intuitive. In my very humble opinion, the <code>FILE</code>'s end-of-file state should be set to <code>true</code> if any read operation results in the end of file being reached. Instead, you have to manually check if the end of file has been reached after each read operation. For example, something like this will work if reading from a text file using <code>fgetc()</code>:</p>

<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span>

<span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span>
{
  FILE *in = fopen(<span class="hljs-string">"testfile.txt"</span>, <span class="hljs-string">"r"</span>);

  <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>) {
    <span class="hljs-type">char</span> c = fgetc(in);
    <span class="hljs-keyword">if</span> (feof(in)) <span class="hljs-keyword">break</span>;
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%c"</span>, c);
  }

  fclose(in);
  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>

<p>It would be great if something like this would work instead:</p>

<pre class="lang-c s-code-block"><code class="hljs language-c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span>

<span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span>
{
  FILE *in = fopen(<span class="hljs-string">"testfile.txt"</span>, <span class="hljs-string">"r"</span>);

  <span class="hljs-keyword">while</span>(!feof(in)) {
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%c"</span>, fgetc(in));
  }

  fclose(in);
  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>
    </div></div></div></div></div></div><div class="widget"><a href="/questions/default-constructor-with-empty-brackets-1657388246967">Default constructor with empty brackets</a><a href="/questions/read-file-line-by-line-using-ifstream-in-c++-1657388236966">Read file line by line using ifstream in C++</a><a href="/questions/how-do-i-pandas-group-by-to-get-sum-1657387908708">How do I Pandas group-by to get sum?</a><a href="/questions/safely-turning-a-json-string-into-an-object-1657388194824">Safely turning a JSON string into an object</a><a href="/questions/how-can-i-do-a-full-outer-join-in-mysql-1657388175444">How can I do a FULL OUTER JOIN in MySQL?</a><a href="/questions/what-is-the-difference-between-and-equals()-in-java-1657387729654">What is the difference between == and equals() in Java?</a><a href="/questions/how-to-make-a-div-100percent-height-of-the-browser-window-1657388265955">How to make a div 100% height of the browser window</a><a href="/questions/unfortunately-myapp-has-stopped.-how-can-i-solve-this-1657384402171">Unfortunately MyApp has stopped. How can I solve this?</a><a href="/questions/iterator-invalidation-rules-for-c++-containers-1657387561090">Iterator invalidation rules for C++ containers</a><a href="/questions/how-can-i-group-an-array-of-objects-by-key-1657388065372">How can I group an array of objects by key?</a><a href="/questions/how-to-extract-and-access-data-from-json-with-php-1657384483259">How to extract and access data from JSON with PHP?</a><a href="/questions/what-is-an-indexoutofrangeexception-argumentoutofrangeexception-and-how-do-i-fix-it-1657384697159">What is an IndexOutOfRangeException / ArgumentOutOfRangeException and how do I fix it?</a><a href="/questions/how-do-you-use-bcrypt-for-hashing-passwords-in-php-duplicate-1657387318517">How do you use bcrypt for hashing passwords in PHP? [duplicate]</a><a href="/questions/how-to-parse-json-in-java-1657384575136">How to parse JSON in Java</a><a href="/questions/how-to-use-java.util.scanner-to-correctly-read-user-input-from-system.in-and-act-on-it-1657388546306">How to use java.util.Scanner to correctly read user input from System.in and act on it?</a><a href="/questions/convert-rows-to-columns-using-&#x27;pivot&#x27;-in-sql-server-1657388372528">Convert Rows to columns using &#x27;Pivot&#x27; in SQL Server</a><a href="/questions/how-to-use-java.net.urlconnection-to-fire-and-handle-http-requests-1657387245934">How to use java.net.URLConnection to fire and handle HTTP requests</a><a href="/questions/how-to-get-the-difference-between-two-arrays-in-javascript-1657388463384">How to get the difference between two arrays in JavaScript?</a><a href="/questions/how-to-remove-all-duplicates-from-an-array-of-objects-1657388256190">How to remove all duplicates from an array of objects?</a><a href="/questions/how-can-i-access-and-process-nested-objects-arrays-or-json-1657384332823">How can I access and process nested objects, arrays, or JSON?</a></div></div><span class="cursor-pointer text-lg p-2" style="position:fixed;bottom:20px;left:20px;background:#000;z-index:2000;color:white">Go go top</span></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"data":{"answer":["\n\u0026lt;h3\u0026gt;TL;DR\u0026lt;/h3\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;code\u0026gt;while(!feof)\u0026lt;/code\u0026gt; is wrong because it tests for something that is irrelevant and fails to test for something that you need to know. The result is that you are erroneously executing code that assumes that it is accessing data that was read successfully, when in fact this never happened.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;I\u0026apos;d like to provide an abstract, high-level perspective. So continue reading if you\u0026apos;re interested in what \u0026lt;code\u0026gt;while(!feof)\u0026lt;/code\u0026gt; actually does.\u0026lt;/p\u0026gt;\n\u0026lt;h3\u0026gt;Concurrency and simultaneity\u0026lt;/h3\u0026gt;\n\u0026lt;p\u0026gt;I/O operations interact with the environment. The environment is not part of your program, and not under your control. The environment truly exists \u0026quot;concurrently\u0026quot; with your program. As with all things concurrent, questions about the \u0026quot;current state\u0026quot; don\u0026apos;t make sense: There is no concept of \u0026quot;simultaneity\u0026quot; across concurrent events. Many properties of state simply don\u0026apos;t \u0026lt;em\u0026gt;exist\u0026lt;/em\u0026gt; concurrently.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Let me make this more precise: Suppose you want to ask, \u0026quot;do you have more data\u0026quot;. You could ask this of a concurrent container, or of your I/O system. But the answer is generally unactionable, and thus meaningless. So what if the container says \u0026quot;yes\u0026quot;  by the time you try reading, it may no longer have data. Similarly, if the answer is \u0026quot;no\u0026quot;, by the time you try reading, data may have arrived. The conclusion is that there simply \u0026lt;em\u0026gt;is\u0026lt;/em\u0026gt; no property like \u0026quot;I have data\u0026quot;, since you cannot act meaningfully in response to any possible answer. (The situation is slightly better with buffered input, where you might conceivably get a \u0026quot;yes, I have data\u0026quot; that constitutes some kind of guarantee, but you would still have to be able to deal with the opposite case. And with output the situation is certainly just as bad as I described: you never know if that disk or that network buffer is full.)\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;So we conclude that it is impossible, and in fact un\u0026lt;em\u0026gt;reasonable\u0026lt;/em\u0026gt;, to ask an I/O system whether it \u0026lt;em\u0026gt;will be\u0026lt;/em\u0026gt; able to perform an I/O operation. The only possible way we can interact with it (just as with a concurrent container) is to \u0026lt;em\u0026gt;attempt\u0026lt;/em\u0026gt; the operation and check whether it succeeded or failed. At that moment where you interact with the environment, then and only then can you know whether the interaction was actually possible, and at that point you must commit to performing the interaction. (This is a \u0026quot;synchronisation point\u0026quot;, if you will.)\u0026lt;/p\u0026gt;\n\u0026lt;h3\u0026gt;EOF\u0026lt;/h3\u0026gt;\n\u0026lt;p\u0026gt;Now we get to EOF. EOF is the \u0026lt;em\u0026gt;response\u0026lt;/em\u0026gt; you get from an \u0026lt;em\u0026gt;attempted\u0026lt;/em\u0026gt; I/O operation. It means that you were trying to read or write something, but when doing so you failed to read or write any data, and instead the end of the input or output was encountered. This is true for essentially all the I/O APIs, whether it be the C standard library, C++ iostreams, or other libraries. As long as the I/O operations succeed, you simply \u0026lt;em\u0026gt;cannot know\u0026lt;/em\u0026gt; whether further, future operations will succeed. You \u0026lt;em\u0026gt;must\u0026lt;/em\u0026gt; always first try the operation and then respond to success or failure.\u0026lt;/p\u0026gt;\n\u0026lt;h3\u0026gt;Examples\u0026lt;/h3\u0026gt;\n\u0026lt;p\u0026gt;In each of the examples, note carefully that we \u0026lt;em\u0026gt;first\u0026lt;/em\u0026gt; attempt the I/O operation and \u0026lt;em\u0026gt;then\u0026lt;/em\u0026gt; consume the result if it is valid. Note further that we \u0026lt;em\u0026gt;always\u0026lt;/em\u0026gt; must use the result of the I/O operation, though the result takes different shapes and forms in each example.\u0026lt;/p\u0026gt;\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;C stdio, read from a file:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt; (;;) {\n      \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;size_t\u0026lt;/span\u0026gt; n = fread(buf, \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;, bufsize, infile);\n      consume(buf, n);\n      \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (n == \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;) { \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;break\u0026lt;/span\u0026gt;; }\n  }\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;The result we must use is \u0026lt;code\u0026gt;n\u0026lt;/code\u0026gt;, the number of elements that were read (which may be as little as zero).\u0026lt;/p\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;C stdio, \u0026lt;code\u0026gt;scanf\u0026lt;/code\u0026gt;:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt; (\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; a, b, c; \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;scanf\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;%d %d %d\u0026quot;\u0026lt;/span\u0026gt;, \u0026amp;amp;a, \u0026amp;amp;b, \u0026amp;amp;c) == \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3\u0026lt;/span\u0026gt;; ) {\n      consume(a, b, c);\n  }\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;The result we must use is the return value of \u0026lt;code\u0026gt;scanf\u0026lt;/code\u0026gt;, the number of elements converted.\u0026lt;/p\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;C++, iostreams formatted extraction:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt; (\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; n; \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;std\u0026lt;/span\u0026gt;::\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;cin\u0026lt;/span\u0026gt; \u0026amp;gt;\u0026amp;gt; n; ) {\n      consume(n);\n  }\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;The result we must use is \u0026lt;code\u0026gt;std::cin\u0026lt;/code\u0026gt; itself, which can be evaluated in a boolean context and tells us whether the stream is still in the \u0026lt;code\u0026gt;good()\u0026lt;/code\u0026gt; state.\u0026lt;/p\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;C++, iostreams getline:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt; (\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;std\u0026lt;/span\u0026gt;::\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;string\u0026lt;/span\u0026gt; line; \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;std\u0026lt;/span\u0026gt;::getline(\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;std\u0026lt;/span\u0026gt;::\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;cin\u0026lt;/span\u0026gt;, line); ) {\n      consume(line);\n  }\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;The result we must use is again \u0026lt;code\u0026gt;std::cin\u0026lt;/code\u0026gt;, just as before.\u0026lt;/p\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;POSIX, \u0026lt;code\u0026gt;write(2)\u0026lt;/code\u0026gt; to flush a buffer:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;  \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; * p = buf;\n  \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;ssize_t\u0026lt;/span\u0026gt; n = bufsize;\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt; (\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;ssize_t\u0026lt;/span\u0026gt; k = bufsize; (k = write(fd, p, n)) \u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;; p += k, n -= k) {}\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (n != \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;) { \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;/* error, failed to write complete buffer */\u0026lt;/span\u0026gt; }\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;The result we use here is \u0026lt;code\u0026gt;k\u0026lt;/code\u0026gt;, the number of bytes written. The point here is that we can only know how many bytes were written \u0026lt;em\u0026gt;after\u0026lt;/em\u0026gt; the write operation.\u0026lt;/p\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;POSIX \u0026lt;a href=\u0026quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/getline.html\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;\u0026lt;code\u0026gt;getline()\u0026lt;/code\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;  \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; *buffer = \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;NULL\u0026lt;/span\u0026gt;;\n  \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;size_t\u0026lt;/span\u0026gt; bufsiz = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;;\n  \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;ssize_t\u0026lt;/span\u0026gt; nbytes;\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;while\u0026lt;/span\u0026gt; ((nbytes = getline(\u0026amp;amp;buffer, \u0026amp;amp;bufsiz, fp)) != \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;-1\u0026lt;/span\u0026gt;)\n  {\n      \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;/* Use nbytes of data in buffer */\u0026lt;/span\u0026gt;\n  }\n  \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;free\u0026lt;/span\u0026gt;(buffer);\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;The result we must use is \u0026lt;code\u0026gt;nbytes\u0026lt;/code\u0026gt;, the number of bytes up to and including the newline (or EOF if the file did not end with a newline).\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Note that the function explicitly returns \u0026lt;code\u0026gt;-1\u0026lt;/code\u0026gt; (and not EOF!) when an error occurs or it reaches EOF.\u0026lt;/p\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;p\u0026gt;You may notice that we very rarely spell out the actual word \u0026quot;EOF\u0026quot;. We usually detect the error condition in some other way that is more immediately interesting to us (e.g. failure to perform as much I/O as we had desired). In every example there is some API feature that could tell us explicitly that the EOF state has been encountered, but this is in fact not a terribly useful piece of information. It is much more of a detail than we often care about. What matters is whether the I/O succeeded, more-so than how it failed.\u0026lt;/p\u0026gt;\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;A final example that actually queries the EOF state: Suppose you have a string and want to test that it represents an integer in its entirety, with no extra bits at the end except whitespace. Using C++ iostreams, it goes like this:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;  \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;std\u0026lt;/span\u0026gt;::\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;string\u0026lt;/span\u0026gt; input = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;   123   \u0026quot;\u0026lt;/span\u0026gt;;   \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// example\u0026lt;/span\u0026gt;\n\n  \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;std\u0026lt;/span\u0026gt;::\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;istringstream\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;iss\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(input)\u0026lt;/span\u0026gt;;\n  \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; value;\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (iss \u0026amp;gt;\u0026amp;gt; value \u0026amp;gt;\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;std\u0026lt;/span\u0026gt;::ws \u0026amp;amp;\u0026amp;amp; iss.get() == EOF) {\n      consume(value);\n  } \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;else\u0026lt;/span\u0026gt; {\n      \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// error, \u0026quot;input\u0026quot; is not parsable as an integer\u0026lt;/span\u0026gt;\n  }\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;p\u0026gt;We use two results here. The first is \u0026lt;code\u0026gt;iss\u0026lt;/code\u0026gt;, the stream object itself, to check that the formatted extraction to \u0026lt;code\u0026gt;value\u0026lt;/code\u0026gt; succeeded. But then, after also consuming whitespace, we perform another I/O/ operation, \u0026lt;code\u0026gt;iss.get()\u0026lt;/code\u0026gt;, and expect it to fail as EOF, which is the case if the entire string has already been consumed by the formatted extraction.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;In the C standard library you can achieve something similar with the \u0026lt;code\u0026gt;strto*l\u0026lt;/code\u0026gt; functions by checking that the end pointer has reached the end of the input string.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;It\u0026apos;s wrong because (in the absence of a read error) it enters the loop one more time than the author expects.  If there is a read error, the loop never terminates.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Consider the following code:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;/* WARNING: demonstration of bad coding technique!! */\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;stdio.h\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;stdlib.h\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\nFILE *\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;Fopen\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; *path, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; *mode)\u0026lt;/span\u0026gt;;\n\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;main\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; argc, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; **argv)\u0026lt;/span\u0026gt;\n{\n    FILE *in;\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;unsigned\u0026lt;/span\u0026gt; count;\n\n    in = argc \u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt; ? Fopen(argv[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;], \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;r\u0026quot;\u0026lt;/span\u0026gt;) : \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;stdin\u0026lt;/span\u0026gt;;\n    count = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;;\n\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;/* WARNING: this is a bug */\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;while\u0026lt;/span\u0026gt;( !feof(in) ) {  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;/* This is WRONG! */\u0026lt;/span\u0026gt;\n        fgetc(in);\n        count++;\n    }\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;printf\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Number of characters read: %u\\n\u0026quot;\u0026lt;/span\u0026gt;, count);\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; EXIT_SUCCESS;\n}\n\nFILE * \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;Fopen\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; *path, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; *mode)\u0026lt;/span\u0026gt;\n{\n    FILE *f = fopen(path, mode);\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt;( f == \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;NULL\u0026lt;/span\u0026gt; ) {\n        perror(path);\n        \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;exit\u0026lt;/span\u0026gt;(EXIT_FAILURE);\n    }\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; f;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;This program will consistently print one greater than the number of characters in the input stream (assuming no read errors).  Consider the case where the input stream is empty:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;$ ./a.out \u0026amp;lt; /dev/null\nNumber of characters read: \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;In this case, \u0026lt;code\u0026gt;feof()\u0026lt;/code\u0026gt; is called before any data has been read, so it returns false.  The loop is entered, \u0026lt;code\u0026gt;fgetc()\u0026lt;/code\u0026gt; is called (and returns \u0026lt;code\u0026gt;EOF\u0026lt;/code\u0026gt;), and count is incremented.  Then \u0026lt;code\u0026gt;feof()\u0026lt;/code\u0026gt; is called and returns true, causing the loop to abort.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;This happens in all such cases.  \u0026lt;code\u0026gt;feof()\u0026lt;/code\u0026gt; does not return true until \u0026lt;strong\u0026gt;after\u0026lt;/strong\u0026gt; a read on the stream encounters the end of file.  The purpose of \u0026lt;code\u0026gt;feof()\u0026lt;/code\u0026gt; is NOT to check if the next read will reach the end of file.  The purpose of \u0026lt;code\u0026gt;feof()\u0026lt;/code\u0026gt; is to determine the status of a previous read function\nand distinguish between an error condition and the end of the data stream.  If \u0026lt;code\u0026gt;fread()\u0026lt;/code\u0026gt; returns 0, you must use \u0026lt;code\u0026gt;feof\u0026lt;/code\u0026gt;/\u0026lt;code\u0026gt;ferror\u0026lt;/code\u0026gt; to decide whether an error occurred or if all of the data was consumed.  Similarly if \u0026lt;code\u0026gt;fgetc\u0026lt;/code\u0026gt; returns \u0026lt;code\u0026gt;EOF\u0026lt;/code\u0026gt;.  \u0026lt;code\u0026gt;feof()\u0026lt;/code\u0026gt; is only useful \u0026lt;strong\u0026gt;after\u0026lt;/strong\u0026gt; fread has returned zero or \u0026lt;code\u0026gt;fgetc\u0026lt;/code\u0026gt; has returned \u0026lt;code\u0026gt;EOF\u0026lt;/code\u0026gt;.  Before that happens, \u0026lt;code\u0026gt;feof()\u0026lt;/code\u0026gt; will always return 0.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;It is always necessary to check the return value of a read (either an \u0026lt;code\u0026gt;fread()\u0026lt;/code\u0026gt;, or an \u0026lt;code\u0026gt;fscanf()\u0026lt;/code\u0026gt;, or an \u0026lt;code\u0026gt;fgetc()\u0026lt;/code\u0026gt;) before calling \u0026lt;code\u0026gt;feof()\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Even worse, consider the case where a read error occurs.  In that case, \u0026lt;code\u0026gt;fgetc()\u0026lt;/code\u0026gt; returns \u0026lt;code\u0026gt;EOF\u0026lt;/code\u0026gt;, \u0026lt;code\u0026gt;feof()\u0026lt;/code\u0026gt; returns false, and the loop never terminates.  In all cases where \u0026lt;code\u0026gt;while(!feof(p))\u0026lt;/code\u0026gt; is used, there must be at least a check inside the loop for \u0026lt;code\u0026gt;ferror()\u0026lt;/code\u0026gt;, or at the very least the while condition should be replaced with \u0026lt;code\u0026gt;while(!feof(p) \u0026amp;amp;\u0026amp;amp; !ferror(p))\u0026lt;/code\u0026gt; or there is a very real possibility of an infinite loop, probably spewing all sorts of garbage as invalid data is being processed.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;So, in summary, although I cannot state with certainty that there is never a situation in which it may be semantically correct to write \u0026quot;\u0026lt;code\u0026gt;while(!feof(f))\u0026lt;/code\u0026gt;\u0026quot; (although there \u0026lt;strong\u0026gt;must\u0026lt;/strong\u0026gt; be another check inside the loop with a break to avoid a infinite loop on a read error), it is the case that it is almost certainly always wrong.  And even if a case ever arose where it would be correct, it is so idiomatically wrong that it would not be the right way to write the code.  Anyone seeing that code should immediately hesitate and say, \u0026quot;that\u0026apos;s a bug\u0026quot;.  And possibly slap the author (unless the author is your boss in which case discretion is advised.)\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;No it\u0026apos;s not always wrong. If your loop condition is \u0026quot;while we haven\u0026apos;t tried to read past end of file\u0026quot; then you use \u0026lt;code\u0026gt;while (!feof(f))\u0026lt;/code\u0026gt;. This is however not a common loop condition - usually you want to test for something else (such as \u0026quot;can I read more\u0026quot;). \u0026lt;code\u0026gt;while (!feof(f))\u0026lt;/code\u0026gt; isn\u0026apos;t wrong, it\u0026apos;s just \u0026lt;em\u0026gt;used\u0026lt;/em\u0026gt; wrong.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;\u0026lt;code\u0026gt;feof()\u0026lt;/code\u0026gt; indicates if one has tried to read past the end of file. That means it has little predictive effect: if it is true, you are sure that the next input operation will fail (you aren\u0026apos;t sure the previous one failed BTW), but if it is false, you aren\u0026apos;t sure the next input operation will succeed.  More over, input operations may fail for other reasons than the end of file (a format error for formatted input, a pure IO failure -- disk failure, network timeout -- for all input kinds), so even if you could be predictive about the end of file (and anybody who has tried to implement Ada one, which is predictive, will tell you it can complex if you need to skip spaces, and that it has undesirable effects on interactive devices -- sometimes forcing the input of the next line before starting the handling of the previous one), you would have to be able to handle a failure.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;So the correct idiom in C is to loop with the IO operation success as loop condition, and then test the cause of the failure.  For instance:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;while\u0026lt;/span\u0026gt; (fgets(line, \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;sizeof\u0026lt;/span\u0026gt;(line), file)) {\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;/* note that fgets don\u0026apos;t strip the terminating \\n, checking its\n       presence allow to handle lines longer that sizeof(line), not showed here */\u0026lt;/span\u0026gt;\n    ...\n}\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (ferror(file)) {\n   \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;/* IO failure */\u0026lt;/span\u0026gt;\n} \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;else\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (feof(file)) {\n   \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;/* format error (not possible with fgets, but would be with fscanf) or end of file */\u0026lt;/span\u0026gt;\n} \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;else\u0026lt;/span\u0026gt; {\n   \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;/* format error (not possible with fgets, but would be with fscanf) */\u0026lt;/span\u0026gt;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;\u0026lt;code\u0026gt;feof()\u0026lt;/code\u0026gt; is not very intuitive. In my very humble opinion, the \u0026lt;code\u0026gt;FILE\u0026lt;/code\u0026gt;\u0026apos;s end-of-file state should be set to \u0026lt;code\u0026gt;true\u0026lt;/code\u0026gt; if any read operation results in the end of file being reached. Instead, you have to manually check if the end of file has been reached after each read operation. For example, something like this will work if reading from a text file using \u0026lt;code\u0026gt;fgetc()\u0026lt;/code\u0026gt;:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;stdio.h\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;main\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; argc, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; *argv[])\u0026lt;/span\u0026gt;\n{\n  FILE *in = fopen(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;testfile.txt\u0026quot;\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;r\u0026quot;\u0026lt;/span\u0026gt;);\n\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;while\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;) {\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; c = fgetc(in);\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (feof(in)) \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;break\u0026lt;/span\u0026gt;;\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;printf\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;%c\u0026quot;\u0026lt;/span\u0026gt;, c);\n  }\n\n  fclose(in);\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;It would be great if something like this would work instead:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;stdio.h\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;main\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; argc, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; *argv[])\u0026lt;/span\u0026gt;\n{\n  FILE *in = fopen(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;testfile.txt\u0026quot;\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;r\u0026quot;\u0026lt;/span\u0026gt;);\n\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;while\u0026lt;/span\u0026gt;(!feof(in)) {\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;printf\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;%c\u0026quot;\u0026lt;/span\u0026gt;, fgetc(in));\n  }\n\n  fclose(in);\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    "],"id":39,"title":"Why is “while( !feof(file) )” always wrong?","content":"\n                \n\u0026lt;p\u0026gt;What is wrong with using \u0026lt;code\u0026gt;feof()\u0026lt;/code\u0026gt; to control a read loop?  For example:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-c s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-c\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;stdio.h\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;#\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;include\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026amp;lt;stdlib.h\u0026amp;gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;main\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; argc, \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; **argv)\u0026lt;/span\u0026gt;\n{\n    \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;char\u0026lt;/span\u0026gt; *path = \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;stdin\u0026quot;\u0026lt;/span\u0026gt;;\n    FILE *fp = argc \u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt; ? fopen(path=argv[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;], \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;r\u0026quot;\u0026lt;/span\u0026gt;) : \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;stdin\u0026lt;/span\u0026gt;;\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt;( fp == \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;NULL\u0026lt;/span\u0026gt; ){\n        perror(path);\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; EXIT_FAILURE;\n    }\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;while\u0026lt;/span\u0026gt;( !feof(fp) ){  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;/* THIS IS WRONG */\u0026lt;/span\u0026gt;\n        \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;/* Read and process data from file… */\u0026lt;/span\u0026gt;\n    }\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt;( fclose(fp) != \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt; ){\n        perror(path);\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; EXIT_FAILURE;\n    }\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; EXIT_SUCCESS;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;What is wrong with this loop?\u0026lt;/p\u0026gt;\n    ","slug":"why-is-\"while(-!feof(file)-)\"-always-wrong-1657384367349","postType":"QUESTION","createdAt":"2022-07-09T16:32:47.000Z","updatedAt":"2022-07-09T16:32:47.000Z","tags":[{"id":139,"name":"while-loop","slug":"while-loop","createdAt":"2022-07-09T16:32:47.000Z","updatedAt":"2022-07-09T16:32:47.000Z","Questions_Tags":{"questionId":39,"tagId":139}},{"id":140,"name":"eof","slug":"eof","createdAt":"2022-07-09T16:32:47.000Z","updatedAt":"2022-07-09T16:32:47.000Z","Questions_Tags":{"questionId":39,"tagId":140}},{"id":141,"name":"file","slug":"file","createdAt":"2022-07-09T16:32:47.000Z","updatedAt":"2022-07-09T16:32:47.000Z","Questions_Tags":{"questionId":39,"tagId":141}},{"id":142,"name":"feof","slug":"feof","createdAt":"2022-07-09T16:32:47.000Z","updatedAt":"2022-07-09T16:32:47.000Z","Questions_Tags":{"questionId":39,"tagId":142}}],"relatedQuestions":[{"title":"Why is “while( !feof(file) )” always wrong?","slug":"why-is-\"while(-!feof(file)-)\"-always-wrong-1657384367349","tags":[{"name":"while-loop","Questions_Tags":{"questionId":39,"tagId":139}},{"name":"eof","Questions_Tags":{"questionId":39,"tagId":140}},{"name":"file","Questions_Tags":{"questionId":39,"tagId":141}},{"name":"feof","Questions_Tags":{"questionId":39,"tagId":142}}]}]},"randomQuestions":[{"title":"Default constructor with empty brackets","slug":"default-constructor-with-empty-brackets-1657388246967"},{"title":"Read file line by line using ifstream in C++","slug":"read-file-line-by-line-using-ifstream-in-c++-1657388236966"},{"title":"How do I Pandas group-by to get sum?","slug":"how-do-i-pandas-group-by-to-get-sum-1657387908708"},{"title":"Safely turning a JSON string into an object","slug":"safely-turning-a-json-string-into-an-object-1657388194824"},{"title":"How can I do a FULL OUTER JOIN in MySQL?","slug":"how-can-i-do-a-full-outer-join-in-mysql-1657388175444"},{"title":"What is the difference between == and equals() in Java?","slug":"what-is-the-difference-between-and-equals()-in-java-1657387729654"},{"title":"How to make a div 100% height of the browser window","slug":"how-to-make-a-div-100percent-height-of-the-browser-window-1657388265955"},{"title":"Unfortunately MyApp has stopped. How can I solve this?","slug":"unfortunately-myapp-has-stopped.-how-can-i-solve-this-1657384402171"},{"title":"Iterator invalidation rules for C++ containers","slug":"iterator-invalidation-rules-for-c++-containers-1657387561090"},{"title":"How can I group an array of objects by key?","slug":"how-can-i-group-an-array-of-objects-by-key-1657388065372"},{"title":"How to extract and access data from JSON with PHP?","slug":"how-to-extract-and-access-data-from-json-with-php-1657384483259"},{"title":"What is an IndexOutOfRangeException / ArgumentOutOfRangeException and how do I fix it?","slug":"what-is-an-indexoutofrangeexception-argumentoutofrangeexception-and-how-do-i-fix-it-1657384697159"},{"title":"How do you use bcrypt for hashing passwords in PHP? [duplicate]","slug":"how-do-you-use-bcrypt-for-hashing-passwords-in-php-duplicate-1657387318517"},{"title":"How to parse JSON in Java","slug":"how-to-parse-json-in-java-1657384575136"},{"title":"How to use java.util.Scanner to correctly read user input from System.in and act on it?","slug":"how-to-use-java.util.scanner-to-correctly-read-user-input-from-system.in-and-act-on-it-1657388546306"},{"title":"Convert Rows to columns using 'Pivot' in SQL Server","slug":"convert-rows-to-columns-using-'pivot'-in-sql-server-1657388372528"},{"title":"How to use java.net.URLConnection to fire and handle HTTP requests","slug":"how-to-use-java.net.urlconnection-to-fire-and-handle-http-requests-1657387245934"},{"title":"How to get the difference between two arrays in JavaScript?","slug":"how-to-get-the-difference-between-two-arrays-in-javascript-1657388463384"},{"title":"How to remove all duplicates from an array of objects?","slug":"how-to-remove-all-duplicates-from-an-array-of-objects-1657388256190"},{"title":"How can I access and process nested objects, arrays, or JSON?","slug":"how-can-i-access-and-process-nested-objects-arrays-or-json-1657384332823"}]},"__N_SSG":true},"page":"/questions/[slug]","query":{"slug":"why-is-\"while(-!feof(file)-)\"-always-wrong-1657384367349"},"buildId":"00bsHgHZki2FteshOatnd","isFallback":false,"gsp":true,"locale":"en","locales":["en"],"defaultLocale":"en","scriptLoader":[]}</script></body></html>