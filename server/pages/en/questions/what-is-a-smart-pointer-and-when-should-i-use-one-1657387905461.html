<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><meta name="twitter:card" content="summary_large_image"/><meta name="twitter:site" content="@solutionschecker.com"/><meta name="twitter:creator" content="@solutionschecker.com"/><meta property="og:url" content="https://solutionschecker.com"/><meta property="og:type" content="website"/><meta property="og:image" content="https://solutionschecker.com/solutions-checker-banner.png"/><meta property="og:image:alt" content="Find solution for coding, HTML, CSS, JAVASCRIPT, MYSQL, PHP, PYTHON,... quickly. - solutionschecker.com"/><script type="application/ld+json">{"@context":"https://schema.org","@type":"Organization","logo":"/logo.svg","url":"https://solutionschecker.com"}</script><title>What is a smart pointer and when should I use one? | Solutions Checker</title><meta name="robots" content="index,follow"/><meta name="description" content="What is a smart pointer and when should I use one?
    "/><meta property="og:title" content="What is a smart pointer and when should I use one? | Solutions Checker"/><meta property="og:description" content="What is a smart pointer and when should I use one?
    "/><script type="application/ld+json">{"@context":"https://schema.org","@type":"QAPage","mainEntity":{"name":"What is a smart pointer and when should I use one?","text":"What is a smart pointer and when should I use one?\n    ","answerCount":14,"upVoteCount":500,"suggestedAnswer":[{"text":"UPDATE\n\nThis answer is rather old, and so describes what was &apos;good&apos; at the time, which was smart pointers provided by the Boost library. Since C++11, the standard library has provided sufficient smart pointers types, and so you should favour the use of std::unique_ptr, std::shared_ptr and std::weak_ptr. \n\nThere was also std::auto_ptr. It was very much like a scoped pointer, except that it also had the &quot;special&quot; dangerous ability to be copied  which also unexpectedly transfers ownership.\nIt was deprecated in C++11 and removed in C++17, so you shouldn&apos;t use it.\n\nstd::auto_ptr&lt;MyObject&gt; p1 (new MyObject());\nstd::auto_ptr&lt;MyObject&gt; p2 = p1; // Copy and transfer ownership. \n                                 // p1 gets set to empty!\np2-&gt;DoSomething(); // Works.\np1-&gt;DoSomething(); // Oh oh. Hopefully raises some NULL pointer exception.\n\n\n\n\nOLD ANSWER\n\nA smart pointer is a class that wraps a &apos;raw&apos; (or &apos;bare&apos;) C++ pointer, to manage the lifetime of the object being pointed to. There is no single smart pointer type, but all of them try to abstract a raw pointer in a practical way.\n\nSmart pointers should be preferred over raw pointers. If you feel you need to use pointers (first consider if you really do), you would normally want to use a smart pointer as this can alleviate many of the problems with raw pointers, mainly forgetting to delete the object and leaking memory.\n\nWith raw pointers, the programmer has to explicitly destroy the object when it is no longer useful.\n\n// Need to create the object to achieve some goal\nMyObject* ptr = new MyObject(); \nptr-&gt;DoSomething(); // Use the object in some way\ndelete ptr; // Destroy the object. Done with it.\n// Wait, what if DoSomething() raises an exception...?\n\n\nA smart pointer by comparison defines a policy as to when the object is destroyed. You still have to create the object, but you no longer have to worry about destroying it.\n\nSomeSmartPtr&lt;MyObject&gt; ptr(new MyObject());\nptr-&gt;DoSomething(); // Use the object in some way.\n\n// Destruction of the object happens, depending \n// on the policy the smart pointer class uses.\n\n// Destruction would happen even if DoSomething() \n// raises an exception\n\n\nThe simplest policy in use involves the scope of the smart pointer wrapper object, such as implemented by boost::scoped_ptr or std::unique_ptr. \n\nvoid f()\n{\n    {\n       std::unique_ptr&lt;MyObject&gt; ptr(new MyObject());\n       ptr-&gt;DoSomethingUseful();\n    } // ptr goes out of scope -- \n      // the MyObject is automatically destroyed.\n\n    // ptr-&gt;Oops(); // Compile error: &quot;ptr&quot; not defined\n                    // since it is no longer in scope.\n}\n\n\nNote that std::unique_ptr instances cannot be copied. This prevents the pointer from being deleted multiple times (incorrectly). You can, however, pass references to it around to other functions you call.\n\nstd::unique_ptrs are useful when you want to tie the lifetime of the object to a particular block of code, or if you embedded it as member data inside another object, the lifetime of that other object. The object exists until the containing block of code is exited, or until the containing object is itself destroyed.\n\nA more complex smart pointer policy involves reference counting the pointer. This does allow the pointer to be copied. When the last &quot;reference&quot; to the object is destroyed, the object is deleted. This policy is implemented by boost::shared_ptr and std::shared_ptr.\n\nvoid f()\n{\n    typedef std::shared_ptr&lt;MyObject&gt; MyObjectPtr; // nice short alias\n    MyObjectPtr p1; // Empty\n\n    {\n        MyObjectPtr p2(new MyObject());\n        // There is now one &quot;reference&quot; to the created object\n        p1 = p2; // Copy the pointer.\n        // There are now two references to the object.\n    } // p2 is destroyed, leaving one reference to the object.\n} // p1 is destroyed, leaving a reference count of zero. \n  // The object is deleted.\n\n\nReference counted pointers are very useful when the lifetime of your object is much more complicated, and is not tied directly to a particular section of code or to another object.\n\nThere is one drawback to reference counted pointers  the possibility of creating a dangling reference:\n\n// Create the smart pointer on the heap\nMyObjectPtr* pp = new MyObjectPtr(new MyObject())\n// Hmm, we forgot to destroy the smart pointer,\n// because of that, the object is never destroyed!\n\n\nAnother possibility is creating circular references:\n\nstruct Owner {\n   std::shared_ptr&lt;Owner&gt; other;\n};\n\nstd::shared_ptr&lt;Owner&gt; p1 (new Owner());\nstd::shared_ptr&lt;Owner&gt; p2 (new Owner());\np1-&gt;other = p2; // p1 references p2\np2-&gt;other = p1; // p2 references p1\n\n// Oops, the reference count of of p1 and p2 never goes to zero!\n// The objects are never destroyed!\n\n\nTo work around this problem, both Boost and C++11 have defined a weak_ptr to define a weak (uncounted) reference to a shared_ptr.\n    ","url":"/questions/[slug]#solution1","@type":"Answer","upvoteCount":0},{"text":"Here&apos;s a simple answer for these days of modern C++ (C++11 and later):\n\n&quot;What is a smart pointer?&quot; \nIt&apos;s a type whose values can be used like pointers, but which provides the additional feature of automatic memory management: When a smart pointer is no longer in use, the memory it points to is deallocated (see also the more detailed definition on Wikipedia).\n&quot;When should I use one?&quot; \nIn code which involves tracking the ownership of a piece of memory, allocating or de-allocating; the smart pointer often saves you the need to do these things explicitly.\n&quot;But which smart pointer should I use in which of those cases?&quot;\n\nUse std::unique_ptr when you want your object to live just as long as a single owning reference to it lives. For example, use it for a pointer to memory which gets allocated on entering some scope and de-allocated on exiting the scope.\nUse std::shared_ptr when you do want to refer to your object from multiple places - and do not want your object to be de-allocated until all these references are themselves gone.\nUse std::weak_ptr when you do want to refer to your object from multiple places - for those references for which it&apos;s ok to ignore and deallocate (so they&apos;ll just note the object is gone when you try to dereference).\nDon&apos;t use the boost:: smart pointers or std::auto_ptr except in special cases which you can read up on if you must.\n\n\n&quot;Hey, I didn&apos;t ask which one to use!&quot; \nAh, but you really wanted to, admit it.\n&quot;So when should I use regular pointers then?&quot; \nMostly in code that is oblivious to memory ownership. This would typically be in functions which get a pointer from someplace else and do not allocate nor de-allocate, and do not store a copy of the pointer which outlasts their execution.\n\n    ","url":"/questions/[slug]#solution2","@type":"Answer","upvoteCount":0},{"text":"A smart pointer is a pointer-like type with some additional functionality, e.g. automatic memory deallocation, reference counting etc.\nA small intro is available on the page Smart Pointers - What, Why, Which?.\nOne of the simple smart-pointer types is std::auto_ptr (chapter 20.4.5 of C++ standard), which allows one to deallocate memory automatically when it out of scope and which is more robust than simple pointer usage when exceptions are thrown, although less flexible.\nAnother convenient type is boost::shared_ptr which implements reference counting and automatically deallocates memory when no references to the object remains. This helps avoiding memory leaks and is easy to use to implement RAII.\nThe subject is covered in depth in book &quot;C++ Templates: The Complete Guide&quot; by David Vandevoorde, Nicolai M. Josuttis, chapter Chapter 20. Smart Pointers.\nSome topics covered:\n\nProtecting Against Exceptions\nHolders, (note, std::auto_ptr is implementation of such type of smart pointer)\nResource Acquisition Is Initialization (This is frequently used for exception-safe resource management in C++)\nHolder Limitations\nReference Counting\nConcurrent Counter Access\nDestruction and Deallocation\n\n    ","url":"/questions/[slug]#solution3","@type":"Answer","upvoteCount":0},{"text":"Definitions provided by Chris, Sergdev and Llyod are correct. I prefer a simpler definition though, just to keep my life simple:\nA smart pointer is simply a class that overloads the -&gt;  and * operators. Which means that your object semantically looks like a pointer but you can make it do way cooler things, including reference counting, automatic destruction etc.\nshared_ptr and auto_ptr are sufficient in most cases, but come along with their own set of small idiosyncrasies.\n    ","url":"/questions/[slug]#solution4","@type":"Answer","upvoteCount":0},{"text":"A smart pointer is like a regular (typed) pointer, like &quot;char*&quot;, except when the pointer itself goes out of scope then what it points to is deleted as well. You can use it like you would a regular pointer, by using &quot;-&gt;&quot;, but not if you need an actual pointer to the data. For that, you can use &quot;&amp;*ptr&quot;.\n\nIt is useful for:\n\n\nObjects that must be allocated with new, but that you&apos;d like to have the same lifetime as something on that stack. If the object is assigned to a smart pointer, then they will be deleted when the program exits that function/block.\nData members of classes, so that when the object is deleted all the owned data is deleted as well, without any special code in the destructor (you will need to be sure the destructor is virtual, which is almost always a good thing to do).\n\n\nYou may not want to use a smart pointer when:\n\n\n... the pointer shouldn&apos;t actually own the data... i.e., when you are just using the data, but you want it to survive the function where you are referencing it.\n... the smart pointer isn&apos;t itself going to be destroyed at some point. You don&apos;t want it to sit in memory that never gets destroyed (such as in an object that is dynamically allocated but won&apos;t be explicitly deleted).\n... two smart pointers might point to the same data. (There are, however, even smarter pointers that will handle that... that is called reference counting.)\n\n\nSee also:\n\n\ngarbage collection.\nThis stack overflow question regarding data ownership\n\n    ","url":"/questions/[slug]#solution5","@type":"Answer","upvoteCount":0},{"text":"A smart pointer is an object that acts like a pointer, but additionally provides control on construction, destruction, copying, moving and dereferencing.\n\nOne can implement one&apos;s own smart pointer, but many libraries also provide smart pointer implementations each with different advantages and drawbacks.\n\nFor example, Boost provides the following smart pointer implementations:\n\n\nshared_ptr&lt;T&gt; is a pointer to T using a reference count to determine when the object is no longer needed.\nscoped_ptr&lt;T&gt; is a pointer automatically deleted when it goes out of scope. No assignment is possible.\nintrusive_ptr&lt;T&gt; is another reference counting pointer. It provides better performance than shared_ptr, but requires the type T to provide its own reference counting mechanism.\nweak_ptr&lt;T&gt; is a weak pointer, working in conjunction with shared_ptr to avoid circular references.\nshared_array&lt;T&gt; is like shared_ptr, but for arrays of T.\nscoped_array&lt;T&gt; is like scoped_ptr, but for arrays of T.\n\n\nThese are just one linear descriptions of each and can be used as per need, for further detail and examples one can look at the documentation of Boost.\n\nAdditionally, the C++ standard library provides three smart pointers; std::unique_ptr for unique ownership, std::shared_ptr for shared ownership and std::weak_ptr. std::auto_ptr existed in C++03 but is now deprecated.\n    ","url":"/questions/[slug]#solution6","@type":"Answer","upvoteCount":0},{"text":"Most kinds of smart pointers handle disposing of the pointer-to object for you. It&apos;s very handy because you don&apos;t have to think about disposing of objects manually anymore.\n\nThe most commonly-used smart pointers are std::tr1::shared_ptr (or boost::shared_ptr), and, less commonly, std::auto_ptr. I recommend regular use of shared_ptr.\n\nshared_ptr is very versatile and deals with a large variety of disposal scenarios, including cases where objects need to be &quot;passed across DLL boundaries&quot; (the common nightmare case if different libcs are used between your code and the DLLs).\n    ","url":"/questions/[slug]#solution7","@type":"Answer","upvoteCount":0},{"text":"Here is the Link for similar answers : http://sickprogrammersarea.blogspot.in/2014/03/technical-interview-questions-on-c_6.html\n\nA smart pointer is an object that acts, looks and feels like a normal pointer but offers more functionality. In C++, smart pointers are implemented as template classes that encapsulate a pointer and override standard pointer operators. They have a number of advantages over regular pointers. They are guaranteed to be initialized as either null pointers or pointers to a heap object. Indirection through a null pointer is checked. No delete is ever necessary. Objects are automatically freed when the last pointer to them has gone away. One significant problem with these smart pointers is that unlike regular pointers, they don&apos;t respect inheritance. Smart pointers are unattractive for polymorphic code. Given below is an example for the implementation of smart pointers.\n\nExample: \n\ntemplate &lt;class X&gt;\nclass smart_pointer\n{\n          public:\n               smart_pointer();                          // makes a null pointer\n               smart_pointer(const X&amp; x)            // makes pointer to copy of x\n\n               X&amp; operator *( );\n               const X&amp; operator*( ) const;\n               X* operator-&gt;() const;\n\n               smart_pointer(const smart_pointer &lt;X&gt; &amp;);\n               const smart_pointer &lt;X&gt; &amp; operator =(const smart_pointer&lt;X&gt;&amp;);\n               ~smart_pointer();\n          private:\n               //...\n};\n\n\nThis class implement a smart pointer to an object of type X. The object itself is located on the heap. Here is how to use it:\n\nsmart_pointer &lt;employee&gt; p= employee(&quot;Harris&quot;,1333);\n\n\nLike other overloaded operators, p will behave like a regular pointer,\n\ncout&lt;&lt;*p;\np-&gt;raise_salary(0.5);\n\n    ","url":"/questions/[slug]#solution8","@type":"Answer","upvoteCount":0},{"text":"Let T be a class in this tutorial \nPointers in C++ can be divided into 3 types :\n\n1) Raw pointers :\n\nT a;  \nT * _ptr = &amp;a; \n\n\nThey hold a memory address to a location in memory. Use with caution , as programs become complex hard to keep track. \n\nPointers with const data or address { Read backwards } \n\nT a ; \nconst T * ptr1 = &amp;a ; \nT const * ptr1 = &amp;a ;\n\n\nPointer to a data type T which is a const. Meaning you cannot change the data type using the pointer. ie *ptr1 = 19 ; will not work. But you can move the pointer. ie ptr1++ , ptr1-- ;  etc will work.\nRead backwards : pointer to type T which is const \n\n  T * const ptr2 ;\n\n\nA const pointer to a data type T . Meaning you cannot move the pointer but you can change the value pointed to by the pointer. ie *ptr2 = 19 will work but ptr2++ ; ptr2-- etc will not work. Read backwards : const pointer to a type T \n\nconst T * const ptr3 ; \n\n\nA const pointer to a const data type T . Meaning you cannot either move the pointer nor can you change the data type pointer to be the pointer. ie . ptr3-- ; ptr3++ ; *ptr3 = 19; will not work \n\n3) Smart Pointers : { #include &lt;memory&gt; } \n\nShared Pointer: \n\n  T a ; \n     //shared_ptr&lt;T&gt; shptr(new T) ; not recommended but works \n     shared_ptr&lt;T&gt; shptr = make_shared&lt;T&gt;(); // faster + exception safe\n\n     std::cout &lt;&lt; shptr.use_count() ; // 1 //  gives the number of &quot; \nthings &quot; pointing to it. \n     T * temp = shptr.get(); // gives a pointer to object\n\n     // shared_pointer used like a regular pointer to call member functions\n      shptr-&gt;memFn();\n     (*shptr).memFn(); \n\n    //\n     shptr.reset() ; // frees the object pointed to be the ptr \n     shptr = nullptr ; // frees the object \n     shptr = make_shared&lt;T&gt;() ; // frees the original object and points to new object\n\n\nImplemented using reference counting to keep track of how many &quot; things &quot; point to the object pointed to by the pointer. When this count goes to 0 , the object is automatically deleted , ie objected is deleted when all the share_ptr pointing to the object goes out of scope. \nThis gets rid of the headache of having to delete objects which you have allocated using new. \n\nWeak Pointer : \n    Helps deal with cyclic reference which arises when using Shared Pointer\n    If you have two objects pointed to by two shared pointers and there is an internal shared pointer pointing to each others shared pointer then there will be a cyclic reference and the object will not be deleted when shared pointers go out of scope. To solve this , change the internal member from a shared_ptr to weak_ptr. Note : To access the element pointed to by a weak pointer use lock() , this returns a weak_ptr. \n\nT a ; \nshared_ptr&lt;T&gt; shr = make_shared&lt;T&gt;() ; \nweak_ptr&lt;T&gt; wk = shr ; // initialize a weak_ptr from a shared_ptr \nwk.lock()-&gt;memFn() ; // use lock to get a shared_ptr \n//   ^^^ Can lead to exception if the shared ptr has gone out of scope\nif(!wk.expired()) wk.lock()-&gt;memFn() ;\n// Check if shared ptr has gone out of scope before access\n\n\nSee : When is std::weak_ptr useful?\n\nUnique Pointer : \n    Light weight smart pointer with exclusive ownership. Use when pointer points to unique objects without sharing the objects between the pointers.\n\nunique_ptr&lt;T&gt; uptr(new T);\nuptr-&gt;memFn(); \n\n//T * ptr = uptr.release(); // uptr becomes null and object is pointed to by ptr\nuptr.reset() ; // deletes the object pointed to by uptr \n\n\nTo change the object pointed to by the unique ptr , use move semantics\n\nunique_ptr&lt;T&gt; uptr1(new T);\nunique_ptr&lt;T&gt; uptr2(new T);\nuptr2 = std::move(uptr1); \n// object pointed by uptr2 is deleted and \n// object pointed by uptr1 is pointed to by uptr2\n// uptr1 becomes null \n\n\nReferences : \n    They can essentially be though of as const pointers, ie a pointer which is const and cannot be moved with better syntax.\n\nSee : What are the differences between a pointer variable and a reference variable in C++?  \n\nr-value reference : reference to a temporary object   \nl-value reference : reference to an object whose address can be obtained\nconst reference : reference to a data type which is const and cannot be modified \n\n\nReference : \nhttps://www.youtube.com/channel/UCEOGtxYTB6vo6MQ-WQ9W_nQ \nThanks to Andre for pointing out this question.\n    ","url":"/questions/[slug]#solution9","@type":"Answer","upvoteCount":0},{"text":"http://en.wikipedia.org/wiki/Smart_pointer\n\n\n  In computer science, a smart pointer\n  is an abstract data type that\n  simulates a pointer while providing\n  additional features, such as automatic\n  garbage collection or bounds checking.\n  These additional features are intended\n  to reduce bugs caused by the misuse of\n  pointers while retaining efficiency.\n  Smart pointers typically keep track of\n  the objects that point to them for the\n  purpose of memory management. The\n  misuse of pointers is a major source\n  of bugs: the constant allocation,\n  deallocation and referencing that must\n  be performed by a program written\n  using pointers makes it very likely\n  that some memory leaks will occur.\n  Smart pointers try to prevent memory\n  leaks by making the resource\n  deallocation automatic: when the\n  pointer to an object (or the last in a\n  series of pointers) is destroyed, for\n  example because it goes out of scope,\n  the pointed object is destroyed too.\n\n    ","url":"/questions/[slug]#solution10","@type":"Answer","upvoteCount":0},{"text":"A smart pointer is a class, a wrapper of a normal pointer. Unlike normal pointers, smart points life circle is based on a reference count (how many time the smart pointer object is assigned). So whenever a smart pointer is assigned to another one, the internal reference count plus plus. And whenever the object goes out of scope, the reference count minus minus.\n\nAutomatic pointer, though looks similar, is totally different from smart pointer. It is a convenient class that deallocates the resource whenever an automatic pointer object goes out of variable scope. To some extent, it makes a pointer (to dynamically allocated memory) works similar to a stack variable (statically allocated in compiling time).\n    ","url":"/questions/[slug]#solution11","@type":"Answer","upvoteCount":0},{"text":"What is a smart pointer.\nLong version, In principle:\nhttps://web.stanford.edu/class/archive/cs/cs106l/cs106l.1192/lectures/lecture15/15_RAII.pdf\nA modern C++ idiom:\nRAII: Resource Acquisition Is Initialization.\n\n When you initialize an object, it should already have \n  acquired any resources it needs (in the constructor).\n\n\n When an object goes out of scope, it should release every \n  resource it is using (using the destructor).\n\nkey point:\n There should never be a half-ready or half-dead object.\n When an object is created, it should be in a ready state.\n When an object goes out of scope, it should release its resources. \n The user shouldnt have to do anything more. \n\nRaw Pointers violate RAII: It need user to delete manually when the pointers go out of scope.\nRAII solution is:\nHave a smart pointer class:\n Allocates the memory when initialized\n Frees the memory when destructor is called\n Allows access to underlying pointer\n\nFor smart pointer need copy and share, use shared_ptr:\n use another memory to store Reference counting and shared.\n increment when copy, decrement when destructor.\n delete memory when Reference counting is 0. \n  also delete memory that store Reference counting.\n\nfor smart pointer not own the raw pointer, use weak_ptr:\n not change Reference counting.\n\nshared_ptr usage:\ncorrect way:\nstd::shared_ptr&lt;T&gt; t1 = std::make_shared&lt;T&gt;(TArgs);\nstd::shared_ptr&lt;T&gt; t2 = std::shared_ptr&lt;T&gt;(new T(Targs));\n\nwrong way:\nT* pt = new T(TArgs); // never exposure the raw pointer\nshared_ptr&lt;T&gt; t1 = shared_ptr&lt;T&gt;(pt);\nshared_ptr&lt;T&gt; t2 = shared_ptr&lt;T&gt;(pt);\n\nAlways avoid using raw pointer.\nFor scenario that have to use raw pointer:\nhttps://stackoverflow.com/a/19432062/2482283\nFor raw pointer that not nullptr, use reference instead.\nnot use T*\nuse T&amp;  \n\nFor optional reference which maybe nullptr, use raw pointer, and which means:\nT* pt; is optional reference and maybe nullptr.\nNot own the raw pointer, \nRaw pointer is managed by some one else.\nI only know that the caller is sure it is not released now.\n\n    ","url":"/questions/[slug]#solution12","@type":"Answer","upvoteCount":0},{"text":"Smart Pointers are those where you don&apos;t have to worry about Memory De-Allocation, Resource Sharing and Transfer. \n\nYou can very well use these pointer in the similar way as any allocation works in Java. In java Garbage Collector does the trick, while in Smart Pointers, the trick is done by Destructors.\n    ","url":"/questions/[slug]#solution13","@type":"Answer","upvoteCount":0},{"text":"The existing answers are good but don&apos;t cover what to do when a smart pointer is not the (complete) answer to the problem you are trying to solve.\n\nAmong other things (explained well in other answers) using a smart pointer is a possible solution to How do we use a abstract class as a function return type? which has been marked as a duplicate of this question. However, the first question to ask if tempted to specify an abstract (or in fact, any) base class as a return type in C++ is &quot;what do you really mean?&quot;. There is a good discussion (with further references) of idiomatic object oriented programming in C++ (and how this is different to other languages) in the documentation of the boost pointer container library. In summary, in C++ you have to think about ownership. Which smart pointers help you with, but are not the only solution, or always a complete solution (they don&apos;t give you polymorphic copy) and are not always a solution you want to expose in your interface (and a function return sounds an awful lot like an interface). It might be sufficient to return a reference, for example. But in all of these cases (smart pointer, pointer container or simply returning a reference) you have changed the return from a value to some form of reference. If you really needed copy you may need to add more boilerplate &quot;idiom&quot; or move beyond idiomatic (or otherwise) OOP in C++ to more generic polymorphism using libraries like Adobe Poly or Boost.TypeErasure.\n    ","url":"/questions/[slug]#solution14","@type":"Answer","upvoteCount":0}],"@type":"Question"}}</script><meta name="next-head-count" content="16"/><link rel="preload" href="/_next/static/css/08bcc42a26fe5c92.css" as="style"/><link rel="stylesheet" href="/_next/static/css/08bcc42a26fe5c92.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-0d1b80a048d4787e.js"></script><script src="/_next/static/chunks/webpack-42cdea76c8170223.js" defer=""></script><script src="/_next/static/chunks/framework-4556c45dd113b893.js" defer=""></script><script src="/_next/static/chunks/main-ccfab947c79712f4.js" defer=""></script><script src="/_next/static/chunks/pages/_app-08d1a634dea6705e.js" defer=""></script><script src="/_next/static/chunks/29107295-fbcfe2172188e46f.js" defer=""></script><script src="/_next/static/chunks/150-b06815e21c943e0d.js" defer=""></script><script src="/_next/static/chunks/490-7f0418bb4354ac73.js" defer=""></script><script src="/_next/static/chunks/108-87de33c23337ff53.js" defer=""></script><script src="/_next/static/chunks/pages/questions/%5Bslug%5D-79a1437acf654019.js" defer=""></script><script src="/_next/static/Zo3C7AOWQzKM9qqyzx2hf/_buildManifest.js" defer=""></script><script src="/_next/static/Zo3C7AOWQzKM9qqyzx2hf/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="wrapper"><header><nav class="bg-white border-gray-200 px-4 lg:px-6 py-2.5 dark:bg-gray-800"><div class="flex flex-wrap justify-between items-center mx-auto max-w-screen-xl"><a class="flex items-center" href="/"><img src="/logo-second.png" class="mr-3 h-6 sm:h-9" alt="Solution Checker Logo"/><h4 class="self-center text-xl font-semibold whitespace-nowrap dark:text-white">Solution Checker</h4></a><div class="flex items-center lg:order-2"><button data-collapse-toggle="mobile-menu-2" type="button" class="inline-flex items-center p-2 ml-1 text-sm text-gray-500 rounded-lg lg:hidden hover:bg-gray-100 focus:outline-none focus:ring-2 focus:ring-gray-200 dark:text-gray-400 dark:hover:bg-gray-700 dark:focus:ring-gray-600" aria-controls="mobile-menu-2" aria-expanded="false"><span class="sr-only">Open main menu</span><svg class="w-6 h-6" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M3 5a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM3 10a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM3 15a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1z" clip-rule="evenodd"></path></svg><svg class="hidden w-6 h-6" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z" clip-rule="evenodd"></path></svg></button></div><div class="hidden justify-between items-center w-full lg:flex lg:w-auto lg:order-1" id="mobile-menu-2"><ul class="flex flex-col mt-4 font-medium lg:flex-row lg:space-x-8 lg:mt-0"><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" aria-current="page" href="/">Home</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/questions?tab=news">Questions</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/post?tab=news">Post</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/questions/what-is-a-smart-pointer-and-when-should-i-use-one-1657387905461#">Coding</a></li></ul></div></div></nav></header><div class="main-content"><div class="question my-5"><div class="flex question-header items-center m-auto justify-center"><div class="rounded-xl w-full border p-5 shadow-md bg-white"><div class="flex w-full items-center justify-between border-b pb-3"><div class="flex items-center space-x-3"><div class="text-lg font-bold text-slate-700"><a href="/questions/what-is-a-smart-pointer-and-when-should-i-use-one-1657387905461"><h1>What is a smart pointer and when should I use one?</h1></a></div></div><div class="flex flex-wrap h-auto justify-end items-center space-x-8"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold" href="/questions/tag/smart-pointers">smart-pointers</a></div></div><div class="question-content mt-5">
                
<p>What is a smart pointer and when should I use one?</p>
    </div></div></div><div class="solution-section"><nav class="flex pagination-solution flex-col justify-end"><ul class="inline-flex -space-x-px overflow-auto"><li class="pagination-solution-item"><span data-id="#solution1" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">1</span></li><li class="pagination-solution-item"><span data-id="#solution2" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">2</span></li><li class="pagination-solution-item"><span data-id="#solution3" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">3</span></li><li class="pagination-solution-item"><span data-id="#solution4" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">4</span></li><li class="pagination-solution-item"><span data-id="#solution5" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">5</span></li><li class="pagination-solution-item"><span data-id="#solution6" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">6</span></li><li class="pagination-solution-item"><span data-id="#solution7" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">7</span></li><li class="pagination-solution-item"><span data-id="#solution8" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">8</span></li><li class="pagination-solution-item"><span data-id="#solution9" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">9</span></li><li class="pagination-solution-item"><span data-id="#solution10" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">10</span></li><li class="pagination-solution-item"><span data-id="#solution11" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">11</span></li><li class="pagination-solution-item"><span data-id="#solution12" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">12</span></li><li class="pagination-solution-item"><span data-id="#solution13" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">13</span></li><li class="pagination-solution-item"><span data-id="#solution14" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">14</span></li></ul></nav><div id="solution1" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 1</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/smart-pointers">smart-pointers</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p><strong>UPDATE</strong></p>

<p>This answer is rather old, and so describes what was 'good' at the time, which was smart pointers provided by the Boost library. Since C++11, the standard library has provided sufficient smart pointers types, and so you should favour the use of <a href="http://en.cppreference.com/w/cpp/memory/unique_ptr" rel="noreferrer"><code>std::unique_ptr</code></a>, <a href="http://en.cppreference.com/w/cpp/memory/shared_ptr" rel="noreferrer"><code>std::shared_ptr</code></a> and <a href="http://en.cppreference.com/w/cpp/memory/weak_ptr" rel="noreferrer"><code>std::weak_ptr</code></a>. </p>

<p>There was also <a href="http://en.cppreference.com/w/cpp/memory/auto_ptr" rel="noreferrer"><code>std::auto_ptr</code></a>. It was very much like a scoped pointer, except that it also had the "special" dangerous ability to be copied  which also unexpectedly transfers ownership.<br>
<strong>It was deprecated in C++11 and removed in C++17</strong>, so you shouldn't use it.</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-function">std::auto_ptr&lt;MyObject&gt; <span class="hljs-title">p1</span> <span class="hljs-params">(<span class="hljs-keyword">new</span> MyObject())</span></span>;
std::auto_ptr&lt;MyObject&gt; p2 = p1; <span class="hljs-comment">// Copy and transfer ownership. </span>
                                 <span class="hljs-comment">// p1 gets set to empty!</span>
p2-&gt;<span class="hljs-built_in">DoSomething</span>(); <span class="hljs-comment">// Works.</span>
p1-&gt;<span class="hljs-built_in">DoSomething</span>(); <span class="hljs-comment">// Oh oh. Hopefully raises some NULL pointer exception.</span>
</code></pre>

<hr>

<p><strong>OLD ANSWER</strong></p>

<p>A smart pointer is a class that wraps a 'raw' (or 'bare') C++ pointer, to manage the lifetime of the object being pointed to. There is no single smart pointer type, but all of them try to abstract a raw pointer in a practical way.</p>

<p>Smart pointers should be preferred over raw pointers. If you feel you need to use pointers (first consider if you <em>really</em> do), you would normally want to use a smart pointer as this can alleviate many of the problems with raw pointers, mainly forgetting to delete the object and leaking memory.</p>

<p>With raw pointers, the programmer has to explicitly destroy the object when it is no longer useful.</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-comment">// Need to create the object to achieve some goal</span>
MyObject* ptr = <span class="hljs-keyword">new</span> <span class="hljs-built_in">MyObject</span>(); 
ptr-&gt;<span class="hljs-built_in">DoSomething</span>(); <span class="hljs-comment">// Use the object in some way</span>
<span class="hljs-keyword">delete</span> ptr; <span class="hljs-comment">// Destroy the object. Done with it.</span>
<span class="hljs-comment">// Wait, what if DoSomething() raises an exception...?</span>
</code></pre>

<p>A smart pointer by comparison defines a policy as to when the object is destroyed. You still have to create the object, but you no longer have to worry about destroying it.</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-function">SomeSmartPtr&lt;MyObject&gt; <span class="hljs-title">ptr</span><span class="hljs-params">(<span class="hljs-keyword">new</span> MyObject())</span></span>;
ptr-&gt;<span class="hljs-built_in">DoSomething</span>(); <span class="hljs-comment">// Use the object in some way.</span>

<span class="hljs-comment">// Destruction of the object happens, depending </span>
<span class="hljs-comment">// on the policy the smart pointer class uses.</span>

<span class="hljs-comment">// Destruction would happen even if DoSomething() </span>
<span class="hljs-comment">// raises an exception</span>
</code></pre>

<p>The simplest policy in use involves the scope of the smart pointer wrapper object, such as implemented by <a href="http://www.boost.org/doc/libs/release/libs/smart_ptr/scoped_ptr.htm" rel="noreferrer"><code>boost::scoped_ptr</code></a> or <a href="http://en.cppreference.com/w/cpp/memory/unique_ptr" rel="noreferrer"><code>std::unique_ptr</code></a>. </p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span>
</span>{
    {
       <span class="hljs-function">std::unique_ptr&lt;MyObject&gt; <span class="hljs-title">ptr</span><span class="hljs-params">(<span class="hljs-keyword">new</span> MyObject())</span></span>;
       ptr-&gt;<span class="hljs-built_in">DoSomethingUseful</span>();
    } <span class="hljs-comment">// ptr goes out of scope -- </span>
      <span class="hljs-comment">// the MyObject is automatically destroyed.</span>

    <span class="hljs-comment">// ptr-&gt;Oops(); // Compile error: "ptr" not defined</span>
                    <span class="hljs-comment">// since it is no longer in scope.</span>
}
</code></pre>

<p>Note that <code>std::unique_ptr</code> instances cannot be copied. This prevents the pointer from being deleted multiple times (incorrectly). You can, however, pass references to it around to other functions you call.</p>

<p><code>std::unique_ptr</code>s are useful when you want to tie the lifetime of the object to a particular block of code, or if you embedded it as member data inside another object, the lifetime of that other object. The object exists until the containing block of code is exited, or until the containing object is itself destroyed.</p>

<p>A more complex smart pointer policy involves reference counting the pointer. This does allow the pointer to be copied. When the last "reference" to the object is destroyed, the object is deleted. This policy is implemented by <a href="http://www.boost.org/doc/libs/release/libs/smart_ptr/shared_ptr.htm" rel="noreferrer"><code>boost::shared_ptr</code></a> and <a href="http://en.cppreference.com/w/cpp/memory/shared_ptr" rel="noreferrer"><code>std::shared_ptr</code></a>.</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-keyword">typedef</span> std::shared_ptr&lt;MyObject&gt; MyObjectPtr; <span class="hljs-comment">// nice short alias</span>
    MyObjectPtr p1; <span class="hljs-comment">// Empty</span>

    {
        <span class="hljs-function">MyObjectPtr <span class="hljs-title">p2</span><span class="hljs-params">(<span class="hljs-keyword">new</span> MyObject())</span></span>;
        <span class="hljs-comment">// There is now one "reference" to the created object</span>
        p1 = p2; <span class="hljs-comment">// Copy the pointer.</span>
        <span class="hljs-comment">// There are now two references to the object.</span>
    } <span class="hljs-comment">// p2 is destroyed, leaving one reference to the object.</span>
} <span class="hljs-comment">// p1 is destroyed, leaving a reference count of zero. </span>
  <span class="hljs-comment">// The object is deleted.</span>
</code></pre>

<p>Reference counted pointers are very useful when the lifetime of your object is much more complicated, and is not tied directly to a particular section of code or to another object.</p>

<p>There is one drawback to reference counted pointers  the possibility of creating a dangling reference:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-comment">// Create the smart pointer on the heap</span>
MyObjectPtr* pp = <span class="hljs-keyword">new</span> <span class="hljs-built_in">MyObjectPtr</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">MyObject</span>())
<span class="hljs-comment">// Hmm, we forgot to destroy the smart pointer,</span>
<span class="hljs-comment">// because of that, the object is never destroyed!</span>
</code></pre>

<p>Another possibility is creating circular references:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Owner</span> {
   std::shared_ptr&lt;Owner&gt; other;
};

<span class="hljs-function">std::shared_ptr&lt;Owner&gt; <span class="hljs-title">p1</span> <span class="hljs-params">(<span class="hljs-keyword">new</span> Owner())</span></span>;
<span class="hljs-function">std::shared_ptr&lt;Owner&gt; <span class="hljs-title">p2</span> <span class="hljs-params">(<span class="hljs-keyword">new</span> Owner())</span></span>;
p1-&gt;other = p2; <span class="hljs-comment">// p1 references p2</span>
p2-&gt;other = p1; <span class="hljs-comment">// p2 references p1</span>

<span class="hljs-comment">// Oops, the reference count of of p1 and p2 never goes to zero!</span>
<span class="hljs-comment">// The objects are never destroyed!</span>
</code></pre>

<p>To work around this problem, both Boost and C++11 have defined a <code>weak_ptr</code> to define a weak (uncounted) reference to a <code>shared_ptr</code>.</p>
    </div></div></div></div><div id="solution2" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 2</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/smart-pointers">smart-pointers</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Here's a simple answer for these days of modern C++ (C++11 and later):</p>
<ul>
<li><strong>"What is a smart pointer?"</strong> <br>
It's a type whose values can be used like pointers, but which provides the additional feature of automatic memory management: When a smart pointer is no longer in use, the memory it points to is deallocated (see also <a href="http://en.wikipedia.org/wiki/Smart_pointer" rel="noreferrer">the more detailed definition on Wikipedia</a>).</li>
<li><strong>"When should I use one?"</strong> <br>
In code which involves tracking the ownership of a piece of memory, allocating or de-allocating; the smart pointer often saves you the need to do these things explicitly.</li>
<li><strong>"But which smart pointer should I use in which of those cases?"</strong>
<ul>
<li>Use <a href="http://en.cppreference.com/w/cpp/memory/unique_ptr" rel="noreferrer"><code>std::unique_ptr</code></a> when you want your object to live just as long as a single owning reference to it lives. For example, use it for a pointer to memory which gets allocated on entering some scope and de-allocated on exiting the scope.</li>
<li>Use <a href="http://en.cppreference.com/w/cpp/memory/shared_ptr" rel="noreferrer"><code>std::shared_ptr</code></a> when you do want to refer to your object from multiple places - and do not want your object to be de-allocated until all these references are themselves gone.</li>
<li>Use <a href="http://en.cppreference.com/w/cpp/memory/weak_ptr" rel="noreferrer"><code>std::weak_ptr</code></a> when you do want to refer to your object from multiple places - for those references for which it's ok to ignore and deallocate (so they'll just note the object is gone when you try to dereference).</li>
<li>Don't use the <code>boost::</code> smart pointers or <code>std::auto_ptr</code> except in special cases which you can read up on if you must.</li>
</ul>
</li>
<li><strong>"Hey, I didn't ask which one to use!"</strong> <br>
Ah, but you really wanted to, admit it.</li>
<li><strong>"So when should I use regular pointers then?"</strong> <br>
Mostly in code that is oblivious to memory ownership. This would typically be in functions which get a pointer from someplace else and do not allocate nor de-allocate, and do not store a copy of the pointer which outlasts their execution.</li>
</ul>
    </div></div></div></div><div id="solution3" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 3</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/smart-pointers">smart-pointers</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>A <a href="http://en.wikipedia.org/wiki/Smart_pointer" rel="noreferrer">smart pointer</a> is a pointer-like type with some additional functionality, e.g. automatic memory deallocation, reference counting etc.</p>
<p>A small intro is available on the page <a href="http://ootips.org/yonat/4dev/smart-pointers.html" rel="noreferrer">Smart Pointers - What, Why, Which?</a>.</p>
<p>One of the simple smart-pointer types is <a href="http://en.cppreference.com/w/cpp/memory/auto_ptr" rel="noreferrer"><code>std::auto_ptr</code></a> (chapter 20.4.5 of C++ standard), which allows one to deallocate memory automatically when it out of scope and which is more robust than simple pointer usage when exceptions are thrown, although less flexible.</p>
<p>Another convenient type is <a href="http://www.boost.org/doc/libs/1_36_0/libs/smart_ptr/shared_ptr.htm" rel="noreferrer"><code>boost::shared_ptr</code></a> which implements reference counting and automatically deallocates memory when no references to the object remains. This helps avoiding memory leaks and is easy to use to implement <a href="http://en.wikipedia.org/wiki/Resource_Acquisition_Is_Initialization" rel="noreferrer">RAII</a>.</p>
<p>The subject is covered in depth in book <a href="https://rads.stackoverflow.com/amzn/click/com/0201734842" rel="noreferrer">"C++ Templates: The Complete Guide" by David Vandevoorde, Nicolai M. Josuttis</a>, chapter Chapter 20. Smart Pointers.
Some topics covered:</p>
<ul>
<li>Protecting Against Exceptions</li>
<li>Holders, (note, <a href="http://en.cppreference.com/w/cpp/memory/auto_ptr" rel="noreferrer">std::auto_ptr</a> is implementation of such type of smart pointer)</li>
<li><a href="http://en.wikipedia.org/wiki/Resource_acquisition_is_initialization" rel="noreferrer">Resource Acquisition Is Initialization</a> (This is frequently used for exception-safe resource management in C++)</li>
<li>Holder Limitations</li>
<li><a href="http://en.wikipedia.org/wiki/Reference_counting" rel="noreferrer">Reference Counting</a></li>
<li>Concurrent Counter Access</li>
<li>Destruction and Deallocation</li>
</ul>
    </div></div></div></div><div id="solution4" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 4</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/smart-pointers">smart-pointers</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Definitions provided by Chris, Sergdev and Llyod are correct. I prefer a simpler definition though, just to keep my life simple:
A smart pointer is simply a class that overloads the <code>-&gt;</code>  and <code>*</code> operators. Which means that your object semantically looks like a pointer but you can make it do way cooler things, including reference counting, automatic destruction etc.
<code>shared_ptr</code> and <code>auto_ptr</code> are sufficient in most cases, but come along with their own set of small idiosyncrasies.</p>
    </div></div></div></div><div id="solution5" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 5</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/smart-pointers">smart-pointers</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>A smart pointer is like a regular (typed) pointer, like "char*", except when the pointer itself goes out of scope then what it points to is deleted as well. You can use it like you would a regular pointer, by using "-&gt;", but not if you need an actual pointer to the data. For that, you can use "&amp;*ptr".</p>

<p>It is useful for:</p>

<ul>
<li><p>Objects that must be allocated with new, but that you'd like to have the same lifetime as something on that stack. If the object is assigned to a smart pointer, then they will be deleted when the program exits that function/block.</p></li>
<li><p>Data members of classes, so that when the object is deleted all the owned data is deleted as well, without any special code in the destructor (you will need to be sure the destructor is virtual, which is almost always a good thing to do).</p></li>
</ul>

<p>You may <em>not</em> want to use a smart pointer when:</p>

<ul>
<li>... the pointer shouldn't actually own the data... i.e., when you are just using the data, but you want it to survive the function where you are referencing it.</li>
<li>... the smart pointer isn't itself going to be destroyed at some point. You don't want it to sit in memory that never gets destroyed (such as in an object that is dynamically allocated but won't be explicitly deleted).</li>
<li>... two smart pointers might point to the same data. (There are, however, even smarter pointers that will handle that... that is called <a href="http://en.wikipedia.org/wiki/Reference_counting" rel="noreferrer">reference counting</a>.)</li>
</ul>

<p>See also:</p>

<ul>
<li><a href="http://en.wikipedia.org/wiki/Garbage_collection_(computer_science)" rel="noreferrer">garbage collection</a>.</li>
<li><a href="https://stackoverflow.com/questions/94227/smart-pointers-or-who-owns-you-baby">This stack overflow question</a> regarding data ownership</li>
</ul>
    </div></div></div></div><div id="solution6" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 6</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/smart-pointers">smart-pointers</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>A smart pointer is an object that acts like a pointer, but additionally provides control on construction, destruction, copying, moving and dereferencing.</p>

<p>One can implement one's own smart pointer, but many libraries also provide smart pointer implementations each with different advantages and drawbacks.</p>

<p>For example, <a href="http://www.boost.org/" rel="noreferrer">Boost</a> provides the following smart pointer implementations:</p>

<ul>
<li><code>shared_ptr&lt;T&gt;</code> is a pointer to <code>T</code> using a reference count to determine when the object is no longer needed.</li>
<li><code>scoped_ptr&lt;T&gt;</code> is a pointer automatically deleted when it goes out of scope. No assignment is possible.</li>
<li><code>intrusive_ptr&lt;T&gt;</code> is another reference counting pointer. It provides better performance than <code>shared_ptr</code>, but requires the type <code>T</code> to provide its own reference counting mechanism.</li>
<li><code>weak_ptr&lt;T&gt;</code> is a weak pointer, working in conjunction with <code>shared_ptr</code> to avoid circular references.</li>
<li><code>shared_array&lt;T&gt;</code> is like <code>shared_ptr</code>, but for arrays of <code>T</code>.</li>
<li><code>scoped_array&lt;T&gt;</code> is like <code>scoped_ptr</code>, but for arrays of <code>T</code>.</li>
</ul>

<p>These are just one linear descriptions of each and can be used as per need, for further detail and examples one can look at the documentation of Boost.</p>

<p>Additionally, the C++ standard library provides three smart pointers; <code>std::unique_ptr</code> for unique ownership, <code>std::shared_ptr</code> for shared ownership and <code>std::weak_ptr</code>. <code>std::auto_ptr</code> existed in C++03 but is now deprecated.</p>
    </div></div></div></div><div id="solution7" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 7</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/smart-pointers">smart-pointers</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Most kinds of smart pointers handle disposing of the pointer-to object for you. It's very handy because you don't have to think about disposing of objects manually anymore.</p>

<p>The most commonly-used smart pointers are <code>std::tr1::shared_ptr</code> (or <code>boost::shared_ptr</code>), and, less commonly, <code>std::auto_ptr</code>. I recommend regular use of <code>shared_ptr</code>.</p>

<p><code>shared_ptr</code> is very versatile and deals with a large variety of disposal scenarios, including cases where objects need to be "passed across DLL boundaries" (the common nightmare case if different <code>libc</code>s are used between your code and the DLLs).</p>
    </div></div></div></div><div id="solution8" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 8</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/smart-pointers">smart-pointers</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Here is the Link for similar answers : <a href="http://sickprogrammersarea.blogspot.in/2014/03/technical-interview-questions-on-c_6.html">http://sickprogrammersarea.blogspot.in/2014/03/technical-interview-questions-on-c_6.html</a></p>

<p>A smart pointer is an object that acts, looks and feels like a normal pointer but offers more functionality. In C++, smart pointers are implemented as template classes that encapsulate a pointer and override standard pointer operators. They have a number of advantages over regular pointers. They are guaranteed to be initialized as either null pointers or pointers to a heap object. Indirection through a null pointer is checked. No delete is ever necessary. Objects are automatically freed when the last pointer to them has gone away. One significant problem with these smart pointers is that unlike regular pointers, they don't respect inheritance. Smart pointers are unattractive for polymorphic code. Given below is an example for the implementation of smart pointers.</p>

<p><strong>Example:</strong> </p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">X</span>&gt;
<span class="hljs-keyword">class</span> <span class="hljs-title class_">smart_pointer</span>
{
          <span class="hljs-keyword">public</span>:
               <span class="hljs-built_in">smart_pointer</span>();                          <span class="hljs-comment">// makes a null pointer</span>
               <span class="hljs-built_in">smart_pointer</span>(<span class="hljs-type">const</span> X&amp; x)            <span class="hljs-comment">// makes pointer to copy of x</span>

               X&amp; <span class="hljs-keyword">operator</span> *( );
               <span class="hljs-type">const</span> X&amp; <span class="hljs-keyword">operator</span>*( ) <span class="hljs-type">const</span>;
               X* <span class="hljs-keyword">operator</span>-&gt;() <span class="hljs-type">const</span>;

               <span class="hljs-built_in">smart_pointer</span>(<span class="hljs-type">const</span> smart_pointer &lt;X&gt; &amp;);
               <span class="hljs-type">const</span> smart_pointer &lt;X&gt; &amp; <span class="hljs-keyword">operator</span> =(<span class="hljs-type">const</span> smart_pointer&lt;X&gt;&amp;);
               ~<span class="hljs-built_in">smart_pointer</span>();
          <span class="hljs-keyword">private</span>:
               <span class="hljs-comment">//...</span>
};
</code></pre>

<p>This class implement a smart pointer to an object of type X. The object itself is located on the heap. Here is how to use it:</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp">smart_pointer &lt;employee&gt; p= <span class="hljs-built_in">employee</span>(<span class="hljs-string">"Harris"</span>,<span class="hljs-number">1333</span>);
</code></pre>

<p>Like other overloaded operators, p will behave like a regular pointer,</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp">cout&lt;&lt;*p;
p-&gt;<span class="hljs-built_in">raise_salary</span>(<span class="hljs-number">0.5</span>);
</code></pre>
    </div></div></div></div><div id="solution9" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 9</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/smart-pointers">smart-pointers</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Let T be a class in this tutorial 
Pointers in C++ can be divided into 3 types :</p>

<p>1) <strong>Raw pointers</strong> :</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp">T a;  
T * _ptr = &amp;a; 
</code></pre>

<p>They hold a memory address to a location in memory. Use with caution , as programs become complex hard to keep track. </p>

<p>Pointers with const data or address { Read backwards } </p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp">T a ; 
<span class="hljs-type">const</span> T * ptr1 = &amp;a ; 
T <span class="hljs-type">const</span> * ptr1 = &amp;a ;
</code></pre>

<p>Pointer to a data type T which is a const. Meaning you cannot change the data type using the pointer. ie <code>*ptr1 = 19</code> ; will not work. But you can move the pointer. ie <code>ptr1++ , ptr1--</code> ;  etc will work.
Read backwards : pointer to type T which is const </p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp">  T * <span class="hljs-type">const</span> ptr2 ;
</code></pre>

<p>A const pointer to a data type T . Meaning you cannot move the pointer but you can change the value pointed to by the pointer. ie <code>*ptr2 = 19</code> will work but <code>ptr2++ ; ptr2--</code> etc will not work. Read backwards : const pointer to a type T </p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-type">const</span> T * <span class="hljs-type">const</span> ptr3 ; 
</code></pre>

<p>A const pointer to a const data type T . Meaning you cannot either move the pointer nor can you change the data type pointer to be the pointer. ie . <code>ptr3-- ; ptr3++ ; *ptr3 = 19;</code> will not work </p>

<p>3) <strong>Smart Pointers</strong> : { <code>#include &lt;memory&gt;</code> } </p>

<p><strong>Shared Pointer</strong>: </p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp">  T a ; 
     <span class="hljs-comment">//shared_ptr&lt;T&gt; shptr(new T) ; not recommended but works </span>
     shared_ptr&lt;T&gt; shptr = <span class="hljs-built_in">make_shared</span>&lt;T&gt;(); <span class="hljs-comment">// faster + exception safe</span>

     std::cout &lt;&lt; shptr.<span class="hljs-built_in">use_count</span>() ; <span class="hljs-comment">// 1 //  gives the number of " </span>
things <span class="hljs-string">" pointing to it. 
     T * temp = shptr.get(); // gives a pointer to object

     // shared_pointer used like a regular pointer to call member functions
      shptr-&gt;memFn();
     (*shptr).memFn(); 

    //
     shptr.reset() ; // frees the object pointed to be the ptr 
     shptr = nullptr ; // frees the object 
     shptr = make_shared&lt;T&gt;() ; // frees the original object and points to new object
</span></code></pre>

<p>Implemented using reference counting to keep track of how many " things " point to the object pointed to by the pointer. When this count goes to 0 , the object is automatically deleted , ie objected is deleted when all the share_ptr pointing to the object goes out of scope. 
This gets rid of the headache of having to delete objects which you have allocated using new. </p>

<p><strong>Weak Pointer :</strong> 
    Helps deal with cyclic reference which arises when using Shared Pointer
    If you have two objects pointed to by two shared pointers and there is an internal shared pointer pointing to each others shared pointer then there will be a cyclic reference and the object will not be deleted when shared pointers go out of scope. To solve this , change the internal member from a shared_ptr to weak_ptr. Note : To access the element pointed to by a weak pointer use lock() , this returns a weak_ptr. </p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp">T a ; 
shared_ptr&lt;T&gt; shr = <span class="hljs-built_in">make_shared</span>&lt;T&gt;() ; 
weak_ptr&lt;T&gt; wk = shr ; <span class="hljs-comment">// initialize a weak_ptr from a shared_ptr </span>
wk.<span class="hljs-built_in">lock</span>()-&gt;<span class="hljs-built_in">memFn</span>() ; <span class="hljs-comment">// use lock to get a shared_ptr </span>
<span class="hljs-comment">//   ^^^ Can lead to exception if the shared ptr has gone out of scope</span>
<span class="hljs-keyword">if</span>(!wk.<span class="hljs-built_in">expired</span>()) wk.<span class="hljs-built_in">lock</span>()-&gt;<span class="hljs-built_in">memFn</span>() ;
<span class="hljs-comment">// Check if shared ptr has gone out of scope before access</span>
</code></pre>

<p>See : <a href="https://stackoverflow.com/questions/12030650/when-is-stdweak-ptr-useful">When is std::weak_ptr useful?</a></p>

<p><strong>Unique Pointer :</strong> 
    Light weight smart pointer with exclusive ownership. Use when pointer points to unique objects without sharing the objects between the pointers.</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-function">unique_ptr&lt;T&gt; <span class="hljs-title">uptr</span><span class="hljs-params">(<span class="hljs-keyword">new</span> T)</span></span>;
uptr-&gt;<span class="hljs-built_in">memFn</span>(); 

<span class="hljs-comment">//T * ptr = uptr.release(); // uptr becomes null and object is pointed to by ptr</span>
uptr.<span class="hljs-built_in">reset</span>() ; <span class="hljs-comment">// deletes the object pointed to by uptr </span>
</code></pre>

<p>To change the object pointed to by the unique ptr , use move semantics</p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-function">unique_ptr&lt;T&gt; <span class="hljs-title">uptr1</span><span class="hljs-params">(<span class="hljs-keyword">new</span> T)</span></span>;
<span class="hljs-function">unique_ptr&lt;T&gt; <span class="hljs-title">uptr2</span><span class="hljs-params">(<span class="hljs-keyword">new</span> T)</span></span>;
uptr2 = std::<span class="hljs-built_in">move</span>(uptr1); 
<span class="hljs-comment">// object pointed by uptr2 is deleted and </span>
<span class="hljs-comment">// object pointed by uptr1 is pointed to by uptr2</span>
<span class="hljs-comment">// uptr1 becomes null </span>
</code></pre>

<p>References : 
    They can essentially be though of as const pointers, ie a pointer which is const and cannot be moved with better syntax.</p>

<p>See : <a href="https://stackoverflow.com/questions/57483/what-are-the-differences-between-a-pointer-variable-and-a-reference-variable-in">What are the differences between a pointer variable and a reference variable in C++?</a>  </p>

<pre class="lang-cpp s-code-block"><code class="hljs language-cpp">r-value reference : reference to a temporary object   
l-value reference : reference to an object whose address can be obtained
<span class="hljs-type">const</span> reference : reference to a data type which is <span class="hljs-type">const</span> <span class="hljs-keyword">and</span> cannot be modified 
</code></pre>

<p>Reference : 
<a href="https://www.youtube.com/channel/UCEOGtxYTB6vo6MQ-WQ9W_nQ" rel="noreferrer">https://www.youtube.com/channel/UCEOGtxYTB6vo6MQ-WQ9W_nQ</a> 
Thanks to Andre for pointing out this question.</p>
    </div></div></div></div><div id="solution10" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 10</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/smart-pointers">smart-pointers</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p><a href="http://en.wikipedia.org/wiki/Smart_pointer" rel="noreferrer">http://en.wikipedia.org/wiki/Smart_pointer</a></p>

<blockquote>
  <p>In computer science, a smart pointer
  is an abstract data type that
  simulates a pointer while providing
  additional features, such as automatic
  garbage collection or bounds checking.
  These additional features are intended
  to reduce bugs caused by the misuse of
  pointers while retaining efficiency.
  Smart pointers typically keep track of
  the objects that point to them for the
  purpose of memory management. The
  misuse of pointers is a major source
  of bugs: the constant allocation,
  deallocation and referencing that must
  be performed by a program written
  using pointers makes it very likely
  that some memory leaks will occur.
  Smart pointers try to prevent memory
  leaks by making the resource
  deallocation automatic: when the
  pointer to an object (or the last in a
  series of pointers) is destroyed, for
  example because it goes out of scope,
  the pointed object is destroyed too.</p>
</blockquote>
    </div></div></div></div><div id="solution11" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 11</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/smart-pointers">smart-pointers</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>A smart pointer is a class, a wrapper of a normal pointer. Unlike normal pointers, smart points life circle is based on a reference count (how many time the smart pointer object is assigned). So whenever a smart pointer is assigned to another one, the internal reference count plus plus. And whenever the object goes out of scope, the reference count minus minus.</p>

<p>Automatic pointer, though looks similar, is totally different from smart pointer. It is a convenient class that deallocates the resource whenever an automatic pointer object goes out of variable scope. To some extent, it makes a pointer (to dynamically allocated memory) works similar to a stack variable (statically allocated in compiling time).</p>
    </div></div></div></div><div id="solution12" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 12</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/smart-pointers">smart-pointers</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>What is a smart pointer.</p>
<p>Long version, In principle:</p>
<p><a href="https://web.stanford.edu/class/archive/cs/cs106l/cs106l.1192/lectures/lecture15/15_RAII.pdf" rel="nofollow noreferrer">https://web.stanford.edu/class/archive/cs/cs106l/cs106l.1192/lectures/lecture15/15_RAII.pdf</a></p>
<p>A modern C++ idiom:</p>
<pre class="lang-cpp s-code-block"><code class="hljs language-cpp">RAII: Resource Acquisition Is Initialization.

 When you initialize an object, <span class="hljs-function">it should already have 
  acquired any resources it <span class="hljs-title">needs</span> <span class="hljs-params">(in the constructor)</span>.


 When an object goes out of scope, it should release every 
  resource it is <span class="hljs-title">using</span> <span class="hljs-params">(<span class="hljs-keyword">using</span> the destructor)</span>.
</span></code></pre>
<p>key point:</p>
<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"> There should never be a half-ready <span class="hljs-keyword">or</span> half-dead object.
 When an object is created, it should be in a ready state.
 When an object goes out of scope, it should release its resources. 
 The user shouldnt have to <span class="hljs-keyword">do</span> anything more. 
</code></pre>
<p><strong>Raw Pointers violate RAII</strong>: It need user to delete manually when the pointers go out of scope.</p>
<p>RAII solution is:</p>
<pre class="lang-cpp s-code-block"><code class="hljs language-cpp">Have a smart pointer <span class="hljs-keyword">class</span>:
 Allocates the memory when initialized
 Frees the memory when destructor is called
 Allows access to underlying pointer
</code></pre>
<p>For smart pointer need copy and share, use shared_ptr:</p>
<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"> use another memory to store Reference counting <span class="hljs-keyword">and</span> shared.
 increment when copy, decrement when destructor.
 <span class="hljs-keyword">delete</span> memory when Reference counting is <span class="hljs-number">0.</span> 
  also <span class="hljs-keyword">delete</span> memory that store Reference counting.
</code></pre>
<p>for smart pointer not own the raw pointer, use weak_ptr:</p>
<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"> <span class="hljs-keyword">not</span> change Reference counting.
</code></pre>
<p>shared_ptr usage:</p>
<pre class="lang-cpp s-code-block"><code class="hljs language-cpp">correct way:
std::shared_ptr&lt;T&gt; t1 = std::<span class="hljs-built_in">make_shared</span>&lt;T&gt;(TArgs);
std::shared_ptr&lt;T&gt; t2 = std::<span class="hljs-built_in">shared_ptr</span>&lt;T&gt;(<span class="hljs-keyword">new</span> <span class="hljs-built_in">T</span>(Targs));

wrong way:
T* pt = <span class="hljs-keyword">new</span> <span class="hljs-built_in">T</span>(TArgs); <span class="hljs-comment">// never exposure the raw pointer</span>
shared_ptr&lt;T&gt; t1 = <span class="hljs-built_in">shared_ptr</span>&lt;T&gt;(pt);
shared_ptr&lt;T&gt; t2 = <span class="hljs-built_in">shared_ptr</span>&lt;T&gt;(pt);
</code></pre>
<p>Always avoid using raw pointer.</p>
<p>For scenario that have to use raw pointer:</p>
<p><a href="https://stackoverflow.com/a/19432062/2482283">https://stackoverflow.com/a/19432062/2482283</a></p>
<p>For raw pointer that not nullptr, use reference instead.</p>
<pre class="lang-cpp s-code-block"><code class="hljs language-cpp"><span class="hljs-keyword">not</span> use T*
use T&amp;  
</code></pre>
<p>For optional reference which maybe nullptr, use raw pointer, and which means:</p>
<pre class="lang-cpp s-code-block"><code class="hljs language-cpp">T* pt; is optional reference <span class="hljs-keyword">and</span> maybe <span class="hljs-literal">nullptr</span>.
Not own the raw pointer, 
Raw pointer is managed by some one <span class="hljs-keyword">else</span>.
I only know that the caller is sure it is <span class="hljs-keyword">not</span> released now.
</code></pre>
    </div></div></div></div><div id="solution13" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 13</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/smart-pointers">smart-pointers</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Smart Pointers are those where you don't have to worry about Memory De-Allocation, Resource Sharing and Transfer. </p>

<p>You can very well use these pointer in the similar way as any allocation works in Java. In java Garbage Collector does the trick, while in Smart Pointers, the trick is done by Destructors.</p>
    </div></div></div></div><div id="solution14" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 14</h4><div class="tags-wrap h-max space-x-8"><div class="tags"><a class="rounded-2xl border bg-neutral-100 px-3 py-1 text-sm font-semibold whitespace-nowrap" href="/questions/tag/smart-pointers">smart-pointers</a></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>The existing answers are good but don't cover what to do when a smart pointer is not the (complete) answer to the problem you are trying to solve.</p>

<p>Among other things (explained well in other answers) using a smart pointer is a possible solution to <a href="https://stackoverflow.com/questions/48454208/how-do-we-use-a-abstract-class-as-a-function-return-type">How do we use a abstract class as a function return type?</a> which has been marked as a duplicate of this question. However, the first question to ask if tempted to specify an abstract (or in fact, any) base class as a return type in C++ is "what do you really mean?". There is a good discussion (with further references) of idiomatic object oriented programming in C++ (and how this is different to other languages) in the documentation of the <a href="http://www.boost.org/doc/libs/1_66_0/libs/ptr_container/doc/guidelines.html#recommended-practice-for-object-oriented-programming" rel="nofollow noreferrer">boost pointer container library</a>. In summary, in C++ you have to think about ownership. Which smart pointers help you with, but are not the only solution, or always a complete solution (they don't give you polymorphic copy) and are not always a solution you want to expose in your interface (and a function return sounds an awful lot like an interface). It might be sufficient to return a reference, for example. But in all of these cases (smart pointer, pointer container or simply returning a reference) you have changed the return from a <em>value</em> to some form of <em>reference</em>. If you really needed copy you may need to add more boilerplate "idiom" or move beyond idiomatic (or otherwise) OOP in C++ to more generic polymorphism using libraries like <a href="http://stlab.adobe.com/group__poly__related.html" rel="nofollow noreferrer">Adobe Poly</a> or <a href="http://www.boost.org/doc/libs/1_66_0/doc/html/boost_typeerasure.html" rel="nofollow noreferrer">Boost.TypeErasure</a>.</p>
    </div></div></div></div></div></div><div class="widget"><a href="/questions/mysqli-or-die-does-it-have-to-die-1657388533922">mysqli or die, does it have to die?</a><a href="/questions/event.preventdefault()-vs.-return-false-1657387458377">event.preventDefault() vs. return false</a><a href="/questions/how-does-the-%22this%22-keyword-work-and-when-should-it-be-used-1657384384385">How does the &quot;this&quot; keyword work, and when should it be used?</a><a href="/questions/what-is-the-javascript-version-of-sleep()-1657387391406">What is the JavaScript version of sleep()?</a><a href="/questions/why-does-spring-mvc-respond-with-a-404-and-report-%22no-mapping-found-for-http-request-with-uri-...-in-dispatcherservlet%22-1657387995250">Why does Spring MVC respond with a 404 and report &quot;No mapping found for HTTP request with URI [...] in DispatcherServlet&quot;?</a><a href="/questions/find-object-by-id-in-an-array-of-javascript-objects-1657387572087">Find object by id in an array of JavaScript objects</a><a href="/questions/what-happens-if-you-use-the-32-bit-int-0x80-linux-abi-in-64-bit-code-1657388560485">What happens if you use the 32-bit int 0x80 Linux ABI in 64-bit code?</a><a href="/questions/get-the-data-received-in-a-flask-request-1657387804432">Get the data received in a Flask request</a><a href="/questions/how-can-i-make-an-ajax-call-without-jquery-1657388448955">How can I make an AJAX call without jQuery?</a><a href="/questions/sorting-object-property-by-values-1657388367300">Sorting object property by values</a><a href="/questions/what-is-a-plain-english-explanation-of-%22big-o%22-notation-1657387641953">What is a plain English explanation of &quot;Big O&quot; notation?</a><a href="/questions/what-is-a-smart-pointer-and-when-should-i-use-one-1657387905461">What is a smart pointer and when should I use one?</a><a href="/questions/why-is-24.0000-not-equal-to-24.0000-in-matlab-1657388376753">Why is 24.0000 not equal to 24.0000 in MATLAB?</a><a href="/questions/the-viewdata-item-that-has-the-key-&#x27;xxx&#x27;-is-of-type-&#x27;system.int32&#x27;-but-must-be-of-type-&#x27;ienumerablelessselectlistitemgreater&#x27;-1657388454191">The ViewData item that has the key &#x27;XXX&#x27; is of type &#x27;System.Int32&#x27; but must be of type &#x27;IEnumerable&lt;SelectListItem&gt;&#x27;</a><a href="/questions/sort-a-maplesskey-valuegreater-by-values-1657387443904">Sort a Map&lt;Key, Value&gt; by values</a><a href="/questions/tkinter:-attributeerror:-nonetype-object-has-no-attribute-lessattribute-namegreater-1657385472410">Tkinter: AttributeError: NoneType object has no attribute &lt;attribute name&gt;</a><a href="/questions/flexbox:-center-horizontally-and-vertically-1657384587888">Flexbox: center horizontally and vertically</a><a href="/questions/difference-between-sh-and-bash-1657388197713">Difference between sh and Bash</a><a href="/questions/how-do-i-pandas-group-by-to-get-sum-1657387908708">How do I Pandas group-by to get sum?</a><a href="/questions/error-in-finding-last-used-cell-in-excel-with-vba-1657384584748">Error in finding last used cell in Excel with VBA</a></div></div><span class="cursor-pointer text-lg p-2" style="position:fixed;bottom:20px;left:20px;background:#000;z-index:2000;color:white">Go go top</span></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"data":{"answer":["\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;UPDATE\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;This answer is rather old, and so describes what was \u0026apos;good\u0026apos; at the time, which was smart pointers provided by the Boost library. Since C++11, the standard library has provided sufficient smart pointers types, and so you should favour the use of \u0026lt;a href=\u0026quot;http://en.cppreference.com/w/cpp/memory/unique_ptr\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;\u0026lt;code\u0026gt;std::unique_ptr\u0026lt;/code\u0026gt;\u0026lt;/a\u0026gt;, \u0026lt;a href=\u0026quot;http://en.cppreference.com/w/cpp/memory/shared_ptr\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;\u0026lt;code\u0026gt;std::shared_ptr\u0026lt;/code\u0026gt;\u0026lt;/a\u0026gt; and \u0026lt;a href=\u0026quot;http://en.cppreference.com/w/cpp/memory/weak_ptr\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;\u0026lt;code\u0026gt;std::weak_ptr\u0026lt;/code\u0026gt;\u0026lt;/a\u0026gt;. \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;There was also \u0026lt;a href=\u0026quot;http://en.cppreference.com/w/cpp/memory/auto_ptr\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;\u0026lt;code\u0026gt;std::auto_ptr\u0026lt;/code\u0026gt;\u0026lt;/a\u0026gt;. It was very much like a scoped pointer, except that it also had the \u0026quot;special\u0026quot; dangerous ability to be copied  which also unexpectedly transfers ownership.\u0026lt;br\u0026gt;\n\u0026lt;strong\u0026gt;It was deprecated in C++11 and removed in C++17\u0026lt;/strong\u0026gt;, so you shouldn\u0026apos;t use it.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;std::auto_ptr\u0026amp;lt;MyObject\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;p1\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; MyObject())\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;;\nstd::auto_ptr\u0026amp;lt;MyObject\u0026amp;gt; p2 = p1; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Copy and transfer ownership. \u0026lt;/span\u0026gt;\n                                 \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// p1 gets set to empty!\u0026lt;/span\u0026gt;\np2-\u0026amp;gt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;DoSomething\u0026lt;/span\u0026gt;(); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Works.\u0026lt;/span\u0026gt;\np1-\u0026amp;gt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;DoSomething\u0026lt;/span\u0026gt;(); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Oh oh. Hopefully raises some NULL pointer exception.\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;hr\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;OLD ANSWER\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;A smart pointer is a class that wraps a \u0026apos;raw\u0026apos; (or \u0026apos;bare\u0026apos;) C++ pointer, to manage the lifetime of the object being pointed to. There is no single smart pointer type, but all of them try to abstract a raw pointer in a practical way.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Smart pointers should be preferred over raw pointers. If you feel you need to use pointers (first consider if you \u0026lt;em\u0026gt;really\u0026lt;/em\u0026gt; do), you would normally want to use a smart pointer as this can alleviate many of the problems with raw pointers, mainly forgetting to delete the object and leaking memory.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;With raw pointers, the programmer has to explicitly destroy the object when it is no longer useful.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Need to create the object to achieve some goal\u0026lt;/span\u0026gt;\nMyObject* ptr = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;MyObject\u0026lt;/span\u0026gt;(); \nptr-\u0026amp;gt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;DoSomething\u0026lt;/span\u0026gt;(); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Use the object in some way\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;delete\u0026lt;/span\u0026gt; ptr; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Destroy the object. Done with it.\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Wait, what if DoSomething() raises an exception...?\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;A smart pointer by comparison defines a policy as to when the object is destroyed. You still have to create the object, but you no longer have to worry about destroying it.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;SomeSmartPtr\u0026amp;lt;MyObject\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;ptr\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; MyObject())\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;;\nptr-\u0026amp;gt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;DoSomething\u0026lt;/span\u0026gt;(); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Use the object in some way.\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Destruction of the object happens, depending \u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// on the policy the smart pointer class uses.\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Destruction would happen even if DoSomething() \u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// raises an exception\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;The simplest policy in use involves the scope of the smart pointer wrapper object, such as implemented by \u0026lt;a href=\u0026quot;http://www.boost.org/doc/libs/release/libs/smart_ptr/scoped_ptr.htm\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;\u0026lt;code\u0026gt;boost::scoped_ptr\u0026lt;/code\u0026gt;\u0026lt;/a\u0026gt; or \u0026lt;a href=\u0026quot;http://en.cppreference.com/w/cpp/memory/unique_ptr\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;\u0026lt;code\u0026gt;std::unique_ptr\u0026lt;/code\u0026gt;\u0026lt;/a\u0026gt;. \u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;f\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt;\n\u0026lt;/span\u0026gt;{\n    {\n       \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;std::unique_ptr\u0026amp;lt;MyObject\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;ptr\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; MyObject())\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;;\n       ptr-\u0026amp;gt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;DoSomethingUseful\u0026lt;/span\u0026gt;();\n    } \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// ptr goes out of scope -- \u0026lt;/span\u0026gt;\n      \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// the MyObject is automatically destroyed.\u0026lt;/span\u0026gt;\n\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// ptr-\u0026amp;gt;Oops(); // Compile error: \u0026quot;ptr\u0026quot; not defined\u0026lt;/span\u0026gt;\n                    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// since it is no longer in scope.\u0026lt;/span\u0026gt;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Note that \u0026lt;code\u0026gt;std::unique_ptr\u0026lt;/code\u0026gt; instances cannot be copied. This prevents the pointer from being deleted multiple times (incorrectly). You can, however, pass references to it around to other functions you call.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;code\u0026gt;std::unique_ptr\u0026lt;/code\u0026gt;s are useful when you want to tie the lifetime of the object to a particular block of code, or if you embedded it as member data inside another object, the lifetime of that other object. The object exists until the containing block of code is exited, or until the containing object is itself destroyed.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;A more complex smart pointer policy involves reference counting the pointer. This does allow the pointer to be copied. When the last \u0026quot;reference\u0026quot; to the object is destroyed, the object is deleted. This policy is implemented by \u0026lt;a href=\u0026quot;http://www.boost.org/doc/libs/release/libs/smart_ptr/shared_ptr.htm\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;\u0026lt;code\u0026gt;boost::shared_ptr\u0026lt;/code\u0026gt;\u0026lt;/a\u0026gt; and \u0026lt;a href=\u0026quot;http://en.cppreference.com/w/cpp/memory/shared_ptr\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;\u0026lt;code\u0026gt;std::shared_ptr\u0026lt;/code\u0026gt;\u0026lt;/a\u0026gt;.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;f\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;()\u0026lt;/span\u0026gt;\n\u0026lt;/span\u0026gt;{\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;typedef\u0026lt;/span\u0026gt; std::shared_ptr\u0026amp;lt;MyObject\u0026amp;gt; MyObjectPtr; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// nice short alias\u0026lt;/span\u0026gt;\n    MyObjectPtr p1; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Empty\u0026lt;/span\u0026gt;\n\n    {\n        \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;MyObjectPtr \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;p2\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; MyObject())\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;;\n        \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// There is now one \u0026quot;reference\u0026quot; to the created object\u0026lt;/span\u0026gt;\n        p1 = p2; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Copy the pointer.\u0026lt;/span\u0026gt;\n        \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// There are now two references to the object.\u0026lt;/span\u0026gt;\n    } \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// p2 is destroyed, leaving one reference to the object.\u0026lt;/span\u0026gt;\n} \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// p1 is destroyed, leaving a reference count of zero. \u0026lt;/span\u0026gt;\n  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// The object is deleted.\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Reference counted pointers are very useful when the lifetime of your object is much more complicated, and is not tied directly to a particular section of code or to another object.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;There is one drawback to reference counted pointers  the possibility of creating a dangling reference:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Create the smart pointer on the heap\u0026lt;/span\u0026gt;\nMyObjectPtr* pp = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;MyObjectPtr\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;MyObject\u0026lt;/span\u0026gt;())\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Hmm, we forgot to destroy the smart pointer,\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// because of that, the object is never destroyed!\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Another possibility is creating circular references:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Owner\u0026lt;/span\u0026gt; {\n   std::shared_ptr\u0026amp;lt;Owner\u0026amp;gt; other;\n};\n\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;std::shared_ptr\u0026amp;lt;Owner\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;p1\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; Owner())\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;;\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;std::shared_ptr\u0026amp;lt;Owner\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;p2\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; Owner())\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;;\np1-\u0026amp;gt;other = p2; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// p1 references p2\u0026lt;/span\u0026gt;\np2-\u0026amp;gt;other = p1; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// p2 references p1\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Oops, the reference count of of p1 and p2 never goes to zero!\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// The objects are never destroyed!\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;To work around this problem, both Boost and C++11 have defined a \u0026lt;code\u0026gt;weak_ptr\u0026lt;/code\u0026gt; to define a weak (uncounted) reference to a \u0026lt;code\u0026gt;shared_ptr\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Here\u0026apos;s a simple answer for these days of modern C++ (C++11 and later):\u0026lt;/p\u0026gt;\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;strong\u0026gt;\u0026quot;What is a smart pointer?\u0026quot;\u0026lt;/strong\u0026gt; \u0026lt;br\u0026gt;\nIt\u0026apos;s a type whose values can be used like pointers, but which provides the additional feature of automatic memory management: When a smart pointer is no longer in use, the memory it points to is deallocated (see also \u0026lt;a href=\u0026quot;http://en.wikipedia.org/wiki/Smart_pointer\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;the more detailed definition on Wikipedia\u0026lt;/a\u0026gt;).\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;strong\u0026gt;\u0026quot;When should I use one?\u0026quot;\u0026lt;/strong\u0026gt; \u0026lt;br\u0026gt;\nIn code which involves tracking the ownership of a piece of memory, allocating or de-allocating; the smart pointer often saves you the need to do these things explicitly.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;strong\u0026gt;\u0026quot;But which smart pointer should I use in which of those cases?\u0026quot;\u0026lt;/strong\u0026gt;\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;Use \u0026lt;a href=\u0026quot;http://en.cppreference.com/w/cpp/memory/unique_ptr\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;\u0026lt;code\u0026gt;std::unique_ptr\u0026lt;/code\u0026gt;\u0026lt;/a\u0026gt; when you want your object to live just as long as a single owning reference to it lives. For example, use it for a pointer to memory which gets allocated on entering some scope and de-allocated on exiting the scope.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Use \u0026lt;a href=\u0026quot;http://en.cppreference.com/w/cpp/memory/shared_ptr\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;\u0026lt;code\u0026gt;std::shared_ptr\u0026lt;/code\u0026gt;\u0026lt;/a\u0026gt; when you do want to refer to your object from multiple places - and do not want your object to be de-allocated until all these references are themselves gone.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Use \u0026lt;a href=\u0026quot;http://en.cppreference.com/w/cpp/memory/weak_ptr\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;\u0026lt;code\u0026gt;std::weak_ptr\u0026lt;/code\u0026gt;\u0026lt;/a\u0026gt; when you do want to refer to your object from multiple places - for those references for which it\u0026apos;s ok to ignore and deallocate (so they\u0026apos;ll just note the object is gone when you try to dereference).\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Don\u0026apos;t use the \u0026lt;code\u0026gt;boost::\u0026lt;/code\u0026gt; smart pointers or \u0026lt;code\u0026gt;std::auto_ptr\u0026lt;/code\u0026gt; except in special cases which you can read up on if you must.\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;strong\u0026gt;\u0026quot;Hey, I didn\u0026apos;t ask which one to use!\u0026quot;\u0026lt;/strong\u0026gt; \u0026lt;br\u0026gt;\nAh, but you really wanted to, admit it.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;strong\u0026gt;\u0026quot;So when should I use regular pointers then?\u0026quot;\u0026lt;/strong\u0026gt; \u0026lt;br\u0026gt;\nMostly in code that is oblivious to memory ownership. This would typically be in functions which get a pointer from someplace else and do not allocate nor de-allocate, and do not store a copy of the pointer which outlasts their execution.\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n    ","\n\u0026lt;p\u0026gt;A \u0026lt;a href=\u0026quot;http://en.wikipedia.org/wiki/Smart_pointer\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;smart pointer\u0026lt;/a\u0026gt; is a pointer-like type with some additional functionality, e.g. automatic memory deallocation, reference counting etc.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;A small intro is available on the page \u0026lt;a href=\u0026quot;http://ootips.org/yonat/4dev/smart-pointers.html\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;Smart Pointers - What, Why, Which?\u0026lt;/a\u0026gt;.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;One of the simple smart-pointer types is \u0026lt;a href=\u0026quot;http://en.cppreference.com/w/cpp/memory/auto_ptr\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;\u0026lt;code\u0026gt;std::auto_ptr\u0026lt;/code\u0026gt;\u0026lt;/a\u0026gt; (chapter 20.4.5 of C++ standard), which allows one to deallocate memory automatically when it out of scope and which is more robust than simple pointer usage when exceptions are thrown, although less flexible.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Another convenient type is \u0026lt;a href=\u0026quot;http://www.boost.org/doc/libs/1_36_0/libs/smart_ptr/shared_ptr.htm\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;\u0026lt;code\u0026gt;boost::shared_ptr\u0026lt;/code\u0026gt;\u0026lt;/a\u0026gt; which implements reference counting and automatically deallocates memory when no references to the object remains. This helps avoiding memory leaks and is easy to use to implement \u0026lt;a href=\u0026quot;http://en.wikipedia.org/wiki/Resource_Acquisition_Is_Initialization\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;RAII\u0026lt;/a\u0026gt;.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;The subject is covered in depth in book \u0026lt;a href=\u0026quot;https://rads.stackoverflow.com/amzn/click/com/0201734842\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;\u0026quot;C++ Templates: The Complete Guide\u0026quot; by David Vandevoorde, Nicolai M. Josuttis\u0026lt;/a\u0026gt;, chapter Chapter 20. Smart Pointers.\nSome topics covered:\u0026lt;/p\u0026gt;\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;Protecting Against Exceptions\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Holders, (note, \u0026lt;a href=\u0026quot;http://en.cppreference.com/w/cpp/memory/auto_ptr\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;std::auto_ptr\u0026lt;/a\u0026gt; is implementation of such type of smart pointer)\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;a href=\u0026quot;http://en.wikipedia.org/wiki/Resource_acquisition_is_initialization\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;Resource Acquisition Is Initialization\u0026lt;/a\u0026gt; (This is frequently used for exception-safe resource management in C++)\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Holder Limitations\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;a href=\u0026quot;http://en.wikipedia.org/wiki/Reference_counting\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;Reference Counting\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Concurrent Counter Access\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;Destruction and Deallocation\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Definitions provided by Chris, Sergdev and Llyod are correct. I prefer a simpler definition though, just to keep my life simple:\nA smart pointer is simply a class that overloads the \u0026lt;code\u0026gt;-\u0026amp;gt;\u0026lt;/code\u0026gt;  and \u0026lt;code\u0026gt;*\u0026lt;/code\u0026gt; operators. Which means that your object semantically looks like a pointer but you can make it do way cooler things, including reference counting, automatic destruction etc.\n\u0026lt;code\u0026gt;shared_ptr\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;auto_ptr\u0026lt;/code\u0026gt; are sufficient in most cases, but come along with their own set of small idiosyncrasies.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;A smart pointer is like a regular (typed) pointer, like \u0026quot;char*\u0026quot;, except when the pointer itself goes out of scope then what it points to is deleted as well. You can use it like you would a regular pointer, by using \u0026quot;-\u0026amp;gt;\u0026quot;, but not if you need an actual pointer to the data. For that, you can use \u0026quot;\u0026amp;amp;*ptr\u0026quot;.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;It is useful for:\u0026lt;/p\u0026gt;\n\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;Objects that must be allocated with new, but that you\u0026apos;d like to have the same lifetime as something on that stack. If the object is assigned to a smart pointer, then they will be deleted when the program exits that function/block.\u0026lt;/p\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;Data members of classes, so that when the object is deleted all the owned data is deleted as well, without any special code in the destructor (you will need to be sure the destructor is virtual, which is almost always a good thing to do).\u0026lt;/p\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\n\u0026lt;p\u0026gt;You may \u0026lt;em\u0026gt;not\u0026lt;/em\u0026gt; want to use a smart pointer when:\u0026lt;/p\u0026gt;\n\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;... the pointer shouldn\u0026apos;t actually own the data... i.e., when you are just using the data, but you want it to survive the function where you are referencing it.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;... the smart pointer isn\u0026apos;t itself going to be destroyed at some point. You don\u0026apos;t want it to sit in memory that never gets destroyed (such as in an object that is dynamically allocated but won\u0026apos;t be explicitly deleted).\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;... two smart pointers might point to the same data. (There are, however, even smarter pointers that will handle that... that is called \u0026lt;a href=\u0026quot;http://en.wikipedia.org/wiki/Reference_counting\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;reference counting\u0026lt;/a\u0026gt;.)\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\n\u0026lt;p\u0026gt;See also:\u0026lt;/p\u0026gt;\n\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;a href=\u0026quot;http://en.wikipedia.org/wiki/Garbage_collection_(computer_science)\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;garbage collection\u0026lt;/a\u0026gt;.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;a href=\u0026quot;https://stackoverflow.com/questions/94227/smart-pointers-or-who-owns-you-baby\u0026quot;\u0026gt;This stack overflow question\u0026lt;/a\u0026gt; regarding data ownership\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n    ","\n\u0026lt;p\u0026gt;A smart pointer is an object that acts like a pointer, but additionally provides control on construction, destruction, copying, moving and dereferencing.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;One can implement one\u0026apos;s own smart pointer, but many libraries also provide smart pointer implementations each with different advantages and drawbacks.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;For example, \u0026lt;a href=\u0026quot;http://www.boost.org/\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;Boost\u0026lt;/a\u0026gt; provides the following smart pointer implementations:\u0026lt;/p\u0026gt;\n\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;code\u0026gt;shared_ptr\u0026amp;lt;T\u0026amp;gt;\u0026lt;/code\u0026gt; is a pointer to \u0026lt;code\u0026gt;T\u0026lt;/code\u0026gt; using a reference count to determine when the object is no longer needed.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;code\u0026gt;scoped_ptr\u0026amp;lt;T\u0026amp;gt;\u0026lt;/code\u0026gt; is a pointer automatically deleted when it goes out of scope. No assignment is possible.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;code\u0026gt;intrusive_ptr\u0026amp;lt;T\u0026amp;gt;\u0026lt;/code\u0026gt; is another reference counting pointer. It provides better performance than \u0026lt;code\u0026gt;shared_ptr\u0026lt;/code\u0026gt;, but requires the type \u0026lt;code\u0026gt;T\u0026lt;/code\u0026gt; to provide its own reference counting mechanism.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;code\u0026gt;weak_ptr\u0026amp;lt;T\u0026amp;gt;\u0026lt;/code\u0026gt; is a weak pointer, working in conjunction with \u0026lt;code\u0026gt;shared_ptr\u0026lt;/code\u0026gt; to avoid circular references.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;code\u0026gt;shared_array\u0026amp;lt;T\u0026amp;gt;\u0026lt;/code\u0026gt; is like \u0026lt;code\u0026gt;shared_ptr\u0026lt;/code\u0026gt;, but for arrays of \u0026lt;code\u0026gt;T\u0026lt;/code\u0026gt;.\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;code\u0026gt;scoped_array\u0026amp;lt;T\u0026amp;gt;\u0026lt;/code\u0026gt; is like \u0026lt;code\u0026gt;scoped_ptr\u0026lt;/code\u0026gt;, but for arrays of \u0026lt;code\u0026gt;T\u0026lt;/code\u0026gt;.\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\n\u0026lt;p\u0026gt;These are just one linear descriptions of each and can be used as per need, for further detail and examples one can look at the documentation of Boost.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Additionally, the C++ standard library provides three smart pointers; \u0026lt;code\u0026gt;std::unique_ptr\u0026lt;/code\u0026gt; for unique ownership, \u0026lt;code\u0026gt;std::shared_ptr\u0026lt;/code\u0026gt; for shared ownership and \u0026lt;code\u0026gt;std::weak_ptr\u0026lt;/code\u0026gt;. \u0026lt;code\u0026gt;std::auto_ptr\u0026lt;/code\u0026gt; existed in C++03 but is now deprecated.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Most kinds of smart pointers handle disposing of the pointer-to object for you. It\u0026apos;s very handy because you don\u0026apos;t have to think about disposing of objects manually anymore.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;The most commonly-used smart pointers are \u0026lt;code\u0026gt;std::tr1::shared_ptr\u0026lt;/code\u0026gt; (or \u0026lt;code\u0026gt;boost::shared_ptr\u0026lt;/code\u0026gt;), and, less commonly, \u0026lt;code\u0026gt;std::auto_ptr\u0026lt;/code\u0026gt;. I recommend regular use of \u0026lt;code\u0026gt;shared_ptr\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;code\u0026gt;shared_ptr\u0026lt;/code\u0026gt; is very versatile and deals with a large variety of disposal scenarios, including cases where objects need to be \u0026quot;passed across DLL boundaries\u0026quot; (the common nightmare case if different \u0026lt;code\u0026gt;libc\u0026lt;/code\u0026gt;s are used between your code and the DLLs).\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Here is the Link for similar answers : \u0026lt;a href=\u0026quot;http://sickprogrammersarea.blogspot.in/2014/03/technical-interview-questions-on-c_6.html\u0026quot;\u0026gt;http://sickprogrammersarea.blogspot.in/2014/03/technical-interview-questions-on-c_6.html\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;A smart pointer is an object that acts, looks and feels like a normal pointer but offers more functionality. In C++, smart pointers are implemented as template classes that encapsulate a pointer and override standard pointer operators. They have a number of advantages over regular pointers. They are guaranteed to be initialized as either null pointers or pointers to a heap object. Indirection through a null pointer is checked. No delete is ever necessary. Objects are automatically freed when the last pointer to them has gone away. One significant problem with these smart pointers is that unlike regular pointers, they don\u0026apos;t respect inheritance. Smart pointers are unattractive for polymorphic code. Given below is an example for the implementation of smart pointers.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Example:\u0026lt;/strong\u0026gt; \u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;template\u0026lt;/span\u0026gt; \u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;X\u0026lt;/span\u0026gt;\u0026amp;gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;smart_pointer\u0026lt;/span\u0026gt;\n{\n          \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt;:\n               \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;smart_pointer\u0026lt;/span\u0026gt;();                          \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// makes a null pointer\u0026lt;/span\u0026gt;\n               \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;smart_pointer\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; X\u0026amp;amp; x)            \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// makes pointer to copy of x\u0026lt;/span\u0026gt;\n\n               X\u0026amp;amp; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;operator\u0026lt;/span\u0026gt; *( );\n               \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; X\u0026amp;amp; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;operator\u0026lt;/span\u0026gt;*( ) \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt;;\n               X* \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;operator\u0026lt;/span\u0026gt;-\u0026amp;gt;() \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt;;\n\n               \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;smart_pointer\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; smart_pointer \u0026amp;lt;X\u0026amp;gt; \u0026amp;amp;);\n               \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; smart_pointer \u0026amp;lt;X\u0026amp;gt; \u0026amp;amp; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;operator\u0026lt;/span\u0026gt; =(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; smart_pointer\u0026amp;lt;X\u0026amp;gt;\u0026amp;amp;);\n               ~\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;smart_pointer\u0026lt;/span\u0026gt;();\n          \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;private\u0026lt;/span\u0026gt;:\n               \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//...\u0026lt;/span\u0026gt;\n};\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;This class implement a smart pointer to an object of type X. The object itself is located on the heap. Here is how to use it:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;smart_pointer \u0026amp;lt;employee\u0026amp;gt; p= \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;employee\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Harris\u0026quot;\u0026lt;/span\u0026gt;,\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1333\u0026lt;/span\u0026gt;);\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Like other overloaded operators, p will behave like a regular pointer,\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;cout\u0026amp;lt;\u0026amp;lt;*p;\np-\u0026amp;gt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;raise_salary\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0.5\u0026lt;/span\u0026gt;);\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Let T be a class in this tutorial \nPointers in C++ can be divided into 3 types :\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;1) \u0026lt;strong\u0026gt;Raw pointers\u0026lt;/strong\u0026gt; :\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;T a;  \nT * _ptr = \u0026amp;amp;a; \n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;They hold a memory address to a location in memory. Use with caution , as programs become complex hard to keep track. \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Pointers with const data or address { Read backwards } \u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;T a ; \n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; T * ptr1 = \u0026amp;amp;a ; \nT \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; * ptr1 = \u0026amp;amp;a ;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Pointer to a data type T which is a const. Meaning you cannot change the data type using the pointer. ie \u0026lt;code\u0026gt;*ptr1 = 19\u0026lt;/code\u0026gt; ; will not work. But you can move the pointer. ie \u0026lt;code\u0026gt;ptr1++ , ptr1--\u0026lt;/code\u0026gt; ;  etc will work.\nRead backwards : pointer to type T which is const \u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;  T * \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; ptr2 ;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;A const pointer to a data type T . Meaning you cannot move the pointer but you can change the value pointed to by the pointer. ie \u0026lt;code\u0026gt;*ptr2 = 19\u0026lt;/code\u0026gt; will work but \u0026lt;code\u0026gt;ptr2++ ; ptr2--\u0026lt;/code\u0026gt; etc will not work. Read backwards : const pointer to a type T \u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; T * \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; ptr3 ; \n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;A const pointer to a const data type T . Meaning you cannot either move the pointer nor can you change the data type pointer to be the pointer. ie . \u0026lt;code\u0026gt;ptr3-- ; ptr3++ ; *ptr3 = 19;\u0026lt;/code\u0026gt; will not work \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;3) \u0026lt;strong\u0026gt;Smart Pointers\u0026lt;/strong\u0026gt; : { \u0026lt;code\u0026gt;#include \u0026amp;lt;memory\u0026amp;gt;\u0026lt;/code\u0026gt; } \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Shared Pointer\u0026lt;/strong\u0026gt;: \u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;  T a ; \n     \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//shared_ptr\u0026amp;lt;T\u0026amp;gt; shptr(new T) ; not recommended but works \u0026lt;/span\u0026gt;\n     shared_ptr\u0026amp;lt;T\u0026amp;gt; shptr = \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;make_shared\u0026lt;/span\u0026gt;\u0026amp;lt;T\u0026amp;gt;(); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// faster + exception safe\u0026lt;/span\u0026gt;\n\n     std::cout \u0026amp;lt;\u0026amp;lt; shptr.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;use_count\u0026lt;/span\u0026gt;() ; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// 1 //  gives the number of \u0026quot; \u0026lt;/span\u0026gt;\nthings \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot; pointing to it. \n     T * temp = shptr.get(); // gives a pointer to object\n\n     // shared_pointer used like a regular pointer to call member functions\n      shptr-\u0026amp;gt;memFn();\n     (*shptr).memFn(); \n\n    //\n     shptr.reset() ; // frees the object pointed to be the ptr \n     shptr = nullptr ; // frees the object \n     shptr = make_shared\u0026amp;lt;T\u0026amp;gt;() ; // frees the original object and points to new object\n\u0026lt;/span\u0026gt;\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Implemented using reference counting to keep track of how many \u0026quot; things \u0026quot; point to the object pointed to by the pointer. When this count goes to 0 , the object is automatically deleted , ie objected is deleted when all the share_ptr pointing to the object goes out of scope. \nThis gets rid of the headache of having to delete objects which you have allocated using new. \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Weak Pointer :\u0026lt;/strong\u0026gt; \n    Helps deal with cyclic reference which arises when using Shared Pointer\n    If you have two objects pointed to by two shared pointers and there is an internal shared pointer pointing to each others shared pointer then there will be a cyclic reference and the object will not be deleted when shared pointers go out of scope. To solve this , change the internal member from a shared_ptr to weak_ptr. Note : To access the element pointed to by a weak pointer use lock() , this returns a weak_ptr. \u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;T a ; \nshared_ptr\u0026amp;lt;T\u0026amp;gt; shr = \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;make_shared\u0026lt;/span\u0026gt;\u0026amp;lt;T\u0026amp;gt;() ; \nweak_ptr\u0026amp;lt;T\u0026amp;gt; wk = shr ; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// initialize a weak_ptr from a shared_ptr \u0026lt;/span\u0026gt;\nwk.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;lock\u0026lt;/span\u0026gt;()-\u0026amp;gt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;memFn\u0026lt;/span\u0026gt;() ; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// use lock to get a shared_ptr \u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//   ^^^ Can lead to exception if the shared ptr has gone out of scope\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt;(!wk.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;expired\u0026lt;/span\u0026gt;()) wk.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;lock\u0026lt;/span\u0026gt;()-\u0026amp;gt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;memFn\u0026lt;/span\u0026gt;() ;\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Check if shared ptr has gone out of scope before access\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;See : \u0026lt;a href=\u0026quot;https://stackoverflow.com/questions/12030650/when-is-stdweak-ptr-useful\u0026quot;\u0026gt;When is std::weak_ptr useful?\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Unique Pointer :\u0026lt;/strong\u0026gt; \n    Light weight smart pointer with exclusive ownership. Use when pointer points to unique objects without sharing the objects between the pointers.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;unique_ptr\u0026amp;lt;T\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;uptr\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; T)\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;;\nuptr-\u0026amp;gt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;memFn\u0026lt;/span\u0026gt;(); \n\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//T * ptr = uptr.release(); // uptr becomes null and object is pointed to by ptr\u0026lt;/span\u0026gt;\nuptr.\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;reset\u0026lt;/span\u0026gt;() ; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// deletes the object pointed to by uptr \u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;To change the object pointed to by the unique ptr , use move semantics\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;unique_ptr\u0026amp;lt;T\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;uptr1\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; T)\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;;\n\u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;unique_ptr\u0026amp;lt;T\u0026amp;gt; \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;uptr2\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; T)\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;;\nuptr2 = std::\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;move\u0026lt;/span\u0026gt;(uptr1); \n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// object pointed by uptr2 is deleted and \u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// object pointed by uptr1 is pointed to by uptr2\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// uptr1 becomes null \u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;References : \n    They can essentially be though of as const pointers, ie a pointer which is const and cannot be moved with better syntax.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;See : \u0026lt;a href=\u0026quot;https://stackoverflow.com/questions/57483/what-are-the-differences-between-a-pointer-variable-and-a-reference-variable-in\u0026quot;\u0026gt;What are the differences between a pointer variable and a reference variable in C++?\u0026lt;/a\u0026gt;  \u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;r-value reference : reference to a temporary object   \nl-value reference : reference to an object whose address can be obtained\n\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; reference : reference to a data type which is \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;const\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;and\u0026lt;/span\u0026gt; cannot be modified \n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Reference : \n\u0026lt;a href=\u0026quot;https://www.youtube.com/channel/UCEOGtxYTB6vo6MQ-WQ9W_nQ\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;https://www.youtube.com/channel/UCEOGtxYTB6vo6MQ-WQ9W_nQ\u0026lt;/a\u0026gt; \nThanks to Andre for pointing out this question.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;\u0026lt;a href=\u0026quot;http://en.wikipedia.org/wiki/Smart_pointer\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;http://en.wikipedia.org/wiki/Smart_pointer\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;In computer science, a smart pointer\n  is an abstract data type that\n  simulates a pointer while providing\n  additional features, such as automatic\n  garbage collection or bounds checking.\n  These additional features are intended\n  to reduce bugs caused by the misuse of\n  pointers while retaining efficiency.\n  Smart pointers typically keep track of\n  the objects that point to them for the\n  purpose of memory management. The\n  misuse of pointers is a major source\n  of bugs: the constant allocation,\n  deallocation and referencing that must\n  be performed by a program written\n  using pointers makes it very likely\n  that some memory leaks will occur.\n  Smart pointers try to prevent memory\n  leaks by making the resource\n  deallocation automatic: when the\n  pointer to an object (or the last in a\n  series of pointers) is destroyed, for\n  example because it goes out of scope,\n  the pointed object is destroyed too.\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n    ","\n\u0026lt;p\u0026gt;A smart pointer is a class, a wrapper of a normal pointer. Unlike normal pointers, smart points life circle is based on a reference count (how many time the smart pointer object is assigned). So whenever a smart pointer is assigned to another one, the internal reference count plus plus. And whenever the object goes out of scope, the reference count minus minus.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Automatic pointer, though looks similar, is totally different from smart pointer. It is a convenient class that deallocates the resource whenever an automatic pointer object goes out of variable scope. To some extent, it makes a pointer (to dynamically allocated memory) works similar to a stack variable (statically allocated in compiling time).\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;What is a smart pointer.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Long version, In principle:\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;a href=\u0026quot;https://web.stanford.edu/class/archive/cs/cs106l/cs106l.1192/lectures/lecture15/15_RAII.pdf\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;https://web.stanford.edu/class/archive/cs/cs106l/cs106l.1192/lectures/lecture15/15_RAII.pdf\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;A modern C++ idiom:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;RAII: Resource Acquisition Is Initialization.\n\n When you initialize an object, \u0026lt;span class=\u0026quot;hljs-function\u0026quot;\u0026gt;it should already have \n  acquired any resources it \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;needs\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(in the constructor)\u0026lt;/span\u0026gt;.\n\n\n When an object goes out of scope, it should release every \n  resource it is \u0026lt;span class=\u0026quot;hljs-title\u0026quot;\u0026gt;using\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;(\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;using\u0026lt;/span\u0026gt; the destructor)\u0026lt;/span\u0026gt;.\n\u0026lt;/span\u0026gt;\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;key point:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt; There should never be a half-ready \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;or\u0026lt;/span\u0026gt; half-dead object.\n When an object is created, it should be in a ready state.\n When an object goes out of scope, it should release its resources. \n The user shouldnt have to \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;do\u0026lt;/span\u0026gt; anything more. \n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Raw Pointers violate RAII\u0026lt;/strong\u0026gt;: It need user to delete manually when the pointers go out of scope.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;RAII solution is:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;Have a smart pointer \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt;:\n Allocates the memory when initialized\n Frees the memory when destructor is called\n Allows access to underlying pointer\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;For smart pointer need copy and share, use shared_ptr:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt; use another memory to store Reference counting \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;and\u0026lt;/span\u0026gt; shared.\n increment when copy, decrement when destructor.\n \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;delete\u0026lt;/span\u0026gt; memory when Reference counting is \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0.\u0026lt;/span\u0026gt; \n  also \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;delete\u0026lt;/span\u0026gt; memory that store Reference counting.\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;for smart pointer not own the raw pointer, use weak_ptr:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;not\u0026lt;/span\u0026gt; change Reference counting.\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;shared_ptr usage:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;correct way:\nstd::shared_ptr\u0026amp;lt;T\u0026amp;gt; t1 = std::\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;make_shared\u0026lt;/span\u0026gt;\u0026amp;lt;T\u0026amp;gt;(TArgs);\nstd::shared_ptr\u0026amp;lt;T\u0026amp;gt; t2 = std::\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;shared_ptr\u0026lt;/span\u0026gt;\u0026amp;lt;T\u0026amp;gt;(\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;T\u0026lt;/span\u0026gt;(Targs));\n\nwrong way:\nT* pt = \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;T\u0026lt;/span\u0026gt;(TArgs); \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// never exposure the raw pointer\u0026lt;/span\u0026gt;\nshared_ptr\u0026amp;lt;T\u0026amp;gt; t1 = \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;shared_ptr\u0026lt;/span\u0026gt;\u0026amp;lt;T\u0026amp;gt;(pt);\nshared_ptr\u0026amp;lt;T\u0026amp;gt; t2 = \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;shared_ptr\u0026lt;/span\u0026gt;\u0026amp;lt;T\u0026amp;gt;(pt);\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;Always avoid using raw pointer.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;For scenario that have to use raw pointer:\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;a href=\u0026quot;https://stackoverflow.com/a/19432062/2482283\u0026quot;\u0026gt;https://stackoverflow.com/a/19432062/2482283\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;For raw pointer that not nullptr, use reference instead.\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;not\u0026lt;/span\u0026gt; use T*\nuse T\u0026amp;amp;  \n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;For optional reference which maybe nullptr, use raw pointer, and which means:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-cpp s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-cpp\u0026quot;\u0026gt;T* pt; is optional reference \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;and\u0026lt;/span\u0026gt; maybe \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;nullptr\u0026lt;/span\u0026gt;.\nNot own the raw pointer, \nRaw pointer is managed by some one \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;else\u0026lt;/span\u0026gt;.\nI only know that the caller is sure it is \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;not\u0026lt;/span\u0026gt; released now.\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Smart Pointers are those where you don\u0026apos;t have to worry about Memory De-Allocation, Resource Sharing and Transfer. \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;You can very well use these pointer in the similar way as any allocation works in Java. In java Garbage Collector does the trick, while in Smart Pointers, the trick is done by Destructors.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;The existing answers are good but don\u0026apos;t cover what to do when a smart pointer is not the (complete) answer to the problem you are trying to solve.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Among other things (explained well in other answers) using a smart pointer is a possible solution to \u0026lt;a href=\u0026quot;https://stackoverflow.com/questions/48454208/how-do-we-use-a-abstract-class-as-a-function-return-type\u0026quot;\u0026gt;How do we use a abstract class as a function return type?\u0026lt;/a\u0026gt; which has been marked as a duplicate of this question. However, the first question to ask if tempted to specify an abstract (or in fact, any) base class as a return type in C++ is \u0026quot;what do you really mean?\u0026quot;. There is a good discussion (with further references) of idiomatic object oriented programming in C++ (and how this is different to other languages) in the documentation of the \u0026lt;a href=\u0026quot;http://www.boost.org/doc/libs/1_66_0/libs/ptr_container/doc/guidelines.html#recommended-practice-for-object-oriented-programming\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;boost pointer container library\u0026lt;/a\u0026gt;. In summary, in C++ you have to think about ownership. Which smart pointers help you with, but are not the only solution, or always a complete solution (they don\u0026apos;t give you polymorphic copy) and are not always a solution you want to expose in your interface (and a function return sounds an awful lot like an interface). It might be sufficient to return a reference, for example. But in all of these cases (smart pointer, pointer container or simply returning a reference) you have changed the return from a \u0026lt;em\u0026gt;value\u0026lt;/em\u0026gt; to some form of \u0026lt;em\u0026gt;reference\u0026lt;/em\u0026gt;. If you really needed copy you may need to add more boilerplate \u0026quot;idiom\u0026quot; or move beyond idiomatic (or otherwise) OOP in C++ to more generic polymorphism using libraries like \u0026lt;a href=\u0026quot;http://stlab.adobe.com/group__poly__related.html\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;Adobe Poly\u0026lt;/a\u0026gt; or \u0026lt;a href=\u0026quot;http://www.boost.org/doc/libs/1_66_0/doc/html/boost_typeerasure.html\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;Boost.TypeErasure\u0026lt;/a\u0026gt;.\u0026lt;/p\u0026gt;\n    "],"id":414,"title":"What is a smart pointer and when should I use one?","content":"\n                \n\u0026lt;p\u0026gt;What is a smart pointer and when should I use one?\u0026lt;/p\u0026gt;\n    ","slug":"what-is-a-smart-pointer-and-when-should-i-use-one-1657387905461","postType":"QUESTION","createdAt":"2022-07-09T17:31:45.000Z","updatedAt":"2022-07-09T17:31:45.000Z","tags":[{"id":2202,"name":"smart-pointers","slug":"smart-pointers","createdAt":"2022-07-09T17:31:45.000Z","updatedAt":"2022-07-09T17:31:45.000Z","Questions_Tags":{"questionId":414,"tagId":2202}}],"relatedQuestions":[{"title":"What is a smart pointer and when should I use one?","slug":"what-is-a-smart-pointer-and-when-should-i-use-one-1657387905461","tags":[{"name":"smart-pointers","Questions_Tags":{"questionId":414,"tagId":2202}}]}]},"randomQuestions":[{"title":"mysqli or die, does it have to die?","slug":"mysqli-or-die-does-it-have-to-die-1657388533922"},{"title":"event.preventDefault() vs. return false","slug":"event.preventdefault()-vs.-return-false-1657387458377"},{"title":"How does the \"this\" keyword work, and when should it be used?","slug":"how-does-the-\"this\"-keyword-work-and-when-should-it-be-used-1657384384385"},{"title":"What is the JavaScript version of sleep()?","slug":"what-is-the-javascript-version-of-sleep()-1657387391406"},{"title":"Why does Spring MVC respond with a 404 and report \"No mapping found for HTTP request with URI [...] in DispatcherServlet\"?","slug":"why-does-spring-mvc-respond-with-a-404-and-report-\"no-mapping-found-for-http-request-with-uri-...-in-dispatcherservlet\"-1657387995250"},{"title":"Find object by id in an array of JavaScript objects","slug":"find-object-by-id-in-an-array-of-javascript-objects-1657387572087"},{"title":"What happens if you use the 32-bit int 0x80 Linux ABI in 64-bit code?","slug":"what-happens-if-you-use-the-32-bit-int-0x80-linux-abi-in-64-bit-code-1657388560485"},{"title":"Get the data received in a Flask request","slug":"get-the-data-received-in-a-flask-request-1657387804432"},{"title":"How can I make an AJAX call without jQuery?","slug":"how-can-i-make-an-ajax-call-without-jquery-1657388448955"},{"title":"Sorting object property by values","slug":"sorting-object-property-by-values-1657388367300"},{"title":"What is a plain English explanation of \"Big O\" notation?","slug":"what-is-a-plain-english-explanation-of-\"big-o\"-notation-1657387641953"},{"title":"What is a smart pointer and when should I use one?","slug":"what-is-a-smart-pointer-and-when-should-i-use-one-1657387905461"},{"title":"Why is 24.0000 not equal to 24.0000 in MATLAB?","slug":"why-is-24.0000-not-equal-to-24.0000-in-matlab-1657388376753"},{"title":"The ViewData item that has the key 'XXX' is of type 'System.Int32' but must be of type 'IEnumerable\u003cSelectListItem\u003e'","slug":"the-viewdata-item-that-has-the-key-'xxx'-is-of-type-'system.int32'-but-must-be-of-type-'ienumerablelessselectlistitemgreater'-1657388454191"},{"title":"Sort a Map\u003cKey, Value\u003e by values","slug":"sort-a-maplesskey-valuegreater-by-values-1657387443904"},{"title":"Tkinter: AttributeError: NoneType object has no attribute \u003cattribute name\u003e","slug":"tkinter:-attributeerror:-nonetype-object-has-no-attribute-lessattribute-namegreater-1657385472410"},{"title":"Flexbox: center horizontally and vertically","slug":"flexbox:-center-horizontally-and-vertically-1657384587888"},{"title":"Difference between sh and Bash","slug":"difference-between-sh-and-bash-1657388197713"},{"title":"How do I Pandas group-by to get sum?","slug":"how-do-i-pandas-group-by-to-get-sum-1657387908708"},{"title":"Error in finding last used cell in Excel with VBA","slug":"error-in-finding-last-used-cell-in-excel-with-vba-1657384584748"}]},"__N_SSG":true},"page":"/questions/[slug]","query":{"slug":"what-is-a-smart-pointer-and-when-should-i-use-one-1657387905461"},"buildId":"Zo3C7AOWQzKM9qqyzx2hf","isFallback":false,"gsp":true,"locale":"en","locales":["en"],"defaultLocale":"en","scriptLoader":[]}</script></body></html>