<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><meta name="twitter:card" content="summary_large_image"/><meta name="twitter:site" content="@solutionschecker.com"/><meta name="twitter:creator" content="@solutionschecker.com"/><meta property="og:url" content="https://solutionschecker.com"/><meta property="og:type" content="website"/><meta property="og:image" content="https://solutionschecker.com/solutions-checker-banner.png"/><meta property="og:image:alt" content="Find solution for coding, HTML, CSS, JAVASCRIPT, MYSQL, PHP, PYTHON,... quickly. - solutionschecker.com"/><script type="application/ld+json">{"@context":"https://schema.org","@type":"Organization","logo":"/logo.svg","url":"https://solutionschecker.com"}</script><title>What does &quot;Fatal error: Unexpectedly found nil while unwrapping an Optional value&quot; mean? | Solutions Checker</title><meta name="robots" content="index,follow"/><meta name="description" content="My Swift program is crashing with EXC_BAD_INSTRUCTION and one of the following similar errors. What does this error mean, and how do I fix it?


  Fatal error: Unexpectedly found nil while unwrapping an Optional value  


or


  Fatal error: Unexpectedly found nil while implicitly unwrapping an Optional value  




This post is intended to collect answers to &quot;unexpectedly found nil&quot; issues, so that they are not scattered and hard to find. Feel free to add your own answer or edit the existing wiki answer.
    "/><meta property="og:title" content="What does &quot;Fatal error: Unexpectedly found nil while unwrapping an Optional value&quot; mean? | Solutions Checker"/><meta property="og:description" content="My Swift program is crashing with EXC_BAD_INSTRUCTION and one of the following similar errors. What does this error mean, and how do I fix it?


  Fatal error: Unexpectedly found nil while unwrapping an Optional value  


or


  Fatal error: Unexpectedly found nil while implicitly unwrapping an Optional value  




This post is intended to collect answers to &quot;unexpectedly found nil&quot; issues, so that they are not scattered and hard to find. Feel free to add your own answer or edit the existing wiki answer.
    "/><script type="application/ld+json">{"@context":"https://schema.org","@type":"QAPage","mainEntity":{"name":"What does &quot;Fatal error: Unexpectedly found nil while unwrapping an Optional value&quot; mean?","text":"My Swift program is crashing with EXC_BAD_INSTRUCTION and one of the following similar errors. What does this error mean, and how do I fix it?\n\n\n  Fatal error: Unexpectedly found nil while unwrapping an Optional value  \n\n\nor\n\n\n  Fatal error: Unexpectedly found nil while implicitly unwrapping an Optional value  \n\n\n\n\nThis post is intended to collect answers to &quot;unexpectedly found nil&quot; issues, so that they are not scattered and hard to find. Feel free to add your own answer or edit the existing wiki answer.\n    ","answerCount":15,"upVoteCount":500,"suggestedAnswer":[{"text":"Background: Whats an Optional?\nIn Swift, Optional&lt;Wrapped&gt; is an option type: it can contain any value from the original (&quot;Wrapped&quot;) type, or no value at all (the special value nil). An optional value must be unwrapped before it can be used.\nOptional is a generic type, which means that Optional&lt;Int&gt; and Optional&lt;String&gt; are distinct types  the type inside &lt;&gt; is called the Wrapped type. Under the hood, an Optional is an enum with two cases: .some(Wrapped) and .none, where .none is equivalent to nil.\nOptionals can be declared using the named type Optional&lt;T&gt;, or (most commonly) as a shorthand with a ? suffix.\nvar anInt: Int = 42\nvar anOptionalInt: Int? = 42\nvar anotherOptionalInt: Int?  // `nil` is the default when no value is provided\nvar aVerboseOptionalInt: Optional&lt;Int&gt;  // equivalent to `Int?`\n\nanOptionalInt = nil // now this variable contains nil instead of an integer\n\nOptionals are a simple yet powerful tool to express your assumptions while writing code. The compiler can use this information to prevent you from making mistakes. From The Swift Programming Language:\n\nSwift is a type-safe language, which means the language helps you to be clear about the types of values your code can work with. If part of your code requires a String, type safety prevents you from passing it an Int by mistake. Likewise, type safety prevents you from accidentally passing an optional String to a piece of code that requires a non-optional String. Type safety helps you catch and fix errors as early as possible in the development process.\n\nSome other programming languages also have generic option types: for example, Maybe in Haskell, option in Rust, and optional in C++17.\nIn programming languages without option types, a particular &quot;sentinel&quot; value is often used to indicate the absence of a valid value. In Objective-C, for example, nil (the null pointer) represents the lack of an object. For primitive types such as int, a null pointer can&apos;t be used, so you would need either a separate variable (such as value: Int and isValid: Bool) or a designated sentinel value (such as -1 or INT_MIN). These approaches are error-prone because it&apos;s easy to forget to check isValid or to check for the sentinel value. Also, if a particular value is chosen as the sentinel, that means it can no longer be treated as a valid value.\nOption types such as Swift&apos;s Optional solve these problems by introducing a special, separate nil value (so you don&apos;t have to designate a sentinel value), and by leveraging the strong type system so the compiler can help you remember to check for nil when necessary.\n\nWhy did I get Fatal error: Unexpectedly found nil while unwrapping an Optional value?\nIn order to access an optionals value (if it has one at all), you need to unwrap it. An optional value can be unwrapped safely or forcibly. If you force-unwrap an optional, and it didn&apos;t have a value, your program will crash with the above message.\nXcode will show you the crash by highlighting a line of code. The problem occurs on this line.\n\nThis crash can occur with two different kinds of force-unwrap:\n1. Explicit Force Unwrapping\nThis is done with the ! operator on an optional. For example:\nlet anOptionalString: String?\nprint(anOptionalString!) // &lt;- CRASH\n\n\nFatal error: Unexpectedly found nil while unwrapping an Optional value\n\nAs anOptionalString is nil here, you will get a crash on the line where you force unwrap it.\n2. Implicitly Unwrapped Optionals\nThese are defined with  a !, rather than a ? after the type.\nvar optionalDouble: Double!   // this value is implicitly unwrapped wherever it&apos;s used\n\nThese optionals are assumed to contain a value. Therefore whenever you access an implicitly unwrapped optional, it will automatically be force unwrapped for you. If it doesnt contain a value, it will crash.\nprint(optionalDouble) // &lt;- CRASH\n\n\nFatal error: Unexpectedly found nil while implicitly unwrapping an Optional value\n\nIn order to work out which variable caused the crash, you can hold  while clicking to show the definition, where you might find the optional type.\n\nIBOutlets, in particular, are usually implicitly unwrapped optionals. This is because your xib or storyboard will link up the outlets at runtime, after initialization. You should therefore ensure that youre not accessing outlets before they&apos;re loaded in. You also should check that the connections are correct in your storyboard/xib file, otherwise the values will be nil at runtime, and therefore crash when they are implicitly unwrapped. When fixing connections, try deleting the lines of code that define your outlets, then reconnect them.\n\nWhen should I ever force unwrap an Optional?\nExplicit Force Unwrapping\nAs a general rule, you should never explicitly force unwrap an optional with the ! operator. There may be cases where using ! is acceptable  but you should only ever be using it if you are 100% sure that the optional contains a value.\nWhile there may be an occasion where you can use force unwrapping, as you know for a fact that an optional contains a value  there is not a single place where you cannot safely unwrap that optional instead.\n\nImplicitly Unwrapped Optionals\nThese variables are designed so that you can defer their assignment until later in your code. It is your responsibility to ensure they have a value before you access them. However, because they involve force unwrapping, they are still inherently unsafe  as they assume your value is non-nil, even though assigning nil is valid.\nYou should only be using implicitly unwrapped optionals as a last resort. If you can use a lazy variable, or provide a default value for a variable  you should do so instead of using an implicitly unwrapped optional.\nHowever, there are a few scenarios where implicitly unwrapped optionals are beneficial, and you are still able to use various ways of safely unwrapping them as listed below  but you should always use them with due caution.\n\nHow can I safely deal with Optionals?\nThe simplest way to check whether an optional contains a value, is to compare it to nil.\nif anOptionalInt != nil {\n    print(&quot;Contains a value!&quot;)\n} else {\n    print(&quot;Doesnt contain a value.&quot;)\n}\n\nHowever, 99.9% of the time when working with optionals, youll actually want to access the value it contains, if it contains one at all. To do this, you can use Optional Binding.\nOptional Binding\nOptional Binding allows you to check if an optional contains a value  and allows you to assign the unwrapped value to a new variable or constant. It uses the syntax if let x = anOptional {...} or if var x = anOptional {...}, depending if you need to modify the value of the new variable after binding it.\nFor example:\nif let number = anOptionalInt {\n    print(&quot;Contains a value! It is \\(number)!&quot;)\n} else {\n    print(&quot;Doesnt contain a number&quot;)\n}\n\nWhat this does is first check that the optional contains a value. If it does, then the unwrapped value is assigned to  a new variable (number)  which you can then freely use as if it were non-optional. If the optional doesnt contain a value, then the else clause will be invoked, as you would expect.\nWhats neat about optional binding, is you can unwrap multiple optionals at the same time. You can just separate the statements with a comma. The statement will succeed if all the optionals were unwrapped.\nvar anOptionalInt : Int?\nvar anOptionalString : String?\n\nif let number = anOptionalInt, let text = anOptionalString {\n    print(&quot;anOptionalInt contains a value: \\(number). And so does anOptionalString, its: \\(text)&quot;)\n} else {\n    print(&quot;One or more of the optionals dont contain a value&quot;)\n}\n\nAnother neat trick is that you can also use commas to check for a certain condition on the value, after unwrapping it.\nif let number = anOptionalInt, number &gt; 0 {\n    print(&quot;anOptionalInt contains a value: \\(number), and its greater than zero!&quot;)\n}\n\nThe only catch with using optional binding within an if statement, is that you can only access the unwrapped value from within the scope of the statement. If you need access to the value from outside of the scope of the statement, you can use a guard statement.\nA guard statement allows you to define a condition for success  and the current scope will only continue executing if that condition is met. They are defined with the syntax guard condition else {...}.\nSo, to use them with an optional binding, you can do this:\nguard let number = anOptionalInt else {\n    return\n}\n\n(Note that within the guard body, you must use one of the control transfer statements in order to exit the scope of the currently executing code).\nIf anOptionalInt contains a value, it will be unwrapped and assigned to the new number constant. The code after the guard will then continue executing. If it doesnt contain a value  the guard will execute the code within the brackets, which will lead to transfer of control, so that the code immediately after will not be executed.\nThe real neat thing about guard statements is the unwrapped value is now available to use in code that follows the statement (as we know that future code can only execute if the optional has a value). This is a great for eliminating pyramids of doom created by nesting multiple if statements.\nFor example:\nguard let number = anOptionalInt else {\n    return\n}\n\nprint(&quot;anOptionalInt contains a value, and its: \\(number)!&quot;)\n\nGuards also support the same neat tricks that the if statement supported, such as unwrapping multiple optionals at the same time and using the where clause.\nWhether you use an if or guard statement completely depends on whether any future code requires the optional to contain a value.\nNil Coalescing Operator\nThe Nil Coalescing Operator is a nifty shorthand version of the ternary conditional operator, primarily designed to convert optionals to non-optionals. It has the syntax a ?? b, where a is an optional type and b is the same type as a (although usually non-optional).\nIt essentially lets you say If a contains a value, unwrap it. If it doesnt then return b instead. For example, you could use it like this:\nlet number = anOptionalInt ?? 0\n\nThis will define a number constant of Int type, that will either contain the value of anOptionalInt, if it contains a value, or 0 otherwise.\nIts just shorthand for:\nlet number = anOptionalInt != nil ? anOptionalInt! : 0\n\nOptional Chaining\nYou can use Optional Chaining in order to call a method or access a property on an optional. This is simply done by suffixing the variable name with a ? when using it.\nFor example, say we have a variable foo, of type an optional Foo instance.\nvar foo : Foo?\n\nIf we wanted to call a method on foo that doesnt return anything, we can simply do:\nfoo?.doSomethingInteresting()\n\nIf foo contains a value, this method will be called on it. If it doesnt, nothing bad will happen  the code will simply continue executing.\n(This is similar behaviour to sending messages to nil in Objective-C)\nThis can therefore also be used to set properties as well as call methods. For example:\nfoo?.bar = Bar()\n\nAgain, nothing bad will happen here if foo is nil. Your code will simply continue executing.\nAnother neat trick that optional chaining lets you do is check whether setting a property or calling a method was successful. You can do this by comparing the return value to nil.\n(This is because an optional value will return Void? rather than Void on a method that doesnt return anything)\nFor example:\nif (foo?.bar = Bar()) != nil {\n    print(&quot;bar was set successfully&quot;)\n} else {\n    print(&quot;bar wasnt set successfully&quot;)\n}\n\nHowever, things become a little bit more tricky when trying to access properties or call methods that return a value. Because foo is optional, anything returned from it will also be optional. To deal with this, you can either unwrap the optionals that get returned using one of the above methods  or unwrap foo itself before accessing methods or calling methods that return values.\nAlso, as the name suggests, you can chain these statements together. This means that if foo has an optional property baz, which has a property qux  you could write the following:\nlet optionalQux = foo?.baz?.qux\n\nAgain, because foo and baz are optional, the value returned from qux will always be an optional regardless of whether qux itself is optional.\nmap and flatMap\nAn often underused feature with optionals is the ability to use the map and flatMap functions. These allow you to apply non-optional transforms to optional variables. If an optional has a value, you can apply a given transformation to it. If it doesnt have a value, it will remain nil.\nFor example, lets say you have an optional string:\nlet anOptionalString:String?\n\nBy applying the map function to it  we can use the stringByAppendingString function in order to concatenate it to another string.\nBecause stringByAppendingString takes a non-optional string argument, we cannot input our optional string directly. However, by using map, we can use allow stringByAppendingString to be used if anOptionalString has a value.\nFor example:\nvar anOptionalString:String? = &quot;bar&quot;\n\nanOptionalString = anOptionalString.map {unwrappedString in\n    return &quot;foo&quot;.stringByAppendingString(unwrappedString)\n}\n\nprint(anOptionalString) // Optional(&quot;foobar&quot;)\n\nHowever, if anOptionalString doesnt have a value, map will return nil. For example:\nvar anOptionalString:String?\n\nanOptionalString = anOptionalString.map {unwrappedString in\n    return &quot;foo&quot;.stringByAppendingString(unwrappedString)\n}\n\nprint(anOptionalString) // nil\n\nflatMap works similarly to map, except it allows you to return another optional from within the closure body. This means you can input an optional into a process that requires a non-optional input, but can output an optional itself.\ntry!\nSwift&apos;s error handling system can be safely used with Do-Try-Catch:\ndo {\n    let result = try someThrowingFunc() \n} catch {\n    print(error)\n}\n\nIf someThrowingFunc() throws an error, the error will be safely caught in the catch block.\nThe error constant you see in the catch block has not been declared by us - it&apos;s automatically generated by catch.\nYou can also declare error yourself, it has the advantage of being able to cast it to a useful format, for example:\ndo {\n    let result = try someThrowingFunc()    \n} catch let error as NSError {\n    print(error.debugDescription)\n}\n\nUsing try this way is the proper way to try, catch and handle errors coming from throwing functions.\nThere&apos;s also try? which absorbs the error:\nif let result = try? someThrowingFunc() {\n    // cool\n} else {\n    // handle the failure, but there&apos;s no error information available\n}\n\nBut Swift&apos;s error handling system also provides a way to &quot;force try&quot; with try!:\nlet result = try! someThrowingFunc()\n\nThe concepts explained in this post also apply here: if an error is thrown, the application will crash.\nYou should only ever use try! if you can prove that its result will never fail in your context - and this is very rare.\nMost of the time you will use the complete Do-Try-Catch system - and the optional one, try?, in the rare cases where handling the error is not important.\n\nResources\n\nApple documentation on Swift Optionals\nWhen to use and when not to use implicitly unwrapped optionals\nLearn how to debug an iOS app crash\n\n    ","url":"/questions/[slug]#solution1","@type":"Answer","upvoteCount":0},{"text":"TL;DR answer\nWith very few exceptions, this rule is golden:\nAvoid use of !\nDeclare variable optional (?), not implicitly unwrapped optionals (IUO) (!)\nIn other words, rather use:\nvar nameOfDaughter: String?\nInstead of:\nvar nameOfDaughter: String!\nUnwrap optional variable using if let or guard let\nEither unwrap variable like this:\nif let nameOfDaughter = nameOfDaughter {\n    print(&quot;My daughters name is: \\(nameOfDaughter)&quot;)\n}\n\nOr like this:\nguard let nameOfDaughter = nameOfDaughter else { return }\nprint(&quot;My daughters name is: \\(nameOfDaughter)&quot;)\n\nThis answer was intended to be concise, for full comprehension read accepted answer\n\nResources\n\nAvoiding force unwrapping\n\n    ","url":"/questions/[slug]#solution2","@type":"Answer","upvoteCount":0},{"text":"This question comes up ALL THE TIME on SO. It&apos;s one of the first things that new Swift developers struggle with.\nBackground:\nSwift uses the concept of &quot;Optionals&quot; to deal with values that could contain a value, or not. In other languages like C, you might store a value of 0 in a variable to indicate that it contains no value. However, what if 0 is a valid value? Then you might use -1. What if -1 is a valid value? And so on.\nSwift optionals let you set up a variable of any type to contain either a valid value, or no value.\nYou put a question mark after the type when you declare a variable to mean (type x, or no value).\nAn optional is actually a container than contains either a variable of a given type, or nothing.\nAn optional needs to be &quot;unwrapped&quot; in order to fetch the value inside.\nThe &quot;!&quot; operator is a &quot;force unwrap&quot; operator. It says &quot;trust me. I know what I am doing. I guarantee that when this code runs, the variable will not contain nil.&quot; If you are wrong, you crash.\nUnless you really do know what you are doing, avoid the &quot;!&quot; force unwrap operator. It is probably the largest source of crashes for beginning Swift programmers.\nHow to deal with optionals:\nThere are lots of other ways of dealing with optionals that are safer. Here are some (not an exhaustive list)\nYou can use &quot;optional binding&quot; or &quot;if let&quot; to say &quot;if this optional contains a value, save that value into a new, non-optional variable. If the optional does not contain a value, skip the body of this if statement&quot;.\nHere is an example of optional binding with our foo optional:\nif let newFoo = foo //If let is called optional binding. {\n  print(&quot;foo is not nil&quot;)\n} else {\n  print(&quot;foo is nil&quot;)\n}\n\nNote that the variable you define when you use optional biding only exists (is only &quot;in scope&quot;) in the body of the if statement.\nAlternately, you could use a guard statement, which lets you exit your function if the variable is nil:\nfunc aFunc(foo: Int?) {\n  guard let newFoo = input else { return }\n  //For the rest of the function newFoo is a non-optional var\n}\n\nGuard statements were added in Swift 2. Guard lets you preserve the &quot;golden path&quot; through your code, and avoid ever-increasing levels of nested ifs that sometimes result from using &quot;if let&quot; optional binding.\nThere is also a construct called the &quot;nil coalescing operator&quot;. It takes the form &quot;optional_var ?? replacement_val&quot;. It returns a non-optional variable with the same type as the data contained in the optional. If the optional contains nil, it returns the value of the expression after the &quot;??&quot; symbol.\nSo you could use code like this:\nlet newFoo = foo ?? &quot;nil&quot; // &quot;??&quot; is the nil coalescing operator\nprint(&quot;foo = \\(newFoo)&quot;)\n\nYou could also use try/catch or guard error handling, but generally one of the other techniques above is cleaner.\nEDIT:\nAnother, slightly more subtle gotcha with optionals is &quot;implicitly unwrapped optionals. When we declare foo, we could say:\nvar foo: String!\n\nIn that case foo is still an optional, but you don&apos;t have to unwrap it to reference it.  That means any time you try to reference foo, you crash if it&apos;s nil.\nSo this code:\nvar foo: String!\n\n\nlet upperFoo = foo.capitalizedString\n\nWill crash on reference to foo&apos;s capitalizedString property even though we&apos;re not force-unwrapping foo. the print looks fine, but it&apos;s not.\nThus you want to be really careful with implicitly unwrapped optionals.  (and perhaps even avoid them completely until you have a solid understanding of optionals.)\nBottom line: When you are first learning Swift, pretend the &quot;!&quot; character is not part of the language. It&apos;s likely to get you into trouble.\n    ","url":"/questions/[slug]#solution3","@type":"Answer","upvoteCount":0},{"text":"Since the above answers clearly explains how to play safely with Optionals.\nI will try explain what Optionals are really in swift.\n\nAnother way to declare an optional variable is \n\nvar i : Optional&lt;Int&gt;\n\nAnd Optional type is nothing but an enumeration with two cases, i.e \n\n enum Optional&lt;Wrapped&gt; : ExpressibleByNilLiteral {\n    case none \n    case some(Wrapped)\n    .\n    .\n    .\n}\n\n\nSo to assign a nil to our variable &apos;i&apos;. We can do \nvar i = Optional&lt;Int&gt;.none\nor to assign a value, we will pass some value \nvar i = Optional&lt;Int&gt;.some(28) \n\nAccording to swift, &apos;nil&apos; is the absence of value.\nAnd to create an instance initialized with nil We have to conform to a protocol called ExpressibleByNilLiteral and great if you guessed it, only Optionals conform to ExpressibleByNilLiteral and conforming to other types is discouraged.\n\nExpressibleByNilLiteral has a single method called init(nilLiteral:) which initializes an instace with nil. You usually wont call this method and according to swift documentation it is discouraged to call this initializer directly as the compiler calls it whenever you initialize an Optional type with nil literal.\n\nEven myself has to wrap (no pun intended) my head around Optionals :D\nHappy Swfting All. \n    ","url":"/questions/[slug]#solution4","@type":"Answer","upvoteCount":0},{"text":"First, you should know what an Optional value is.\nYou can step to The Swift Programming Language for detail.\n\nSecond, you should know the optional value has two statuses. One is the full value, and the other is a nil value. So before you implement an optional value, you should check which state it is.\n\nYou can use if let ... or guard let ... else and so on.\n\nOne other way, if you don&apos;t want to check the variable state before your implementation, you can also use var buildingName = buildingName ?? &quot;buildingName&quot; instead.\n    ","url":"/questions/[slug]#solution5","@type":"Answer","upvoteCount":0},{"text":"I had this error once when I was trying to set my Outlets values from the prepare for segue method as follows:\n\noverride func prepare(for segue: UIStoryboardSegue, sender: Any?) {\n    if let destination = segue.destination as? DestinationVC{\n\n        if let item = sender as? DataItem{\n            // This line pops up the error\n            destination.nameLabel.text = item.name\n        }\n    }\n}\n\n\nThen I found out that I can&apos;t set the values of the destination controller outlets because the controller hasn&apos;t been loaded or initialized yet.\n\nSo I solved it this way:\n\noverride func prepare(for segue: UIStoryboardSegue, sender: Any?) {\n    if let destination = segue.destination as? DestinationVC{\n\n        if let item = sender as? DataItem{\n            // Created this method in the destination Controller to update its outlets after it&apos;s being initialized and loaded\n            destination.updateView(itemData:  item)\n        }\n    }\n}\n\n\nDestination Controller:\n\n// This variable to hold the data received to update the Label text after the VIEW DID LOAD\nvar name = &quot;&quot;\n\n// Outlets\n@IBOutlet weak var nameLabel: UILabel!\n\noverride func viewDidLoad() {\n    super.viewDidLoad()\n\n    // Do any additional setup after loading the view.\n    nameLabel.text = name\n}\n\nfunc updateView(itemDate: ObjectModel) {\n    name = itemDate.name\n}\n\n\nI hope this answer helps anyone out there with the same issue as I found the marked answer is great resource to the understanding of optionals and how they work but hasn&apos;t addressed the issue itself directly.\n    ","url":"/questions/[slug]#solution6","@type":"Answer","upvoteCount":0},{"text":"Basically you tried to use a nil value in places where Swift allows only non-nil ones, by telling the compiler to trust you that there will never be nil value there, thus allowing your app to compile.\n\nThere are several scenarios that lead to this kind of fatal error:\n\n\nforced unwraps:\n\nlet user = someVariable!\n\n\nIf someVariable is nil, then you&apos;ll get a crash. By doing a force unwrap you moved the nil check responsibility from the compiler to you, basically by doing a forced unwrap you&apos;re guaranteeing to the compiler that you&apos;ll never have nil values there. And guess what it happens if somehow a nil value ends in in someVariable?\n\nSolution? Use optional binding (aka if-let), do the variable processing there:\n\nif user = someVariable {\n    // do your stuff\n}\n\nforced (down)casts:\n\nlet myRectangle = someShape as! Rectangle\n\n\nHere by force casting you tell the compiler to no longer worry, as you&apos;ll always have a Rectangle instance there. And as long as that holds, you don&apos;t have to worry. The problems start when you or your colleagues from the project start circulating non-rectangle values.\n\nSolution? Use optional binding (aka if-let), do the variable processing there:\n\nif let myRectangle = someShape as? Rectangle {\n    // yay, I have a rectangle\n}\n\nImplicitly unwrapped optionals. Let&apos;s assume you have the following class definition:\n\nclass User {\n    var name: String!\n\n    init() {\n        name = &quot;(unnamed)&quot;\n    }\n\n    func nicerName() {\n        return &quot;Mr/Ms &quot; + name\n    }\n}\n\n\nNow, if no-one messes up with the name property by setting it to nil, then it works as expected, however if User is initialized from a JSON that lacks the name key, then you get the fatal error when trying to use the property.\n\nSolution? Don&apos;t use them :) Unless you&apos;re 102% sure that the property will always have a non-nil value by the time it needs to be used. In most cases converting to an optional or non-optional will work. Making it non-optional will also result in the compiler helping you by telling the code paths you missed giving a value to that property\nUnconnected, or not yet connected, outlets. This is a particular case of scenario #3. Basically you have some XIB-loaded class that you want to use.\n\nclass SignInViewController: UIViewController {\n\n    @IBOutlet var emailTextField: UITextField!\n}\n\n\nNow if you missed connecting the outlet from the XIB editor, then the app will crash as soon as you&apos;ll want to use the outlet.\nSolution? Make sure all outlets are connected. Or use the ? operator on them: emailTextField?.text = &quot;my@email.com&quot;. Or declare the outlet as optional, though in this case the compiler will force you to unwrap it all over the code.\nValues coming from Objective-C, and that don&apos;t have nullability annotations. Let&apos;s assume we have the following Objective-C class:\n\n@interface MyUser: NSObject\n@property NSString *name;\n@end\n\n\nNow if no nullability annotations are specified (either explicitly or via NS_ASSUME_NONNULL_BEGIN/NS_ASSUME_NONNULL_END), then the name property will be imported in Swift as String! (an IUO - implicitly unwrapped optional). As soon as some swift code will want to use the value, it will crash if name is nil.\n\nSolution? Add nullability annotations to your Objective-C code. Beware though, the Objective-C compiler is a little bit permissive when it comes to nullability, you might end up with nil values, even if you explicitly marked them as nonnull.\n\n    ","url":"/questions/[slug]#solution7","@type":"Answer","upvoteCount":0},{"text":"This is more of a important comment and that why implicitly unwrapped optionals can be deceptive when it comes to debugging nil values.\n\nThink of the following code: \nIt compiles with no errors/warnings:\n\nc1.address.city = c3.address.city\n\n\nYet at runtime it gives the following error: Fatal error: Unexpectedly found nil while unwrapping an Optional value\n\nCan you tell me which object is nil? \n\nYou can&apos;t!\n\nThe full code would be: \n\nclass ViewController: UIViewController {\n\n    override func viewDidLoad() {\n        super.viewDidLoad()\n\n        var c1 = NormalContact()\n        let c3 = BadContact()\n\n        c1.address.city = c3.address.city // compiler hides the truth from you and then you sudden get a crash\n    }\n}\n\nstruct NormalContact {\n    var address : Address = Address(city: &quot;defaultCity&quot;)\n}\n\nstruct BadContact {\n    var address : Address!\n}\n\nstruct Address {\n    var city : String\n}\n\n\nLong story short by using var address : Address! you&apos;re hiding the possibility that a variable can be nil from other readers. And when it crashes you&apos;re like &quot;what the hell?! my address isn&apos;t an optional, so why am I crashing?!. \n\nHence it&apos;s better to write as such: \n\nc1.address.city = c2.address!.city  // ERROR:  Fatal error: Unexpectedly found nil while unwrapping an Optional value \n\n\nCan you now tell me which object it is that was nil? \n\nThis time the code has been made more clear to you. You can rationalize and think that likely it&apos;s the address parameter that was forcefully unwrapped. \n\nThe full code would be :\n\nclass ViewController: UIViewController {\n\n    override func viewDidLoad() {\n        super.viewDidLoad()\n\n        var c1 = NormalContact()\n        let c2 = GoodContact()\n\n        c1.address.city = c2.address!.city\n        c1.address.city = c2.address?.city // not compile-able. No deceiving by the compiler\n        c1.address.city = c2.address.city // not compile-able. No deceiving by the compiler\n        if let city = c2.address?.city {  // safest approach. But that&apos;s not what I&apos;m talking about here. \n            c1.address.city = city\n        }\n\n    }\n}\n\nstruct NormalContact {\n    var address : Address = Address(city: &quot;defaultCity&quot;)\n}\n\nstruct GoodContact {\n    var address : Address?\n}\n\nstruct Address {\n    var city : String\n}\n\n    ","url":"/questions/[slug]#solution8","@type":"Answer","upvoteCount":0},{"text":"The errors EXC_BAD_INSTRUCTION and fatal error: unexpectedly found nil while implicitly unwrapping an Optional value appears the most when you have declared an @IBOutlet, but not connected to the storyboard.\n\nYou should also learn about how Optionals work, mentioned in other answers, but this is the only time that mostly appears to me.\n    ","url":"/questions/[slug]#solution9","@type":"Answer","upvoteCount":0},{"text":"If you get this error in CollectionView try to create CustomCell file and Custom xib also.\n\nadd this code in ViewDidLoad() at mainVC.\n\n    let nib = UINib(nibName: &quot;CustomnibName&quot;, bundle: nil)\n    self.collectionView.register(nib, forCellWithReuseIdentifier: &quot;cell&quot;)\n\n    ","url":"/questions/[slug]#solution10","@type":"Answer","upvoteCount":0},{"text":"Xcode 12 iOS 14 Swift 5\nMy problem was the type of navigation as I called the vie controller direct without instantiating the storyboard so that&apos;s mean data was not set yet from the storyboard.\nWhen you navigate, navigate with\nlet homeViewController = UIStoryboard(name: &quot;Main&quot;, bundle: nil).instantiateViewController(withIdentifier: &quot;home&quot;) as? HomeEventsViewController\n    homeViewController?.modalTransitionStyle = .crossDissolve\n    homeViewController?.modalPresentationStyle = .fullScreen\n    view.present(homeViewController ?? UIViewController(), animated: true, completion: nil)\n\nHopefully it works :-)\n    ","url":"/questions/[slug]#solution11","@type":"Answer","upvoteCount":0},{"text":"I came across this error while making a segue from a table view controller to a view controller because I had forgotten to specify the custom class name for the view controller in the main storyboard.\n\nSomething simple that is worth checking if all else looks ok\n    ","url":"/questions/[slug]#solution12","@type":"Answer","upvoteCount":0},{"text":"If my case I set a variable to UILabel which was nil.\nSo I fixed it and thereafter it did not throw the error.\nCode snippet\nclass ResultViewController: UIViewController {\n\n    @IBOutlet weak var resultLabel: UILabel!\n    var bmiValue=&quot;&quot;\n    override func viewDidLoad() {\n        super.viewDidLoad()\n        print(bmiValue)\n        resultLabel.text=bmiValue //where bmiValue was nil , I fixed it and problem was solved\n\n    }\n    \n    @IBAction func recaculateBmi(_ sender: UIButton) {\n        self.dismiss(animated: true, completion: nil)\n    }\n    \n\n}\n\n    ","url":"/questions/[slug]#solution13","@type":"Answer","upvoteCount":0},{"text":"in simple words\nyou are trying to use a value of the optional variable which is nil.\nquick fix could be use guard or if let instead of force unwrap like putting ! at the end of variable\n    ","url":"/questions/[slug]#solution14","@type":"Answer","upvoteCount":0},{"text":"This is because you are trying to use a value which can possible be nil, but you decided you don&apos;t want to have to check it, but instead assume its set when you uses it and define it as !, there are different philosophies on use of variable set as force unwrap, some people are against there use at all, I personal think they are ok for things that will crash all the time and are simple to reason about, usually references to resource, like outlets to xib files, or uses of images with you app that are part of your assets, if these are not set up properly, you app is going to crash straight away, for a very obvious reason, you can get into difficult when the order of objects being created can be uncertain, and trying to reason solutions to this can be difficult, it usually means a bad design as even it you make them optional, calls to you optional variable may not ever be executed, some projects can demand use of force unwraps for security reasons, things like banking apps, because they want the app to crash rather then continue to work in an unplanned way.\n    ","url":"/questions/[slug]#solution15","@type":"Answer","upvoteCount":0}],"@type":"Question"}}</script><meta name="next-head-count" content="16"/><link rel="preload" href="/_next/static/css/08bcc42a26fe5c92.css" as="style"/><link rel="stylesheet" href="/_next/static/css/08bcc42a26fe5c92.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-0d1b80a048d4787e.js"></script><script src="/_next/static/chunks/webpack-42cdea76c8170223.js" defer=""></script><script src="/_next/static/chunks/framework-4556c45dd113b893.js" defer=""></script><script src="/_next/static/chunks/main-ccfab947c79712f4.js" defer=""></script><script src="/_next/static/chunks/pages/_app-08d1a634dea6705e.js" defer=""></script><script src="/_next/static/chunks/29107295-fbcfe2172188e46f.js" defer=""></script><script src="/_next/static/chunks/150-b06815e21c943e0d.js" defer=""></script><script src="/_next/static/chunks/490-7f0418bb4354ac73.js" defer=""></script><script src="/_next/static/chunks/108-87de33c23337ff53.js" defer=""></script><script src="/_next/static/chunks/pages/questions/%5Bslug%5D-79a1437acf654019.js" defer=""></script><script src="/_next/static/6ctJfCympFH_chh5mjicD/_buildManifest.js" defer=""></script><script src="/_next/static/6ctJfCympFH_chh5mjicD/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="wrapper"><header><nav class="bg-white border-gray-200 px-4 lg:px-6 py-2.5 dark:bg-gray-800"><div class="flex flex-wrap justify-between items-center mx-auto max-w-screen-xl"><a class="flex items-center" href="/"><img src="/logo-second.png" class="mr-3 h-6 sm:h-9" alt="Solution Checker Logo"/><h4 class="self-center text-xl font-semibold whitespace-nowrap dark:text-white">Solution Checker</h4></a><div class="flex items-center lg:order-2"><button data-collapse-toggle="mobile-menu-2" type="button" class="inline-flex items-center p-2 ml-1 text-sm text-gray-500 rounded-lg lg:hidden hover:bg-gray-100 focus:outline-none focus:ring-2 focus:ring-gray-200 dark:text-gray-400 dark:hover:bg-gray-700 dark:focus:ring-gray-600" aria-controls="mobile-menu-2" aria-expanded="false"><span class="sr-only">Open main menu</span><svg class="w-6 h-6" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M3 5a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM3 10a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM3 15a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1z" clip-rule="evenodd"></path></svg><svg class="hidden w-6 h-6" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z" clip-rule="evenodd"></path></svg></button></div><div class="hidden justify-between items-center w-full lg:flex lg:w-auto lg:order-1" id="mobile-menu-2"><ul class="flex flex-col mt-4 font-medium lg:flex-row lg:space-x-8 lg:mt-0"><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" aria-current="page" href="/">Home</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/questions?tab=news">Questions</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/post?tab=news">Post</a></li><li><a class="block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 lg:hover:bg-transparent lg:border-0 lg:hover:text-blue-700 lg:p-0 dark:text-gray-400 lg:dark:hover:text-white dark:hover:bg-gray-700 dark:hover:text-white lg:dark:hover:bg-transparent dark:border-gray-700" href="/questions/what-does-%22fatal-error:-unexpectedly-found-nil-while-unwrapping-an-optional-value%22-mean-1657384593944#">Coding</a></li></ul></div></div></nav></header><div class="main-content"><div class="question my-5"><div class="flex question-header items-center m-auto justify-center"><div class="rounded-xl w-full border p-5 shadow-md bg-white"><div class="flex w-full items-center justify-between border-b pb-3"><div class="flex items-center space-x-3"><div class="text-lg font-bold text-slate-700"><a href="/questions/what-does-%22fatal-error:-unexpectedly-found-nil-while-unwrapping-an-optional-value%22-mean-1657384593944"><h1>What does &quot;Fatal error: Unexpectedly found nil while unwrapping an Optional value&quot; mean?</h1></a></div></div><div class="flex flex-wrap h-auto justify-end items-center space-x-8"></div></div><div class="question-content mt-5">
                
<p>My Swift program is crashing with <code>EXC_BAD_INSTRUCTION</code> and one of the following similar errors. What does this error mean, and how do I fix it?</p>

<blockquote>
  <p>Fatal error: Unexpectedly found nil while unwrapping an Optional value  </p>
</blockquote>

<p><em>or</em></p>

<blockquote>
  <p>Fatal error: Unexpectedly found nil while implicitly unwrapping an Optional value  </p>
</blockquote>

<hr>

<p><sup>This post is intended to collect answers to "unexpectedly found nil" issues, so that they are not scattered and hard to find. Feel free to add your own answer or <a href="https://stackoverflow.com/posts/32170457/edit">edit</a> the existing wiki answer.</sup></p>
    </div></div></div><div class="solution-section"><nav class="flex pagination-solution flex-col justify-end"><ul class="inline-flex -space-x-px overflow-auto"><li class="pagination-solution-item"><span data-id="#solution1" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">1</span></li><li class="pagination-solution-item"><span data-id="#solution2" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">2</span></li><li class="pagination-solution-item"><span data-id="#solution3" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">3</span></li><li class="pagination-solution-item"><span data-id="#solution4" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">4</span></li><li class="pagination-solution-item"><span data-id="#solution5" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">5</span></li><li class="pagination-solution-item"><span data-id="#solution6" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">6</span></li><li class="pagination-solution-item"><span data-id="#solution7" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">7</span></li><li class="pagination-solution-item"><span data-id="#solution8" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">8</span></li><li class="pagination-solution-item"><span data-id="#solution9" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">9</span></li><li class="pagination-solution-item"><span data-id="#solution10" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">10</span></li><li class="pagination-solution-item"><span data-id="#solution11" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">11</span></li><li class="pagination-solution-item"><span data-id="#solution12" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">12</span></li><li class="pagination-solution-item"><span data-id="#solution13" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">13</span></li><li class="pagination-solution-item"><span data-id="#solution14" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">14</span></li><li class="pagination-solution-item"><span data-id="#solution15" class="cursor-pointer py-2 px-3 leading-tight text-gray-500 bg-white border border-gray-300 hover:bg-gray-100 hover:text-gray-700 dark:bg-gray-800 dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white">15</span></li></ul></nav><div id="solution1" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 1</h4><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<h2>Background: Whats an Optional?</h2>
<p>In Swift, <a href="https://docs.swift.org/swift-book/LanguageGuide/TheBasics.html#ID330" rel="noreferrer"><code>Optional&lt;Wrapped&gt;</code></a> is an <a href="https://en.wikipedia.org/wiki/Option_type" rel="noreferrer">option type</a>: it can contain any value from the original ("Wrapped") type, or no value at all (the special value <code>nil</code>). An optional value must be <strong>unwrapped</strong> before it can be used.</p>
<p>Optional is a <a href="https://developer.apple.com/library/mac/documentation/Swift/Conceptual/Swift_Programming_Language/Generics.html" rel="noreferrer">generic type</a>, which means that <code>Optional&lt;Int&gt;</code> and <code>Optional&lt;String&gt;</code> are distinct types  the type inside <code>&lt;&gt;</code> is called the Wrapped type. Under the hood, an Optional is an <a href="https://docs.swift.org/swift-book/LanguageGuide/Enumerations.html" rel="noreferrer">enum</a> with two cases: <code>.some(Wrapped)</code> and <code>.none</code>, where <code>.none</code> is equivalent to <code>nil</code>.</p>
<p>Optionals can be declared using the named type <code>Optional&lt;T&gt;</code>, or (most commonly) as a shorthand with a <code>?</code> suffix.</p>
<pre class="lang-swift s-code-block"><code class="hljs language-swift"><span class="hljs-keyword">var</span> anInt: <span class="hljs-type">Int</span> <span class="hljs-operator">=</span> <span class="hljs-number">42</span>
<span class="hljs-keyword">var</span> anOptionalInt: <span class="hljs-type">Int</span>? <span class="hljs-operator">=</span> <span class="hljs-number">42</span>
<span class="hljs-keyword">var</span> anotherOptionalInt: <span class="hljs-type">Int</span>?  <span class="hljs-comment">// `nil` is the default when no value is provided</span>
<span class="hljs-keyword">var</span> aVerboseOptionalInt: <span class="hljs-type">Optional</span>&lt;<span class="hljs-type">Int</span>&gt;  <span class="hljs-comment">// equivalent to `Int?`</span>

anOptionalInt <span class="hljs-operator">=</span> <span class="hljs-literal">nil</span> <span class="hljs-comment">// now this variable contains nil instead of an integer</span>
</code></pre>
<p>Optionals are a simple yet powerful tool to express your assumptions while writing code. The compiler can use this information to prevent you from making mistakes. From <a href="https://docs.swift.org/swift-book/LanguageGuide/TheBasics.html" rel="noreferrer">The Swift Programming Language</a>:</p>
<blockquote>
<p>Swift is a <em>type-safe</em> language, which means the language helps you to be clear about the types of values your code can work with. If part of your code requires a <code>String</code>, type safety prevents you from passing it an <code>Int</code> by mistake. <strong>Likewise, type safety prevents you from accidentally passing an optional <code>String</code> to a piece of code that requires a non-optional <code>String</code>.</strong> Type safety helps you catch and fix errors as early as possible in the development process.</p>
</blockquote>
<p>Some other programming languages also have generic <a href="https://en.wikipedia.org/wiki/Option_type" rel="noreferrer">option types</a>: for example, <a href="https://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Maybe.html" rel="noreferrer">Maybe</a> in Haskell, <a href="https://doc.rust-lang.org/std/option/" rel="noreferrer">option</a> in Rust, and <a href="https://en.cppreference.com/w/cpp/utility/optional" rel="noreferrer">optional</a> in C++17.</p>
<p>In programming languages <em>without</em> option types, a particular <a href="https://en.wikipedia.org/wiki/Sentinel_value" rel="noreferrer">"sentinel" value</a> is often used to indicate the absence of a valid value. In Objective-C, for example, <code>nil</code> (the <a href="https://en.wikipedia.org/wiki/Null_pointer" rel="noreferrer">null pointer</a>) represents the lack of an object. For primitive types such as <code>int</code>, a null pointer can't be used, so you would need either a separate variable (such as <code>value: Int</code> and <code>isValid: Bool</code>) or a designated sentinel value (such as <code>-1</code> or <code>INT_MIN</code>). These approaches are error-prone because it's easy to forget to check <code>isValid</code> or to check for the sentinel value. Also, if a particular value is chosen as the sentinel, that means it can no longer be treated as a <em>valid</em> value.</p>
<p>Option types such as Swift's <code>Optional</code> solve these problems by introducing a special, separate <code>nil</code> value (so you don't have to designate a sentinel value), and by leveraging the strong type system so the compiler can help you remember to check for nil when necessary.</p>
<hr>
<h2>Why did I get <em>Fatal error: Unexpectedly found nil while unwrapping an Optional value</em>?</h2>
<p>In order to access an optionals value (if it has one at all), you need to <strong>unwrap</strong> it. An optional value can be unwrapped safely or forcibly. If you force-unwrap an optional, and it <em>didn't</em> have a value, your program will crash with the above message.</p>
<p>Xcode will show you the crash by highlighting a line of code. The problem occurs on this line.</p>
<p><a href="https://i.stack.imgur.com/dQelz.png" rel="noreferrer"><img src="https://i.stack.imgur.com/dQelz.png" alt="crashed line"></a></p>
<p>This crash can occur with two different kinds of force-unwrap:</p>
<h3>1. Explicit Force Unwrapping</h3>
<p>This is done with the <code>!</code> operator on an optional. For example:</p>
<pre class="lang-swift s-code-block"><code class="hljs language-swift"><span class="hljs-keyword">let</span> anOptionalString: <span class="hljs-type">String</span>?
<span class="hljs-built_in">print</span>(anOptionalString<span class="hljs-operator">!</span>) <span class="hljs-comment">// &lt;- CRASH</span>
</code></pre>
<blockquote>
<p>Fatal error: Unexpectedly found nil while unwrapping an Optional value</p>
</blockquote>
<p>As <code>anOptionalString</code> is <code>nil</code> here, you will get a crash on the line where you force unwrap it.</p>
<h3>2. Implicitly Unwrapped Optionals</h3>
<p>These are defined with  a <code>!</code>, rather than a <code>?</code> after the type.</p>
<pre class="lang-swift s-code-block"><code class="hljs language-swift"><span class="hljs-keyword">var</span> optionalDouble: <span class="hljs-type">Double</span>!   <span class="hljs-comment">// this value is implicitly unwrapped wherever it's used</span>
</code></pre>
<p>These optionals are assumed to contain a value. Therefore whenever you access an implicitly unwrapped optional, it will automatically be force unwrapped for you. If it doesnt contain a value, it will crash.</p>
<pre class="lang-swift s-code-block"><code class="hljs language-swift"><span class="hljs-built_in">print</span>(optionalDouble) <span class="hljs-comment">// &lt;- CRASH</span>
</code></pre>
<blockquote>
<p>Fatal error: Unexpectedly found nil while <strong>implicitly</strong> unwrapping an Optional value</p>
</blockquote>
<p>In order to work out which variable caused the crash, you can hold <kbd></kbd> while clicking to show the definition, where you might find the optional type.</p>
<img src="https://i.stack.imgur.com/zZmlK.gif" width="300">
<p>IBOutlets, in particular, are usually implicitly unwrapped optionals. This is because your xib or storyboard will link up the outlets at runtime, <em>after</em> initialization. You should therefore ensure that youre not accessing outlets before they're loaded in. You also should check that the connections are correct in your storyboard/xib file, otherwise the values will be <code>nil</code> at runtime, and therefore crash when they are implicitly unwrapped. When fixing connections, try deleting the lines of code that define your outlets, then reconnect them.</p>
<hr>
<h2>When should I ever force unwrap an Optional?</h2>
<h3>Explicit Force Unwrapping</h3>
<p>As a general rule, you should never explicitly force unwrap an optional with the <code>!</code> operator. There may be cases where using <code>!</code> is acceptable  but you should only ever be using it if you are 100% sure that the optional contains a value.</p>
<p>While there <em>may</em> be an occasion where you can use force unwrapping, as you know for a <em>fact</em> that an optional contains a value  there is not a <em>single</em> place where you cannot safely unwrap that optional instead.</p>
<p><b></b></p>
<h3>Implicitly Unwrapped Optionals</h3>
<p>These variables are designed so that you can defer their assignment until later in your code. It is <em>your</em> responsibility to ensure they have a value before you access them. However, because they involve force unwrapping, they are still inherently unsafe  as they <em>assume</em> your value is non-nil, even though assigning nil is valid.</p>
<p>You should only be using implicitly unwrapped optionals as a <em>last resort</em>. If you can use a <a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Properties.html#//apple_ref/doc/uid/TP40014097-CH14-ID255" rel="noreferrer">lazy variable</a>, or provide a <a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Initialization.html#//apple_ref/doc/uid/TP40014097-CH18-ID206" rel="noreferrer">default value</a> for a variable  you should do so instead of using an implicitly unwrapped optional.</p>
<p>However, there are a <a href="https://stackoverflow.com/a/24583157/2976878">few scenarios where implicitly unwrapped optionals are beneficial</a>, and you are still able to use various ways of safely unwrapping them as listed below  but you should <em>always</em> use them with due caution.</p>
<hr>
<h2>How can I safely deal with Optionals?</h2>
<p>The simplest way to check whether an optional contains a value, is to compare it to <code>nil</code>.</p>
<pre class="lang-swift s-code-block"><code class="hljs language-swift"><span class="hljs-keyword">if</span> anOptionalInt <span class="hljs-operator">!=</span> <span class="hljs-literal">nil</span> {
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"Contains a value!"</span>)
} <span class="hljs-keyword">else</span> {
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"Doesnt contain a value."</span>)
}
</code></pre>
<p>However, 99.9% of the time when working with optionals, youll actually want to access the value it contains, if it contains one at all. To do this, you can use <em>Optional Binding</em>.</p>
<h3>Optional Binding</h3>
<p>Optional Binding allows you to check if an optional contains a value  and allows you to assign the unwrapped value to a new variable or constant. It uses the syntax <code>if let x = anOptional {...}</code> or <code>if var x = anOptional {...}</code>, depending if you need to modify the value of the new variable after binding it.</p>
<p>For example:</p>
<pre class="lang-swift s-code-block"><code class="hljs language-swift"><span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> number <span class="hljs-operator">=</span> anOptionalInt {
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"Contains a value! It is <span class="hljs-subst">\(number)</span>!"</span>)
} <span class="hljs-keyword">else</span> {
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"Doesnt contain a number"</span>)
}
</code></pre>
<p>What this does is first check that the optional contains a value. If it <em>does</em>, then the unwrapped value is assigned to  a new variable (<code>number</code>)  which you can then freely use as if it were non-optional. If the optional <em>doesnt</em> contain a value, then the else clause will be invoked, as you would expect.</p>
<p>Whats neat about optional binding, is you can unwrap multiple optionals at the same time. You can just separate the statements with a comma. The statement will succeed if all the optionals were unwrapped.</p>
<pre class="lang-swift s-code-block"><code class="hljs language-swift"><span class="hljs-keyword">var</span> anOptionalInt : <span class="hljs-type">Int</span>?
<span class="hljs-keyword">var</span> anOptionalString : <span class="hljs-type">String</span>?

<span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> number <span class="hljs-operator">=</span> anOptionalInt, <span class="hljs-keyword">let</span> text <span class="hljs-operator">=</span> anOptionalString {
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"anOptionalInt contains a value: <span class="hljs-subst">\(number)</span>. And so does anOptionalString, its: <span class="hljs-subst">\(text)</span>"</span>)
} <span class="hljs-keyword">else</span> {
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"One or more of the optionals dont contain a value"</span>)
}
</code></pre>
<p>Another neat trick is that you can also use commas to check for a certain condition on the value, after unwrapping it.</p>
<pre class="lang-swift s-code-block"><code class="hljs language-swift"><span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> number <span class="hljs-operator">=</span> anOptionalInt, number <span class="hljs-operator">&gt;</span> <span class="hljs-number">0</span> {
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"anOptionalInt contains a value: <span class="hljs-subst">\(number)</span>, and its greater than zero!"</span>)
}
</code></pre>
<p>The only catch with using optional binding within an if statement, is that you can only access the unwrapped value from within the scope of the statement. If you need access to the value from outside of the scope of the statement, you can use a <em>guard statement</em>.</p>
<p>A <a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Statements.html#//apple_ref/swift/grammar/if-statement" rel="noreferrer">guard statement</a> allows you to define a condition for success  and the current scope will only continue executing if that condition is met. They are defined with the syntax <code>guard condition else {...}</code>.</p>
<p>So, to use them with an optional binding, you can do this:</p>
<pre class="lang-swift s-code-block"><code class="hljs language-swift"><span class="hljs-keyword">guard</span> <span class="hljs-keyword">let</span> number <span class="hljs-operator">=</span> anOptionalInt <span class="hljs-keyword">else</span> {
    <span class="hljs-keyword">return</span>
}
</code></pre>
<p><sup>(Note that within the guard body, you <strong>must</strong> use one of the <a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/ControlFlow.html#//apple_ref/doc/uid/TP40014097-CH9-ID135" rel="noreferrer">control transfer statements</a> in order to exit the scope of the currently executing code).</sup></p>
<p>If <code>anOptionalInt</code> contains a value, it will be unwrapped and assigned to the new <code>number</code> constant. The code <em>after</em> the guard will then continue executing. If it doesnt contain a value  the guard will execute the code within the brackets, which will lead to transfer of control, so that the code immediately after will not be executed.</p>
<p>The real neat thing about guard statements is the unwrapped value is now available to use in code that follows the statement (as we know that future code can <em>only</em> execute if the optional has a value). This is a great for eliminating <a href="https://en.wikipedia.org/wiki/Pyramid_of_doom_(programming)" rel="noreferrer">pyramids of doom</a> created by nesting multiple if statements.</p>
<p>For example:</p>
<pre class="lang-swift s-code-block"><code class="hljs language-swift"><span class="hljs-keyword">guard</span> <span class="hljs-keyword">let</span> number <span class="hljs-operator">=</span> anOptionalInt <span class="hljs-keyword">else</span> {
    <span class="hljs-keyword">return</span>
}

<span class="hljs-built_in">print</span>(<span class="hljs-string">"anOptionalInt contains a value, and its: <span class="hljs-subst">\(number)</span>!"</span>)
</code></pre>
<p>Guards also support the same neat tricks that the if statement supported, such as unwrapping multiple optionals at the same time and using the <code>where</code> clause.</p>
<p>Whether you use an if or guard statement completely depends on whether any future code <em>requires</em> the optional to contain a value.</p>
<h3>Nil Coalescing Operator</h3>
<p>The <a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/BasicOperators.html#//apple_ref/doc/uid/TP40014097-CH6-ID72" rel="noreferrer">Nil Coalescing Operator</a> is a nifty shorthand version of the <a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/BasicOperators.html#//apple_ref/doc/uid/TP40014097-CH6-ID71" rel="noreferrer">ternary conditional operator</a>, primarily designed to convert optionals to non-optionals. It has the syntax <code>a ?? b</code>, where <code>a</code> is an optional type and <code>b</code> is the same type as <code>a</code> (although usually non-optional).</p>
<p>It essentially lets you say If <code>a</code> contains a value, unwrap it. If it doesnt then return <code>b</code> instead. For example, you could use it like this:</p>
<pre class="lang-swift s-code-block"><code class="hljs language-swift"><span class="hljs-keyword">let</span> number <span class="hljs-operator">=</span> anOptionalInt <span class="hljs-operator">??</span> <span class="hljs-number">0</span>
</code></pre>
<p>This will define a <code>number</code> constant of <code>Int</code> type, that will either contain the value of <code>anOptionalInt</code>, if it contains a value, or <code>0</code> otherwise.</p>
<p>Its just shorthand for:</p>
<pre class="lang-swift s-code-block"><code class="hljs language-swift"><span class="hljs-keyword">let</span> number <span class="hljs-operator">=</span> anOptionalInt <span class="hljs-operator">!=</span> <span class="hljs-literal">nil</span> <span class="hljs-operator">?</span> anOptionalInt<span class="hljs-operator">!</span> : <span class="hljs-number">0</span>
</code></pre>
<h3>Optional Chaining</h3>
<p>You can use <a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/OptionalChaining.html#//apple_ref/doc/uid/TP40014097-CH21-ID245" rel="noreferrer">Optional Chaining</a> in order to call a method or access a property on an optional. This is simply done by suffixing the variable name with a <code>?</code> when using it.</p>
<p>For example, say we have a variable <code>foo</code>, of type an optional <code>Foo</code> instance.</p>
<pre class="lang-swift s-code-block"><code class="hljs language-swift"><span class="hljs-keyword">var</span> foo : <span class="hljs-type">Foo</span>?
</code></pre>
<p>If we wanted to call a method on <code>foo</code> that doesnt return anything, we can simply do:</p>
<pre class="lang-swift s-code-block"><code class="hljs language-swift">foo<span class="hljs-operator">?</span>.doSomethingInteresting()
</code></pre>
<p>If <code>foo</code> contains a value, this method will be called on it. If it doesnt, nothing bad will happen  the code will simply continue executing.</p>
<p><sup>(This is similar behaviour to sending messages to <code>nil</code> in Objective-C)</sup></p>
<p>This can therefore also be used to set properties as well as call methods. For example:</p>
<pre class="lang-swift s-code-block"><code class="hljs language-swift">foo<span class="hljs-operator">?</span>.bar <span class="hljs-operator">=</span> <span class="hljs-type">Bar</span>()
</code></pre>
<p>Again, nothing bad will happen here if <code>foo</code> is <code>nil</code>. Your code will simply continue executing.</p>
<p>Another neat trick that optional chaining lets you do is check whether setting a property or calling a method was successful. You can do this by comparing the return value to <code>nil</code>.</p>
<p><sup>(This is because an optional value will return <code>Void?</code> rather than <code>Void</code> on a method that doesnt return anything)</sup></p>
<p>For example:</p>
<pre class="lang-swift s-code-block"><code class="hljs language-swift"><span class="hljs-keyword">if</span> (foo<span class="hljs-operator">?</span>.bar <span class="hljs-operator">=</span> <span class="hljs-type">Bar</span>()) <span class="hljs-operator">!=</span> <span class="hljs-literal">nil</span> {
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"bar was set successfully"</span>)
} <span class="hljs-keyword">else</span> {
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"bar wasnt set successfully"</span>)
}
</code></pre>
<p>However, things become a little bit more tricky when trying to access properties or call methods that return a value. Because <code>foo</code> is optional, anything returned from it will also be optional. To deal with this, you can either unwrap the optionals that get returned using one of the above methods  or unwrap <code>foo</code> itself before accessing methods or calling methods that return values.</p>
<p>Also, as the name suggests, you can chain these statements together. This means that if <code>foo</code> has an optional property <code>baz</code>, which has a property <code>qux</code>  you could write the following:</p>
<pre class="lang-swift s-code-block"><code class="hljs language-swift"><span class="hljs-keyword">let</span> optionalQux <span class="hljs-operator">=</span> foo<span class="hljs-operator">?</span>.baz<span class="hljs-operator">?</span>.qux
</code></pre>
<p>Again, because <code>foo</code> and <code>baz</code> are optional, the value returned from <code>qux</code> will always be an optional regardless of whether <code>qux</code> itself is optional.</p>
<h3><code>map</code> and <code>flatMap</code></h3>
<p>An often underused feature with optionals is the ability to use the <code>map</code> and <code>flatMap</code> functions. These allow you to apply non-optional transforms to optional variables. If an optional has a value, you can apply a given transformation to it. If it doesnt have a value, it will remain <code>nil</code>.</p>
<p>For example, lets say you have an optional string:</p>
<pre class="lang-swift s-code-block"><code class="hljs language-swift"><span class="hljs-keyword">let</span> anOptionalString:<span class="hljs-type">String</span>?
</code></pre>
<p>By applying the <code>map</code> function to it  we can use the <code>stringByAppendingString</code> function in order to concatenate it to another string.</p>
<p>Because <code>stringByAppendingString</code> takes a non-optional string argument, we cannot input our optional string directly. However, by using <code>map</code>, we can use allow <code>stringByAppendingString</code> to be used if <code>anOptionalString</code> has a value.</p>
<p>For example:</p>
<pre class="lang-swift s-code-block"><code class="hljs language-swift"><span class="hljs-keyword">var</span> anOptionalString:<span class="hljs-type">String</span>? <span class="hljs-operator">=</span> <span class="hljs-string">"bar"</span>

anOptionalString <span class="hljs-operator">=</span> anOptionalString.map {unwrappedString <span class="hljs-keyword">in</span>
    <span class="hljs-keyword">return</span> <span class="hljs-string">"foo"</span>.stringByAppendingString(unwrappedString)
}

<span class="hljs-built_in">print</span>(anOptionalString) <span class="hljs-comment">// Optional("foobar")</span>
</code></pre>
<p>However, if <code>anOptionalString</code> doesnt have a value, <code>map</code> will return <code>nil</code>. For example:</p>
<pre class="lang-swift s-code-block"><code class="hljs language-swift"><span class="hljs-keyword">var</span> anOptionalString:<span class="hljs-type">String</span>?

anOptionalString <span class="hljs-operator">=</span> anOptionalString.map {unwrappedString <span class="hljs-keyword">in</span>
    <span class="hljs-keyword">return</span> <span class="hljs-string">"foo"</span>.stringByAppendingString(unwrappedString)
}

<span class="hljs-built_in">print</span>(anOptionalString) <span class="hljs-comment">// nil</span>
</code></pre>
<p><code>flatMap</code> works similarly to <code>map</code>, except it allows you to return <em>another</em> optional from within the closure body. This means you can input an optional into a process that requires a non-optional input, but can output an optional itself.</p>
<h2><code>try!</code></h2>
<p>Swift's error handling system can be safely used with <a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/ErrorHandling.html#//apple_ref/doc/uid/TP40014097-CH42-ID508" rel="noreferrer">Do-Try-Catch</a>:</p>
<pre class="lang-swift s-code-block"><code class="hljs language-swift"><span class="hljs-keyword">do</span> {
    <span class="hljs-keyword">let</span> result <span class="hljs-operator">=</span> <span class="hljs-keyword">try</span> someThrowingFunc() 
} <span class="hljs-keyword">catch</span> {
    <span class="hljs-built_in">print</span>(error)
}
</code></pre>
<p>If <code>someThrowingFunc()</code> throws an error, the error will be safely caught in the <code>catch</code> block.</p>
<p>The <code>error</code> constant you see in the <code>catch</code> block has not been declared by us - it's automatically generated by <code>catch</code>.</p>
<p>You can also declare <code>error</code> yourself, it has the advantage of being able to cast it to a useful format, for example:</p>
<pre class="lang-swift s-code-block"><code class="hljs language-swift"><span class="hljs-keyword">do</span> {
    <span class="hljs-keyword">let</span> result <span class="hljs-operator">=</span> <span class="hljs-keyword">try</span> someThrowingFunc()    
} <span class="hljs-keyword">catch</span> <span class="hljs-keyword">let</span> error <span class="hljs-keyword">as</span> <span class="hljs-type">NSError</span> {
    <span class="hljs-built_in">print</span>(error.debugDescription)
}
</code></pre>
<p>Using <code>try</code> this way is the proper way to try, catch and handle errors coming from throwing functions.</p>
<p>There's also <code>try?</code> which absorbs the error:</p>
<pre class="lang-swift s-code-block"><code class="hljs language-swift"><span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> result <span class="hljs-operator">=</span> <span class="hljs-keyword">try?</span> someThrowingFunc() {
    <span class="hljs-comment">// cool</span>
} <span class="hljs-keyword">else</span> {
    <span class="hljs-comment">// handle the failure, but there's no error information available</span>
}
</code></pre>
<p>But Swift's error handling system also provides a way to "force try" with <code>try!</code>:</p>
<pre class="lang-swift s-code-block"><code class="hljs language-swift"><span class="hljs-keyword">let</span> result <span class="hljs-operator">=</span> <span class="hljs-keyword">try!</span> someThrowingFunc()
</code></pre>
<p>The concepts explained in this post also apply here: if an error is thrown, the application will crash.</p>
<p><em>You should only ever use <code>try!</code> if you can prove that its result will never fail in your context - and this is very rare.</em></p>
<p>Most of the time you will use the complete Do-Try-Catch system - and the optional one, <code>try?</code>, in the rare cases where handling the error is not important.</p>
<hr>
<h2>Resources</h2>
<ul>
<li><a href="https://docs.swift.org/swift-book/LanguageGuide/TheBasics.html#ID330" rel="noreferrer">Apple documentation on Swift Optionals</a></li>
<li><a href="https://stackoverflow.com/a/24583157/2976878">When to use and when not to use implicitly unwrapped optionals</a></li>
<li><a href="http://www.raywenderlich.com/10209/my-app-crashed-now-what-part-1" rel="noreferrer">Learn how to debug an iOS app crash</a></li>
</ul>
    </div></div></div></div><div id="solution2" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 2</h4><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<h1>TL;DR answer</h1>
<p>With <a href="https://stackoverflow.com/a/24583157/1311272">very few exceptions</a>, this rule is golden:</p>
<h1>Avoid use of <code>!</code></h1>
<h3>Declare variable optional (<code>?</code>), not implicitly unwrapped optionals (IUO) (<code>!</code>)</h3>
<p>In other words, rather use:<br>
<code>var nameOfDaughter: String?</code></p>
<p>Instead of:<br>
<code>var nameOfDaughter: String!</code></p>
<h3>Unwrap optional variable using <code>if let</code> or <code>guard let</code></h3>
<p>Either unwrap variable like this:</p>
<pre class="lang-swift s-code-block"><code class="hljs language-swift"><span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> nameOfDaughter <span class="hljs-operator">=</span> nameOfDaughter {
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"My daughters name is: <span class="hljs-subst">\(nameOfDaughter)</span>"</span>)
}
</code></pre>
<p>Or like this:</p>
<pre class="lang-swift s-code-block"><code class="hljs language-swift"><span class="hljs-keyword">guard</span> <span class="hljs-keyword">let</span> nameOfDaughter <span class="hljs-operator">=</span> nameOfDaughter <span class="hljs-keyword">else</span> { <span class="hljs-keyword">return</span> }
<span class="hljs-built_in">print</span>(<span class="hljs-string">"My daughters name is: <span class="hljs-subst">\(nameOfDaughter)</span>"</span>)
</code></pre>
<p>This answer was intended to be concise, <a href="https://stackoverflow.com/a/32170457/1311272">for full comprehension read accepted answer</a></p>
<hr>
<h2>Resources</h2>
<ul>
<li><a href="https://blog.timac.org/2017/0628-swift-banning-force-unwrapping-optionals/" rel="nofollow noreferrer">Avoiding force unwrapping</a></li>
</ul>
    </div></div></div></div><div id="solution3" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 3</h4><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>This question comes up <strong>ALL THE TIME</strong> on SO. It's one of the first things that new Swift developers struggle with.</p>
<h2>Background:</h2>
<p>Swift uses the concept of "Optionals" to deal with values that could contain a value, or not. In other languages like C, you might store a value of 0 in a variable to indicate that it contains no value. However, what if 0 is a valid value? Then you might use -1. What if -1 is a valid value? And so on.</p>
<p>Swift optionals let you set up a variable of any type to contain either a valid value, or no value.</p>
<p>You put a question mark after the type when you declare a variable to mean (type x, or no value).</p>
<p>An optional is actually a container than contains either a variable of a given type, or nothing.</p>
<p>An optional needs to be "unwrapped" in order to fetch the value inside.</p>
<p>The "!" operator is a "force unwrap" operator. It says "trust me. I know what I am doing. I guarantee that when this code runs, the variable will not contain nil." If you are wrong, you crash.</p>
<p>Unless you really <strong>do</strong> know what you are doing, avoid the "!" force unwrap operator. It is probably the largest source of crashes for beginning Swift programmers.</p>
<h2>How to deal with optionals:</h2>
<p>There are lots of other ways of dealing with optionals that are safer. Here are some (not an exhaustive list)</p>
<p>You can use "optional binding" or "if let" to say "if this optional contains a value, save that value into a new, non-optional variable. If the optional does not contain a value, skip the body of this if statement".</p>
<p>Here is an example of optional binding with our <code>foo</code> optional:</p>
<pre class="lang-swift s-code-block"><code class="hljs language-swift"><span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> newFoo <span class="hljs-operator">=</span> foo <span class="hljs-comment">//If let is called optional binding. {</span>
  <span class="hljs-built_in">print</span>(<span class="hljs-string">"foo is not nil"</span>)
} <span class="hljs-keyword">else</span> {
  <span class="hljs-built_in">print</span>(<span class="hljs-string">"foo is nil"</span>)
}
</code></pre>
<p>Note that the variable you define when you use optional biding only exists (is only "in scope") in the body of the if statement.</p>
<p>Alternately, you could use a guard statement, which lets you exit your function if the variable is nil:</p>
<pre class="lang-swift s-code-block"><code class="hljs language-swift"><span class="hljs-keyword">func</span> <span class="hljs-title function_">aFunc</span>(<span class="hljs-params">foo</span>: <span class="hljs-type">Int</span>?) {
  <span class="hljs-keyword">guard</span> <span class="hljs-keyword">let</span> newFoo <span class="hljs-operator">=</span> input <span class="hljs-keyword">else</span> { <span class="hljs-keyword">return</span> }
  <span class="hljs-comment">//For the rest of the function newFoo is a non-optional var</span>
}
</code></pre>
<p>Guard statements were added in Swift 2. Guard lets you preserve the "golden path" through your code, and avoid ever-increasing levels of nested ifs that sometimes result from using "if let" optional binding.</p>
<p>There is also a construct called the "nil coalescing operator". It takes the form "optional_var ?? replacement_val". It returns a non-optional variable with the same type as the data contained in the optional. If the optional contains nil, it returns the value of the expression after the "??" symbol.</p>
<p>So you could use code like this:</p>
<pre class="lang-swift s-code-block"><code class="hljs language-swift"><span class="hljs-keyword">let</span> newFoo <span class="hljs-operator">=</span> foo <span class="hljs-operator">??</span> <span class="hljs-string">"nil"</span> <span class="hljs-comment">// "??" is the nil coalescing operator</span>
<span class="hljs-built_in">print</span>(<span class="hljs-string">"foo = <span class="hljs-subst">\(newFoo)</span>"</span>)
</code></pre>
<p>You could also use try/catch or guard error handling, but generally one of the other techniques above is cleaner.</p>
<h2>EDIT:</h2>
<p>Another, slightly more subtle gotcha with optionals is "implicitly unwrapped optionals. When we declare foo, we could say:</p>
<pre class="lang-swift s-code-block"><code class="hljs language-swift"><span class="hljs-keyword">var</span> foo: <span class="hljs-type">String</span>!
</code></pre>
<p>In that case foo is still an optional, but you don't have to unwrap it to reference it.  That means any time you try to reference foo, you crash if it's nil.</p>
<p>So this code:</p>
<pre class="lang-swift s-code-block"><code class="hljs language-swift"><span class="hljs-keyword">var</span> foo: <span class="hljs-type">String</span>!


<span class="hljs-keyword">let</span> upperFoo <span class="hljs-operator">=</span> foo.capitalizedString
</code></pre>
<p>Will crash on reference to foo's capitalizedString property even though we're not force-unwrapping foo. the print looks fine, but it's not.</p>
<p>Thus you want to be really careful with implicitly unwrapped optionals.  (and perhaps even avoid them completely until you have a solid understanding of optionals.)</p>
<p>Bottom line: When you are first learning Swift, pretend the "!" character is not part of the language. It's likely to get you into trouble.</p>
    </div></div></div></div><div id="solution4" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 4</h4><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Since the above answers clearly explains how to play safely with Optionals.
I will try explain what Optionals are really in swift.</p>

<p>Another way to declare an optional variable is </p>

<p><code>var i : Optional&lt;Int&gt;</code></p>

<p>And Optional type is nothing but an enumeration with two cases, i.e </p>

<pre class="lang-swift s-code-block"><code class="hljs language-swift"> <span class="hljs-keyword">enum</span> <span class="hljs-title class_">Optional</span>&lt;<span class="hljs-title class_">Wrapped</span>&gt; : <span class="hljs-title class_">ExpressibleByNilLiteral</span> {
    <span class="hljs-keyword">case</span> none 
    <span class="hljs-keyword">case</span> <span class="hljs-keyword">some</span>(<span class="hljs-type">Wrapped</span>)
    .
    .
    .
}
</code></pre>

<p>So to assign a nil to our variable 'i'. We can do 
<code>var i = Optional&lt;Int&gt;.none</code>
or to assign a value, we will pass some value 
<code>var i = Optional&lt;Int&gt;.some(28)</code> </p>

<p>According to swift, 'nil' is the absence of value.
And to create an instance initialized with <code>nil</code> We have to conform to a protocol called <code>ExpressibleByNilLiteral</code> and great if you guessed it, only <code>Optionals</code> conform to <code>ExpressibleByNilLiteral</code> and conforming to other types is discouraged.</p>

<p><code>ExpressibleByNilLiteral</code> has a single method called <code>init(nilLiteral:)</code> which initializes an instace with nil. You usually wont call this method and according to swift documentation it is discouraged to call this initializer directly as the compiler calls it whenever you initialize an Optional type with <code>nil</code> literal.</p>

<p>Even myself has to wrap (no pun intended) my head around Optionals :D
<em>Happy Swfting All</em>. </p>
    </div></div></div></div><div id="solution5" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 5</h4><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>First, you should know what an Optional value is.
You can step to <a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/OptionalChaining.html" rel="nofollow noreferrer">The Swift Programming Language</a> for detail.</p>

<p>Second, you should know the optional value has two statuses. One is the full value, and the other is a nil value. So before you implement an optional value, you should check which state it is.</p>

<p>You can use <code>if let ...</code> or <code>guard let ... else</code> and so on.</p>

<p>One other way, if you don't want to check the variable state before your implementation, you can also use <code>var buildingName = buildingName ?? "buildingName"</code> instead.</p>
    </div></div></div></div><div id="solution6" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 6</h4><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>I had this error once when I was trying to set my Outlets values from the prepare for segue method as follows:</p>

<pre class="lang-swift s-code-block"><code class="hljs language-swift"><span class="hljs-keyword">override</span> <span class="hljs-keyword">func</span> <span class="hljs-title function_">prepare</span>(<span class="hljs-params">for</span> <span class="hljs-params">segue</span>: <span class="hljs-type">UIStoryboardSegue</span>, <span class="hljs-params">sender</span>: <span class="hljs-keyword">Any</span><span class="hljs-operator">?</span>) {
    <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> destination <span class="hljs-operator">=</span> segue.destination <span class="hljs-keyword">as?</span> <span class="hljs-type">DestinationVC</span>{

        <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> item <span class="hljs-operator">=</span> sender <span class="hljs-keyword">as?</span> <span class="hljs-type">DataItem</span>{
            <span class="hljs-comment">// This line pops up the error</span>
            destination.nameLabel.text <span class="hljs-operator">=</span> item.name
        }
    }
}
</code></pre>

<p>Then I found out that I can't set the values of the destination controller outlets because the controller hasn't been loaded or initialized yet.</p>

<p>So I solved it this way:</p>

<pre class="lang-swift s-code-block"><code class="hljs language-swift"><span class="hljs-keyword">override</span> <span class="hljs-keyword">func</span> <span class="hljs-title function_">prepare</span>(<span class="hljs-params">for</span> <span class="hljs-params">segue</span>: <span class="hljs-type">UIStoryboardSegue</span>, <span class="hljs-params">sender</span>: <span class="hljs-keyword">Any</span><span class="hljs-operator">?</span>) {
    <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> destination <span class="hljs-operator">=</span> segue.destination <span class="hljs-keyword">as?</span> <span class="hljs-type">DestinationVC</span>{

        <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> item <span class="hljs-operator">=</span> sender <span class="hljs-keyword">as?</span> <span class="hljs-type">DataItem</span>{
            <span class="hljs-comment">// Created this method in the destination Controller to update its outlets after it's being initialized and loaded</span>
            destination.updateView(itemData:  item)
        }
    }
}
</code></pre>

<p>Destination Controller:</p>

<pre class="lang-swift s-code-block"><code class="hljs language-swift"><span class="hljs-comment">// This variable to hold the data received to update the Label text after the VIEW DID LOAD</span>
<span class="hljs-keyword">var</span> name <span class="hljs-operator">=</span> <span class="hljs-string">""</span>

<span class="hljs-comment">// Outlets</span>
<span class="hljs-keyword">@IBOutlet</span> <span class="hljs-keyword">weak</span> <span class="hljs-keyword">var</span> nameLabel: <span class="hljs-type">UILabel</span>!

<span class="hljs-keyword">override</span> <span class="hljs-keyword">func</span> <span class="hljs-title function_">viewDidLoad</span>() {
    <span class="hljs-keyword">super</span>.viewDidLoad()

    <span class="hljs-comment">// Do any additional setup after loading the view.</span>
    nameLabel.text <span class="hljs-operator">=</span> name
}

<span class="hljs-keyword">func</span> <span class="hljs-title function_">updateView</span>(<span class="hljs-params">itemDate</span>: <span class="hljs-type">ObjectModel</span>) {
    name <span class="hljs-operator">=</span> itemDate.name
}
</code></pre>

<p>I hope this answer helps anyone out there with the same issue as I found the marked answer is great resource to the understanding of optionals and how they work but hasn't addressed the issue itself directly.</p>
    </div></div></div></div><div id="solution7" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 7</h4><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Basically you tried to use a nil value in places where Swift allows only non-nil ones, by telling the compiler to trust you that there will never be nil value there, thus allowing your app to compile.</p>

<p>There are several scenarios that lead to this kind of fatal error:</p>

<ol>
<li><p>forced unwraps:</p>

<pre class="lang-swift s-code-block"><code class="hljs language-swift"><span class="hljs-keyword">let</span> user <span class="hljs-operator">=</span> someVariable<span class="hljs-operator">!</span>
</code></pre>

<p>If <code>someVariable</code> is nil, then you'll get a crash. By doing a force unwrap you moved the nil check responsibility from the compiler to you, basically by doing a forced unwrap you're guaranteeing to the compiler that you'll never have nil values there. And guess what it happens if somehow a nil value ends in in <code>someVariable</code>?</p>

<p>Solution? Use optional binding (aka if-let), do the variable processing there:</p>

<pre class="lang-swift s-code-block"><code class="hljs language-swift"><span class="hljs-keyword">if</span> user <span class="hljs-operator">=</span> someVariable {
    <span class="hljs-comment">// do your stuff</span>
}
</code></pre></li>
<li><p>forced (down)casts:</p>

<pre class="lang-swift s-code-block"><code class="hljs language-swift"><span class="hljs-keyword">let</span> myRectangle <span class="hljs-operator">=</span> someShape <span class="hljs-keyword">as!</span> <span class="hljs-type">Rectangle</span>
</code></pre>

<p>Here by force casting you tell the compiler to no longer worry, as you'll always have a <code>Rectangle</code> instance there. And as long as that holds, you don't have to worry. The problems start when you or your colleagues from the project start circulating non-rectangle values.</p>

<p>Solution? Use optional binding (aka if-let), do the variable processing there:</p>

<pre class="lang-swift s-code-block"><code class="hljs language-swift"><span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> myRectangle <span class="hljs-operator">=</span> someShape <span class="hljs-keyword">as?</span> <span class="hljs-type">Rectangle</span> {
    <span class="hljs-comment">// yay, I have a rectangle</span>
}
</code></pre></li>
<li><p>Implicitly unwrapped optionals. Let's assume you have the following class definition:</p>

<pre class="lang-swift s-code-block"><code class="hljs language-swift"><span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> {
    <span class="hljs-keyword">var</span> name: <span class="hljs-type">String</span>!

    <span class="hljs-keyword">init</span>() {
        name <span class="hljs-operator">=</span> <span class="hljs-string">"(unnamed)"</span>
    }

    <span class="hljs-keyword">func</span> <span class="hljs-title function_">nicerName</span>() {
        <span class="hljs-keyword">return</span> <span class="hljs-string">"Mr/Ms "</span> <span class="hljs-operator">+</span> name
    }
}
</code></pre>

<p>Now, if no-one messes up with the <code>name</code> property by setting it to <code>nil</code>, then it works as expected, however if <code>User</code> is initialized from a JSON that lacks the <code>name</code> key, then you get the fatal error when trying to use the property.</p>

<p>Solution? Don't use them :) Unless you're 102% sure that the property will always have a non-nil value by the time it needs to be used. In most cases converting to an optional or non-optional will work. Making it non-optional will also result in the compiler helping you by telling the code paths you missed giving a value to that property</p></li>
<li><p>Unconnected, or not yet connected, outlets. This is a particular case of scenario #3. Basically you have some XIB-loaded class that you want to use.</p>

<pre class="lang-swift s-code-block"><code class="hljs language-swift"><span class="hljs-keyword">class</span> <span class="hljs-title class_">SignInViewController</span>: <span class="hljs-title class_">UIViewController</span> {

    <span class="hljs-keyword">@IBOutlet</span> <span class="hljs-keyword">var</span> emailTextField: <span class="hljs-type">UITextField</span>!
}
</code></pre>

<p>Now if you missed connecting the outlet from the XIB editor, then the app will crash as soon as you'll want to use the outlet.
Solution? Make sure all outlets are connected. Or use the <code>?</code> operator on them: <code>emailTextField?.text = "my@email.com"</code>. Or declare the outlet as optional, though in this case the compiler will force you to unwrap it all over the code.</p></li>
<li><p>Values coming from Objective-C, and that don't have nullability annotations. Let's assume we have the following Objective-C class:</p>

<pre class="lang-swift s-code-block"><code class="hljs language-swift"><span class="hljs-meta">@interface</span> <span class="hljs-type">MyUser</span>: <span class="hljs-type">NSObject</span>
<span class="hljs-meta">@property</span> <span class="hljs-type">NSString</span> <span class="hljs-operator">*</span>name;
<span class="hljs-meta">@end</span>
</code></pre>

<p>Now if no nullability annotations are specified (either explicitly or via <code>NS_ASSUME_NONNULL_BEGIN</code>/<code>NS_ASSUME_NONNULL_END</code>), then the <code>name</code> property will be imported in Swift as <code>String!</code> (an IUO - implicitly unwrapped optional). As soon as some swift code will want to use the value, it will crash if <code>name</code> is nil.</p>

<p>Solution? Add nullability annotations to your Objective-C code. Beware though, the Objective-C compiler is a little bit permissive when it comes to nullability, you might end up with nil values, even if you explicitly marked them as <code>nonnull</code>.</p></li>
</ol>
    </div></div></div></div><div id="solution8" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 8</h4><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>This is more of a important comment and that why implicitly unwrapped optionals can be deceptive when it comes to debugging <code>nil</code> values.</p>

<p>Think of the following code: 
It compiles with no errors/warnings:</p>

<pre class="lang-swift s-code-block"><code class="hljs language-swift">c1.address.city <span class="hljs-operator">=</span> c3.address.city
</code></pre>

<p>Yet at runtime it gives the following error: <em>Fatal error: Unexpectedly found nil while unwrapping an Optional value</em></p>

<p><strong>Can you tell me which object is <code>nil</code>?</strong> </p>

<p>You can't!</p>

<p>The full code would be: </p>

<pre class="lang-swift s-code-block"><code class="hljs language-swift"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ViewController</span>: <span class="hljs-title class_">UIViewController</span> {

    <span class="hljs-keyword">override</span> <span class="hljs-keyword">func</span> <span class="hljs-title function_">viewDidLoad</span>() {
        <span class="hljs-keyword">super</span>.viewDidLoad()

        <span class="hljs-keyword">var</span> c1 <span class="hljs-operator">=</span> <span class="hljs-type">NormalContact</span>()
        <span class="hljs-keyword">let</span> c3 <span class="hljs-operator">=</span> <span class="hljs-type">BadContact</span>()

        c1.address.city <span class="hljs-operator">=</span> c3.address.city <span class="hljs-comment">// compiler hides the truth from you and then you sudden get a crash</span>
    }
}

<span class="hljs-keyword">struct</span> <span class="hljs-title class_">NormalContact</span> {
    <span class="hljs-keyword">var</span> address : <span class="hljs-type">Address</span> <span class="hljs-operator">=</span> <span class="hljs-type">Address</span>(city: <span class="hljs-string">"defaultCity"</span>)
}

<span class="hljs-keyword">struct</span> <span class="hljs-title class_">BadContact</span> {
    <span class="hljs-keyword">var</span> address : <span class="hljs-type">Address</span>!
}

<span class="hljs-keyword">struct</span> <span class="hljs-title class_">Address</span> {
    <span class="hljs-keyword">var</span> city : <span class="hljs-type">String</span>
}
</code></pre>

<p>Long story short by using <code>var address : Address!</code> you're <strong>hiding</strong> the possibility that a variable can be <code>nil</code> from other readers. And when it crashes you're like "what the hell?! my <code>address</code> isn't an optional, so why am I crashing?!. </p>

<p>Hence it's better to write as such: </p>

<pre class="lang-swift s-code-block"><code class="hljs language-swift">c1.address.city <span class="hljs-operator">=</span> c2.address<span class="hljs-operator">!</span>.city  <span class="hljs-comment">// ERROR:  Fatal error: Unexpectedly found nil while unwrapping an Optional value </span>
</code></pre>

<p><strong>Can you now tell me which object it is that was <code>nil</code>?</strong> </p>

<p>This time the code has been made more clear to you. You can rationalize and think that likely it's the <code>address</code> parameter that was forcefully unwrapped. </p>

<p>The full code would be :</p>

<pre class="lang-swift s-code-block"><code class="hljs language-swift"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ViewController</span>: <span class="hljs-title class_">UIViewController</span> {

    <span class="hljs-keyword">override</span> <span class="hljs-keyword">func</span> <span class="hljs-title function_">viewDidLoad</span>() {
        <span class="hljs-keyword">super</span>.viewDidLoad()

        <span class="hljs-keyword">var</span> c1 <span class="hljs-operator">=</span> <span class="hljs-type">NormalContact</span>()
        <span class="hljs-keyword">let</span> c2 <span class="hljs-operator">=</span> <span class="hljs-type">GoodContact</span>()

        c1.address.city <span class="hljs-operator">=</span> c2.address<span class="hljs-operator">!</span>.city
        c1.address.city <span class="hljs-operator">=</span> c2.address<span class="hljs-operator">?</span>.city <span class="hljs-comment">// not compile-able. No deceiving by the compiler</span>
        c1.address.city <span class="hljs-operator">=</span> c2.address.city <span class="hljs-comment">// not compile-able. No deceiving by the compiler</span>
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> city <span class="hljs-operator">=</span> c2.address<span class="hljs-operator">?</span>.city {  <span class="hljs-comment">// safest approach. But that's not what I'm talking about here. </span>
            c1.address.city <span class="hljs-operator">=</span> city
        }

    }
}

<span class="hljs-keyword">struct</span> <span class="hljs-title class_">NormalContact</span> {
    <span class="hljs-keyword">var</span> address : <span class="hljs-type">Address</span> <span class="hljs-operator">=</span> <span class="hljs-type">Address</span>(city: <span class="hljs-string">"defaultCity"</span>)
}

<span class="hljs-keyword">struct</span> <span class="hljs-title class_">GoodContact</span> {
    <span class="hljs-keyword">var</span> address : <span class="hljs-type">Address</span>?
}

<span class="hljs-keyword">struct</span> <span class="hljs-title class_">Address</span> {
    <span class="hljs-keyword">var</span> city : <span class="hljs-type">String</span>
}
</code></pre>
    </div></div></div></div><div id="solution9" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 9</h4><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>The errors <code>EXC_BAD_INSTRUCTION</code> and <code>fatal error: unexpectedly found nil while implicitly unwrapping an Optional value</code> appears the most when you have declared an <code>@IBOutlet</code>, but not connected to the <strong>storyboard</strong>.</p>

<p>You should also learn about how <strong>Optionals</strong> work, mentioned in other answers, but this is the only time that mostly appears to me.</p>
    </div></div></div></div><div id="solution10" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 10</h4><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>If you get this error in CollectionView try to create CustomCell file and Custom xib also.</p>

<p>add this code in ViewDidLoad() at mainVC.</p>

<pre class="lang-swift s-code-block"><code class="hljs language-swift">    <span class="hljs-keyword">let</span> nib <span class="hljs-operator">=</span> <span class="hljs-type">UINib</span>(nibName: <span class="hljs-string">"CustomnibName"</span>, bundle: <span class="hljs-literal">nil</span>)
    <span class="hljs-keyword">self</span>.collectionView.register(nib, forCellWithReuseIdentifier: <span class="hljs-string">"cell"</span>)
</code></pre>
    </div></div></div></div><div id="solution11" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 11</h4><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>Xcode 12 iOS 14 Swift 5</p>
<p>My problem was the type of navigation as I called the vie controller direct without instantiating the storyboard so that's mean data was not set yet from the storyboard.</p>
<p>When you navigate, navigate with</p>
<pre class="lang-swift s-code-block"><code class="hljs language-swift"><span class="hljs-keyword">let</span> homeViewController <span class="hljs-operator">=</span> <span class="hljs-type">UIStoryboard</span>(name: <span class="hljs-string">"Main"</span>, bundle: <span class="hljs-literal">nil</span>).instantiateViewController(withIdentifier: <span class="hljs-string">"home"</span>) <span class="hljs-keyword">as?</span> <span class="hljs-type">HomeEventsViewController</span>
    homeViewController<span class="hljs-operator">?</span>.modalTransitionStyle <span class="hljs-operator">=</span> .crossDissolve
    homeViewController<span class="hljs-operator">?</span>.modalPresentationStyle <span class="hljs-operator">=</span> .fullScreen
    view.present(homeViewController <span class="hljs-operator">??</span> <span class="hljs-type">UIViewController</span>(), animated: <span class="hljs-literal">true</span>, completion: <span class="hljs-literal">nil</span>)
</code></pre>
<p>Hopefully it works :-)</p>
    </div></div></div></div><div id="solution12" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 12</h4><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>I came across this error while making a segue from a table view controller to a view controller because I had forgotten to specify the custom class name for the view controller in the main storyboard.</p>

<p>Something simple that is worth checking if all else looks ok</p>
    </div></div></div></div><div id="solution13" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 13</h4><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>If my case I set a variable to UILabel which was nil.</p>
<p>So I fixed it and thereafter it did not throw the error.</p>
<p>Code snippet</p>
<pre class="lang-swift s-code-block"><code class="hljs language-swift"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ResultViewController</span>: <span class="hljs-title class_">UIViewController</span> {

    <span class="hljs-keyword">@IBOutlet</span> <span class="hljs-keyword">weak</span> <span class="hljs-keyword">var</span> resultLabel: <span class="hljs-type">UILabel</span>!
    <span class="hljs-keyword">var</span> bmiValue<span class="hljs-operator">=</span><span class="hljs-string">""</span>
    <span class="hljs-keyword">override</span> <span class="hljs-keyword">func</span> <span class="hljs-title function_">viewDidLoad</span>() {
        <span class="hljs-keyword">super</span>.viewDidLoad()
        <span class="hljs-built_in">print</span>(bmiValue)
        resultLabel.text<span class="hljs-operator">=</span>bmiValue <span class="hljs-comment">//where bmiValue was nil , I fixed it and problem was solved</span>

    }
    
    <span class="hljs-keyword">@IBAction</span> <span class="hljs-keyword">func</span> <span class="hljs-title function_">recaculateBmi</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">sender</span>: <span class="hljs-type">UIButton</span>) {
        <span class="hljs-keyword">self</span>.dismiss(animated: <span class="hljs-literal">true</span>, completion: <span class="hljs-literal">nil</span>)
    }
    

}
</code></pre>
    </div></div></div></div><div id="solution14" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 14</h4><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>in simple words
you are trying to use a value of the optional variable which is nil.
quick fix could be use <code>guard</code> or <code>if let</code> instead of force unwrap like putting <code>!</code> at the end of variable</p>
    </div></div></div></div><div id="solution15" class="flex mt-5 answer items-center justify-center py-5"><div class="rounded-xl solution-inner border md:px-10 md:py-10 px-2 py-10 shadow-md bg-white"><div style="display:flex;justify-content:space-between"><h4 class="text-4xl font-semibold mb-5">Solution 15</h4><div class="tags-wrap h-max space-x-8"><div class="tags"></div></div></div><div class=" items-center justify-between"><div class=" space-x-4 md:space-x-8">
<p>This is because you are trying to use a value which can possible be nil, but you decided you don't want to have to check it, but instead assume its set when you uses it and define it as !, there are different philosophies on use of variable set as force unwrap, some people are against there use at all, I personal think they are ok for things that will crash all the time and are simple to reason about, usually references to resource, like outlets to xib files, or uses of images with you app that are part of your assets, if these are not set up properly, you app is going to crash straight away, for a very obvious reason, you can get into difficult when the order of objects being created can be uncertain, and trying to reason solutions to this can be difficult, it usually means a bad design as even it you make them optional, calls to you optional variable may not ever be executed, some projects can demand use of force unwraps for security reasons, things like banking apps, because they want the app to crash rather then continue to work in an unplanned way.</p>
    </div></div></div></div></div></div><div class="widget"><a href="/questions/most-efficient-method-to-groupby-on-an-array-of-objects-1657387580538">Most efficient method to groupby on an array of objects</a><a href="/questions/reference-what-does-this-regex-mean-1657384291445">Reference - What does this regex mean?</a><a href="/questions/why-does-my-javascript-code-receive-a-%22no-&#x27;access-control-allow-origin&#x27;-header-is-present-on-the-requested-resource%22-error-while-postman-does-not-1657384636363">Why does my JavaScript code receive a &quot;No &#x27;Access-Control-Allow-Origin&#x27; header is present on the requested resource&quot; error, while Postman does not?</a><a href="/questions/convert-one-date-format-into-another-in-php-1657384566234">Convert one date format into another in PHP</a><a href="/questions/using-limit-within-group-by-to-get-n-results-per-group-1657388324167">Using LIMIT within GROUP BY to get N results per group?</a><a href="/questions/scanf()-leaves-the-newline-character-in-the-buffer-1657384699202">scanf() leaves the newline character in the buffer</a><a href="/questions/what-special-characters-must-be-escaped-in-regular-expressions-1657387465381">What special characters must be escaped in regular expressions?</a><a href="/questions/example-images-for-code-and-mark-up-qandas-closed-1657387690222">Example images for code and mark-up Q&amp;As [closed]</a><a href="/questions/how-can-i-vertically-align-elements-in-a-div-1657385504431">How can I vertically align elements in a div?</a><a href="/questions/split-array-into-chunks-1657387896420">Split array into chunks</a><a href="/questions/.prop()-vs-.attr()-1657384898328">.prop() vs .attr()</a><a href="/questions/what-is-the-purpose-of-the-var-keyword-and-when-should-i-use-it-(or-omit-it)-1657387525538">What is the purpose of the var keyword and when should I use it (or omit it)?</a><a href="/questions/iterating-over-dictionaries-using-&#x27;for&#x27;-loops-1657388334481">Iterating over dictionaries using &#x27;for&#x27; loops</a><a href="/questions/how-do-i-use-shell-variables-in-an-awk-script-1657387754261">How do I use shell variables in an awk script?</a><a href="/questions/what&#x27;s-the-meaning-of-%22greater%22-(an-arrow-formed-from-equals-and-greater-than)-in-javascript-1657387977118">What&#x27;s the meaning of &quot;=&gt;&quot; (an arrow formed from equals &amp; greater than) in JavaScript?</a><a href="/questions/why-does-my-function-that-calls-an-api-or-launches-a-coroutine-return-an-empty-or-null-value-1657388483820">Why does my function that calls an API or launches a coroutine return an empty or null value?</a><a href="/questions/get-selected-value-in-dropdown-list-using-javascript-1657387631638">Get selected value in dropdown list using JavaScript</a><a href="/questions/why-does-%22a-x-or-y-or-z%22-always-evaluate-to-true-1657384855216">Why does &quot;a == x or y or z&quot; always evaluate to True?</a><a href="/questions/providing-white-space-in-a-swing-gui-1657384734588">Providing white space in a Swing GUI</a><a href="/questions/how-can-i-get-useful-error-messages-in-php-1657384609065">How can I get useful error messages in PHP?</a></div></div><span class="cursor-pointer text-lg p-2" style="position:fixed;bottom:20px;left:20px;background:#000;z-index:2000;color:white">Go go top</span></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"data":{"answer":["\n\u0026lt;h2\u0026gt;Background: Whats an Optional?\u0026lt;/h2\u0026gt;\n\u0026lt;p\u0026gt;In Swift, \u0026lt;a href=\u0026quot;https://docs.swift.org/swift-book/LanguageGuide/TheBasics.html#ID330\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;\u0026lt;code\u0026gt;Optional\u0026amp;lt;Wrapped\u0026amp;gt;\u0026lt;/code\u0026gt;\u0026lt;/a\u0026gt; is an \u0026lt;a href=\u0026quot;https://en.wikipedia.org/wiki/Option_type\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;option type\u0026lt;/a\u0026gt;: it can contain any value from the original (\u0026quot;Wrapped\u0026quot;) type, or no value at all (the special value \u0026lt;code\u0026gt;nil\u0026lt;/code\u0026gt;). An optional value must be \u0026lt;strong\u0026gt;unwrapped\u0026lt;/strong\u0026gt; before it can be used.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Optional is a \u0026lt;a href=\u0026quot;https://developer.apple.com/library/mac/documentation/Swift/Conceptual/Swift_Programming_Language/Generics.html\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;generic type\u0026lt;/a\u0026gt;, which means that \u0026lt;code\u0026gt;Optional\u0026amp;lt;Int\u0026amp;gt;\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;Optional\u0026amp;lt;String\u0026amp;gt;\u0026lt;/code\u0026gt; are distinct types  the type inside \u0026lt;code\u0026gt;\u0026amp;lt;\u0026amp;gt;\u0026lt;/code\u0026gt; is called the Wrapped type. Under the hood, an Optional is an \u0026lt;a href=\u0026quot;https://docs.swift.org/swift-book/LanguageGuide/Enumerations.html\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;enum\u0026lt;/a\u0026gt; with two cases: \u0026lt;code\u0026gt;.some(Wrapped)\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;.none\u0026lt;/code\u0026gt;, where \u0026lt;code\u0026gt;.none\u0026lt;/code\u0026gt; is equivalent to \u0026lt;code\u0026gt;nil\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Optionals can be declared using the named type \u0026lt;code\u0026gt;Optional\u0026amp;lt;T\u0026amp;gt;\u0026lt;/code\u0026gt;, or (most commonly) as a shorthand with a \u0026lt;code\u0026gt;?\u0026lt;/code\u0026gt; suffix.\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-swift s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-swift\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; anInt: \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;Int\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;42\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; anOptionalInt: \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;Int\u0026lt;/span\u0026gt;? \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;42\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; anotherOptionalInt: \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;Int\u0026lt;/span\u0026gt;?  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// `nil` is the default when no value is provided\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; aVerboseOptionalInt: \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;Optional\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;Int\u0026lt;/span\u0026gt;\u0026amp;gt;  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// equivalent to `Int?`\u0026lt;/span\u0026gt;\n\nanOptionalInt \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;nil\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// now this variable contains nil instead of an integer\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;Optionals are a simple yet powerful tool to express your assumptions while writing code. The compiler can use this information to prevent you from making mistakes. From \u0026lt;a href=\u0026quot;https://docs.swift.org/swift-book/LanguageGuide/TheBasics.html\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;The Swift Programming Language\u0026lt;/a\u0026gt;:\u0026lt;/p\u0026gt;\n\u0026lt;blockquote\u0026gt;\n\u0026lt;p\u0026gt;Swift is a \u0026lt;em\u0026gt;type-safe\u0026lt;/em\u0026gt; language, which means the language helps you to be clear about the types of values your code can work with. If part of your code requires a \u0026lt;code\u0026gt;String\u0026lt;/code\u0026gt;, type safety prevents you from passing it an \u0026lt;code\u0026gt;Int\u0026lt;/code\u0026gt; by mistake. \u0026lt;strong\u0026gt;Likewise, type safety prevents you from accidentally passing an optional \u0026lt;code\u0026gt;String\u0026lt;/code\u0026gt; to a piece of code that requires a non-optional \u0026lt;code\u0026gt;String\u0026lt;/code\u0026gt;.\u0026lt;/strong\u0026gt; Type safety helps you catch and fix errors as early as possible in the development process.\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\u0026lt;p\u0026gt;Some other programming languages also have generic \u0026lt;a href=\u0026quot;https://en.wikipedia.org/wiki/Option_type\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;option types\u0026lt;/a\u0026gt;: for example, \u0026lt;a href=\u0026quot;https://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Maybe.html\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;Maybe\u0026lt;/a\u0026gt; in Haskell, \u0026lt;a href=\u0026quot;https://doc.rust-lang.org/std/option/\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;option\u0026lt;/a\u0026gt; in Rust, and \u0026lt;a href=\u0026quot;https://en.cppreference.com/w/cpp/utility/optional\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;optional\u0026lt;/a\u0026gt; in C++17.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;In programming languages \u0026lt;em\u0026gt;without\u0026lt;/em\u0026gt; option types, a particular \u0026lt;a href=\u0026quot;https://en.wikipedia.org/wiki/Sentinel_value\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;\u0026quot;sentinel\u0026quot; value\u0026lt;/a\u0026gt; is often used to indicate the absence of a valid value. In Objective-C, for example, \u0026lt;code\u0026gt;nil\u0026lt;/code\u0026gt; (the \u0026lt;a href=\u0026quot;https://en.wikipedia.org/wiki/Null_pointer\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;null pointer\u0026lt;/a\u0026gt;) represents the lack of an object. For primitive types such as \u0026lt;code\u0026gt;int\u0026lt;/code\u0026gt;, a null pointer can\u0026apos;t be used, so you would need either a separate variable (such as \u0026lt;code\u0026gt;value: Int\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;isValid: Bool\u0026lt;/code\u0026gt;) or a designated sentinel value (such as \u0026lt;code\u0026gt;-1\u0026lt;/code\u0026gt; or \u0026lt;code\u0026gt;INT_MIN\u0026lt;/code\u0026gt;). These approaches are error-prone because it\u0026apos;s easy to forget to check \u0026lt;code\u0026gt;isValid\u0026lt;/code\u0026gt; or to check for the sentinel value. Also, if a particular value is chosen as the sentinel, that means it can no longer be treated as a \u0026lt;em\u0026gt;valid\u0026lt;/em\u0026gt; value.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Option types such as Swift\u0026apos;s \u0026lt;code\u0026gt;Optional\u0026lt;/code\u0026gt; solve these problems by introducing a special, separate \u0026lt;code\u0026gt;nil\u0026lt;/code\u0026gt; value (so you don\u0026apos;t have to designate a sentinel value), and by leveraging the strong type system so the compiler can help you remember to check for nil when necessary.\u0026lt;/p\u0026gt;\n\u0026lt;hr\u0026gt;\n\u0026lt;h2\u0026gt;Why did I get \u0026lt;em\u0026gt;Fatal error: Unexpectedly found nil while unwrapping an Optional value\u0026lt;/em\u0026gt;?\u0026lt;/h2\u0026gt;\n\u0026lt;p\u0026gt;In order to access an optionals value (if it has one at all), you need to \u0026lt;strong\u0026gt;unwrap\u0026lt;/strong\u0026gt; it. An optional value can be unwrapped safely or forcibly. If you force-unwrap an optional, and it \u0026lt;em\u0026gt;didn\u0026apos;t\u0026lt;/em\u0026gt; have a value, your program will crash with the above message.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Xcode will show you the crash by highlighting a line of code. The problem occurs on this line.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;a href=\u0026quot;https://i.stack.imgur.com/dQelz.png\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;\u0026lt;img src=\u0026quot;https://i.stack.imgur.com/dQelz.png\u0026quot; alt=\u0026quot;crashed line\u0026quot;\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;This crash can occur with two different kinds of force-unwrap:\u0026lt;/p\u0026gt;\n\u0026lt;h3\u0026gt;1. Explicit Force Unwrapping\u0026lt;/h3\u0026gt;\n\u0026lt;p\u0026gt;This is done with the \u0026lt;code\u0026gt;!\u0026lt;/code\u0026gt; operator on an optional. For example:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-swift s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-swift\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;let\u0026lt;/span\u0026gt; anOptionalString: \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;String\u0026lt;/span\u0026gt;?\n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt;(anOptionalString\u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;!\u0026lt;/span\u0026gt;) \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// \u0026amp;lt;- CRASH\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;blockquote\u0026gt;\n\u0026lt;p\u0026gt;Fatal error: Unexpectedly found nil while unwrapping an Optional value\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\u0026lt;p\u0026gt;As \u0026lt;code\u0026gt;anOptionalString\u0026lt;/code\u0026gt; is \u0026lt;code\u0026gt;nil\u0026lt;/code\u0026gt; here, you will get a crash on the line where you force unwrap it.\u0026lt;/p\u0026gt;\n\u0026lt;h3\u0026gt;2. Implicitly Unwrapped Optionals\u0026lt;/h3\u0026gt;\n\u0026lt;p\u0026gt;These are defined with  a \u0026lt;code\u0026gt;!\u0026lt;/code\u0026gt;, rather than a \u0026lt;code\u0026gt;?\u0026lt;/code\u0026gt; after the type.\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-swift s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-swift\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; optionalDouble: \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;Double\u0026lt;/span\u0026gt;!   \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// this value is implicitly unwrapped wherever it\u0026apos;s used\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;These optionals are assumed to contain a value. Therefore whenever you access an implicitly unwrapped optional, it will automatically be force unwrapped for you. If it doesnt contain a value, it will crash.\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-swift s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-swift\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt;(optionalDouble) \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// \u0026amp;lt;- CRASH\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;blockquote\u0026gt;\n\u0026lt;p\u0026gt;Fatal error: Unexpectedly found nil while \u0026lt;strong\u0026gt;implicitly\u0026lt;/strong\u0026gt; unwrapping an Optional value\u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\u0026lt;p\u0026gt;In order to work out which variable caused the crash, you can hold \u0026lt;kbd\u0026gt;\u0026lt;/kbd\u0026gt; while clicking to show the definition, where you might find the optional type.\u0026lt;/p\u0026gt;\n\u0026lt;img src=\u0026quot;https://i.stack.imgur.com/zZmlK.gif\u0026quot; width=\u0026quot;300\u0026quot;\u0026gt;\n\u0026lt;p\u0026gt;IBOutlets, in particular, are usually implicitly unwrapped optionals. This is because your xib or storyboard will link up the outlets at runtime, \u0026lt;em\u0026gt;after\u0026lt;/em\u0026gt; initialization. You should therefore ensure that youre not accessing outlets before they\u0026apos;re loaded in. You also should check that the connections are correct in your storyboard/xib file, otherwise the values will be \u0026lt;code\u0026gt;nil\u0026lt;/code\u0026gt; at runtime, and therefore crash when they are implicitly unwrapped. When fixing connections, try deleting the lines of code that define your outlets, then reconnect them.\u0026lt;/p\u0026gt;\n\u0026lt;hr\u0026gt;\n\u0026lt;h2\u0026gt;When should I ever force unwrap an Optional?\u0026lt;/h2\u0026gt;\n\u0026lt;h3\u0026gt;Explicit Force Unwrapping\u0026lt;/h3\u0026gt;\n\u0026lt;p\u0026gt;As a general rule, you should never explicitly force unwrap an optional with the \u0026lt;code\u0026gt;!\u0026lt;/code\u0026gt; operator. There may be cases where using \u0026lt;code\u0026gt;!\u0026lt;/code\u0026gt; is acceptable  but you should only ever be using it if you are 100% sure that the optional contains a value.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;While there \u0026lt;em\u0026gt;may\u0026lt;/em\u0026gt; be an occasion where you can use force unwrapping, as you know for a \u0026lt;em\u0026gt;fact\u0026lt;/em\u0026gt; that an optional contains a value  there is not a \u0026lt;em\u0026gt;single\u0026lt;/em\u0026gt; place where you cannot safely unwrap that optional instead.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;b\u0026gt;\u0026lt;/b\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;h3\u0026gt;Implicitly Unwrapped Optionals\u0026lt;/h3\u0026gt;\n\u0026lt;p\u0026gt;These variables are designed so that you can defer their assignment until later in your code. It is \u0026lt;em\u0026gt;your\u0026lt;/em\u0026gt; responsibility to ensure they have a value before you access them. However, because they involve force unwrapping, they are still inherently unsafe  as they \u0026lt;em\u0026gt;assume\u0026lt;/em\u0026gt; your value is non-nil, even though assigning nil is valid.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;You should only be using implicitly unwrapped optionals as a \u0026lt;em\u0026gt;last resort\u0026lt;/em\u0026gt;. If you can use a \u0026lt;a href=\u0026quot;https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Properties.html#//apple_ref/doc/uid/TP40014097-CH14-ID255\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;lazy variable\u0026lt;/a\u0026gt;, or provide a \u0026lt;a href=\u0026quot;https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Initialization.html#//apple_ref/doc/uid/TP40014097-CH18-ID206\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;default value\u0026lt;/a\u0026gt; for a variable  you should do so instead of using an implicitly unwrapped optional.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;However, there are a \u0026lt;a href=\u0026quot;https://stackoverflow.com/a/24583157/2976878\u0026quot;\u0026gt;few scenarios where implicitly unwrapped optionals are beneficial\u0026lt;/a\u0026gt;, and you are still able to use various ways of safely unwrapping them as listed below  but you should \u0026lt;em\u0026gt;always\u0026lt;/em\u0026gt; use them with due caution.\u0026lt;/p\u0026gt;\n\u0026lt;hr\u0026gt;\n\u0026lt;h2\u0026gt;How can I safely deal with Optionals?\u0026lt;/h2\u0026gt;\n\u0026lt;p\u0026gt;The simplest way to check whether an optional contains a value, is to compare it to \u0026lt;code\u0026gt;nil\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-swift s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-swift\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; anOptionalInt \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;!=\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;nil\u0026lt;/span\u0026gt; {\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Contains a value!\u0026quot;\u0026lt;/span\u0026gt;)\n} \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;else\u0026lt;/span\u0026gt; {\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Doesnt contain a value.\u0026quot;\u0026lt;/span\u0026gt;)\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;However, 99.9% of the time when working with optionals, youll actually want to access the value it contains, if it contains one at all. To do this, you can use \u0026lt;em\u0026gt;Optional Binding\u0026lt;/em\u0026gt;.\u0026lt;/p\u0026gt;\n\u0026lt;h3\u0026gt;Optional Binding\u0026lt;/h3\u0026gt;\n\u0026lt;p\u0026gt;Optional Binding allows you to check if an optional contains a value  and allows you to assign the unwrapped value to a new variable or constant. It uses the syntax \u0026lt;code\u0026gt;if let x = anOptional {...}\u0026lt;/code\u0026gt; or \u0026lt;code\u0026gt;if var x = anOptional {...}\u0026lt;/code\u0026gt;, depending if you need to modify the value of the new variable after binding it.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;For example:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-swift s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-swift\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;let\u0026lt;/span\u0026gt; number \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; anOptionalInt {\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Contains a value! It is \u0026lt;span class=\u0026quot;hljs-subst\u0026quot;\u0026gt;\\(number)\u0026lt;/span\u0026gt;!\u0026quot;\u0026lt;/span\u0026gt;)\n} \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;else\u0026lt;/span\u0026gt; {\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Doesnt contain a number\u0026quot;\u0026lt;/span\u0026gt;)\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;What this does is first check that the optional contains a value. If it \u0026lt;em\u0026gt;does\u0026lt;/em\u0026gt;, then the unwrapped value is assigned to  a new variable (\u0026lt;code\u0026gt;number\u0026lt;/code\u0026gt;)  which you can then freely use as if it were non-optional. If the optional \u0026lt;em\u0026gt;doesnt\u0026lt;/em\u0026gt; contain a value, then the else clause will be invoked, as you would expect.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Whats neat about optional binding, is you can unwrap multiple optionals at the same time. You can just separate the statements with a comma. The statement will succeed if all the optionals were unwrapped.\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-swift s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-swift\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; anOptionalInt : \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;Int\u0026lt;/span\u0026gt;?\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; anOptionalString : \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;String\u0026lt;/span\u0026gt;?\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;let\u0026lt;/span\u0026gt; number \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; anOptionalInt, \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;let\u0026lt;/span\u0026gt; text \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; anOptionalString {\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;anOptionalInt contains a value: \u0026lt;span class=\u0026quot;hljs-subst\u0026quot;\u0026gt;\\(number)\u0026lt;/span\u0026gt;. And so does anOptionalString, its: \u0026lt;span class=\u0026quot;hljs-subst\u0026quot;\u0026gt;\\(text)\u0026lt;/span\u0026gt;\u0026quot;\u0026lt;/span\u0026gt;)\n} \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;else\u0026lt;/span\u0026gt; {\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;One or more of the optionals dont contain a value\u0026quot;\u0026lt;/span\u0026gt;)\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;Another neat trick is that you can also use commas to check for a certain condition on the value, after unwrapping it.\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-swift s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-swift\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;let\u0026lt;/span\u0026gt; number \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; anOptionalInt, number \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;\u0026amp;gt;\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt; {\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;anOptionalInt contains a value: \u0026lt;span class=\u0026quot;hljs-subst\u0026quot;\u0026gt;\\(number)\u0026lt;/span\u0026gt;, and its greater than zero!\u0026quot;\u0026lt;/span\u0026gt;)\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;The only catch with using optional binding within an if statement, is that you can only access the unwrapped value from within the scope of the statement. If you need access to the value from outside of the scope of the statement, you can use a \u0026lt;em\u0026gt;guard statement\u0026lt;/em\u0026gt;.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;A \u0026lt;a href=\u0026quot;https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Statements.html#//apple_ref/swift/grammar/if-statement\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;guard statement\u0026lt;/a\u0026gt; allows you to define a condition for success  and the current scope will only continue executing if that condition is met. They are defined with the syntax \u0026lt;code\u0026gt;guard condition else {...}\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;So, to use them with an optional binding, you can do this:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-swift s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-swift\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;guard\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;let\u0026lt;/span\u0026gt; number \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; anOptionalInt \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;else\u0026lt;/span\u0026gt; {\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;sup\u0026gt;(Note that within the guard body, you \u0026lt;strong\u0026gt;must\u0026lt;/strong\u0026gt; use one of the \u0026lt;a href=\u0026quot;https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/ControlFlow.html#//apple_ref/doc/uid/TP40014097-CH9-ID135\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;control transfer statements\u0026lt;/a\u0026gt; in order to exit the scope of the currently executing code).\u0026lt;/sup\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;If \u0026lt;code\u0026gt;anOptionalInt\u0026lt;/code\u0026gt; contains a value, it will be unwrapped and assigned to the new \u0026lt;code\u0026gt;number\u0026lt;/code\u0026gt; constant. The code \u0026lt;em\u0026gt;after\u0026lt;/em\u0026gt; the guard will then continue executing. If it doesnt contain a value  the guard will execute the code within the brackets, which will lead to transfer of control, so that the code immediately after will not be executed.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;The real neat thing about guard statements is the unwrapped value is now available to use in code that follows the statement (as we know that future code can \u0026lt;em\u0026gt;only\u0026lt;/em\u0026gt; execute if the optional has a value). This is a great for eliminating \u0026lt;a href=\u0026quot;https://en.wikipedia.org/wiki/Pyramid_of_doom_(programming)\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;pyramids of doom\u0026lt;/a\u0026gt; created by nesting multiple if statements.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;For example:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-swift s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-swift\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;guard\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;let\u0026lt;/span\u0026gt; number \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; anOptionalInt \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;else\u0026lt;/span\u0026gt; {\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt;\n}\n\n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;anOptionalInt contains a value, and its: \u0026lt;span class=\u0026quot;hljs-subst\u0026quot;\u0026gt;\\(number)\u0026lt;/span\u0026gt;!\u0026quot;\u0026lt;/span\u0026gt;)\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;Guards also support the same neat tricks that the if statement supported, such as unwrapping multiple optionals at the same time and using the \u0026lt;code\u0026gt;where\u0026lt;/code\u0026gt; clause.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Whether you use an if or guard statement completely depends on whether any future code \u0026lt;em\u0026gt;requires\u0026lt;/em\u0026gt; the optional to contain a value.\u0026lt;/p\u0026gt;\n\u0026lt;h3\u0026gt;Nil Coalescing Operator\u0026lt;/h3\u0026gt;\n\u0026lt;p\u0026gt;The \u0026lt;a href=\u0026quot;https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/BasicOperators.html#//apple_ref/doc/uid/TP40014097-CH6-ID72\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;Nil Coalescing Operator\u0026lt;/a\u0026gt; is a nifty shorthand version of the \u0026lt;a href=\u0026quot;https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/BasicOperators.html#//apple_ref/doc/uid/TP40014097-CH6-ID71\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;ternary conditional operator\u0026lt;/a\u0026gt;, primarily designed to convert optionals to non-optionals. It has the syntax \u0026lt;code\u0026gt;a ?? b\u0026lt;/code\u0026gt;, where \u0026lt;code\u0026gt;a\u0026lt;/code\u0026gt; is an optional type and \u0026lt;code\u0026gt;b\u0026lt;/code\u0026gt; is the same type as \u0026lt;code\u0026gt;a\u0026lt;/code\u0026gt; (although usually non-optional).\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;It essentially lets you say If \u0026lt;code\u0026gt;a\u0026lt;/code\u0026gt; contains a value, unwrap it. If it doesnt then return \u0026lt;code\u0026gt;b\u0026lt;/code\u0026gt; instead. For example, you could use it like this:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-swift s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-swift\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;let\u0026lt;/span\u0026gt; number \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; anOptionalInt \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;??\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;This will define a \u0026lt;code\u0026gt;number\u0026lt;/code\u0026gt; constant of \u0026lt;code\u0026gt;Int\u0026lt;/code\u0026gt; type, that will either contain the value of \u0026lt;code\u0026gt;anOptionalInt\u0026lt;/code\u0026gt;, if it contains a value, or \u0026lt;code\u0026gt;0\u0026lt;/code\u0026gt; otherwise.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Its just shorthand for:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-swift s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-swift\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;let\u0026lt;/span\u0026gt; number \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; anOptionalInt \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;!=\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;nil\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;?\u0026lt;/span\u0026gt; anOptionalInt\u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;!\u0026lt;/span\u0026gt; : \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;h3\u0026gt;Optional Chaining\u0026lt;/h3\u0026gt;\n\u0026lt;p\u0026gt;You can use \u0026lt;a href=\u0026quot;https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/OptionalChaining.html#//apple_ref/doc/uid/TP40014097-CH21-ID245\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;Optional Chaining\u0026lt;/a\u0026gt; in order to call a method or access a property on an optional. This is simply done by suffixing the variable name with a \u0026lt;code\u0026gt;?\u0026lt;/code\u0026gt; when using it.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;For example, say we have a variable \u0026lt;code\u0026gt;foo\u0026lt;/code\u0026gt;, of type an optional \u0026lt;code\u0026gt;Foo\u0026lt;/code\u0026gt; instance.\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-swift s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-swift\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; foo : \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;Foo\u0026lt;/span\u0026gt;?\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;If we wanted to call a method on \u0026lt;code\u0026gt;foo\u0026lt;/code\u0026gt; that doesnt return anything, we can simply do:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-swift s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-swift\u0026quot;\u0026gt;foo\u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;?\u0026lt;/span\u0026gt;.doSomethingInteresting()\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;If \u0026lt;code\u0026gt;foo\u0026lt;/code\u0026gt; contains a value, this method will be called on it. If it doesnt, nothing bad will happen  the code will simply continue executing.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;sup\u0026gt;(This is similar behaviour to sending messages to \u0026lt;code\u0026gt;nil\u0026lt;/code\u0026gt; in Objective-C)\u0026lt;/sup\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;This can therefore also be used to set properties as well as call methods. For example:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-swift s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-swift\u0026quot;\u0026gt;foo\u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;?\u0026lt;/span\u0026gt;.bar \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;Bar\u0026lt;/span\u0026gt;()\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;Again, nothing bad will happen here if \u0026lt;code\u0026gt;foo\u0026lt;/code\u0026gt; is \u0026lt;code\u0026gt;nil\u0026lt;/code\u0026gt;. Your code will simply continue executing.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Another neat trick that optional chaining lets you do is check whether setting a property or calling a method was successful. You can do this by comparing the return value to \u0026lt;code\u0026gt;nil\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;sup\u0026gt;(This is because an optional value will return \u0026lt;code\u0026gt;Void?\u0026lt;/code\u0026gt; rather than \u0026lt;code\u0026gt;Void\u0026lt;/code\u0026gt; on a method that doesnt return anything)\u0026lt;/sup\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;For example:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-swift s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-swift\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (foo\u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;?\u0026lt;/span\u0026gt;.bar \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;Bar\u0026lt;/span\u0026gt;()) \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;!=\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;nil\u0026lt;/span\u0026gt; {\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;bar was set successfully\u0026quot;\u0026lt;/span\u0026gt;)\n} \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;else\u0026lt;/span\u0026gt; {\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;bar wasnt set successfully\u0026quot;\u0026lt;/span\u0026gt;)\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;However, things become a little bit more tricky when trying to access properties or call methods that return a value. Because \u0026lt;code\u0026gt;foo\u0026lt;/code\u0026gt; is optional, anything returned from it will also be optional. To deal with this, you can either unwrap the optionals that get returned using one of the above methods  or unwrap \u0026lt;code\u0026gt;foo\u0026lt;/code\u0026gt; itself before accessing methods or calling methods that return values.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Also, as the name suggests, you can chain these statements together. This means that if \u0026lt;code\u0026gt;foo\u0026lt;/code\u0026gt; has an optional property \u0026lt;code\u0026gt;baz\u0026lt;/code\u0026gt;, which has a property \u0026lt;code\u0026gt;qux\u0026lt;/code\u0026gt;  you could write the following:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-swift s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-swift\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;let\u0026lt;/span\u0026gt; optionalQux \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; foo\u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;?\u0026lt;/span\u0026gt;.baz\u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;?\u0026lt;/span\u0026gt;.qux\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;Again, because \u0026lt;code\u0026gt;foo\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;baz\u0026lt;/code\u0026gt; are optional, the value returned from \u0026lt;code\u0026gt;qux\u0026lt;/code\u0026gt; will always be an optional regardless of whether \u0026lt;code\u0026gt;qux\u0026lt;/code\u0026gt; itself is optional.\u0026lt;/p\u0026gt;\n\u0026lt;h3\u0026gt;\u0026lt;code\u0026gt;map\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;flatMap\u0026lt;/code\u0026gt;\u0026lt;/h3\u0026gt;\n\u0026lt;p\u0026gt;An often underused feature with optionals is the ability to use the \u0026lt;code\u0026gt;map\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;flatMap\u0026lt;/code\u0026gt; functions. These allow you to apply non-optional transforms to optional variables. If an optional has a value, you can apply a given transformation to it. If it doesnt have a value, it will remain \u0026lt;code\u0026gt;nil\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;For example, lets say you have an optional string:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-swift s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-swift\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;let\u0026lt;/span\u0026gt; anOptionalString:\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;String\u0026lt;/span\u0026gt;?\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;By applying the \u0026lt;code\u0026gt;map\u0026lt;/code\u0026gt; function to it  we can use the \u0026lt;code\u0026gt;stringByAppendingString\u0026lt;/code\u0026gt; function in order to concatenate it to another string.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Because \u0026lt;code\u0026gt;stringByAppendingString\u0026lt;/code\u0026gt; takes a non-optional string argument, we cannot input our optional string directly. However, by using \u0026lt;code\u0026gt;map\u0026lt;/code\u0026gt;, we can use allow \u0026lt;code\u0026gt;stringByAppendingString\u0026lt;/code\u0026gt; to be used if \u0026lt;code\u0026gt;anOptionalString\u0026lt;/code\u0026gt; has a value.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;For example:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-swift s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-swift\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; anOptionalString:\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;String\u0026lt;/span\u0026gt;? \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;bar\u0026quot;\u0026lt;/span\u0026gt;\n\nanOptionalString \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; anOptionalString.map {unwrappedString \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;in\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;foo\u0026quot;\u0026lt;/span\u0026gt;.stringByAppendingString(unwrappedString)\n}\n\n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt;(anOptionalString) \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Optional(\u0026quot;foobar\u0026quot;)\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;However, if \u0026lt;code\u0026gt;anOptionalString\u0026lt;/code\u0026gt; doesnt have a value, \u0026lt;code\u0026gt;map\u0026lt;/code\u0026gt; will return \u0026lt;code\u0026gt;nil\u0026lt;/code\u0026gt;. For example:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-swift s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-swift\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; anOptionalString:\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;String\u0026lt;/span\u0026gt;?\n\nanOptionalString \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; anOptionalString.map {unwrappedString \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;in\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;foo\u0026quot;\u0026lt;/span\u0026gt;.stringByAppendingString(unwrappedString)\n}\n\n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt;(anOptionalString) \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// nil\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;code\u0026gt;flatMap\u0026lt;/code\u0026gt; works similarly to \u0026lt;code\u0026gt;map\u0026lt;/code\u0026gt;, except it allows you to return \u0026lt;em\u0026gt;another\u0026lt;/em\u0026gt; optional from within the closure body. This means you can input an optional into a process that requires a non-optional input, but can output an optional itself.\u0026lt;/p\u0026gt;\n\u0026lt;h2\u0026gt;\u0026lt;code\u0026gt;try!\u0026lt;/code\u0026gt;\u0026lt;/h2\u0026gt;\n\u0026lt;p\u0026gt;Swift\u0026apos;s error handling system can be safely used with \u0026lt;a href=\u0026quot;https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/ErrorHandling.html#//apple_ref/doc/uid/TP40014097-CH42-ID508\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;Do-Try-Catch\u0026lt;/a\u0026gt;:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-swift s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-swift\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;do\u0026lt;/span\u0026gt; {\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;let\u0026lt;/span\u0026gt; result \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;try\u0026lt;/span\u0026gt; someThrowingFunc() \n} \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;catch\u0026lt;/span\u0026gt; {\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt;(error)\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;If \u0026lt;code\u0026gt;someThrowingFunc()\u0026lt;/code\u0026gt; throws an error, the error will be safely caught in the \u0026lt;code\u0026gt;catch\u0026lt;/code\u0026gt; block.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;The \u0026lt;code\u0026gt;error\u0026lt;/code\u0026gt; constant you see in the \u0026lt;code\u0026gt;catch\u0026lt;/code\u0026gt; block has not been declared by us - it\u0026apos;s automatically generated by \u0026lt;code\u0026gt;catch\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;You can also declare \u0026lt;code\u0026gt;error\u0026lt;/code\u0026gt; yourself, it has the advantage of being able to cast it to a useful format, for example:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-swift s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-swift\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;do\u0026lt;/span\u0026gt; {\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;let\u0026lt;/span\u0026gt; result \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;try\u0026lt;/span\u0026gt; someThrowingFunc()    \n} \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;catch\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;let\u0026lt;/span\u0026gt; error \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;as\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;NSError\u0026lt;/span\u0026gt; {\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt;(error.debugDescription)\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;Using \u0026lt;code\u0026gt;try\u0026lt;/code\u0026gt; this way is the proper way to try, catch and handle errors coming from throwing functions.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;There\u0026apos;s also \u0026lt;code\u0026gt;try?\u0026lt;/code\u0026gt; which absorbs the error:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-swift s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-swift\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;let\u0026lt;/span\u0026gt; result \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;try?\u0026lt;/span\u0026gt; someThrowingFunc() {\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// cool\u0026lt;/span\u0026gt;\n} \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;else\u0026lt;/span\u0026gt; {\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// handle the failure, but there\u0026apos;s no error information available\u0026lt;/span\u0026gt;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;But Swift\u0026apos;s error handling system also provides a way to \u0026quot;force try\u0026quot; with \u0026lt;code\u0026gt;try!\u0026lt;/code\u0026gt;:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-swift s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-swift\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;let\u0026lt;/span\u0026gt; result \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;try!\u0026lt;/span\u0026gt; someThrowingFunc()\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;The concepts explained in this post also apply here: if an error is thrown, the application will crash.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;\u0026lt;em\u0026gt;You should only ever use \u0026lt;code\u0026gt;try!\u0026lt;/code\u0026gt; if you can prove that its result will never fail in your context - and this is very rare.\u0026lt;/em\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Most of the time you will use the complete Do-Try-Catch system - and the optional one, \u0026lt;code\u0026gt;try?\u0026lt;/code\u0026gt;, in the rare cases where handling the error is not important.\u0026lt;/p\u0026gt;\n\u0026lt;hr\u0026gt;\n\u0026lt;h2\u0026gt;Resources\u0026lt;/h2\u0026gt;\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;a href=\u0026quot;https://docs.swift.org/swift-book/LanguageGuide/TheBasics.html#ID330\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;Apple documentation on Swift Optionals\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;a href=\u0026quot;https://stackoverflow.com/a/24583157/2976878\u0026quot;\u0026gt;When to use and when not to use implicitly unwrapped optionals\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;a href=\u0026quot;http://www.raywenderlich.com/10209/my-app-crashed-now-what-part-1\u0026quot; rel=\u0026quot;noreferrer\u0026quot;\u0026gt;Learn how to debug an iOS app crash\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n    ","\n\u0026lt;h1\u0026gt;TL;DR answer\u0026lt;/h1\u0026gt;\n\u0026lt;p\u0026gt;With \u0026lt;a href=\u0026quot;https://stackoverflow.com/a/24583157/1311272\u0026quot;\u0026gt;very few exceptions\u0026lt;/a\u0026gt;, this rule is golden:\u0026lt;/p\u0026gt;\n\u0026lt;h1\u0026gt;Avoid use of \u0026lt;code\u0026gt;!\u0026lt;/code\u0026gt;\u0026lt;/h1\u0026gt;\n\u0026lt;h3\u0026gt;Declare variable optional (\u0026lt;code\u0026gt;?\u0026lt;/code\u0026gt;), not implicitly unwrapped optionals (IUO) (\u0026lt;code\u0026gt;!\u0026lt;/code\u0026gt;)\u0026lt;/h3\u0026gt;\n\u0026lt;p\u0026gt;In other words, rather use:\u0026lt;br\u0026gt;\n\u0026lt;code\u0026gt;var nameOfDaughter: String?\u0026lt;/code\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Instead of:\u0026lt;br\u0026gt;\n\u0026lt;code\u0026gt;var nameOfDaughter: String!\u0026lt;/code\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;h3\u0026gt;Unwrap optional variable using \u0026lt;code\u0026gt;if let\u0026lt;/code\u0026gt; or \u0026lt;code\u0026gt;guard let\u0026lt;/code\u0026gt;\u0026lt;/h3\u0026gt;\n\u0026lt;p\u0026gt;Either unwrap variable like this:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-swift s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-swift\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;let\u0026lt;/span\u0026gt; nameOfDaughter \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; nameOfDaughter {\n    \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;My daughters name is: \u0026lt;span class=\u0026quot;hljs-subst\u0026quot;\u0026gt;\\(nameOfDaughter)\u0026lt;/span\u0026gt;\u0026quot;\u0026lt;/span\u0026gt;)\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;Or like this:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-swift s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-swift\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;guard\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;let\u0026lt;/span\u0026gt; nameOfDaughter \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; nameOfDaughter \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;else\u0026lt;/span\u0026gt; { \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; }\n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;My daughters name is: \u0026lt;span class=\u0026quot;hljs-subst\u0026quot;\u0026gt;\\(nameOfDaughter)\u0026lt;/span\u0026gt;\u0026quot;\u0026lt;/span\u0026gt;)\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;This answer was intended to be concise, \u0026lt;a href=\u0026quot;https://stackoverflow.com/a/32170457/1311272\u0026quot;\u0026gt;for full comprehension read accepted answer\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\n\u0026lt;hr\u0026gt;\n\u0026lt;h2\u0026gt;Resources\u0026lt;/h2\u0026gt;\n\u0026lt;ul\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;a href=\u0026quot;https://blog.timac.org/2017/0628-swift-banning-force-unwrapping-optionals/\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;Avoiding force unwrapping\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n    ","\n\u0026lt;p\u0026gt;This question comes up \u0026lt;strong\u0026gt;ALL THE TIME\u0026lt;/strong\u0026gt; on SO. It\u0026apos;s one of the first things that new Swift developers struggle with.\u0026lt;/p\u0026gt;\n\u0026lt;h2\u0026gt;Background:\u0026lt;/h2\u0026gt;\n\u0026lt;p\u0026gt;Swift uses the concept of \u0026quot;Optionals\u0026quot; to deal with values that could contain a value, or not. In other languages like C, you might store a value of 0 in a variable to indicate that it contains no value. However, what if 0 is a valid value? Then you might use -1. What if -1 is a valid value? And so on.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Swift optionals let you set up a variable of any type to contain either a valid value, or no value.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;You put a question mark after the type when you declare a variable to mean (type x, or no value).\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;An optional is actually a container than contains either a variable of a given type, or nothing.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;An optional needs to be \u0026quot;unwrapped\u0026quot; in order to fetch the value inside.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;The \u0026quot;!\u0026quot; operator is a \u0026quot;force unwrap\u0026quot; operator. It says \u0026quot;trust me. I know what I am doing. I guarantee that when this code runs, the variable will not contain nil.\u0026quot; If you are wrong, you crash.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Unless you really \u0026lt;strong\u0026gt;do\u0026lt;/strong\u0026gt; know what you are doing, avoid the \u0026quot;!\u0026quot; force unwrap operator. It is probably the largest source of crashes for beginning Swift programmers.\u0026lt;/p\u0026gt;\n\u0026lt;h2\u0026gt;How to deal with optionals:\u0026lt;/h2\u0026gt;\n\u0026lt;p\u0026gt;There are lots of other ways of dealing with optionals that are safer. Here are some (not an exhaustive list)\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;You can use \u0026quot;optional binding\u0026quot; or \u0026quot;if let\u0026quot; to say \u0026quot;if this optional contains a value, save that value into a new, non-optional variable. If the optional does not contain a value, skip the body of this if statement\u0026quot;.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Here is an example of optional binding with our \u0026lt;code\u0026gt;foo\u0026lt;/code\u0026gt; optional:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-swift s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-swift\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;let\u0026lt;/span\u0026gt; newFoo \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; foo \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//If let is called optional binding. {\u0026lt;/span\u0026gt;\n  \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;foo is not nil\u0026quot;\u0026lt;/span\u0026gt;)\n} \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;else\u0026lt;/span\u0026gt; {\n  \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;foo is nil\u0026quot;\u0026lt;/span\u0026gt;)\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;Note that the variable you define when you use optional biding only exists (is only \u0026quot;in scope\u0026quot;) in the body of the if statement.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Alternately, you could use a guard statement, which lets you exit your function if the variable is nil:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-swift s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-swift\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;func\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;aFunc\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;foo\u0026lt;/span\u0026gt;: \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;Int\u0026lt;/span\u0026gt;?) {\n  \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;guard\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;let\u0026lt;/span\u0026gt; newFoo \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; input \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;else\u0026lt;/span\u0026gt; { \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; }\n  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//For the rest of the function newFoo is a non-optional var\u0026lt;/span\u0026gt;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;Guard statements were added in Swift 2. Guard lets you preserve the \u0026quot;golden path\u0026quot; through your code, and avoid ever-increasing levels of nested ifs that sometimes result from using \u0026quot;if let\u0026quot; optional binding.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;There is also a construct called the \u0026quot;nil coalescing operator\u0026quot;. It takes the form \u0026quot;optional_var ?? replacement_val\u0026quot;. It returns a non-optional variable with the same type as the data contained in the optional. If the optional contains nil, it returns the value of the expression after the \u0026quot;??\u0026quot; symbol.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;So you could use code like this:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-swift s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-swift\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;let\u0026lt;/span\u0026gt; newFoo \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; foo \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;??\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;nil\u0026quot;\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// \u0026quot;??\u0026quot; is the nil coalescing operator\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;foo = \u0026lt;span class=\u0026quot;hljs-subst\u0026quot;\u0026gt;\\(newFoo)\u0026lt;/span\u0026gt;\u0026quot;\u0026lt;/span\u0026gt;)\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;You could also use try/catch or guard error handling, but generally one of the other techniques above is cleaner.\u0026lt;/p\u0026gt;\n\u0026lt;h2\u0026gt;EDIT:\u0026lt;/h2\u0026gt;\n\u0026lt;p\u0026gt;Another, slightly more subtle gotcha with optionals is \u0026quot;implicitly unwrapped optionals. When we declare foo, we could say:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-swift s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-swift\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; foo: \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;String\u0026lt;/span\u0026gt;!\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;In that case foo is still an optional, but you don\u0026apos;t have to unwrap it to reference it.  That means any time you try to reference foo, you crash if it\u0026apos;s nil.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;So this code:\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-swift s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-swift\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; foo: \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;String\u0026lt;/span\u0026gt;!\n\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;let\u0026lt;/span\u0026gt; upperFoo \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; foo.capitalizedString\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;Will crash on reference to foo\u0026apos;s capitalizedString property even though we\u0026apos;re not force-unwrapping foo. the print looks fine, but it\u0026apos;s not.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Thus you want to be really careful with implicitly unwrapped optionals.  (and perhaps even avoid them completely until you have a solid understanding of optionals.)\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Bottom line: When you are first learning Swift, pretend the \u0026quot;!\u0026quot; character is not part of the language. It\u0026apos;s likely to get you into trouble.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Since the above answers clearly explains how to play safely with Optionals.\nI will try explain what Optionals are really in swift.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Another way to declare an optional variable is \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;code\u0026gt;var i : Optional\u0026amp;lt;Int\u0026amp;gt;\u0026lt;/code\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;And Optional type is nothing but an enumeration with two cases, i.e \u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-swift s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-swift\u0026quot;\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;enum\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Optional\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Wrapped\u0026lt;/span\u0026gt;\u0026amp;gt; : \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;ExpressibleByNilLiteral\u0026lt;/span\u0026gt; {\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;case\u0026lt;/span\u0026gt; none \n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;case\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;some\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;Wrapped\u0026lt;/span\u0026gt;)\n    .\n    .\n    .\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;So to assign a nil to our variable \u0026apos;i\u0026apos;. We can do \n\u0026lt;code\u0026gt;var i = Optional\u0026amp;lt;Int\u0026amp;gt;.none\u0026lt;/code\u0026gt;\nor to assign a value, we will pass some value \n\u0026lt;code\u0026gt;var i = Optional\u0026amp;lt;Int\u0026amp;gt;.some(28)\u0026lt;/code\u0026gt; \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;According to swift, \u0026apos;nil\u0026apos; is the absence of value.\nAnd to create an instance initialized with \u0026lt;code\u0026gt;nil\u0026lt;/code\u0026gt; We have to conform to a protocol called \u0026lt;code\u0026gt;ExpressibleByNilLiteral\u0026lt;/code\u0026gt; and great if you guessed it, only \u0026lt;code\u0026gt;Optionals\u0026lt;/code\u0026gt; conform to \u0026lt;code\u0026gt;ExpressibleByNilLiteral\u0026lt;/code\u0026gt; and conforming to other types is discouraged.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;code\u0026gt;ExpressibleByNilLiteral\u0026lt;/code\u0026gt; has a single method called \u0026lt;code\u0026gt;init(nilLiteral:)\u0026lt;/code\u0026gt; which initializes an instace with nil. You usually wont call this method and according to swift documentation it is discouraged to call this initializer directly as the compiler calls it whenever you initialize an Optional type with \u0026lt;code\u0026gt;nil\u0026lt;/code\u0026gt; literal.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Even myself has to wrap (no pun intended) my head around Optionals :D\n\u0026lt;em\u0026gt;Happy Swfting All\u0026lt;/em\u0026gt;. \u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;First, you should know what an Optional value is.\nYou can step to \u0026lt;a href=\u0026quot;https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/OptionalChaining.html\u0026quot; rel=\u0026quot;nofollow noreferrer\u0026quot;\u0026gt;The Swift Programming Language\u0026lt;/a\u0026gt; for detail.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Second, you should know the optional value has two statuses. One is the full value, and the other is a nil value. So before you implement an optional value, you should check which state it is.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;You can use \u0026lt;code\u0026gt;if let ...\u0026lt;/code\u0026gt; or \u0026lt;code\u0026gt;guard let ... else\u0026lt;/code\u0026gt; and so on.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;One other way, if you don\u0026apos;t want to check the variable state before your implementation, you can also use \u0026lt;code\u0026gt;var buildingName = buildingName ?? \u0026quot;buildingName\u0026quot;\u0026lt;/code\u0026gt; instead.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;I had this error once when I was trying to set my Outlets values from the prepare for segue method as follows:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-swift s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-swift\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;override\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;func\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;prepare\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;segue\u0026lt;/span\u0026gt;: \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;UIStoryboardSegue\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;sender\u0026lt;/span\u0026gt;: \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;Any\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;?\u0026lt;/span\u0026gt;) {\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;let\u0026lt;/span\u0026gt; destination \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; segue.destination \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;as?\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;DestinationVC\u0026lt;/span\u0026gt;{\n\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;let\u0026lt;/span\u0026gt; item \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; sender \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;as?\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;DataItem\u0026lt;/span\u0026gt;{\n            \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// This line pops up the error\u0026lt;/span\u0026gt;\n            destination.nameLabel.text \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; item.name\n        }\n    }\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Then I found out that I can\u0026apos;t set the values of the destination controller outlets because the controller hasn\u0026apos;t been loaded or initialized yet.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;So I solved it this way:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-swift s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-swift\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;override\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;func\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;prepare\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;segue\u0026lt;/span\u0026gt;: \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;UIStoryboardSegue\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;sender\u0026lt;/span\u0026gt;: \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;Any\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;?\u0026lt;/span\u0026gt;) {\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;let\u0026lt;/span\u0026gt; destination \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; segue.destination \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;as?\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;DestinationVC\u0026lt;/span\u0026gt;{\n\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;let\u0026lt;/span\u0026gt; item \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; sender \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;as?\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;DataItem\u0026lt;/span\u0026gt;{\n            \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Created this method in the destination Controller to update its outlets after it\u0026apos;s being initialized and loaded\u0026lt;/span\u0026gt;\n            destination.updateView(itemData:  item)\n        }\n    }\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Destination Controller:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-swift s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-swift\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// This variable to hold the data received to update the Label text after the VIEW DID LOAD\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; name \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;\u0026quot;\u0026lt;/span\u0026gt;\n\n\u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Outlets\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;@IBOutlet\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;weak\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; nameLabel: \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;UILabel\u0026lt;/span\u0026gt;!\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;override\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;func\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;viewDidLoad\u0026lt;/span\u0026gt;() {\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;super\u0026lt;/span\u0026gt;.viewDidLoad()\n\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// Do any additional setup after loading the view.\u0026lt;/span\u0026gt;\n    nameLabel.text \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; name\n}\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;func\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;updateView\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;itemDate\u0026lt;/span\u0026gt;: \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;ObjectModel\u0026lt;/span\u0026gt;) {\n    name \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; itemDate.name\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;I hope this answer helps anyone out there with the same issue as I found the marked answer is great resource to the understanding of optionals and how they work but hasn\u0026apos;t addressed the issue itself directly.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Basically you tried to use a nil value in places where Swift allows only non-nil ones, by telling the compiler to trust you that there will never be nil value there, thus allowing your app to compile.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;There are several scenarios that lead to this kind of fatal error:\u0026lt;/p\u0026gt;\n\n\u0026lt;ol\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;forced unwraps:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-swift s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-swift\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;let\u0026lt;/span\u0026gt; user \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; someVariable\u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;!\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;If \u0026lt;code\u0026gt;someVariable\u0026lt;/code\u0026gt; is nil, then you\u0026apos;ll get a crash. By doing a force unwrap you moved the nil check responsibility from the compiler to you, basically by doing a forced unwrap you\u0026apos;re guaranteeing to the compiler that you\u0026apos;ll never have nil values there. And guess what it happens if somehow a nil value ends in in \u0026lt;code\u0026gt;someVariable\u0026lt;/code\u0026gt;?\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Solution? Use optional binding (aka if-let), do the variable processing there:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-swift s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-swift\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; user \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; someVariable {\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// do your stuff\u0026lt;/span\u0026gt;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;forced (down)casts:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-swift s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-swift\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;let\u0026lt;/span\u0026gt; myRectangle \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; someShape \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;as!\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;Rectangle\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Here by force casting you tell the compiler to no longer worry, as you\u0026apos;ll always have a \u0026lt;code\u0026gt;Rectangle\u0026lt;/code\u0026gt; instance there. And as long as that holds, you don\u0026apos;t have to worry. The problems start when you or your colleagues from the project start circulating non-rectangle values.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Solution? Use optional binding (aka if-let), do the variable processing there:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-swift s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-swift\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;let\u0026lt;/span\u0026gt; myRectangle \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; someShape \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;as?\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;Rectangle\u0026lt;/span\u0026gt; {\n    \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// yay, I have a rectangle\u0026lt;/span\u0026gt;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;Implicitly unwrapped optionals. Let\u0026apos;s assume you have the following class definition:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-swift s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-swift\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;User\u0026lt;/span\u0026gt; {\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; name: \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;String\u0026lt;/span\u0026gt;!\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;init\u0026lt;/span\u0026gt;() {\n        name \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;(unnamed)\u0026quot;\u0026lt;/span\u0026gt;\n    }\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;func\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;nicerName\u0026lt;/span\u0026gt;() {\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Mr/Ms \u0026quot;\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;+\u0026lt;/span\u0026gt; name\n    }\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Now, if no-one messes up with the \u0026lt;code\u0026gt;name\u0026lt;/code\u0026gt; property by setting it to \u0026lt;code\u0026gt;nil\u0026lt;/code\u0026gt;, then it works as expected, however if \u0026lt;code\u0026gt;User\u0026lt;/code\u0026gt; is initialized from a JSON that lacks the \u0026lt;code\u0026gt;name\u0026lt;/code\u0026gt; key, then you get the fatal error when trying to use the property.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Solution? Don\u0026apos;t use them :) Unless you\u0026apos;re 102% sure that the property will always have a non-nil value by the time it needs to be used. In most cases converting to an optional or non-optional will work. Making it non-optional will also result in the compiler helping you by telling the code paths you missed giving a value to that property\u0026lt;/p\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;Unconnected, or not yet connected, outlets. This is a particular case of scenario #3. Basically you have some XIB-loaded class that you want to use.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-swift s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-swift\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;SignInViewController\u0026lt;/span\u0026gt;: \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;UIViewController\u0026lt;/span\u0026gt; {\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;@IBOutlet\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; emailTextField: \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;UITextField\u0026lt;/span\u0026gt;!\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Now if you missed connecting the outlet from the XIB editor, then the app will crash as soon as you\u0026apos;ll want to use the outlet.\nSolution? Make sure all outlets are connected. Or use the \u0026lt;code\u0026gt;?\u0026lt;/code\u0026gt; operator on them: \u0026lt;code\u0026gt;emailTextField?.text = \u0026quot;my@email.com\u0026quot;\u0026lt;/code\u0026gt;. Or declare the outlet as optional, though in this case the compiler will force you to unwrap it all over the code.\u0026lt;/p\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;li\u0026gt;\u0026lt;p\u0026gt;Values coming from Objective-C, and that don\u0026apos;t have nullability annotations. Let\u0026apos;s assume we have the following Objective-C class:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-swift s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-swift\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;@interface\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;MyUser\u0026lt;/span\u0026gt;: \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;NSObject\u0026lt;/span\u0026gt;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;@property\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;NSString\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;*\u0026lt;/span\u0026gt;name;\n\u0026lt;span class=\u0026quot;hljs-meta\u0026quot;\u0026gt;@end\u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Now if no nullability annotations are specified (either explicitly or via \u0026lt;code\u0026gt;NS_ASSUME_NONNULL_BEGIN\u0026lt;/code\u0026gt;/\u0026lt;code\u0026gt;NS_ASSUME_NONNULL_END\u0026lt;/code\u0026gt;), then the \u0026lt;code\u0026gt;name\u0026lt;/code\u0026gt; property will be imported in Swift as \u0026lt;code\u0026gt;String!\u0026lt;/code\u0026gt; (an IUO - implicitly unwrapped optional). As soon as some swift code will want to use the value, it will crash if \u0026lt;code\u0026gt;name\u0026lt;/code\u0026gt; is nil.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Solution? Add nullability annotations to your Objective-C code. Beware though, the Objective-C compiler is a little bit permissive when it comes to nullability, you might end up with nil values, even if you explicitly marked them as \u0026lt;code\u0026gt;nonnull\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt;\u0026lt;/li\u0026gt;\n\u0026lt;/ol\u0026gt;\n    ","\n\u0026lt;p\u0026gt;This is more of a important comment and that why implicitly unwrapped optionals can be deceptive when it comes to debugging \u0026lt;code\u0026gt;nil\u0026lt;/code\u0026gt; values.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Think of the following code: \nIt compiles with no errors/warnings:\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-swift s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-swift\u0026quot;\u0026gt;c1.address.city \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; c3.address.city\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Yet at runtime it gives the following error: \u0026lt;em\u0026gt;Fatal error: Unexpectedly found nil while unwrapping an Optional value\u0026lt;/em\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Can you tell me which object is \u0026lt;code\u0026gt;nil\u0026lt;/code\u0026gt;?\u0026lt;/strong\u0026gt; \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;You can\u0026apos;t!\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;The full code would be: \u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-swift s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-swift\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;ViewController\u0026lt;/span\u0026gt;: \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;UIViewController\u0026lt;/span\u0026gt; {\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;override\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;func\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;viewDidLoad\u0026lt;/span\u0026gt;() {\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;super\u0026lt;/span\u0026gt;.viewDidLoad()\n\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; c1 \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;NormalContact\u0026lt;/span\u0026gt;()\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;let\u0026lt;/span\u0026gt; c3 \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;BadContact\u0026lt;/span\u0026gt;()\n\n        c1.address.city \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; c3.address.city \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// compiler hides the truth from you and then you sudden get a crash\u0026lt;/span\u0026gt;\n    }\n}\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;NormalContact\u0026lt;/span\u0026gt; {\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; address : \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;Address\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;Address\u0026lt;/span\u0026gt;(city: \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;defaultCity\u0026quot;\u0026lt;/span\u0026gt;)\n}\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;BadContact\u0026lt;/span\u0026gt; {\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; address : \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;Address\u0026lt;/span\u0026gt;!\n}\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Address\u0026lt;/span\u0026gt; {\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; city : \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;String\u0026lt;/span\u0026gt;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;Long story short by using \u0026lt;code\u0026gt;var address : Address!\u0026lt;/code\u0026gt; you\u0026apos;re \u0026lt;strong\u0026gt;hiding\u0026lt;/strong\u0026gt; the possibility that a variable can be \u0026lt;code\u0026gt;nil\u0026lt;/code\u0026gt; from other readers. And when it crashes you\u0026apos;re like \u0026quot;what the hell?! my \u0026lt;code\u0026gt;address\u0026lt;/code\u0026gt; isn\u0026apos;t an optional, so why am I crashing?!. \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Hence it\u0026apos;s better to write as such: \u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-swift s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-swift\u0026quot;\u0026gt;c1.address.city \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; c2.address\u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;!\u0026lt;/span\u0026gt;.city  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// ERROR:  Fatal error: Unexpectedly found nil while unwrapping an Optional value \u0026lt;/span\u0026gt;\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Can you now tell me which object it is that was \u0026lt;code\u0026gt;nil\u0026lt;/code\u0026gt;?\u0026lt;/strong\u0026gt; \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;This time the code has been made more clear to you. You can rationalize and think that likely it\u0026apos;s the \u0026lt;code\u0026gt;address\u0026lt;/code\u0026gt; parameter that was forcefully unwrapped. \u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;The full code would be :\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-swift s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-swift\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;ViewController\u0026lt;/span\u0026gt;: \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;UIViewController\u0026lt;/span\u0026gt; {\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;override\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;func\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;viewDidLoad\u0026lt;/span\u0026gt;() {\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;super\u0026lt;/span\u0026gt;.viewDidLoad()\n\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; c1 \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;NormalContact\u0026lt;/span\u0026gt;()\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;let\u0026lt;/span\u0026gt; c2 \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;GoodContact\u0026lt;/span\u0026gt;()\n\n        c1.address.city \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; c2.address\u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;!\u0026lt;/span\u0026gt;.city\n        c1.address.city \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; c2.address\u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;?\u0026lt;/span\u0026gt;.city \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// not compile-able. No deceiving by the compiler\u0026lt;/span\u0026gt;\n        c1.address.city \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; c2.address.city \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// not compile-able. No deceiving by the compiler\u0026lt;/span\u0026gt;\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;let\u0026lt;/span\u0026gt; city \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; c2.address\u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;?\u0026lt;/span\u0026gt;.city {  \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;// safest approach. But that\u0026apos;s not what I\u0026apos;m talking about here. \u0026lt;/span\u0026gt;\n            c1.address.city \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; city\n        }\n\n    }\n}\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;NormalContact\u0026lt;/span\u0026gt; {\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; address : \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;Address\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;Address\u0026lt;/span\u0026gt;(city: \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;defaultCity\u0026quot;\u0026lt;/span\u0026gt;)\n}\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;GoodContact\u0026lt;/span\u0026gt; {\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; address : \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;Address\u0026lt;/span\u0026gt;?\n}\n\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;struct\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;Address\u0026lt;/span\u0026gt; {\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; city : \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;String\u0026lt;/span\u0026gt;\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;The errors \u0026lt;code\u0026gt;EXC_BAD_INSTRUCTION\u0026lt;/code\u0026gt; and \u0026lt;code\u0026gt;fatal error: unexpectedly found nil while implicitly unwrapping an Optional value\u0026lt;/code\u0026gt; appears the most when you have declared an \u0026lt;code\u0026gt;@IBOutlet\u0026lt;/code\u0026gt;, but not connected to the \u0026lt;strong\u0026gt;storyboard\u0026lt;/strong\u0026gt;.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;You should also learn about how \u0026lt;strong\u0026gt;Optionals\u0026lt;/strong\u0026gt; work, mentioned in other answers, but this is the only time that mostly appears to me.\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;If you get this error in CollectionView try to create CustomCell file and Custom xib also.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;add this code in ViewDidLoad() at mainVC.\u0026lt;/p\u0026gt;\n\n\u0026lt;pre class=\u0026quot;lang-swift s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-swift\u0026quot;\u0026gt;    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;let\u0026lt;/span\u0026gt; nib \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;UINib\u0026lt;/span\u0026gt;(nibName: \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;CustomnibName\u0026quot;\u0026lt;/span\u0026gt;, bundle: \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;nil\u0026lt;/span\u0026gt;)\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;self\u0026lt;/span\u0026gt;.collectionView.register(nib, forCellWithReuseIdentifier: \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;cell\u0026quot;\u0026lt;/span\u0026gt;)\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;Xcode 12 iOS 14 Swift 5\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;My problem was the type of navigation as I called the vie controller direct without instantiating the storyboard so that\u0026apos;s mean data was not set yet from the storyboard.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;When you navigate, navigate with\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-swift s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-swift\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;let\u0026lt;/span\u0026gt; homeViewController \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;UIStoryboard\u0026lt;/span\u0026gt;(name: \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;Main\u0026quot;\u0026lt;/span\u0026gt;, bundle: \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;nil\u0026lt;/span\u0026gt;).instantiateViewController(withIdentifier: \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;home\u0026quot;\u0026lt;/span\u0026gt;) \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;as?\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;HomeEventsViewController\u0026lt;/span\u0026gt;\n    homeViewController\u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;?\u0026lt;/span\u0026gt;.modalTransitionStyle \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; .crossDissolve\n    homeViewController\u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;?\u0026lt;/span\u0026gt;.modalPresentationStyle \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt; .fullScreen\n    view.present(homeViewController \u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;??\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;UIViewController\u0026lt;/span\u0026gt;(), animated: \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;true\u0026lt;/span\u0026gt;, completion: \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;nil\u0026lt;/span\u0026gt;)\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n\u0026lt;p\u0026gt;Hopefully it works :-)\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;I came across this error while making a segue from a table view controller to a view controller because I had forgotten to specify the custom class name for the view controller in the main storyboard.\u0026lt;/p\u0026gt;\n\n\u0026lt;p\u0026gt;Something simple that is worth checking if all else looks ok\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;If my case I set a variable to UILabel which was nil.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;So I fixed it and thereafter it did not throw the error.\u0026lt;/p\u0026gt;\n\u0026lt;p\u0026gt;Code snippet\u0026lt;/p\u0026gt;\n\u0026lt;pre class=\u0026quot;lang-swift s-code-block\u0026quot;\u0026gt;\u0026lt;code class=\u0026quot;hljs language-swift\u0026quot;\u0026gt;\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;ResultViewController\u0026lt;/span\u0026gt;: \u0026lt;span class=\u0026quot;hljs-title class_\u0026quot;\u0026gt;UIViewController\u0026lt;/span\u0026gt; {\n\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;@IBOutlet\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;weak\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; resultLabel: \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;UILabel\u0026lt;/span\u0026gt;!\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; bmiValue\u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;\u0026quot;\u0026lt;/span\u0026gt;\n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;override\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;func\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;viewDidLoad\u0026lt;/span\u0026gt;() {\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;super\u0026lt;/span\u0026gt;.viewDidLoad()\n        \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;print\u0026lt;/span\u0026gt;(bmiValue)\n        resultLabel.text\u0026lt;span class=\u0026quot;hljs-operator\u0026quot;\u0026gt;=\u0026lt;/span\u0026gt;bmiValue \u0026lt;span class=\u0026quot;hljs-comment\u0026quot;\u0026gt;//where bmiValue was nil , I fixed it and problem was solved\u0026lt;/span\u0026gt;\n\n    }\n    \n    \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;@IBAction\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;func\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-title function_\u0026quot;\u0026gt;recaculateBmi\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;_\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-params\u0026quot;\u0026gt;sender\u0026lt;/span\u0026gt;: \u0026lt;span class=\u0026quot;hljs-type\u0026quot;\u0026gt;UIButton\u0026lt;/span\u0026gt;) {\n        \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;self\u0026lt;/span\u0026gt;.dismiss(animated: \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;true\u0026lt;/span\u0026gt;, completion: \u0026lt;span class=\u0026quot;hljs-literal\u0026quot;\u0026gt;nil\u0026lt;/span\u0026gt;)\n    }\n    \n\n}\n\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\n    ","\n\u0026lt;p\u0026gt;in simple words\nyou are trying to use a value of the optional variable which is nil.\nquick fix could be use \u0026lt;code\u0026gt;guard\u0026lt;/code\u0026gt; or \u0026lt;code\u0026gt;if let\u0026lt;/code\u0026gt; instead of force unwrap like putting \u0026lt;code\u0026gt;!\u0026lt;/code\u0026gt; at the end of variable\u0026lt;/p\u0026gt;\n    ","\n\u0026lt;p\u0026gt;This is because you are trying to use a value which can possible be nil, but you decided you don\u0026apos;t want to have to check it, but instead assume its set when you uses it and define it as !, there are different philosophies on use of variable set as force unwrap, some people are against there use at all, I personal think they are ok for things that will crash all the time and are simple to reason about, usually references to resource, like outlets to xib files, or uses of images with you app that are part of your assets, if these are not set up properly, you app is going to crash straight away, for a very obvious reason, you can get into difficult when the order of objects being created can be uncertain, and trying to reason solutions to this can be difficult, it usually means a bad design as even it you make them optional, calls to you optional variable may not ever be executed, some projects can demand use of force unwraps for security reasons, things like banking apps, because they want the app to crash rather then continue to work in an unplanned way.\u0026lt;/p\u0026gt;\n    "],"id":98,"title":"What does \"Fatal error: Unexpectedly found nil while unwrapping an Optional value\" mean?","content":"\n                \n\u0026lt;p\u0026gt;My Swift program is crashing with \u0026lt;code\u0026gt;EXC_BAD_INSTRUCTION\u0026lt;/code\u0026gt; and one of the following similar errors. What does this error mean, and how do I fix it?\u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;Fatal error: Unexpectedly found nil while unwrapping an Optional value  \u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;em\u0026gt;or\u0026lt;/em\u0026gt;\u0026lt;/p\u0026gt;\n\n\u0026lt;blockquote\u0026gt;\n  \u0026lt;p\u0026gt;Fatal error: Unexpectedly found nil while implicitly unwrapping an Optional value  \u0026lt;/p\u0026gt;\n\u0026lt;/blockquote\u0026gt;\n\n\u0026lt;hr\u0026gt;\n\n\u0026lt;p\u0026gt;\u0026lt;sup\u0026gt;This post is intended to collect answers to \u0026quot;unexpectedly found nil\u0026quot; issues, so that they are not scattered and hard to find. Feel free to add your own answer or \u0026lt;a href=\u0026quot;https://stackoverflow.com/posts/32170457/edit\u0026quot;\u0026gt;edit\u0026lt;/a\u0026gt; the existing wiki answer.\u0026lt;/sup\u0026gt;\u0026lt;/p\u0026gt;\n    ","slug":"what-does-\"fatal-error:-unexpectedly-found-nil-while-unwrapping-an-optional-value\"-mean-1657384593944","postType":"QUESTION","createdAt":"2022-07-09T16:36:33.000Z","updatedAt":"2022-07-09T16:36:33.000Z","tags":[],"relatedQuestions":[]},"randomQuestions":[{"title":"Most efficient method to groupby on an array of objects","slug":"most-efficient-method-to-groupby-on-an-array-of-objects-1657387580538"},{"title":"Reference - What does this regex mean?","slug":"reference-what-does-this-regex-mean-1657384291445"},{"title":"Why does my JavaScript code receive a \"No 'Access-Control-Allow-Origin' header is present on the requested resource\" error, while Postman does not?","slug":"why-does-my-javascript-code-receive-a-\"no-'access-control-allow-origin'-header-is-present-on-the-requested-resource\"-error-while-postman-does-not-1657384636363"},{"title":"Convert one date format into another in PHP","slug":"convert-one-date-format-into-another-in-php-1657384566234"},{"title":"Using LIMIT within GROUP BY to get N results per group?","slug":"using-limit-within-group-by-to-get-n-results-per-group-1657388324167"},{"title":"scanf() leaves the newline character in the buffer","slug":"scanf()-leaves-the-newline-character-in-the-buffer-1657384699202"},{"title":"What special characters must be escaped in regular expressions?","slug":"what-special-characters-must-be-escaped-in-regular-expressions-1657387465381"},{"title":"Example images for code and mark-up Q\u0026As [closed]","slug":"example-images-for-code-and-mark-up-qandas-closed-1657387690222"},{"title":"How can I vertically align elements in a div?","slug":"how-can-i-vertically-align-elements-in-a-div-1657385504431"},{"title":"Split array into chunks","slug":"split-array-into-chunks-1657387896420"},{"title":".prop() vs .attr()","slug":".prop()-vs-.attr()-1657384898328"},{"title":"What is the purpose of the var keyword and when should I use it (or omit it)?","slug":"what-is-the-purpose-of-the-var-keyword-and-when-should-i-use-it-(or-omit-it)-1657387525538"},{"title":"Iterating over dictionaries using 'for' loops","slug":"iterating-over-dictionaries-using-'for'-loops-1657388334481"},{"title":"How do I use shell variables in an awk script?","slug":"how-do-i-use-shell-variables-in-an-awk-script-1657387754261"},{"title":"What's the meaning of \"=\u003e\" (an arrow formed from equals \u0026 greater than) in JavaScript?","slug":"what's-the-meaning-of-\"greater\"-(an-arrow-formed-from-equals-and-greater-than)-in-javascript-1657387977118"},{"title":"Why does my function that calls an API or launches a coroutine return an empty or null value?","slug":"why-does-my-function-that-calls-an-api-or-launches-a-coroutine-return-an-empty-or-null-value-1657388483820"},{"title":"Get selected value in dropdown list using JavaScript","slug":"get-selected-value-in-dropdown-list-using-javascript-1657387631638"},{"title":"Why does \"a == x or y or z\" always evaluate to True?","slug":"why-does-\"a-x-or-y-or-z\"-always-evaluate-to-true-1657384855216"},{"title":"Providing white space in a Swing GUI","slug":"providing-white-space-in-a-swing-gui-1657384734588"},{"title":"How can I get useful error messages in PHP?","slug":"how-can-i-get-useful-error-messages-in-php-1657384609065"}]},"__N_SSG":true},"page":"/questions/[slug]","query":{"slug":"what-does-\"fatal-error:-unexpectedly-found-nil-while-unwrapping-an-optional-value\"-mean-1657384593944"},"buildId":"6ctJfCympFH_chh5mjicD","isFallback":false,"gsp":true,"locale":"en","locales":["en"],"defaultLocale":"en","scriptLoader":[]}</script></body></html>